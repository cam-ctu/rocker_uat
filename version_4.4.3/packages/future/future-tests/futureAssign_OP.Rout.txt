
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:21:10.272] plan(): Setting new future strategy stack:
[10:21:10.272] List of future strategies:
[10:21:10.272] 1. sequential:
[10:21:10.272]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.272]    - tweaked: FALSE
[10:21:10.272]    - call: future::plan("sequential")
[10:21:10.287] plan(): nbrOfWorkers() = 1
> 
> message("*** %<-% ...")
*** %<-% ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("*** %%<-%% with %s futures ...", sQuote(strategy)))
+     plan(strategy)
+ 
+     rm(list = intersect(c("x", "y"), ls()))
+ 
+     message("** Future evaluation without globals")
+     v1 %<-% { x <- 1 }
+     stopifnot(!exists("x", inherits = FALSE), identical(v1, 1))
+ 
+     message("** Future evaluation with globals")
+     a <- 2
+     v2 %<-% { x <- a }
+     stopifnot(!exists("x", inherits = FALSE), identical(v2, a))
+ 
+     message("** Future evaluation with errors")
+     v3 %<-% {
+       x <- 3
+       stop("Woops!")
+       x
+     }
+     stopifnot(!exists("x", inherits = FALSE))
+     res <- tryCatch(identical(v3, 3), error = identity)
+     stopifnot(inherits(res, "error"))
+ 
+ 
+     y <- listenv::listenv()
+     for (ii in 1:3) {
+       y[[ii]] %<-% {
+         if (ii %% 2 == 0) stop("Woops!")
+         ii
+       }
+     }
+     res <- tryCatch(as.list(y), error = identity)
+     stopifnot(inherits(res, "error"))
+     z <- y[c(1, 3)]
+     z <- unlist(z)
+     stopifnot(all(z == c(1, 3)))
+     res <- tryCatch(y[[2]], error = identity)
+     stopifnot(inherits(res, "error"))
+     res <- tryCatch(y[1:2], error = identity)
+     stopifnot(inherits(res, "error"))
+ 
+ 
+     message("** Future evaluation with a poor-man's \"progress bar\"")
+     v4 %<-% {
+       cat("Processing: ")
+       for (ii in 1:10) { cat(".") }
+       cat(" [100%]\n")
+       4
+     }
+ 
+ 
+     message("** Collecting results")
+     printf("v1 = %s\n", v1)
+     stopifnot(v1 == 1)
+ 
+     printf("v2 = %s\n", v2)
+     stopifnot(v2 == a)
+ 
+     stopifnot(tryCatch({
+       printf("v3 = %s\n", v3)
+     }, error = function(ex) {
+       printf("v3: <%s> (as expect)\n", class(ex)[1])
+       TRUE
+     }))
+ 
+     printf("v4 = %s\n", v4)
+     #stopifnot(v4 == 4)
+ 
+ 
+     message("** Left-to-right and right-to-left future assignments")
+     c %<-% 1
+     printf("c = %s\n", c)
+     1 %->% d
+     printf("d = %s\n", d)
+     stopifnot(d == c)
+ 
+ 
+ 
+     message("** Nested future assignments")
+     a %<-% {
+       b <- 1
+       c %<-% 2
+       3 -> d
+       4 %->% e
+       b + c + d + e
+     }
+     printf("a = %s\n", a)
+     stopifnot(a == 10)
+ 
+     { a + 1 } %->% b
+     printf("b = %s\n", b)
+     stopifnot(b == a + 1)
+ 
+     message(sprintf("*** %%<-%% with %s futures ... DONE", sQuote(strategy)))
+   } # for (strategy in ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** %<-% with ‘sequential’ futures ...
[10:21:10.349] plan(): Setting new future strategy stack:
[10:21:10.349] List of future strategies:
[10:21:10.349] 1. sequential:
[10:21:10.349]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.349]    - tweaked: FALSE
[10:21:10.349]    - call: plan(strategy)
[10:21:10.362] plan(): nbrOfWorkers() = 1
** Future evaluation without globals
[10:21:10.363] getGlobalsAndPackages() ...
[10:21:10.363] Searching for globals...
[10:21:10.367] - globals found: [2] ‘{’, ‘<-’
[10:21:10.367] Searching for globals ... DONE
[10:21:10.368] Resolving globals: FALSE
[10:21:10.368] 
[10:21:10.368] 
[10:21:10.368] getGlobalsAndPackages() ... DONE
[10:21:10.369] run() for ‘Future’ ...
[10:21:10.369] - state: ‘created’
[10:21:10.369] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:10.369] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:10.370] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:10.370]   - Field: ‘label’
[10:21:10.370]   - Field: ‘local’
[10:21:10.370]   - Field: ‘owner’
[10:21:10.370]   - Field: ‘envir’
[10:21:10.370]   - Field: ‘packages’
[10:21:10.370]   - Field: ‘gc’
[10:21:10.370]   - Field: ‘conditions’
[10:21:10.370]   - Field: ‘expr’
[10:21:10.370]   - Field: ‘uuid’
[10:21:10.370]   - Field: ‘seed’
[10:21:10.371]   - Field: ‘version’
[10:21:10.371]   - Field: ‘result’
[10:21:10.371]   - Field: ‘asynchronous’
[10:21:10.371]   - Field: ‘calls’
[10:21:10.371]   - Field: ‘globals’
[10:21:10.371]   - Field: ‘stdout’
[10:21:10.371]   - Field: ‘earlySignal’
[10:21:10.371]   - Field: ‘lazy’
[10:21:10.371]   - Field: ‘state’
[10:21:10.371] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:10.371] - Launch lazy future ...
[10:21:10.372] Packages needed by the future expression (n = 0): <none>
[10:21:10.372] Packages needed by future strategies (n = 0): <none>
[10:21:10.373] {
[10:21:10.373]     {
[10:21:10.373]         {
[10:21:10.373]             ...future.startTime <- base::Sys.time()
[10:21:10.373]             {
[10:21:10.373]                 {
[10:21:10.373]                   {
[10:21:10.373]                     base::local({
[10:21:10.373]                       has_future <- base::requireNamespace("future", 
[10:21:10.373]                         quietly = TRUE)
[10:21:10.373]                       if (has_future) {
[10:21:10.373]                         ns <- base::getNamespace("future")
[10:21:10.373]                         version <- ns[[".package"]][["version"]]
[10:21:10.373]                         if (is.null(version)) 
[10:21:10.373]                           version <- utils::packageVersion("future")
[10:21:10.373]                       }
[10:21:10.373]                       else {
[10:21:10.373]                         version <- NULL
[10:21:10.373]                       }
[10:21:10.373]                       if (!has_future || version < "1.8.0") {
[10:21:10.373]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.373]                           "", base::R.version$version.string), 
[10:21:10.373]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:10.373]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.373]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.373]                             "release", "version")], collapse = " "), 
[10:21:10.373]                           hostname = base::Sys.info()[["nodename"]])
[10:21:10.373]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.373]                           info)
[10:21:10.373]                         info <- base::paste(info, collapse = "; ")
[10:21:10.373]                         if (!has_future) {
[10:21:10.373]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.373]                             info)
[10:21:10.373]                         }
[10:21:10.373]                         else {
[10:21:10.373]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.373]                             info, version)
[10:21:10.373]                         }
[10:21:10.373]                         base::stop(msg)
[10:21:10.373]                       }
[10:21:10.373]                     })
[10:21:10.373]                   }
[10:21:10.373]                   ...future.strategy.old <- future::plan("list")
[10:21:10.373]                   options(future.plan = NULL)
[10:21:10.373]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.373]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.373]                 }
[10:21:10.373]                 ...future.workdir <- getwd()
[10:21:10.373]             }
[10:21:10.373]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.373]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.373]         }
[10:21:10.373]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.373]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.373]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.373]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.373]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.373]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.373]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.373]             base::names(...future.oldOptions))
[10:21:10.373]     }
[10:21:10.373]     if (FALSE) {
[10:21:10.373]     }
[10:21:10.373]     else {
[10:21:10.373]         if (TRUE) {
[10:21:10.373]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.373]                 open = "w")
[10:21:10.373]         }
[10:21:10.373]         else {
[10:21:10.373]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.373]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.373]         }
[10:21:10.373]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.373]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.373]             base::sink(type = "output", split = FALSE)
[10:21:10.373]             base::close(...future.stdout)
[10:21:10.373]         }, add = TRUE)
[10:21:10.373]     }
[10:21:10.373]     ...future.frame <- base::sys.nframe()
[10:21:10.373]     ...future.conditions <- base::list()
[10:21:10.373]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.373]     if (FALSE) {
[10:21:10.373]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.373]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.373]     }
[10:21:10.373]     ...future.result <- base::tryCatch({
[10:21:10.373]         base::withCallingHandlers({
[10:21:10.373]             ...future.value <- base::withVisible(base::local({
[10:21:10.373]                 x <- 1
[10:21:10.373]             }))
[10:21:10.373]             future::FutureResult(value = ...future.value$value, 
[10:21:10.373]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.373]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.373]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.373]                     ...future.globalenv.names))
[10:21:10.373]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.373]         }, condition = base::local({
[10:21:10.373]             c <- base::c
[10:21:10.373]             inherits <- base::inherits
[10:21:10.373]             invokeRestart <- base::invokeRestart
[10:21:10.373]             length <- base::length
[10:21:10.373]             list <- base::list
[10:21:10.373]             seq.int <- base::seq.int
[10:21:10.373]             signalCondition <- base::signalCondition
[10:21:10.373]             sys.calls <- base::sys.calls
[10:21:10.373]             `[[` <- base::`[[`
[10:21:10.373]             `+` <- base::`+`
[10:21:10.373]             `<<-` <- base::`<<-`
[10:21:10.373]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.373]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.373]                   3L)]
[10:21:10.373]             }
[10:21:10.373]             function(cond) {
[10:21:10.373]                 is_error <- inherits(cond, "error")
[10:21:10.373]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.373]                   NULL)
[10:21:10.373]                 if (is_error) {
[10:21:10.373]                   sessionInformation <- function() {
[10:21:10.373]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.373]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.373]                       search = base::search(), system = base::Sys.info())
[10:21:10.373]                   }
[10:21:10.373]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.373]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.373]                     cond$call), session = sessionInformation(), 
[10:21:10.373]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.373]                   signalCondition(cond)
[10:21:10.373]                 }
[10:21:10.373]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.373]                 "immediateCondition"))) {
[10:21:10.373]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.373]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.373]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.373]                   if (TRUE && !signal) {
[10:21:10.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.373]                     {
[10:21:10.373]                       inherits <- base::inherits
[10:21:10.373]                       invokeRestart <- base::invokeRestart
[10:21:10.373]                       is.null <- base::is.null
[10:21:10.373]                       muffled <- FALSE
[10:21:10.373]                       if (inherits(cond, "message")) {
[10:21:10.373]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.373]                         if (muffled) 
[10:21:10.373]                           invokeRestart("muffleMessage")
[10:21:10.373]                       }
[10:21:10.373]                       else if (inherits(cond, "warning")) {
[10:21:10.373]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.373]                         if (muffled) 
[10:21:10.373]                           invokeRestart("muffleWarning")
[10:21:10.373]                       }
[10:21:10.373]                       else if (inherits(cond, "condition")) {
[10:21:10.373]                         if (!is.null(pattern)) {
[10:21:10.373]                           computeRestarts <- base::computeRestarts
[10:21:10.373]                           grepl <- base::grepl
[10:21:10.373]                           restarts <- computeRestarts(cond)
[10:21:10.373]                           for (restart in restarts) {
[10:21:10.373]                             name <- restart$name
[10:21:10.373]                             if (is.null(name)) 
[10:21:10.373]                               next
[10:21:10.373]                             if (!grepl(pattern, name)) 
[10:21:10.373]                               next
[10:21:10.373]                             invokeRestart(restart)
[10:21:10.373]                             muffled <- TRUE
[10:21:10.373]                             break
[10:21:10.373]                           }
[10:21:10.373]                         }
[10:21:10.373]                       }
[10:21:10.373]                       invisible(muffled)
[10:21:10.373]                     }
[10:21:10.373]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.373]                   }
[10:21:10.373]                 }
[10:21:10.373]                 else {
[10:21:10.373]                   if (TRUE) {
[10:21:10.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.373]                     {
[10:21:10.373]                       inherits <- base::inherits
[10:21:10.373]                       invokeRestart <- base::invokeRestart
[10:21:10.373]                       is.null <- base::is.null
[10:21:10.373]                       muffled <- FALSE
[10:21:10.373]                       if (inherits(cond, "message")) {
[10:21:10.373]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.373]                         if (muffled) 
[10:21:10.373]                           invokeRestart("muffleMessage")
[10:21:10.373]                       }
[10:21:10.373]                       else if (inherits(cond, "warning")) {
[10:21:10.373]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.373]                         if (muffled) 
[10:21:10.373]                           invokeRestart("muffleWarning")
[10:21:10.373]                       }
[10:21:10.373]                       else if (inherits(cond, "condition")) {
[10:21:10.373]                         if (!is.null(pattern)) {
[10:21:10.373]                           computeRestarts <- base::computeRestarts
[10:21:10.373]                           grepl <- base::grepl
[10:21:10.373]                           restarts <- computeRestarts(cond)
[10:21:10.373]                           for (restart in restarts) {
[10:21:10.373]                             name <- restart$name
[10:21:10.373]                             if (is.null(name)) 
[10:21:10.373]                               next
[10:21:10.373]                             if (!grepl(pattern, name)) 
[10:21:10.373]                               next
[10:21:10.373]                             invokeRestart(restart)
[10:21:10.373]                             muffled <- TRUE
[10:21:10.373]                             break
[10:21:10.373]                           }
[10:21:10.373]                         }
[10:21:10.373]                       }
[10:21:10.373]                       invisible(muffled)
[10:21:10.373]                     }
[10:21:10.373]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.373]                   }
[10:21:10.373]                 }
[10:21:10.373]             }
[10:21:10.373]         }))
[10:21:10.373]     }, error = function(ex) {
[10:21:10.373]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.373]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.373]                 ...future.rng), started = ...future.startTime, 
[10:21:10.373]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.373]             version = "1.8"), class = "FutureResult")
[10:21:10.373]     }, finally = {
[10:21:10.373]         if (!identical(...future.workdir, getwd())) 
[10:21:10.373]             setwd(...future.workdir)
[10:21:10.373]         {
[10:21:10.373]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.373]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.373]             }
[10:21:10.373]             base::options(...future.oldOptions)
[10:21:10.373]             if (.Platform$OS.type == "windows") {
[10:21:10.373]                 old_names <- names(...future.oldEnvVars)
[10:21:10.373]                 envs <- base::Sys.getenv()
[10:21:10.373]                 names <- names(envs)
[10:21:10.373]                 common <- intersect(names, old_names)
[10:21:10.373]                 added <- setdiff(names, old_names)
[10:21:10.373]                 removed <- setdiff(old_names, names)
[10:21:10.373]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.373]                   envs[common]]
[10:21:10.373]                 NAMES <- toupper(changed)
[10:21:10.373]                 args <- list()
[10:21:10.373]                 for (kk in seq_along(NAMES)) {
[10:21:10.373]                   name <- changed[[kk]]
[10:21:10.373]                   NAME <- NAMES[[kk]]
[10:21:10.373]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.373]                     next
[10:21:10.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.373]                 }
[10:21:10.373]                 NAMES <- toupper(added)
[10:21:10.373]                 for (kk in seq_along(NAMES)) {
[10:21:10.373]                   name <- added[[kk]]
[10:21:10.373]                   NAME <- NAMES[[kk]]
[10:21:10.373]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.373]                     next
[10:21:10.373]                   args[[name]] <- ""
[10:21:10.373]                 }
[10:21:10.373]                 NAMES <- toupper(removed)
[10:21:10.373]                 for (kk in seq_along(NAMES)) {
[10:21:10.373]                   name <- removed[[kk]]
[10:21:10.373]                   NAME <- NAMES[[kk]]
[10:21:10.373]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.373]                     next
[10:21:10.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.373]                 }
[10:21:10.373]                 if (length(args) > 0) 
[10:21:10.373]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.373]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.373]             }
[10:21:10.373]             else {
[10:21:10.373]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.373]             }
[10:21:10.373]             {
[10:21:10.373]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.373]                   0L) {
[10:21:10.373]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.373]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.373]                   base::options(opts)
[10:21:10.373]                 }
[10:21:10.373]                 {
[10:21:10.373]                   {
[10:21:10.373]                     NULL
[10:21:10.373]                     RNGkind("Mersenne-Twister")
[10:21:10.373]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:10.373]                       inherits = FALSE)
[10:21:10.373]                   }
[10:21:10.373]                   options(future.plan = NULL)
[10:21:10.373]                   if (is.na(NA_character_)) 
[10:21:10.373]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.373]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.373]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.373]                     .init = FALSE)
[10:21:10.373]                 }
[10:21:10.373]             }
[10:21:10.373]         }
[10:21:10.373]     })
[10:21:10.373]     if (TRUE) {
[10:21:10.373]         base::sink(type = "output", split = FALSE)
[10:21:10.373]         if (TRUE) {
[10:21:10.373]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.373]         }
[10:21:10.373]         else {
[10:21:10.373]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.373]         }
[10:21:10.373]         base::close(...future.stdout)
[10:21:10.373]         ...future.stdout <- NULL
[10:21:10.373]     }
[10:21:10.373]     ...future.result$conditions <- ...future.conditions
[10:21:10.373]     ...future.result$finished <- base::Sys.time()
[10:21:10.373]     ...future.result
[10:21:10.373] }
[10:21:10.375] plan(): Setting new future strategy stack:
[10:21:10.375] List of future strategies:
[10:21:10.375] 1. sequential:
[10:21:10.375]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.375]    - tweaked: FALSE
[10:21:10.375]    - call: NULL
[10:21:10.375] plan(): nbrOfWorkers() = 1
[10:21:10.377] plan(): Setting new future strategy stack:
[10:21:10.377] List of future strategies:
[10:21:10.377] 1. sequential:
[10:21:10.377]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.377]    - tweaked: FALSE
[10:21:10.377]    - call: plan(strategy)
[10:21:10.377] plan(): nbrOfWorkers() = 1
[10:21:10.377] SequentialFuture started (and completed)
[10:21:10.378] - Launch lazy future ... done
[10:21:10.378] run() for ‘SequentialFuture’ ... done
** Future evaluation with globals
[10:21:10.379] getGlobalsAndPackages() ...
[10:21:10.379] Searching for globals...
[10:21:10.379] - globals found: [3] ‘{’, ‘<-’, ‘a’
[10:21:10.380] Searching for globals ... DONE
[10:21:10.380] Resolving globals: FALSE
[10:21:10.380] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:10.381] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:10.381] - globals: [1] ‘a’
[10:21:10.381] 
[10:21:10.381] getGlobalsAndPackages() ... DONE
[10:21:10.381] run() for ‘Future’ ...
[10:21:10.381] - state: ‘created’
[10:21:10.382] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:10.382] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:10.382] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:10.382]   - Field: ‘label’
[10:21:10.382]   - Field: ‘local’
[10:21:10.382]   - Field: ‘owner’
[10:21:10.382]   - Field: ‘envir’
[10:21:10.382]   - Field: ‘packages’
[10:21:10.382]   - Field: ‘gc’
[10:21:10.383]   - Field: ‘conditions’
[10:21:10.383]   - Field: ‘expr’
[10:21:10.383]   - Field: ‘uuid’
[10:21:10.383]   - Field: ‘seed’
[10:21:10.383]   - Field: ‘version’
[10:21:10.383]   - Field: ‘result’
[10:21:10.383]   - Field: ‘asynchronous’
[10:21:10.383]   - Field: ‘calls’
[10:21:10.383]   - Field: ‘globals’
[10:21:10.383]   - Field: ‘stdout’
[10:21:10.383]   - Field: ‘earlySignal’
[10:21:10.383]   - Field: ‘lazy’
[10:21:10.383]   - Field: ‘state’
[10:21:10.384] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:10.384] - Launch lazy future ...
[10:21:10.384] Packages needed by the future expression (n = 0): <none>
[10:21:10.384] Packages needed by future strategies (n = 0): <none>
[10:21:10.384] {
[10:21:10.384]     {
[10:21:10.384]         {
[10:21:10.384]             ...future.startTime <- base::Sys.time()
[10:21:10.384]             {
[10:21:10.384]                 {
[10:21:10.384]                   {
[10:21:10.384]                     base::local({
[10:21:10.384]                       has_future <- base::requireNamespace("future", 
[10:21:10.384]                         quietly = TRUE)
[10:21:10.384]                       if (has_future) {
[10:21:10.384]                         ns <- base::getNamespace("future")
[10:21:10.384]                         version <- ns[[".package"]][["version"]]
[10:21:10.384]                         if (is.null(version)) 
[10:21:10.384]                           version <- utils::packageVersion("future")
[10:21:10.384]                       }
[10:21:10.384]                       else {
[10:21:10.384]                         version <- NULL
[10:21:10.384]                       }
[10:21:10.384]                       if (!has_future || version < "1.8.0") {
[10:21:10.384]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.384]                           "", base::R.version$version.string), 
[10:21:10.384]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:10.384]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.384]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.384]                             "release", "version")], collapse = " "), 
[10:21:10.384]                           hostname = base::Sys.info()[["nodename"]])
[10:21:10.384]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.384]                           info)
[10:21:10.384]                         info <- base::paste(info, collapse = "; ")
[10:21:10.384]                         if (!has_future) {
[10:21:10.384]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.384]                             info)
[10:21:10.384]                         }
[10:21:10.384]                         else {
[10:21:10.384]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.384]                             info, version)
[10:21:10.384]                         }
[10:21:10.384]                         base::stop(msg)
[10:21:10.384]                       }
[10:21:10.384]                     })
[10:21:10.384]                   }
[10:21:10.384]                   ...future.strategy.old <- future::plan("list")
[10:21:10.384]                   options(future.plan = NULL)
[10:21:10.384]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.384]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.384]                 }
[10:21:10.384]                 ...future.workdir <- getwd()
[10:21:10.384]             }
[10:21:10.384]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.384]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.384]         }
[10:21:10.384]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.384]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.384]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.384]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.384]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.384]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.384]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.384]             base::names(...future.oldOptions))
[10:21:10.384]     }
[10:21:10.384]     if (FALSE) {
[10:21:10.384]     }
[10:21:10.384]     else {
[10:21:10.384]         if (TRUE) {
[10:21:10.384]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.384]                 open = "w")
[10:21:10.384]         }
[10:21:10.384]         else {
[10:21:10.384]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.384]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.384]         }
[10:21:10.384]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.384]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.384]             base::sink(type = "output", split = FALSE)
[10:21:10.384]             base::close(...future.stdout)
[10:21:10.384]         }, add = TRUE)
[10:21:10.384]     }
[10:21:10.384]     ...future.frame <- base::sys.nframe()
[10:21:10.384]     ...future.conditions <- base::list()
[10:21:10.384]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.384]     if (FALSE) {
[10:21:10.384]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.384]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.384]     }
[10:21:10.384]     ...future.result <- base::tryCatch({
[10:21:10.384]         base::withCallingHandlers({
[10:21:10.384]             ...future.value <- base::withVisible(base::local({
[10:21:10.384]                 x <- a
[10:21:10.384]             }))
[10:21:10.384]             future::FutureResult(value = ...future.value$value, 
[10:21:10.384]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.384]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.384]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.384]                     ...future.globalenv.names))
[10:21:10.384]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.384]         }, condition = base::local({
[10:21:10.384]             c <- base::c
[10:21:10.384]             inherits <- base::inherits
[10:21:10.384]             invokeRestart <- base::invokeRestart
[10:21:10.384]             length <- base::length
[10:21:10.384]             list <- base::list
[10:21:10.384]             seq.int <- base::seq.int
[10:21:10.384]             signalCondition <- base::signalCondition
[10:21:10.384]             sys.calls <- base::sys.calls
[10:21:10.384]             `[[` <- base::`[[`
[10:21:10.384]             `+` <- base::`+`
[10:21:10.384]             `<<-` <- base::`<<-`
[10:21:10.384]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.384]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.384]                   3L)]
[10:21:10.384]             }
[10:21:10.384]             function(cond) {
[10:21:10.384]                 is_error <- inherits(cond, "error")
[10:21:10.384]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.384]                   NULL)
[10:21:10.384]                 if (is_error) {
[10:21:10.384]                   sessionInformation <- function() {
[10:21:10.384]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.384]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.384]                       search = base::search(), system = base::Sys.info())
[10:21:10.384]                   }
[10:21:10.384]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.384]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.384]                     cond$call), session = sessionInformation(), 
[10:21:10.384]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.384]                   signalCondition(cond)
[10:21:10.384]                 }
[10:21:10.384]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.384]                 "immediateCondition"))) {
[10:21:10.384]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.384]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.384]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.384]                   if (TRUE && !signal) {
[10:21:10.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.384]                     {
[10:21:10.384]                       inherits <- base::inherits
[10:21:10.384]                       invokeRestart <- base::invokeRestart
[10:21:10.384]                       is.null <- base::is.null
[10:21:10.384]                       muffled <- FALSE
[10:21:10.384]                       if (inherits(cond, "message")) {
[10:21:10.384]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.384]                         if (muffled) 
[10:21:10.384]                           invokeRestart("muffleMessage")
[10:21:10.384]                       }
[10:21:10.384]                       else if (inherits(cond, "warning")) {
[10:21:10.384]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.384]                         if (muffled) 
[10:21:10.384]                           invokeRestart("muffleWarning")
[10:21:10.384]                       }
[10:21:10.384]                       else if (inherits(cond, "condition")) {
[10:21:10.384]                         if (!is.null(pattern)) {
[10:21:10.384]                           computeRestarts <- base::computeRestarts
[10:21:10.384]                           grepl <- base::grepl
[10:21:10.384]                           restarts <- computeRestarts(cond)
[10:21:10.384]                           for (restart in restarts) {
[10:21:10.384]                             name <- restart$name
[10:21:10.384]                             if (is.null(name)) 
[10:21:10.384]                               next
[10:21:10.384]                             if (!grepl(pattern, name)) 
[10:21:10.384]                               next
[10:21:10.384]                             invokeRestart(restart)
[10:21:10.384]                             muffled <- TRUE
[10:21:10.384]                             break
[10:21:10.384]                           }
[10:21:10.384]                         }
[10:21:10.384]                       }
[10:21:10.384]                       invisible(muffled)
[10:21:10.384]                     }
[10:21:10.384]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.384]                   }
[10:21:10.384]                 }
[10:21:10.384]                 else {
[10:21:10.384]                   if (TRUE) {
[10:21:10.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.384]                     {
[10:21:10.384]                       inherits <- base::inherits
[10:21:10.384]                       invokeRestart <- base::invokeRestart
[10:21:10.384]                       is.null <- base::is.null
[10:21:10.384]                       muffled <- FALSE
[10:21:10.384]                       if (inherits(cond, "message")) {
[10:21:10.384]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.384]                         if (muffled) 
[10:21:10.384]                           invokeRestart("muffleMessage")
[10:21:10.384]                       }
[10:21:10.384]                       else if (inherits(cond, "warning")) {
[10:21:10.384]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.384]                         if (muffled) 
[10:21:10.384]                           invokeRestart("muffleWarning")
[10:21:10.384]                       }
[10:21:10.384]                       else if (inherits(cond, "condition")) {
[10:21:10.384]                         if (!is.null(pattern)) {
[10:21:10.384]                           computeRestarts <- base::computeRestarts
[10:21:10.384]                           grepl <- base::grepl
[10:21:10.384]                           restarts <- computeRestarts(cond)
[10:21:10.384]                           for (restart in restarts) {
[10:21:10.384]                             name <- restart$name
[10:21:10.384]                             if (is.null(name)) 
[10:21:10.384]                               next
[10:21:10.384]                             if (!grepl(pattern, name)) 
[10:21:10.384]                               next
[10:21:10.384]                             invokeRestart(restart)
[10:21:10.384]                             muffled <- TRUE
[10:21:10.384]                             break
[10:21:10.384]                           }
[10:21:10.384]                         }
[10:21:10.384]                       }
[10:21:10.384]                       invisible(muffled)
[10:21:10.384]                     }
[10:21:10.384]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.384]                   }
[10:21:10.384]                 }
[10:21:10.384]             }
[10:21:10.384]         }))
[10:21:10.384]     }, error = function(ex) {
[10:21:10.384]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.384]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.384]                 ...future.rng), started = ...future.startTime, 
[10:21:10.384]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.384]             version = "1.8"), class = "FutureResult")
[10:21:10.384]     }, finally = {
[10:21:10.384]         if (!identical(...future.workdir, getwd())) 
[10:21:10.384]             setwd(...future.workdir)
[10:21:10.384]         {
[10:21:10.384]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.384]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.384]             }
[10:21:10.384]             base::options(...future.oldOptions)
[10:21:10.384]             if (.Platform$OS.type == "windows") {
[10:21:10.384]                 old_names <- names(...future.oldEnvVars)
[10:21:10.384]                 envs <- base::Sys.getenv()
[10:21:10.384]                 names <- names(envs)
[10:21:10.384]                 common <- intersect(names, old_names)
[10:21:10.384]                 added <- setdiff(names, old_names)
[10:21:10.384]                 removed <- setdiff(old_names, names)
[10:21:10.384]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.384]                   envs[common]]
[10:21:10.384]                 NAMES <- toupper(changed)
[10:21:10.384]                 args <- list()
[10:21:10.384]                 for (kk in seq_along(NAMES)) {
[10:21:10.384]                   name <- changed[[kk]]
[10:21:10.384]                   NAME <- NAMES[[kk]]
[10:21:10.384]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.384]                     next
[10:21:10.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.384]                 }
[10:21:10.384]                 NAMES <- toupper(added)
[10:21:10.384]                 for (kk in seq_along(NAMES)) {
[10:21:10.384]                   name <- added[[kk]]
[10:21:10.384]                   NAME <- NAMES[[kk]]
[10:21:10.384]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.384]                     next
[10:21:10.384]                   args[[name]] <- ""
[10:21:10.384]                 }
[10:21:10.384]                 NAMES <- toupper(removed)
[10:21:10.384]                 for (kk in seq_along(NAMES)) {
[10:21:10.384]                   name <- removed[[kk]]
[10:21:10.384]                   NAME <- NAMES[[kk]]
[10:21:10.384]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.384]                     next
[10:21:10.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.384]                 }
[10:21:10.384]                 if (length(args) > 0) 
[10:21:10.384]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.384]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.384]             }
[10:21:10.384]             else {
[10:21:10.384]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.384]             }
[10:21:10.384]             {
[10:21:10.384]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.384]                   0L) {
[10:21:10.384]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.384]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.384]                   base::options(opts)
[10:21:10.384]                 }
[10:21:10.384]                 {
[10:21:10.384]                   {
[10:21:10.384]                     NULL
[10:21:10.384]                     RNGkind("Mersenne-Twister")
[10:21:10.384]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:10.384]                       inherits = FALSE)
[10:21:10.384]                   }
[10:21:10.384]                   options(future.plan = NULL)
[10:21:10.384]                   if (is.na(NA_character_)) 
[10:21:10.384]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.384]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.384]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.384]                     .init = FALSE)
[10:21:10.384]                 }
[10:21:10.384]             }
[10:21:10.384]         }
[10:21:10.384]     })
[10:21:10.384]     if (TRUE) {
[10:21:10.384]         base::sink(type = "output", split = FALSE)
[10:21:10.384]         if (TRUE) {
[10:21:10.384]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.384]         }
[10:21:10.384]         else {
[10:21:10.384]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.384]         }
[10:21:10.384]         base::close(...future.stdout)
[10:21:10.384]         ...future.stdout <- NULL
[10:21:10.384]     }
[10:21:10.384]     ...future.result$conditions <- ...future.conditions
[10:21:10.384]     ...future.result$finished <- base::Sys.time()
[10:21:10.384]     ...future.result
[10:21:10.384] }
[10:21:10.386] assign_globals() ...
[10:21:10.386] List of 1
[10:21:10.386]  $ a: num 2
[10:21:10.386]  - attr(*, "where")=List of 1
[10:21:10.386]   ..$ a:<environment: R_EmptyEnv> 
[10:21:10.386]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:10.386]  - attr(*, "resolved")= logi FALSE
[10:21:10.386]  - attr(*, "total_size")= num 39
[10:21:10.386]  - attr(*, "already-done")= logi TRUE
[10:21:10.393] - copied ‘a’ to environment
[10:21:10.394] assign_globals() ... done
[10:21:10.394] plan(): Setting new future strategy stack:
[10:21:10.394] List of future strategies:
[10:21:10.394] 1. sequential:
[10:21:10.394]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.394]    - tweaked: FALSE
[10:21:10.394]    - call: NULL
[10:21:10.394] plan(): nbrOfWorkers() = 1
[10:21:10.395] plan(): Setting new future strategy stack:
[10:21:10.395] List of future strategies:
[10:21:10.395] 1. sequential:
[10:21:10.395]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.395]    - tweaked: FALSE
[10:21:10.395]    - call: plan(strategy)
[10:21:10.396] plan(): nbrOfWorkers() = 1
[10:21:10.396] SequentialFuture started (and completed)
[10:21:10.396] - Launch lazy future ... done
[10:21:10.396] run() for ‘SequentialFuture’ ... done
** Future evaluation with errors
[10:21:10.396] getGlobalsAndPackages() ...
[10:21:10.397] Searching for globals...
[10:21:10.400] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[10:21:10.400] Searching for globals ... DONE
[10:21:10.400] Resolving globals: FALSE
[10:21:10.400] 
[10:21:10.400] 
[10:21:10.401] getGlobalsAndPackages() ... DONE
[10:21:10.401] run() for ‘Future’ ...
[10:21:10.401] - state: ‘created’
[10:21:10.401] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:10.401] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:10.401] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:10.401]   - Field: ‘label’
[10:21:10.402]   - Field: ‘local’
[10:21:10.402]   - Field: ‘owner’
[10:21:10.402]   - Field: ‘envir’
[10:21:10.402]   - Field: ‘packages’
[10:21:10.402]   - Field: ‘gc’
[10:21:10.402]   - Field: ‘conditions’
[10:21:10.402]   - Field: ‘expr’
[10:21:10.402]   - Field: ‘uuid’
[10:21:10.402]   - Field: ‘seed’
[10:21:10.402]   - Field: ‘version’
[10:21:10.402]   - Field: ‘result’
[10:21:10.402]   - Field: ‘asynchronous’
[10:21:10.403]   - Field: ‘calls’
[10:21:10.403]   - Field: ‘globals’
[10:21:10.403]   - Field: ‘stdout’
[10:21:10.403]   - Field: ‘earlySignal’
[10:21:10.403]   - Field: ‘lazy’
[10:21:10.403]   - Field: ‘state’
[10:21:10.403] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:10.403] - Launch lazy future ...
[10:21:10.403] Packages needed by the future expression (n = 0): <none>
[10:21:10.403] Packages needed by future strategies (n = 0): <none>
[10:21:10.404] {
[10:21:10.404]     {
[10:21:10.404]         {
[10:21:10.404]             ...future.startTime <- base::Sys.time()
[10:21:10.404]             {
[10:21:10.404]                 {
[10:21:10.404]                   {
[10:21:10.404]                     base::local({
[10:21:10.404]                       has_future <- base::requireNamespace("future", 
[10:21:10.404]                         quietly = TRUE)
[10:21:10.404]                       if (has_future) {
[10:21:10.404]                         ns <- base::getNamespace("future")
[10:21:10.404]                         version <- ns[[".package"]][["version"]]
[10:21:10.404]                         if (is.null(version)) 
[10:21:10.404]                           version <- utils::packageVersion("future")
[10:21:10.404]                       }
[10:21:10.404]                       else {
[10:21:10.404]                         version <- NULL
[10:21:10.404]                       }
[10:21:10.404]                       if (!has_future || version < "1.8.0") {
[10:21:10.404]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.404]                           "", base::R.version$version.string), 
[10:21:10.404]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:10.404]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.404]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.404]                             "release", "version")], collapse = " "), 
[10:21:10.404]                           hostname = base::Sys.info()[["nodename"]])
[10:21:10.404]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.404]                           info)
[10:21:10.404]                         info <- base::paste(info, collapse = "; ")
[10:21:10.404]                         if (!has_future) {
[10:21:10.404]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.404]                             info)
[10:21:10.404]                         }
[10:21:10.404]                         else {
[10:21:10.404]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.404]                             info, version)
[10:21:10.404]                         }
[10:21:10.404]                         base::stop(msg)
[10:21:10.404]                       }
[10:21:10.404]                     })
[10:21:10.404]                   }
[10:21:10.404]                   ...future.strategy.old <- future::plan("list")
[10:21:10.404]                   options(future.plan = NULL)
[10:21:10.404]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.404]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.404]                 }
[10:21:10.404]                 ...future.workdir <- getwd()
[10:21:10.404]             }
[10:21:10.404]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.404]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.404]         }
[10:21:10.404]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.404]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.404]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.404]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.404]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.404]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.404]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.404]             base::names(...future.oldOptions))
[10:21:10.404]     }
[10:21:10.404]     if (FALSE) {
[10:21:10.404]     }
[10:21:10.404]     else {
[10:21:10.404]         if (TRUE) {
[10:21:10.404]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.404]                 open = "w")
[10:21:10.404]         }
[10:21:10.404]         else {
[10:21:10.404]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.404]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.404]         }
[10:21:10.404]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.404]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.404]             base::sink(type = "output", split = FALSE)
[10:21:10.404]             base::close(...future.stdout)
[10:21:10.404]         }, add = TRUE)
[10:21:10.404]     }
[10:21:10.404]     ...future.frame <- base::sys.nframe()
[10:21:10.404]     ...future.conditions <- base::list()
[10:21:10.404]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.404]     if (FALSE) {
[10:21:10.404]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.404]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.404]     }
[10:21:10.404]     ...future.result <- base::tryCatch({
[10:21:10.404]         base::withCallingHandlers({
[10:21:10.404]             ...future.value <- base::withVisible(base::local({
[10:21:10.404]                 x <- 3
[10:21:10.404]                 stop("Woops!")
[10:21:10.404]                 x
[10:21:10.404]             }))
[10:21:10.404]             future::FutureResult(value = ...future.value$value, 
[10:21:10.404]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.404]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.404]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.404]                     ...future.globalenv.names))
[10:21:10.404]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.404]         }, condition = base::local({
[10:21:10.404]             c <- base::c
[10:21:10.404]             inherits <- base::inherits
[10:21:10.404]             invokeRestart <- base::invokeRestart
[10:21:10.404]             length <- base::length
[10:21:10.404]             list <- base::list
[10:21:10.404]             seq.int <- base::seq.int
[10:21:10.404]             signalCondition <- base::signalCondition
[10:21:10.404]             sys.calls <- base::sys.calls
[10:21:10.404]             `[[` <- base::`[[`
[10:21:10.404]             `+` <- base::`+`
[10:21:10.404]             `<<-` <- base::`<<-`
[10:21:10.404]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.404]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.404]                   3L)]
[10:21:10.404]             }
[10:21:10.404]             function(cond) {
[10:21:10.404]                 is_error <- inherits(cond, "error")
[10:21:10.404]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.404]                   NULL)
[10:21:10.404]                 if (is_error) {
[10:21:10.404]                   sessionInformation <- function() {
[10:21:10.404]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.404]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.404]                       search = base::search(), system = base::Sys.info())
[10:21:10.404]                   }
[10:21:10.404]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.404]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.404]                     cond$call), session = sessionInformation(), 
[10:21:10.404]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.404]                   signalCondition(cond)
[10:21:10.404]                 }
[10:21:10.404]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.404]                 "immediateCondition"))) {
[10:21:10.404]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.404]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.404]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.404]                   if (TRUE && !signal) {
[10:21:10.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.404]                     {
[10:21:10.404]                       inherits <- base::inherits
[10:21:10.404]                       invokeRestart <- base::invokeRestart
[10:21:10.404]                       is.null <- base::is.null
[10:21:10.404]                       muffled <- FALSE
[10:21:10.404]                       if (inherits(cond, "message")) {
[10:21:10.404]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.404]                         if (muffled) 
[10:21:10.404]                           invokeRestart("muffleMessage")
[10:21:10.404]                       }
[10:21:10.404]                       else if (inherits(cond, "warning")) {
[10:21:10.404]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.404]                         if (muffled) 
[10:21:10.404]                           invokeRestart("muffleWarning")
[10:21:10.404]                       }
[10:21:10.404]                       else if (inherits(cond, "condition")) {
[10:21:10.404]                         if (!is.null(pattern)) {
[10:21:10.404]                           computeRestarts <- base::computeRestarts
[10:21:10.404]                           grepl <- base::grepl
[10:21:10.404]                           restarts <- computeRestarts(cond)
[10:21:10.404]                           for (restart in restarts) {
[10:21:10.404]                             name <- restart$name
[10:21:10.404]                             if (is.null(name)) 
[10:21:10.404]                               next
[10:21:10.404]                             if (!grepl(pattern, name)) 
[10:21:10.404]                               next
[10:21:10.404]                             invokeRestart(restart)
[10:21:10.404]                             muffled <- TRUE
[10:21:10.404]                             break
[10:21:10.404]                           }
[10:21:10.404]                         }
[10:21:10.404]                       }
[10:21:10.404]                       invisible(muffled)
[10:21:10.404]                     }
[10:21:10.404]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.404]                   }
[10:21:10.404]                 }
[10:21:10.404]                 else {
[10:21:10.404]                   if (TRUE) {
[10:21:10.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.404]                     {
[10:21:10.404]                       inherits <- base::inherits
[10:21:10.404]                       invokeRestart <- base::invokeRestart
[10:21:10.404]                       is.null <- base::is.null
[10:21:10.404]                       muffled <- FALSE
[10:21:10.404]                       if (inherits(cond, "message")) {
[10:21:10.404]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.404]                         if (muffled) 
[10:21:10.404]                           invokeRestart("muffleMessage")
[10:21:10.404]                       }
[10:21:10.404]                       else if (inherits(cond, "warning")) {
[10:21:10.404]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.404]                         if (muffled) 
[10:21:10.404]                           invokeRestart("muffleWarning")
[10:21:10.404]                       }
[10:21:10.404]                       else if (inherits(cond, "condition")) {
[10:21:10.404]                         if (!is.null(pattern)) {
[10:21:10.404]                           computeRestarts <- base::computeRestarts
[10:21:10.404]                           grepl <- base::grepl
[10:21:10.404]                           restarts <- computeRestarts(cond)
[10:21:10.404]                           for (restart in restarts) {
[10:21:10.404]                             name <- restart$name
[10:21:10.404]                             if (is.null(name)) 
[10:21:10.404]                               next
[10:21:10.404]                             if (!grepl(pattern, name)) 
[10:21:10.404]                               next
[10:21:10.404]                             invokeRestart(restart)
[10:21:10.404]                             muffled <- TRUE
[10:21:10.404]                             break
[10:21:10.404]                           }
[10:21:10.404]                         }
[10:21:10.404]                       }
[10:21:10.404]                       invisible(muffled)
[10:21:10.404]                     }
[10:21:10.404]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.404]                   }
[10:21:10.404]                 }
[10:21:10.404]             }
[10:21:10.404]         }))
[10:21:10.404]     }, error = function(ex) {
[10:21:10.404]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.404]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.404]                 ...future.rng), started = ...future.startTime, 
[10:21:10.404]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.404]             version = "1.8"), class = "FutureResult")
[10:21:10.404]     }, finally = {
[10:21:10.404]         if (!identical(...future.workdir, getwd())) 
[10:21:10.404]             setwd(...future.workdir)
[10:21:10.404]         {
[10:21:10.404]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.404]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.404]             }
[10:21:10.404]             base::options(...future.oldOptions)
[10:21:10.404]             if (.Platform$OS.type == "windows") {
[10:21:10.404]                 old_names <- names(...future.oldEnvVars)
[10:21:10.404]                 envs <- base::Sys.getenv()
[10:21:10.404]                 names <- names(envs)
[10:21:10.404]                 common <- intersect(names, old_names)
[10:21:10.404]                 added <- setdiff(names, old_names)
[10:21:10.404]                 removed <- setdiff(old_names, names)
[10:21:10.404]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.404]                   envs[common]]
[10:21:10.404]                 NAMES <- toupper(changed)
[10:21:10.404]                 args <- list()
[10:21:10.404]                 for (kk in seq_along(NAMES)) {
[10:21:10.404]                   name <- changed[[kk]]
[10:21:10.404]                   NAME <- NAMES[[kk]]
[10:21:10.404]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.404]                     next
[10:21:10.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.404]                 }
[10:21:10.404]                 NAMES <- toupper(added)
[10:21:10.404]                 for (kk in seq_along(NAMES)) {
[10:21:10.404]                   name <- added[[kk]]
[10:21:10.404]                   NAME <- NAMES[[kk]]
[10:21:10.404]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.404]                     next
[10:21:10.404]                   args[[name]] <- ""
[10:21:10.404]                 }
[10:21:10.404]                 NAMES <- toupper(removed)
[10:21:10.404]                 for (kk in seq_along(NAMES)) {
[10:21:10.404]                   name <- removed[[kk]]
[10:21:10.404]                   NAME <- NAMES[[kk]]
[10:21:10.404]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.404]                     next
[10:21:10.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.404]                 }
[10:21:10.404]                 if (length(args) > 0) 
[10:21:10.404]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.404]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.404]             }
[10:21:10.404]             else {
[10:21:10.404]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.404]             }
[10:21:10.404]             {
[10:21:10.404]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.404]                   0L) {
[10:21:10.404]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.404]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.404]                   base::options(opts)
[10:21:10.404]                 }
[10:21:10.404]                 {
[10:21:10.404]                   {
[10:21:10.404]                     NULL
[10:21:10.404]                     RNGkind("Mersenne-Twister")
[10:21:10.404]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:10.404]                       inherits = FALSE)
[10:21:10.404]                   }
[10:21:10.404]                   options(future.plan = NULL)
[10:21:10.404]                   if (is.na(NA_character_)) 
[10:21:10.404]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.404]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.404]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.404]                     .init = FALSE)
[10:21:10.404]                 }
[10:21:10.404]             }
[10:21:10.404]         }
[10:21:10.404]     })
[10:21:10.404]     if (TRUE) {
[10:21:10.404]         base::sink(type = "output", split = FALSE)
[10:21:10.404]         if (TRUE) {
[10:21:10.404]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.404]         }
[10:21:10.404]         else {
[10:21:10.404]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.404]         }
[10:21:10.404]         base::close(...future.stdout)
[10:21:10.404]         ...future.stdout <- NULL
[10:21:10.404]     }
[10:21:10.404]     ...future.result$conditions <- ...future.conditions
[10:21:10.404]     ...future.result$finished <- base::Sys.time()
[10:21:10.404]     ...future.result
[10:21:10.404] }
[10:21:10.406] plan(): Setting new future strategy stack:
[10:21:10.406] List of future strategies:
[10:21:10.406] 1. sequential:
[10:21:10.406]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.406]    - tweaked: FALSE
[10:21:10.406]    - call: NULL
[10:21:10.406] plan(): nbrOfWorkers() = 1
[10:21:10.407] plan(): Setting new future strategy stack:
[10:21:10.407] List of future strategies:
[10:21:10.407] 1. sequential:
[10:21:10.407]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.407]    - tweaked: FALSE
[10:21:10.407]    - call: plan(strategy)
[10:21:10.408] plan(): nbrOfWorkers() = 1
[10:21:10.408] SequentialFuture started (and completed)
[10:21:10.408] signalConditions() ...
[10:21:10.408]  - include = ‘immediateCondition’
[10:21:10.408]  - exclude = 
[10:21:10.408]  - resignal = FALSE
[10:21:10.408]  - Number of conditions: 1
[10:21:10.408] signalConditions() ... done
[10:21:10.408] - Launch lazy future ... done
[10:21:10.408] run() for ‘SequentialFuture’ ... done
[10:21:10.409] signalConditions() ...
[10:21:10.409]  - include = ‘immediateCondition’
[10:21:10.409]  - exclude = 
[10:21:10.409]  - resignal = FALSE
[10:21:10.409]  - Number of conditions: 1
[10:21:10.409] signalConditions() ... done
[10:21:10.409] Future state: ‘finished’
[10:21:10.409] signalConditions() ...
[10:21:10.409]  - include = ‘condition’
[10:21:10.409]  - exclude = ‘immediateCondition’
[10:21:10.409]  - resignal = TRUE
[10:21:10.410]  - Number of conditions: 1
[10:21:10.410]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:10.410] signalConditions() ... done
[10:21:10.410] getGlobalsAndPackages() ...
[10:21:10.410] Searching for globals...
[10:21:10.412] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[10:21:10.412] Searching for globals ... DONE
[10:21:10.412] Resolving globals: FALSE
[10:21:10.413] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:10.413] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:10.413] - globals: [1] ‘ii’
[10:21:10.413] 
[10:21:10.413] getGlobalsAndPackages() ... DONE
[10:21:10.414] run() for ‘Future’ ...
[10:21:10.414] - state: ‘created’
[10:21:10.414] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:10.414] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:10.414] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:10.414]   - Field: ‘label’
[10:21:10.414]   - Field: ‘local’
[10:21:10.414]   - Field: ‘owner’
[10:21:10.415]   - Field: ‘envir’
[10:21:10.415]   - Field: ‘packages’
[10:21:10.415]   - Field: ‘gc’
[10:21:10.415]   - Field: ‘conditions’
[10:21:10.415]   - Field: ‘expr’
[10:21:10.415]   - Field: ‘uuid’
[10:21:10.415]   - Field: ‘seed’
[10:21:10.415]   - Field: ‘version’
[10:21:10.415]   - Field: ‘result’
[10:21:10.415]   - Field: ‘asynchronous’
[10:21:10.415]   - Field: ‘calls’
[10:21:10.415]   - Field: ‘globals’
[10:21:10.416]   - Field: ‘stdout’
[10:21:10.416]   - Field: ‘earlySignal’
[10:21:10.416]   - Field: ‘lazy’
[10:21:10.416]   - Field: ‘state’
[10:21:10.416] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:10.416] - Launch lazy future ...
[10:21:10.416] Packages needed by the future expression (n = 0): <none>
[10:21:10.416] Packages needed by future strategies (n = 0): <none>
[10:21:10.417] {
[10:21:10.417]     {
[10:21:10.417]         {
[10:21:10.417]             ...future.startTime <- base::Sys.time()
[10:21:10.417]             {
[10:21:10.417]                 {
[10:21:10.417]                   {
[10:21:10.417]                     base::local({
[10:21:10.417]                       has_future <- base::requireNamespace("future", 
[10:21:10.417]                         quietly = TRUE)
[10:21:10.417]                       if (has_future) {
[10:21:10.417]                         ns <- base::getNamespace("future")
[10:21:10.417]                         version <- ns[[".package"]][["version"]]
[10:21:10.417]                         if (is.null(version)) 
[10:21:10.417]                           version <- utils::packageVersion("future")
[10:21:10.417]                       }
[10:21:10.417]                       else {
[10:21:10.417]                         version <- NULL
[10:21:10.417]                       }
[10:21:10.417]                       if (!has_future || version < "1.8.0") {
[10:21:10.417]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.417]                           "", base::R.version$version.string), 
[10:21:10.417]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:10.417]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.417]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.417]                             "release", "version")], collapse = " "), 
[10:21:10.417]                           hostname = base::Sys.info()[["nodename"]])
[10:21:10.417]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.417]                           info)
[10:21:10.417]                         info <- base::paste(info, collapse = "; ")
[10:21:10.417]                         if (!has_future) {
[10:21:10.417]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.417]                             info)
[10:21:10.417]                         }
[10:21:10.417]                         else {
[10:21:10.417]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.417]                             info, version)
[10:21:10.417]                         }
[10:21:10.417]                         base::stop(msg)
[10:21:10.417]                       }
[10:21:10.417]                     })
[10:21:10.417]                   }
[10:21:10.417]                   ...future.strategy.old <- future::plan("list")
[10:21:10.417]                   options(future.plan = NULL)
[10:21:10.417]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.417]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.417]                 }
[10:21:10.417]                 ...future.workdir <- getwd()
[10:21:10.417]             }
[10:21:10.417]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.417]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.417]         }
[10:21:10.417]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.417]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.417]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.417]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.417]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.417]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.417]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.417]             base::names(...future.oldOptions))
[10:21:10.417]     }
[10:21:10.417]     if (FALSE) {
[10:21:10.417]     }
[10:21:10.417]     else {
[10:21:10.417]         if (TRUE) {
[10:21:10.417]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.417]                 open = "w")
[10:21:10.417]         }
[10:21:10.417]         else {
[10:21:10.417]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.417]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.417]         }
[10:21:10.417]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.417]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.417]             base::sink(type = "output", split = FALSE)
[10:21:10.417]             base::close(...future.stdout)
[10:21:10.417]         }, add = TRUE)
[10:21:10.417]     }
[10:21:10.417]     ...future.frame <- base::sys.nframe()
[10:21:10.417]     ...future.conditions <- base::list()
[10:21:10.417]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.417]     if (FALSE) {
[10:21:10.417]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.417]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.417]     }
[10:21:10.417]     ...future.result <- base::tryCatch({
[10:21:10.417]         base::withCallingHandlers({
[10:21:10.417]             ...future.value <- base::withVisible(base::local({
[10:21:10.417]                 if (ii%%2 == 0) 
[10:21:10.417]                   stop("Woops!")
[10:21:10.417]                 ii
[10:21:10.417]             }))
[10:21:10.417]             future::FutureResult(value = ...future.value$value, 
[10:21:10.417]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.417]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.417]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.417]                     ...future.globalenv.names))
[10:21:10.417]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.417]         }, condition = base::local({
[10:21:10.417]             c <- base::c
[10:21:10.417]             inherits <- base::inherits
[10:21:10.417]             invokeRestart <- base::invokeRestart
[10:21:10.417]             length <- base::length
[10:21:10.417]             list <- base::list
[10:21:10.417]             seq.int <- base::seq.int
[10:21:10.417]             signalCondition <- base::signalCondition
[10:21:10.417]             sys.calls <- base::sys.calls
[10:21:10.417]             `[[` <- base::`[[`
[10:21:10.417]             `+` <- base::`+`
[10:21:10.417]             `<<-` <- base::`<<-`
[10:21:10.417]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.417]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.417]                   3L)]
[10:21:10.417]             }
[10:21:10.417]             function(cond) {
[10:21:10.417]                 is_error <- inherits(cond, "error")
[10:21:10.417]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.417]                   NULL)
[10:21:10.417]                 if (is_error) {
[10:21:10.417]                   sessionInformation <- function() {
[10:21:10.417]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.417]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.417]                       search = base::search(), system = base::Sys.info())
[10:21:10.417]                   }
[10:21:10.417]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.417]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.417]                     cond$call), session = sessionInformation(), 
[10:21:10.417]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.417]                   signalCondition(cond)
[10:21:10.417]                 }
[10:21:10.417]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.417]                 "immediateCondition"))) {
[10:21:10.417]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.417]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.417]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.417]                   if (TRUE && !signal) {
[10:21:10.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.417]                     {
[10:21:10.417]                       inherits <- base::inherits
[10:21:10.417]                       invokeRestart <- base::invokeRestart
[10:21:10.417]                       is.null <- base::is.null
[10:21:10.417]                       muffled <- FALSE
[10:21:10.417]                       if (inherits(cond, "message")) {
[10:21:10.417]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.417]                         if (muffled) 
[10:21:10.417]                           invokeRestart("muffleMessage")
[10:21:10.417]                       }
[10:21:10.417]                       else if (inherits(cond, "warning")) {
[10:21:10.417]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.417]                         if (muffled) 
[10:21:10.417]                           invokeRestart("muffleWarning")
[10:21:10.417]                       }
[10:21:10.417]                       else if (inherits(cond, "condition")) {
[10:21:10.417]                         if (!is.null(pattern)) {
[10:21:10.417]                           computeRestarts <- base::computeRestarts
[10:21:10.417]                           grepl <- base::grepl
[10:21:10.417]                           restarts <- computeRestarts(cond)
[10:21:10.417]                           for (restart in restarts) {
[10:21:10.417]                             name <- restart$name
[10:21:10.417]                             if (is.null(name)) 
[10:21:10.417]                               next
[10:21:10.417]                             if (!grepl(pattern, name)) 
[10:21:10.417]                               next
[10:21:10.417]                             invokeRestart(restart)
[10:21:10.417]                             muffled <- TRUE
[10:21:10.417]                             break
[10:21:10.417]                           }
[10:21:10.417]                         }
[10:21:10.417]                       }
[10:21:10.417]                       invisible(muffled)
[10:21:10.417]                     }
[10:21:10.417]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.417]                   }
[10:21:10.417]                 }
[10:21:10.417]                 else {
[10:21:10.417]                   if (TRUE) {
[10:21:10.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.417]                     {
[10:21:10.417]                       inherits <- base::inherits
[10:21:10.417]                       invokeRestart <- base::invokeRestart
[10:21:10.417]                       is.null <- base::is.null
[10:21:10.417]                       muffled <- FALSE
[10:21:10.417]                       if (inherits(cond, "message")) {
[10:21:10.417]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.417]                         if (muffled) 
[10:21:10.417]                           invokeRestart("muffleMessage")
[10:21:10.417]                       }
[10:21:10.417]                       else if (inherits(cond, "warning")) {
[10:21:10.417]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.417]                         if (muffled) 
[10:21:10.417]                           invokeRestart("muffleWarning")
[10:21:10.417]                       }
[10:21:10.417]                       else if (inherits(cond, "condition")) {
[10:21:10.417]                         if (!is.null(pattern)) {
[10:21:10.417]                           computeRestarts <- base::computeRestarts
[10:21:10.417]                           grepl <- base::grepl
[10:21:10.417]                           restarts <- computeRestarts(cond)
[10:21:10.417]                           for (restart in restarts) {
[10:21:10.417]                             name <- restart$name
[10:21:10.417]                             if (is.null(name)) 
[10:21:10.417]                               next
[10:21:10.417]                             if (!grepl(pattern, name)) 
[10:21:10.417]                               next
[10:21:10.417]                             invokeRestart(restart)
[10:21:10.417]                             muffled <- TRUE
[10:21:10.417]                             break
[10:21:10.417]                           }
[10:21:10.417]                         }
[10:21:10.417]                       }
[10:21:10.417]                       invisible(muffled)
[10:21:10.417]                     }
[10:21:10.417]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.417]                   }
[10:21:10.417]                 }
[10:21:10.417]             }
[10:21:10.417]         }))
[10:21:10.417]     }, error = function(ex) {
[10:21:10.417]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.417]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.417]                 ...future.rng), started = ...future.startTime, 
[10:21:10.417]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.417]             version = "1.8"), class = "FutureResult")
[10:21:10.417]     }, finally = {
[10:21:10.417]         if (!identical(...future.workdir, getwd())) 
[10:21:10.417]             setwd(...future.workdir)
[10:21:10.417]         {
[10:21:10.417]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.417]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.417]             }
[10:21:10.417]             base::options(...future.oldOptions)
[10:21:10.417]             if (.Platform$OS.type == "windows") {
[10:21:10.417]                 old_names <- names(...future.oldEnvVars)
[10:21:10.417]                 envs <- base::Sys.getenv()
[10:21:10.417]                 names <- names(envs)
[10:21:10.417]                 common <- intersect(names, old_names)
[10:21:10.417]                 added <- setdiff(names, old_names)
[10:21:10.417]                 removed <- setdiff(old_names, names)
[10:21:10.417]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.417]                   envs[common]]
[10:21:10.417]                 NAMES <- toupper(changed)
[10:21:10.417]                 args <- list()
[10:21:10.417]                 for (kk in seq_along(NAMES)) {
[10:21:10.417]                   name <- changed[[kk]]
[10:21:10.417]                   NAME <- NAMES[[kk]]
[10:21:10.417]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.417]                     next
[10:21:10.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.417]                 }
[10:21:10.417]                 NAMES <- toupper(added)
[10:21:10.417]                 for (kk in seq_along(NAMES)) {
[10:21:10.417]                   name <- added[[kk]]
[10:21:10.417]                   NAME <- NAMES[[kk]]
[10:21:10.417]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.417]                     next
[10:21:10.417]                   args[[name]] <- ""
[10:21:10.417]                 }
[10:21:10.417]                 NAMES <- toupper(removed)
[10:21:10.417]                 for (kk in seq_along(NAMES)) {
[10:21:10.417]                   name <- removed[[kk]]
[10:21:10.417]                   NAME <- NAMES[[kk]]
[10:21:10.417]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.417]                     next
[10:21:10.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.417]                 }
[10:21:10.417]                 if (length(args) > 0) 
[10:21:10.417]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.417]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.417]             }
[10:21:10.417]             else {
[10:21:10.417]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.417]             }
[10:21:10.417]             {
[10:21:10.417]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.417]                   0L) {
[10:21:10.417]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.417]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.417]                   base::options(opts)
[10:21:10.417]                 }
[10:21:10.417]                 {
[10:21:10.417]                   {
[10:21:10.417]                     NULL
[10:21:10.417]                     RNGkind("Mersenne-Twister")
[10:21:10.417]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:10.417]                       inherits = FALSE)
[10:21:10.417]                   }
[10:21:10.417]                   options(future.plan = NULL)
[10:21:10.417]                   if (is.na(NA_character_)) 
[10:21:10.417]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.417]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.417]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.417]                     .init = FALSE)
[10:21:10.417]                 }
[10:21:10.417]             }
[10:21:10.417]         }
[10:21:10.417]     })
[10:21:10.417]     if (TRUE) {
[10:21:10.417]         base::sink(type = "output", split = FALSE)
[10:21:10.417]         if (TRUE) {
[10:21:10.417]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.417]         }
[10:21:10.417]         else {
[10:21:10.417]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.417]         }
[10:21:10.417]         base::close(...future.stdout)
[10:21:10.417]         ...future.stdout <- NULL
[10:21:10.417]     }
[10:21:10.417]     ...future.result$conditions <- ...future.conditions
[10:21:10.417]     ...future.result$finished <- base::Sys.time()
[10:21:10.417]     ...future.result
[10:21:10.417] }
[10:21:10.418] assign_globals() ...
[10:21:10.418] List of 1
[10:21:10.418]  $ ii: int 1
[10:21:10.418]  - attr(*, "where")=List of 1
[10:21:10.418]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:10.418]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:10.418]  - attr(*, "resolved")= logi FALSE
[10:21:10.418]  - attr(*, "total_size")= num 35
[10:21:10.418]  - attr(*, "already-done")= logi TRUE
[10:21:10.422] - copied ‘ii’ to environment
[10:21:10.422] assign_globals() ... done
[10:21:10.423] plan(): Setting new future strategy stack:
[10:21:10.423] List of future strategies:
[10:21:10.423] 1. sequential:
[10:21:10.423]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.423]    - tweaked: FALSE
[10:21:10.423]    - call: NULL
[10:21:10.423] plan(): nbrOfWorkers() = 1
[10:21:10.424] plan(): Setting new future strategy stack:
[10:21:10.424] List of future strategies:
[10:21:10.424] 1. sequential:
[10:21:10.424]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.424]    - tweaked: FALSE
[10:21:10.424]    - call: plan(strategy)
[10:21:10.424] plan(): nbrOfWorkers() = 1
[10:21:10.425] SequentialFuture started (and completed)
[10:21:10.425] - Launch lazy future ... done
[10:21:10.425] run() for ‘SequentialFuture’ ... done
[10:21:10.425] getGlobalsAndPackages() ...
[10:21:10.425] Searching for globals...
[10:21:10.427] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[10:21:10.427] Searching for globals ... DONE
[10:21:10.427] Resolving globals: FALSE
[10:21:10.427] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:10.428] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:10.428] - globals: [1] ‘ii’
[10:21:10.428] 
[10:21:10.428] getGlobalsAndPackages() ... DONE
[10:21:10.428] run() for ‘Future’ ...
[10:21:10.428] - state: ‘created’
[10:21:10.428] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:10.429] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:10.429] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:10.429]   - Field: ‘label’
[10:21:10.429]   - Field: ‘local’
[10:21:10.429]   - Field: ‘owner’
[10:21:10.429]   - Field: ‘envir’
[10:21:10.429]   - Field: ‘packages’
[10:21:10.429]   - Field: ‘gc’
[10:21:10.429]   - Field: ‘conditions’
[10:21:10.430]   - Field: ‘expr’
[10:21:10.430]   - Field: ‘uuid’
[10:21:10.430]   - Field: ‘seed’
[10:21:10.430]   - Field: ‘version’
[10:21:10.430]   - Field: ‘result’
[10:21:10.430]   - Field: ‘asynchronous’
[10:21:10.430]   - Field: ‘calls’
[10:21:10.430]   - Field: ‘globals’
[10:21:10.430]   - Field: ‘stdout’
[10:21:10.430]   - Field: ‘earlySignal’
[10:21:10.430]   - Field: ‘lazy’
[10:21:10.430]   - Field: ‘state’
[10:21:10.431] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:10.431] - Launch lazy future ...
[10:21:10.431] Packages needed by the future expression (n = 0): <none>
[10:21:10.431] Packages needed by future strategies (n = 0): <none>
[10:21:10.431] {
[10:21:10.431]     {
[10:21:10.431]         {
[10:21:10.431]             ...future.startTime <- base::Sys.time()
[10:21:10.431]             {
[10:21:10.431]                 {
[10:21:10.431]                   {
[10:21:10.431]                     base::local({
[10:21:10.431]                       has_future <- base::requireNamespace("future", 
[10:21:10.431]                         quietly = TRUE)
[10:21:10.431]                       if (has_future) {
[10:21:10.431]                         ns <- base::getNamespace("future")
[10:21:10.431]                         version <- ns[[".package"]][["version"]]
[10:21:10.431]                         if (is.null(version)) 
[10:21:10.431]                           version <- utils::packageVersion("future")
[10:21:10.431]                       }
[10:21:10.431]                       else {
[10:21:10.431]                         version <- NULL
[10:21:10.431]                       }
[10:21:10.431]                       if (!has_future || version < "1.8.0") {
[10:21:10.431]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.431]                           "", base::R.version$version.string), 
[10:21:10.431]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:10.431]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.431]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.431]                             "release", "version")], collapse = " "), 
[10:21:10.431]                           hostname = base::Sys.info()[["nodename"]])
[10:21:10.431]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.431]                           info)
[10:21:10.431]                         info <- base::paste(info, collapse = "; ")
[10:21:10.431]                         if (!has_future) {
[10:21:10.431]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.431]                             info)
[10:21:10.431]                         }
[10:21:10.431]                         else {
[10:21:10.431]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.431]                             info, version)
[10:21:10.431]                         }
[10:21:10.431]                         base::stop(msg)
[10:21:10.431]                       }
[10:21:10.431]                     })
[10:21:10.431]                   }
[10:21:10.431]                   ...future.strategy.old <- future::plan("list")
[10:21:10.431]                   options(future.plan = NULL)
[10:21:10.431]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.431]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.431]                 }
[10:21:10.431]                 ...future.workdir <- getwd()
[10:21:10.431]             }
[10:21:10.431]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.431]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.431]         }
[10:21:10.431]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.431]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.431]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.431]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.431]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.431]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.431]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.431]             base::names(...future.oldOptions))
[10:21:10.431]     }
[10:21:10.431]     if (FALSE) {
[10:21:10.431]     }
[10:21:10.431]     else {
[10:21:10.431]         if (TRUE) {
[10:21:10.431]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.431]                 open = "w")
[10:21:10.431]         }
[10:21:10.431]         else {
[10:21:10.431]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.431]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.431]         }
[10:21:10.431]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.431]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.431]             base::sink(type = "output", split = FALSE)
[10:21:10.431]             base::close(...future.stdout)
[10:21:10.431]         }, add = TRUE)
[10:21:10.431]     }
[10:21:10.431]     ...future.frame <- base::sys.nframe()
[10:21:10.431]     ...future.conditions <- base::list()
[10:21:10.431]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.431]     if (FALSE) {
[10:21:10.431]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.431]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.431]     }
[10:21:10.431]     ...future.result <- base::tryCatch({
[10:21:10.431]         base::withCallingHandlers({
[10:21:10.431]             ...future.value <- base::withVisible(base::local({
[10:21:10.431]                 if (ii%%2 == 0) 
[10:21:10.431]                   stop("Woops!")
[10:21:10.431]                 ii
[10:21:10.431]             }))
[10:21:10.431]             future::FutureResult(value = ...future.value$value, 
[10:21:10.431]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.431]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.431]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.431]                     ...future.globalenv.names))
[10:21:10.431]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.431]         }, condition = base::local({
[10:21:10.431]             c <- base::c
[10:21:10.431]             inherits <- base::inherits
[10:21:10.431]             invokeRestart <- base::invokeRestart
[10:21:10.431]             length <- base::length
[10:21:10.431]             list <- base::list
[10:21:10.431]             seq.int <- base::seq.int
[10:21:10.431]             signalCondition <- base::signalCondition
[10:21:10.431]             sys.calls <- base::sys.calls
[10:21:10.431]             `[[` <- base::`[[`
[10:21:10.431]             `+` <- base::`+`
[10:21:10.431]             `<<-` <- base::`<<-`
[10:21:10.431]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.431]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.431]                   3L)]
[10:21:10.431]             }
[10:21:10.431]             function(cond) {
[10:21:10.431]                 is_error <- inherits(cond, "error")
[10:21:10.431]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.431]                   NULL)
[10:21:10.431]                 if (is_error) {
[10:21:10.431]                   sessionInformation <- function() {
[10:21:10.431]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.431]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.431]                       search = base::search(), system = base::Sys.info())
[10:21:10.431]                   }
[10:21:10.431]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.431]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.431]                     cond$call), session = sessionInformation(), 
[10:21:10.431]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.431]                   signalCondition(cond)
[10:21:10.431]                 }
[10:21:10.431]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.431]                 "immediateCondition"))) {
[10:21:10.431]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.431]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.431]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.431]                   if (TRUE && !signal) {
[10:21:10.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.431]                     {
[10:21:10.431]                       inherits <- base::inherits
[10:21:10.431]                       invokeRestart <- base::invokeRestart
[10:21:10.431]                       is.null <- base::is.null
[10:21:10.431]                       muffled <- FALSE
[10:21:10.431]                       if (inherits(cond, "message")) {
[10:21:10.431]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.431]                         if (muffled) 
[10:21:10.431]                           invokeRestart("muffleMessage")
[10:21:10.431]                       }
[10:21:10.431]                       else if (inherits(cond, "warning")) {
[10:21:10.431]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.431]                         if (muffled) 
[10:21:10.431]                           invokeRestart("muffleWarning")
[10:21:10.431]                       }
[10:21:10.431]                       else if (inherits(cond, "condition")) {
[10:21:10.431]                         if (!is.null(pattern)) {
[10:21:10.431]                           computeRestarts <- base::computeRestarts
[10:21:10.431]                           grepl <- base::grepl
[10:21:10.431]                           restarts <- computeRestarts(cond)
[10:21:10.431]                           for (restart in restarts) {
[10:21:10.431]                             name <- restart$name
[10:21:10.431]                             if (is.null(name)) 
[10:21:10.431]                               next
[10:21:10.431]                             if (!grepl(pattern, name)) 
[10:21:10.431]                               next
[10:21:10.431]                             invokeRestart(restart)
[10:21:10.431]                             muffled <- TRUE
[10:21:10.431]                             break
[10:21:10.431]                           }
[10:21:10.431]                         }
[10:21:10.431]                       }
[10:21:10.431]                       invisible(muffled)
[10:21:10.431]                     }
[10:21:10.431]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.431]                   }
[10:21:10.431]                 }
[10:21:10.431]                 else {
[10:21:10.431]                   if (TRUE) {
[10:21:10.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.431]                     {
[10:21:10.431]                       inherits <- base::inherits
[10:21:10.431]                       invokeRestart <- base::invokeRestart
[10:21:10.431]                       is.null <- base::is.null
[10:21:10.431]                       muffled <- FALSE
[10:21:10.431]                       if (inherits(cond, "message")) {
[10:21:10.431]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.431]                         if (muffled) 
[10:21:10.431]                           invokeRestart("muffleMessage")
[10:21:10.431]                       }
[10:21:10.431]                       else if (inherits(cond, "warning")) {
[10:21:10.431]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.431]                         if (muffled) 
[10:21:10.431]                           invokeRestart("muffleWarning")
[10:21:10.431]                       }
[10:21:10.431]                       else if (inherits(cond, "condition")) {
[10:21:10.431]                         if (!is.null(pattern)) {
[10:21:10.431]                           computeRestarts <- base::computeRestarts
[10:21:10.431]                           grepl <- base::grepl
[10:21:10.431]                           restarts <- computeRestarts(cond)
[10:21:10.431]                           for (restart in restarts) {
[10:21:10.431]                             name <- restart$name
[10:21:10.431]                             if (is.null(name)) 
[10:21:10.431]                               next
[10:21:10.431]                             if (!grepl(pattern, name)) 
[10:21:10.431]                               next
[10:21:10.431]                             invokeRestart(restart)
[10:21:10.431]                             muffled <- TRUE
[10:21:10.431]                             break
[10:21:10.431]                           }
[10:21:10.431]                         }
[10:21:10.431]                       }
[10:21:10.431]                       invisible(muffled)
[10:21:10.431]                     }
[10:21:10.431]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.431]                   }
[10:21:10.431]                 }
[10:21:10.431]             }
[10:21:10.431]         }))
[10:21:10.431]     }, error = function(ex) {
[10:21:10.431]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.431]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.431]                 ...future.rng), started = ...future.startTime, 
[10:21:10.431]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.431]             version = "1.8"), class = "FutureResult")
[10:21:10.431]     }, finally = {
[10:21:10.431]         if (!identical(...future.workdir, getwd())) 
[10:21:10.431]             setwd(...future.workdir)
[10:21:10.431]         {
[10:21:10.431]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.431]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.431]             }
[10:21:10.431]             base::options(...future.oldOptions)
[10:21:10.431]             if (.Platform$OS.type == "windows") {
[10:21:10.431]                 old_names <- names(...future.oldEnvVars)
[10:21:10.431]                 envs <- base::Sys.getenv()
[10:21:10.431]                 names <- names(envs)
[10:21:10.431]                 common <- intersect(names, old_names)
[10:21:10.431]                 added <- setdiff(names, old_names)
[10:21:10.431]                 removed <- setdiff(old_names, names)
[10:21:10.431]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.431]                   envs[common]]
[10:21:10.431]                 NAMES <- toupper(changed)
[10:21:10.431]                 args <- list()
[10:21:10.431]                 for (kk in seq_along(NAMES)) {
[10:21:10.431]                   name <- changed[[kk]]
[10:21:10.431]                   NAME <- NAMES[[kk]]
[10:21:10.431]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.431]                     next
[10:21:10.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.431]                 }
[10:21:10.431]                 NAMES <- toupper(added)
[10:21:10.431]                 for (kk in seq_along(NAMES)) {
[10:21:10.431]                   name <- added[[kk]]
[10:21:10.431]                   NAME <- NAMES[[kk]]
[10:21:10.431]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.431]                     next
[10:21:10.431]                   args[[name]] <- ""
[10:21:10.431]                 }
[10:21:10.431]                 NAMES <- toupper(removed)
[10:21:10.431]                 for (kk in seq_along(NAMES)) {
[10:21:10.431]                   name <- removed[[kk]]
[10:21:10.431]                   NAME <- NAMES[[kk]]
[10:21:10.431]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.431]                     next
[10:21:10.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.431]                 }
[10:21:10.431]                 if (length(args) > 0) 
[10:21:10.431]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.431]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.431]             }
[10:21:10.431]             else {
[10:21:10.431]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.431]             }
[10:21:10.431]             {
[10:21:10.431]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.431]                   0L) {
[10:21:10.431]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.431]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.431]                   base::options(opts)
[10:21:10.431]                 }
[10:21:10.431]                 {
[10:21:10.431]                   {
[10:21:10.431]                     NULL
[10:21:10.431]                     RNGkind("Mersenne-Twister")
[10:21:10.431]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:10.431]                       inherits = FALSE)
[10:21:10.431]                   }
[10:21:10.431]                   options(future.plan = NULL)
[10:21:10.431]                   if (is.na(NA_character_)) 
[10:21:10.431]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.431]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.431]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.431]                     .init = FALSE)
[10:21:10.431]                 }
[10:21:10.431]             }
[10:21:10.431]         }
[10:21:10.431]     })
[10:21:10.431]     if (TRUE) {
[10:21:10.431]         base::sink(type = "output", split = FALSE)
[10:21:10.431]         if (TRUE) {
[10:21:10.431]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.431]         }
[10:21:10.431]         else {
[10:21:10.431]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.431]         }
[10:21:10.431]         base::close(...future.stdout)
[10:21:10.431]         ...future.stdout <- NULL
[10:21:10.431]     }
[10:21:10.431]     ...future.result$conditions <- ...future.conditions
[10:21:10.431]     ...future.result$finished <- base::Sys.time()
[10:21:10.431]     ...future.result
[10:21:10.431] }
[10:21:10.433] assign_globals() ...
[10:21:10.433] List of 1
[10:21:10.433]  $ ii: int 2
[10:21:10.433]  - attr(*, "where")=List of 1
[10:21:10.433]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:10.433]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:10.433]  - attr(*, "resolved")= logi FALSE
[10:21:10.433]  - attr(*, "total_size")= num 35
[10:21:10.433]  - attr(*, "already-done")= logi TRUE
[10:21:10.435] - copied ‘ii’ to environment
[10:21:10.435] assign_globals() ... done
[10:21:10.436] plan(): Setting new future strategy stack:
[10:21:10.436] List of future strategies:
[10:21:10.436] 1. sequential:
[10:21:10.436]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.436]    - tweaked: FALSE
[10:21:10.436]    - call: NULL
[10:21:10.436] plan(): nbrOfWorkers() = 1
[10:21:10.437] plan(): Setting new future strategy stack:
[10:21:10.437] List of future strategies:
[10:21:10.437] 1. sequential:
[10:21:10.437]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.437]    - tweaked: FALSE
[10:21:10.437]    - call: plan(strategy)
[10:21:10.438] plan(): nbrOfWorkers() = 1
[10:21:10.438] SequentialFuture started (and completed)
[10:21:10.438] signalConditions() ...
[10:21:10.438]  - include = ‘immediateCondition’
[10:21:10.438]  - exclude = 
[10:21:10.438]  - resignal = FALSE
[10:21:10.438]  - Number of conditions: 1
[10:21:10.438] signalConditions() ... done
[10:21:10.438] - Launch lazy future ... done
[10:21:10.438] run() for ‘SequentialFuture’ ... done
[10:21:10.439] getGlobalsAndPackages() ...
[10:21:10.439] Searching for globals...
[10:21:10.440] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[10:21:10.440] Searching for globals ... DONE
[10:21:10.440] Resolving globals: FALSE
[10:21:10.441] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:10.441] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:10.441] - globals: [1] ‘ii’
[10:21:10.441] 
[10:21:10.442] getGlobalsAndPackages() ... DONE
[10:21:10.442] run() for ‘Future’ ...
[10:21:10.442] - state: ‘created’
[10:21:10.442] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:10.442] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:10.442] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:10.442]   - Field: ‘label’
[10:21:10.442]   - Field: ‘local’
[10:21:10.443]   - Field: ‘owner’
[10:21:10.443]   - Field: ‘envir’
[10:21:10.443]   - Field: ‘packages’
[10:21:10.443]   - Field: ‘gc’
[10:21:10.443]   - Field: ‘conditions’
[10:21:10.443]   - Field: ‘expr’
[10:21:10.443]   - Field: ‘uuid’
[10:21:10.443]   - Field: ‘seed’
[10:21:10.443]   - Field: ‘version’
[10:21:10.443]   - Field: ‘result’
[10:21:10.443]   - Field: ‘asynchronous’
[10:21:10.444]   - Field: ‘calls’
[10:21:10.444]   - Field: ‘globals’
[10:21:10.444]   - Field: ‘stdout’
[10:21:10.444]   - Field: ‘earlySignal’
[10:21:10.444]   - Field: ‘lazy’
[10:21:10.444]   - Field: ‘state’
[10:21:10.444] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:10.444] - Launch lazy future ...
[10:21:10.444] Packages needed by the future expression (n = 0): <none>
[10:21:10.444] Packages needed by future strategies (n = 0): <none>
[10:21:10.445] {
[10:21:10.445]     {
[10:21:10.445]         {
[10:21:10.445]             ...future.startTime <- base::Sys.time()
[10:21:10.445]             {
[10:21:10.445]                 {
[10:21:10.445]                   {
[10:21:10.445]                     base::local({
[10:21:10.445]                       has_future <- base::requireNamespace("future", 
[10:21:10.445]                         quietly = TRUE)
[10:21:10.445]                       if (has_future) {
[10:21:10.445]                         ns <- base::getNamespace("future")
[10:21:10.445]                         version <- ns[[".package"]][["version"]]
[10:21:10.445]                         if (is.null(version)) 
[10:21:10.445]                           version <- utils::packageVersion("future")
[10:21:10.445]                       }
[10:21:10.445]                       else {
[10:21:10.445]                         version <- NULL
[10:21:10.445]                       }
[10:21:10.445]                       if (!has_future || version < "1.8.0") {
[10:21:10.445]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.445]                           "", base::R.version$version.string), 
[10:21:10.445]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:10.445]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.445]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.445]                             "release", "version")], collapse = " "), 
[10:21:10.445]                           hostname = base::Sys.info()[["nodename"]])
[10:21:10.445]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.445]                           info)
[10:21:10.445]                         info <- base::paste(info, collapse = "; ")
[10:21:10.445]                         if (!has_future) {
[10:21:10.445]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.445]                             info)
[10:21:10.445]                         }
[10:21:10.445]                         else {
[10:21:10.445]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.445]                             info, version)
[10:21:10.445]                         }
[10:21:10.445]                         base::stop(msg)
[10:21:10.445]                       }
[10:21:10.445]                     })
[10:21:10.445]                   }
[10:21:10.445]                   ...future.strategy.old <- future::plan("list")
[10:21:10.445]                   options(future.plan = NULL)
[10:21:10.445]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.445]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.445]                 }
[10:21:10.445]                 ...future.workdir <- getwd()
[10:21:10.445]             }
[10:21:10.445]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.445]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.445]         }
[10:21:10.445]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.445]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.445]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.445]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.445]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.445]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.445]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.445]             base::names(...future.oldOptions))
[10:21:10.445]     }
[10:21:10.445]     if (FALSE) {
[10:21:10.445]     }
[10:21:10.445]     else {
[10:21:10.445]         if (TRUE) {
[10:21:10.445]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.445]                 open = "w")
[10:21:10.445]         }
[10:21:10.445]         else {
[10:21:10.445]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.445]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.445]         }
[10:21:10.445]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.445]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.445]             base::sink(type = "output", split = FALSE)
[10:21:10.445]             base::close(...future.stdout)
[10:21:10.445]         }, add = TRUE)
[10:21:10.445]     }
[10:21:10.445]     ...future.frame <- base::sys.nframe()
[10:21:10.445]     ...future.conditions <- base::list()
[10:21:10.445]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.445]     if (FALSE) {
[10:21:10.445]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.445]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.445]     }
[10:21:10.445]     ...future.result <- base::tryCatch({
[10:21:10.445]         base::withCallingHandlers({
[10:21:10.445]             ...future.value <- base::withVisible(base::local({
[10:21:10.445]                 if (ii%%2 == 0) 
[10:21:10.445]                   stop("Woops!")
[10:21:10.445]                 ii
[10:21:10.445]             }))
[10:21:10.445]             future::FutureResult(value = ...future.value$value, 
[10:21:10.445]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.445]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.445]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.445]                     ...future.globalenv.names))
[10:21:10.445]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.445]         }, condition = base::local({
[10:21:10.445]             c <- base::c
[10:21:10.445]             inherits <- base::inherits
[10:21:10.445]             invokeRestart <- base::invokeRestart
[10:21:10.445]             length <- base::length
[10:21:10.445]             list <- base::list
[10:21:10.445]             seq.int <- base::seq.int
[10:21:10.445]             signalCondition <- base::signalCondition
[10:21:10.445]             sys.calls <- base::sys.calls
[10:21:10.445]             `[[` <- base::`[[`
[10:21:10.445]             `+` <- base::`+`
[10:21:10.445]             `<<-` <- base::`<<-`
[10:21:10.445]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.445]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.445]                   3L)]
[10:21:10.445]             }
[10:21:10.445]             function(cond) {
[10:21:10.445]                 is_error <- inherits(cond, "error")
[10:21:10.445]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.445]                   NULL)
[10:21:10.445]                 if (is_error) {
[10:21:10.445]                   sessionInformation <- function() {
[10:21:10.445]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.445]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.445]                       search = base::search(), system = base::Sys.info())
[10:21:10.445]                   }
[10:21:10.445]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.445]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.445]                     cond$call), session = sessionInformation(), 
[10:21:10.445]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.445]                   signalCondition(cond)
[10:21:10.445]                 }
[10:21:10.445]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.445]                 "immediateCondition"))) {
[10:21:10.445]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.445]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.445]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.445]                   if (TRUE && !signal) {
[10:21:10.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.445]                     {
[10:21:10.445]                       inherits <- base::inherits
[10:21:10.445]                       invokeRestart <- base::invokeRestart
[10:21:10.445]                       is.null <- base::is.null
[10:21:10.445]                       muffled <- FALSE
[10:21:10.445]                       if (inherits(cond, "message")) {
[10:21:10.445]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.445]                         if (muffled) 
[10:21:10.445]                           invokeRestart("muffleMessage")
[10:21:10.445]                       }
[10:21:10.445]                       else if (inherits(cond, "warning")) {
[10:21:10.445]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.445]                         if (muffled) 
[10:21:10.445]                           invokeRestart("muffleWarning")
[10:21:10.445]                       }
[10:21:10.445]                       else if (inherits(cond, "condition")) {
[10:21:10.445]                         if (!is.null(pattern)) {
[10:21:10.445]                           computeRestarts <- base::computeRestarts
[10:21:10.445]                           grepl <- base::grepl
[10:21:10.445]                           restarts <- computeRestarts(cond)
[10:21:10.445]                           for (restart in restarts) {
[10:21:10.445]                             name <- restart$name
[10:21:10.445]                             if (is.null(name)) 
[10:21:10.445]                               next
[10:21:10.445]                             if (!grepl(pattern, name)) 
[10:21:10.445]                               next
[10:21:10.445]                             invokeRestart(restart)
[10:21:10.445]                             muffled <- TRUE
[10:21:10.445]                             break
[10:21:10.445]                           }
[10:21:10.445]                         }
[10:21:10.445]                       }
[10:21:10.445]                       invisible(muffled)
[10:21:10.445]                     }
[10:21:10.445]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.445]                   }
[10:21:10.445]                 }
[10:21:10.445]                 else {
[10:21:10.445]                   if (TRUE) {
[10:21:10.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.445]                     {
[10:21:10.445]                       inherits <- base::inherits
[10:21:10.445]                       invokeRestart <- base::invokeRestart
[10:21:10.445]                       is.null <- base::is.null
[10:21:10.445]                       muffled <- FALSE
[10:21:10.445]                       if (inherits(cond, "message")) {
[10:21:10.445]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.445]                         if (muffled) 
[10:21:10.445]                           invokeRestart("muffleMessage")
[10:21:10.445]                       }
[10:21:10.445]                       else if (inherits(cond, "warning")) {
[10:21:10.445]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.445]                         if (muffled) 
[10:21:10.445]                           invokeRestart("muffleWarning")
[10:21:10.445]                       }
[10:21:10.445]                       else if (inherits(cond, "condition")) {
[10:21:10.445]                         if (!is.null(pattern)) {
[10:21:10.445]                           computeRestarts <- base::computeRestarts
[10:21:10.445]                           grepl <- base::grepl
[10:21:10.445]                           restarts <- computeRestarts(cond)
[10:21:10.445]                           for (restart in restarts) {
[10:21:10.445]                             name <- restart$name
[10:21:10.445]                             if (is.null(name)) 
[10:21:10.445]                               next
[10:21:10.445]                             if (!grepl(pattern, name)) 
[10:21:10.445]                               next
[10:21:10.445]                             invokeRestart(restart)
[10:21:10.445]                             muffled <- TRUE
[10:21:10.445]                             break
[10:21:10.445]                           }
[10:21:10.445]                         }
[10:21:10.445]                       }
[10:21:10.445]                       invisible(muffled)
[10:21:10.445]                     }
[10:21:10.445]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.445]                   }
[10:21:10.445]                 }
[10:21:10.445]             }
[10:21:10.445]         }))
[10:21:10.445]     }, error = function(ex) {
[10:21:10.445]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.445]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.445]                 ...future.rng), started = ...future.startTime, 
[10:21:10.445]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.445]             version = "1.8"), class = "FutureResult")
[10:21:10.445]     }, finally = {
[10:21:10.445]         if (!identical(...future.workdir, getwd())) 
[10:21:10.445]             setwd(...future.workdir)
[10:21:10.445]         {
[10:21:10.445]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.445]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.445]             }
[10:21:10.445]             base::options(...future.oldOptions)
[10:21:10.445]             if (.Platform$OS.type == "windows") {
[10:21:10.445]                 old_names <- names(...future.oldEnvVars)
[10:21:10.445]                 envs <- base::Sys.getenv()
[10:21:10.445]                 names <- names(envs)
[10:21:10.445]                 common <- intersect(names, old_names)
[10:21:10.445]                 added <- setdiff(names, old_names)
[10:21:10.445]                 removed <- setdiff(old_names, names)
[10:21:10.445]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.445]                   envs[common]]
[10:21:10.445]                 NAMES <- toupper(changed)
[10:21:10.445]                 args <- list()
[10:21:10.445]                 for (kk in seq_along(NAMES)) {
[10:21:10.445]                   name <- changed[[kk]]
[10:21:10.445]                   NAME <- NAMES[[kk]]
[10:21:10.445]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.445]                     next
[10:21:10.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.445]                 }
[10:21:10.445]                 NAMES <- toupper(added)
[10:21:10.445]                 for (kk in seq_along(NAMES)) {
[10:21:10.445]                   name <- added[[kk]]
[10:21:10.445]                   NAME <- NAMES[[kk]]
[10:21:10.445]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.445]                     next
[10:21:10.445]                   args[[name]] <- ""
[10:21:10.445]                 }
[10:21:10.445]                 NAMES <- toupper(removed)
[10:21:10.445]                 for (kk in seq_along(NAMES)) {
[10:21:10.445]                   name <- removed[[kk]]
[10:21:10.445]                   NAME <- NAMES[[kk]]
[10:21:10.445]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.445]                     next
[10:21:10.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.445]                 }
[10:21:10.445]                 if (length(args) > 0) 
[10:21:10.445]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.445]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.445]             }
[10:21:10.445]             else {
[10:21:10.445]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.445]             }
[10:21:10.445]             {
[10:21:10.445]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.445]                   0L) {
[10:21:10.445]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.445]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.445]                   base::options(opts)
[10:21:10.445]                 }
[10:21:10.445]                 {
[10:21:10.445]                   {
[10:21:10.445]                     NULL
[10:21:10.445]                     RNGkind("Mersenne-Twister")
[10:21:10.445]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:10.445]                       inherits = FALSE)
[10:21:10.445]                   }
[10:21:10.445]                   options(future.plan = NULL)
[10:21:10.445]                   if (is.na(NA_character_)) 
[10:21:10.445]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.445]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.445]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.445]                     .init = FALSE)
[10:21:10.445]                 }
[10:21:10.445]             }
[10:21:10.445]         }
[10:21:10.445]     })
[10:21:10.445]     if (TRUE) {
[10:21:10.445]         base::sink(type = "output", split = FALSE)
[10:21:10.445]         if (TRUE) {
[10:21:10.445]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.445]         }
[10:21:10.445]         else {
[10:21:10.445]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.445]         }
[10:21:10.445]         base::close(...future.stdout)
[10:21:10.445]         ...future.stdout <- NULL
[10:21:10.445]     }
[10:21:10.445]     ...future.result$conditions <- ...future.conditions
[10:21:10.445]     ...future.result$finished <- base::Sys.time()
[10:21:10.445]     ...future.result
[10:21:10.445] }
[10:21:10.446] assign_globals() ...
[10:21:10.447] List of 1
[10:21:10.447]  $ ii: int 3
[10:21:10.447]  - attr(*, "where")=List of 1
[10:21:10.447]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:10.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:10.447]  - attr(*, "resolved")= logi FALSE
[10:21:10.447]  - attr(*, "total_size")= num 35
[10:21:10.447]  - attr(*, "already-done")= logi TRUE
[10:21:10.451] - copied ‘ii’ to environment
[10:21:10.451] assign_globals() ... done
[10:21:10.451] plan(): Setting new future strategy stack:
[10:21:10.451] List of future strategies:
[10:21:10.451] 1. sequential:
[10:21:10.451]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.451]    - tweaked: FALSE
[10:21:10.451]    - call: NULL
[10:21:10.451] plan(): nbrOfWorkers() = 1
[10:21:10.452] plan(): Setting new future strategy stack:
[10:21:10.452] List of future strategies:
[10:21:10.452] 1. sequential:
[10:21:10.452]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.452]    - tweaked: FALSE
[10:21:10.452]    - call: plan(strategy)
[10:21:10.453] plan(): nbrOfWorkers() = 1
[10:21:10.453] SequentialFuture started (and completed)
[10:21:10.453] - Launch lazy future ... done
[10:21:10.453] run() for ‘SequentialFuture’ ... done
[10:21:10.453] signalConditions() ...
[10:21:10.453]  - include = ‘immediateCondition’
[10:21:10.454]  - exclude = 
[10:21:10.454]  - resignal = FALSE
[10:21:10.454]  - Number of conditions: 1
[10:21:10.454] signalConditions() ... done
[10:21:10.454] Future state: ‘finished’
[10:21:10.454] signalConditions() ...
[10:21:10.454]  - include = ‘condition’
[10:21:10.454]  - exclude = ‘immediateCondition’
[10:21:10.454]  - resignal = TRUE
[10:21:10.454]  - Number of conditions: 1
[10:21:10.454]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:10.455] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[10:21:10.455] signalConditions() ...
[10:21:10.456]  - include = ‘immediateCondition’
[10:21:10.456]  - exclude = 
[10:21:10.456]  - resignal = FALSE
[10:21:10.456]  - Number of conditions: 1
[10:21:10.456] signalConditions() ... done
[10:21:10.456] Future state: ‘finished’
[10:21:10.456] signalConditions() ...
[10:21:10.456]  - include = ‘condition’
[10:21:10.456]  - exclude = ‘immediateCondition’
[10:21:10.456]  - resignal = TRUE
[10:21:10.456]  - Number of conditions: 1
[10:21:10.457]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:10.457] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[10:21:10.457] signalConditions() ...
[10:21:10.457]  - include = ‘immediateCondition’
[10:21:10.457]  - exclude = 
[10:21:10.457]  - resignal = FALSE
[10:21:10.457]  - Number of conditions: 1
[10:21:10.457] signalConditions() ... done
[10:21:10.457] Future state: ‘finished’
[10:21:10.458] signalConditions() ...
[10:21:10.458]  - include = ‘condition’
[10:21:10.458]  - exclude = ‘immediateCondition’
[10:21:10.458]  - resignal = TRUE
[10:21:10.458]  - Number of conditions: 1
[10:21:10.458]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:10.458] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[10:21:10.458] getGlobalsAndPackages() ...
[10:21:10.458] Searching for globals...
[10:21:10.460] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[10:21:10.460] Searching for globals ... DONE
[10:21:10.460] Resolving globals: FALSE
[10:21:10.461] 
[10:21:10.461] 
[10:21:10.461] getGlobalsAndPackages() ... DONE
[10:21:10.461] run() for ‘Future’ ...
[10:21:10.461] - state: ‘created’
[10:21:10.461] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:10.462] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:10.462] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:10.462]   - Field: ‘label’
[10:21:10.462]   - Field: ‘local’
[10:21:10.462]   - Field: ‘owner’
[10:21:10.462]   - Field: ‘envir’
[10:21:10.462]   - Field: ‘packages’
[10:21:10.462]   - Field: ‘gc’
[10:21:10.462]   - Field: ‘conditions’
[10:21:10.462]   - Field: ‘expr’
[10:21:10.463]   - Field: ‘uuid’
[10:21:10.463]   - Field: ‘seed’
[10:21:10.463]   - Field: ‘version’
[10:21:10.463]   - Field: ‘result’
[10:21:10.463]   - Field: ‘asynchronous’
[10:21:10.463]   - Field: ‘calls’
[10:21:10.463]   - Field: ‘globals’
[10:21:10.463]   - Field: ‘stdout’
[10:21:10.463]   - Field: ‘earlySignal’
[10:21:10.463]   - Field: ‘lazy’
[10:21:10.463]   - Field: ‘state’
[10:21:10.463] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:10.464] - Launch lazy future ...
[10:21:10.464] Packages needed by the future expression (n = 0): <none>
[10:21:10.464] Packages needed by future strategies (n = 0): <none>
[10:21:10.464] {
[10:21:10.464]     {
[10:21:10.464]         {
[10:21:10.464]             ...future.startTime <- base::Sys.time()
[10:21:10.464]             {
[10:21:10.464]                 {
[10:21:10.464]                   {
[10:21:10.464]                     base::local({
[10:21:10.464]                       has_future <- base::requireNamespace("future", 
[10:21:10.464]                         quietly = TRUE)
[10:21:10.464]                       if (has_future) {
[10:21:10.464]                         ns <- base::getNamespace("future")
[10:21:10.464]                         version <- ns[[".package"]][["version"]]
[10:21:10.464]                         if (is.null(version)) 
[10:21:10.464]                           version <- utils::packageVersion("future")
[10:21:10.464]                       }
[10:21:10.464]                       else {
[10:21:10.464]                         version <- NULL
[10:21:10.464]                       }
[10:21:10.464]                       if (!has_future || version < "1.8.0") {
[10:21:10.464]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.464]                           "", base::R.version$version.string), 
[10:21:10.464]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:10.464]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.464]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.464]                             "release", "version")], collapse = " "), 
[10:21:10.464]                           hostname = base::Sys.info()[["nodename"]])
[10:21:10.464]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.464]                           info)
[10:21:10.464]                         info <- base::paste(info, collapse = "; ")
[10:21:10.464]                         if (!has_future) {
[10:21:10.464]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.464]                             info)
[10:21:10.464]                         }
[10:21:10.464]                         else {
[10:21:10.464]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.464]                             info, version)
[10:21:10.464]                         }
[10:21:10.464]                         base::stop(msg)
[10:21:10.464]                       }
[10:21:10.464]                     })
[10:21:10.464]                   }
[10:21:10.464]                   ...future.strategy.old <- future::plan("list")
[10:21:10.464]                   options(future.plan = NULL)
[10:21:10.464]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.464]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.464]                 }
[10:21:10.464]                 ...future.workdir <- getwd()
[10:21:10.464]             }
[10:21:10.464]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.464]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.464]         }
[10:21:10.464]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.464]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.464]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.464]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.464]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.464]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.464]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.464]             base::names(...future.oldOptions))
[10:21:10.464]     }
[10:21:10.464]     if (FALSE) {
[10:21:10.464]     }
[10:21:10.464]     else {
[10:21:10.464]         if (TRUE) {
[10:21:10.464]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.464]                 open = "w")
[10:21:10.464]         }
[10:21:10.464]         else {
[10:21:10.464]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.464]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.464]         }
[10:21:10.464]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.464]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.464]             base::sink(type = "output", split = FALSE)
[10:21:10.464]             base::close(...future.stdout)
[10:21:10.464]         }, add = TRUE)
[10:21:10.464]     }
[10:21:10.464]     ...future.frame <- base::sys.nframe()
[10:21:10.464]     ...future.conditions <- base::list()
[10:21:10.464]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.464]     if (FALSE) {
[10:21:10.464]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.464]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.464]     }
[10:21:10.464]     ...future.result <- base::tryCatch({
[10:21:10.464]         base::withCallingHandlers({
[10:21:10.464]             ...future.value <- base::withVisible(base::local({
[10:21:10.464]                 cat("Processing: ")
[10:21:10.464]                 for (ii in 1:10) {
[10:21:10.464]                   cat(".")
[10:21:10.464]                 }
[10:21:10.464]                 cat(" [100%]\n")
[10:21:10.464]                 4
[10:21:10.464]             }))
[10:21:10.464]             future::FutureResult(value = ...future.value$value, 
[10:21:10.464]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.464]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.464]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.464]                     ...future.globalenv.names))
[10:21:10.464]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.464]         }, condition = base::local({
[10:21:10.464]             c <- base::c
[10:21:10.464]             inherits <- base::inherits
[10:21:10.464]             invokeRestart <- base::invokeRestart
[10:21:10.464]             length <- base::length
[10:21:10.464]             list <- base::list
[10:21:10.464]             seq.int <- base::seq.int
[10:21:10.464]             signalCondition <- base::signalCondition
[10:21:10.464]             sys.calls <- base::sys.calls
[10:21:10.464]             `[[` <- base::`[[`
[10:21:10.464]             `+` <- base::`+`
[10:21:10.464]             `<<-` <- base::`<<-`
[10:21:10.464]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.464]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.464]                   3L)]
[10:21:10.464]             }
[10:21:10.464]             function(cond) {
[10:21:10.464]                 is_error <- inherits(cond, "error")
[10:21:10.464]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.464]                   NULL)
[10:21:10.464]                 if (is_error) {
[10:21:10.464]                   sessionInformation <- function() {
[10:21:10.464]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.464]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.464]                       search = base::search(), system = base::Sys.info())
[10:21:10.464]                   }
[10:21:10.464]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.464]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.464]                     cond$call), session = sessionInformation(), 
[10:21:10.464]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.464]                   signalCondition(cond)
[10:21:10.464]                 }
[10:21:10.464]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.464]                 "immediateCondition"))) {
[10:21:10.464]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.464]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.464]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.464]                   if (TRUE && !signal) {
[10:21:10.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.464]                     {
[10:21:10.464]                       inherits <- base::inherits
[10:21:10.464]                       invokeRestart <- base::invokeRestart
[10:21:10.464]                       is.null <- base::is.null
[10:21:10.464]                       muffled <- FALSE
[10:21:10.464]                       if (inherits(cond, "message")) {
[10:21:10.464]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.464]                         if (muffled) 
[10:21:10.464]                           invokeRestart("muffleMessage")
[10:21:10.464]                       }
[10:21:10.464]                       else if (inherits(cond, "warning")) {
[10:21:10.464]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.464]                         if (muffled) 
[10:21:10.464]                           invokeRestart("muffleWarning")
[10:21:10.464]                       }
[10:21:10.464]                       else if (inherits(cond, "condition")) {
[10:21:10.464]                         if (!is.null(pattern)) {
[10:21:10.464]                           computeRestarts <- base::computeRestarts
[10:21:10.464]                           grepl <- base::grepl
[10:21:10.464]                           restarts <- computeRestarts(cond)
[10:21:10.464]                           for (restart in restarts) {
[10:21:10.464]                             name <- restart$name
[10:21:10.464]                             if (is.null(name)) 
[10:21:10.464]                               next
[10:21:10.464]                             if (!grepl(pattern, name)) 
[10:21:10.464]                               next
[10:21:10.464]                             invokeRestart(restart)
[10:21:10.464]                             muffled <- TRUE
[10:21:10.464]                             break
[10:21:10.464]                           }
[10:21:10.464]                         }
[10:21:10.464]                       }
[10:21:10.464]                       invisible(muffled)
[10:21:10.464]                     }
[10:21:10.464]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.464]                   }
[10:21:10.464]                 }
[10:21:10.464]                 else {
[10:21:10.464]                   if (TRUE) {
[10:21:10.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.464]                     {
[10:21:10.464]                       inherits <- base::inherits
[10:21:10.464]                       invokeRestart <- base::invokeRestart
[10:21:10.464]                       is.null <- base::is.null
[10:21:10.464]                       muffled <- FALSE
[10:21:10.464]                       if (inherits(cond, "message")) {
[10:21:10.464]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.464]                         if (muffled) 
[10:21:10.464]                           invokeRestart("muffleMessage")
[10:21:10.464]                       }
[10:21:10.464]                       else if (inherits(cond, "warning")) {
[10:21:10.464]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.464]                         if (muffled) 
[10:21:10.464]                           invokeRestart("muffleWarning")
[10:21:10.464]                       }
[10:21:10.464]                       else if (inherits(cond, "condition")) {
[10:21:10.464]                         if (!is.null(pattern)) {
[10:21:10.464]                           computeRestarts <- base::computeRestarts
[10:21:10.464]                           grepl <- base::grepl
[10:21:10.464]                           restarts <- computeRestarts(cond)
[10:21:10.464]                           for (restart in restarts) {
[10:21:10.464]                             name <- restart$name
[10:21:10.464]                             if (is.null(name)) 
[10:21:10.464]                               next
[10:21:10.464]                             if (!grepl(pattern, name)) 
[10:21:10.464]                               next
[10:21:10.464]                             invokeRestart(restart)
[10:21:10.464]                             muffled <- TRUE
[10:21:10.464]                             break
[10:21:10.464]                           }
[10:21:10.464]                         }
[10:21:10.464]                       }
[10:21:10.464]                       invisible(muffled)
[10:21:10.464]                     }
[10:21:10.464]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.464]                   }
[10:21:10.464]                 }
[10:21:10.464]             }
[10:21:10.464]         }))
[10:21:10.464]     }, error = function(ex) {
[10:21:10.464]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.464]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.464]                 ...future.rng), started = ...future.startTime, 
[10:21:10.464]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.464]             version = "1.8"), class = "FutureResult")
[10:21:10.464]     }, finally = {
[10:21:10.464]         if (!identical(...future.workdir, getwd())) 
[10:21:10.464]             setwd(...future.workdir)
[10:21:10.464]         {
[10:21:10.464]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.464]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.464]             }
[10:21:10.464]             base::options(...future.oldOptions)
[10:21:10.464]             if (.Platform$OS.type == "windows") {
[10:21:10.464]                 old_names <- names(...future.oldEnvVars)
[10:21:10.464]                 envs <- base::Sys.getenv()
[10:21:10.464]                 names <- names(envs)
[10:21:10.464]                 common <- intersect(names, old_names)
[10:21:10.464]                 added <- setdiff(names, old_names)
[10:21:10.464]                 removed <- setdiff(old_names, names)
[10:21:10.464]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.464]                   envs[common]]
[10:21:10.464]                 NAMES <- toupper(changed)
[10:21:10.464]                 args <- list()
[10:21:10.464]                 for (kk in seq_along(NAMES)) {
[10:21:10.464]                   name <- changed[[kk]]
[10:21:10.464]                   NAME <- NAMES[[kk]]
[10:21:10.464]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.464]                     next
[10:21:10.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.464]                 }
[10:21:10.464]                 NAMES <- toupper(added)
[10:21:10.464]                 for (kk in seq_along(NAMES)) {
[10:21:10.464]                   name <- added[[kk]]
[10:21:10.464]                   NAME <- NAMES[[kk]]
[10:21:10.464]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.464]                     next
[10:21:10.464]                   args[[name]] <- ""
[10:21:10.464]                 }
[10:21:10.464]                 NAMES <- toupper(removed)
[10:21:10.464]                 for (kk in seq_along(NAMES)) {
[10:21:10.464]                   name <- removed[[kk]]
[10:21:10.464]                   NAME <- NAMES[[kk]]
[10:21:10.464]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.464]                     next
[10:21:10.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.464]                 }
[10:21:10.464]                 if (length(args) > 0) 
[10:21:10.464]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.464]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.464]             }
[10:21:10.464]             else {
[10:21:10.464]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.464]             }
[10:21:10.464]             {
[10:21:10.464]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.464]                   0L) {
[10:21:10.464]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.464]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.464]                   base::options(opts)
[10:21:10.464]                 }
[10:21:10.464]                 {
[10:21:10.464]                   {
[10:21:10.464]                     NULL
[10:21:10.464]                     RNGkind("Mersenne-Twister")
[10:21:10.464]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:10.464]                       inherits = FALSE)
[10:21:10.464]                   }
[10:21:10.464]                   options(future.plan = NULL)
[10:21:10.464]                   if (is.na(NA_character_)) 
[10:21:10.464]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.464]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.464]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.464]                     .init = FALSE)
[10:21:10.464]                 }
[10:21:10.464]             }
[10:21:10.464]         }
[10:21:10.464]     })
[10:21:10.464]     if (TRUE) {
[10:21:10.464]         base::sink(type = "output", split = FALSE)
[10:21:10.464]         if (TRUE) {
[10:21:10.464]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.464]         }
[10:21:10.464]         else {
[10:21:10.464]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.464]         }
[10:21:10.464]         base::close(...future.stdout)
[10:21:10.464]         ...future.stdout <- NULL
[10:21:10.464]     }
[10:21:10.464]     ...future.result$conditions <- ...future.conditions
[10:21:10.464]     ...future.result$finished <- base::Sys.time()
[10:21:10.464]     ...future.result
[10:21:10.464] }
[10:21:10.466] plan(): Setting new future strategy stack:
[10:21:10.466] List of future strategies:
[10:21:10.466] 1. sequential:
[10:21:10.466]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.466]    - tweaked: FALSE
[10:21:10.466]    - call: NULL
[10:21:10.467] plan(): nbrOfWorkers() = 1
[10:21:10.467] plan(): Setting new future strategy stack:
[10:21:10.467] List of future strategies:
[10:21:10.467] 1. sequential:
[10:21:10.467]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.467]    - tweaked: FALSE
[10:21:10.467]    - call: plan(strategy)
[10:21:10.468] plan(): nbrOfWorkers() = 1
[10:21:10.468] SequentialFuture started (and completed)
[10:21:10.468] - Launch lazy future ... done
[10:21:10.468] run() for ‘SequentialFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[10:21:10.470] signalConditions() ...
[10:21:10.470]  - include = ‘immediateCondition’
[10:21:10.470]  - exclude = 
[10:21:10.470]  - resignal = FALSE
[10:21:10.470]  - Number of conditions: 1
[10:21:10.470] signalConditions() ... done
[10:21:10.470] Future state: ‘finished’
[10:21:10.470] signalConditions() ...
[10:21:10.470]  - include = ‘condition’
[10:21:10.470]  - exclude = ‘immediateCondition’
[10:21:10.470]  - resignal = TRUE
[10:21:10.470]  - Number of conditions: 1
[10:21:10.471]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:10.471] signalConditions() ... done
v3: <simpleError> (as expect)
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[10:21:10.471] getGlobalsAndPackages() ...
[10:21:10.471] Searching for globals...
[10:21:10.471] 
[10:21:10.472] Searching for globals ... DONE
[10:21:10.472] - globals: [0] <none>
[10:21:10.472] getGlobalsAndPackages() ... DONE
[10:21:10.472] run() for ‘Future’ ...
[10:21:10.472] - state: ‘created’
[10:21:10.472] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:10.472] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:10.472] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:10.473]   - Field: ‘label’
[10:21:10.473]   - Field: ‘local’
[10:21:10.474]   - Field: ‘owner’
[10:21:10.474]   - Field: ‘envir’
[10:21:10.474]   - Field: ‘packages’
[10:21:10.474]   - Field: ‘gc’
[10:21:10.474]   - Field: ‘conditions’
[10:21:10.475]   - Field: ‘expr’
[10:21:10.475]   - Field: ‘uuid’
[10:21:10.475]   - Field: ‘seed’
[10:21:10.475]   - Field: ‘version’
[10:21:10.475]   - Field: ‘result’
[10:21:10.475]   - Field: ‘asynchronous’
[10:21:10.475]   - Field: ‘calls’
[10:21:10.475]   - Field: ‘globals’
[10:21:10.475]   - Field: ‘stdout’
[10:21:10.475]   - Field: ‘earlySignal’
[10:21:10.475]   - Field: ‘lazy’
[10:21:10.476]   - Field: ‘state’
[10:21:10.476] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:10.476] - Launch lazy future ...
[10:21:10.476] Packages needed by the future expression (n = 0): <none>
[10:21:10.476] Packages needed by future strategies (n = 0): <none>
[10:21:10.476] {
[10:21:10.476]     {
[10:21:10.476]         {
[10:21:10.476]             ...future.startTime <- base::Sys.time()
[10:21:10.476]             {
[10:21:10.476]                 {
[10:21:10.476]                   {
[10:21:10.476]                     base::local({
[10:21:10.476]                       has_future <- base::requireNamespace("future", 
[10:21:10.476]                         quietly = TRUE)
[10:21:10.476]                       if (has_future) {
[10:21:10.476]                         ns <- base::getNamespace("future")
[10:21:10.476]                         version <- ns[[".package"]][["version"]]
[10:21:10.476]                         if (is.null(version)) 
[10:21:10.476]                           version <- utils::packageVersion("future")
[10:21:10.476]                       }
[10:21:10.476]                       else {
[10:21:10.476]                         version <- NULL
[10:21:10.476]                       }
[10:21:10.476]                       if (!has_future || version < "1.8.0") {
[10:21:10.476]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.476]                           "", base::R.version$version.string), 
[10:21:10.476]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:10.476]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.476]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.476]                             "release", "version")], collapse = " "), 
[10:21:10.476]                           hostname = base::Sys.info()[["nodename"]])
[10:21:10.476]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.476]                           info)
[10:21:10.476]                         info <- base::paste(info, collapse = "; ")
[10:21:10.476]                         if (!has_future) {
[10:21:10.476]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.476]                             info)
[10:21:10.476]                         }
[10:21:10.476]                         else {
[10:21:10.476]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.476]                             info, version)
[10:21:10.476]                         }
[10:21:10.476]                         base::stop(msg)
[10:21:10.476]                       }
[10:21:10.476]                     })
[10:21:10.476]                   }
[10:21:10.476]                   ...future.strategy.old <- future::plan("list")
[10:21:10.476]                   options(future.plan = NULL)
[10:21:10.476]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.476]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.476]                 }
[10:21:10.476]                 ...future.workdir <- getwd()
[10:21:10.476]             }
[10:21:10.476]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.476]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.476]         }
[10:21:10.476]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.476]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.476]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.476]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.476]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.476]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.476]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.476]             base::names(...future.oldOptions))
[10:21:10.476]     }
[10:21:10.476]     if (FALSE) {
[10:21:10.476]     }
[10:21:10.476]     else {
[10:21:10.476]         if (TRUE) {
[10:21:10.476]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.476]                 open = "w")
[10:21:10.476]         }
[10:21:10.476]         else {
[10:21:10.476]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.476]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.476]         }
[10:21:10.476]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.476]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.476]             base::sink(type = "output", split = FALSE)
[10:21:10.476]             base::close(...future.stdout)
[10:21:10.476]         }, add = TRUE)
[10:21:10.476]     }
[10:21:10.476]     ...future.frame <- base::sys.nframe()
[10:21:10.476]     ...future.conditions <- base::list()
[10:21:10.476]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.476]     if (FALSE) {
[10:21:10.476]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.476]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.476]     }
[10:21:10.476]     ...future.result <- base::tryCatch({
[10:21:10.476]         base::withCallingHandlers({
[10:21:10.476]             ...future.value <- base::withVisible(base::local(1))
[10:21:10.476]             future::FutureResult(value = ...future.value$value, 
[10:21:10.476]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.476]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.476]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.476]                     ...future.globalenv.names))
[10:21:10.476]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.476]         }, condition = base::local({
[10:21:10.476]             c <- base::c
[10:21:10.476]             inherits <- base::inherits
[10:21:10.476]             invokeRestart <- base::invokeRestart
[10:21:10.476]             length <- base::length
[10:21:10.476]             list <- base::list
[10:21:10.476]             seq.int <- base::seq.int
[10:21:10.476]             signalCondition <- base::signalCondition
[10:21:10.476]             sys.calls <- base::sys.calls
[10:21:10.476]             `[[` <- base::`[[`
[10:21:10.476]             `+` <- base::`+`
[10:21:10.476]             `<<-` <- base::`<<-`
[10:21:10.476]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.476]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.476]                   3L)]
[10:21:10.476]             }
[10:21:10.476]             function(cond) {
[10:21:10.476]                 is_error <- inherits(cond, "error")
[10:21:10.476]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.476]                   NULL)
[10:21:10.476]                 if (is_error) {
[10:21:10.476]                   sessionInformation <- function() {
[10:21:10.476]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.476]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.476]                       search = base::search(), system = base::Sys.info())
[10:21:10.476]                   }
[10:21:10.476]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.476]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.476]                     cond$call), session = sessionInformation(), 
[10:21:10.476]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.476]                   signalCondition(cond)
[10:21:10.476]                 }
[10:21:10.476]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.476]                 "immediateCondition"))) {
[10:21:10.476]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.476]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.476]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.476]                   if (TRUE && !signal) {
[10:21:10.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.476]                     {
[10:21:10.476]                       inherits <- base::inherits
[10:21:10.476]                       invokeRestart <- base::invokeRestart
[10:21:10.476]                       is.null <- base::is.null
[10:21:10.476]                       muffled <- FALSE
[10:21:10.476]                       if (inherits(cond, "message")) {
[10:21:10.476]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.476]                         if (muffled) 
[10:21:10.476]                           invokeRestart("muffleMessage")
[10:21:10.476]                       }
[10:21:10.476]                       else if (inherits(cond, "warning")) {
[10:21:10.476]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.476]                         if (muffled) 
[10:21:10.476]                           invokeRestart("muffleWarning")
[10:21:10.476]                       }
[10:21:10.476]                       else if (inherits(cond, "condition")) {
[10:21:10.476]                         if (!is.null(pattern)) {
[10:21:10.476]                           computeRestarts <- base::computeRestarts
[10:21:10.476]                           grepl <- base::grepl
[10:21:10.476]                           restarts <- computeRestarts(cond)
[10:21:10.476]                           for (restart in restarts) {
[10:21:10.476]                             name <- restart$name
[10:21:10.476]                             if (is.null(name)) 
[10:21:10.476]                               next
[10:21:10.476]                             if (!grepl(pattern, name)) 
[10:21:10.476]                               next
[10:21:10.476]                             invokeRestart(restart)
[10:21:10.476]                             muffled <- TRUE
[10:21:10.476]                             break
[10:21:10.476]                           }
[10:21:10.476]                         }
[10:21:10.476]                       }
[10:21:10.476]                       invisible(muffled)
[10:21:10.476]                     }
[10:21:10.476]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.476]                   }
[10:21:10.476]                 }
[10:21:10.476]                 else {
[10:21:10.476]                   if (TRUE) {
[10:21:10.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.476]                     {
[10:21:10.476]                       inherits <- base::inherits
[10:21:10.476]                       invokeRestart <- base::invokeRestart
[10:21:10.476]                       is.null <- base::is.null
[10:21:10.476]                       muffled <- FALSE
[10:21:10.476]                       if (inherits(cond, "message")) {
[10:21:10.476]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.476]                         if (muffled) 
[10:21:10.476]                           invokeRestart("muffleMessage")
[10:21:10.476]                       }
[10:21:10.476]                       else if (inherits(cond, "warning")) {
[10:21:10.476]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.476]                         if (muffled) 
[10:21:10.476]                           invokeRestart("muffleWarning")
[10:21:10.476]                       }
[10:21:10.476]                       else if (inherits(cond, "condition")) {
[10:21:10.476]                         if (!is.null(pattern)) {
[10:21:10.476]                           computeRestarts <- base::computeRestarts
[10:21:10.476]                           grepl <- base::grepl
[10:21:10.476]                           restarts <- computeRestarts(cond)
[10:21:10.476]                           for (restart in restarts) {
[10:21:10.476]                             name <- restart$name
[10:21:10.476]                             if (is.null(name)) 
[10:21:10.476]                               next
[10:21:10.476]                             if (!grepl(pattern, name)) 
[10:21:10.476]                               next
[10:21:10.476]                             invokeRestart(restart)
[10:21:10.476]                             muffled <- TRUE
[10:21:10.476]                             break
[10:21:10.476]                           }
[10:21:10.476]                         }
[10:21:10.476]                       }
[10:21:10.476]                       invisible(muffled)
[10:21:10.476]                     }
[10:21:10.476]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.476]                   }
[10:21:10.476]                 }
[10:21:10.476]             }
[10:21:10.476]         }))
[10:21:10.476]     }, error = function(ex) {
[10:21:10.476]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.476]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.476]                 ...future.rng), started = ...future.startTime, 
[10:21:10.476]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.476]             version = "1.8"), class = "FutureResult")
[10:21:10.476]     }, finally = {
[10:21:10.476]         if (!identical(...future.workdir, getwd())) 
[10:21:10.476]             setwd(...future.workdir)
[10:21:10.476]         {
[10:21:10.476]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.476]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.476]             }
[10:21:10.476]             base::options(...future.oldOptions)
[10:21:10.476]             if (.Platform$OS.type == "windows") {
[10:21:10.476]                 old_names <- names(...future.oldEnvVars)
[10:21:10.476]                 envs <- base::Sys.getenv()
[10:21:10.476]                 names <- names(envs)
[10:21:10.476]                 common <- intersect(names, old_names)
[10:21:10.476]                 added <- setdiff(names, old_names)
[10:21:10.476]                 removed <- setdiff(old_names, names)
[10:21:10.476]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.476]                   envs[common]]
[10:21:10.476]                 NAMES <- toupper(changed)
[10:21:10.476]                 args <- list()
[10:21:10.476]                 for (kk in seq_along(NAMES)) {
[10:21:10.476]                   name <- changed[[kk]]
[10:21:10.476]                   NAME <- NAMES[[kk]]
[10:21:10.476]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.476]                     next
[10:21:10.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.476]                 }
[10:21:10.476]                 NAMES <- toupper(added)
[10:21:10.476]                 for (kk in seq_along(NAMES)) {
[10:21:10.476]                   name <- added[[kk]]
[10:21:10.476]                   NAME <- NAMES[[kk]]
[10:21:10.476]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.476]                     next
[10:21:10.476]                   args[[name]] <- ""
[10:21:10.476]                 }
[10:21:10.476]                 NAMES <- toupper(removed)
[10:21:10.476]                 for (kk in seq_along(NAMES)) {
[10:21:10.476]                   name <- removed[[kk]]
[10:21:10.476]                   NAME <- NAMES[[kk]]
[10:21:10.476]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.476]                     next
[10:21:10.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.476]                 }
[10:21:10.476]                 if (length(args) > 0) 
[10:21:10.476]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.476]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.476]             }
[10:21:10.476]             else {
[10:21:10.476]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.476]             }
[10:21:10.476]             {
[10:21:10.476]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.476]                   0L) {
[10:21:10.476]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.476]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.476]                   base::options(opts)
[10:21:10.476]                 }
[10:21:10.476]                 {
[10:21:10.476]                   {
[10:21:10.476]                     NULL
[10:21:10.476]                     RNGkind("Mersenne-Twister")
[10:21:10.476]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:10.476]                       inherits = FALSE)
[10:21:10.476]                   }
[10:21:10.476]                   options(future.plan = NULL)
[10:21:10.476]                   if (is.na(NA_character_)) 
[10:21:10.476]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.476]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.476]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.476]                     .init = FALSE)
[10:21:10.476]                 }
[10:21:10.476]             }
[10:21:10.476]         }
[10:21:10.476]     })
[10:21:10.476]     if (TRUE) {
[10:21:10.476]         base::sink(type = "output", split = FALSE)
[10:21:10.476]         if (TRUE) {
[10:21:10.476]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.476]         }
[10:21:10.476]         else {
[10:21:10.476]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.476]         }
[10:21:10.476]         base::close(...future.stdout)
[10:21:10.476]         ...future.stdout <- NULL
[10:21:10.476]     }
[10:21:10.476]     ...future.result$conditions <- ...future.conditions
[10:21:10.476]     ...future.result$finished <- base::Sys.time()
[10:21:10.476]     ...future.result
[10:21:10.476] }
[10:21:10.478] plan(): Setting new future strategy stack:
[10:21:10.478] List of future strategies:
[10:21:10.478] 1. sequential:
[10:21:10.478]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.478]    - tweaked: FALSE
[10:21:10.478]    - call: NULL
[10:21:10.479] plan(): nbrOfWorkers() = 1
[10:21:10.479] plan(): Setting new future strategy stack:
[10:21:10.479] List of future strategies:
[10:21:10.479] 1. sequential:
[10:21:10.479]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.479]    - tweaked: FALSE
[10:21:10.479]    - call: plan(strategy)
[10:21:10.480] plan(): nbrOfWorkers() = 1
[10:21:10.480] SequentialFuture started (and completed)
[10:21:10.480] - Launch lazy future ... done
[10:21:10.480] run() for ‘SequentialFuture’ ... done
c = 1
[10:21:10.481] getGlobalsAndPackages() ...
[10:21:10.481] Searching for globals...
[10:21:10.481] 
[10:21:10.481] Searching for globals ... DONE
[10:21:10.481] - globals: [0] <none>
[10:21:10.481] getGlobalsAndPackages() ... DONE
[10:21:10.482] run() for ‘Future’ ...
[10:21:10.482] - state: ‘created’
[10:21:10.482] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:10.482] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:10.482] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:10.482]   - Field: ‘label’
[10:21:10.482]   - Field: ‘local’
[10:21:10.482]   - Field: ‘owner’
[10:21:10.482]   - Field: ‘envir’
[10:21:10.483]   - Field: ‘packages’
[10:21:10.483]   - Field: ‘gc’
[10:21:10.483]   - Field: ‘conditions’
[10:21:10.483]   - Field: ‘expr’
[10:21:10.483]   - Field: ‘uuid’
[10:21:10.483]   - Field: ‘seed’
[10:21:10.483]   - Field: ‘version’
[10:21:10.483]   - Field: ‘result’
[10:21:10.483]   - Field: ‘asynchronous’
[10:21:10.483]   - Field: ‘calls’
[10:21:10.483]   - Field: ‘globals’
[10:21:10.484]   - Field: ‘stdout’
[10:21:10.484]   - Field: ‘earlySignal’
[10:21:10.484]   - Field: ‘lazy’
[10:21:10.484]   - Field: ‘state’
[10:21:10.484] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:10.484] - Launch lazy future ...
[10:21:10.484] Packages needed by the future expression (n = 0): <none>
[10:21:10.484] Packages needed by future strategies (n = 0): <none>
[10:21:10.485] {
[10:21:10.485]     {
[10:21:10.485]         {
[10:21:10.485]             ...future.startTime <- base::Sys.time()
[10:21:10.485]             {
[10:21:10.485]                 {
[10:21:10.485]                   {
[10:21:10.485]                     base::local({
[10:21:10.485]                       has_future <- base::requireNamespace("future", 
[10:21:10.485]                         quietly = TRUE)
[10:21:10.485]                       if (has_future) {
[10:21:10.485]                         ns <- base::getNamespace("future")
[10:21:10.485]                         version <- ns[[".package"]][["version"]]
[10:21:10.485]                         if (is.null(version)) 
[10:21:10.485]                           version <- utils::packageVersion("future")
[10:21:10.485]                       }
[10:21:10.485]                       else {
[10:21:10.485]                         version <- NULL
[10:21:10.485]                       }
[10:21:10.485]                       if (!has_future || version < "1.8.0") {
[10:21:10.485]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.485]                           "", base::R.version$version.string), 
[10:21:10.485]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:10.485]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.485]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.485]                             "release", "version")], collapse = " "), 
[10:21:10.485]                           hostname = base::Sys.info()[["nodename"]])
[10:21:10.485]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.485]                           info)
[10:21:10.485]                         info <- base::paste(info, collapse = "; ")
[10:21:10.485]                         if (!has_future) {
[10:21:10.485]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.485]                             info)
[10:21:10.485]                         }
[10:21:10.485]                         else {
[10:21:10.485]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.485]                             info, version)
[10:21:10.485]                         }
[10:21:10.485]                         base::stop(msg)
[10:21:10.485]                       }
[10:21:10.485]                     })
[10:21:10.485]                   }
[10:21:10.485]                   ...future.strategy.old <- future::plan("list")
[10:21:10.485]                   options(future.plan = NULL)
[10:21:10.485]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.485]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.485]                 }
[10:21:10.485]                 ...future.workdir <- getwd()
[10:21:10.485]             }
[10:21:10.485]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.485]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.485]         }
[10:21:10.485]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.485]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.485]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.485]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.485]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.485]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.485]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.485]             base::names(...future.oldOptions))
[10:21:10.485]     }
[10:21:10.485]     if (FALSE) {
[10:21:10.485]     }
[10:21:10.485]     else {
[10:21:10.485]         if (TRUE) {
[10:21:10.485]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.485]                 open = "w")
[10:21:10.485]         }
[10:21:10.485]         else {
[10:21:10.485]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.485]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.485]         }
[10:21:10.485]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.485]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.485]             base::sink(type = "output", split = FALSE)
[10:21:10.485]             base::close(...future.stdout)
[10:21:10.485]         }, add = TRUE)
[10:21:10.485]     }
[10:21:10.485]     ...future.frame <- base::sys.nframe()
[10:21:10.485]     ...future.conditions <- base::list()
[10:21:10.485]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.485]     if (FALSE) {
[10:21:10.485]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.485]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.485]     }
[10:21:10.485]     ...future.result <- base::tryCatch({
[10:21:10.485]         base::withCallingHandlers({
[10:21:10.485]             ...future.value <- base::withVisible(base::local(1))
[10:21:10.485]             future::FutureResult(value = ...future.value$value, 
[10:21:10.485]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.485]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.485]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.485]                     ...future.globalenv.names))
[10:21:10.485]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.485]         }, condition = base::local({
[10:21:10.485]             c <- base::c
[10:21:10.485]             inherits <- base::inherits
[10:21:10.485]             invokeRestart <- base::invokeRestart
[10:21:10.485]             length <- base::length
[10:21:10.485]             list <- base::list
[10:21:10.485]             seq.int <- base::seq.int
[10:21:10.485]             signalCondition <- base::signalCondition
[10:21:10.485]             sys.calls <- base::sys.calls
[10:21:10.485]             `[[` <- base::`[[`
[10:21:10.485]             `+` <- base::`+`
[10:21:10.485]             `<<-` <- base::`<<-`
[10:21:10.485]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.485]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.485]                   3L)]
[10:21:10.485]             }
[10:21:10.485]             function(cond) {
[10:21:10.485]                 is_error <- inherits(cond, "error")
[10:21:10.485]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.485]                   NULL)
[10:21:10.485]                 if (is_error) {
[10:21:10.485]                   sessionInformation <- function() {
[10:21:10.485]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.485]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.485]                       search = base::search(), system = base::Sys.info())
[10:21:10.485]                   }
[10:21:10.485]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.485]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.485]                     cond$call), session = sessionInformation(), 
[10:21:10.485]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.485]                   signalCondition(cond)
[10:21:10.485]                 }
[10:21:10.485]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.485]                 "immediateCondition"))) {
[10:21:10.485]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.485]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.485]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.485]                   if (TRUE && !signal) {
[10:21:10.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.485]                     {
[10:21:10.485]                       inherits <- base::inherits
[10:21:10.485]                       invokeRestart <- base::invokeRestart
[10:21:10.485]                       is.null <- base::is.null
[10:21:10.485]                       muffled <- FALSE
[10:21:10.485]                       if (inherits(cond, "message")) {
[10:21:10.485]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.485]                         if (muffled) 
[10:21:10.485]                           invokeRestart("muffleMessage")
[10:21:10.485]                       }
[10:21:10.485]                       else if (inherits(cond, "warning")) {
[10:21:10.485]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.485]                         if (muffled) 
[10:21:10.485]                           invokeRestart("muffleWarning")
[10:21:10.485]                       }
[10:21:10.485]                       else if (inherits(cond, "condition")) {
[10:21:10.485]                         if (!is.null(pattern)) {
[10:21:10.485]                           computeRestarts <- base::computeRestarts
[10:21:10.485]                           grepl <- base::grepl
[10:21:10.485]                           restarts <- computeRestarts(cond)
[10:21:10.485]                           for (restart in restarts) {
[10:21:10.485]                             name <- restart$name
[10:21:10.485]                             if (is.null(name)) 
[10:21:10.485]                               next
[10:21:10.485]                             if (!grepl(pattern, name)) 
[10:21:10.485]                               next
[10:21:10.485]                             invokeRestart(restart)
[10:21:10.485]                             muffled <- TRUE
[10:21:10.485]                             break
[10:21:10.485]                           }
[10:21:10.485]                         }
[10:21:10.485]                       }
[10:21:10.485]                       invisible(muffled)
[10:21:10.485]                     }
[10:21:10.485]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.485]                   }
[10:21:10.485]                 }
[10:21:10.485]                 else {
[10:21:10.485]                   if (TRUE) {
[10:21:10.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.485]                     {
[10:21:10.485]                       inherits <- base::inherits
[10:21:10.485]                       invokeRestart <- base::invokeRestart
[10:21:10.485]                       is.null <- base::is.null
[10:21:10.485]                       muffled <- FALSE
[10:21:10.485]                       if (inherits(cond, "message")) {
[10:21:10.485]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.485]                         if (muffled) 
[10:21:10.485]                           invokeRestart("muffleMessage")
[10:21:10.485]                       }
[10:21:10.485]                       else if (inherits(cond, "warning")) {
[10:21:10.485]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.485]                         if (muffled) 
[10:21:10.485]                           invokeRestart("muffleWarning")
[10:21:10.485]                       }
[10:21:10.485]                       else if (inherits(cond, "condition")) {
[10:21:10.485]                         if (!is.null(pattern)) {
[10:21:10.485]                           computeRestarts <- base::computeRestarts
[10:21:10.485]                           grepl <- base::grepl
[10:21:10.485]                           restarts <- computeRestarts(cond)
[10:21:10.485]                           for (restart in restarts) {
[10:21:10.485]                             name <- restart$name
[10:21:10.485]                             if (is.null(name)) 
[10:21:10.485]                               next
[10:21:10.485]                             if (!grepl(pattern, name)) 
[10:21:10.485]                               next
[10:21:10.485]                             invokeRestart(restart)
[10:21:10.485]                             muffled <- TRUE
[10:21:10.485]                             break
[10:21:10.485]                           }
[10:21:10.485]                         }
[10:21:10.485]                       }
[10:21:10.485]                       invisible(muffled)
[10:21:10.485]                     }
[10:21:10.485]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.485]                   }
[10:21:10.485]                 }
[10:21:10.485]             }
[10:21:10.485]         }))
[10:21:10.485]     }, error = function(ex) {
[10:21:10.485]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.485]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.485]                 ...future.rng), started = ...future.startTime, 
[10:21:10.485]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.485]             version = "1.8"), class = "FutureResult")
[10:21:10.485]     }, finally = {
[10:21:10.485]         if (!identical(...future.workdir, getwd())) 
[10:21:10.485]             setwd(...future.workdir)
[10:21:10.485]         {
[10:21:10.485]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.485]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.485]             }
[10:21:10.485]             base::options(...future.oldOptions)
[10:21:10.485]             if (.Platform$OS.type == "windows") {
[10:21:10.485]                 old_names <- names(...future.oldEnvVars)
[10:21:10.485]                 envs <- base::Sys.getenv()
[10:21:10.485]                 names <- names(envs)
[10:21:10.485]                 common <- intersect(names, old_names)
[10:21:10.485]                 added <- setdiff(names, old_names)
[10:21:10.485]                 removed <- setdiff(old_names, names)
[10:21:10.485]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.485]                   envs[common]]
[10:21:10.485]                 NAMES <- toupper(changed)
[10:21:10.485]                 args <- list()
[10:21:10.485]                 for (kk in seq_along(NAMES)) {
[10:21:10.485]                   name <- changed[[kk]]
[10:21:10.485]                   NAME <- NAMES[[kk]]
[10:21:10.485]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.485]                     next
[10:21:10.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.485]                 }
[10:21:10.485]                 NAMES <- toupper(added)
[10:21:10.485]                 for (kk in seq_along(NAMES)) {
[10:21:10.485]                   name <- added[[kk]]
[10:21:10.485]                   NAME <- NAMES[[kk]]
[10:21:10.485]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.485]                     next
[10:21:10.485]                   args[[name]] <- ""
[10:21:10.485]                 }
[10:21:10.485]                 NAMES <- toupper(removed)
[10:21:10.485]                 for (kk in seq_along(NAMES)) {
[10:21:10.485]                   name <- removed[[kk]]
[10:21:10.485]                   NAME <- NAMES[[kk]]
[10:21:10.485]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.485]                     next
[10:21:10.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.485]                 }
[10:21:10.485]                 if (length(args) > 0) 
[10:21:10.485]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.485]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.485]             }
[10:21:10.485]             else {
[10:21:10.485]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.485]             }
[10:21:10.485]             {
[10:21:10.485]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.485]                   0L) {
[10:21:10.485]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.485]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.485]                   base::options(opts)
[10:21:10.485]                 }
[10:21:10.485]                 {
[10:21:10.485]                   {
[10:21:10.485]                     NULL
[10:21:10.485]                     RNGkind("Mersenne-Twister")
[10:21:10.485]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:10.485]                       inherits = FALSE)
[10:21:10.485]                   }
[10:21:10.485]                   options(future.plan = NULL)
[10:21:10.485]                   if (is.na(NA_character_)) 
[10:21:10.485]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.485]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.485]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.485]                     .init = FALSE)
[10:21:10.485]                 }
[10:21:10.485]             }
[10:21:10.485]         }
[10:21:10.485]     })
[10:21:10.485]     if (TRUE) {
[10:21:10.485]         base::sink(type = "output", split = FALSE)
[10:21:10.485]         if (TRUE) {
[10:21:10.485]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.485]         }
[10:21:10.485]         else {
[10:21:10.485]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.485]         }
[10:21:10.485]         base::close(...future.stdout)
[10:21:10.485]         ...future.stdout <- NULL
[10:21:10.485]     }
[10:21:10.485]     ...future.result$conditions <- ...future.conditions
[10:21:10.485]     ...future.result$finished <- base::Sys.time()
[10:21:10.485]     ...future.result
[10:21:10.485] }
[10:21:10.487] plan(): Setting new future strategy stack:
[10:21:10.487] List of future strategies:
[10:21:10.487] 1. sequential:
[10:21:10.487]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.487]    - tweaked: FALSE
[10:21:10.487]    - call: NULL
[10:21:10.487] plan(): nbrOfWorkers() = 1
[10:21:10.488] plan(): Setting new future strategy stack:
[10:21:10.488] List of future strategies:
[10:21:10.488] 1. sequential:
[10:21:10.488]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.488]    - tweaked: FALSE
[10:21:10.488]    - call: plan(strategy)
[10:21:10.488] plan(): nbrOfWorkers() = 1
[10:21:10.489] SequentialFuture started (and completed)
[10:21:10.489] - Launch lazy future ... done
[10:21:10.489] run() for ‘SequentialFuture’ ... done
d = 1
** Nested future assignments
[10:21:10.489] getGlobalsAndPackages() ...
[10:21:10.489] Searching for globals...
[10:21:10.493] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[10:21:10.493] Searching for globals ... DONE
[10:21:10.493] Resolving globals: FALSE
[10:21:10.493] 
[10:21:10.494] - packages: [1] ‘future’
[10:21:10.494] getGlobalsAndPackages() ... DONE
[10:21:10.494] run() for ‘Future’ ...
[10:21:10.494] - state: ‘created’
[10:21:10.494] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:10.494] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:10.495] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:10.495]   - Field: ‘label’
[10:21:10.495]   - Field: ‘local’
[10:21:10.495]   - Field: ‘owner’
[10:21:10.495]   - Field: ‘envir’
[10:21:10.495]   - Field: ‘packages’
[10:21:10.495]   - Field: ‘gc’
[10:21:10.495]   - Field: ‘conditions’
[10:21:10.495]   - Field: ‘expr’
[10:21:10.495]   - Field: ‘uuid’
[10:21:10.495]   - Field: ‘seed’
[10:21:10.496]   - Field: ‘version’
[10:21:10.496]   - Field: ‘result’
[10:21:10.496]   - Field: ‘asynchronous’
[10:21:10.496]   - Field: ‘calls’
[10:21:10.496]   - Field: ‘globals’
[10:21:10.496]   - Field: ‘stdout’
[10:21:10.496]   - Field: ‘earlySignal’
[10:21:10.496]   - Field: ‘lazy’
[10:21:10.496]   - Field: ‘state’
[10:21:10.496] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:10.496] - Launch lazy future ...
[10:21:10.497] Packages needed by the future expression (n = 1): ‘future’
[10:21:10.497] Packages needed by future strategies (n = 0): <none>
[10:21:10.497] {
[10:21:10.497]     {
[10:21:10.497]         {
[10:21:10.497]             ...future.startTime <- base::Sys.time()
[10:21:10.497]             {
[10:21:10.497]                 {
[10:21:10.497]                   {
[10:21:10.497]                     {
[10:21:10.497]                       base::local({
[10:21:10.497]                         has_future <- base::requireNamespace("future", 
[10:21:10.497]                           quietly = TRUE)
[10:21:10.497]                         if (has_future) {
[10:21:10.497]                           ns <- base::getNamespace("future")
[10:21:10.497]                           version <- ns[[".package"]][["version"]]
[10:21:10.497]                           if (is.null(version)) 
[10:21:10.497]                             version <- utils::packageVersion("future")
[10:21:10.497]                         }
[10:21:10.497]                         else {
[10:21:10.497]                           version <- NULL
[10:21:10.497]                         }
[10:21:10.497]                         if (!has_future || version < "1.8.0") {
[10:21:10.497]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.497]                             "", base::R.version$version.string), 
[10:21:10.497]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:10.497]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.497]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.497]                               "release", "version")], collapse = " "), 
[10:21:10.497]                             hostname = base::Sys.info()[["nodename"]])
[10:21:10.497]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.497]                             info)
[10:21:10.497]                           info <- base::paste(info, collapse = "; ")
[10:21:10.497]                           if (!has_future) {
[10:21:10.497]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.497]                               info)
[10:21:10.497]                           }
[10:21:10.497]                           else {
[10:21:10.497]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.497]                               info, version)
[10:21:10.497]                           }
[10:21:10.497]                           base::stop(msg)
[10:21:10.497]                         }
[10:21:10.497]                       })
[10:21:10.497]                     }
[10:21:10.497]                     base::local({
[10:21:10.497]                       for (pkg in "future") {
[10:21:10.497]                         base::loadNamespace(pkg)
[10:21:10.497]                         base::library(pkg, character.only = TRUE)
[10:21:10.497]                       }
[10:21:10.497]                     })
[10:21:10.497]                   }
[10:21:10.497]                   ...future.strategy.old <- future::plan("list")
[10:21:10.497]                   options(future.plan = NULL)
[10:21:10.497]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.497]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.497]                 }
[10:21:10.497]                 ...future.workdir <- getwd()
[10:21:10.497]             }
[10:21:10.497]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.497]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.497]         }
[10:21:10.497]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.497]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.497]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.497]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.497]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.497]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.497]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.497]             base::names(...future.oldOptions))
[10:21:10.497]     }
[10:21:10.497]     if (FALSE) {
[10:21:10.497]     }
[10:21:10.497]     else {
[10:21:10.497]         if (TRUE) {
[10:21:10.497]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.497]                 open = "w")
[10:21:10.497]         }
[10:21:10.497]         else {
[10:21:10.497]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.497]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.497]         }
[10:21:10.497]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.497]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.497]             base::sink(type = "output", split = FALSE)
[10:21:10.497]             base::close(...future.stdout)
[10:21:10.497]         }, add = TRUE)
[10:21:10.497]     }
[10:21:10.497]     ...future.frame <- base::sys.nframe()
[10:21:10.497]     ...future.conditions <- base::list()
[10:21:10.497]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.497]     if (FALSE) {
[10:21:10.497]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.497]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.497]     }
[10:21:10.497]     ...future.result <- base::tryCatch({
[10:21:10.497]         base::withCallingHandlers({
[10:21:10.497]             ...future.value <- base::withVisible(base::local({
[10:21:10.497]                 b <- 1
[10:21:10.497]                 c %<-% 2
[10:21:10.497]                 d <- 3
[10:21:10.497]                 4 %->% e
[10:21:10.497]                 b + c + d + e
[10:21:10.497]             }))
[10:21:10.497]             future::FutureResult(value = ...future.value$value, 
[10:21:10.497]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.497]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.497]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.497]                     ...future.globalenv.names))
[10:21:10.497]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.497]         }, condition = base::local({
[10:21:10.497]             c <- base::c
[10:21:10.497]             inherits <- base::inherits
[10:21:10.497]             invokeRestart <- base::invokeRestart
[10:21:10.497]             length <- base::length
[10:21:10.497]             list <- base::list
[10:21:10.497]             seq.int <- base::seq.int
[10:21:10.497]             signalCondition <- base::signalCondition
[10:21:10.497]             sys.calls <- base::sys.calls
[10:21:10.497]             `[[` <- base::`[[`
[10:21:10.497]             `+` <- base::`+`
[10:21:10.497]             `<<-` <- base::`<<-`
[10:21:10.497]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.497]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.497]                   3L)]
[10:21:10.497]             }
[10:21:10.497]             function(cond) {
[10:21:10.497]                 is_error <- inherits(cond, "error")
[10:21:10.497]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.497]                   NULL)
[10:21:10.497]                 if (is_error) {
[10:21:10.497]                   sessionInformation <- function() {
[10:21:10.497]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.497]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.497]                       search = base::search(), system = base::Sys.info())
[10:21:10.497]                   }
[10:21:10.497]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.497]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.497]                     cond$call), session = sessionInformation(), 
[10:21:10.497]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.497]                   signalCondition(cond)
[10:21:10.497]                 }
[10:21:10.497]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.497]                 "immediateCondition"))) {
[10:21:10.497]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.497]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.497]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.497]                   if (TRUE && !signal) {
[10:21:10.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.497]                     {
[10:21:10.497]                       inherits <- base::inherits
[10:21:10.497]                       invokeRestart <- base::invokeRestart
[10:21:10.497]                       is.null <- base::is.null
[10:21:10.497]                       muffled <- FALSE
[10:21:10.497]                       if (inherits(cond, "message")) {
[10:21:10.497]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.497]                         if (muffled) 
[10:21:10.497]                           invokeRestart("muffleMessage")
[10:21:10.497]                       }
[10:21:10.497]                       else if (inherits(cond, "warning")) {
[10:21:10.497]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.497]                         if (muffled) 
[10:21:10.497]                           invokeRestart("muffleWarning")
[10:21:10.497]                       }
[10:21:10.497]                       else if (inherits(cond, "condition")) {
[10:21:10.497]                         if (!is.null(pattern)) {
[10:21:10.497]                           computeRestarts <- base::computeRestarts
[10:21:10.497]                           grepl <- base::grepl
[10:21:10.497]                           restarts <- computeRestarts(cond)
[10:21:10.497]                           for (restart in restarts) {
[10:21:10.497]                             name <- restart$name
[10:21:10.497]                             if (is.null(name)) 
[10:21:10.497]                               next
[10:21:10.497]                             if (!grepl(pattern, name)) 
[10:21:10.497]                               next
[10:21:10.497]                             invokeRestart(restart)
[10:21:10.497]                             muffled <- TRUE
[10:21:10.497]                             break
[10:21:10.497]                           }
[10:21:10.497]                         }
[10:21:10.497]                       }
[10:21:10.497]                       invisible(muffled)
[10:21:10.497]                     }
[10:21:10.497]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.497]                   }
[10:21:10.497]                 }
[10:21:10.497]                 else {
[10:21:10.497]                   if (TRUE) {
[10:21:10.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.497]                     {
[10:21:10.497]                       inherits <- base::inherits
[10:21:10.497]                       invokeRestart <- base::invokeRestart
[10:21:10.497]                       is.null <- base::is.null
[10:21:10.497]                       muffled <- FALSE
[10:21:10.497]                       if (inherits(cond, "message")) {
[10:21:10.497]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.497]                         if (muffled) 
[10:21:10.497]                           invokeRestart("muffleMessage")
[10:21:10.497]                       }
[10:21:10.497]                       else if (inherits(cond, "warning")) {
[10:21:10.497]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.497]                         if (muffled) 
[10:21:10.497]                           invokeRestart("muffleWarning")
[10:21:10.497]                       }
[10:21:10.497]                       else if (inherits(cond, "condition")) {
[10:21:10.497]                         if (!is.null(pattern)) {
[10:21:10.497]                           computeRestarts <- base::computeRestarts
[10:21:10.497]                           grepl <- base::grepl
[10:21:10.497]                           restarts <- computeRestarts(cond)
[10:21:10.497]                           for (restart in restarts) {
[10:21:10.497]                             name <- restart$name
[10:21:10.497]                             if (is.null(name)) 
[10:21:10.497]                               next
[10:21:10.497]                             if (!grepl(pattern, name)) 
[10:21:10.497]                               next
[10:21:10.497]                             invokeRestart(restart)
[10:21:10.497]                             muffled <- TRUE
[10:21:10.497]                             break
[10:21:10.497]                           }
[10:21:10.497]                         }
[10:21:10.497]                       }
[10:21:10.497]                       invisible(muffled)
[10:21:10.497]                     }
[10:21:10.497]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.497]                   }
[10:21:10.497]                 }
[10:21:10.497]             }
[10:21:10.497]         }))
[10:21:10.497]     }, error = function(ex) {
[10:21:10.497]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.497]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.497]                 ...future.rng), started = ...future.startTime, 
[10:21:10.497]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.497]             version = "1.8"), class = "FutureResult")
[10:21:10.497]     }, finally = {
[10:21:10.497]         if (!identical(...future.workdir, getwd())) 
[10:21:10.497]             setwd(...future.workdir)
[10:21:10.497]         {
[10:21:10.497]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.497]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.497]             }
[10:21:10.497]             base::options(...future.oldOptions)
[10:21:10.497]             if (.Platform$OS.type == "windows") {
[10:21:10.497]                 old_names <- names(...future.oldEnvVars)
[10:21:10.497]                 envs <- base::Sys.getenv()
[10:21:10.497]                 names <- names(envs)
[10:21:10.497]                 common <- intersect(names, old_names)
[10:21:10.497]                 added <- setdiff(names, old_names)
[10:21:10.497]                 removed <- setdiff(old_names, names)
[10:21:10.497]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.497]                   envs[common]]
[10:21:10.497]                 NAMES <- toupper(changed)
[10:21:10.497]                 args <- list()
[10:21:10.497]                 for (kk in seq_along(NAMES)) {
[10:21:10.497]                   name <- changed[[kk]]
[10:21:10.497]                   NAME <- NAMES[[kk]]
[10:21:10.497]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.497]                     next
[10:21:10.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.497]                 }
[10:21:10.497]                 NAMES <- toupper(added)
[10:21:10.497]                 for (kk in seq_along(NAMES)) {
[10:21:10.497]                   name <- added[[kk]]
[10:21:10.497]                   NAME <- NAMES[[kk]]
[10:21:10.497]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.497]                     next
[10:21:10.497]                   args[[name]] <- ""
[10:21:10.497]                 }
[10:21:10.497]                 NAMES <- toupper(removed)
[10:21:10.497]                 for (kk in seq_along(NAMES)) {
[10:21:10.497]                   name <- removed[[kk]]
[10:21:10.497]                   NAME <- NAMES[[kk]]
[10:21:10.497]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.497]                     next
[10:21:10.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.497]                 }
[10:21:10.497]                 if (length(args) > 0) 
[10:21:10.497]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.497]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.497]             }
[10:21:10.497]             else {
[10:21:10.497]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.497]             }
[10:21:10.497]             {
[10:21:10.497]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.497]                   0L) {
[10:21:10.497]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.497]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.497]                   base::options(opts)
[10:21:10.497]                 }
[10:21:10.497]                 {
[10:21:10.497]                   {
[10:21:10.497]                     NULL
[10:21:10.497]                     RNGkind("Mersenne-Twister")
[10:21:10.497]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:10.497]                       inherits = FALSE)
[10:21:10.497]                   }
[10:21:10.497]                   options(future.plan = NULL)
[10:21:10.497]                   if (is.na(NA_character_)) 
[10:21:10.497]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.497]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.497]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.497]                     .init = FALSE)
[10:21:10.497]                 }
[10:21:10.497]             }
[10:21:10.497]         }
[10:21:10.497]     })
[10:21:10.497]     if (TRUE) {
[10:21:10.497]         base::sink(type = "output", split = FALSE)
[10:21:10.497]         if (TRUE) {
[10:21:10.497]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.497]         }
[10:21:10.497]         else {
[10:21:10.497]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.497]         }
[10:21:10.497]         base::close(...future.stdout)
[10:21:10.497]         ...future.stdout <- NULL
[10:21:10.497]     }
[10:21:10.497]     ...future.result$conditions <- ...future.conditions
[10:21:10.497]     ...future.result$finished <- base::Sys.time()
[10:21:10.497]     ...future.result
[10:21:10.497] }
[10:21:10.499] plan(): Setting new future strategy stack:
[10:21:10.499] List of future strategies:
[10:21:10.499] 1. sequential:
[10:21:10.499]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.499]    - tweaked: FALSE
[10:21:10.499]    - call: NULL
[10:21:10.500] plan(): nbrOfWorkers() = 1
[10:21:10.537] plan(): Setting new future strategy stack:
[10:21:10.537] List of future strategies:
[10:21:10.537] 1. sequential:
[10:21:10.537]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.537]    - tweaked: FALSE
[10:21:10.537]    - call: plan(strategy)
[10:21:10.537] plan(): nbrOfWorkers() = 1
[10:21:10.537] SequentialFuture started (and completed)
[10:21:10.538] signalConditions() ...
[10:21:10.538]  - include = ‘immediateCondition’
[10:21:10.538]  - exclude = 
[10:21:10.538]  - resignal = FALSE
[10:21:10.538]  - Number of conditions: 88
[10:21:10.538] signalConditions() ... done
[10:21:10.538] - Launch lazy future ... done
[10:21:10.538] run() for ‘SequentialFuture’ ... done
[10:21:10.538] signalConditions() ...
[10:21:10.538]  - include = ‘immediateCondition’
[10:21:10.539]  - exclude = 
[10:21:10.539]  - resignal = FALSE
[10:21:10.539]  - Number of conditions: 88
[10:21:10.539] signalConditions() ... done
[10:21:10.539] Future state: ‘finished’
[10:21:10.539] signalConditions() ...
[10:21:10.539]  - include = ‘condition’
[10:21:10.539]  - exclude = ‘immediateCondition’
[10:21:10.539]  - resignal = TRUE
[10:21:10.539]  - Number of conditions: 88
[10:21:10.539]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.500] getGlobalsAndPackages() ...
[10:21:10.540]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.500] Searching for globals...
[10:21:10.540]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.517] 
[10:21:10.540]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.517] Searching for globals ... DONE
[10:21:10.540]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.517] - globals: [0] <none>
[10:21:10.540]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.517] getGlobalsAndPackages() ... DONE
[10:21:10.540]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.517] run() for ‘Future’ ...
[10:21:10.540]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.517] - state: ‘created’
[10:21:10.540]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.518] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:10.541]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.518] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:10.541]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.518] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:10.541]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.518]   - Field: ‘label’
[10:21:10.541]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.518]   - Field: ‘local’
[10:21:10.541]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.518]   - Field: ‘owner’
[10:21:10.541]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.518]   - Field: ‘envir’
[10:21:10.541]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.519]   - Field: ‘packages’
[10:21:10.541]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.519]   - Field: ‘gc’
[10:21:10.542]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.519]   - Field: ‘conditions’
[10:21:10.542]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.519]   - Field: ‘expr’
[10:21:10.542]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.519]   - Field: ‘uuid’
[10:21:10.542]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.519]   - Field: ‘seed’
[10:21:10.542]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.519]   - Field: ‘version’
[10:21:10.542]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.519]   - Field: ‘result’
[10:21:10.542]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.519]   - Field: ‘asynchronous’
[10:21:10.542]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.520]   - Field: ‘calls’
[10:21:10.543]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.520]   - Field: ‘globals’
[10:21:10.543]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.520]   - Field: ‘stdout’
[10:21:10.543]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.520]   - Field: ‘earlySignal’
[10:21:10.543]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.520]   - Field: ‘lazy’
[10:21:10.543]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.520]   - Field: ‘state’
[10:21:10.543]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.520] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:10.543]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.520] - Launch lazy future ...
[10:21:10.543]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.520] Packages needed by the future expression (n = 0): <none>
[10:21:10.543]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.521] Packages needed by future strategies (n = 0): <none>
[10:21:10.544]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.521] {
[10:21:10.521]     {
[10:21:10.521]         {
[10:21:10.521]             ...future.startTime <- base::Sys.time()
[10:21:10.521]             {
[10:21:10.521]                 {
[10:21:10.521]                   {
[10:21:10.521]                     base::local({
[10:21:10.521]                       has_future <- base::requireNamespace("future", 
[10:21:10.521]                         quietly = TRUE)
[10:21:10.521]                       if (has_future) {
[10:21:10.521]                         ns <- base::getNamespace("future")
[10:21:10.521]                         version <- ns[[".package"]][["version"]]
[10:21:10.521]                         if (is.null(version)) 
[10:21:10.521]                           version <- utils::packageVersion("future")
[10:21:10.521]                       }
[10:21:10.521]                       else {
[10:21:10.521]                         version <- NULL
[10:21:10.521]                       }
[10:21:10.521]                       if (!has_future || version < "1.8.0") {
[10:21:10.521]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.521]                           "", base::R.version$version.string), 
[10:21:10.521]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:10.521]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.521]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.521]                             "release", "version")], collapse = " "), 
[10:21:10.521]                           hostname = base::Sys.info()[["nodename"]])
[10:21:10.521]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.521]                           info)
[10:21:10.521]                         info <- base::paste(info, collapse = "; ")
[10:21:10.521]                         if (!has_future) {
[10:21:10.521]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.521]                             info)
[10:21:10.521]                         }
[10:21:10.521]                         else {
[10:21:10.521]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.521]                             info, version)
[10:21:10.521]                         }
[10:21:10.521]                         base::stop(msg)
[10:21:10.521]                       }
[10:21:10.521]                     })
[10:21:10.521]                   }
[10:21:10.521]                   ...future.strategy.old <- future::plan("list")
[10:21:10.521]                   options(future.plan = NULL)
[10:21:10.521]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.521]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.521]                 }
[10:21:10.521]                 ...future.workdir <- getwd()
[10:21:10.521]             }
[10:21:10.521]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.521]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.521]         }
[10:21:10.521]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.521]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.521]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.521]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.521]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.521]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.521]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.521]             base::names(...future.oldOptions))
[10:21:10.521]     }
[10:21:10.521]     if (FALSE) {
[10:21:10.521]     }
[10:21:10.521]     else {
[10:21:10.521]         if (TRUE) {
[10:21:10.521]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.521]                 open = "w")
[10:21:10.521]         }
[10:21:10.521]         else {
[10:21:10.521]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.521]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.521]         }
[10:21:10.521]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.521]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.521]             base::sink(type = "output", split = FALSE)
[10:21:10.521]             base::close(...future.stdout)
[10:21:10.521]         }, add = TRUE)
[10:21:10.521]     }
[10:21:10.521]     ...future.frame <- base::sys.nframe()
[10:21:10.521]     ...future.conditions <- base::list()
[10:21:10.521]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.521]     if (FALSE) {
[10:21:10.521]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.521]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.521]     }
[10:21:10.521]     ...future.result <- base::tryCatch({
[10:21:10.521]         base::withCallingHandlers({
[10:21:10.521]             ...future.value <- base::withVisible(base::local(2))
[10:21:10.521]             future::FutureResult(value = ...future.value$value, 
[10:21:10.521]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.521]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.521]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.521]                     ...future.globalenv.names))
[10:21:10.521]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.521]         }, condition = base::local({
[10:21:10.521]             c <- base::c
[10:21:10.521]             inherits <- base::inherits
[10:21:10.521]             invokeRestart <- base::invokeRestart
[10:21:10.521]             length <- base::length
[10:21:10.521]             list <- base::list
[10:21:10.521]             seq.int <- base::seq.int
[10:21:10.521]             signalCondition <- base::signalCondition
[10:21:10.521]             sys.calls <- base::sys.calls
[10:21:10.521]             `[[` <- base::`[[`
[10:21:10.521]             `+` <- base::`+`
[10:21:10.521]             `<<-` <- base::`<<-`
[10:21:10.521]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.521]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.521]                   3L)]
[10:21:10.521]             }
[10:21:10.521]             function(cond) {
[10:21:10.521]                 is_error <- inherits(cond, "error")
[10:21:10.521]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.521]                   NULL)
[10:21:10.521]                 if (is_error) {
[10:21:10.521]                   sessionInformation <- function() {
[10:21:10.521]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.521]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.521]                       search = base::search(), system = base::Sys.info())
[10:21:10.521]                   }
[10:21:10.521]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.521]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.521]                     cond$call), session = sessionInformation(), 
[10:21:10.521]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.521]                   signalCondition(cond)
[10:21:10.521]                 }
[10:21:10.521]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.521]                 "immediateCondition"))) {
[10:21:10.521]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.521]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.521]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.521]                   if (TRUE && !signal) {
[10:21:10.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.521]                     {
[10:21:10.521]                       inherits <- base::inherits
[10:21:10.521]                       invokeRestart <- base::invokeRestart
[10:21:10.521]                       is.null <- base::is.null
[10:21:10.521]                       muffled <- FALSE
[10:21:10.521]                       if (inherits(cond, "message")) {
[10:21:10.521]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.521]                         if (muffled) 
[10:21:10.521]                           invokeRestart("muffleMessage")
[10:21:10.521]                       }
[10:21:10.521]                       else if (inherits(cond, "warning")) {
[10:21:10.521]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.521]                         if (muffled) 
[10:21:10.521]                           invokeRestart("muffleWarning")
[10:21:10.521]                       }
[10:21:10.521]                       else if (inherits(cond, "condition")) {
[10:21:10.521]                         if (!is.null(pattern)) {
[10:21:10.521]                           computeRestarts <- base::computeRestarts
[10:21:10.521]                           grepl <- base::grepl
[10:21:10.521]                           restarts <- computeRestarts(cond)
[10:21:10.521]                           for (restart in restarts) {
[10:21:10.521]                             name <- restart$name
[10:21:10.521]                             if (is.null(name)) 
[10:21:10.521]                               next
[10:21:10.521]                             if (!grepl(pattern, name)) 
[10:21:10.521]                               next
[10:21:10.521]                             invokeRestart(restart)
[10:21:10.521]                             muffled <- TRUE
[10:21:10.521]                             break
[10:21:10.521]                           }
[10:21:10.521]                         }
[10:21:10.521]                       }
[10:21:10.521]                       invisible(muffled)
[10:21:10.521]                     }
[10:21:10.521]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.521]                   }
[10:21:10.521]                 }
[10:21:10.521]                 else {
[10:21:10.521]                   if (TRUE) {
[10:21:10.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.521]                     {
[10:21:10.521]                       inherits <- base::inherits
[10:21:10.521]                       invokeRestart <- base::invokeRestart
[10:21:10.521]                       is.null <- base::is.null
[10:21:10.521]                       muffled <- FALSE
[10:21:10.521]                       if (inherits(cond, "message")) {
[10:21:10.521]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.521]                         if (muffled) 
[10:21:10.521]                           invokeRestart("muffleMessage")
[10:21:10.521]                       }
[10:21:10.521]                       else if (inherits(cond, "warning")) {
[10:21:10.521]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.521]                         if (muffled) 
[10:21:10.521]                           invokeRestart("muffleWarning")
[10:21:10.521]                       }
[10:21:10.521]                       else if (inherits(cond, "condition")) {
[10:21:10.521]                         if (!is.null(pattern)) {
[10:21:10.521]                           computeRestarts <- base::computeRestarts
[10:21:10.521]                           grepl <- base::grepl
[10:21:10.521]                           restarts <- computeRestarts(cond)
[10:21:10.521]                           for (restart in restarts) {
[10:21:10.521]                             name <- restart$name
[10:21:10.521]                             if (is.null(name)) 
[10:21:10.521]                               next
[10:21:10.521]                             if (!grepl(pattern, name)) 
[10:21:10.521]                               next
[10:21:10.521]                             invokeRestart(restart)
[10:21:10.521]                             muffled <- TRUE
[10:21:10.521]                             break
[10:21:10.521]                           }
[10:21:10.521]                         }
[10:21:10.521]                       }
[10:21:10.521]                       invisible(muffled)
[10:21:10.521]                     }
[10:21:10.521]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.521]                   }
[10:21:10.521]                 }
[10:21:10.521]             }
[10:21:10.521]         }))
[10:21:10.521]     }, error = function(ex) {
[10:21:10.521]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.521]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.521]                 ...future.rng), started = ...future.startTime, 
[10:21:10.521]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.521]             version = "1.8"), class = "FutureResult")
[10:21:10.521]     }, finally = {
[10:21:10.521]         if (!identical(...future.workdir, getwd())) 
[10:21:10.521]             setwd(...future.workdir)
[10:21:10.521]         {
[10:21:10.521]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.521]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.521]             }
[10:21:10.521]             base::options(...future.oldOptions)
[10:21:10.521]             if (.Platform$OS.type == "windows") {
[10:21:10.521]                 old_names <- names(...future.oldEnvVars)
[10:21:10.521]                 envs <- base::Sys.getenv()
[10:21:10.521]                 names <- names(envs)
[10:21:10.521]                 common <- intersect(names, old_names)
[10:21:10.521]                 added <- setdiff(names, old_names)
[10:21:10.521]                 removed <- setdiff(old_names, names)
[10:21:10.521]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.521]                   envs[common]]
[10:21:10.521]                 NAMES <- toupper(changed)
[10:21:10.521]                 args <- list()
[10:21:10.521]                 for (kk in seq_along(NAMES)) {
[10:21:10.521]                   name <- changed[[kk]]
[10:21:10.521]                   NAME <- NAMES[[kk]]
[10:21:10.521]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.521]                     next
[10:21:10.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.521]                 }
[10:21:10.521]                 NAMES <- toupper(added)
[10:21:10.521]                 for (kk in seq_along(NAMES)) {
[10:21:10.521]                   name <- added[[kk]]
[10:21:10.521]                   NAME <- NAMES[[kk]]
[10:21:10.521]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.521]                     next
[10:21:10.521]                   args[[name]] <- ""
[10:21:10.521]                 }
[10:21:10.521]                 NAMES <- toupper(removed)
[10:21:10.521]                 for (kk in seq_along(NAMES)) {
[10:21:10.521]                   name <- removed[[kk]]
[10:21:10.521]                   NAME <- NAMES[[kk]]
[10:21:10.521]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.521]                     next
[10:21:10.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.521]                 }
[10:21:10.521]                 if (length(args) > 0) 
[10:21:10.521]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.521]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.521]             }
[10:21:10.521]             else {
[10:21:10.521]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.521]             }
[10:21:10.521]             {
[10:21:10.521]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.521]                   0L) {
[10:21:10.521]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.521]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.521]                   base::options(opts)
[10:21:10.521]                 }
[10:21:10.521]                 {
[10:21:10.521]                   {
[10:21:10.521]                     NULL
[10:21:10.521]                     RNGkind("Mersenne-Twister")
[10:21:10.521]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:10.521]                       inherits = FALSE)
[10:21:10.521]                   }
[10:21:10.521]                   options(future.plan = NULL)
[10:21:10.521]                   if (is.na(NA_character_)) 
[10:21:10.521]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.521]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.521]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.521]                     .init = FALSE)
[10:21:10.521]                 }
[10:21:10.521]             }
[10:21:10.521]         }
[10:21:10.521]     })
[10:21:10.521]     if (TRUE) {
[10:21:10.521]         base::sink(type = "output", split = FALSE)
[10:21:10.521]         if (TRUE) {
[10:21:10.521]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.521]         }
[10:21:10.521]         else {
[10:21:10.521]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.521]         }
[10:21:10.521]         base::close(...future.stdout)
[10:21:10.521]         ...future.stdout <- NULL
[10:21:10.521]     }
[10:21:10.521]     ...future.result$conditions <- ...future.conditions
[10:21:10.521]     ...future.result$finished <- base::Sys.time()
[10:21:10.521]     ...future.result
[10:21:10.521] }
[10:21:10.544]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.523] plan(): Setting new future strategy stack:
[10:21:10.544]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.523] List of future strategies:
[10:21:10.523] 1. sequential:
[10:21:10.523]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.523]    - tweaked: FALSE
[10:21:10.523]    - call: NULL
[10:21:10.544]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.523] plan(): nbrOfWorkers() = 1
[10:21:10.544]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.524] plan(): Setting new future strategy stack:
[10:21:10.544]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.524] List of future strategies:
[10:21:10.524] 1. sequential:
[10:21:10.524]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.524]    - tweaked: FALSE
[10:21:10.524]    - call: NULL
[10:21:10.544]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.527] plan(): nbrOfWorkers() = 1
[10:21:10.545]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.527] SequentialFuture started (and completed)
[10:21:10.545]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.527] - Launch lazy future ... done
[10:21:10.545]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.527] run() for ‘SequentialFuture’ ... done
[10:21:10.545]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.527] getGlobalsAndPackages() ...
[10:21:10.545]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.527] Searching for globals...
[10:21:10.545]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.528] 
[10:21:10.545]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.528] Searching for globals ... DONE
[10:21:10.545]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.528] - globals: [0] <none>
[10:21:10.546]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.528] getGlobalsAndPackages() ... DONE
[10:21:10.546]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.528] run() for ‘Future’ ...
[10:21:10.546]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.529] - state: ‘created’
[10:21:10.546]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.529] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:10.546]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.529] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:10.546]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.529] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:10.546]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.529]   - Field: ‘label’
[10:21:10.546]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.529]   - Field: ‘local’
[10:21:10.547]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.529]   - Field: ‘owner’
[10:21:10.547]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.530]   - Field: ‘envir’
[10:21:10.547]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.530]   - Field: ‘packages’
[10:21:10.547]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.530]   - Field: ‘gc’
[10:21:10.547]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.530]   - Field: ‘conditions’
[10:21:10.547]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.530]   - Field: ‘expr’
[10:21:10.547]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.530]   - Field: ‘uuid’
[10:21:10.547]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.530]   - Field: ‘seed’
[10:21:10.547]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.530]   - Field: ‘version’
[10:21:10.548]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.530]   - Field: ‘result’
[10:21:10.548]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.530]   - Field: ‘asynchronous’
[10:21:10.548]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.531]   - Field: ‘calls’
[10:21:10.548]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.531]   - Field: ‘globals’
[10:21:10.548]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.531]   - Field: ‘stdout’
[10:21:10.548]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.531]   - Field: ‘earlySignal’
[10:21:10.548]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.531]   - Field: ‘lazy’
[10:21:10.548]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.531]   - Field: ‘state’
[10:21:10.549]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.531] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:10.549]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.531] - Launch lazy future ...
[10:21:10.549]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.531] Packages needed by the future expression (n = 0): <none>
[10:21:10.551]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.532] Packages needed by future strategies (n = 0): <none>
[10:21:10.551]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.532] {
[10:21:10.532]     {
[10:21:10.532]         {
[10:21:10.532]             ...future.startTime <- base::Sys.time()
[10:21:10.532]             {
[10:21:10.532]                 {
[10:21:10.532]                   {
[10:21:10.532]                     base::local({
[10:21:10.532]                       has_future <- base::requireNamespace("future", 
[10:21:10.532]                         quietly = TRUE)
[10:21:10.532]                       if (has_future) {
[10:21:10.532]                         ns <- base::getNamespace("future")
[10:21:10.532]                         version <- ns[[".package"]][["version"]]
[10:21:10.532]                         if (is.null(version)) 
[10:21:10.532]                           version <- utils::packageVersion("future")
[10:21:10.532]                       }
[10:21:10.532]                       else {
[10:21:10.532]                         version <- NULL
[10:21:10.532]                       }
[10:21:10.532]                       if (!has_future || version < "1.8.0") {
[10:21:10.532]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.532]                           "", base::R.version$version.string), 
[10:21:10.532]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:10.532]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.532]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.532]                             "release", "version")], collapse = " "), 
[10:21:10.532]                           hostname = base::Sys.info()[["nodename"]])
[10:21:10.532]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.532]                           info)
[10:21:10.532]                         info <- base::paste(info, collapse = "; ")
[10:21:10.532]                         if (!has_future) {
[10:21:10.532]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.532]                             info)
[10:21:10.532]                         }
[10:21:10.532]                         else {
[10:21:10.532]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.532]                             info, version)
[10:21:10.532]                         }
[10:21:10.532]                         base::stop(msg)
[10:21:10.532]                       }
[10:21:10.532]                     })
[10:21:10.532]                   }
[10:21:10.532]                   ...future.strategy.old <- future::plan("list")
[10:21:10.532]                   options(future.plan = NULL)
[10:21:10.532]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.532]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.532]                 }
[10:21:10.532]                 ...future.workdir <- getwd()
[10:21:10.532]             }
[10:21:10.532]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.532]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.532]         }
[10:21:10.532]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.532]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.532]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.532]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.532]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.532]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.532]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.532]             base::names(...future.oldOptions))
[10:21:10.532]     }
[10:21:10.532]     if (FALSE) {
[10:21:10.532]     }
[10:21:10.532]     else {
[10:21:10.532]         if (TRUE) {
[10:21:10.532]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.532]                 open = "w")
[10:21:10.532]         }
[10:21:10.532]         else {
[10:21:10.532]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.532]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.532]         }
[10:21:10.532]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.532]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.532]             base::sink(type = "output", split = FALSE)
[10:21:10.532]             base::close(...future.stdout)
[10:21:10.532]         }, add = TRUE)
[10:21:10.532]     }
[10:21:10.532]     ...future.frame <- base::sys.nframe()
[10:21:10.532]     ...future.conditions <- base::list()
[10:21:10.532]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.532]     if (FALSE) {
[10:21:10.532]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.532]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.532]     }
[10:21:10.532]     ...future.result <- base::tryCatch({
[10:21:10.532]         base::withCallingHandlers({
[10:21:10.532]             ...future.value <- base::withVisible(base::local(4))
[10:21:10.532]             future::FutureResult(value = ...future.value$value, 
[10:21:10.532]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.532]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.532]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.532]                     ...future.globalenv.names))
[10:21:10.532]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.532]         }, condition = base::local({
[10:21:10.532]             c <- base::c
[10:21:10.532]             inherits <- base::inherits
[10:21:10.532]             invokeRestart <- base::invokeRestart
[10:21:10.532]             length <- base::length
[10:21:10.532]             list <- base::list
[10:21:10.532]             seq.int <- base::seq.int
[10:21:10.532]             signalCondition <- base::signalCondition
[10:21:10.532]             sys.calls <- base::sys.calls
[10:21:10.532]             `[[` <- base::`[[`
[10:21:10.532]             `+` <- base::`+`
[10:21:10.532]             `<<-` <- base::`<<-`
[10:21:10.532]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.532]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.532]                   3L)]
[10:21:10.532]             }
[10:21:10.532]             function(cond) {
[10:21:10.532]                 is_error <- inherits(cond, "error")
[10:21:10.532]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.532]                   NULL)
[10:21:10.532]                 if (is_error) {
[10:21:10.532]                   sessionInformation <- function() {
[10:21:10.532]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.532]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.532]                       search = base::search(), system = base::Sys.info())
[10:21:10.532]                   }
[10:21:10.532]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.532]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.532]                     cond$call), session = sessionInformation(), 
[10:21:10.532]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.532]                   signalCondition(cond)
[10:21:10.532]                 }
[10:21:10.532]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.532]                 "immediateCondition"))) {
[10:21:10.532]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.532]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.532]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.532]                   if (TRUE && !signal) {
[10:21:10.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.532]                     {
[10:21:10.532]                       inherits <- base::inherits
[10:21:10.532]                       invokeRestart <- base::invokeRestart
[10:21:10.532]                       is.null <- base::is.null
[10:21:10.532]                       muffled <- FALSE
[10:21:10.532]                       if (inherits(cond, "message")) {
[10:21:10.532]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.532]                         if (muffled) 
[10:21:10.532]                           invokeRestart("muffleMessage")
[10:21:10.532]                       }
[10:21:10.532]                       else if (inherits(cond, "warning")) {
[10:21:10.532]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.532]                         if (muffled) 
[10:21:10.532]                           invokeRestart("muffleWarning")
[10:21:10.532]                       }
[10:21:10.532]                       else if (inherits(cond, "condition")) {
[10:21:10.532]                         if (!is.null(pattern)) {
[10:21:10.532]                           computeRestarts <- base::computeRestarts
[10:21:10.532]                           grepl <- base::grepl
[10:21:10.532]                           restarts <- computeRestarts(cond)
[10:21:10.532]                           for (restart in restarts) {
[10:21:10.532]                             name <- restart$name
[10:21:10.532]                             if (is.null(name)) 
[10:21:10.532]                               next
[10:21:10.532]                             if (!grepl(pattern, name)) 
[10:21:10.532]                               next
[10:21:10.532]                             invokeRestart(restart)
[10:21:10.532]                             muffled <- TRUE
[10:21:10.532]                             break
[10:21:10.532]                           }
[10:21:10.532]                         }
[10:21:10.532]                       }
[10:21:10.532]                       invisible(muffled)
[10:21:10.532]                     }
[10:21:10.532]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.532]                   }
[10:21:10.532]                 }
[10:21:10.532]                 else {
[10:21:10.532]                   if (TRUE) {
[10:21:10.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.532]                     {
[10:21:10.532]                       inherits <- base::inherits
[10:21:10.532]                       invokeRestart <- base::invokeRestart
[10:21:10.532]                       is.null <- base::is.null
[10:21:10.532]                       muffled <- FALSE
[10:21:10.532]                       if (inherits(cond, "message")) {
[10:21:10.532]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.532]                         if (muffled) 
[10:21:10.532]                           invokeRestart("muffleMessage")
[10:21:10.532]                       }
[10:21:10.532]                       else if (inherits(cond, "warning")) {
[10:21:10.532]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.532]                         if (muffled) 
[10:21:10.532]                           invokeRestart("muffleWarning")
[10:21:10.532]                       }
[10:21:10.532]                       else if (inherits(cond, "condition")) {
[10:21:10.532]                         if (!is.null(pattern)) {
[10:21:10.532]                           computeRestarts <- base::computeRestarts
[10:21:10.532]                           grepl <- base::grepl
[10:21:10.532]                           restarts <- computeRestarts(cond)
[10:21:10.532]                           for (restart in restarts) {
[10:21:10.532]                             name <- restart$name
[10:21:10.532]                             if (is.null(name)) 
[10:21:10.532]                               next
[10:21:10.532]                             if (!grepl(pattern, name)) 
[10:21:10.532]                               next
[10:21:10.532]                             invokeRestart(restart)
[10:21:10.532]                             muffled <- TRUE
[10:21:10.532]                             break
[10:21:10.532]                           }
[10:21:10.532]                         }
[10:21:10.532]                       }
[10:21:10.532]                       invisible(muffled)
[10:21:10.532]                     }
[10:21:10.532]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.532]                   }
[10:21:10.532]                 }
[10:21:10.532]             }
[10:21:10.532]         }))
[10:21:10.532]     }, error = function(ex) {
[10:21:10.532]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.532]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.532]                 ...future.rng), started = ...future.startTime, 
[10:21:10.532]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.532]             version = "1.8"), class = "FutureResult")
[10:21:10.532]     }, finally = {
[10:21:10.532]         if (!identical(...future.workdir, getwd())) 
[10:21:10.532]             setwd(...future.workdir)
[10:21:10.532]         {
[10:21:10.532]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.532]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.532]             }
[10:21:10.532]             base::options(...future.oldOptions)
[10:21:10.532]             if (.Platform$OS.type == "windows") {
[10:21:10.532]                 old_names <- names(...future.oldEnvVars)
[10:21:10.532]                 envs <- base::Sys.getenv()
[10:21:10.532]                 names <- names(envs)
[10:21:10.532]                 common <- intersect(names, old_names)
[10:21:10.532]                 added <- setdiff(names, old_names)
[10:21:10.532]                 removed <- setdiff(old_names, names)
[10:21:10.532]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.532]                   envs[common]]
[10:21:10.532]                 NAMES <- toupper(changed)
[10:21:10.532]                 args <- list()
[10:21:10.532]                 for (kk in seq_along(NAMES)) {
[10:21:10.532]                   name <- changed[[kk]]
[10:21:10.532]                   NAME <- NAMES[[kk]]
[10:21:10.532]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.532]                     next
[10:21:10.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.532]                 }
[10:21:10.532]                 NAMES <- toupper(added)
[10:21:10.532]                 for (kk in seq_along(NAMES)) {
[10:21:10.532]                   name <- added[[kk]]
[10:21:10.532]                   NAME <- NAMES[[kk]]
[10:21:10.532]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.532]                     next
[10:21:10.532]                   args[[name]] <- ""
[10:21:10.532]                 }
[10:21:10.532]                 NAMES <- toupper(removed)
[10:21:10.532]                 for (kk in seq_along(NAMES)) {
[10:21:10.532]                   name <- removed[[kk]]
[10:21:10.532]                   NAME <- NAMES[[kk]]
[10:21:10.532]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.532]                     next
[10:21:10.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.532]                 }
[10:21:10.532]                 if (length(args) > 0) 
[10:21:10.532]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.532]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.532]             }
[10:21:10.532]             else {
[10:21:10.532]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.532]             }
[10:21:10.532]             {
[10:21:10.532]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.532]                   0L) {
[10:21:10.532]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.532]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.532]                   base::options(opts)
[10:21:10.532]                 }
[10:21:10.532]                 {
[10:21:10.532]                   {
[10:21:10.532]                     NULL
[10:21:10.532]                     RNGkind("Mersenne-Twister")
[10:21:10.532]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:10.532]                       inherits = FALSE)
[10:21:10.532]                   }
[10:21:10.532]                   options(future.plan = NULL)
[10:21:10.532]                   if (is.na(NA_character_)) 
[10:21:10.532]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.532]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.532]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.532]                     .init = FALSE)
[10:21:10.532]                 }
[10:21:10.532]             }
[10:21:10.532]         }
[10:21:10.532]     })
[10:21:10.532]     if (TRUE) {
[10:21:10.532]         base::sink(type = "output", split = FALSE)
[10:21:10.532]         if (TRUE) {
[10:21:10.532]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.532]         }
[10:21:10.532]         else {
[10:21:10.532]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.532]         }
[10:21:10.532]         base::close(...future.stdout)
[10:21:10.532]         ...future.stdout <- NULL
[10:21:10.532]     }
[10:21:10.532]     ...future.result$conditions <- ...future.conditions
[10:21:10.532]     ...future.result$finished <- base::Sys.time()
[10:21:10.532]     ...future.result
[10:21:10.532] }
[10:21:10.551]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.534] plan(): Setting new future strategy stack:
[10:21:10.551]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.534] List of future strategies:
[10:21:10.534] 1. sequential:
[10:21:10.534]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.534]    - tweaked: FALSE
[10:21:10.534]    - call: NULL
[10:21:10.551]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.534] plan(): nbrOfWorkers() = 1
[10:21:10.551]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.535] plan(): Setting new future strategy stack:
[10:21:10.552]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.535] List of future strategies:
[10:21:10.535] 1. sequential:
[10:21:10.535]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.535]    - tweaked: FALSE
[10:21:10.535]    - call: NULL
[10:21:10.552]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.536] plan(): nbrOfWorkers() = 1
[10:21:10.552]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.536] SequentialFuture started (and completed)
[10:21:10.552]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.536] - Launch lazy future ... done
[10:21:10.552]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.536] run() for ‘SequentialFuture’ ... done
[10:21:10.552] signalConditions() ... done
a = 10
[10:21:10.552] getGlobalsAndPackages() ...
[10:21:10.553] Searching for globals...
[10:21:10.553] - globals found: [3] ‘{’, ‘+’, ‘a’
[10:21:10.554] Searching for globals ... DONE
[10:21:10.554] Resolving globals: FALSE
[10:21:10.554] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:10.554] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:10.554] - globals: [1] ‘a’
[10:21:10.555] 
[10:21:10.555] getGlobalsAndPackages() ... DONE
[10:21:10.555] run() for ‘Future’ ...
[10:21:10.555] - state: ‘created’
[10:21:10.555] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:10.555] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:10.556] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:10.556]   - Field: ‘label’
[10:21:10.556]   - Field: ‘local’
[10:21:10.556]   - Field: ‘owner’
[10:21:10.556]   - Field: ‘envir’
[10:21:10.556]   - Field: ‘packages’
[10:21:10.556]   - Field: ‘gc’
[10:21:10.556]   - Field: ‘conditions’
[10:21:10.556]   - Field: ‘expr’
[10:21:10.556]   - Field: ‘uuid’
[10:21:10.556]   - Field: ‘seed’
[10:21:10.556]   - Field: ‘version’
[10:21:10.557]   - Field: ‘result’
[10:21:10.557]   - Field: ‘asynchronous’
[10:21:10.557]   - Field: ‘calls’
[10:21:10.557]   - Field: ‘globals’
[10:21:10.557]   - Field: ‘stdout’
[10:21:10.557]   - Field: ‘earlySignal’
[10:21:10.557]   - Field: ‘lazy’
[10:21:10.557]   - Field: ‘state’
[10:21:10.557] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:10.557] - Launch lazy future ...
[10:21:10.558] Packages needed by the future expression (n = 0): <none>
[10:21:10.558] Packages needed by future strategies (n = 0): <none>
[10:21:10.558] {
[10:21:10.558]     {
[10:21:10.558]         {
[10:21:10.558]             ...future.startTime <- base::Sys.time()
[10:21:10.558]             {
[10:21:10.558]                 {
[10:21:10.558]                   {
[10:21:10.558]                     base::local({
[10:21:10.558]                       has_future <- base::requireNamespace("future", 
[10:21:10.558]                         quietly = TRUE)
[10:21:10.558]                       if (has_future) {
[10:21:10.558]                         ns <- base::getNamespace("future")
[10:21:10.558]                         version <- ns[[".package"]][["version"]]
[10:21:10.558]                         if (is.null(version)) 
[10:21:10.558]                           version <- utils::packageVersion("future")
[10:21:10.558]                       }
[10:21:10.558]                       else {
[10:21:10.558]                         version <- NULL
[10:21:10.558]                       }
[10:21:10.558]                       if (!has_future || version < "1.8.0") {
[10:21:10.558]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.558]                           "", base::R.version$version.string), 
[10:21:10.558]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:10.558]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.558]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.558]                             "release", "version")], collapse = " "), 
[10:21:10.558]                           hostname = base::Sys.info()[["nodename"]])
[10:21:10.558]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.558]                           info)
[10:21:10.558]                         info <- base::paste(info, collapse = "; ")
[10:21:10.558]                         if (!has_future) {
[10:21:10.558]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.558]                             info)
[10:21:10.558]                         }
[10:21:10.558]                         else {
[10:21:10.558]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.558]                             info, version)
[10:21:10.558]                         }
[10:21:10.558]                         base::stop(msg)
[10:21:10.558]                       }
[10:21:10.558]                     })
[10:21:10.558]                   }
[10:21:10.558]                   ...future.strategy.old <- future::plan("list")
[10:21:10.558]                   options(future.plan = NULL)
[10:21:10.558]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.558]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.558]                 }
[10:21:10.558]                 ...future.workdir <- getwd()
[10:21:10.558]             }
[10:21:10.558]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.558]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.558]         }
[10:21:10.558]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.558]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.558]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.558]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.558]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.558]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.558]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.558]             base::names(...future.oldOptions))
[10:21:10.558]     }
[10:21:10.558]     if (FALSE) {
[10:21:10.558]     }
[10:21:10.558]     else {
[10:21:10.558]         if (TRUE) {
[10:21:10.558]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.558]                 open = "w")
[10:21:10.558]         }
[10:21:10.558]         else {
[10:21:10.558]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.558]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.558]         }
[10:21:10.558]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.558]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.558]             base::sink(type = "output", split = FALSE)
[10:21:10.558]             base::close(...future.stdout)
[10:21:10.558]         }, add = TRUE)
[10:21:10.558]     }
[10:21:10.558]     ...future.frame <- base::sys.nframe()
[10:21:10.558]     ...future.conditions <- base::list()
[10:21:10.558]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.558]     if (FALSE) {
[10:21:10.558]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.558]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.558]     }
[10:21:10.558]     ...future.result <- base::tryCatch({
[10:21:10.558]         base::withCallingHandlers({
[10:21:10.558]             ...future.value <- base::withVisible(base::local({
[10:21:10.558]                 a + 1
[10:21:10.558]             }))
[10:21:10.558]             future::FutureResult(value = ...future.value$value, 
[10:21:10.558]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.558]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.558]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.558]                     ...future.globalenv.names))
[10:21:10.558]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.558]         }, condition = base::local({
[10:21:10.558]             c <- base::c
[10:21:10.558]             inherits <- base::inherits
[10:21:10.558]             invokeRestart <- base::invokeRestart
[10:21:10.558]             length <- base::length
[10:21:10.558]             list <- base::list
[10:21:10.558]             seq.int <- base::seq.int
[10:21:10.558]             signalCondition <- base::signalCondition
[10:21:10.558]             sys.calls <- base::sys.calls
[10:21:10.558]             `[[` <- base::`[[`
[10:21:10.558]             `+` <- base::`+`
[10:21:10.558]             `<<-` <- base::`<<-`
[10:21:10.558]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.558]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.558]                   3L)]
[10:21:10.558]             }
[10:21:10.558]             function(cond) {
[10:21:10.558]                 is_error <- inherits(cond, "error")
[10:21:10.558]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.558]                   NULL)
[10:21:10.558]                 if (is_error) {
[10:21:10.558]                   sessionInformation <- function() {
[10:21:10.558]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.558]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.558]                       search = base::search(), system = base::Sys.info())
[10:21:10.558]                   }
[10:21:10.558]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.558]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.558]                     cond$call), session = sessionInformation(), 
[10:21:10.558]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.558]                   signalCondition(cond)
[10:21:10.558]                 }
[10:21:10.558]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.558]                 "immediateCondition"))) {
[10:21:10.558]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.558]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.558]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.558]                   if (TRUE && !signal) {
[10:21:10.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.558]                     {
[10:21:10.558]                       inherits <- base::inherits
[10:21:10.558]                       invokeRestart <- base::invokeRestart
[10:21:10.558]                       is.null <- base::is.null
[10:21:10.558]                       muffled <- FALSE
[10:21:10.558]                       if (inherits(cond, "message")) {
[10:21:10.558]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.558]                         if (muffled) 
[10:21:10.558]                           invokeRestart("muffleMessage")
[10:21:10.558]                       }
[10:21:10.558]                       else if (inherits(cond, "warning")) {
[10:21:10.558]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.558]                         if (muffled) 
[10:21:10.558]                           invokeRestart("muffleWarning")
[10:21:10.558]                       }
[10:21:10.558]                       else if (inherits(cond, "condition")) {
[10:21:10.558]                         if (!is.null(pattern)) {
[10:21:10.558]                           computeRestarts <- base::computeRestarts
[10:21:10.558]                           grepl <- base::grepl
[10:21:10.558]                           restarts <- computeRestarts(cond)
[10:21:10.558]                           for (restart in restarts) {
[10:21:10.558]                             name <- restart$name
[10:21:10.558]                             if (is.null(name)) 
[10:21:10.558]                               next
[10:21:10.558]                             if (!grepl(pattern, name)) 
[10:21:10.558]                               next
[10:21:10.558]                             invokeRestart(restart)
[10:21:10.558]                             muffled <- TRUE
[10:21:10.558]                             break
[10:21:10.558]                           }
[10:21:10.558]                         }
[10:21:10.558]                       }
[10:21:10.558]                       invisible(muffled)
[10:21:10.558]                     }
[10:21:10.558]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.558]                   }
[10:21:10.558]                 }
[10:21:10.558]                 else {
[10:21:10.558]                   if (TRUE) {
[10:21:10.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.558]                     {
[10:21:10.558]                       inherits <- base::inherits
[10:21:10.558]                       invokeRestart <- base::invokeRestart
[10:21:10.558]                       is.null <- base::is.null
[10:21:10.558]                       muffled <- FALSE
[10:21:10.558]                       if (inherits(cond, "message")) {
[10:21:10.558]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.558]                         if (muffled) 
[10:21:10.558]                           invokeRestart("muffleMessage")
[10:21:10.558]                       }
[10:21:10.558]                       else if (inherits(cond, "warning")) {
[10:21:10.558]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.558]                         if (muffled) 
[10:21:10.558]                           invokeRestart("muffleWarning")
[10:21:10.558]                       }
[10:21:10.558]                       else if (inherits(cond, "condition")) {
[10:21:10.558]                         if (!is.null(pattern)) {
[10:21:10.558]                           computeRestarts <- base::computeRestarts
[10:21:10.558]                           grepl <- base::grepl
[10:21:10.558]                           restarts <- computeRestarts(cond)
[10:21:10.558]                           for (restart in restarts) {
[10:21:10.558]                             name <- restart$name
[10:21:10.558]                             if (is.null(name)) 
[10:21:10.558]                               next
[10:21:10.558]                             if (!grepl(pattern, name)) 
[10:21:10.558]                               next
[10:21:10.558]                             invokeRestart(restart)
[10:21:10.558]                             muffled <- TRUE
[10:21:10.558]                             break
[10:21:10.558]                           }
[10:21:10.558]                         }
[10:21:10.558]                       }
[10:21:10.558]                       invisible(muffled)
[10:21:10.558]                     }
[10:21:10.558]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.558]                   }
[10:21:10.558]                 }
[10:21:10.558]             }
[10:21:10.558]         }))
[10:21:10.558]     }, error = function(ex) {
[10:21:10.558]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.558]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.558]                 ...future.rng), started = ...future.startTime, 
[10:21:10.558]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.558]             version = "1.8"), class = "FutureResult")
[10:21:10.558]     }, finally = {
[10:21:10.558]         if (!identical(...future.workdir, getwd())) 
[10:21:10.558]             setwd(...future.workdir)
[10:21:10.558]         {
[10:21:10.558]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.558]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.558]             }
[10:21:10.558]             base::options(...future.oldOptions)
[10:21:10.558]             if (.Platform$OS.type == "windows") {
[10:21:10.558]                 old_names <- names(...future.oldEnvVars)
[10:21:10.558]                 envs <- base::Sys.getenv()
[10:21:10.558]                 names <- names(envs)
[10:21:10.558]                 common <- intersect(names, old_names)
[10:21:10.558]                 added <- setdiff(names, old_names)
[10:21:10.558]                 removed <- setdiff(old_names, names)
[10:21:10.558]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.558]                   envs[common]]
[10:21:10.558]                 NAMES <- toupper(changed)
[10:21:10.558]                 args <- list()
[10:21:10.558]                 for (kk in seq_along(NAMES)) {
[10:21:10.558]                   name <- changed[[kk]]
[10:21:10.558]                   NAME <- NAMES[[kk]]
[10:21:10.558]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.558]                     next
[10:21:10.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.558]                 }
[10:21:10.558]                 NAMES <- toupper(added)
[10:21:10.558]                 for (kk in seq_along(NAMES)) {
[10:21:10.558]                   name <- added[[kk]]
[10:21:10.558]                   NAME <- NAMES[[kk]]
[10:21:10.558]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.558]                     next
[10:21:10.558]                   args[[name]] <- ""
[10:21:10.558]                 }
[10:21:10.558]                 NAMES <- toupper(removed)
[10:21:10.558]                 for (kk in seq_along(NAMES)) {
[10:21:10.558]                   name <- removed[[kk]]
[10:21:10.558]                   NAME <- NAMES[[kk]]
[10:21:10.558]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.558]                     next
[10:21:10.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.558]                 }
[10:21:10.558]                 if (length(args) > 0) 
[10:21:10.558]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.558]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.558]             }
[10:21:10.558]             else {
[10:21:10.558]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.558]             }
[10:21:10.558]             {
[10:21:10.558]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.558]                   0L) {
[10:21:10.558]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.558]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.558]                   base::options(opts)
[10:21:10.558]                 }
[10:21:10.558]                 {
[10:21:10.558]                   {
[10:21:10.558]                     NULL
[10:21:10.558]                     RNGkind("Mersenne-Twister")
[10:21:10.558]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:10.558]                       inherits = FALSE)
[10:21:10.558]                   }
[10:21:10.558]                   options(future.plan = NULL)
[10:21:10.558]                   if (is.na(NA_character_)) 
[10:21:10.558]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.558]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.558]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.558]                     .init = FALSE)
[10:21:10.558]                 }
[10:21:10.558]             }
[10:21:10.558]         }
[10:21:10.558]     })
[10:21:10.558]     if (TRUE) {
[10:21:10.558]         base::sink(type = "output", split = FALSE)
[10:21:10.558]         if (TRUE) {
[10:21:10.558]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.558]         }
[10:21:10.558]         else {
[10:21:10.558]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.558]         }
[10:21:10.558]         base::close(...future.stdout)
[10:21:10.558]         ...future.stdout <- NULL
[10:21:10.558]     }
[10:21:10.558]     ...future.result$conditions <- ...future.conditions
[10:21:10.558]     ...future.result$finished <- base::Sys.time()
[10:21:10.558]     ...future.result
[10:21:10.558] }
[10:21:10.560] assign_globals() ...
[10:21:10.560] List of 1
[10:21:10.560]  $ a: num 10
[10:21:10.560]  - attr(*, "where")=List of 1
[10:21:10.560]   ..$ a:<environment: R_EmptyEnv> 
[10:21:10.560]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:10.560]  - attr(*, "resolved")= logi FALSE
[10:21:10.560]  - attr(*, "total_size")= num 39
[10:21:10.560]  - attr(*, "already-done")= logi TRUE
[10:21:10.562] - copied ‘a’ to environment
[10:21:10.562] assign_globals() ... done
[10:21:10.563] plan(): Setting new future strategy stack:
[10:21:10.563] List of future strategies:
[10:21:10.563] 1. sequential:
[10:21:10.563]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.563]    - tweaked: FALSE
[10:21:10.563]    - call: NULL
[10:21:10.563] plan(): nbrOfWorkers() = 1
[10:21:10.564] plan(): Setting new future strategy stack:
[10:21:10.564] List of future strategies:
[10:21:10.564] 1. sequential:
[10:21:10.564]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.564]    - tweaked: FALSE
[10:21:10.564]    - call: plan(strategy)
[10:21:10.565] plan(): nbrOfWorkers() = 1
[10:21:10.565] SequentialFuture started (and completed)
[10:21:10.565] - Launch lazy future ... done
[10:21:10.565] run() for ‘SequentialFuture’ ... done
b = 11
*** %<-% with ‘sequential’ futures ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** %<-% with ‘multicore’ futures ...
[10:21:10.570] plan(): Setting new future strategy stack:
[10:21:10.570] List of future strategies:
[10:21:10.570] 1. multicore:
[10:21:10.570]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:10.570]    - tweaked: FALSE
[10:21:10.570]    - call: plan(strategy)
[10:21:10.572] plan(): nbrOfWorkers() = 2
** Future evaluation without globals
[10:21:10.573] getGlobalsAndPackages() ...
[10:21:10.573] Searching for globals...
[10:21:10.574] - globals found: [2] ‘{’, ‘<-’
[10:21:10.574] Searching for globals ... DONE
[10:21:10.574] Resolving globals: FALSE
[10:21:10.574] 
[10:21:10.574] 
[10:21:10.574] getGlobalsAndPackages() ... DONE
[10:21:10.574] run() for ‘Future’ ...
[10:21:10.575] - state: ‘created’
[10:21:10.576] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:10.578] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:10.578] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:10.578]   - Field: ‘label’
[10:21:10.578]   - Field: ‘local’
[10:21:10.578]   - Field: ‘owner’
[10:21:10.578]   - Field: ‘envir’
[10:21:10.579]   - Field: ‘workers’
[10:21:10.579]   - Field: ‘packages’
[10:21:10.579]   - Field: ‘gc’
[10:21:10.579]   - Field: ‘job’
[10:21:10.579]   - Field: ‘conditions’
[10:21:10.579]   - Field: ‘expr’
[10:21:10.579]   - Field: ‘uuid’
[10:21:10.579]   - Field: ‘seed’
[10:21:10.579]   - Field: ‘version’
[10:21:10.579]   - Field: ‘result’
[10:21:10.579]   - Field: ‘asynchronous’
[10:21:10.580]   - Field: ‘calls’
[10:21:10.580]   - Field: ‘globals’
[10:21:10.580]   - Field: ‘stdout’
[10:21:10.580]   - Field: ‘earlySignal’
[10:21:10.580]   - Field: ‘lazy’
[10:21:10.580]   - Field: ‘state’
[10:21:10.580] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:10.580] - Launch lazy future ...
[10:21:10.581] Packages needed by the future expression (n = 0): <none>
[10:21:10.581] Packages needed by future strategies (n = 0): <none>
[10:21:10.582] {
[10:21:10.582]     {
[10:21:10.582]         {
[10:21:10.582]             ...future.startTime <- base::Sys.time()
[10:21:10.582]             {
[10:21:10.582]                 {
[10:21:10.582]                   {
[10:21:10.582]                     {
[10:21:10.582]                       base::local({
[10:21:10.582]                         has_future <- base::requireNamespace("future", 
[10:21:10.582]                           quietly = TRUE)
[10:21:10.582]                         if (has_future) {
[10:21:10.582]                           ns <- base::getNamespace("future")
[10:21:10.582]                           version <- ns[[".package"]][["version"]]
[10:21:10.582]                           if (is.null(version)) 
[10:21:10.582]                             version <- utils::packageVersion("future")
[10:21:10.582]                         }
[10:21:10.582]                         else {
[10:21:10.582]                           version <- NULL
[10:21:10.582]                         }
[10:21:10.582]                         if (!has_future || version < "1.8.0") {
[10:21:10.582]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.582]                             "", base::R.version$version.string), 
[10:21:10.582]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:10.582]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.582]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.582]                               "release", "version")], collapse = " "), 
[10:21:10.582]                             hostname = base::Sys.info()[["nodename"]])
[10:21:10.582]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.582]                             info)
[10:21:10.582]                           info <- base::paste(info, collapse = "; ")
[10:21:10.582]                           if (!has_future) {
[10:21:10.582]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.582]                               info)
[10:21:10.582]                           }
[10:21:10.582]                           else {
[10:21:10.582]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.582]                               info, version)
[10:21:10.582]                           }
[10:21:10.582]                           base::stop(msg)
[10:21:10.582]                         }
[10:21:10.582]                       })
[10:21:10.582]                     }
[10:21:10.582]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:10.582]                     base::options(mc.cores = 1L)
[10:21:10.582]                   }
[10:21:10.582]                   ...future.strategy.old <- future::plan("list")
[10:21:10.582]                   options(future.plan = NULL)
[10:21:10.582]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.582]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.582]                 }
[10:21:10.582]                 ...future.workdir <- getwd()
[10:21:10.582]             }
[10:21:10.582]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.582]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.582]         }
[10:21:10.582]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.582]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.582]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.582]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.582]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.582]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.582]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.582]             base::names(...future.oldOptions))
[10:21:10.582]     }
[10:21:10.582]     if (FALSE) {
[10:21:10.582]     }
[10:21:10.582]     else {
[10:21:10.582]         if (TRUE) {
[10:21:10.582]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.582]                 open = "w")
[10:21:10.582]         }
[10:21:10.582]         else {
[10:21:10.582]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.582]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.582]         }
[10:21:10.582]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.582]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.582]             base::sink(type = "output", split = FALSE)
[10:21:10.582]             base::close(...future.stdout)
[10:21:10.582]         }, add = TRUE)
[10:21:10.582]     }
[10:21:10.582]     ...future.frame <- base::sys.nframe()
[10:21:10.582]     ...future.conditions <- base::list()
[10:21:10.582]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.582]     if (FALSE) {
[10:21:10.582]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.582]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.582]     }
[10:21:10.582]     ...future.result <- base::tryCatch({
[10:21:10.582]         base::withCallingHandlers({
[10:21:10.582]             ...future.value <- base::withVisible(base::local({
[10:21:10.582]                 withCallingHandlers({
[10:21:10.582]                   {
[10:21:10.582]                     x <- 1
[10:21:10.582]                   }
[10:21:10.582]                 }, immediateCondition = function(cond) {
[10:21:10.582]                   save_rds <- function (object, pathname, ...) 
[10:21:10.582]                   {
[10:21:10.582]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:10.582]                     if (file_test("-f", pathname_tmp)) {
[10:21:10.582]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.582]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:10.582]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.582]                         fi_tmp[["mtime"]])
[10:21:10.582]                     }
[10:21:10.582]                     tryCatch({
[10:21:10.582]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:10.582]                     }, error = function(ex) {
[10:21:10.582]                       msg <- conditionMessage(ex)
[10:21:10.582]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.582]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:10.582]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.582]                         fi_tmp[["mtime"]], msg)
[10:21:10.582]                       ex$message <- msg
[10:21:10.582]                       stop(ex)
[10:21:10.582]                     })
[10:21:10.582]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:10.582]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:10.582]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:10.582]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.582]                       fi <- file.info(pathname)
[10:21:10.582]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:10.582]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.582]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:10.582]                         fi[["size"]], fi[["mtime"]])
[10:21:10.582]                       stop(msg)
[10:21:10.582]                     }
[10:21:10.582]                     invisible(pathname)
[10:21:10.582]                   }
[10:21:10.582]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:10.582]                     rootPath = tempdir()) 
[10:21:10.582]                   {
[10:21:10.582]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:10.582]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:10.582]                       tmpdir = path, fileext = ".rds")
[10:21:10.582]                     save_rds(obj, file)
[10:21:10.582]                   }
[10:21:10.582]                   saveImmediateCondition(cond, path = "/tmp/RtmpKymecF/.future/immediateConditions")
[10:21:10.582]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.582]                   {
[10:21:10.582]                     inherits <- base::inherits
[10:21:10.582]                     invokeRestart <- base::invokeRestart
[10:21:10.582]                     is.null <- base::is.null
[10:21:10.582]                     muffled <- FALSE
[10:21:10.582]                     if (inherits(cond, "message")) {
[10:21:10.582]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:10.582]                       if (muffled) 
[10:21:10.582]                         invokeRestart("muffleMessage")
[10:21:10.582]                     }
[10:21:10.582]                     else if (inherits(cond, "warning")) {
[10:21:10.582]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:10.582]                       if (muffled) 
[10:21:10.582]                         invokeRestart("muffleWarning")
[10:21:10.582]                     }
[10:21:10.582]                     else if (inherits(cond, "condition")) {
[10:21:10.582]                       if (!is.null(pattern)) {
[10:21:10.582]                         computeRestarts <- base::computeRestarts
[10:21:10.582]                         grepl <- base::grepl
[10:21:10.582]                         restarts <- computeRestarts(cond)
[10:21:10.582]                         for (restart in restarts) {
[10:21:10.582]                           name <- restart$name
[10:21:10.582]                           if (is.null(name)) 
[10:21:10.582]                             next
[10:21:10.582]                           if (!grepl(pattern, name)) 
[10:21:10.582]                             next
[10:21:10.582]                           invokeRestart(restart)
[10:21:10.582]                           muffled <- TRUE
[10:21:10.582]                           break
[10:21:10.582]                         }
[10:21:10.582]                       }
[10:21:10.582]                     }
[10:21:10.582]                     invisible(muffled)
[10:21:10.582]                   }
[10:21:10.582]                   muffleCondition(cond)
[10:21:10.582]                 })
[10:21:10.582]             }))
[10:21:10.582]             future::FutureResult(value = ...future.value$value, 
[10:21:10.582]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.582]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.582]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.582]                     ...future.globalenv.names))
[10:21:10.582]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.582]         }, condition = base::local({
[10:21:10.582]             c <- base::c
[10:21:10.582]             inherits <- base::inherits
[10:21:10.582]             invokeRestart <- base::invokeRestart
[10:21:10.582]             length <- base::length
[10:21:10.582]             list <- base::list
[10:21:10.582]             seq.int <- base::seq.int
[10:21:10.582]             signalCondition <- base::signalCondition
[10:21:10.582]             sys.calls <- base::sys.calls
[10:21:10.582]             `[[` <- base::`[[`
[10:21:10.582]             `+` <- base::`+`
[10:21:10.582]             `<<-` <- base::`<<-`
[10:21:10.582]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.582]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.582]                   3L)]
[10:21:10.582]             }
[10:21:10.582]             function(cond) {
[10:21:10.582]                 is_error <- inherits(cond, "error")
[10:21:10.582]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.582]                   NULL)
[10:21:10.582]                 if (is_error) {
[10:21:10.582]                   sessionInformation <- function() {
[10:21:10.582]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.582]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.582]                       search = base::search(), system = base::Sys.info())
[10:21:10.582]                   }
[10:21:10.582]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.582]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.582]                     cond$call), session = sessionInformation(), 
[10:21:10.582]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.582]                   signalCondition(cond)
[10:21:10.582]                 }
[10:21:10.582]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.582]                 "immediateCondition"))) {
[10:21:10.582]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.582]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.582]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.582]                   if (TRUE && !signal) {
[10:21:10.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.582]                     {
[10:21:10.582]                       inherits <- base::inherits
[10:21:10.582]                       invokeRestart <- base::invokeRestart
[10:21:10.582]                       is.null <- base::is.null
[10:21:10.582]                       muffled <- FALSE
[10:21:10.582]                       if (inherits(cond, "message")) {
[10:21:10.582]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.582]                         if (muffled) 
[10:21:10.582]                           invokeRestart("muffleMessage")
[10:21:10.582]                       }
[10:21:10.582]                       else if (inherits(cond, "warning")) {
[10:21:10.582]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.582]                         if (muffled) 
[10:21:10.582]                           invokeRestart("muffleWarning")
[10:21:10.582]                       }
[10:21:10.582]                       else if (inherits(cond, "condition")) {
[10:21:10.582]                         if (!is.null(pattern)) {
[10:21:10.582]                           computeRestarts <- base::computeRestarts
[10:21:10.582]                           grepl <- base::grepl
[10:21:10.582]                           restarts <- computeRestarts(cond)
[10:21:10.582]                           for (restart in restarts) {
[10:21:10.582]                             name <- restart$name
[10:21:10.582]                             if (is.null(name)) 
[10:21:10.582]                               next
[10:21:10.582]                             if (!grepl(pattern, name)) 
[10:21:10.582]                               next
[10:21:10.582]                             invokeRestart(restart)
[10:21:10.582]                             muffled <- TRUE
[10:21:10.582]                             break
[10:21:10.582]                           }
[10:21:10.582]                         }
[10:21:10.582]                       }
[10:21:10.582]                       invisible(muffled)
[10:21:10.582]                     }
[10:21:10.582]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.582]                   }
[10:21:10.582]                 }
[10:21:10.582]                 else {
[10:21:10.582]                   if (TRUE) {
[10:21:10.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.582]                     {
[10:21:10.582]                       inherits <- base::inherits
[10:21:10.582]                       invokeRestart <- base::invokeRestart
[10:21:10.582]                       is.null <- base::is.null
[10:21:10.582]                       muffled <- FALSE
[10:21:10.582]                       if (inherits(cond, "message")) {
[10:21:10.582]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.582]                         if (muffled) 
[10:21:10.582]                           invokeRestart("muffleMessage")
[10:21:10.582]                       }
[10:21:10.582]                       else if (inherits(cond, "warning")) {
[10:21:10.582]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.582]                         if (muffled) 
[10:21:10.582]                           invokeRestart("muffleWarning")
[10:21:10.582]                       }
[10:21:10.582]                       else if (inherits(cond, "condition")) {
[10:21:10.582]                         if (!is.null(pattern)) {
[10:21:10.582]                           computeRestarts <- base::computeRestarts
[10:21:10.582]                           grepl <- base::grepl
[10:21:10.582]                           restarts <- computeRestarts(cond)
[10:21:10.582]                           for (restart in restarts) {
[10:21:10.582]                             name <- restart$name
[10:21:10.582]                             if (is.null(name)) 
[10:21:10.582]                               next
[10:21:10.582]                             if (!grepl(pattern, name)) 
[10:21:10.582]                               next
[10:21:10.582]                             invokeRestart(restart)
[10:21:10.582]                             muffled <- TRUE
[10:21:10.582]                             break
[10:21:10.582]                           }
[10:21:10.582]                         }
[10:21:10.582]                       }
[10:21:10.582]                       invisible(muffled)
[10:21:10.582]                     }
[10:21:10.582]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.582]                   }
[10:21:10.582]                 }
[10:21:10.582]             }
[10:21:10.582]         }))
[10:21:10.582]     }, error = function(ex) {
[10:21:10.582]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.582]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.582]                 ...future.rng), started = ...future.startTime, 
[10:21:10.582]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.582]             version = "1.8"), class = "FutureResult")
[10:21:10.582]     }, finally = {
[10:21:10.582]         if (!identical(...future.workdir, getwd())) 
[10:21:10.582]             setwd(...future.workdir)
[10:21:10.582]         {
[10:21:10.582]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.582]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.582]             }
[10:21:10.582]             base::options(...future.oldOptions)
[10:21:10.582]             if (.Platform$OS.type == "windows") {
[10:21:10.582]                 old_names <- names(...future.oldEnvVars)
[10:21:10.582]                 envs <- base::Sys.getenv()
[10:21:10.582]                 names <- names(envs)
[10:21:10.582]                 common <- intersect(names, old_names)
[10:21:10.582]                 added <- setdiff(names, old_names)
[10:21:10.582]                 removed <- setdiff(old_names, names)
[10:21:10.582]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.582]                   envs[common]]
[10:21:10.582]                 NAMES <- toupper(changed)
[10:21:10.582]                 args <- list()
[10:21:10.582]                 for (kk in seq_along(NAMES)) {
[10:21:10.582]                   name <- changed[[kk]]
[10:21:10.582]                   NAME <- NAMES[[kk]]
[10:21:10.582]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.582]                     next
[10:21:10.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.582]                 }
[10:21:10.582]                 NAMES <- toupper(added)
[10:21:10.582]                 for (kk in seq_along(NAMES)) {
[10:21:10.582]                   name <- added[[kk]]
[10:21:10.582]                   NAME <- NAMES[[kk]]
[10:21:10.582]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.582]                     next
[10:21:10.582]                   args[[name]] <- ""
[10:21:10.582]                 }
[10:21:10.582]                 NAMES <- toupper(removed)
[10:21:10.582]                 for (kk in seq_along(NAMES)) {
[10:21:10.582]                   name <- removed[[kk]]
[10:21:10.582]                   NAME <- NAMES[[kk]]
[10:21:10.582]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.582]                     next
[10:21:10.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.582]                 }
[10:21:10.582]                 if (length(args) > 0) 
[10:21:10.582]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.582]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.582]             }
[10:21:10.582]             else {
[10:21:10.582]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.582]             }
[10:21:10.582]             {
[10:21:10.582]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.582]                   0L) {
[10:21:10.582]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.582]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.582]                   base::options(opts)
[10:21:10.582]                 }
[10:21:10.582]                 {
[10:21:10.582]                   {
[10:21:10.582]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:10.582]                     NULL
[10:21:10.582]                   }
[10:21:10.582]                   options(future.plan = NULL)
[10:21:10.582]                   if (is.na(NA_character_)) 
[10:21:10.582]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.582]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.582]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.582]                     .init = FALSE)
[10:21:10.582]                 }
[10:21:10.582]             }
[10:21:10.582]         }
[10:21:10.582]     })
[10:21:10.582]     if (TRUE) {
[10:21:10.582]         base::sink(type = "output", split = FALSE)
[10:21:10.582]         if (TRUE) {
[10:21:10.582]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.582]         }
[10:21:10.582]         else {
[10:21:10.582]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.582]         }
[10:21:10.582]         base::close(...future.stdout)
[10:21:10.582]         ...future.stdout <- NULL
[10:21:10.582]     }
[10:21:10.582]     ...future.result$conditions <- ...future.conditions
[10:21:10.582]     ...future.result$finished <- base::Sys.time()
[10:21:10.582]     ...future.result
[10:21:10.582] }
[10:21:10.584] requestCore(): workers = 2
[10:21:10.587] MulticoreFuture started
[10:21:10.587] - Launch lazy future ... done
[10:21:10.588] plan(): Setting new future strategy stack:
[10:21:10.588] run() for ‘MulticoreFuture’ ... done
[10:21:10.588] List of future strategies:
[10:21:10.588] 1. sequential:
[10:21:10.588]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.588]    - tweaked: FALSE
[10:21:10.588]    - call: NULL
[10:21:10.589] plan(): nbrOfWorkers() = 1
[10:21:10.589] result() for MulticoreFuture ...
[10:21:10.591] plan(): Setting new future strategy stack:
[10:21:10.591] List of future strategies:
[10:21:10.591] 1. multicore:
[10:21:10.591]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:10.591]    - tweaked: FALSE
[10:21:10.591]    - call: plan(strategy)
[10:21:10.594] plan(): nbrOfWorkers() = 2
[10:21:10.599] result() for MulticoreFuture ...
[10:21:10.599] result() for MulticoreFuture ... done
[10:21:10.599] result() for MulticoreFuture ... done
[10:21:10.599] result() for MulticoreFuture ...
[10:21:10.599] result() for MulticoreFuture ... done
** Future evaluation with globals
[10:21:10.600] getGlobalsAndPackages() ...
[10:21:10.600] Searching for globals...
[10:21:10.601] - globals found: [3] ‘{’, ‘<-’, ‘a’
[10:21:10.601] Searching for globals ... DONE
[10:21:10.602] Resolving globals: FALSE
[10:21:10.602] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:10.603] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:10.603] - globals: [1] ‘a’
[10:21:10.603] 
[10:21:10.603] getGlobalsAndPackages() ... DONE
[10:21:10.603] run() for ‘Future’ ...
[10:21:10.603] - state: ‘created’
[10:21:10.604] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:10.606] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:10.606] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:10.606]   - Field: ‘label’
[10:21:10.606]   - Field: ‘local’
[10:21:10.606]   - Field: ‘owner’
[10:21:10.606]   - Field: ‘envir’
[10:21:10.606]   - Field: ‘workers’
[10:21:10.606]   - Field: ‘packages’
[10:21:10.607]   - Field: ‘gc’
[10:21:10.607]   - Field: ‘job’
[10:21:10.607]   - Field: ‘conditions’
[10:21:10.607]   - Field: ‘expr’
[10:21:10.607]   - Field: ‘uuid’
[10:21:10.607]   - Field: ‘seed’
[10:21:10.607]   - Field: ‘version’
[10:21:10.607]   - Field: ‘result’
[10:21:10.608]   - Field: ‘asynchronous’
[10:21:10.608]   - Field: ‘calls’
[10:21:10.608]   - Field: ‘globals’
[10:21:10.608]   - Field: ‘stdout’
[10:21:10.608]   - Field: ‘earlySignal’
[10:21:10.608]   - Field: ‘lazy’
[10:21:10.608]   - Field: ‘state’
[10:21:10.608] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:10.608] - Launch lazy future ...
[10:21:10.609] Packages needed by the future expression (n = 0): <none>
[10:21:10.609] Packages needed by future strategies (n = 0): <none>
[10:21:10.609] {
[10:21:10.609]     {
[10:21:10.609]         {
[10:21:10.609]             ...future.startTime <- base::Sys.time()
[10:21:10.609]             {
[10:21:10.609]                 {
[10:21:10.609]                   {
[10:21:10.609]                     {
[10:21:10.609]                       base::local({
[10:21:10.609]                         has_future <- base::requireNamespace("future", 
[10:21:10.609]                           quietly = TRUE)
[10:21:10.609]                         if (has_future) {
[10:21:10.609]                           ns <- base::getNamespace("future")
[10:21:10.609]                           version <- ns[[".package"]][["version"]]
[10:21:10.609]                           if (is.null(version)) 
[10:21:10.609]                             version <- utils::packageVersion("future")
[10:21:10.609]                         }
[10:21:10.609]                         else {
[10:21:10.609]                           version <- NULL
[10:21:10.609]                         }
[10:21:10.609]                         if (!has_future || version < "1.8.0") {
[10:21:10.609]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.609]                             "", base::R.version$version.string), 
[10:21:10.609]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:10.609]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.609]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.609]                               "release", "version")], collapse = " "), 
[10:21:10.609]                             hostname = base::Sys.info()[["nodename"]])
[10:21:10.609]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.609]                             info)
[10:21:10.609]                           info <- base::paste(info, collapse = "; ")
[10:21:10.609]                           if (!has_future) {
[10:21:10.609]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.609]                               info)
[10:21:10.609]                           }
[10:21:10.609]                           else {
[10:21:10.609]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.609]                               info, version)
[10:21:10.609]                           }
[10:21:10.609]                           base::stop(msg)
[10:21:10.609]                         }
[10:21:10.609]                       })
[10:21:10.609]                     }
[10:21:10.609]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:10.609]                     base::options(mc.cores = 1L)
[10:21:10.609]                   }
[10:21:10.609]                   ...future.strategy.old <- future::plan("list")
[10:21:10.609]                   options(future.plan = NULL)
[10:21:10.609]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.609]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.609]                 }
[10:21:10.609]                 ...future.workdir <- getwd()
[10:21:10.609]             }
[10:21:10.609]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.609]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.609]         }
[10:21:10.609]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.609]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.609]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.609]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.609]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.609]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.609]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.609]             base::names(...future.oldOptions))
[10:21:10.609]     }
[10:21:10.609]     if (FALSE) {
[10:21:10.609]     }
[10:21:10.609]     else {
[10:21:10.609]         if (TRUE) {
[10:21:10.609]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.609]                 open = "w")
[10:21:10.609]         }
[10:21:10.609]         else {
[10:21:10.609]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.609]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.609]         }
[10:21:10.609]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.609]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.609]             base::sink(type = "output", split = FALSE)
[10:21:10.609]             base::close(...future.stdout)
[10:21:10.609]         }, add = TRUE)
[10:21:10.609]     }
[10:21:10.609]     ...future.frame <- base::sys.nframe()
[10:21:10.609]     ...future.conditions <- base::list()
[10:21:10.609]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.609]     if (FALSE) {
[10:21:10.609]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.609]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.609]     }
[10:21:10.609]     ...future.result <- base::tryCatch({
[10:21:10.609]         base::withCallingHandlers({
[10:21:10.609]             ...future.value <- base::withVisible(base::local({
[10:21:10.609]                 withCallingHandlers({
[10:21:10.609]                   {
[10:21:10.609]                     x <- a
[10:21:10.609]                   }
[10:21:10.609]                 }, immediateCondition = function(cond) {
[10:21:10.609]                   save_rds <- function (object, pathname, ...) 
[10:21:10.609]                   {
[10:21:10.609]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:10.609]                     if (file_test("-f", pathname_tmp)) {
[10:21:10.609]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.609]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:10.609]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.609]                         fi_tmp[["mtime"]])
[10:21:10.609]                     }
[10:21:10.609]                     tryCatch({
[10:21:10.609]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:10.609]                     }, error = function(ex) {
[10:21:10.609]                       msg <- conditionMessage(ex)
[10:21:10.609]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.609]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:10.609]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.609]                         fi_tmp[["mtime"]], msg)
[10:21:10.609]                       ex$message <- msg
[10:21:10.609]                       stop(ex)
[10:21:10.609]                     })
[10:21:10.609]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:10.609]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:10.609]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:10.609]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.609]                       fi <- file.info(pathname)
[10:21:10.609]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:10.609]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.609]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:10.609]                         fi[["size"]], fi[["mtime"]])
[10:21:10.609]                       stop(msg)
[10:21:10.609]                     }
[10:21:10.609]                     invisible(pathname)
[10:21:10.609]                   }
[10:21:10.609]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:10.609]                     rootPath = tempdir()) 
[10:21:10.609]                   {
[10:21:10.609]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:10.609]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:10.609]                       tmpdir = path, fileext = ".rds")
[10:21:10.609]                     save_rds(obj, file)
[10:21:10.609]                   }
[10:21:10.609]                   saveImmediateCondition(cond, path = "/tmp/RtmpKymecF/.future/immediateConditions")
[10:21:10.609]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.609]                   {
[10:21:10.609]                     inherits <- base::inherits
[10:21:10.609]                     invokeRestart <- base::invokeRestart
[10:21:10.609]                     is.null <- base::is.null
[10:21:10.609]                     muffled <- FALSE
[10:21:10.609]                     if (inherits(cond, "message")) {
[10:21:10.609]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:10.609]                       if (muffled) 
[10:21:10.609]                         invokeRestart("muffleMessage")
[10:21:10.609]                     }
[10:21:10.609]                     else if (inherits(cond, "warning")) {
[10:21:10.609]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:10.609]                       if (muffled) 
[10:21:10.609]                         invokeRestart("muffleWarning")
[10:21:10.609]                     }
[10:21:10.609]                     else if (inherits(cond, "condition")) {
[10:21:10.609]                       if (!is.null(pattern)) {
[10:21:10.609]                         computeRestarts <- base::computeRestarts
[10:21:10.609]                         grepl <- base::grepl
[10:21:10.609]                         restarts <- computeRestarts(cond)
[10:21:10.609]                         for (restart in restarts) {
[10:21:10.609]                           name <- restart$name
[10:21:10.609]                           if (is.null(name)) 
[10:21:10.609]                             next
[10:21:10.609]                           if (!grepl(pattern, name)) 
[10:21:10.609]                             next
[10:21:10.609]                           invokeRestart(restart)
[10:21:10.609]                           muffled <- TRUE
[10:21:10.609]                           break
[10:21:10.609]                         }
[10:21:10.609]                       }
[10:21:10.609]                     }
[10:21:10.609]                     invisible(muffled)
[10:21:10.609]                   }
[10:21:10.609]                   muffleCondition(cond)
[10:21:10.609]                 })
[10:21:10.609]             }))
[10:21:10.609]             future::FutureResult(value = ...future.value$value, 
[10:21:10.609]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.609]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.609]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.609]                     ...future.globalenv.names))
[10:21:10.609]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.609]         }, condition = base::local({
[10:21:10.609]             c <- base::c
[10:21:10.609]             inherits <- base::inherits
[10:21:10.609]             invokeRestart <- base::invokeRestart
[10:21:10.609]             length <- base::length
[10:21:10.609]             list <- base::list
[10:21:10.609]             seq.int <- base::seq.int
[10:21:10.609]             signalCondition <- base::signalCondition
[10:21:10.609]             sys.calls <- base::sys.calls
[10:21:10.609]             `[[` <- base::`[[`
[10:21:10.609]             `+` <- base::`+`
[10:21:10.609]             `<<-` <- base::`<<-`
[10:21:10.609]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.609]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.609]                   3L)]
[10:21:10.609]             }
[10:21:10.609]             function(cond) {
[10:21:10.609]                 is_error <- inherits(cond, "error")
[10:21:10.609]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.609]                   NULL)
[10:21:10.609]                 if (is_error) {
[10:21:10.609]                   sessionInformation <- function() {
[10:21:10.609]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.609]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.609]                       search = base::search(), system = base::Sys.info())
[10:21:10.609]                   }
[10:21:10.609]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.609]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.609]                     cond$call), session = sessionInformation(), 
[10:21:10.609]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.609]                   signalCondition(cond)
[10:21:10.609]                 }
[10:21:10.609]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.609]                 "immediateCondition"))) {
[10:21:10.609]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.609]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.609]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.609]                   if (TRUE && !signal) {
[10:21:10.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.609]                     {
[10:21:10.609]                       inherits <- base::inherits
[10:21:10.609]                       invokeRestart <- base::invokeRestart
[10:21:10.609]                       is.null <- base::is.null
[10:21:10.609]                       muffled <- FALSE
[10:21:10.609]                       if (inherits(cond, "message")) {
[10:21:10.609]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.609]                         if (muffled) 
[10:21:10.609]                           invokeRestart("muffleMessage")
[10:21:10.609]                       }
[10:21:10.609]                       else if (inherits(cond, "warning")) {
[10:21:10.609]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.609]                         if (muffled) 
[10:21:10.609]                           invokeRestart("muffleWarning")
[10:21:10.609]                       }
[10:21:10.609]                       else if (inherits(cond, "condition")) {
[10:21:10.609]                         if (!is.null(pattern)) {
[10:21:10.609]                           computeRestarts <- base::computeRestarts
[10:21:10.609]                           grepl <- base::grepl
[10:21:10.609]                           restarts <- computeRestarts(cond)
[10:21:10.609]                           for (restart in restarts) {
[10:21:10.609]                             name <- restart$name
[10:21:10.609]                             if (is.null(name)) 
[10:21:10.609]                               next
[10:21:10.609]                             if (!grepl(pattern, name)) 
[10:21:10.609]                               next
[10:21:10.609]                             invokeRestart(restart)
[10:21:10.609]                             muffled <- TRUE
[10:21:10.609]                             break
[10:21:10.609]                           }
[10:21:10.609]                         }
[10:21:10.609]                       }
[10:21:10.609]                       invisible(muffled)
[10:21:10.609]                     }
[10:21:10.609]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.609]                   }
[10:21:10.609]                 }
[10:21:10.609]                 else {
[10:21:10.609]                   if (TRUE) {
[10:21:10.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.609]                     {
[10:21:10.609]                       inherits <- base::inherits
[10:21:10.609]                       invokeRestart <- base::invokeRestart
[10:21:10.609]                       is.null <- base::is.null
[10:21:10.609]                       muffled <- FALSE
[10:21:10.609]                       if (inherits(cond, "message")) {
[10:21:10.609]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.609]                         if (muffled) 
[10:21:10.609]                           invokeRestart("muffleMessage")
[10:21:10.609]                       }
[10:21:10.609]                       else if (inherits(cond, "warning")) {
[10:21:10.609]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.609]                         if (muffled) 
[10:21:10.609]                           invokeRestart("muffleWarning")
[10:21:10.609]                       }
[10:21:10.609]                       else if (inherits(cond, "condition")) {
[10:21:10.609]                         if (!is.null(pattern)) {
[10:21:10.609]                           computeRestarts <- base::computeRestarts
[10:21:10.609]                           grepl <- base::grepl
[10:21:10.609]                           restarts <- computeRestarts(cond)
[10:21:10.609]                           for (restart in restarts) {
[10:21:10.609]                             name <- restart$name
[10:21:10.609]                             if (is.null(name)) 
[10:21:10.609]                               next
[10:21:10.609]                             if (!grepl(pattern, name)) 
[10:21:10.609]                               next
[10:21:10.609]                             invokeRestart(restart)
[10:21:10.609]                             muffled <- TRUE
[10:21:10.609]                             break
[10:21:10.609]                           }
[10:21:10.609]                         }
[10:21:10.609]                       }
[10:21:10.609]                       invisible(muffled)
[10:21:10.609]                     }
[10:21:10.609]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.609]                   }
[10:21:10.609]                 }
[10:21:10.609]             }
[10:21:10.609]         }))
[10:21:10.609]     }, error = function(ex) {
[10:21:10.609]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.609]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.609]                 ...future.rng), started = ...future.startTime, 
[10:21:10.609]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.609]             version = "1.8"), class = "FutureResult")
[10:21:10.609]     }, finally = {
[10:21:10.609]         if (!identical(...future.workdir, getwd())) 
[10:21:10.609]             setwd(...future.workdir)
[10:21:10.609]         {
[10:21:10.609]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.609]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.609]             }
[10:21:10.609]             base::options(...future.oldOptions)
[10:21:10.609]             if (.Platform$OS.type == "windows") {
[10:21:10.609]                 old_names <- names(...future.oldEnvVars)
[10:21:10.609]                 envs <- base::Sys.getenv()
[10:21:10.609]                 names <- names(envs)
[10:21:10.609]                 common <- intersect(names, old_names)
[10:21:10.609]                 added <- setdiff(names, old_names)
[10:21:10.609]                 removed <- setdiff(old_names, names)
[10:21:10.609]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.609]                   envs[common]]
[10:21:10.609]                 NAMES <- toupper(changed)
[10:21:10.609]                 args <- list()
[10:21:10.609]                 for (kk in seq_along(NAMES)) {
[10:21:10.609]                   name <- changed[[kk]]
[10:21:10.609]                   NAME <- NAMES[[kk]]
[10:21:10.609]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.609]                     next
[10:21:10.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.609]                 }
[10:21:10.609]                 NAMES <- toupper(added)
[10:21:10.609]                 for (kk in seq_along(NAMES)) {
[10:21:10.609]                   name <- added[[kk]]
[10:21:10.609]                   NAME <- NAMES[[kk]]
[10:21:10.609]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.609]                     next
[10:21:10.609]                   args[[name]] <- ""
[10:21:10.609]                 }
[10:21:10.609]                 NAMES <- toupper(removed)
[10:21:10.609]                 for (kk in seq_along(NAMES)) {
[10:21:10.609]                   name <- removed[[kk]]
[10:21:10.609]                   NAME <- NAMES[[kk]]
[10:21:10.609]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.609]                     next
[10:21:10.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.609]                 }
[10:21:10.609]                 if (length(args) > 0) 
[10:21:10.609]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.609]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.609]             }
[10:21:10.609]             else {
[10:21:10.609]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.609]             }
[10:21:10.609]             {
[10:21:10.609]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.609]                   0L) {
[10:21:10.609]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.609]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.609]                   base::options(opts)
[10:21:10.609]                 }
[10:21:10.609]                 {
[10:21:10.609]                   {
[10:21:10.609]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:10.609]                     NULL
[10:21:10.609]                   }
[10:21:10.609]                   options(future.plan = NULL)
[10:21:10.609]                   if (is.na(NA_character_)) 
[10:21:10.609]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.609]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.609]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.609]                     .init = FALSE)
[10:21:10.609]                 }
[10:21:10.609]             }
[10:21:10.609]         }
[10:21:10.609]     })
[10:21:10.609]     if (TRUE) {
[10:21:10.609]         base::sink(type = "output", split = FALSE)
[10:21:10.609]         if (TRUE) {
[10:21:10.609]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.609]         }
[10:21:10.609]         else {
[10:21:10.609]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.609]         }
[10:21:10.609]         base::close(...future.stdout)
[10:21:10.609]         ...future.stdout <- NULL
[10:21:10.609]     }
[10:21:10.609]     ...future.result$conditions <- ...future.conditions
[10:21:10.609]     ...future.result$finished <- base::Sys.time()
[10:21:10.609]     ...future.result
[10:21:10.609] }
[10:21:10.612] assign_globals() ...
[10:21:10.612] List of 1
[10:21:10.612]  $ a: num 2
[10:21:10.612]  - attr(*, "where")=List of 1
[10:21:10.612]   ..$ a:<environment: R_EmptyEnv> 
[10:21:10.612]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:10.612]  - attr(*, "resolved")= logi FALSE
[10:21:10.612]  - attr(*, "total_size")= num 39
[10:21:10.612]  - attr(*, "already-done")= logi TRUE
[10:21:10.615] - copied ‘a’ to environment
[10:21:10.615] assign_globals() ... done
[10:21:10.615] requestCore(): workers = 2
[10:21:10.617] MulticoreFuture started
[10:21:10.617] - Launch lazy future ... done
[10:21:10.618] run() for ‘MulticoreFuture’ ... done
[10:21:10.618] result() for MulticoreFuture ...
[10:21:10.618] plan(): Setting new future strategy stack:
[10:21:10.618] List of future strategies:
[10:21:10.618] 1. sequential:
[10:21:10.618]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.618]    - tweaked: FALSE
[10:21:10.618]    - call: NULL
[10:21:10.619] plan(): nbrOfWorkers() = 1
[10:21:10.621] plan(): Setting new future strategy stack:
[10:21:10.621] List of future strategies:
[10:21:10.621] 1. multicore:
[10:21:10.621]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:10.621]    - tweaked: FALSE
[10:21:10.621]    - call: plan(strategy)
[10:21:10.624] plan(): nbrOfWorkers() = 2
[10:21:10.625] result() for MulticoreFuture ...
[10:21:10.625] result() for MulticoreFuture ... done
[10:21:10.625] result() for MulticoreFuture ... done
[10:21:10.626] result() for MulticoreFuture ...
[10:21:10.626] result() for MulticoreFuture ... done
** Future evaluation with errors
[10:21:10.626] getGlobalsAndPackages() ...
[10:21:10.627] Searching for globals...
[10:21:10.632] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[10:21:10.632] Searching for globals ... DONE
[10:21:10.632] Resolving globals: FALSE
[10:21:10.633] 
[10:21:10.633] 
[10:21:10.633] getGlobalsAndPackages() ... DONE
[10:21:10.633] run() for ‘Future’ ...
[10:21:10.634] - state: ‘created’
[10:21:10.634] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:10.636] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:10.636] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:10.636]   - Field: ‘label’
[10:21:10.636]   - Field: ‘local’
[10:21:10.636]   - Field: ‘owner’
[10:21:10.637]   - Field: ‘envir’
[10:21:10.637]   - Field: ‘workers’
[10:21:10.637]   - Field: ‘packages’
[10:21:10.637]   - Field: ‘gc’
[10:21:10.637]   - Field: ‘job’
[10:21:10.637]   - Field: ‘conditions’
[10:21:10.637]   - Field: ‘expr’
[10:21:10.637]   - Field: ‘uuid’
[10:21:10.638]   - Field: ‘seed’
[10:21:10.638]   - Field: ‘version’
[10:21:10.638]   - Field: ‘result’
[10:21:10.638]   - Field: ‘asynchronous’
[10:21:10.638]   - Field: ‘calls’
[10:21:10.638]   - Field: ‘globals’
[10:21:10.638]   - Field: ‘stdout’
[10:21:10.638]   - Field: ‘earlySignal’
[10:21:10.638]   - Field: ‘lazy’
[10:21:10.639]   - Field: ‘state’
[10:21:10.639] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:10.639] - Launch lazy future ...
[10:21:10.639] Packages needed by the future expression (n = 0): <none>
[10:21:10.639] Packages needed by future strategies (n = 0): <none>
[10:21:10.640] {
[10:21:10.640]     {
[10:21:10.640]         {
[10:21:10.640]             ...future.startTime <- base::Sys.time()
[10:21:10.640]             {
[10:21:10.640]                 {
[10:21:10.640]                   {
[10:21:10.640]                     {
[10:21:10.640]                       base::local({
[10:21:10.640]                         has_future <- base::requireNamespace("future", 
[10:21:10.640]                           quietly = TRUE)
[10:21:10.640]                         if (has_future) {
[10:21:10.640]                           ns <- base::getNamespace("future")
[10:21:10.640]                           version <- ns[[".package"]][["version"]]
[10:21:10.640]                           if (is.null(version)) 
[10:21:10.640]                             version <- utils::packageVersion("future")
[10:21:10.640]                         }
[10:21:10.640]                         else {
[10:21:10.640]                           version <- NULL
[10:21:10.640]                         }
[10:21:10.640]                         if (!has_future || version < "1.8.0") {
[10:21:10.640]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.640]                             "", base::R.version$version.string), 
[10:21:10.640]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:10.640]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.640]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.640]                               "release", "version")], collapse = " "), 
[10:21:10.640]                             hostname = base::Sys.info()[["nodename"]])
[10:21:10.640]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.640]                             info)
[10:21:10.640]                           info <- base::paste(info, collapse = "; ")
[10:21:10.640]                           if (!has_future) {
[10:21:10.640]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.640]                               info)
[10:21:10.640]                           }
[10:21:10.640]                           else {
[10:21:10.640]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.640]                               info, version)
[10:21:10.640]                           }
[10:21:10.640]                           base::stop(msg)
[10:21:10.640]                         }
[10:21:10.640]                       })
[10:21:10.640]                     }
[10:21:10.640]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:10.640]                     base::options(mc.cores = 1L)
[10:21:10.640]                   }
[10:21:10.640]                   ...future.strategy.old <- future::plan("list")
[10:21:10.640]                   options(future.plan = NULL)
[10:21:10.640]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.640]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.640]                 }
[10:21:10.640]                 ...future.workdir <- getwd()
[10:21:10.640]             }
[10:21:10.640]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.640]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.640]         }
[10:21:10.640]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.640]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.640]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.640]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.640]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.640]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.640]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.640]             base::names(...future.oldOptions))
[10:21:10.640]     }
[10:21:10.640]     if (FALSE) {
[10:21:10.640]     }
[10:21:10.640]     else {
[10:21:10.640]         if (TRUE) {
[10:21:10.640]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.640]                 open = "w")
[10:21:10.640]         }
[10:21:10.640]         else {
[10:21:10.640]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.640]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.640]         }
[10:21:10.640]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.640]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.640]             base::sink(type = "output", split = FALSE)
[10:21:10.640]             base::close(...future.stdout)
[10:21:10.640]         }, add = TRUE)
[10:21:10.640]     }
[10:21:10.640]     ...future.frame <- base::sys.nframe()
[10:21:10.640]     ...future.conditions <- base::list()
[10:21:10.640]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.640]     if (FALSE) {
[10:21:10.640]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.640]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.640]     }
[10:21:10.640]     ...future.result <- base::tryCatch({
[10:21:10.640]         base::withCallingHandlers({
[10:21:10.640]             ...future.value <- base::withVisible(base::local({
[10:21:10.640]                 withCallingHandlers({
[10:21:10.640]                   {
[10:21:10.640]                     x <- 3
[10:21:10.640]                     stop("Woops!")
[10:21:10.640]                     x
[10:21:10.640]                   }
[10:21:10.640]                 }, immediateCondition = function(cond) {
[10:21:10.640]                   save_rds <- function (object, pathname, ...) 
[10:21:10.640]                   {
[10:21:10.640]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:10.640]                     if (file_test("-f", pathname_tmp)) {
[10:21:10.640]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.640]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:10.640]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.640]                         fi_tmp[["mtime"]])
[10:21:10.640]                     }
[10:21:10.640]                     tryCatch({
[10:21:10.640]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:10.640]                     }, error = function(ex) {
[10:21:10.640]                       msg <- conditionMessage(ex)
[10:21:10.640]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.640]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:10.640]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.640]                         fi_tmp[["mtime"]], msg)
[10:21:10.640]                       ex$message <- msg
[10:21:10.640]                       stop(ex)
[10:21:10.640]                     })
[10:21:10.640]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:10.640]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:10.640]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:10.640]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.640]                       fi <- file.info(pathname)
[10:21:10.640]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:10.640]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.640]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:10.640]                         fi[["size"]], fi[["mtime"]])
[10:21:10.640]                       stop(msg)
[10:21:10.640]                     }
[10:21:10.640]                     invisible(pathname)
[10:21:10.640]                   }
[10:21:10.640]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:10.640]                     rootPath = tempdir()) 
[10:21:10.640]                   {
[10:21:10.640]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:10.640]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:10.640]                       tmpdir = path, fileext = ".rds")
[10:21:10.640]                     save_rds(obj, file)
[10:21:10.640]                   }
[10:21:10.640]                   saveImmediateCondition(cond, path = "/tmp/RtmpKymecF/.future/immediateConditions")
[10:21:10.640]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.640]                   {
[10:21:10.640]                     inherits <- base::inherits
[10:21:10.640]                     invokeRestart <- base::invokeRestart
[10:21:10.640]                     is.null <- base::is.null
[10:21:10.640]                     muffled <- FALSE
[10:21:10.640]                     if (inherits(cond, "message")) {
[10:21:10.640]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:10.640]                       if (muffled) 
[10:21:10.640]                         invokeRestart("muffleMessage")
[10:21:10.640]                     }
[10:21:10.640]                     else if (inherits(cond, "warning")) {
[10:21:10.640]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:10.640]                       if (muffled) 
[10:21:10.640]                         invokeRestart("muffleWarning")
[10:21:10.640]                     }
[10:21:10.640]                     else if (inherits(cond, "condition")) {
[10:21:10.640]                       if (!is.null(pattern)) {
[10:21:10.640]                         computeRestarts <- base::computeRestarts
[10:21:10.640]                         grepl <- base::grepl
[10:21:10.640]                         restarts <- computeRestarts(cond)
[10:21:10.640]                         for (restart in restarts) {
[10:21:10.640]                           name <- restart$name
[10:21:10.640]                           if (is.null(name)) 
[10:21:10.640]                             next
[10:21:10.640]                           if (!grepl(pattern, name)) 
[10:21:10.640]                             next
[10:21:10.640]                           invokeRestart(restart)
[10:21:10.640]                           muffled <- TRUE
[10:21:10.640]                           break
[10:21:10.640]                         }
[10:21:10.640]                       }
[10:21:10.640]                     }
[10:21:10.640]                     invisible(muffled)
[10:21:10.640]                   }
[10:21:10.640]                   muffleCondition(cond)
[10:21:10.640]                 })
[10:21:10.640]             }))
[10:21:10.640]             future::FutureResult(value = ...future.value$value, 
[10:21:10.640]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.640]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.640]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.640]                     ...future.globalenv.names))
[10:21:10.640]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.640]         }, condition = base::local({
[10:21:10.640]             c <- base::c
[10:21:10.640]             inherits <- base::inherits
[10:21:10.640]             invokeRestart <- base::invokeRestart
[10:21:10.640]             length <- base::length
[10:21:10.640]             list <- base::list
[10:21:10.640]             seq.int <- base::seq.int
[10:21:10.640]             signalCondition <- base::signalCondition
[10:21:10.640]             sys.calls <- base::sys.calls
[10:21:10.640]             `[[` <- base::`[[`
[10:21:10.640]             `+` <- base::`+`
[10:21:10.640]             `<<-` <- base::`<<-`
[10:21:10.640]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.640]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.640]                   3L)]
[10:21:10.640]             }
[10:21:10.640]             function(cond) {
[10:21:10.640]                 is_error <- inherits(cond, "error")
[10:21:10.640]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.640]                   NULL)
[10:21:10.640]                 if (is_error) {
[10:21:10.640]                   sessionInformation <- function() {
[10:21:10.640]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.640]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.640]                       search = base::search(), system = base::Sys.info())
[10:21:10.640]                   }
[10:21:10.640]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.640]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.640]                     cond$call), session = sessionInformation(), 
[10:21:10.640]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.640]                   signalCondition(cond)
[10:21:10.640]                 }
[10:21:10.640]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.640]                 "immediateCondition"))) {
[10:21:10.640]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.640]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.640]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.640]                   if (TRUE && !signal) {
[10:21:10.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.640]                     {
[10:21:10.640]                       inherits <- base::inherits
[10:21:10.640]                       invokeRestart <- base::invokeRestart
[10:21:10.640]                       is.null <- base::is.null
[10:21:10.640]                       muffled <- FALSE
[10:21:10.640]                       if (inherits(cond, "message")) {
[10:21:10.640]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.640]                         if (muffled) 
[10:21:10.640]                           invokeRestart("muffleMessage")
[10:21:10.640]                       }
[10:21:10.640]                       else if (inherits(cond, "warning")) {
[10:21:10.640]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.640]                         if (muffled) 
[10:21:10.640]                           invokeRestart("muffleWarning")
[10:21:10.640]                       }
[10:21:10.640]                       else if (inherits(cond, "condition")) {
[10:21:10.640]                         if (!is.null(pattern)) {
[10:21:10.640]                           computeRestarts <- base::computeRestarts
[10:21:10.640]                           grepl <- base::grepl
[10:21:10.640]                           restarts <- computeRestarts(cond)
[10:21:10.640]                           for (restart in restarts) {
[10:21:10.640]                             name <- restart$name
[10:21:10.640]                             if (is.null(name)) 
[10:21:10.640]                               next
[10:21:10.640]                             if (!grepl(pattern, name)) 
[10:21:10.640]                               next
[10:21:10.640]                             invokeRestart(restart)
[10:21:10.640]                             muffled <- TRUE
[10:21:10.640]                             break
[10:21:10.640]                           }
[10:21:10.640]                         }
[10:21:10.640]                       }
[10:21:10.640]                       invisible(muffled)
[10:21:10.640]                     }
[10:21:10.640]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.640]                   }
[10:21:10.640]                 }
[10:21:10.640]                 else {
[10:21:10.640]                   if (TRUE) {
[10:21:10.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.640]                     {
[10:21:10.640]                       inherits <- base::inherits
[10:21:10.640]                       invokeRestart <- base::invokeRestart
[10:21:10.640]                       is.null <- base::is.null
[10:21:10.640]                       muffled <- FALSE
[10:21:10.640]                       if (inherits(cond, "message")) {
[10:21:10.640]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.640]                         if (muffled) 
[10:21:10.640]                           invokeRestart("muffleMessage")
[10:21:10.640]                       }
[10:21:10.640]                       else if (inherits(cond, "warning")) {
[10:21:10.640]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.640]                         if (muffled) 
[10:21:10.640]                           invokeRestart("muffleWarning")
[10:21:10.640]                       }
[10:21:10.640]                       else if (inherits(cond, "condition")) {
[10:21:10.640]                         if (!is.null(pattern)) {
[10:21:10.640]                           computeRestarts <- base::computeRestarts
[10:21:10.640]                           grepl <- base::grepl
[10:21:10.640]                           restarts <- computeRestarts(cond)
[10:21:10.640]                           for (restart in restarts) {
[10:21:10.640]                             name <- restart$name
[10:21:10.640]                             if (is.null(name)) 
[10:21:10.640]                               next
[10:21:10.640]                             if (!grepl(pattern, name)) 
[10:21:10.640]                               next
[10:21:10.640]                             invokeRestart(restart)
[10:21:10.640]                             muffled <- TRUE
[10:21:10.640]                             break
[10:21:10.640]                           }
[10:21:10.640]                         }
[10:21:10.640]                       }
[10:21:10.640]                       invisible(muffled)
[10:21:10.640]                     }
[10:21:10.640]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.640]                   }
[10:21:10.640]                 }
[10:21:10.640]             }
[10:21:10.640]         }))
[10:21:10.640]     }, error = function(ex) {
[10:21:10.640]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.640]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.640]                 ...future.rng), started = ...future.startTime, 
[10:21:10.640]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.640]             version = "1.8"), class = "FutureResult")
[10:21:10.640]     }, finally = {
[10:21:10.640]         if (!identical(...future.workdir, getwd())) 
[10:21:10.640]             setwd(...future.workdir)
[10:21:10.640]         {
[10:21:10.640]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.640]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.640]             }
[10:21:10.640]             base::options(...future.oldOptions)
[10:21:10.640]             if (.Platform$OS.type == "windows") {
[10:21:10.640]                 old_names <- names(...future.oldEnvVars)
[10:21:10.640]                 envs <- base::Sys.getenv()
[10:21:10.640]                 names <- names(envs)
[10:21:10.640]                 common <- intersect(names, old_names)
[10:21:10.640]                 added <- setdiff(names, old_names)
[10:21:10.640]                 removed <- setdiff(old_names, names)
[10:21:10.640]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.640]                   envs[common]]
[10:21:10.640]                 NAMES <- toupper(changed)
[10:21:10.640]                 args <- list()
[10:21:10.640]                 for (kk in seq_along(NAMES)) {
[10:21:10.640]                   name <- changed[[kk]]
[10:21:10.640]                   NAME <- NAMES[[kk]]
[10:21:10.640]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.640]                     next
[10:21:10.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.640]                 }
[10:21:10.640]                 NAMES <- toupper(added)
[10:21:10.640]                 for (kk in seq_along(NAMES)) {
[10:21:10.640]                   name <- added[[kk]]
[10:21:10.640]                   NAME <- NAMES[[kk]]
[10:21:10.640]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.640]                     next
[10:21:10.640]                   args[[name]] <- ""
[10:21:10.640]                 }
[10:21:10.640]                 NAMES <- toupper(removed)
[10:21:10.640]                 for (kk in seq_along(NAMES)) {
[10:21:10.640]                   name <- removed[[kk]]
[10:21:10.640]                   NAME <- NAMES[[kk]]
[10:21:10.640]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.640]                     next
[10:21:10.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.640]                 }
[10:21:10.640]                 if (length(args) > 0) 
[10:21:10.640]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.640]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.640]             }
[10:21:10.640]             else {
[10:21:10.640]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.640]             }
[10:21:10.640]             {
[10:21:10.640]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.640]                   0L) {
[10:21:10.640]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.640]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.640]                   base::options(opts)
[10:21:10.640]                 }
[10:21:10.640]                 {
[10:21:10.640]                   {
[10:21:10.640]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:10.640]                     NULL
[10:21:10.640]                   }
[10:21:10.640]                   options(future.plan = NULL)
[10:21:10.640]                   if (is.na(NA_character_)) 
[10:21:10.640]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.640]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.640]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.640]                     .init = FALSE)
[10:21:10.640]                 }
[10:21:10.640]             }
[10:21:10.640]         }
[10:21:10.640]     })
[10:21:10.640]     if (TRUE) {
[10:21:10.640]         base::sink(type = "output", split = FALSE)
[10:21:10.640]         if (TRUE) {
[10:21:10.640]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.640]         }
[10:21:10.640]         else {
[10:21:10.640]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.640]         }
[10:21:10.640]         base::close(...future.stdout)
[10:21:10.640]         ...future.stdout <- NULL
[10:21:10.640]     }
[10:21:10.640]     ...future.result$conditions <- ...future.conditions
[10:21:10.640]     ...future.result$finished <- base::Sys.time()
[10:21:10.640]     ...future.result
[10:21:10.640] }
[10:21:10.642] requestCore(): workers = 2
[10:21:10.644] MulticoreFuture started
[10:21:10.645] - Launch lazy future ... done
[10:21:10.645] run() for ‘MulticoreFuture’ ... done
[10:21:10.645] plan(): Setting new future strategy stack:
[10:21:10.646] result() for MulticoreFuture ...
[10:21:10.646] List of future strategies:
[10:21:10.646] 1. sequential:
[10:21:10.646]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.646]    - tweaked: FALSE
[10:21:10.646]    - call: NULL
[10:21:10.647] plan(): nbrOfWorkers() = 1
[10:21:10.649] plan(): Setting new future strategy stack:
[10:21:10.649] List of future strategies:
[10:21:10.649] 1. multicore:
[10:21:10.649]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:10.649]    - tweaked: FALSE
[10:21:10.649]    - call: plan(strategy)
[10:21:10.652] plan(): nbrOfWorkers() = 2
[10:21:10.657] result() for MulticoreFuture ...
[10:21:10.657] result() for MulticoreFuture ... done
[10:21:10.658] signalConditions() ...
[10:21:10.658]  - include = ‘immediateCondition’
[10:21:10.658]  - exclude = 
[10:21:10.658]  - resignal = FALSE
[10:21:10.658]  - Number of conditions: 1
[10:21:10.658] signalConditions() ... done
[10:21:10.658] result() for MulticoreFuture ... done
[10:21:10.659] result() for MulticoreFuture ...
[10:21:10.659] result() for MulticoreFuture ... done
[10:21:10.659] signalConditions() ...
[10:21:10.659]  - include = ‘immediateCondition’
[10:21:10.659]  - exclude = 
[10:21:10.659]  - resignal = FALSE
[10:21:10.659]  - Number of conditions: 1
[10:21:10.659] signalConditions() ... done
[10:21:10.660] Future state: ‘finished’
[10:21:10.660] result() for MulticoreFuture ...
[10:21:10.660] result() for MulticoreFuture ... done
[10:21:10.660] signalConditions() ...
[10:21:10.660]  - include = ‘condition’
[10:21:10.660]  - exclude = ‘immediateCondition’
[10:21:10.660]  - resignal = TRUE
[10:21:10.660]  - Number of conditions: 1
[10:21:10.660]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:10.661] signalConditions() ... done
[10:21:10.661] getGlobalsAndPackages() ...
[10:21:10.661] Searching for globals...
[10:21:10.663] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[10:21:10.664] Searching for globals ... DONE
[10:21:10.664] Resolving globals: FALSE
[10:21:10.664] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:10.665] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:10.665] - globals: [1] ‘ii’
[10:21:10.665] 
[10:21:10.665] getGlobalsAndPackages() ... DONE
[10:21:10.665] run() for ‘Future’ ...
[10:21:10.666] - state: ‘created’
[10:21:10.666] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:10.668] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:10.668] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:10.668]   - Field: ‘label’
[10:21:10.668]   - Field: ‘local’
[10:21:10.668]   - Field: ‘owner’
[10:21:10.669]   - Field: ‘envir’
[10:21:10.669]   - Field: ‘workers’
[10:21:10.669]   - Field: ‘packages’
[10:21:10.669]   - Field: ‘gc’
[10:21:10.669]   - Field: ‘job’
[10:21:10.669]   - Field: ‘conditions’
[10:21:10.669]   - Field: ‘expr’
[10:21:10.669]   - Field: ‘uuid’
[10:21:10.669]   - Field: ‘seed’
[10:21:10.669]   - Field: ‘version’
[10:21:10.670]   - Field: ‘result’
[10:21:10.670]   - Field: ‘asynchronous’
[10:21:10.670]   - Field: ‘calls’
[10:21:10.670]   - Field: ‘globals’
[10:21:10.670]   - Field: ‘stdout’
[10:21:10.670]   - Field: ‘earlySignal’
[10:21:10.670]   - Field: ‘lazy’
[10:21:10.670]   - Field: ‘state’
[10:21:10.670] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:10.671] - Launch lazy future ...
[10:21:10.671] Packages needed by the future expression (n = 0): <none>
[10:21:10.671] Packages needed by future strategies (n = 0): <none>
[10:21:10.671] {
[10:21:10.671]     {
[10:21:10.671]         {
[10:21:10.671]             ...future.startTime <- base::Sys.time()
[10:21:10.671]             {
[10:21:10.671]                 {
[10:21:10.671]                   {
[10:21:10.671]                     {
[10:21:10.671]                       base::local({
[10:21:10.671]                         has_future <- base::requireNamespace("future", 
[10:21:10.671]                           quietly = TRUE)
[10:21:10.671]                         if (has_future) {
[10:21:10.671]                           ns <- base::getNamespace("future")
[10:21:10.671]                           version <- ns[[".package"]][["version"]]
[10:21:10.671]                           if (is.null(version)) 
[10:21:10.671]                             version <- utils::packageVersion("future")
[10:21:10.671]                         }
[10:21:10.671]                         else {
[10:21:10.671]                           version <- NULL
[10:21:10.671]                         }
[10:21:10.671]                         if (!has_future || version < "1.8.0") {
[10:21:10.671]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.671]                             "", base::R.version$version.string), 
[10:21:10.671]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:10.671]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.671]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.671]                               "release", "version")], collapse = " "), 
[10:21:10.671]                             hostname = base::Sys.info()[["nodename"]])
[10:21:10.671]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.671]                             info)
[10:21:10.671]                           info <- base::paste(info, collapse = "; ")
[10:21:10.671]                           if (!has_future) {
[10:21:10.671]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.671]                               info)
[10:21:10.671]                           }
[10:21:10.671]                           else {
[10:21:10.671]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.671]                               info, version)
[10:21:10.671]                           }
[10:21:10.671]                           base::stop(msg)
[10:21:10.671]                         }
[10:21:10.671]                       })
[10:21:10.671]                     }
[10:21:10.671]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:10.671]                     base::options(mc.cores = 1L)
[10:21:10.671]                   }
[10:21:10.671]                   ...future.strategy.old <- future::plan("list")
[10:21:10.671]                   options(future.plan = NULL)
[10:21:10.671]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.671]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.671]                 }
[10:21:10.671]                 ...future.workdir <- getwd()
[10:21:10.671]             }
[10:21:10.671]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.671]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.671]         }
[10:21:10.671]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.671]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.671]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.671]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.671]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.671]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.671]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.671]             base::names(...future.oldOptions))
[10:21:10.671]     }
[10:21:10.671]     if (FALSE) {
[10:21:10.671]     }
[10:21:10.671]     else {
[10:21:10.671]         if (TRUE) {
[10:21:10.671]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.671]                 open = "w")
[10:21:10.671]         }
[10:21:10.671]         else {
[10:21:10.671]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.671]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.671]         }
[10:21:10.671]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.671]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.671]             base::sink(type = "output", split = FALSE)
[10:21:10.671]             base::close(...future.stdout)
[10:21:10.671]         }, add = TRUE)
[10:21:10.671]     }
[10:21:10.671]     ...future.frame <- base::sys.nframe()
[10:21:10.671]     ...future.conditions <- base::list()
[10:21:10.671]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.671]     if (FALSE) {
[10:21:10.671]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.671]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.671]     }
[10:21:10.671]     ...future.result <- base::tryCatch({
[10:21:10.671]         base::withCallingHandlers({
[10:21:10.671]             ...future.value <- base::withVisible(base::local({
[10:21:10.671]                 withCallingHandlers({
[10:21:10.671]                   {
[10:21:10.671]                     if (ii%%2 == 0) 
[10:21:10.671]                       stop("Woops!")
[10:21:10.671]                     ii
[10:21:10.671]                   }
[10:21:10.671]                 }, immediateCondition = function(cond) {
[10:21:10.671]                   save_rds <- function (object, pathname, ...) 
[10:21:10.671]                   {
[10:21:10.671]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:10.671]                     if (file_test("-f", pathname_tmp)) {
[10:21:10.671]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.671]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:10.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.671]                         fi_tmp[["mtime"]])
[10:21:10.671]                     }
[10:21:10.671]                     tryCatch({
[10:21:10.671]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:10.671]                     }, error = function(ex) {
[10:21:10.671]                       msg <- conditionMessage(ex)
[10:21:10.671]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.671]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:10.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.671]                         fi_tmp[["mtime"]], msg)
[10:21:10.671]                       ex$message <- msg
[10:21:10.671]                       stop(ex)
[10:21:10.671]                     })
[10:21:10.671]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:10.671]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:10.671]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:10.671]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.671]                       fi <- file.info(pathname)
[10:21:10.671]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:10.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.671]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:10.671]                         fi[["size"]], fi[["mtime"]])
[10:21:10.671]                       stop(msg)
[10:21:10.671]                     }
[10:21:10.671]                     invisible(pathname)
[10:21:10.671]                   }
[10:21:10.671]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:10.671]                     rootPath = tempdir()) 
[10:21:10.671]                   {
[10:21:10.671]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:10.671]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:10.671]                       tmpdir = path, fileext = ".rds")
[10:21:10.671]                     save_rds(obj, file)
[10:21:10.671]                   }
[10:21:10.671]                   saveImmediateCondition(cond, path = "/tmp/RtmpKymecF/.future/immediateConditions")
[10:21:10.671]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.671]                   {
[10:21:10.671]                     inherits <- base::inherits
[10:21:10.671]                     invokeRestart <- base::invokeRestart
[10:21:10.671]                     is.null <- base::is.null
[10:21:10.671]                     muffled <- FALSE
[10:21:10.671]                     if (inherits(cond, "message")) {
[10:21:10.671]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:10.671]                       if (muffled) 
[10:21:10.671]                         invokeRestart("muffleMessage")
[10:21:10.671]                     }
[10:21:10.671]                     else if (inherits(cond, "warning")) {
[10:21:10.671]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:10.671]                       if (muffled) 
[10:21:10.671]                         invokeRestart("muffleWarning")
[10:21:10.671]                     }
[10:21:10.671]                     else if (inherits(cond, "condition")) {
[10:21:10.671]                       if (!is.null(pattern)) {
[10:21:10.671]                         computeRestarts <- base::computeRestarts
[10:21:10.671]                         grepl <- base::grepl
[10:21:10.671]                         restarts <- computeRestarts(cond)
[10:21:10.671]                         for (restart in restarts) {
[10:21:10.671]                           name <- restart$name
[10:21:10.671]                           if (is.null(name)) 
[10:21:10.671]                             next
[10:21:10.671]                           if (!grepl(pattern, name)) 
[10:21:10.671]                             next
[10:21:10.671]                           invokeRestart(restart)
[10:21:10.671]                           muffled <- TRUE
[10:21:10.671]                           break
[10:21:10.671]                         }
[10:21:10.671]                       }
[10:21:10.671]                     }
[10:21:10.671]                     invisible(muffled)
[10:21:10.671]                   }
[10:21:10.671]                   muffleCondition(cond)
[10:21:10.671]                 })
[10:21:10.671]             }))
[10:21:10.671]             future::FutureResult(value = ...future.value$value, 
[10:21:10.671]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.671]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.671]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.671]                     ...future.globalenv.names))
[10:21:10.671]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.671]         }, condition = base::local({
[10:21:10.671]             c <- base::c
[10:21:10.671]             inherits <- base::inherits
[10:21:10.671]             invokeRestart <- base::invokeRestart
[10:21:10.671]             length <- base::length
[10:21:10.671]             list <- base::list
[10:21:10.671]             seq.int <- base::seq.int
[10:21:10.671]             signalCondition <- base::signalCondition
[10:21:10.671]             sys.calls <- base::sys.calls
[10:21:10.671]             `[[` <- base::`[[`
[10:21:10.671]             `+` <- base::`+`
[10:21:10.671]             `<<-` <- base::`<<-`
[10:21:10.671]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.671]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.671]                   3L)]
[10:21:10.671]             }
[10:21:10.671]             function(cond) {
[10:21:10.671]                 is_error <- inherits(cond, "error")
[10:21:10.671]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.671]                   NULL)
[10:21:10.671]                 if (is_error) {
[10:21:10.671]                   sessionInformation <- function() {
[10:21:10.671]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.671]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.671]                       search = base::search(), system = base::Sys.info())
[10:21:10.671]                   }
[10:21:10.671]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.671]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.671]                     cond$call), session = sessionInformation(), 
[10:21:10.671]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.671]                   signalCondition(cond)
[10:21:10.671]                 }
[10:21:10.671]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.671]                 "immediateCondition"))) {
[10:21:10.671]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.671]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.671]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.671]                   if (TRUE && !signal) {
[10:21:10.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.671]                     {
[10:21:10.671]                       inherits <- base::inherits
[10:21:10.671]                       invokeRestart <- base::invokeRestart
[10:21:10.671]                       is.null <- base::is.null
[10:21:10.671]                       muffled <- FALSE
[10:21:10.671]                       if (inherits(cond, "message")) {
[10:21:10.671]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.671]                         if (muffled) 
[10:21:10.671]                           invokeRestart("muffleMessage")
[10:21:10.671]                       }
[10:21:10.671]                       else if (inherits(cond, "warning")) {
[10:21:10.671]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.671]                         if (muffled) 
[10:21:10.671]                           invokeRestart("muffleWarning")
[10:21:10.671]                       }
[10:21:10.671]                       else if (inherits(cond, "condition")) {
[10:21:10.671]                         if (!is.null(pattern)) {
[10:21:10.671]                           computeRestarts <- base::computeRestarts
[10:21:10.671]                           grepl <- base::grepl
[10:21:10.671]                           restarts <- computeRestarts(cond)
[10:21:10.671]                           for (restart in restarts) {
[10:21:10.671]                             name <- restart$name
[10:21:10.671]                             if (is.null(name)) 
[10:21:10.671]                               next
[10:21:10.671]                             if (!grepl(pattern, name)) 
[10:21:10.671]                               next
[10:21:10.671]                             invokeRestart(restart)
[10:21:10.671]                             muffled <- TRUE
[10:21:10.671]                             break
[10:21:10.671]                           }
[10:21:10.671]                         }
[10:21:10.671]                       }
[10:21:10.671]                       invisible(muffled)
[10:21:10.671]                     }
[10:21:10.671]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.671]                   }
[10:21:10.671]                 }
[10:21:10.671]                 else {
[10:21:10.671]                   if (TRUE) {
[10:21:10.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.671]                     {
[10:21:10.671]                       inherits <- base::inherits
[10:21:10.671]                       invokeRestart <- base::invokeRestart
[10:21:10.671]                       is.null <- base::is.null
[10:21:10.671]                       muffled <- FALSE
[10:21:10.671]                       if (inherits(cond, "message")) {
[10:21:10.671]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.671]                         if (muffled) 
[10:21:10.671]                           invokeRestart("muffleMessage")
[10:21:10.671]                       }
[10:21:10.671]                       else if (inherits(cond, "warning")) {
[10:21:10.671]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.671]                         if (muffled) 
[10:21:10.671]                           invokeRestart("muffleWarning")
[10:21:10.671]                       }
[10:21:10.671]                       else if (inherits(cond, "condition")) {
[10:21:10.671]                         if (!is.null(pattern)) {
[10:21:10.671]                           computeRestarts <- base::computeRestarts
[10:21:10.671]                           grepl <- base::grepl
[10:21:10.671]                           restarts <- computeRestarts(cond)
[10:21:10.671]                           for (restart in restarts) {
[10:21:10.671]                             name <- restart$name
[10:21:10.671]                             if (is.null(name)) 
[10:21:10.671]                               next
[10:21:10.671]                             if (!grepl(pattern, name)) 
[10:21:10.671]                               next
[10:21:10.671]                             invokeRestart(restart)
[10:21:10.671]                             muffled <- TRUE
[10:21:10.671]                             break
[10:21:10.671]                           }
[10:21:10.671]                         }
[10:21:10.671]                       }
[10:21:10.671]                       invisible(muffled)
[10:21:10.671]                     }
[10:21:10.671]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.671]                   }
[10:21:10.671]                 }
[10:21:10.671]             }
[10:21:10.671]         }))
[10:21:10.671]     }, error = function(ex) {
[10:21:10.671]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.671]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.671]                 ...future.rng), started = ...future.startTime, 
[10:21:10.671]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.671]             version = "1.8"), class = "FutureResult")
[10:21:10.671]     }, finally = {
[10:21:10.671]         if (!identical(...future.workdir, getwd())) 
[10:21:10.671]             setwd(...future.workdir)
[10:21:10.671]         {
[10:21:10.671]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.671]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.671]             }
[10:21:10.671]             base::options(...future.oldOptions)
[10:21:10.671]             if (.Platform$OS.type == "windows") {
[10:21:10.671]                 old_names <- names(...future.oldEnvVars)
[10:21:10.671]                 envs <- base::Sys.getenv()
[10:21:10.671]                 names <- names(envs)
[10:21:10.671]                 common <- intersect(names, old_names)
[10:21:10.671]                 added <- setdiff(names, old_names)
[10:21:10.671]                 removed <- setdiff(old_names, names)
[10:21:10.671]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.671]                   envs[common]]
[10:21:10.671]                 NAMES <- toupper(changed)
[10:21:10.671]                 args <- list()
[10:21:10.671]                 for (kk in seq_along(NAMES)) {
[10:21:10.671]                   name <- changed[[kk]]
[10:21:10.671]                   NAME <- NAMES[[kk]]
[10:21:10.671]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.671]                     next
[10:21:10.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.671]                 }
[10:21:10.671]                 NAMES <- toupper(added)
[10:21:10.671]                 for (kk in seq_along(NAMES)) {
[10:21:10.671]                   name <- added[[kk]]
[10:21:10.671]                   NAME <- NAMES[[kk]]
[10:21:10.671]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.671]                     next
[10:21:10.671]                   args[[name]] <- ""
[10:21:10.671]                 }
[10:21:10.671]                 NAMES <- toupper(removed)
[10:21:10.671]                 for (kk in seq_along(NAMES)) {
[10:21:10.671]                   name <- removed[[kk]]
[10:21:10.671]                   NAME <- NAMES[[kk]]
[10:21:10.671]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.671]                     next
[10:21:10.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.671]                 }
[10:21:10.671]                 if (length(args) > 0) 
[10:21:10.671]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.671]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.671]             }
[10:21:10.671]             else {
[10:21:10.671]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.671]             }
[10:21:10.671]             {
[10:21:10.671]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.671]                   0L) {
[10:21:10.671]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.671]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.671]                   base::options(opts)
[10:21:10.671]                 }
[10:21:10.671]                 {
[10:21:10.671]                   {
[10:21:10.671]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:10.671]                     NULL
[10:21:10.671]                   }
[10:21:10.671]                   options(future.plan = NULL)
[10:21:10.671]                   if (is.na(NA_character_)) 
[10:21:10.671]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.671]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.671]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.671]                     .init = FALSE)
[10:21:10.671]                 }
[10:21:10.671]             }
[10:21:10.671]         }
[10:21:10.671]     })
[10:21:10.671]     if (TRUE) {
[10:21:10.671]         base::sink(type = "output", split = FALSE)
[10:21:10.671]         if (TRUE) {
[10:21:10.671]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.671]         }
[10:21:10.671]         else {
[10:21:10.671]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.671]         }
[10:21:10.671]         base::close(...future.stdout)
[10:21:10.671]         ...future.stdout <- NULL
[10:21:10.671]     }
[10:21:10.671]     ...future.result$conditions <- ...future.conditions
[10:21:10.671]     ...future.result$finished <- base::Sys.time()
[10:21:10.671]     ...future.result
[10:21:10.671] }
[10:21:10.674] assign_globals() ...
[10:21:10.674] List of 1
[10:21:10.674]  $ ii: int 1
[10:21:10.674]  - attr(*, "where")=List of 1
[10:21:10.674]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:10.674]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:10.674]  - attr(*, "resolved")= logi FALSE
[10:21:10.674]  - attr(*, "total_size")= num 35
[10:21:10.674]  - attr(*, "already-done")= logi TRUE
[10:21:10.680] - copied ‘ii’ to environment
[10:21:10.680] assign_globals() ... done
[10:21:10.680] requestCore(): workers = 2
[10:21:10.682] MulticoreFuture started
[10:21:10.682] - Launch lazy future ... done
[10:21:10.682] run() for ‘MulticoreFuture’ ... done
[10:21:10.683] plan(): Setting new future strategy stack:
[10:21:10.684] getGlobalsAndPackages() ...
[10:21:10.683] List of future strategies:
[10:21:10.683] 1. sequential:
[10:21:10.683]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.683]    - tweaked: FALSE
[10:21:10.683]    - call: NULL
[10:21:10.684] Searching for globals...
[10:21:10.684] plan(): nbrOfWorkers() = 1
[10:21:10.686] plan(): Setting new future strategy stack:
[10:21:10.686] List of future strategies:
[10:21:10.686] 1. multicore:
[10:21:10.686]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:10.686]    - tweaked: FALSE
[10:21:10.686]    - call: plan(strategy)
[10:21:10.688] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[10:21:10.688] Searching for globals ... DONE
[10:21:10.688] Resolving globals: FALSE
[10:21:10.689] plan(): nbrOfWorkers() = 2
[10:21:10.689] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:10.690] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:10.690] - globals: [1] ‘ii’
[10:21:10.690] 
[10:21:10.691] getGlobalsAndPackages() ... DONE
[10:21:10.691] run() for ‘Future’ ...
[10:21:10.691] - state: ‘created’
[10:21:10.692] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:10.694] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:10.694] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:10.694]   - Field: ‘label’
[10:21:10.695]   - Field: ‘local’
[10:21:10.695]   - Field: ‘owner’
[10:21:10.695]   - Field: ‘envir’
[10:21:10.695]   - Field: ‘workers’
[10:21:10.695]   - Field: ‘packages’
[10:21:10.695]   - Field: ‘gc’
[10:21:10.695]   - Field: ‘job’
[10:21:10.696]   - Field: ‘conditions’
[10:21:10.696]   - Field: ‘expr’
[10:21:10.696]   - Field: ‘uuid’
[10:21:10.696]   - Field: ‘seed’
[10:21:10.696]   - Field: ‘version’
[10:21:10.696]   - Field: ‘result’
[10:21:10.697]   - Field: ‘asynchronous’
[10:21:10.697]   - Field: ‘calls’
[10:21:10.697]   - Field: ‘globals’
[10:21:10.697]   - Field: ‘stdout’
[10:21:10.697]   - Field: ‘earlySignal’
[10:21:10.697]   - Field: ‘lazy’
[10:21:10.697]   - Field: ‘state’
[10:21:10.698] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:10.698] - Launch lazy future ...
[10:21:10.698] Packages needed by the future expression (n = 0): <none>
[10:21:10.698] Packages needed by future strategies (n = 0): <none>
[10:21:10.699] {
[10:21:10.699]     {
[10:21:10.699]         {
[10:21:10.699]             ...future.startTime <- base::Sys.time()
[10:21:10.699]             {
[10:21:10.699]                 {
[10:21:10.699]                   {
[10:21:10.699]                     {
[10:21:10.699]                       base::local({
[10:21:10.699]                         has_future <- base::requireNamespace("future", 
[10:21:10.699]                           quietly = TRUE)
[10:21:10.699]                         if (has_future) {
[10:21:10.699]                           ns <- base::getNamespace("future")
[10:21:10.699]                           version <- ns[[".package"]][["version"]]
[10:21:10.699]                           if (is.null(version)) 
[10:21:10.699]                             version <- utils::packageVersion("future")
[10:21:10.699]                         }
[10:21:10.699]                         else {
[10:21:10.699]                           version <- NULL
[10:21:10.699]                         }
[10:21:10.699]                         if (!has_future || version < "1.8.0") {
[10:21:10.699]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.699]                             "", base::R.version$version.string), 
[10:21:10.699]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:10.699]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.699]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.699]                               "release", "version")], collapse = " "), 
[10:21:10.699]                             hostname = base::Sys.info()[["nodename"]])
[10:21:10.699]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.699]                             info)
[10:21:10.699]                           info <- base::paste(info, collapse = "; ")
[10:21:10.699]                           if (!has_future) {
[10:21:10.699]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.699]                               info)
[10:21:10.699]                           }
[10:21:10.699]                           else {
[10:21:10.699]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.699]                               info, version)
[10:21:10.699]                           }
[10:21:10.699]                           base::stop(msg)
[10:21:10.699]                         }
[10:21:10.699]                       })
[10:21:10.699]                     }
[10:21:10.699]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:10.699]                     base::options(mc.cores = 1L)
[10:21:10.699]                   }
[10:21:10.699]                   ...future.strategy.old <- future::plan("list")
[10:21:10.699]                   options(future.plan = NULL)
[10:21:10.699]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.699]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.699]                 }
[10:21:10.699]                 ...future.workdir <- getwd()
[10:21:10.699]             }
[10:21:10.699]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.699]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.699]         }
[10:21:10.699]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.699]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.699]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.699]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.699]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.699]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.699]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.699]             base::names(...future.oldOptions))
[10:21:10.699]     }
[10:21:10.699]     if (FALSE) {
[10:21:10.699]     }
[10:21:10.699]     else {
[10:21:10.699]         if (TRUE) {
[10:21:10.699]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.699]                 open = "w")
[10:21:10.699]         }
[10:21:10.699]         else {
[10:21:10.699]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.699]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.699]         }
[10:21:10.699]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.699]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.699]             base::sink(type = "output", split = FALSE)
[10:21:10.699]             base::close(...future.stdout)
[10:21:10.699]         }, add = TRUE)
[10:21:10.699]     }
[10:21:10.699]     ...future.frame <- base::sys.nframe()
[10:21:10.699]     ...future.conditions <- base::list()
[10:21:10.699]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.699]     if (FALSE) {
[10:21:10.699]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.699]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.699]     }
[10:21:10.699]     ...future.result <- base::tryCatch({
[10:21:10.699]         base::withCallingHandlers({
[10:21:10.699]             ...future.value <- base::withVisible(base::local({
[10:21:10.699]                 withCallingHandlers({
[10:21:10.699]                   {
[10:21:10.699]                     if (ii%%2 == 0) 
[10:21:10.699]                       stop("Woops!")
[10:21:10.699]                     ii
[10:21:10.699]                   }
[10:21:10.699]                 }, immediateCondition = function(cond) {
[10:21:10.699]                   save_rds <- function (object, pathname, ...) 
[10:21:10.699]                   {
[10:21:10.699]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:10.699]                     if (file_test("-f", pathname_tmp)) {
[10:21:10.699]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.699]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:10.699]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.699]                         fi_tmp[["mtime"]])
[10:21:10.699]                     }
[10:21:10.699]                     tryCatch({
[10:21:10.699]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:10.699]                     }, error = function(ex) {
[10:21:10.699]                       msg <- conditionMessage(ex)
[10:21:10.699]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.699]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:10.699]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.699]                         fi_tmp[["mtime"]], msg)
[10:21:10.699]                       ex$message <- msg
[10:21:10.699]                       stop(ex)
[10:21:10.699]                     })
[10:21:10.699]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:10.699]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:10.699]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:10.699]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.699]                       fi <- file.info(pathname)
[10:21:10.699]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:10.699]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.699]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:10.699]                         fi[["size"]], fi[["mtime"]])
[10:21:10.699]                       stop(msg)
[10:21:10.699]                     }
[10:21:10.699]                     invisible(pathname)
[10:21:10.699]                   }
[10:21:10.699]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:10.699]                     rootPath = tempdir()) 
[10:21:10.699]                   {
[10:21:10.699]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:10.699]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:10.699]                       tmpdir = path, fileext = ".rds")
[10:21:10.699]                     save_rds(obj, file)
[10:21:10.699]                   }
[10:21:10.699]                   saveImmediateCondition(cond, path = "/tmp/RtmpKymecF/.future/immediateConditions")
[10:21:10.699]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.699]                   {
[10:21:10.699]                     inherits <- base::inherits
[10:21:10.699]                     invokeRestart <- base::invokeRestart
[10:21:10.699]                     is.null <- base::is.null
[10:21:10.699]                     muffled <- FALSE
[10:21:10.699]                     if (inherits(cond, "message")) {
[10:21:10.699]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:10.699]                       if (muffled) 
[10:21:10.699]                         invokeRestart("muffleMessage")
[10:21:10.699]                     }
[10:21:10.699]                     else if (inherits(cond, "warning")) {
[10:21:10.699]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:10.699]                       if (muffled) 
[10:21:10.699]                         invokeRestart("muffleWarning")
[10:21:10.699]                     }
[10:21:10.699]                     else if (inherits(cond, "condition")) {
[10:21:10.699]                       if (!is.null(pattern)) {
[10:21:10.699]                         computeRestarts <- base::computeRestarts
[10:21:10.699]                         grepl <- base::grepl
[10:21:10.699]                         restarts <- computeRestarts(cond)
[10:21:10.699]                         for (restart in restarts) {
[10:21:10.699]                           name <- restart$name
[10:21:10.699]                           if (is.null(name)) 
[10:21:10.699]                             next
[10:21:10.699]                           if (!grepl(pattern, name)) 
[10:21:10.699]                             next
[10:21:10.699]                           invokeRestart(restart)
[10:21:10.699]                           muffled <- TRUE
[10:21:10.699]                           break
[10:21:10.699]                         }
[10:21:10.699]                       }
[10:21:10.699]                     }
[10:21:10.699]                     invisible(muffled)
[10:21:10.699]                   }
[10:21:10.699]                   muffleCondition(cond)
[10:21:10.699]                 })
[10:21:10.699]             }))
[10:21:10.699]             future::FutureResult(value = ...future.value$value, 
[10:21:10.699]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.699]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.699]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.699]                     ...future.globalenv.names))
[10:21:10.699]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.699]         }, condition = base::local({
[10:21:10.699]             c <- base::c
[10:21:10.699]             inherits <- base::inherits
[10:21:10.699]             invokeRestart <- base::invokeRestart
[10:21:10.699]             length <- base::length
[10:21:10.699]             list <- base::list
[10:21:10.699]             seq.int <- base::seq.int
[10:21:10.699]             signalCondition <- base::signalCondition
[10:21:10.699]             sys.calls <- base::sys.calls
[10:21:10.699]             `[[` <- base::`[[`
[10:21:10.699]             `+` <- base::`+`
[10:21:10.699]             `<<-` <- base::`<<-`
[10:21:10.699]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.699]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.699]                   3L)]
[10:21:10.699]             }
[10:21:10.699]             function(cond) {
[10:21:10.699]                 is_error <- inherits(cond, "error")
[10:21:10.699]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.699]                   NULL)
[10:21:10.699]                 if (is_error) {
[10:21:10.699]                   sessionInformation <- function() {
[10:21:10.699]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.699]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.699]                       search = base::search(), system = base::Sys.info())
[10:21:10.699]                   }
[10:21:10.699]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.699]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.699]                     cond$call), session = sessionInformation(), 
[10:21:10.699]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.699]                   signalCondition(cond)
[10:21:10.699]                 }
[10:21:10.699]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.699]                 "immediateCondition"))) {
[10:21:10.699]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.699]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.699]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.699]                   if (TRUE && !signal) {
[10:21:10.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.699]                     {
[10:21:10.699]                       inherits <- base::inherits
[10:21:10.699]                       invokeRestart <- base::invokeRestart
[10:21:10.699]                       is.null <- base::is.null
[10:21:10.699]                       muffled <- FALSE
[10:21:10.699]                       if (inherits(cond, "message")) {
[10:21:10.699]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.699]                         if (muffled) 
[10:21:10.699]                           invokeRestart("muffleMessage")
[10:21:10.699]                       }
[10:21:10.699]                       else if (inherits(cond, "warning")) {
[10:21:10.699]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.699]                         if (muffled) 
[10:21:10.699]                           invokeRestart("muffleWarning")
[10:21:10.699]                       }
[10:21:10.699]                       else if (inherits(cond, "condition")) {
[10:21:10.699]                         if (!is.null(pattern)) {
[10:21:10.699]                           computeRestarts <- base::computeRestarts
[10:21:10.699]                           grepl <- base::grepl
[10:21:10.699]                           restarts <- computeRestarts(cond)
[10:21:10.699]                           for (restart in restarts) {
[10:21:10.699]                             name <- restart$name
[10:21:10.699]                             if (is.null(name)) 
[10:21:10.699]                               next
[10:21:10.699]                             if (!grepl(pattern, name)) 
[10:21:10.699]                               next
[10:21:10.699]                             invokeRestart(restart)
[10:21:10.699]                             muffled <- TRUE
[10:21:10.699]                             break
[10:21:10.699]                           }
[10:21:10.699]                         }
[10:21:10.699]                       }
[10:21:10.699]                       invisible(muffled)
[10:21:10.699]                     }
[10:21:10.699]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.699]                   }
[10:21:10.699]                 }
[10:21:10.699]                 else {
[10:21:10.699]                   if (TRUE) {
[10:21:10.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.699]                     {
[10:21:10.699]                       inherits <- base::inherits
[10:21:10.699]                       invokeRestart <- base::invokeRestart
[10:21:10.699]                       is.null <- base::is.null
[10:21:10.699]                       muffled <- FALSE
[10:21:10.699]                       if (inherits(cond, "message")) {
[10:21:10.699]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.699]                         if (muffled) 
[10:21:10.699]                           invokeRestart("muffleMessage")
[10:21:10.699]                       }
[10:21:10.699]                       else if (inherits(cond, "warning")) {
[10:21:10.699]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.699]                         if (muffled) 
[10:21:10.699]                           invokeRestart("muffleWarning")
[10:21:10.699]                       }
[10:21:10.699]                       else if (inherits(cond, "condition")) {
[10:21:10.699]                         if (!is.null(pattern)) {
[10:21:10.699]                           computeRestarts <- base::computeRestarts
[10:21:10.699]                           grepl <- base::grepl
[10:21:10.699]                           restarts <- computeRestarts(cond)
[10:21:10.699]                           for (restart in restarts) {
[10:21:10.699]                             name <- restart$name
[10:21:10.699]                             if (is.null(name)) 
[10:21:10.699]                               next
[10:21:10.699]                             if (!grepl(pattern, name)) 
[10:21:10.699]                               next
[10:21:10.699]                             invokeRestart(restart)
[10:21:10.699]                             muffled <- TRUE
[10:21:10.699]                             break
[10:21:10.699]                           }
[10:21:10.699]                         }
[10:21:10.699]                       }
[10:21:10.699]                       invisible(muffled)
[10:21:10.699]                     }
[10:21:10.699]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.699]                   }
[10:21:10.699]                 }
[10:21:10.699]             }
[10:21:10.699]         }))
[10:21:10.699]     }, error = function(ex) {
[10:21:10.699]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.699]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.699]                 ...future.rng), started = ...future.startTime, 
[10:21:10.699]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.699]             version = "1.8"), class = "FutureResult")
[10:21:10.699]     }, finally = {
[10:21:10.699]         if (!identical(...future.workdir, getwd())) 
[10:21:10.699]             setwd(...future.workdir)
[10:21:10.699]         {
[10:21:10.699]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.699]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.699]             }
[10:21:10.699]             base::options(...future.oldOptions)
[10:21:10.699]             if (.Platform$OS.type == "windows") {
[10:21:10.699]                 old_names <- names(...future.oldEnvVars)
[10:21:10.699]                 envs <- base::Sys.getenv()
[10:21:10.699]                 names <- names(envs)
[10:21:10.699]                 common <- intersect(names, old_names)
[10:21:10.699]                 added <- setdiff(names, old_names)
[10:21:10.699]                 removed <- setdiff(old_names, names)
[10:21:10.699]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.699]                   envs[common]]
[10:21:10.699]                 NAMES <- toupper(changed)
[10:21:10.699]                 args <- list()
[10:21:10.699]                 for (kk in seq_along(NAMES)) {
[10:21:10.699]                   name <- changed[[kk]]
[10:21:10.699]                   NAME <- NAMES[[kk]]
[10:21:10.699]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.699]                     next
[10:21:10.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.699]                 }
[10:21:10.699]                 NAMES <- toupper(added)
[10:21:10.699]                 for (kk in seq_along(NAMES)) {
[10:21:10.699]                   name <- added[[kk]]
[10:21:10.699]                   NAME <- NAMES[[kk]]
[10:21:10.699]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.699]                     next
[10:21:10.699]                   args[[name]] <- ""
[10:21:10.699]                 }
[10:21:10.699]                 NAMES <- toupper(removed)
[10:21:10.699]                 for (kk in seq_along(NAMES)) {
[10:21:10.699]                   name <- removed[[kk]]
[10:21:10.699]                   NAME <- NAMES[[kk]]
[10:21:10.699]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.699]                     next
[10:21:10.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.699]                 }
[10:21:10.699]                 if (length(args) > 0) 
[10:21:10.699]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.699]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.699]             }
[10:21:10.699]             else {
[10:21:10.699]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.699]             }
[10:21:10.699]             {
[10:21:10.699]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.699]                   0L) {
[10:21:10.699]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.699]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.699]                   base::options(opts)
[10:21:10.699]                 }
[10:21:10.699]                 {
[10:21:10.699]                   {
[10:21:10.699]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:10.699]                     NULL
[10:21:10.699]                   }
[10:21:10.699]                   options(future.plan = NULL)
[10:21:10.699]                   if (is.na(NA_character_)) 
[10:21:10.699]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.699]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.699]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.699]                     .init = FALSE)
[10:21:10.699]                 }
[10:21:10.699]             }
[10:21:10.699]         }
[10:21:10.699]     })
[10:21:10.699]     if (TRUE) {
[10:21:10.699]         base::sink(type = "output", split = FALSE)
[10:21:10.699]         if (TRUE) {
[10:21:10.699]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.699]         }
[10:21:10.699]         else {
[10:21:10.699]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.699]         }
[10:21:10.699]         base::close(...future.stdout)
[10:21:10.699]         ...future.stdout <- NULL
[10:21:10.699]     }
[10:21:10.699]     ...future.result$conditions <- ...future.conditions
[10:21:10.699]     ...future.result$finished <- base::Sys.time()
[10:21:10.699]     ...future.result
[10:21:10.699] }
[10:21:10.702] assign_globals() ...
[10:21:10.703] List of 1
[10:21:10.703]  $ ii: int 2
[10:21:10.703]  - attr(*, "where")=List of 1
[10:21:10.703]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:10.703]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:10.703]  - attr(*, "resolved")= logi FALSE
[10:21:10.703]  - attr(*, "total_size")= num 35
[10:21:10.703]  - attr(*, "already-done")= logi TRUE
[10:21:10.707] - copied ‘ii’ to environment
[10:21:10.707] assign_globals() ... done
[10:21:10.707] requestCore(): workers = 2
[10:21:10.709] MulticoreFuture started
[10:21:10.710] - Launch lazy future ... done
[10:21:10.710] run() for ‘MulticoreFuture’ ... done
[10:21:10.711] plan(): Setting new future strategy stack:
[10:21:10.711] getGlobalsAndPackages() ...
[10:21:10.711] Searching for globals...
[10:21:10.711] List of future strategies:
[10:21:10.711] 1. sequential:
[10:21:10.711]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.711]    - tweaked: FALSE
[10:21:10.711]    - call: NULL
[10:21:10.712] plan(): nbrOfWorkers() = 1
[10:21:10.714] plan(): Setting new future strategy stack:
[10:21:10.714] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[10:21:10.714] Searching for globals ... DONE
[10:21:10.714] List of future strategies:
[10:21:10.714] 1. multicore:
[10:21:10.714]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:10.714]    - tweaked: FALSE
[10:21:10.714]    - call: plan(strategy)
[10:21:10.715] Resolving globals: FALSE
[10:21:10.715] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:10.716] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:10.716] - globals: [1] ‘ii’
[10:21:10.716] 
[10:21:10.717] getGlobalsAndPackages() ... DONE
[10:21:10.717] run() for ‘Future’ ...
[10:21:10.717] - state: ‘created’
[10:21:10.717] plan(): nbrOfWorkers() = 2
[10:21:10.718] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:10.720] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:10.720] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:10.721]   - Field: ‘label’
[10:21:10.721]   - Field: ‘local’
[10:21:10.721]   - Field: ‘owner’
[10:21:10.721]   - Field: ‘envir’
[10:21:10.721]   - Field: ‘workers’
[10:21:10.721]   - Field: ‘packages’
[10:21:10.721]   - Field: ‘gc’
[10:21:10.722]   - Field: ‘job’
[10:21:10.722]   - Field: ‘conditions’
[10:21:10.722]   - Field: ‘expr’
[10:21:10.722]   - Field: ‘uuid’
[10:21:10.722]   - Field: ‘seed’
[10:21:10.722]   - Field: ‘version’
[10:21:10.722]   - Field: ‘result’
[10:21:10.723]   - Field: ‘asynchronous’
[10:21:10.723]   - Field: ‘calls’
[10:21:10.723]   - Field: ‘globals’
[10:21:10.723]   - Field: ‘stdout’
[10:21:10.723]   - Field: ‘earlySignal’
[10:21:10.723]   - Field: ‘lazy’
[10:21:10.723]   - Field: ‘state’
[10:21:10.723] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:10.724] - Launch lazy future ...
[10:21:10.724] Packages needed by the future expression (n = 0): <none>
[10:21:10.724] Packages needed by future strategies (n = 0): <none>
[10:21:10.728] {
[10:21:10.728]     {
[10:21:10.728]         {
[10:21:10.728]             ...future.startTime <- base::Sys.time()
[10:21:10.728]             {
[10:21:10.728]                 {
[10:21:10.728]                   {
[10:21:10.728]                     {
[10:21:10.728]                       base::local({
[10:21:10.728]                         has_future <- base::requireNamespace("future", 
[10:21:10.728]                           quietly = TRUE)
[10:21:10.728]                         if (has_future) {
[10:21:10.728]                           ns <- base::getNamespace("future")
[10:21:10.728]                           version <- ns[[".package"]][["version"]]
[10:21:10.728]                           if (is.null(version)) 
[10:21:10.728]                             version <- utils::packageVersion("future")
[10:21:10.728]                         }
[10:21:10.728]                         else {
[10:21:10.728]                           version <- NULL
[10:21:10.728]                         }
[10:21:10.728]                         if (!has_future || version < "1.8.0") {
[10:21:10.728]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.728]                             "", base::R.version$version.string), 
[10:21:10.728]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:10.728]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.728]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.728]                               "release", "version")], collapse = " "), 
[10:21:10.728]                             hostname = base::Sys.info()[["nodename"]])
[10:21:10.728]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.728]                             info)
[10:21:10.728]                           info <- base::paste(info, collapse = "; ")
[10:21:10.728]                           if (!has_future) {
[10:21:10.728]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.728]                               info)
[10:21:10.728]                           }
[10:21:10.728]                           else {
[10:21:10.728]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.728]                               info, version)
[10:21:10.728]                           }
[10:21:10.728]                           base::stop(msg)
[10:21:10.728]                         }
[10:21:10.728]                       })
[10:21:10.728]                     }
[10:21:10.728]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:10.728]                     base::options(mc.cores = 1L)
[10:21:10.728]                   }
[10:21:10.728]                   ...future.strategy.old <- future::plan("list")
[10:21:10.728]                   options(future.plan = NULL)
[10:21:10.728]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.728]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.728]                 }
[10:21:10.728]                 ...future.workdir <- getwd()
[10:21:10.728]             }
[10:21:10.728]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.728]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.728]         }
[10:21:10.728]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.728]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.728]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.728]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.728]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.728]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.728]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.728]             base::names(...future.oldOptions))
[10:21:10.728]     }
[10:21:10.728]     if (FALSE) {
[10:21:10.728]     }
[10:21:10.728]     else {
[10:21:10.728]         if (TRUE) {
[10:21:10.728]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.728]                 open = "w")
[10:21:10.728]         }
[10:21:10.728]         else {
[10:21:10.728]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.728]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.728]         }
[10:21:10.728]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.728]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.728]             base::sink(type = "output", split = FALSE)
[10:21:10.728]             base::close(...future.stdout)
[10:21:10.728]         }, add = TRUE)
[10:21:10.728]     }
[10:21:10.728]     ...future.frame <- base::sys.nframe()
[10:21:10.728]     ...future.conditions <- base::list()
[10:21:10.728]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.728]     if (FALSE) {
[10:21:10.728]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.728]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.728]     }
[10:21:10.728]     ...future.result <- base::tryCatch({
[10:21:10.728]         base::withCallingHandlers({
[10:21:10.728]             ...future.value <- base::withVisible(base::local({
[10:21:10.728]                 withCallingHandlers({
[10:21:10.728]                   {
[10:21:10.728]                     if (ii%%2 == 0) 
[10:21:10.728]                       stop("Woops!")
[10:21:10.728]                     ii
[10:21:10.728]                   }
[10:21:10.728]                 }, immediateCondition = function(cond) {
[10:21:10.728]                   save_rds <- function (object, pathname, ...) 
[10:21:10.728]                   {
[10:21:10.728]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:10.728]                     if (file_test("-f", pathname_tmp)) {
[10:21:10.728]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.728]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:10.728]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.728]                         fi_tmp[["mtime"]])
[10:21:10.728]                     }
[10:21:10.728]                     tryCatch({
[10:21:10.728]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:10.728]                     }, error = function(ex) {
[10:21:10.728]                       msg <- conditionMessage(ex)
[10:21:10.728]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.728]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:10.728]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.728]                         fi_tmp[["mtime"]], msg)
[10:21:10.728]                       ex$message <- msg
[10:21:10.728]                       stop(ex)
[10:21:10.728]                     })
[10:21:10.728]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:10.728]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:10.728]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:10.728]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.728]                       fi <- file.info(pathname)
[10:21:10.728]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:10.728]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.728]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:10.728]                         fi[["size"]], fi[["mtime"]])
[10:21:10.728]                       stop(msg)
[10:21:10.728]                     }
[10:21:10.728]                     invisible(pathname)
[10:21:10.728]                   }
[10:21:10.728]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:10.728]                     rootPath = tempdir()) 
[10:21:10.728]                   {
[10:21:10.728]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:10.728]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:10.728]                       tmpdir = path, fileext = ".rds")
[10:21:10.728]                     save_rds(obj, file)
[10:21:10.728]                   }
[10:21:10.728]                   saveImmediateCondition(cond, path = "/tmp/RtmpKymecF/.future/immediateConditions")
[10:21:10.728]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.728]                   {
[10:21:10.728]                     inherits <- base::inherits
[10:21:10.728]                     invokeRestart <- base::invokeRestart
[10:21:10.728]                     is.null <- base::is.null
[10:21:10.728]                     muffled <- FALSE
[10:21:10.728]                     if (inherits(cond, "message")) {
[10:21:10.728]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:10.728]                       if (muffled) 
[10:21:10.728]                         invokeRestart("muffleMessage")
[10:21:10.728]                     }
[10:21:10.728]                     else if (inherits(cond, "warning")) {
[10:21:10.728]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:10.728]                       if (muffled) 
[10:21:10.728]                         invokeRestart("muffleWarning")
[10:21:10.728]                     }
[10:21:10.728]                     else if (inherits(cond, "condition")) {
[10:21:10.728]                       if (!is.null(pattern)) {
[10:21:10.728]                         computeRestarts <- base::computeRestarts
[10:21:10.728]                         grepl <- base::grepl
[10:21:10.728]                         restarts <- computeRestarts(cond)
[10:21:10.728]                         for (restart in restarts) {
[10:21:10.728]                           name <- restart$name
[10:21:10.728]                           if (is.null(name)) 
[10:21:10.728]                             next
[10:21:10.728]                           if (!grepl(pattern, name)) 
[10:21:10.728]                             next
[10:21:10.728]                           invokeRestart(restart)
[10:21:10.728]                           muffled <- TRUE
[10:21:10.728]                           break
[10:21:10.728]                         }
[10:21:10.728]                       }
[10:21:10.728]                     }
[10:21:10.728]                     invisible(muffled)
[10:21:10.728]                   }
[10:21:10.728]                   muffleCondition(cond)
[10:21:10.728]                 })
[10:21:10.728]             }))
[10:21:10.728]             future::FutureResult(value = ...future.value$value, 
[10:21:10.728]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.728]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.728]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.728]                     ...future.globalenv.names))
[10:21:10.728]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.728]         }, condition = base::local({
[10:21:10.728]             c <- base::c
[10:21:10.728]             inherits <- base::inherits
[10:21:10.728]             invokeRestart <- base::invokeRestart
[10:21:10.728]             length <- base::length
[10:21:10.728]             list <- base::list
[10:21:10.728]             seq.int <- base::seq.int
[10:21:10.728]             signalCondition <- base::signalCondition
[10:21:10.728]             sys.calls <- base::sys.calls
[10:21:10.728]             `[[` <- base::`[[`
[10:21:10.728]             `+` <- base::`+`
[10:21:10.728]             `<<-` <- base::`<<-`
[10:21:10.728]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.728]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.728]                   3L)]
[10:21:10.728]             }
[10:21:10.728]             function(cond) {
[10:21:10.728]                 is_error <- inherits(cond, "error")
[10:21:10.728]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.728]                   NULL)
[10:21:10.728]                 if (is_error) {
[10:21:10.728]                   sessionInformation <- function() {
[10:21:10.728]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.728]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.728]                       search = base::search(), system = base::Sys.info())
[10:21:10.728]                   }
[10:21:10.728]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.728]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.728]                     cond$call), session = sessionInformation(), 
[10:21:10.728]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.728]                   signalCondition(cond)
[10:21:10.728]                 }
[10:21:10.728]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.728]                 "immediateCondition"))) {
[10:21:10.728]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.728]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.728]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.728]                   if (TRUE && !signal) {
[10:21:10.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.728]                     {
[10:21:10.728]                       inherits <- base::inherits
[10:21:10.728]                       invokeRestart <- base::invokeRestart
[10:21:10.728]                       is.null <- base::is.null
[10:21:10.728]                       muffled <- FALSE
[10:21:10.728]                       if (inherits(cond, "message")) {
[10:21:10.728]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.728]                         if (muffled) 
[10:21:10.728]                           invokeRestart("muffleMessage")
[10:21:10.728]                       }
[10:21:10.728]                       else if (inherits(cond, "warning")) {
[10:21:10.728]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.728]                         if (muffled) 
[10:21:10.728]                           invokeRestart("muffleWarning")
[10:21:10.728]                       }
[10:21:10.728]                       else if (inherits(cond, "condition")) {
[10:21:10.728]                         if (!is.null(pattern)) {
[10:21:10.728]                           computeRestarts <- base::computeRestarts
[10:21:10.728]                           grepl <- base::grepl
[10:21:10.728]                           restarts <- computeRestarts(cond)
[10:21:10.728]                           for (restart in restarts) {
[10:21:10.728]                             name <- restart$name
[10:21:10.728]                             if (is.null(name)) 
[10:21:10.728]                               next
[10:21:10.728]                             if (!grepl(pattern, name)) 
[10:21:10.728]                               next
[10:21:10.728]                             invokeRestart(restart)
[10:21:10.728]                             muffled <- TRUE
[10:21:10.728]                             break
[10:21:10.728]                           }
[10:21:10.728]                         }
[10:21:10.728]                       }
[10:21:10.728]                       invisible(muffled)
[10:21:10.728]                     }
[10:21:10.728]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.728]                   }
[10:21:10.728]                 }
[10:21:10.728]                 else {
[10:21:10.728]                   if (TRUE) {
[10:21:10.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.728]                     {
[10:21:10.728]                       inherits <- base::inherits
[10:21:10.728]                       invokeRestart <- base::invokeRestart
[10:21:10.728]                       is.null <- base::is.null
[10:21:10.728]                       muffled <- FALSE
[10:21:10.728]                       if (inherits(cond, "message")) {
[10:21:10.728]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.728]                         if (muffled) 
[10:21:10.728]                           invokeRestart("muffleMessage")
[10:21:10.728]                       }
[10:21:10.728]                       else if (inherits(cond, "warning")) {
[10:21:10.728]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.728]                         if (muffled) 
[10:21:10.728]                           invokeRestart("muffleWarning")
[10:21:10.728]                       }
[10:21:10.728]                       else if (inherits(cond, "condition")) {
[10:21:10.728]                         if (!is.null(pattern)) {
[10:21:10.728]                           computeRestarts <- base::computeRestarts
[10:21:10.728]                           grepl <- base::grepl
[10:21:10.728]                           restarts <- computeRestarts(cond)
[10:21:10.728]                           for (restart in restarts) {
[10:21:10.728]                             name <- restart$name
[10:21:10.728]                             if (is.null(name)) 
[10:21:10.728]                               next
[10:21:10.728]                             if (!grepl(pattern, name)) 
[10:21:10.728]                               next
[10:21:10.728]                             invokeRestart(restart)
[10:21:10.728]                             muffled <- TRUE
[10:21:10.728]                             break
[10:21:10.728]                           }
[10:21:10.728]                         }
[10:21:10.728]                       }
[10:21:10.728]                       invisible(muffled)
[10:21:10.728]                     }
[10:21:10.728]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.728]                   }
[10:21:10.728]                 }
[10:21:10.728]             }
[10:21:10.728]         }))
[10:21:10.728]     }, error = function(ex) {
[10:21:10.728]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.728]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.728]                 ...future.rng), started = ...future.startTime, 
[10:21:10.728]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.728]             version = "1.8"), class = "FutureResult")
[10:21:10.728]     }, finally = {
[10:21:10.728]         if (!identical(...future.workdir, getwd())) 
[10:21:10.728]             setwd(...future.workdir)
[10:21:10.728]         {
[10:21:10.728]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.728]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.728]             }
[10:21:10.728]             base::options(...future.oldOptions)
[10:21:10.728]             if (.Platform$OS.type == "windows") {
[10:21:10.728]                 old_names <- names(...future.oldEnvVars)
[10:21:10.728]                 envs <- base::Sys.getenv()
[10:21:10.728]                 names <- names(envs)
[10:21:10.728]                 common <- intersect(names, old_names)
[10:21:10.728]                 added <- setdiff(names, old_names)
[10:21:10.728]                 removed <- setdiff(old_names, names)
[10:21:10.728]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.728]                   envs[common]]
[10:21:10.728]                 NAMES <- toupper(changed)
[10:21:10.728]                 args <- list()
[10:21:10.728]                 for (kk in seq_along(NAMES)) {
[10:21:10.728]                   name <- changed[[kk]]
[10:21:10.728]                   NAME <- NAMES[[kk]]
[10:21:10.728]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.728]                     next
[10:21:10.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.728]                 }
[10:21:10.728]                 NAMES <- toupper(added)
[10:21:10.728]                 for (kk in seq_along(NAMES)) {
[10:21:10.728]                   name <- added[[kk]]
[10:21:10.728]                   NAME <- NAMES[[kk]]
[10:21:10.728]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.728]                     next
[10:21:10.728]                   args[[name]] <- ""
[10:21:10.728]                 }
[10:21:10.728]                 NAMES <- toupper(removed)
[10:21:10.728]                 for (kk in seq_along(NAMES)) {
[10:21:10.728]                   name <- removed[[kk]]
[10:21:10.728]                   NAME <- NAMES[[kk]]
[10:21:10.728]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.728]                     next
[10:21:10.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.728]                 }
[10:21:10.728]                 if (length(args) > 0) 
[10:21:10.728]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.728]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.728]             }
[10:21:10.728]             else {
[10:21:10.728]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.728]             }
[10:21:10.728]             {
[10:21:10.728]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.728]                   0L) {
[10:21:10.728]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.728]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.728]                   base::options(opts)
[10:21:10.728]                 }
[10:21:10.728]                 {
[10:21:10.728]                   {
[10:21:10.728]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:10.728]                     NULL
[10:21:10.728]                   }
[10:21:10.728]                   options(future.plan = NULL)
[10:21:10.728]                   if (is.na(NA_character_)) 
[10:21:10.728]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.728]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.728]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.728]                     .init = FALSE)
[10:21:10.728]                 }
[10:21:10.728]             }
[10:21:10.728]         }
[10:21:10.728]     })
[10:21:10.728]     if (TRUE) {
[10:21:10.728]         base::sink(type = "output", split = FALSE)
[10:21:10.728]         if (TRUE) {
[10:21:10.728]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.728]         }
[10:21:10.728]         else {
[10:21:10.728]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.728]         }
[10:21:10.728]         base::close(...future.stdout)
[10:21:10.728]         ...future.stdout <- NULL
[10:21:10.728]     }
[10:21:10.728]     ...future.result$conditions <- ...future.conditions
[10:21:10.728]     ...future.result$finished <- base::Sys.time()
[10:21:10.728]     ...future.result
[10:21:10.728] }
[10:21:10.731] assign_globals() ...
[10:21:10.732] List of 1
[10:21:10.732]  $ ii: int 3
[10:21:10.732]  - attr(*, "where")=List of 1
[10:21:10.732]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:10.732]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:10.732]  - attr(*, "resolved")= logi FALSE
[10:21:10.732]  - attr(*, "total_size")= num 35
[10:21:10.732]  - attr(*, "already-done")= logi TRUE
[10:21:10.736] - copied ‘ii’ to environment
[10:21:10.737] assign_globals() ... done
[10:21:10.737] requestCore(): workers = 2
[10:21:10.737] Poll #1 (0): usedCores() = 2, workers = 2
[10:21:10.749] result() for MulticoreFuture ...
[10:21:10.749] result() for MulticoreFuture ...
[10:21:10.750] result() for MulticoreFuture ... done
[10:21:10.750] result() for MulticoreFuture ... done
[10:21:10.750] result() for MulticoreFuture ...
[10:21:10.750] result() for MulticoreFuture ... done
[10:21:10.753] MulticoreFuture started
[10:21:10.753] - Launch lazy future ... done
[10:21:10.754] run() for ‘MulticoreFuture’ ... done
[10:21:10.754] plan(): Setting new future strategy stack:
[10:21:10.754] result() for MulticoreFuture ...
[10:21:10.755] result() for MulticoreFuture ... done
[10:21:10.755] result() for MulticoreFuture ...
[10:21:10.755] result() for MulticoreFuture ... done
[10:21:10.756] result() for MulticoreFuture ...
[10:21:10.754] List of future strategies:
[10:21:10.754] 1. sequential:
[10:21:10.754]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.754]    - tweaked: FALSE
[10:21:10.754]    - call: NULL
[10:21:10.756] plan(): nbrOfWorkers() = 1
[10:21:10.759] plan(): Setting new future strategy stack:
[10:21:10.759] List of future strategies:
[10:21:10.759] 1. multicore:
[10:21:10.759]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:10.759]    - tweaked: FALSE
[10:21:10.759]    - call: plan(strategy)
[10:21:10.761] result() for MulticoreFuture ...
[10:21:10.761] result() for MulticoreFuture ... done
[10:21:10.761] signalConditions() ...
[10:21:10.762]  - include = ‘immediateCondition’
[10:21:10.762]  - exclude = 
[10:21:10.762]  - resignal = FALSE
[10:21:10.762]  - Number of conditions: 1
[10:21:10.763] signalConditions() ... done
[10:21:10.763] result() for MulticoreFuture ... done
[10:21:10.763] result() for MulticoreFuture ...
[10:21:10.763] result() for MulticoreFuture ... done
[10:21:10.763] signalConditions() ...
[10:21:10.764] plan(): nbrOfWorkers() = 2
[10:21:10.764]  - include = ‘immediateCondition’
[10:21:10.764]  - exclude = 
[10:21:10.764]  - resignal = FALSE
[10:21:10.764]  - Number of conditions: 1
[10:21:10.764] signalConditions() ... done
[10:21:10.765] Future state: ‘finished’
[10:21:10.765] result() for MulticoreFuture ...
[10:21:10.765] result() for MulticoreFuture ... done
[10:21:10.765] signalConditions() ...
[10:21:10.765]  - include = ‘condition’
[10:21:10.765]  - exclude = ‘immediateCondition’
[10:21:10.765]  - resignal = TRUE
[10:21:10.766]  - Number of conditions: 1
[10:21:10.766]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:10.766] signalConditions() ... done
[10:21:10.767] result() for MulticoreFuture ...
[10:21:10.767] result() for MulticoreFuture ...
[10:21:10.768] result() for MulticoreFuture ... done
[10:21:10.768] result() for MulticoreFuture ... done
[10:21:10.768] result() for MulticoreFuture ...
[10:21:10.768] result() for MulticoreFuture ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[10:21:10.769] result() for MulticoreFuture ...
[10:21:10.769] result() for MulticoreFuture ... done
[10:21:10.769] result() for MulticoreFuture ...
[10:21:10.769] result() for MulticoreFuture ... done
[10:21:10.769] signalConditions() ...
[10:21:10.769]  - include = ‘immediateCondition’
[10:21:10.770]  - exclude = 
[10:21:10.770]  - resignal = FALSE
[10:21:10.770]  - Number of conditions: 1
[10:21:10.770] signalConditions() ... done
[10:21:10.770] Future state: ‘finished’
[10:21:10.770] result() for MulticoreFuture ...
[10:21:10.770] result() for MulticoreFuture ... done
[10:21:10.770] signalConditions() ...
[10:21:10.771]  - include = ‘condition’
[10:21:10.771]  - exclude = ‘immediateCondition’
[10:21:10.771]  - resignal = TRUE
[10:21:10.771]  - Number of conditions: 1
[10:21:10.771]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:10.771] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[10:21:10.772] result() for MulticoreFuture ...
[10:21:10.772] result() for MulticoreFuture ... done
[10:21:10.772] result() for MulticoreFuture ...
[10:21:10.772] result() for MulticoreFuture ... done
[10:21:10.772] signalConditions() ...
[10:21:10.772]  - include = ‘immediateCondition’
[10:21:10.772]  - exclude = 
[10:21:10.772]  - resignal = FALSE
[10:21:10.772]  - Number of conditions: 1
[10:21:10.773] signalConditions() ... done
[10:21:10.773] Future state: ‘finished’
[10:21:10.773] result() for MulticoreFuture ...
[10:21:10.773] result() for MulticoreFuture ... done
[10:21:10.773] signalConditions() ...
[10:21:10.773]  - include = ‘condition’
[10:21:10.773]  - exclude = ‘immediateCondition’
[10:21:10.773]  - resignal = TRUE
[10:21:10.773]  - Number of conditions: 1
[10:21:10.773]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:10.774] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[10:21:10.774] getGlobalsAndPackages() ...
[10:21:10.774] Searching for globals...
[10:21:10.777] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[10:21:10.777] Searching for globals ... DONE
[10:21:10.777] Resolving globals: FALSE
[10:21:10.777] 
[10:21:10.778] 
[10:21:10.778] getGlobalsAndPackages() ... DONE
[10:21:10.778] run() for ‘Future’ ...
[10:21:10.778] - state: ‘created’
[10:21:10.778] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:10.780] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:10.784] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:10.784]   - Field: ‘label’
[10:21:10.784]   - Field: ‘local’
[10:21:10.784]   - Field: ‘owner’
[10:21:10.784]   - Field: ‘envir’
[10:21:10.784]   - Field: ‘workers’
[10:21:10.784]   - Field: ‘packages’
[10:21:10.785]   - Field: ‘gc’
[10:21:10.785]   - Field: ‘job’
[10:21:10.785]   - Field: ‘conditions’
[10:21:10.785]   - Field: ‘expr’
[10:21:10.785]   - Field: ‘uuid’
[10:21:10.785]   - Field: ‘seed’
[10:21:10.785]   - Field: ‘version’
[10:21:10.785]   - Field: ‘result’
[10:21:10.786]   - Field: ‘asynchronous’
[10:21:10.786]   - Field: ‘calls’
[10:21:10.786]   - Field: ‘globals’
[10:21:10.786]   - Field: ‘stdout’
[10:21:10.786]   - Field: ‘earlySignal’
[10:21:10.786]   - Field: ‘lazy’
[10:21:10.786]   - Field: ‘state’
[10:21:10.786] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:10.787] - Launch lazy future ...
[10:21:10.787] Packages needed by the future expression (n = 0): <none>
[10:21:10.787] Packages needed by future strategies (n = 0): <none>
[10:21:10.788] {
[10:21:10.788]     {
[10:21:10.788]         {
[10:21:10.788]             ...future.startTime <- base::Sys.time()
[10:21:10.788]             {
[10:21:10.788]                 {
[10:21:10.788]                   {
[10:21:10.788]                     {
[10:21:10.788]                       base::local({
[10:21:10.788]                         has_future <- base::requireNamespace("future", 
[10:21:10.788]                           quietly = TRUE)
[10:21:10.788]                         if (has_future) {
[10:21:10.788]                           ns <- base::getNamespace("future")
[10:21:10.788]                           version <- ns[[".package"]][["version"]]
[10:21:10.788]                           if (is.null(version)) 
[10:21:10.788]                             version <- utils::packageVersion("future")
[10:21:10.788]                         }
[10:21:10.788]                         else {
[10:21:10.788]                           version <- NULL
[10:21:10.788]                         }
[10:21:10.788]                         if (!has_future || version < "1.8.0") {
[10:21:10.788]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.788]                             "", base::R.version$version.string), 
[10:21:10.788]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:10.788]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.788]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.788]                               "release", "version")], collapse = " "), 
[10:21:10.788]                             hostname = base::Sys.info()[["nodename"]])
[10:21:10.788]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.788]                             info)
[10:21:10.788]                           info <- base::paste(info, collapse = "; ")
[10:21:10.788]                           if (!has_future) {
[10:21:10.788]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.788]                               info)
[10:21:10.788]                           }
[10:21:10.788]                           else {
[10:21:10.788]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.788]                               info, version)
[10:21:10.788]                           }
[10:21:10.788]                           base::stop(msg)
[10:21:10.788]                         }
[10:21:10.788]                       })
[10:21:10.788]                     }
[10:21:10.788]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:10.788]                     base::options(mc.cores = 1L)
[10:21:10.788]                   }
[10:21:10.788]                   ...future.strategy.old <- future::plan("list")
[10:21:10.788]                   options(future.plan = NULL)
[10:21:10.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.788]                 }
[10:21:10.788]                 ...future.workdir <- getwd()
[10:21:10.788]             }
[10:21:10.788]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.788]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.788]         }
[10:21:10.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.788]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.788]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.788]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.788]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.788]             base::names(...future.oldOptions))
[10:21:10.788]     }
[10:21:10.788]     if (FALSE) {
[10:21:10.788]     }
[10:21:10.788]     else {
[10:21:10.788]         if (TRUE) {
[10:21:10.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.788]                 open = "w")
[10:21:10.788]         }
[10:21:10.788]         else {
[10:21:10.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.788]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.788]         }
[10:21:10.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.788]             base::sink(type = "output", split = FALSE)
[10:21:10.788]             base::close(...future.stdout)
[10:21:10.788]         }, add = TRUE)
[10:21:10.788]     }
[10:21:10.788]     ...future.frame <- base::sys.nframe()
[10:21:10.788]     ...future.conditions <- base::list()
[10:21:10.788]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.788]     if (FALSE) {
[10:21:10.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.788]     }
[10:21:10.788]     ...future.result <- base::tryCatch({
[10:21:10.788]         base::withCallingHandlers({
[10:21:10.788]             ...future.value <- base::withVisible(base::local({
[10:21:10.788]                 withCallingHandlers({
[10:21:10.788]                   {
[10:21:10.788]                     cat("Processing: ")
[10:21:10.788]                     for (ii in 1:10) {
[10:21:10.788]                       cat(".")
[10:21:10.788]                     }
[10:21:10.788]                     cat(" [100%]\n")
[10:21:10.788]                     4
[10:21:10.788]                   }
[10:21:10.788]                 }, immediateCondition = function(cond) {
[10:21:10.788]                   save_rds <- function (object, pathname, ...) 
[10:21:10.788]                   {
[10:21:10.788]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:10.788]                     if (file_test("-f", pathname_tmp)) {
[10:21:10.788]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.788]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:10.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.788]                         fi_tmp[["mtime"]])
[10:21:10.788]                     }
[10:21:10.788]                     tryCatch({
[10:21:10.788]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:10.788]                     }, error = function(ex) {
[10:21:10.788]                       msg <- conditionMessage(ex)
[10:21:10.788]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.788]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:10.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.788]                         fi_tmp[["mtime"]], msg)
[10:21:10.788]                       ex$message <- msg
[10:21:10.788]                       stop(ex)
[10:21:10.788]                     })
[10:21:10.788]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:10.788]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:10.788]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:10.788]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.788]                       fi <- file.info(pathname)
[10:21:10.788]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:10.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.788]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:10.788]                         fi[["size"]], fi[["mtime"]])
[10:21:10.788]                       stop(msg)
[10:21:10.788]                     }
[10:21:10.788]                     invisible(pathname)
[10:21:10.788]                   }
[10:21:10.788]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:10.788]                     rootPath = tempdir()) 
[10:21:10.788]                   {
[10:21:10.788]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:10.788]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:10.788]                       tmpdir = path, fileext = ".rds")
[10:21:10.788]                     save_rds(obj, file)
[10:21:10.788]                   }
[10:21:10.788]                   saveImmediateCondition(cond, path = "/tmp/RtmpKymecF/.future/immediateConditions")
[10:21:10.788]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.788]                   {
[10:21:10.788]                     inherits <- base::inherits
[10:21:10.788]                     invokeRestart <- base::invokeRestart
[10:21:10.788]                     is.null <- base::is.null
[10:21:10.788]                     muffled <- FALSE
[10:21:10.788]                     if (inherits(cond, "message")) {
[10:21:10.788]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:10.788]                       if (muffled) 
[10:21:10.788]                         invokeRestart("muffleMessage")
[10:21:10.788]                     }
[10:21:10.788]                     else if (inherits(cond, "warning")) {
[10:21:10.788]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:10.788]                       if (muffled) 
[10:21:10.788]                         invokeRestart("muffleWarning")
[10:21:10.788]                     }
[10:21:10.788]                     else if (inherits(cond, "condition")) {
[10:21:10.788]                       if (!is.null(pattern)) {
[10:21:10.788]                         computeRestarts <- base::computeRestarts
[10:21:10.788]                         grepl <- base::grepl
[10:21:10.788]                         restarts <- computeRestarts(cond)
[10:21:10.788]                         for (restart in restarts) {
[10:21:10.788]                           name <- restart$name
[10:21:10.788]                           if (is.null(name)) 
[10:21:10.788]                             next
[10:21:10.788]                           if (!grepl(pattern, name)) 
[10:21:10.788]                             next
[10:21:10.788]                           invokeRestart(restart)
[10:21:10.788]                           muffled <- TRUE
[10:21:10.788]                           break
[10:21:10.788]                         }
[10:21:10.788]                       }
[10:21:10.788]                     }
[10:21:10.788]                     invisible(muffled)
[10:21:10.788]                   }
[10:21:10.788]                   muffleCondition(cond)
[10:21:10.788]                 })
[10:21:10.788]             }))
[10:21:10.788]             future::FutureResult(value = ...future.value$value, 
[10:21:10.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.788]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.788]                     ...future.globalenv.names))
[10:21:10.788]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.788]         }, condition = base::local({
[10:21:10.788]             c <- base::c
[10:21:10.788]             inherits <- base::inherits
[10:21:10.788]             invokeRestart <- base::invokeRestart
[10:21:10.788]             length <- base::length
[10:21:10.788]             list <- base::list
[10:21:10.788]             seq.int <- base::seq.int
[10:21:10.788]             signalCondition <- base::signalCondition
[10:21:10.788]             sys.calls <- base::sys.calls
[10:21:10.788]             `[[` <- base::`[[`
[10:21:10.788]             `+` <- base::`+`
[10:21:10.788]             `<<-` <- base::`<<-`
[10:21:10.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.788]                   3L)]
[10:21:10.788]             }
[10:21:10.788]             function(cond) {
[10:21:10.788]                 is_error <- inherits(cond, "error")
[10:21:10.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.788]                   NULL)
[10:21:10.788]                 if (is_error) {
[10:21:10.788]                   sessionInformation <- function() {
[10:21:10.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.788]                       search = base::search(), system = base::Sys.info())
[10:21:10.788]                   }
[10:21:10.788]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.788]                     cond$call), session = sessionInformation(), 
[10:21:10.788]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.788]                   signalCondition(cond)
[10:21:10.788]                 }
[10:21:10.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.788]                 "immediateCondition"))) {
[10:21:10.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.788]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.788]                   if (TRUE && !signal) {
[10:21:10.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.788]                     {
[10:21:10.788]                       inherits <- base::inherits
[10:21:10.788]                       invokeRestart <- base::invokeRestart
[10:21:10.788]                       is.null <- base::is.null
[10:21:10.788]                       muffled <- FALSE
[10:21:10.788]                       if (inherits(cond, "message")) {
[10:21:10.788]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.788]                         if (muffled) 
[10:21:10.788]                           invokeRestart("muffleMessage")
[10:21:10.788]                       }
[10:21:10.788]                       else if (inherits(cond, "warning")) {
[10:21:10.788]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.788]                         if (muffled) 
[10:21:10.788]                           invokeRestart("muffleWarning")
[10:21:10.788]                       }
[10:21:10.788]                       else if (inherits(cond, "condition")) {
[10:21:10.788]                         if (!is.null(pattern)) {
[10:21:10.788]                           computeRestarts <- base::computeRestarts
[10:21:10.788]                           grepl <- base::grepl
[10:21:10.788]                           restarts <- computeRestarts(cond)
[10:21:10.788]                           for (restart in restarts) {
[10:21:10.788]                             name <- restart$name
[10:21:10.788]                             if (is.null(name)) 
[10:21:10.788]                               next
[10:21:10.788]                             if (!grepl(pattern, name)) 
[10:21:10.788]                               next
[10:21:10.788]                             invokeRestart(restart)
[10:21:10.788]                             muffled <- TRUE
[10:21:10.788]                             break
[10:21:10.788]                           }
[10:21:10.788]                         }
[10:21:10.788]                       }
[10:21:10.788]                       invisible(muffled)
[10:21:10.788]                     }
[10:21:10.788]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.788]                   }
[10:21:10.788]                 }
[10:21:10.788]                 else {
[10:21:10.788]                   if (TRUE) {
[10:21:10.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.788]                     {
[10:21:10.788]                       inherits <- base::inherits
[10:21:10.788]                       invokeRestart <- base::invokeRestart
[10:21:10.788]                       is.null <- base::is.null
[10:21:10.788]                       muffled <- FALSE
[10:21:10.788]                       if (inherits(cond, "message")) {
[10:21:10.788]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.788]                         if (muffled) 
[10:21:10.788]                           invokeRestart("muffleMessage")
[10:21:10.788]                       }
[10:21:10.788]                       else if (inherits(cond, "warning")) {
[10:21:10.788]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.788]                         if (muffled) 
[10:21:10.788]                           invokeRestart("muffleWarning")
[10:21:10.788]                       }
[10:21:10.788]                       else if (inherits(cond, "condition")) {
[10:21:10.788]                         if (!is.null(pattern)) {
[10:21:10.788]                           computeRestarts <- base::computeRestarts
[10:21:10.788]                           grepl <- base::grepl
[10:21:10.788]                           restarts <- computeRestarts(cond)
[10:21:10.788]                           for (restart in restarts) {
[10:21:10.788]                             name <- restart$name
[10:21:10.788]                             if (is.null(name)) 
[10:21:10.788]                               next
[10:21:10.788]                             if (!grepl(pattern, name)) 
[10:21:10.788]                               next
[10:21:10.788]                             invokeRestart(restart)
[10:21:10.788]                             muffled <- TRUE
[10:21:10.788]                             break
[10:21:10.788]                           }
[10:21:10.788]                         }
[10:21:10.788]                       }
[10:21:10.788]                       invisible(muffled)
[10:21:10.788]                     }
[10:21:10.788]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.788]                   }
[10:21:10.788]                 }
[10:21:10.788]             }
[10:21:10.788]         }))
[10:21:10.788]     }, error = function(ex) {
[10:21:10.788]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.788]                 ...future.rng), started = ...future.startTime, 
[10:21:10.788]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.788]             version = "1.8"), class = "FutureResult")
[10:21:10.788]     }, finally = {
[10:21:10.788]         if (!identical(...future.workdir, getwd())) 
[10:21:10.788]             setwd(...future.workdir)
[10:21:10.788]         {
[10:21:10.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.788]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.788]             }
[10:21:10.788]             base::options(...future.oldOptions)
[10:21:10.788]             if (.Platform$OS.type == "windows") {
[10:21:10.788]                 old_names <- names(...future.oldEnvVars)
[10:21:10.788]                 envs <- base::Sys.getenv()
[10:21:10.788]                 names <- names(envs)
[10:21:10.788]                 common <- intersect(names, old_names)
[10:21:10.788]                 added <- setdiff(names, old_names)
[10:21:10.788]                 removed <- setdiff(old_names, names)
[10:21:10.788]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.788]                   envs[common]]
[10:21:10.788]                 NAMES <- toupper(changed)
[10:21:10.788]                 args <- list()
[10:21:10.788]                 for (kk in seq_along(NAMES)) {
[10:21:10.788]                   name <- changed[[kk]]
[10:21:10.788]                   NAME <- NAMES[[kk]]
[10:21:10.788]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.788]                     next
[10:21:10.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.788]                 }
[10:21:10.788]                 NAMES <- toupper(added)
[10:21:10.788]                 for (kk in seq_along(NAMES)) {
[10:21:10.788]                   name <- added[[kk]]
[10:21:10.788]                   NAME <- NAMES[[kk]]
[10:21:10.788]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.788]                     next
[10:21:10.788]                   args[[name]] <- ""
[10:21:10.788]                 }
[10:21:10.788]                 NAMES <- toupper(removed)
[10:21:10.788]                 for (kk in seq_along(NAMES)) {
[10:21:10.788]                   name <- removed[[kk]]
[10:21:10.788]                   NAME <- NAMES[[kk]]
[10:21:10.788]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.788]                     next
[10:21:10.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.788]                 }
[10:21:10.788]                 if (length(args) > 0) 
[10:21:10.788]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.788]             }
[10:21:10.788]             else {
[10:21:10.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.788]             }
[10:21:10.788]             {
[10:21:10.788]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.788]                   0L) {
[10:21:10.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.788]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.788]                   base::options(opts)
[10:21:10.788]                 }
[10:21:10.788]                 {
[10:21:10.788]                   {
[10:21:10.788]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:10.788]                     NULL
[10:21:10.788]                   }
[10:21:10.788]                   options(future.plan = NULL)
[10:21:10.788]                   if (is.na(NA_character_)) 
[10:21:10.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.788]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.788]                     .init = FALSE)
[10:21:10.788]                 }
[10:21:10.788]             }
[10:21:10.788]         }
[10:21:10.788]     })
[10:21:10.788]     if (TRUE) {
[10:21:10.788]         base::sink(type = "output", split = FALSE)
[10:21:10.788]         if (TRUE) {
[10:21:10.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.788]         }
[10:21:10.788]         else {
[10:21:10.788]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.788]         }
[10:21:10.788]         base::close(...future.stdout)
[10:21:10.788]         ...future.stdout <- NULL
[10:21:10.788]     }
[10:21:10.788]     ...future.result$conditions <- ...future.conditions
[10:21:10.788]     ...future.result$finished <- base::Sys.time()
[10:21:10.788]     ...future.result
[10:21:10.788] }
[10:21:10.790] requestCore(): workers = 2
[10:21:10.792] MulticoreFuture started
[10:21:10.793] - Launch lazy future ... done
[10:21:10.793] run() for ‘MulticoreFuture’ ... done
[10:21:10.793] plan(): Setting new future strategy stack:
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[10:21:10.794] result() for MulticoreFuture ...
[10:21:10.794] result() for MulticoreFuture ... done
[10:21:10.794] result() for MulticoreFuture ...
[10:21:10.794] List of future strategies:
[10:21:10.794] 1. sequential:
[10:21:10.794]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.794]    - tweaked: FALSE
[10:21:10.794]    - call: NULL
[10:21:10.795] result() for MulticoreFuture ... done
[10:21:10.795] signalConditions() ...
[10:21:10.795] plan(): nbrOfWorkers() = 1
[10:21:10.795]  - include = ‘immediateCondition’
[10:21:10.795]  - exclude = 
[10:21:10.795]  - resignal = FALSE
[10:21:10.795]  - Number of conditions: 1
[10:21:10.796] signalConditions() ... done
[10:21:10.796] Future state: ‘finished’
[10:21:10.796] result() for MulticoreFuture ...
[10:21:10.796] result() for MulticoreFuture ... done
[10:21:10.796] signalConditions() ...
[10:21:10.796]  - include = ‘condition’
[10:21:10.797] plan(): Setting new future strategy stack:
[10:21:10.797]  - exclude = ‘immediateCondition’
[10:21:10.797]  - resignal = TRUE
[10:21:10.797]  - Number of conditions: 1
[10:21:10.797] List of future strategies:
[10:21:10.797] 1. multicore:
[10:21:10.797]    - args: function (..., workers = availa[10:21:10.797]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
bleCores(constraints = "multicore"), envir = parent.frame())
[10:21:10.797]    - tweaked: FALSE
[10:21:10.797]    - call: plan(strategy)
[10:21:10.797] signalConditions() ... done
v3: <simpleError> (as expect)
[10:21:10.798] result() for MulticoreFuture ...
[10:21:10.800] plan(): nbrOfWorkers() = 2
[10:21:10.801] result() for MulticoreFuture ...
[10:21:10.801] result() for MulticoreFuture ... done
[10:21:10.801] result() for MulticoreFuture ... done
[10:21:10.801] result() for MulticoreFuture ...
[10:21:10.801] result() for MulticoreFuture ... done
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[10:21:10.802] getGlobalsAndPackages() ...
[10:21:10.802] Searching for globals...
[10:21:10.802] 
[10:21:10.803] Searching for globals ... DONE
[10:21:10.803] - globals: [0] <none>
[10:21:10.803] getGlobalsAndPackages() ... DONE
[10:21:10.803] run() for ‘Future’ ...
[10:21:10.803] - state: ‘created’
[10:21:10.804] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:10.806] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:10.806] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:10.806]   - Field: ‘label’
[10:21:10.806]   - Field: ‘local’
[10:21:10.806]   - Field: ‘owner’
[10:21:10.806]   - Field: ‘envir’
[10:21:10.806]   - Field: ‘workers’
[10:21:10.807]   - Field: ‘packages’
[10:21:10.807]   - Field: ‘gc’
[10:21:10.807]   - Field: ‘job’
[10:21:10.807]   - Field: ‘conditions’
[10:21:10.807]   - Field: ‘expr’
[10:21:10.807]   - Field: ‘uuid’
[10:21:10.807]   - Field: ‘seed’
[10:21:10.807]   - Field: ‘version’
[10:21:10.807]   - Field: ‘result’
[10:21:10.808]   - Field: ‘asynchronous’
[10:21:10.808]   - Field: ‘calls’
[10:21:10.808]   - Field: ‘globals’
[10:21:10.808]   - Field: ‘stdout’
[10:21:10.808]   - Field: ‘earlySignal’
[10:21:10.808]   - Field: ‘lazy’
[10:21:10.808]   - Field: ‘state’
[10:21:10.808] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:10.808] - Launch lazy future ...
[10:21:10.809] Packages needed by the future expression (n = 0): <none>
[10:21:10.809] Packages needed by future strategies (n = 0): <none>
[10:21:10.809] {
[10:21:10.809]     {
[10:21:10.809]         {
[10:21:10.809]             ...future.startTime <- base::Sys.time()
[10:21:10.809]             {
[10:21:10.809]                 {
[10:21:10.809]                   {
[10:21:10.809]                     {
[10:21:10.809]                       base::local({
[10:21:10.809]                         has_future <- base::requireNamespace("future", 
[10:21:10.809]                           quietly = TRUE)
[10:21:10.809]                         if (has_future) {
[10:21:10.809]                           ns <- base::getNamespace("future")
[10:21:10.809]                           version <- ns[[".package"]][["version"]]
[10:21:10.809]                           if (is.null(version)) 
[10:21:10.809]                             version <- utils::packageVersion("future")
[10:21:10.809]                         }
[10:21:10.809]                         else {
[10:21:10.809]                           version <- NULL
[10:21:10.809]                         }
[10:21:10.809]                         if (!has_future || version < "1.8.0") {
[10:21:10.809]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.809]                             "", base::R.version$version.string), 
[10:21:10.809]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:10.809]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.809]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.809]                               "release", "version")], collapse = " "), 
[10:21:10.809]                             hostname = base::Sys.info()[["nodename"]])
[10:21:10.809]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.809]                             info)
[10:21:10.809]                           info <- base::paste(info, collapse = "; ")
[10:21:10.809]                           if (!has_future) {
[10:21:10.809]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.809]                               info)
[10:21:10.809]                           }
[10:21:10.809]                           else {
[10:21:10.809]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.809]                               info, version)
[10:21:10.809]                           }
[10:21:10.809]                           base::stop(msg)
[10:21:10.809]                         }
[10:21:10.809]                       })
[10:21:10.809]                     }
[10:21:10.809]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:10.809]                     base::options(mc.cores = 1L)
[10:21:10.809]                   }
[10:21:10.809]                   ...future.strategy.old <- future::plan("list")
[10:21:10.809]                   options(future.plan = NULL)
[10:21:10.809]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.809]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.809]                 }
[10:21:10.809]                 ...future.workdir <- getwd()
[10:21:10.809]             }
[10:21:10.809]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.809]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.809]         }
[10:21:10.809]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.809]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.809]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.809]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.809]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.809]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.809]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.809]             base::names(...future.oldOptions))
[10:21:10.809]     }
[10:21:10.809]     if (FALSE) {
[10:21:10.809]     }
[10:21:10.809]     else {
[10:21:10.809]         if (TRUE) {
[10:21:10.809]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.809]                 open = "w")
[10:21:10.809]         }
[10:21:10.809]         else {
[10:21:10.809]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.809]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.809]         }
[10:21:10.809]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.809]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.809]             base::sink(type = "output", split = FALSE)
[10:21:10.809]             base::close(...future.stdout)
[10:21:10.809]         }, add = TRUE)
[10:21:10.809]     }
[10:21:10.809]     ...future.frame <- base::sys.nframe()
[10:21:10.809]     ...future.conditions <- base::list()
[10:21:10.809]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.809]     if (FALSE) {
[10:21:10.809]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.809]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.809]     }
[10:21:10.809]     ...future.result <- base::tryCatch({
[10:21:10.809]         base::withCallingHandlers({
[10:21:10.809]             ...future.value <- base::withVisible(base::local({
[10:21:10.809]                 withCallingHandlers({
[10:21:10.809]                   1
[10:21:10.809]                 }, immediateCondition = function(cond) {
[10:21:10.809]                   save_rds <- function (object, pathname, ...) 
[10:21:10.809]                   {
[10:21:10.809]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:10.809]                     if (file_test("-f", pathname_tmp)) {
[10:21:10.809]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.809]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:10.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.809]                         fi_tmp[["mtime"]])
[10:21:10.809]                     }
[10:21:10.809]                     tryCatch({
[10:21:10.809]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:10.809]                     }, error = function(ex) {
[10:21:10.809]                       msg <- conditionMessage(ex)
[10:21:10.809]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.809]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:10.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.809]                         fi_tmp[["mtime"]], msg)
[10:21:10.809]                       ex$message <- msg
[10:21:10.809]                       stop(ex)
[10:21:10.809]                     })
[10:21:10.809]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:10.809]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:10.809]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:10.809]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.809]                       fi <- file.info(pathname)
[10:21:10.809]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:10.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.809]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:10.809]                         fi[["size"]], fi[["mtime"]])
[10:21:10.809]                       stop(msg)
[10:21:10.809]                     }
[10:21:10.809]                     invisible(pathname)
[10:21:10.809]                   }
[10:21:10.809]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:10.809]                     rootPath = tempdir()) 
[10:21:10.809]                   {
[10:21:10.809]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:10.809]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:10.809]                       tmpdir = path, fileext = ".rds")
[10:21:10.809]                     save_rds(obj, file)
[10:21:10.809]                   }
[10:21:10.809]                   saveImmediateCondition(cond, path = "/tmp/RtmpKymecF/.future/immediateConditions")
[10:21:10.809]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.809]                   {
[10:21:10.809]                     inherits <- base::inherits
[10:21:10.809]                     invokeRestart <- base::invokeRestart
[10:21:10.809]                     is.null <- base::is.null
[10:21:10.809]                     muffled <- FALSE
[10:21:10.809]                     if (inherits(cond, "message")) {
[10:21:10.809]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:10.809]                       if (muffled) 
[10:21:10.809]                         invokeRestart("muffleMessage")
[10:21:10.809]                     }
[10:21:10.809]                     else if (inherits(cond, "warning")) {
[10:21:10.809]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:10.809]                       if (muffled) 
[10:21:10.809]                         invokeRestart("muffleWarning")
[10:21:10.809]                     }
[10:21:10.809]                     else if (inherits(cond, "condition")) {
[10:21:10.809]                       if (!is.null(pattern)) {
[10:21:10.809]                         computeRestarts <- base::computeRestarts
[10:21:10.809]                         grepl <- base::grepl
[10:21:10.809]                         restarts <- computeRestarts(cond)
[10:21:10.809]                         for (restart in restarts) {
[10:21:10.809]                           name <- restart$name
[10:21:10.809]                           if (is.null(name)) 
[10:21:10.809]                             next
[10:21:10.809]                           if (!grepl(pattern, name)) 
[10:21:10.809]                             next
[10:21:10.809]                           invokeRestart(restart)
[10:21:10.809]                           muffled <- TRUE
[10:21:10.809]                           break
[10:21:10.809]                         }
[10:21:10.809]                       }
[10:21:10.809]                     }
[10:21:10.809]                     invisible(muffled)
[10:21:10.809]                   }
[10:21:10.809]                   muffleCondition(cond)
[10:21:10.809]                 })
[10:21:10.809]             }))
[10:21:10.809]             future::FutureResult(value = ...future.value$value, 
[10:21:10.809]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.809]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.809]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.809]                     ...future.globalenv.names))
[10:21:10.809]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.809]         }, condition = base::local({
[10:21:10.809]             c <- base::c
[10:21:10.809]             inherits <- base::inherits
[10:21:10.809]             invokeRestart <- base::invokeRestart
[10:21:10.809]             length <- base::length
[10:21:10.809]             list <- base::list
[10:21:10.809]             seq.int <- base::seq.int
[10:21:10.809]             signalCondition <- base::signalCondition
[10:21:10.809]             sys.calls <- base::sys.calls
[10:21:10.809]             `[[` <- base::`[[`
[10:21:10.809]             `+` <- base::`+`
[10:21:10.809]             `<<-` <- base::`<<-`
[10:21:10.809]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.809]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.809]                   3L)]
[10:21:10.809]             }
[10:21:10.809]             function(cond) {
[10:21:10.809]                 is_error <- inherits(cond, "error")
[10:21:10.809]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.809]                   NULL)
[10:21:10.809]                 if (is_error) {
[10:21:10.809]                   sessionInformation <- function() {
[10:21:10.809]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.809]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.809]                       search = base::search(), system = base::Sys.info())
[10:21:10.809]                   }
[10:21:10.809]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.809]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.809]                     cond$call), session = sessionInformation(), 
[10:21:10.809]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.809]                   signalCondition(cond)
[10:21:10.809]                 }
[10:21:10.809]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.809]                 "immediateCondition"))) {
[10:21:10.809]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.809]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.809]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.809]                   if (TRUE && !signal) {
[10:21:10.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.809]                     {
[10:21:10.809]                       inherits <- base::inherits
[10:21:10.809]                       invokeRestart <- base::invokeRestart
[10:21:10.809]                       is.null <- base::is.null
[10:21:10.809]                       muffled <- FALSE
[10:21:10.809]                       if (inherits(cond, "message")) {
[10:21:10.809]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.809]                         if (muffled) 
[10:21:10.809]                           invokeRestart("muffleMessage")
[10:21:10.809]                       }
[10:21:10.809]                       else if (inherits(cond, "warning")) {
[10:21:10.809]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.809]                         if (muffled) 
[10:21:10.809]                           invokeRestart("muffleWarning")
[10:21:10.809]                       }
[10:21:10.809]                       else if (inherits(cond, "condition")) {
[10:21:10.809]                         if (!is.null(pattern)) {
[10:21:10.809]                           computeRestarts <- base::computeRestarts
[10:21:10.809]                           grepl <- base::grepl
[10:21:10.809]                           restarts <- computeRestarts(cond)
[10:21:10.809]                           for (restart in restarts) {
[10:21:10.809]                             name <- restart$name
[10:21:10.809]                             if (is.null(name)) 
[10:21:10.809]                               next
[10:21:10.809]                             if (!grepl(pattern, name)) 
[10:21:10.809]                               next
[10:21:10.809]                             invokeRestart(restart)
[10:21:10.809]                             muffled <- TRUE
[10:21:10.809]                             break
[10:21:10.809]                           }
[10:21:10.809]                         }
[10:21:10.809]                       }
[10:21:10.809]                       invisible(muffled)
[10:21:10.809]                     }
[10:21:10.809]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.809]                   }
[10:21:10.809]                 }
[10:21:10.809]                 else {
[10:21:10.809]                   if (TRUE) {
[10:21:10.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.809]                     {
[10:21:10.809]                       inherits <- base::inherits
[10:21:10.809]                       invokeRestart <- base::invokeRestart
[10:21:10.809]                       is.null <- base::is.null
[10:21:10.809]                       muffled <- FALSE
[10:21:10.809]                       if (inherits(cond, "message")) {
[10:21:10.809]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.809]                         if (muffled) 
[10:21:10.809]                           invokeRestart("muffleMessage")
[10:21:10.809]                       }
[10:21:10.809]                       else if (inherits(cond, "warning")) {
[10:21:10.809]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.809]                         if (muffled) 
[10:21:10.809]                           invokeRestart("muffleWarning")
[10:21:10.809]                       }
[10:21:10.809]                       else if (inherits(cond, "condition")) {
[10:21:10.809]                         if (!is.null(pattern)) {
[10:21:10.809]                           computeRestarts <- base::computeRestarts
[10:21:10.809]                           grepl <- base::grepl
[10:21:10.809]                           restarts <- computeRestarts(cond)
[10:21:10.809]                           for (restart in restarts) {
[10:21:10.809]                             name <- restart$name
[10:21:10.809]                             if (is.null(name)) 
[10:21:10.809]                               next
[10:21:10.809]                             if (!grepl(pattern, name)) 
[10:21:10.809]                               next
[10:21:10.809]                             invokeRestart(restart)
[10:21:10.809]                             muffled <- TRUE
[10:21:10.809]                             break
[10:21:10.809]                           }
[10:21:10.809]                         }
[10:21:10.809]                       }
[10:21:10.809]                       invisible(muffled)
[10:21:10.809]                     }
[10:21:10.809]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.809]                   }
[10:21:10.809]                 }
[10:21:10.809]             }
[10:21:10.809]         }))
[10:21:10.809]     }, error = function(ex) {
[10:21:10.809]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.809]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.809]                 ...future.rng), started = ...future.startTime, 
[10:21:10.809]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.809]             version = "1.8"), class = "FutureResult")
[10:21:10.809]     }, finally = {
[10:21:10.809]         if (!identical(...future.workdir, getwd())) 
[10:21:10.809]             setwd(...future.workdir)
[10:21:10.809]         {
[10:21:10.809]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.809]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.809]             }
[10:21:10.809]             base::options(...future.oldOptions)
[10:21:10.809]             if (.Platform$OS.type == "windows") {
[10:21:10.809]                 old_names <- names(...future.oldEnvVars)
[10:21:10.809]                 envs <- base::Sys.getenv()
[10:21:10.809]                 names <- names(envs)
[10:21:10.809]                 common <- intersect(names, old_names)
[10:21:10.809]                 added <- setdiff(names, old_names)
[10:21:10.809]                 removed <- setdiff(old_names, names)
[10:21:10.809]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.809]                   envs[common]]
[10:21:10.809]                 NAMES <- toupper(changed)
[10:21:10.809]                 args <- list()
[10:21:10.809]                 for (kk in seq_along(NAMES)) {
[10:21:10.809]                   name <- changed[[kk]]
[10:21:10.809]                   NAME <- NAMES[[kk]]
[10:21:10.809]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.809]                     next
[10:21:10.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.809]                 }
[10:21:10.809]                 NAMES <- toupper(added)
[10:21:10.809]                 for (kk in seq_along(NAMES)) {
[10:21:10.809]                   name <- added[[kk]]
[10:21:10.809]                   NAME <- NAMES[[kk]]
[10:21:10.809]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.809]                     next
[10:21:10.809]                   args[[name]] <- ""
[10:21:10.809]                 }
[10:21:10.809]                 NAMES <- toupper(removed)
[10:21:10.809]                 for (kk in seq_along(NAMES)) {
[10:21:10.809]                   name <- removed[[kk]]
[10:21:10.809]                   NAME <- NAMES[[kk]]
[10:21:10.809]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.809]                     next
[10:21:10.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.809]                 }
[10:21:10.809]                 if (length(args) > 0) 
[10:21:10.809]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.809]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.809]             }
[10:21:10.809]             else {
[10:21:10.809]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.809]             }
[10:21:10.809]             {
[10:21:10.809]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.809]                   0L) {
[10:21:10.809]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.809]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.809]                   base::options(opts)
[10:21:10.809]                 }
[10:21:10.809]                 {
[10:21:10.809]                   {
[10:21:10.809]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:10.809]                     NULL
[10:21:10.809]                   }
[10:21:10.809]                   options(future.plan = NULL)
[10:21:10.809]                   if (is.na(NA_character_)) 
[10:21:10.809]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.809]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.809]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.809]                     .init = FALSE)
[10:21:10.809]                 }
[10:21:10.809]             }
[10:21:10.809]         }
[10:21:10.809]     })
[10:21:10.809]     if (TRUE) {
[10:21:10.809]         base::sink(type = "output", split = FALSE)
[10:21:10.809]         if (TRUE) {
[10:21:10.809]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.809]         }
[10:21:10.809]         else {
[10:21:10.809]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.809]         }
[10:21:10.809]         base::close(...future.stdout)
[10:21:10.809]         ...future.stdout <- NULL
[10:21:10.809]     }
[10:21:10.809]     ...future.result$conditions <- ...future.conditions
[10:21:10.809]     ...future.result$finished <- base::Sys.time()
[10:21:10.809]     ...future.result
[10:21:10.809] }
[10:21:10.812] requestCore(): workers = 2
[10:21:10.814] MulticoreFuture started
[10:21:10.814] - Launch lazy future ... done
[10:21:10.815] run() for ‘MulticoreFuture’ ... done
[10:21:10.815] result() for MulticoreFuture ...
[10:21:10.815] plan(): Setting new future strategy stack:
[10:21:10.815] List of future strategies:
[10:21:10.815] 1. sequential:
[10:21:10.815]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.815]    - tweaked: FALSE
[10:21:10.815]    - call: NULL
[10:21:10.816] plan(): nbrOfWorkers() = 1
[10:21:10.818] plan(): Setting new future strategy stack:
[10:21:10.818] List of future strategies:
[10:21:10.818] 1. multicore:
[10:21:10.818]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:10.818]    - tweaked: FALSE
[10:21:10.818]    - call: plan(strategy)
[10:21:10.821] plan(): nbrOfWorkers() = 2
[10:21:10.822] result() for MulticoreFuture ...
[10:21:10.822] result() for MulticoreFuture ... done
[10:21:10.823] result() for MulticoreFuture ... done
[10:21:10.823] result() for MulticoreFuture ...
[10:21:10.823] result() for MulticoreFuture ... done
c = 1
[10:21:10.823] getGlobalsAndPackages() ...
[10:21:10.823] Searching for globals...
[10:21:10.824] 
[10:21:10.824] Searching for globals ... DONE
[10:21:10.824] - globals: [0] <none>
[10:21:10.824] getGlobalsAndPackages() ... DONE
[10:21:10.825] run() for ‘Future’ ...
[10:21:10.825] - state: ‘created’
[10:21:10.825] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:10.827] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:10.827] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:10.827]   - Field: ‘label’
[10:21:10.828]   - Field: ‘local’
[10:21:10.828]   - Field: ‘owner’
[10:21:10.828]   - Field: ‘envir’
[10:21:10.828]   - Field: ‘workers’
[10:21:10.828]   - Field: ‘packages’
[10:21:10.828]   - Field: ‘gc’
[10:21:10.828]   - Field: ‘job’
[10:21:10.828]   - Field: ‘conditions’
[10:21:10.829]   - Field: ‘expr’
[10:21:10.829]   - Field: ‘uuid’
[10:21:10.829]   - Field: ‘seed’
[10:21:10.829]   - Field: ‘version’
[10:21:10.829]   - Field: ‘result’
[10:21:10.829]   - Field: ‘asynchronous’
[10:21:10.829]   - Field: ‘calls’
[10:21:10.829]   - Field: ‘globals’
[10:21:10.829]   - Field: ‘stdout’
[10:21:10.829]   - Field: ‘earlySignal’
[10:21:10.830]   - Field: ‘lazy’
[10:21:10.830]   - Field: ‘state’
[10:21:10.832] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:10.833] - Launch lazy future ...
[10:21:10.833] Packages needed by the future expression (n = 0): <none>
[10:21:10.833] Packages needed by future strategies (n = 0): <none>
[10:21:10.834] {
[10:21:10.834]     {
[10:21:10.834]         {
[10:21:10.834]             ...future.startTime <- base::Sys.time()
[10:21:10.834]             {
[10:21:10.834]                 {
[10:21:10.834]                   {
[10:21:10.834]                     {
[10:21:10.834]                       base::local({
[10:21:10.834]                         has_future <- base::requireNamespace("future", 
[10:21:10.834]                           quietly = TRUE)
[10:21:10.834]                         if (has_future) {
[10:21:10.834]                           ns <- base::getNamespace("future")
[10:21:10.834]                           version <- ns[[".package"]][["version"]]
[10:21:10.834]                           if (is.null(version)) 
[10:21:10.834]                             version <- utils::packageVersion("future")
[10:21:10.834]                         }
[10:21:10.834]                         else {
[10:21:10.834]                           version <- NULL
[10:21:10.834]                         }
[10:21:10.834]                         if (!has_future || version < "1.8.0") {
[10:21:10.834]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.834]                             "", base::R.version$version.string), 
[10:21:10.834]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:10.834]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.834]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.834]                               "release", "version")], collapse = " "), 
[10:21:10.834]                             hostname = base::Sys.info()[["nodename"]])
[10:21:10.834]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.834]                             info)
[10:21:10.834]                           info <- base::paste(info, collapse = "; ")
[10:21:10.834]                           if (!has_future) {
[10:21:10.834]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.834]                               info)
[10:21:10.834]                           }
[10:21:10.834]                           else {
[10:21:10.834]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.834]                               info, version)
[10:21:10.834]                           }
[10:21:10.834]                           base::stop(msg)
[10:21:10.834]                         }
[10:21:10.834]                       })
[10:21:10.834]                     }
[10:21:10.834]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:10.834]                     base::options(mc.cores = 1L)
[10:21:10.834]                   }
[10:21:10.834]                   ...future.strategy.old <- future::plan("list")
[10:21:10.834]                   options(future.plan = NULL)
[10:21:10.834]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.834]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.834]                 }
[10:21:10.834]                 ...future.workdir <- getwd()
[10:21:10.834]             }
[10:21:10.834]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.834]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.834]         }
[10:21:10.834]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.834]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.834]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.834]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.834]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.834]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.834]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.834]             base::names(...future.oldOptions))
[10:21:10.834]     }
[10:21:10.834]     if (FALSE) {
[10:21:10.834]     }
[10:21:10.834]     else {
[10:21:10.834]         if (TRUE) {
[10:21:10.834]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.834]                 open = "w")
[10:21:10.834]         }
[10:21:10.834]         else {
[10:21:10.834]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.834]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.834]         }
[10:21:10.834]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.834]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.834]             base::sink(type = "output", split = FALSE)
[10:21:10.834]             base::close(...future.stdout)
[10:21:10.834]         }, add = TRUE)
[10:21:10.834]     }
[10:21:10.834]     ...future.frame <- base::sys.nframe()
[10:21:10.834]     ...future.conditions <- base::list()
[10:21:10.834]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.834]     if (FALSE) {
[10:21:10.834]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.834]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.834]     }
[10:21:10.834]     ...future.result <- base::tryCatch({
[10:21:10.834]         base::withCallingHandlers({
[10:21:10.834]             ...future.value <- base::withVisible(base::local({
[10:21:10.834]                 withCallingHandlers({
[10:21:10.834]                   1
[10:21:10.834]                 }, immediateCondition = function(cond) {
[10:21:10.834]                   save_rds <- function (object, pathname, ...) 
[10:21:10.834]                   {
[10:21:10.834]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:10.834]                     if (file_test("-f", pathname_tmp)) {
[10:21:10.834]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.834]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:10.834]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.834]                         fi_tmp[["mtime"]])
[10:21:10.834]                     }
[10:21:10.834]                     tryCatch({
[10:21:10.834]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:10.834]                     }, error = function(ex) {
[10:21:10.834]                       msg <- conditionMessage(ex)
[10:21:10.834]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.834]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:10.834]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.834]                         fi_tmp[["mtime"]], msg)
[10:21:10.834]                       ex$message <- msg
[10:21:10.834]                       stop(ex)
[10:21:10.834]                     })
[10:21:10.834]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:10.834]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:10.834]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:10.834]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.834]                       fi <- file.info(pathname)
[10:21:10.834]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:10.834]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.834]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:10.834]                         fi[["size"]], fi[["mtime"]])
[10:21:10.834]                       stop(msg)
[10:21:10.834]                     }
[10:21:10.834]                     invisible(pathname)
[10:21:10.834]                   }
[10:21:10.834]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:10.834]                     rootPath = tempdir()) 
[10:21:10.834]                   {
[10:21:10.834]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:10.834]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:10.834]                       tmpdir = path, fileext = ".rds")
[10:21:10.834]                     save_rds(obj, file)
[10:21:10.834]                   }
[10:21:10.834]                   saveImmediateCondition(cond, path = "/tmp/RtmpKymecF/.future/immediateConditions")
[10:21:10.834]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.834]                   {
[10:21:10.834]                     inherits <- base::inherits
[10:21:10.834]                     invokeRestart <- base::invokeRestart
[10:21:10.834]                     is.null <- base::is.null
[10:21:10.834]                     muffled <- FALSE
[10:21:10.834]                     if (inherits(cond, "message")) {
[10:21:10.834]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:10.834]                       if (muffled) 
[10:21:10.834]                         invokeRestart("muffleMessage")
[10:21:10.834]                     }
[10:21:10.834]                     else if (inherits(cond, "warning")) {
[10:21:10.834]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:10.834]                       if (muffled) 
[10:21:10.834]                         invokeRestart("muffleWarning")
[10:21:10.834]                     }
[10:21:10.834]                     else if (inherits(cond, "condition")) {
[10:21:10.834]                       if (!is.null(pattern)) {
[10:21:10.834]                         computeRestarts <- base::computeRestarts
[10:21:10.834]                         grepl <- base::grepl
[10:21:10.834]                         restarts <- computeRestarts(cond)
[10:21:10.834]                         for (restart in restarts) {
[10:21:10.834]                           name <- restart$name
[10:21:10.834]                           if (is.null(name)) 
[10:21:10.834]                             next
[10:21:10.834]                           if (!grepl(pattern, name)) 
[10:21:10.834]                             next
[10:21:10.834]                           invokeRestart(restart)
[10:21:10.834]                           muffled <- TRUE
[10:21:10.834]                           break
[10:21:10.834]                         }
[10:21:10.834]                       }
[10:21:10.834]                     }
[10:21:10.834]                     invisible(muffled)
[10:21:10.834]                   }
[10:21:10.834]                   muffleCondition(cond)
[10:21:10.834]                 })
[10:21:10.834]             }))
[10:21:10.834]             future::FutureResult(value = ...future.value$value, 
[10:21:10.834]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.834]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.834]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.834]                     ...future.globalenv.names))
[10:21:10.834]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.834]         }, condition = base::local({
[10:21:10.834]             c <- base::c
[10:21:10.834]             inherits <- base::inherits
[10:21:10.834]             invokeRestart <- base::invokeRestart
[10:21:10.834]             length <- base::length
[10:21:10.834]             list <- base::list
[10:21:10.834]             seq.int <- base::seq.int
[10:21:10.834]             signalCondition <- base::signalCondition
[10:21:10.834]             sys.calls <- base::sys.calls
[10:21:10.834]             `[[` <- base::`[[`
[10:21:10.834]             `+` <- base::`+`
[10:21:10.834]             `<<-` <- base::`<<-`
[10:21:10.834]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.834]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.834]                   3L)]
[10:21:10.834]             }
[10:21:10.834]             function(cond) {
[10:21:10.834]                 is_error <- inherits(cond, "error")
[10:21:10.834]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.834]                   NULL)
[10:21:10.834]                 if (is_error) {
[10:21:10.834]                   sessionInformation <- function() {
[10:21:10.834]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.834]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.834]                       search = base::search(), system = base::Sys.info())
[10:21:10.834]                   }
[10:21:10.834]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.834]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.834]                     cond$call), session = sessionInformation(), 
[10:21:10.834]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.834]                   signalCondition(cond)
[10:21:10.834]                 }
[10:21:10.834]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.834]                 "immediateCondition"))) {
[10:21:10.834]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.834]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.834]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.834]                   if (TRUE && !signal) {
[10:21:10.834]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.834]                     {
[10:21:10.834]                       inherits <- base::inherits
[10:21:10.834]                       invokeRestart <- base::invokeRestart
[10:21:10.834]                       is.null <- base::is.null
[10:21:10.834]                       muffled <- FALSE
[10:21:10.834]                       if (inherits(cond, "message")) {
[10:21:10.834]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.834]                         if (muffled) 
[10:21:10.834]                           invokeRestart("muffleMessage")
[10:21:10.834]                       }
[10:21:10.834]                       else if (inherits(cond, "warning")) {
[10:21:10.834]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.834]                         if (muffled) 
[10:21:10.834]                           invokeRestart("muffleWarning")
[10:21:10.834]                       }
[10:21:10.834]                       else if (inherits(cond, "condition")) {
[10:21:10.834]                         if (!is.null(pattern)) {
[10:21:10.834]                           computeRestarts <- base::computeRestarts
[10:21:10.834]                           grepl <- base::grepl
[10:21:10.834]                           restarts <- computeRestarts(cond)
[10:21:10.834]                           for (restart in restarts) {
[10:21:10.834]                             name <- restart$name
[10:21:10.834]                             if (is.null(name)) 
[10:21:10.834]                               next
[10:21:10.834]                             if (!grepl(pattern, name)) 
[10:21:10.834]                               next
[10:21:10.834]                             invokeRestart(restart)
[10:21:10.834]                             muffled <- TRUE
[10:21:10.834]                             break
[10:21:10.834]                           }
[10:21:10.834]                         }
[10:21:10.834]                       }
[10:21:10.834]                       invisible(muffled)
[10:21:10.834]                     }
[10:21:10.834]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.834]                   }
[10:21:10.834]                 }
[10:21:10.834]                 else {
[10:21:10.834]                   if (TRUE) {
[10:21:10.834]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.834]                     {
[10:21:10.834]                       inherits <- base::inherits
[10:21:10.834]                       invokeRestart <- base::invokeRestart
[10:21:10.834]                       is.null <- base::is.null
[10:21:10.834]                       muffled <- FALSE
[10:21:10.834]                       if (inherits(cond, "message")) {
[10:21:10.834]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.834]                         if (muffled) 
[10:21:10.834]                           invokeRestart("muffleMessage")
[10:21:10.834]                       }
[10:21:10.834]                       else if (inherits(cond, "warning")) {
[10:21:10.834]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.834]                         if (muffled) 
[10:21:10.834]                           invokeRestart("muffleWarning")
[10:21:10.834]                       }
[10:21:10.834]                       else if (inherits(cond, "condition")) {
[10:21:10.834]                         if (!is.null(pattern)) {
[10:21:10.834]                           computeRestarts <- base::computeRestarts
[10:21:10.834]                           grepl <- base::grepl
[10:21:10.834]                           restarts <- computeRestarts(cond)
[10:21:10.834]                           for (restart in restarts) {
[10:21:10.834]                             name <- restart$name
[10:21:10.834]                             if (is.null(name)) 
[10:21:10.834]                               next
[10:21:10.834]                             if (!grepl(pattern, name)) 
[10:21:10.834]                               next
[10:21:10.834]                             invokeRestart(restart)
[10:21:10.834]                             muffled <- TRUE
[10:21:10.834]                             break
[10:21:10.834]                           }
[10:21:10.834]                         }
[10:21:10.834]                       }
[10:21:10.834]                       invisible(muffled)
[10:21:10.834]                     }
[10:21:10.834]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.834]                   }
[10:21:10.834]                 }
[10:21:10.834]             }
[10:21:10.834]         }))
[10:21:10.834]     }, error = function(ex) {
[10:21:10.834]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.834]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.834]                 ...future.rng), started = ...future.startTime, 
[10:21:10.834]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.834]             version = "1.8"), class = "FutureResult")
[10:21:10.834]     }, finally = {
[10:21:10.834]         if (!identical(...future.workdir, getwd())) 
[10:21:10.834]             setwd(...future.workdir)
[10:21:10.834]         {
[10:21:10.834]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.834]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.834]             }
[10:21:10.834]             base::options(...future.oldOptions)
[10:21:10.834]             if (.Platform$OS.type == "windows") {
[10:21:10.834]                 old_names <- names(...future.oldEnvVars)
[10:21:10.834]                 envs <- base::Sys.getenv()
[10:21:10.834]                 names <- names(envs)
[10:21:10.834]                 common <- intersect(names, old_names)
[10:21:10.834]                 added <- setdiff(names, old_names)
[10:21:10.834]                 removed <- setdiff(old_names, names)
[10:21:10.834]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.834]                   envs[common]]
[10:21:10.834]                 NAMES <- toupper(changed)
[10:21:10.834]                 args <- list()
[10:21:10.834]                 for (kk in seq_along(NAMES)) {
[10:21:10.834]                   name <- changed[[kk]]
[10:21:10.834]                   NAME <- NAMES[[kk]]
[10:21:10.834]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.834]                     next
[10:21:10.834]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.834]                 }
[10:21:10.834]                 NAMES <- toupper(added)
[10:21:10.834]                 for (kk in seq_along(NAMES)) {
[10:21:10.834]                   name <- added[[kk]]
[10:21:10.834]                   NAME <- NAMES[[kk]]
[10:21:10.834]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.834]                     next
[10:21:10.834]                   args[[name]] <- ""
[10:21:10.834]                 }
[10:21:10.834]                 NAMES <- toupper(removed)
[10:21:10.834]                 for (kk in seq_along(NAMES)) {
[10:21:10.834]                   name <- removed[[kk]]
[10:21:10.834]                   NAME <- NAMES[[kk]]
[10:21:10.834]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.834]                     next
[10:21:10.834]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.834]                 }
[10:21:10.834]                 if (length(args) > 0) 
[10:21:10.834]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.834]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.834]             }
[10:21:10.834]             else {
[10:21:10.834]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.834]             }
[10:21:10.834]             {
[10:21:10.834]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.834]                   0L) {
[10:21:10.834]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.834]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.834]                   base::options(opts)
[10:21:10.834]                 }
[10:21:10.834]                 {
[10:21:10.834]                   {
[10:21:10.834]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:10.834]                     NULL
[10:21:10.834]                   }
[10:21:10.834]                   options(future.plan = NULL)
[10:21:10.834]                   if (is.na(NA_character_)) 
[10:21:10.834]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.834]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.834]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.834]                     .init = FALSE)
[10:21:10.834]                 }
[10:21:10.834]             }
[10:21:10.834]         }
[10:21:10.834]     })
[10:21:10.834]     if (TRUE) {
[10:21:10.834]         base::sink(type = "output", split = FALSE)
[10:21:10.834]         if (TRUE) {
[10:21:10.834]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.834]         }
[10:21:10.834]         else {
[10:21:10.834]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.834]         }
[10:21:10.834]         base::close(...future.stdout)
[10:21:10.834]         ...future.stdout <- NULL
[10:21:10.834]     }
[10:21:10.834]     ...future.result$conditions <- ...future.conditions
[10:21:10.834]     ...future.result$finished <- base::Sys.time()
[10:21:10.834]     ...future.result
[10:21:10.834] }
[10:21:10.836] requestCore(): workers = 2
[10:21:10.838] MulticoreFuture started
[10:21:10.838] - Launch lazy future ... done
[10:21:10.839] run() for ‘MulticoreFuture’ ... done
[10:21:10.839] plan(): Setting new future strategy stack:
[10:21:10.839] result() for MulticoreFuture ...
[10:21:10.839] List of future strategies:
[10:21:10.839] 1. sequential:
[10:21:10.839]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.839]    - tweaked: FALSE
[10:21:10.839]    - call: NULL
[10:21:10.840] plan(): nbrOfWorkers() = 1
[10:21:10.842] plan(): Setting new future strategy stack:
[10:21:10.842] List of future strategies:
[10:21:10.842] 1. multicore:
[10:21:10.842]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:10.842]    - tweaked: FALSE
[10:21:10.842]    - call: plan(strategy)
[10:21:10.846] plan(): nbrOfWorkers() = 2
[10:21:10.847] result() for MulticoreFuture ...
[10:21:10.847] result() for MulticoreFuture ... done
[10:21:10.847] result() for MulticoreFuture ... done
[10:21:10.847] result() for MulticoreFuture ...
[10:21:10.847] result() for MulticoreFuture ... done
d = 1
** Nested future assignments
[10:21:10.848] getGlobalsAndPackages() ...
[10:21:10.848] Searching for globals...
[10:21:10.853] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[10:21:10.853] Searching for globals ... DONE
[10:21:10.854] Resolving globals: FALSE
[10:21:10.854] 
[10:21:10.854] - packages: [1] ‘future’
[10:21:10.854] getGlobalsAndPackages() ... DONE
[10:21:10.855] run() for ‘Future’ ...
[10:21:10.855] - state: ‘created’
[10:21:10.855] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:10.857] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:10.857] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:10.857]   - Field: ‘label’
[10:21:10.858]   - Field: ‘local’
[10:21:10.858]   - Field: ‘owner’
[10:21:10.858]   - Field: ‘envir’
[10:21:10.858]   - Field: ‘workers’
[10:21:10.858]   - Field: ‘packages’
[10:21:10.858]   - Field: ‘gc’
[10:21:10.858]   - Field: ‘job’
[10:21:10.858]   - Field: ‘conditions’
[10:21:10.858]   - Field: ‘expr’
[10:21:10.859]   - Field: ‘uuid’
[10:21:10.859]   - Field: ‘seed’
[10:21:10.859]   - Field: ‘version’
[10:21:10.859]   - Field: ‘result’
[10:21:10.859]   - Field: ‘asynchronous’
[10:21:10.859]   - Field: ‘calls’
[10:21:10.859]   - Field: ‘globals’
[10:21:10.859]   - Field: ‘stdout’
[10:21:10.859]   - Field: ‘earlySignal’
[10:21:10.860]   - Field: ‘lazy’
[10:21:10.860]   - Field: ‘state’
[10:21:10.860] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:10.860] - Launch lazy future ...
[10:21:10.860] Packages needed by the future expression (n = 1): ‘future’
[10:21:10.860] Packages needed by future strategies (n = 0): <none>
[10:21:10.861] {
[10:21:10.861]     {
[10:21:10.861]         {
[10:21:10.861]             ...future.startTime <- base::Sys.time()
[10:21:10.861]             {
[10:21:10.861]                 {
[10:21:10.861]                   {
[10:21:10.861]                     {
[10:21:10.861]                       {
[10:21:10.861]                         base::local({
[10:21:10.861]                           has_future <- base::requireNamespace("future", 
[10:21:10.861]                             quietly = TRUE)
[10:21:10.861]                           if (has_future) {
[10:21:10.861]                             ns <- base::getNamespace("future")
[10:21:10.861]                             version <- ns[[".package"]][["version"]]
[10:21:10.861]                             if (is.null(version)) 
[10:21:10.861]                               version <- utils::packageVersion("future")
[10:21:10.861]                           }
[10:21:10.861]                           else {
[10:21:10.861]                             version <- NULL
[10:21:10.861]                           }
[10:21:10.861]                           if (!has_future || version < "1.8.0") {
[10:21:10.861]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.861]                               "", base::R.version$version.string), 
[10:21:10.861]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:10.861]                                 base::R.version$platform, 8 * 
[10:21:10.861]                                   base::.Machine$sizeof.pointer), 
[10:21:10.861]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.861]                                 "release", "version")], collapse = " "), 
[10:21:10.861]                               hostname = base::Sys.info()[["nodename"]])
[10:21:10.861]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.861]                               info)
[10:21:10.861]                             info <- base::paste(info, collapse = "; ")
[10:21:10.861]                             if (!has_future) {
[10:21:10.861]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.861]                                 info)
[10:21:10.861]                             }
[10:21:10.861]                             else {
[10:21:10.861]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.861]                                 info, version)
[10:21:10.861]                             }
[10:21:10.861]                             base::stop(msg)
[10:21:10.861]                           }
[10:21:10.861]                         })
[10:21:10.861]                       }
[10:21:10.861]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:10.861]                       base::options(mc.cores = 1L)
[10:21:10.861]                     }
[10:21:10.861]                     base::local({
[10:21:10.861]                       for (pkg in "future") {
[10:21:10.861]                         base::loadNamespace(pkg)
[10:21:10.861]                         base::library(pkg, character.only = TRUE)
[10:21:10.861]                       }
[10:21:10.861]                     })
[10:21:10.861]                   }
[10:21:10.861]                   ...future.strategy.old <- future::plan("list")
[10:21:10.861]                   options(future.plan = NULL)
[10:21:10.861]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.861]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.861]                 }
[10:21:10.861]                 ...future.workdir <- getwd()
[10:21:10.861]             }
[10:21:10.861]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.861]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.861]         }
[10:21:10.861]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.861]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.861]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.861]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.861]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.861]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.861]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.861]             base::names(...future.oldOptions))
[10:21:10.861]     }
[10:21:10.861]     if (FALSE) {
[10:21:10.861]     }
[10:21:10.861]     else {
[10:21:10.861]         if (TRUE) {
[10:21:10.861]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.861]                 open = "w")
[10:21:10.861]         }
[10:21:10.861]         else {
[10:21:10.861]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.861]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.861]         }
[10:21:10.861]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.861]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.861]             base::sink(type = "output", split = FALSE)
[10:21:10.861]             base::close(...future.stdout)
[10:21:10.861]         }, add = TRUE)
[10:21:10.861]     }
[10:21:10.861]     ...future.frame <- base::sys.nframe()
[10:21:10.861]     ...future.conditions <- base::list()
[10:21:10.861]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.861]     if (FALSE) {
[10:21:10.861]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.861]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.861]     }
[10:21:10.861]     ...future.result <- base::tryCatch({
[10:21:10.861]         base::withCallingHandlers({
[10:21:10.861]             ...future.value <- base::withVisible(base::local({
[10:21:10.861]                 withCallingHandlers({
[10:21:10.861]                   {
[10:21:10.861]                     b <- 1
[10:21:10.861]                     c %<-% 2
[10:21:10.861]                     d <- 3
[10:21:10.861]                     4 %->% e
[10:21:10.861]                     b + c + d + e
[10:21:10.861]                   }
[10:21:10.861]                 }, immediateCondition = function(cond) {
[10:21:10.861]                   save_rds <- function (object, pathname, ...) 
[10:21:10.861]                   {
[10:21:10.861]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:10.861]                     if (file_test("-f", pathname_tmp)) {
[10:21:10.861]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.861]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:10.861]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.861]                         fi_tmp[["mtime"]])
[10:21:10.861]                     }
[10:21:10.861]                     tryCatch({
[10:21:10.861]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:10.861]                     }, error = function(ex) {
[10:21:10.861]                       msg <- conditionMessage(ex)
[10:21:10.861]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.861]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:10.861]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.861]                         fi_tmp[["mtime"]], msg)
[10:21:10.861]                       ex$message <- msg
[10:21:10.861]                       stop(ex)
[10:21:10.861]                     })
[10:21:10.861]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:10.861]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:10.861]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:10.861]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.861]                       fi <- file.info(pathname)
[10:21:10.861]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:10.861]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.861]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:10.861]                         fi[["size"]], fi[["mtime"]])
[10:21:10.861]                       stop(msg)
[10:21:10.861]                     }
[10:21:10.861]                     invisible(pathname)
[10:21:10.861]                   }
[10:21:10.861]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:10.861]                     rootPath = tempdir()) 
[10:21:10.861]                   {
[10:21:10.861]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:10.861]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:10.861]                       tmpdir = path, fileext = ".rds")
[10:21:10.861]                     save_rds(obj, file)
[10:21:10.861]                   }
[10:21:10.861]                   saveImmediateCondition(cond, path = "/tmp/RtmpKymecF/.future/immediateConditions")
[10:21:10.861]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.861]                   {
[10:21:10.861]                     inherits <- base::inherits
[10:21:10.861]                     invokeRestart <- base::invokeRestart
[10:21:10.861]                     is.null <- base::is.null
[10:21:10.861]                     muffled <- FALSE
[10:21:10.861]                     if (inherits(cond, "message")) {
[10:21:10.861]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:10.861]                       if (muffled) 
[10:21:10.861]                         invokeRestart("muffleMessage")
[10:21:10.861]                     }
[10:21:10.861]                     else if (inherits(cond, "warning")) {
[10:21:10.861]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:10.861]                       if (muffled) 
[10:21:10.861]                         invokeRestart("muffleWarning")
[10:21:10.861]                     }
[10:21:10.861]                     else if (inherits(cond, "condition")) {
[10:21:10.861]                       if (!is.null(pattern)) {
[10:21:10.861]                         computeRestarts <- base::computeRestarts
[10:21:10.861]                         grepl <- base::grepl
[10:21:10.861]                         restarts <- computeRestarts(cond)
[10:21:10.861]                         for (restart in restarts) {
[10:21:10.861]                           name <- restart$name
[10:21:10.861]                           if (is.null(name)) 
[10:21:10.861]                             next
[10:21:10.861]                           if (!grepl(pattern, name)) 
[10:21:10.861]                             next
[10:21:10.861]                           invokeRestart(restart)
[10:21:10.861]                           muffled <- TRUE
[10:21:10.861]                           break
[10:21:10.861]                         }
[10:21:10.861]                       }
[10:21:10.861]                     }
[10:21:10.861]                     invisible(muffled)
[10:21:10.861]                   }
[10:21:10.861]                   muffleCondition(cond)
[10:21:10.861]                 })
[10:21:10.861]             }))
[10:21:10.861]             future::FutureResult(value = ...future.value$value, 
[10:21:10.861]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.861]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.861]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.861]                     ...future.globalenv.names))
[10:21:10.861]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.861]         }, condition = base::local({
[10:21:10.861]             c <- base::c
[10:21:10.861]             inherits <- base::inherits
[10:21:10.861]             invokeRestart <- base::invokeRestart
[10:21:10.861]             length <- base::length
[10:21:10.861]             list <- base::list
[10:21:10.861]             seq.int <- base::seq.int
[10:21:10.861]             signalCondition <- base::signalCondition
[10:21:10.861]             sys.calls <- base::sys.calls
[10:21:10.861]             `[[` <- base::`[[`
[10:21:10.861]             `+` <- base::`+`
[10:21:10.861]             `<<-` <- base::`<<-`
[10:21:10.861]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.861]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.861]                   3L)]
[10:21:10.861]             }
[10:21:10.861]             function(cond) {
[10:21:10.861]                 is_error <- inherits(cond, "error")
[10:21:10.861]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.861]                   NULL)
[10:21:10.861]                 if (is_error) {
[10:21:10.861]                   sessionInformation <- function() {
[10:21:10.861]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.861]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.861]                       search = base::search(), system = base::Sys.info())
[10:21:10.861]                   }
[10:21:10.861]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.861]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.861]                     cond$call), session = sessionInformation(), 
[10:21:10.861]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.861]                   signalCondition(cond)
[10:21:10.861]                 }
[10:21:10.861]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.861]                 "immediateCondition"))) {
[10:21:10.861]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.861]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.861]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.861]                   if (TRUE && !signal) {
[10:21:10.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.861]                     {
[10:21:10.861]                       inherits <- base::inherits
[10:21:10.861]                       invokeRestart <- base::invokeRestart
[10:21:10.861]                       is.null <- base::is.null
[10:21:10.861]                       muffled <- FALSE
[10:21:10.861]                       if (inherits(cond, "message")) {
[10:21:10.861]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.861]                         if (muffled) 
[10:21:10.861]                           invokeRestart("muffleMessage")
[10:21:10.861]                       }
[10:21:10.861]                       else if (inherits(cond, "warning")) {
[10:21:10.861]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.861]                         if (muffled) 
[10:21:10.861]                           invokeRestart("muffleWarning")
[10:21:10.861]                       }
[10:21:10.861]                       else if (inherits(cond, "condition")) {
[10:21:10.861]                         if (!is.null(pattern)) {
[10:21:10.861]                           computeRestarts <- base::computeRestarts
[10:21:10.861]                           grepl <- base::grepl
[10:21:10.861]                           restarts <- computeRestarts(cond)
[10:21:10.861]                           for (restart in restarts) {
[10:21:10.861]                             name <- restart$name
[10:21:10.861]                             if (is.null(name)) 
[10:21:10.861]                               next
[10:21:10.861]                             if (!grepl(pattern, name)) 
[10:21:10.861]                               next
[10:21:10.861]                             invokeRestart(restart)
[10:21:10.861]                             muffled <- TRUE
[10:21:10.861]                             break
[10:21:10.861]                           }
[10:21:10.861]                         }
[10:21:10.861]                       }
[10:21:10.861]                       invisible(muffled)
[10:21:10.861]                     }
[10:21:10.861]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.861]                   }
[10:21:10.861]                 }
[10:21:10.861]                 else {
[10:21:10.861]                   if (TRUE) {
[10:21:10.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.861]                     {
[10:21:10.861]                       inherits <- base::inherits
[10:21:10.861]                       invokeRestart <- base::invokeRestart
[10:21:10.861]                       is.null <- base::is.null
[10:21:10.861]                       muffled <- FALSE
[10:21:10.861]                       if (inherits(cond, "message")) {
[10:21:10.861]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.861]                         if (muffled) 
[10:21:10.861]                           invokeRestart("muffleMessage")
[10:21:10.861]                       }
[10:21:10.861]                       else if (inherits(cond, "warning")) {
[10:21:10.861]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.861]                         if (muffled) 
[10:21:10.861]                           invokeRestart("muffleWarning")
[10:21:10.861]                       }
[10:21:10.861]                       else if (inherits(cond, "condition")) {
[10:21:10.861]                         if (!is.null(pattern)) {
[10:21:10.861]                           computeRestarts <- base::computeRestarts
[10:21:10.861]                           grepl <- base::grepl
[10:21:10.861]                           restarts <- computeRestarts(cond)
[10:21:10.861]                           for (restart in restarts) {
[10:21:10.861]                             name <- restart$name
[10:21:10.861]                             if (is.null(name)) 
[10:21:10.861]                               next
[10:21:10.861]                             if (!grepl(pattern, name)) 
[10:21:10.861]                               next
[10:21:10.861]                             invokeRestart(restart)
[10:21:10.861]                             muffled <- TRUE
[10:21:10.861]                             break
[10:21:10.861]                           }
[10:21:10.861]                         }
[10:21:10.861]                       }
[10:21:10.861]                       invisible(muffled)
[10:21:10.861]                     }
[10:21:10.861]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.861]                   }
[10:21:10.861]                 }
[10:21:10.861]             }
[10:21:10.861]         }))
[10:21:10.861]     }, error = function(ex) {
[10:21:10.861]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.861]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.861]                 ...future.rng), started = ...future.startTime, 
[10:21:10.861]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.861]             version = "1.8"), class = "FutureResult")
[10:21:10.861]     }, finally = {
[10:21:10.861]         if (!identical(...future.workdir, getwd())) 
[10:21:10.861]             setwd(...future.workdir)
[10:21:10.861]         {
[10:21:10.861]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.861]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.861]             }
[10:21:10.861]             base::options(...future.oldOptions)
[10:21:10.861]             if (.Platform$OS.type == "windows") {
[10:21:10.861]                 old_names <- names(...future.oldEnvVars)
[10:21:10.861]                 envs <- base::Sys.getenv()
[10:21:10.861]                 names <- names(envs)
[10:21:10.861]                 common <- intersect(names, old_names)
[10:21:10.861]                 added <- setdiff(names, old_names)
[10:21:10.861]                 removed <- setdiff(old_names, names)
[10:21:10.861]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.861]                   envs[common]]
[10:21:10.861]                 NAMES <- toupper(changed)
[10:21:10.861]                 args <- list()
[10:21:10.861]                 for (kk in seq_along(NAMES)) {
[10:21:10.861]                   name <- changed[[kk]]
[10:21:10.861]                   NAME <- NAMES[[kk]]
[10:21:10.861]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.861]                     next
[10:21:10.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.861]                 }
[10:21:10.861]                 NAMES <- toupper(added)
[10:21:10.861]                 for (kk in seq_along(NAMES)) {
[10:21:10.861]                   name <- added[[kk]]
[10:21:10.861]                   NAME <- NAMES[[kk]]
[10:21:10.861]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.861]                     next
[10:21:10.861]                   args[[name]] <- ""
[10:21:10.861]                 }
[10:21:10.861]                 NAMES <- toupper(removed)
[10:21:10.861]                 for (kk in seq_along(NAMES)) {
[10:21:10.861]                   name <- removed[[kk]]
[10:21:10.861]                   NAME <- NAMES[[kk]]
[10:21:10.861]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.861]                     next
[10:21:10.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.861]                 }
[10:21:10.861]                 if (length(args) > 0) 
[10:21:10.861]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.861]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.861]             }
[10:21:10.861]             else {
[10:21:10.861]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.861]             }
[10:21:10.861]             {
[10:21:10.861]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.861]                   0L) {
[10:21:10.861]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.861]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.861]                   base::options(opts)
[10:21:10.861]                 }
[10:21:10.861]                 {
[10:21:10.861]                   {
[10:21:10.861]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:10.861]                     NULL
[10:21:10.861]                   }
[10:21:10.861]                   options(future.plan = NULL)
[10:21:10.861]                   if (is.na(NA_character_)) 
[10:21:10.861]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.861]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.861]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.861]                     .init = FALSE)
[10:21:10.861]                 }
[10:21:10.861]             }
[10:21:10.861]         }
[10:21:10.861]     })
[10:21:10.861]     if (TRUE) {
[10:21:10.861]         base::sink(type = "output", split = FALSE)
[10:21:10.861]         if (TRUE) {
[10:21:10.861]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.861]         }
[10:21:10.861]         else {
[10:21:10.861]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.861]         }
[10:21:10.861]         base::close(...future.stdout)
[10:21:10.861]         ...future.stdout <- NULL
[10:21:10.861]     }
[10:21:10.861]     ...future.result$conditions <- ...future.conditions
[10:21:10.861]     ...future.result$finished <- base::Sys.time()
[10:21:10.861]     ...future.result
[10:21:10.861] }
[10:21:10.864] requestCore(): workers = 2
[10:21:10.866] MulticoreFuture started
[10:21:10.866] - Launch lazy future ... done
[10:21:10.866] run() for ‘MulticoreFuture’ ... done
[10:21:10.867] result() for MulticoreFuture ...
[10:21:10.867] plan(): Setting new future strategy stack:
[10:21:10.867] List of future strategies:
[10:21:10.867] 1. sequential:
[10:21:10.867]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.867]    - tweaked: FALSE
[10:21:10.867]    - call: NULL
[10:21:10.868] plan(): nbrOfWorkers() = 1
[10:21:10.902] plan(): Setting new future strategy stack:
[10:21:10.902] List of future strategies:
[10:21:10.902] 1. multicore:
[10:21:10.902]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:10.902]    - tweaked: FALSE
[10:21:10.902]    - call: plan(strategy)
[10:21:10.904] plan(): nbrOfWorkers() = 2
[10:21:10.906] result() for MulticoreFuture ...
[10:21:10.906] result() for MulticoreFuture ... done
[10:21:10.906] signalConditions() ...
[10:21:10.906]  - include = ‘immediateCondition’
[10:21:10.906]  - exclude = 
[10:21:10.906]  - resignal = FALSE
[10:21:10.907]  - Number of conditions: 88
[10:21:10.907] signalConditions() ... done
[10:21:10.907] result() for MulticoreFuture ... done
[10:21:10.907] result() for MulticoreFuture ...
[10:21:10.907] result() for MulticoreFuture ... done
[10:21:10.907] signalConditions() ...
[10:21:10.907]  - include = ‘immediateCondition’
[10:21:10.907]  - exclude = 
[10:21:10.908]  - resignal = FALSE
[10:21:10.908]  - Number of conditions: 88
[10:21:10.908] signalConditions() ... done
[10:21:10.908] Future state: ‘finished’
[10:21:10.908] result() for MulticoreFuture ...
[10:21:10.908] result() for MulticoreFuture ... done
[10:21:10.908] signalConditions() ...
[10:21:10.908]  - include = ‘condition’
[10:21:10.909]  - exclude = ‘immediateCondition’
[10:21:10.909]  - resignal = TRUE
[10:21:10.909]  - Number of conditions: 88
[10:21:10.909]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.869] getGlobalsAndPackages() ...
[10:21:10.909]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.870] Searching for globals...
[10:21:10.909]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.870] 
[10:21:10.909]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.871] Searching for globals ... DONE
[10:21:10.910]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.871] - globals: [0] <none>
[10:21:10.910]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.871] getGlobalsAndPackages() ... DONE
[10:21:10.910]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.872] run() for ‘Future’ ...
[10:21:10.910]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.872] - state: ‘created’
[10:21:10.910]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.872] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:10.913]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.873] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:10.913]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.873] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:10.913]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.873]   - Field: ‘label’
[10:21:10.914]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.873]   - Field: ‘local’
[10:21:10.914]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.873]   - Field: ‘owner’
[10:21:10.914]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.874]   - Field: ‘envir’
[10:21:10.914]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.874]   - Field: ‘packages’
[10:21:10.914]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.874]   - Field: ‘gc’
[10:21:10.915]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.874]   - Field: ‘conditions’
[10:21:10.915]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.874]   - Field: ‘expr’
[10:21:10.915]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.874]   - Field: ‘uuid’
[10:21:10.915]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.875]   - Field: ‘seed’
[10:21:10.915]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.875]   - Field: ‘version’
[10:21:10.916]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.875]   - Field: ‘result’
[10:21:10.916]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.875]   - Field: ‘asynchronous’
[10:21:10.916]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.879]   - Field: ‘calls’
[10:21:10.916]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.880]   - Field: ‘globals’
[10:21:10.916]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.880]   - Field: ‘stdout’
[10:21:10.916]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.880]   - Field: ‘earlySignal’
[10:21:10.917]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.880]   - Field: ‘lazy’
[10:21:10.917]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.881]   - Field: ‘state’
[10:21:10.917]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.881] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:10.917]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.881] - Launch lazy future ...
[10:21:10.917]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.882] Packages needed by the future expression (n = 0): <none>
[10:21:10.917]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.882] Packages needed by future strategies (n = 0): <none>
[10:21:10.918]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.883] {
[10:21:10.883]     {
[10:21:10.883]         {
[10:21:10.883]             ...future.startTime <- base::Sys.time()
[10:21:10.883]             {
[10:21:10.883]                 {
[10:21:10.883]                   {
[10:21:10.883]                     base::local({
[10:21:10.883]                       has_future <- base::requireNamespace("future", 
[10:21:10.883]                         quietly = TRUE)
[10:21:10.883]                       if (has_future) {
[10:21:10.883]                         ns <- base::getNamespace("future")
[10:21:10.883]                         version <- ns[[".package"]][["version"]]
[10:21:10.883]                         if (is.null(version)) 
[10:21:10.883]                           version <- utils::packageVersion("future")
[10:21:10.883]                       }
[10:21:10.883]                       else {
[10:21:10.883]                         version <- NULL
[10:21:10.883]                       }
[10:21:10.883]                       if (!has_future || version < "1.8.0") {
[10:21:10.883]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.883]                           "", base::R.version$version.string), 
[10:21:10.883]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:10.883]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.883]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.883]                             "release", "version")], collapse = " "), 
[10:21:10.883]                           hostname = base::Sys.info()[["nodename"]])
[10:21:10.883]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.883]                           info)
[10:21:10.883]                         info <- base::paste(info, collapse = "; ")
[10:21:10.883]                         if (!has_future) {
[10:21:10.883]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.883]                             info)
[10:21:10.883]                         }
[10:21:10.883]                         else {
[10:21:10.883]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.883]                             info, version)
[10:21:10.883]                         }
[10:21:10.883]                         base::stop(msg)
[10:21:10.883]                       }
[10:21:10.883]                     })
[10:21:10.883]                   }
[10:21:10.883]                   ...future.strategy.old <- future::plan("list")
[10:21:10.883]                   options(future.plan = NULL)
[10:21:10.883]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.883]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.883]                 }
[10:21:10.883]                 ...future.workdir <- getwd()
[10:21:10.883]             }
[10:21:10.883]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.883]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.883]         }
[10:21:10.883]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.883]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.883]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.883]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.883]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.883]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.883]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.883]             base::names(...future.oldOptions))
[10:21:10.883]     }
[10:21:10.883]     if (FALSE) {
[10:21:10.883]     }
[10:21:10.883]     else {
[10:21:10.883]         if (TRUE) {
[10:21:10.883]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.883]                 open = "w")
[10:21:10.883]         }
[10:21:10.883]         else {
[10:21:10.883]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.883]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.883]         }
[10:21:10.883]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.883]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.883]             base::sink(type = "output", split = FALSE)
[10:21:10.883]             base::close(...future.stdout)
[10:21:10.883]         }, add = TRUE)
[10:21:10.883]     }
[10:21:10.883]     ...future.frame <- base::sys.nframe()
[10:21:10.883]     ...future.conditions <- base::list()
[10:21:10.883]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.883]     if (FALSE) {
[10:21:10.883]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.883]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.883]     }
[10:21:10.883]     ...future.result <- base::tryCatch({
[10:21:10.883]         base::withCallingHandlers({
[10:21:10.883]             ...future.value <- base::withVisible(base::local(2))
[10:21:10.883]             future::FutureResult(value = ...future.value$value, 
[10:21:10.883]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.883]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.883]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.883]                     ...future.globalenv.names))
[10:21:10.883]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.883]         }, condition = base::local({
[10:21:10.883]             c <- base::c
[10:21:10.883]             inherits <- base::inherits
[10:21:10.883]             invokeRestart <- base::invokeRestart
[10:21:10.883]             length <- base::length
[10:21:10.883]             list <- base::list
[10:21:10.883]             seq.int <- base::seq.int
[10:21:10.883]             signalCondition <- base::signalCondition
[10:21:10.883]             sys.calls <- base::sys.calls
[10:21:10.883]             `[[` <- base::`[[`
[10:21:10.883]             `+` <- base::`+`
[10:21:10.883]             `<<-` <- base::`<<-`
[10:21:10.883]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.883]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.883]                   3L)]
[10:21:10.883]             }
[10:21:10.883]             function(cond) {
[10:21:10.883]                 is_error <- inherits(cond, "error")
[10:21:10.883]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.883]                   NULL)
[10:21:10.883]                 if (is_error) {
[10:21:10.883]                   sessionInformation <- function() {
[10:21:10.883]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.883]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.883]                       search = base::search(), system = base::Sys.info())
[10:21:10.883]                   }
[10:21:10.883]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.883]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.883]                     cond$call), session = sessionInformation(), 
[10:21:10.883]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.883]                   signalCondition(cond)
[10:21:10.883]                 }
[10:21:10.883]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.883]                 "immediateCondition"))) {
[10:21:10.883]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.883]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.883]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.883]                   if (TRUE && !signal) {
[10:21:10.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.883]                     {
[10:21:10.883]                       inherits <- base::inherits
[10:21:10.883]                       invokeRestart <- base::invokeRestart
[10:21:10.883]                       is.null <- base::is.null
[10:21:10.883]                       muffled <- FALSE
[10:21:10.883]                       if (inherits(cond, "message")) {
[10:21:10.883]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.883]                         if (muffled) 
[10:21:10.883]                           invokeRestart("muffleMessage")
[10:21:10.883]                       }
[10:21:10.883]                       else if (inherits(cond, "warning")) {
[10:21:10.883]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.883]                         if (muffled) 
[10:21:10.883]                           invokeRestart("muffleWarning")
[10:21:10.883]                       }
[10:21:10.883]                       else if (inherits(cond, "condition")) {
[10:21:10.883]                         if (!is.null(pattern)) {
[10:21:10.883]                           computeRestarts <- base::computeRestarts
[10:21:10.883]                           grepl <- base::grepl
[10:21:10.883]                           restarts <- computeRestarts(cond)
[10:21:10.883]                           for (restart in restarts) {
[10:21:10.883]                             name <- restart$name
[10:21:10.883]                             if (is.null(name)) 
[10:21:10.883]                               next
[10:21:10.883]                             if (!grepl(pattern, name)) 
[10:21:10.883]                               next
[10:21:10.883]                             invokeRestart(restart)
[10:21:10.883]                             muffled <- TRUE
[10:21:10.883]                             break
[10:21:10.883]                           }
[10:21:10.883]                         }
[10:21:10.883]                       }
[10:21:10.883]                       invisible(muffled)
[10:21:10.883]                     }
[10:21:10.883]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.883]                   }
[10:21:10.883]                 }
[10:21:10.883]                 else {
[10:21:10.883]                   if (TRUE) {
[10:21:10.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.883]                     {
[10:21:10.883]                       inherits <- base::inherits
[10:21:10.883]                       invokeRestart <- base::invokeRestart
[10:21:10.883]                       is.null <- base::is.null
[10:21:10.883]                       muffled <- FALSE
[10:21:10.883]                       if (inherits(cond, "message")) {
[10:21:10.883]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.883]                         if (muffled) 
[10:21:10.883]                           invokeRestart("muffleMessage")
[10:21:10.883]                       }
[10:21:10.883]                       else if (inherits(cond, "warning")) {
[10:21:10.883]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.883]                         if (muffled) 
[10:21:10.883]                           invokeRestart("muffleWarning")
[10:21:10.883]                       }
[10:21:10.883]                       else if (inherits(cond, "condition")) {
[10:21:10.883]                         if (!is.null(pattern)) {
[10:21:10.883]                           computeRestarts <- base::computeRestarts
[10:21:10.883]                           grepl <- base::grepl
[10:21:10.883]                           restarts <- computeRestarts(cond)
[10:21:10.883]                           for (restart in restarts) {
[10:21:10.883]                             name <- restart$name
[10:21:10.883]                             if (is.null(name)) 
[10:21:10.883]                               next
[10:21:10.883]                             if (!grepl(pattern, name)) 
[10:21:10.883]                               next
[10:21:10.883]                             invokeRestart(restart)
[10:21:10.883]                             muffled <- TRUE
[10:21:10.883]                             break
[10:21:10.883]                           }
[10:21:10.883]                         }
[10:21:10.883]                       }
[10:21:10.883]                       invisible(muffled)
[10:21:10.883]                     }
[10:21:10.883]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.883]                   }
[10:21:10.883]                 }
[10:21:10.883]             }
[10:21:10.883]         }))
[10:21:10.883]     }, error = function(ex) {
[10:21:10.883]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.883]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.883]                 ...future.rng), started = ...future.startTime, 
[10:21:10.883]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.883]             version = "1.8"), class = "FutureResult")
[10:21:10.883]     }, finally = {
[10:21:10.883]         if (!identical(...future.workdir, getwd())) 
[10:21:10.883]             setwd(...future.workdir)
[10:21:10.883]         {
[10:21:10.883]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.883]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.883]             }
[10:21:10.883]             base::options(...future.oldOptions)
[10:21:10.883]             if (.Platform$OS.type == "windows") {
[10:21:10.883]                 old_names <- names(...future.oldEnvVars)
[10:21:10.883]                 envs <- base::Sys.getenv()
[10:21:10.883]                 names <- names(envs)
[10:21:10.883]                 common <- intersect(names, old_names)
[10:21:10.883]                 added <- setdiff(names, old_names)
[10:21:10.883]                 removed <- setdiff(old_names, names)
[10:21:10.883]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.883]                   envs[common]]
[10:21:10.883]                 NAMES <- toupper(changed)
[10:21:10.883]                 args <- list()
[10:21:10.883]                 for (kk in seq_along(NAMES)) {
[10:21:10.883]                   name <- changed[[kk]]
[10:21:10.883]                   NAME <- NAMES[[kk]]
[10:21:10.883]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.883]                     next
[10:21:10.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.883]                 }
[10:21:10.883]                 NAMES <- toupper(added)
[10:21:10.883]                 for (kk in seq_along(NAMES)) {
[10:21:10.883]                   name <- added[[kk]]
[10:21:10.883]                   NAME <- NAMES[[kk]]
[10:21:10.883]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.883]                     next
[10:21:10.883]                   args[[name]] <- ""
[10:21:10.883]                 }
[10:21:10.883]                 NAMES <- toupper(removed)
[10:21:10.883]                 for (kk in seq_along(NAMES)) {
[10:21:10.883]                   name <- removed[[kk]]
[10:21:10.883]                   NAME <- NAMES[[kk]]
[10:21:10.883]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.883]                     next
[10:21:10.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.883]                 }
[10:21:10.883]                 if (length(args) > 0) 
[10:21:10.883]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.883]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.883]             }
[10:21:10.883]             else {
[10:21:10.883]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.883]             }
[10:21:10.883]             {
[10:21:10.883]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.883]                   0L) {
[10:21:10.883]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.883]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.883]                   base::options(opts)
[10:21:10.883]                 }
[10:21:10.883]                 {
[10:21:10.883]                   {
[10:21:10.883]                     NULL
[10:21:10.883]                     RNGkind("Mersenne-Twister")
[10:21:10.883]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:10.883]                       inherits = FALSE)
[10:21:10.883]                   }
[10:21:10.883]                   options(future.plan = NULL)
[10:21:10.883]                   if (is.na(NA_character_)) 
[10:21:10.883]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.883]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.883]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.883]                     .init = FALSE)
[10:21:10.883]                 }
[10:21:10.883]             }
[10:21:10.883]         }
[10:21:10.883]     })
[10:21:10.883]     if (TRUE) {
[10:21:10.883]         base::sink(type = "output", split = FALSE)
[10:21:10.883]         if (TRUE) {
[10:21:10.883]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.883]         }
[10:21:10.883]         else {
[10:21:10.883]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.883]         }
[10:21:10.883]         base::close(...future.stdout)
[10:21:10.883]         ...future.stdout <- NULL
[10:21:10.883]     }
[10:21:10.883]     ...future.result$conditions <- ...future.conditions
[10:21:10.883]     ...future.result$finished <- base::Sys.time()
[10:21:10.883]     ...future.result
[10:21:10.883] }
[10:21:10.918]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.885] plan(): Setting new future strategy stack:
[10:21:10.918]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.885] List of future strategies:
[10:21:10.885] 1. sequential:
[10:21:10.885]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.885]    - tweaked: FALSE
[10:21:10.885]    - call: NULL
[10:21:10.918]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.886] plan(): nbrOfWorkers() = 1
[10:21:10.918]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.887] plan(): Setting new future strategy stack:
[10:21:10.919]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.887] List of future strategies:
[10:21:10.887] 1. sequential:
[10:21:10.887]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.887]    - tweaked: FALSE
[10:21:10.887]    - call: NULL
[10:21:10.919]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.888] plan(): nbrOfWorkers() = 1
[10:21:10.919]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.888] SequentialFuture started (and completed)
[10:21:10.919]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.889] - Launch lazy future ... done
[10:21:10.919]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.889] run() for ‘SequentialFuture’ ... done
[10:21:10.919]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.889] getGlobalsAndPackages() ...
[10:21:10.920]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.889] Searching for globals...
[10:21:10.920]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.890] 
[10:21:10.920]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.890] Searching for globals ... DONE
[10:21:10.920]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.890] - globals: [0] <none>
[10:21:10.920]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.891] getGlobalsAndPackages() ... DONE
[10:21:10.920]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.891] run() for ‘Future’ ...
[10:21:10.921]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.891] - state: ‘created’
[10:21:10.921]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.891] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:10.921]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.892] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:10.921]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.892] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:10.921]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.892]   - Field: ‘label’
[10:21:10.921]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.892]   - Field: ‘local’
[10:21:10.922]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.893]   - Field: ‘owner’
[10:21:10.922]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.893]   - Field: ‘envir’
[10:21:10.922]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.893]   - Field: ‘packages’
[10:21:10.922]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.893]   - Field: ‘gc’
[10:21:10.922]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.893]   - Field: ‘conditions’
[10:21:10.922]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.893]   - Field: ‘expr’
[10:21:10.922]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.893]   - Field: ‘uuid’
[10:21:10.923]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.894]   - Field: ‘seed’
[10:21:10.923]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.894]   - Field: ‘version’
[10:21:10.923]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.894]   - Field: ‘result’
[10:21:10.923]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.894]   - Field: ‘asynchronous’
[10:21:10.923]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.894]   - Field: ‘calls’
[10:21:10.923]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.894]   - Field: ‘globals’
[10:21:10.924]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.895]   - Field: ‘stdout’
[10:21:10.924]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.895]   - Field: ‘earlySignal’
[10:21:10.924]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.895]   - Field: ‘lazy’
[10:21:10.924]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.895]   - Field: ‘state’
[10:21:10.924]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.895] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:10.924]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.895] - Launch lazy future ...
[10:21:10.924]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.896] Packages needed by the future expression (n = 0): <none>
[10:21:10.925]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.896] Packages needed by future strategies (n = 0): <none>
[10:21:10.925]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.896] {
[10:21:10.896]     {
[10:21:10.896]         {
[10:21:10.896]             ...future.startTime <- base::Sys.time()
[10:21:10.896]             {
[10:21:10.896]                 {
[10:21:10.896]                   {
[10:21:10.896]                     base::local({
[10:21:10.896]                       has_future <- base::requireNamespace("future", 
[10:21:10.896]                         quietly = TRUE)
[10:21:10.896]                       if (has_future) {
[10:21:10.896]                         ns <- base::getNamespace("future")
[10:21:10.896]                         version <- ns[[".package"]][["version"]]
[10:21:10.896]                         if (is.null(version)) 
[10:21:10.896]                           version <- utils::packageVersion("future")
[10:21:10.896]                       }
[10:21:10.896]                       else {
[10:21:10.896]                         version <- NULL
[10:21:10.896]                       }
[10:21:10.896]                       if (!has_future || version < "1.8.0") {
[10:21:10.896]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.896]                           "", base::R.version$version.string), 
[10:21:10.896]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:10.896]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.896]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.896]                             "release", "version")], collapse = " "), 
[10:21:10.896]                           hostname = base::Sys.info()[["nodename"]])
[10:21:10.896]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.896]                           info)
[10:21:10.896]                         info <- base::paste(info, collapse = "; ")
[10:21:10.896]                         if (!has_future) {
[10:21:10.896]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.896]                             info)
[10:21:10.896]                         }
[10:21:10.896]                         else {
[10:21:10.896]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.896]                             info, version)
[10:21:10.896]                         }
[10:21:10.896]                         base::stop(msg)
[10:21:10.896]                       }
[10:21:10.896]                     })
[10:21:10.896]                   }
[10:21:10.896]                   ...future.strategy.old <- future::plan("list")
[10:21:10.896]                   options(future.plan = NULL)
[10:21:10.896]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.896]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.896]                 }
[10:21:10.896]                 ...future.workdir <- getwd()
[10:21:10.896]             }
[10:21:10.896]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.896]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.896]         }
[10:21:10.896]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.896]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.896]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.896]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.896]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.896]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.896]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.896]             base::names(...future.oldOptions))
[10:21:10.896]     }
[10:21:10.896]     if (FALSE) {
[10:21:10.896]     }
[10:21:10.896]     else {
[10:21:10.896]         if (TRUE) {
[10:21:10.896]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.896]                 open = "w")
[10:21:10.896]         }
[10:21:10.896]         else {
[10:21:10.896]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.896]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.896]         }
[10:21:10.896]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.896]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.896]             base::sink(type = "output", split = FALSE)
[10:21:10.896]             base::close(...future.stdout)
[10:21:10.896]         }, add = TRUE)
[10:21:10.896]     }
[10:21:10.896]     ...future.frame <- base::sys.nframe()
[10:21:10.896]     ...future.conditions <- base::list()
[10:21:10.896]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.896]     if (FALSE) {
[10:21:10.896]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.896]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.896]     }
[10:21:10.896]     ...future.result <- base::tryCatch({
[10:21:10.896]         base::withCallingHandlers({
[10:21:10.896]             ...future.value <- base::withVisible(base::local(4))
[10:21:10.896]             future::FutureResult(value = ...future.value$value, 
[10:21:10.896]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.896]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.896]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.896]                     ...future.globalenv.names))
[10:21:10.896]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.896]         }, condition = base::local({
[10:21:10.896]             c <- base::c
[10:21:10.896]             inherits <- base::inherits
[10:21:10.896]             invokeRestart <- base::invokeRestart
[10:21:10.896]             length <- base::length
[10:21:10.896]             list <- base::list
[10:21:10.896]             seq.int <- base::seq.int
[10:21:10.896]             signalCondition <- base::signalCondition
[10:21:10.896]             sys.calls <- base::sys.calls
[10:21:10.896]             `[[` <- base::`[[`
[10:21:10.896]             `+` <- base::`+`
[10:21:10.896]             `<<-` <- base::`<<-`
[10:21:10.896]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.896]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.896]                   3L)]
[10:21:10.896]             }
[10:21:10.896]             function(cond) {
[10:21:10.896]                 is_error <- inherits(cond, "error")
[10:21:10.896]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.896]                   NULL)
[10:21:10.896]                 if (is_error) {
[10:21:10.896]                   sessionInformation <- function() {
[10:21:10.896]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.896]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.896]                       search = base::search(), system = base::Sys.info())
[10:21:10.896]                   }
[10:21:10.896]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.896]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.896]                     cond$call), session = sessionInformation(), 
[10:21:10.896]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.896]                   signalCondition(cond)
[10:21:10.896]                 }
[10:21:10.896]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.896]                 "immediateCondition"))) {
[10:21:10.896]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.896]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.896]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.896]                   if (TRUE && !signal) {
[10:21:10.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.896]                     {
[10:21:10.896]                       inherits <- base::inherits
[10:21:10.896]                       invokeRestart <- base::invokeRestart
[10:21:10.896]                       is.null <- base::is.null
[10:21:10.896]                       muffled <- FALSE
[10:21:10.896]                       if (inherits(cond, "message")) {
[10:21:10.896]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.896]                         if (muffled) 
[10:21:10.896]                           invokeRestart("muffleMessage")
[10:21:10.896]                       }
[10:21:10.896]                       else if (inherits(cond, "warning")) {
[10:21:10.896]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.896]                         if (muffled) 
[10:21:10.896]                           invokeRestart("muffleWarning")
[10:21:10.896]                       }
[10:21:10.896]                       else if (inherits(cond, "condition")) {
[10:21:10.896]                         if (!is.null(pattern)) {
[10:21:10.896]                           computeRestarts <- base::computeRestarts
[10:21:10.896]                           grepl <- base::grepl
[10:21:10.896]                           restarts <- computeRestarts(cond)
[10:21:10.896]                           for (restart in restarts) {
[10:21:10.896]                             name <- restart$name
[10:21:10.896]                             if (is.null(name)) 
[10:21:10.896]                               next
[10:21:10.896]                             if (!grepl(pattern, name)) 
[10:21:10.896]                               next
[10:21:10.896]                             invokeRestart(restart)
[10:21:10.896]                             muffled <- TRUE
[10:21:10.896]                             break
[10:21:10.896]                           }
[10:21:10.896]                         }
[10:21:10.896]                       }
[10:21:10.896]                       invisible(muffled)
[10:21:10.896]                     }
[10:21:10.896]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.896]                   }
[10:21:10.896]                 }
[10:21:10.896]                 else {
[10:21:10.896]                   if (TRUE) {
[10:21:10.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.896]                     {
[10:21:10.896]                       inherits <- base::inherits
[10:21:10.896]                       invokeRestart <- base::invokeRestart
[10:21:10.896]                       is.null <- base::is.null
[10:21:10.896]                       muffled <- FALSE
[10:21:10.896]                       if (inherits(cond, "message")) {
[10:21:10.896]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.896]                         if (muffled) 
[10:21:10.896]                           invokeRestart("muffleMessage")
[10:21:10.896]                       }
[10:21:10.896]                       else if (inherits(cond, "warning")) {
[10:21:10.896]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.896]                         if (muffled) 
[10:21:10.896]                           invokeRestart("muffleWarning")
[10:21:10.896]                       }
[10:21:10.896]                       else if (inherits(cond, "condition")) {
[10:21:10.896]                         if (!is.null(pattern)) {
[10:21:10.896]                           computeRestarts <- base::computeRestarts
[10:21:10.896]                           grepl <- base::grepl
[10:21:10.896]                           restarts <- computeRestarts(cond)
[10:21:10.896]                           for (restart in restarts) {
[10:21:10.896]                             name <- restart$name
[10:21:10.896]                             if (is.null(name)) 
[10:21:10.896]                               next
[10:21:10.896]                             if (!grepl(pattern, name)) 
[10:21:10.896]                               next
[10:21:10.896]                             invokeRestart(restart)
[10:21:10.896]                             muffled <- TRUE
[10:21:10.896]                             break
[10:21:10.896]                           }
[10:21:10.896]                         }
[10:21:10.896]                       }
[10:21:10.896]                       invisible(muffled)
[10:21:10.896]                     }
[10:21:10.896]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.896]                   }
[10:21:10.896]                 }
[10:21:10.896]             }
[10:21:10.896]         }))
[10:21:10.896]     }, error = function(ex) {
[10:21:10.896]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.896]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.896]                 ...future.rng), started = ...future.startTime, 
[10:21:10.896]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.896]             version = "1.8"), class = "FutureResult")
[10:21:10.896]     }, finally = {
[10:21:10.896]         if (!identical(...future.workdir, getwd())) 
[10:21:10.896]             setwd(...future.workdir)
[10:21:10.896]         {
[10:21:10.896]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.896]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.896]             }
[10:21:10.896]             base::options(...future.oldOptions)
[10:21:10.896]             if (.Platform$OS.type == "windows") {
[10:21:10.896]                 old_names <- names(...future.oldEnvVars)
[10:21:10.896]                 envs <- base::Sys.getenv()
[10:21:10.896]                 names <- names(envs)
[10:21:10.896]                 common <- intersect(names, old_names)
[10:21:10.896]                 added <- setdiff(names, old_names)
[10:21:10.896]                 removed <- setdiff(old_names, names)
[10:21:10.896]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.896]                   envs[common]]
[10:21:10.896]                 NAMES <- toupper(changed)
[10:21:10.896]                 args <- list()
[10:21:10.896]                 for (kk in seq_along(NAMES)) {
[10:21:10.896]                   name <- changed[[kk]]
[10:21:10.896]                   NAME <- NAMES[[kk]]
[10:21:10.896]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.896]                     next
[10:21:10.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.896]                 }
[10:21:10.896]                 NAMES <- toupper(added)
[10:21:10.896]                 for (kk in seq_along(NAMES)) {
[10:21:10.896]                   name <- added[[kk]]
[10:21:10.896]                   NAME <- NAMES[[kk]]
[10:21:10.896]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.896]                     next
[10:21:10.896]                   args[[name]] <- ""
[10:21:10.896]                 }
[10:21:10.896]                 NAMES <- toupper(removed)
[10:21:10.896]                 for (kk in seq_along(NAMES)) {
[10:21:10.896]                   name <- removed[[kk]]
[10:21:10.896]                   NAME <- NAMES[[kk]]
[10:21:10.896]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.896]                     next
[10:21:10.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.896]                 }
[10:21:10.896]                 if (length(args) > 0) 
[10:21:10.896]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.896]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.896]             }
[10:21:10.896]             else {
[10:21:10.896]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.896]             }
[10:21:10.896]             {
[10:21:10.896]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.896]                   0L) {
[10:21:10.896]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.896]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.896]                   base::options(opts)
[10:21:10.896]                 }
[10:21:10.896]                 {
[10:21:10.896]                   {
[10:21:10.896]                     NULL
[10:21:10.896]                     RNGkind("Mersenne-Twister")
[10:21:10.896]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:10.896]                       inherits = FALSE)
[10:21:10.896]                   }
[10:21:10.896]                   options(future.plan = NULL)
[10:21:10.896]                   if (is.na(NA_character_)) 
[10:21:10.896]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.896]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.896]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.896]                     .init = FALSE)
[10:21:10.896]                 }
[10:21:10.896]             }
[10:21:10.896]         }
[10:21:10.896]     })
[10:21:10.896]     if (TRUE) {
[10:21:10.896]         base::sink(type = "output", split = FALSE)
[10:21:10.896]         if (TRUE) {
[10:21:10.896]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.896]         }
[10:21:10.896]         else {
[10:21:10.896]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.896]         }
[10:21:10.896]         base::close(...future.stdout)
[10:21:10.896]         ...future.stdout <- NULL
[10:21:10.896]     }
[10:21:10.896]     ...future.result$conditions <- ...future.conditions
[10:21:10.896]     ...future.result$finished <- base::Sys.time()
[10:21:10.896]     ...future.result
[10:21:10.896] }
[10:21:10.925]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.898] plan(): Setting new future strategy stack:
[10:21:10.925]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.898] List of future strategies:
[10:21:10.898] 1. sequential:
[10:21:10.898]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.898]    - tweaked: FALSE
[10:21:10.898]    - call: NULL
[10:21:10.925]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.899] plan(): nbrOfWorkers() = 1
[10:21:10.925]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.900] plan(): Setting new future strategy stack:
[10:21:10.926]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.900] List of future strategies:
[10:21:10.900] 1. sequential:
[10:21:10.900]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.900]    - tweaked: FALSE
[10:21:10.900]    - call: NULL
[10:21:10.926]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.901] plan(): nbrOfWorkers() = 1
[10:21:10.926]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.901] SequentialFuture started (and completed)
[10:21:10.926]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.901] - Launch lazy future ... done
[10:21:10.926]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:10.901] run() for ‘SequentialFuture’ ... done
[10:21:10.926] signalConditions() ... done
a = 10
[10:21:10.927] getGlobalsAndPackages() ...
[10:21:10.927] Searching for globals...
[10:21:10.928] - globals found: [3] ‘{’, ‘+’, ‘a’
[10:21:10.928] Searching for globals ... DONE
[10:21:10.928] Resolving globals: FALSE
[10:21:10.929] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:10.929] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:10.929] - globals: [1] ‘a’
[10:21:10.930] 
[10:21:10.930] getGlobalsAndPackages() ... DONE
[10:21:10.930] run() for ‘Future’ ...
[10:21:10.930] - state: ‘created’
[10:21:10.930] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:10.932] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:10.932] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:10.932]   - Field: ‘label’
[10:21:10.932]   - Field: ‘local’
[10:21:10.932]   - Field: ‘owner’
[10:21:10.933]   - Field: ‘envir’
[10:21:10.933]   - Field: ‘workers’
[10:21:10.933]   - Field: ‘packages’
[10:21:10.933]   - Field: ‘gc’
[10:21:10.933]   - Field: ‘job’
[10:21:10.933]   - Field: ‘conditions’
[10:21:10.933]   - Field: ‘expr’
[10:21:10.933]   - Field: ‘uuid’
[10:21:10.933]   - Field: ‘seed’
[10:21:10.933]   - Field: ‘version’
[10:21:10.933]   - Field: ‘result’
[10:21:10.933]   - Field: ‘asynchronous’
[10:21:10.934]   - Field: ‘calls’
[10:21:10.934]   - Field: ‘globals’
[10:21:10.934]   - Field: ‘stdout’
[10:21:10.934]   - Field: ‘earlySignal’
[10:21:10.934]   - Field: ‘lazy’
[10:21:10.934]   - Field: ‘state’
[10:21:10.934] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:10.934] - Launch lazy future ...
[10:21:10.934] Packages needed by the future expression (n = 0): <none>
[10:21:10.935] Packages needed by future strategies (n = 0): <none>
[10:21:10.937] {
[10:21:10.937]     {
[10:21:10.937]         {
[10:21:10.937]             ...future.startTime <- base::Sys.time()
[10:21:10.937]             {
[10:21:10.937]                 {
[10:21:10.937]                   {
[10:21:10.937]                     {
[10:21:10.937]                       base::local({
[10:21:10.937]                         has_future <- base::requireNamespace("future", 
[10:21:10.937]                           quietly = TRUE)
[10:21:10.937]                         if (has_future) {
[10:21:10.937]                           ns <- base::getNamespace("future")
[10:21:10.937]                           version <- ns[[".package"]][["version"]]
[10:21:10.937]                           if (is.null(version)) 
[10:21:10.937]                             version <- utils::packageVersion("future")
[10:21:10.937]                         }
[10:21:10.937]                         else {
[10:21:10.937]                           version <- NULL
[10:21:10.937]                         }
[10:21:10.937]                         if (!has_future || version < "1.8.0") {
[10:21:10.937]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:10.937]                             "", base::R.version$version.string), 
[10:21:10.937]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:10.937]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:10.937]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:10.937]                               "release", "version")], collapse = " "), 
[10:21:10.937]                             hostname = base::Sys.info()[["nodename"]])
[10:21:10.937]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:10.937]                             info)
[10:21:10.937]                           info <- base::paste(info, collapse = "; ")
[10:21:10.937]                           if (!has_future) {
[10:21:10.937]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:10.937]                               info)
[10:21:10.937]                           }
[10:21:10.937]                           else {
[10:21:10.937]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:10.937]                               info, version)
[10:21:10.937]                           }
[10:21:10.937]                           base::stop(msg)
[10:21:10.937]                         }
[10:21:10.937]                       })
[10:21:10.937]                     }
[10:21:10.937]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:10.937]                     base::options(mc.cores = 1L)
[10:21:10.937]                   }
[10:21:10.937]                   ...future.strategy.old <- future::plan("list")
[10:21:10.937]                   options(future.plan = NULL)
[10:21:10.937]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.937]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:10.937]                 }
[10:21:10.937]                 ...future.workdir <- getwd()
[10:21:10.937]             }
[10:21:10.937]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:10.937]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:10.937]         }
[10:21:10.937]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:10.937]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:10.937]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:10.937]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:10.937]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:10.937]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:10.937]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:10.937]             base::names(...future.oldOptions))
[10:21:10.937]     }
[10:21:10.937]     if (FALSE) {
[10:21:10.937]     }
[10:21:10.937]     else {
[10:21:10.937]         if (TRUE) {
[10:21:10.937]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:10.937]                 open = "w")
[10:21:10.937]         }
[10:21:10.937]         else {
[10:21:10.937]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:10.937]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:10.937]         }
[10:21:10.937]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:10.937]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:10.937]             base::sink(type = "output", split = FALSE)
[10:21:10.937]             base::close(...future.stdout)
[10:21:10.937]         }, add = TRUE)
[10:21:10.937]     }
[10:21:10.937]     ...future.frame <- base::sys.nframe()
[10:21:10.937]     ...future.conditions <- base::list()
[10:21:10.937]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:10.937]     if (FALSE) {
[10:21:10.937]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:10.937]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:10.937]     }
[10:21:10.937]     ...future.result <- base::tryCatch({
[10:21:10.937]         base::withCallingHandlers({
[10:21:10.937]             ...future.value <- base::withVisible(base::local({
[10:21:10.937]                 withCallingHandlers({
[10:21:10.937]                   {
[10:21:10.937]                     a + 1
[10:21:10.937]                   }
[10:21:10.937]                 }, immediateCondition = function(cond) {
[10:21:10.937]                   save_rds <- function (object, pathname, ...) 
[10:21:10.937]                   {
[10:21:10.937]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:10.937]                     if (file_test("-f", pathname_tmp)) {
[10:21:10.937]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.937]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:10.937]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.937]                         fi_tmp[["mtime"]])
[10:21:10.937]                     }
[10:21:10.937]                     tryCatch({
[10:21:10.937]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:10.937]                     }, error = function(ex) {
[10:21:10.937]                       msg <- conditionMessage(ex)
[10:21:10.937]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.937]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:10.937]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.937]                         fi_tmp[["mtime"]], msg)
[10:21:10.937]                       ex$message <- msg
[10:21:10.937]                       stop(ex)
[10:21:10.937]                     })
[10:21:10.937]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:10.937]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:10.937]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:10.937]                       fi_tmp <- file.info(pathname_tmp)
[10:21:10.937]                       fi <- file.info(pathname)
[10:21:10.937]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:10.937]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:10.937]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:10.937]                         fi[["size"]], fi[["mtime"]])
[10:21:10.937]                       stop(msg)
[10:21:10.937]                     }
[10:21:10.937]                     invisible(pathname)
[10:21:10.937]                   }
[10:21:10.937]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:10.937]                     rootPath = tempdir()) 
[10:21:10.937]                   {
[10:21:10.937]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:10.937]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:10.937]                       tmpdir = path, fileext = ".rds")
[10:21:10.937]                     save_rds(obj, file)
[10:21:10.937]                   }
[10:21:10.937]                   saveImmediateCondition(cond, path = "/tmp/RtmpKymecF/.future/immediateConditions")
[10:21:10.937]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.937]                   {
[10:21:10.937]                     inherits <- base::inherits
[10:21:10.937]                     invokeRestart <- base::invokeRestart
[10:21:10.937]                     is.null <- base::is.null
[10:21:10.937]                     muffled <- FALSE
[10:21:10.937]                     if (inherits(cond, "message")) {
[10:21:10.937]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:10.937]                       if (muffled) 
[10:21:10.937]                         invokeRestart("muffleMessage")
[10:21:10.937]                     }
[10:21:10.937]                     else if (inherits(cond, "warning")) {
[10:21:10.937]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:10.937]                       if (muffled) 
[10:21:10.937]                         invokeRestart("muffleWarning")
[10:21:10.937]                     }
[10:21:10.937]                     else if (inherits(cond, "condition")) {
[10:21:10.937]                       if (!is.null(pattern)) {
[10:21:10.937]                         computeRestarts <- base::computeRestarts
[10:21:10.937]                         grepl <- base::grepl
[10:21:10.937]                         restarts <- computeRestarts(cond)
[10:21:10.937]                         for (restart in restarts) {
[10:21:10.937]                           name <- restart$name
[10:21:10.937]                           if (is.null(name)) 
[10:21:10.937]                             next
[10:21:10.937]                           if (!grepl(pattern, name)) 
[10:21:10.937]                             next
[10:21:10.937]                           invokeRestart(restart)
[10:21:10.937]                           muffled <- TRUE
[10:21:10.937]                           break
[10:21:10.937]                         }
[10:21:10.937]                       }
[10:21:10.937]                     }
[10:21:10.937]                     invisible(muffled)
[10:21:10.937]                   }
[10:21:10.937]                   muffleCondition(cond)
[10:21:10.937]                 })
[10:21:10.937]             }))
[10:21:10.937]             future::FutureResult(value = ...future.value$value, 
[10:21:10.937]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.937]                   ...future.rng), globalenv = if (FALSE) 
[10:21:10.937]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:10.937]                     ...future.globalenv.names))
[10:21:10.937]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:10.937]         }, condition = base::local({
[10:21:10.937]             c <- base::c
[10:21:10.937]             inherits <- base::inherits
[10:21:10.937]             invokeRestart <- base::invokeRestart
[10:21:10.937]             length <- base::length
[10:21:10.937]             list <- base::list
[10:21:10.937]             seq.int <- base::seq.int
[10:21:10.937]             signalCondition <- base::signalCondition
[10:21:10.937]             sys.calls <- base::sys.calls
[10:21:10.937]             `[[` <- base::`[[`
[10:21:10.937]             `+` <- base::`+`
[10:21:10.937]             `<<-` <- base::`<<-`
[10:21:10.937]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:10.937]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:10.937]                   3L)]
[10:21:10.937]             }
[10:21:10.937]             function(cond) {
[10:21:10.937]                 is_error <- inherits(cond, "error")
[10:21:10.937]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:10.937]                   NULL)
[10:21:10.937]                 if (is_error) {
[10:21:10.937]                   sessionInformation <- function() {
[10:21:10.937]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:10.937]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:10.937]                       search = base::search(), system = base::Sys.info())
[10:21:10.937]                   }
[10:21:10.937]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.937]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:10.937]                     cond$call), session = sessionInformation(), 
[10:21:10.937]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:10.937]                   signalCondition(cond)
[10:21:10.937]                 }
[10:21:10.937]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:10.937]                 "immediateCondition"))) {
[10:21:10.937]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:10.937]                   ...future.conditions[[length(...future.conditions) + 
[10:21:10.937]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:10.937]                   if (TRUE && !signal) {
[10:21:10.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.937]                     {
[10:21:10.937]                       inherits <- base::inherits
[10:21:10.937]                       invokeRestart <- base::invokeRestart
[10:21:10.937]                       is.null <- base::is.null
[10:21:10.937]                       muffled <- FALSE
[10:21:10.937]                       if (inherits(cond, "message")) {
[10:21:10.937]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.937]                         if (muffled) 
[10:21:10.937]                           invokeRestart("muffleMessage")
[10:21:10.937]                       }
[10:21:10.937]                       else if (inherits(cond, "warning")) {
[10:21:10.937]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.937]                         if (muffled) 
[10:21:10.937]                           invokeRestart("muffleWarning")
[10:21:10.937]                       }
[10:21:10.937]                       else if (inherits(cond, "condition")) {
[10:21:10.937]                         if (!is.null(pattern)) {
[10:21:10.937]                           computeRestarts <- base::computeRestarts
[10:21:10.937]                           grepl <- base::grepl
[10:21:10.937]                           restarts <- computeRestarts(cond)
[10:21:10.937]                           for (restart in restarts) {
[10:21:10.937]                             name <- restart$name
[10:21:10.937]                             if (is.null(name)) 
[10:21:10.937]                               next
[10:21:10.937]                             if (!grepl(pattern, name)) 
[10:21:10.937]                               next
[10:21:10.937]                             invokeRestart(restart)
[10:21:10.937]                             muffled <- TRUE
[10:21:10.937]                             break
[10:21:10.937]                           }
[10:21:10.937]                         }
[10:21:10.937]                       }
[10:21:10.937]                       invisible(muffled)
[10:21:10.937]                     }
[10:21:10.937]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.937]                   }
[10:21:10.937]                 }
[10:21:10.937]                 else {
[10:21:10.937]                   if (TRUE) {
[10:21:10.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:10.937]                     {
[10:21:10.937]                       inherits <- base::inherits
[10:21:10.937]                       invokeRestart <- base::invokeRestart
[10:21:10.937]                       is.null <- base::is.null
[10:21:10.937]                       muffled <- FALSE
[10:21:10.937]                       if (inherits(cond, "message")) {
[10:21:10.937]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:10.937]                         if (muffled) 
[10:21:10.937]                           invokeRestart("muffleMessage")
[10:21:10.937]                       }
[10:21:10.937]                       else if (inherits(cond, "warning")) {
[10:21:10.937]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:10.937]                         if (muffled) 
[10:21:10.937]                           invokeRestart("muffleWarning")
[10:21:10.937]                       }
[10:21:10.937]                       else if (inherits(cond, "condition")) {
[10:21:10.937]                         if (!is.null(pattern)) {
[10:21:10.937]                           computeRestarts <- base::computeRestarts
[10:21:10.937]                           grepl <- base::grepl
[10:21:10.937]                           restarts <- computeRestarts(cond)
[10:21:10.937]                           for (restart in restarts) {
[10:21:10.937]                             name <- restart$name
[10:21:10.937]                             if (is.null(name)) 
[10:21:10.937]                               next
[10:21:10.937]                             if (!grepl(pattern, name)) 
[10:21:10.937]                               next
[10:21:10.937]                             invokeRestart(restart)
[10:21:10.937]                             muffled <- TRUE
[10:21:10.937]                             break
[10:21:10.937]                           }
[10:21:10.937]                         }
[10:21:10.937]                       }
[10:21:10.937]                       invisible(muffled)
[10:21:10.937]                     }
[10:21:10.937]                     muffleCondition(cond, pattern = "^muffle")
[10:21:10.937]                   }
[10:21:10.937]                 }
[10:21:10.937]             }
[10:21:10.937]         }))
[10:21:10.937]     }, error = function(ex) {
[10:21:10.937]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:10.937]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:10.937]                 ...future.rng), started = ...future.startTime, 
[10:21:10.937]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:10.937]             version = "1.8"), class = "FutureResult")
[10:21:10.937]     }, finally = {
[10:21:10.937]         if (!identical(...future.workdir, getwd())) 
[10:21:10.937]             setwd(...future.workdir)
[10:21:10.937]         {
[10:21:10.937]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:10.937]                 ...future.oldOptions$nwarnings <- NULL
[10:21:10.937]             }
[10:21:10.937]             base::options(...future.oldOptions)
[10:21:10.937]             if (.Platform$OS.type == "windows") {
[10:21:10.937]                 old_names <- names(...future.oldEnvVars)
[10:21:10.937]                 envs <- base::Sys.getenv()
[10:21:10.937]                 names <- names(envs)
[10:21:10.937]                 common <- intersect(names, old_names)
[10:21:10.937]                 added <- setdiff(names, old_names)
[10:21:10.937]                 removed <- setdiff(old_names, names)
[10:21:10.937]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:10.937]                   envs[common]]
[10:21:10.937]                 NAMES <- toupper(changed)
[10:21:10.937]                 args <- list()
[10:21:10.937]                 for (kk in seq_along(NAMES)) {
[10:21:10.937]                   name <- changed[[kk]]
[10:21:10.937]                   NAME <- NAMES[[kk]]
[10:21:10.937]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.937]                     next
[10:21:10.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.937]                 }
[10:21:10.937]                 NAMES <- toupper(added)
[10:21:10.937]                 for (kk in seq_along(NAMES)) {
[10:21:10.937]                   name <- added[[kk]]
[10:21:10.937]                   NAME <- NAMES[[kk]]
[10:21:10.937]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.937]                     next
[10:21:10.937]                   args[[name]] <- ""
[10:21:10.937]                 }
[10:21:10.937]                 NAMES <- toupper(removed)
[10:21:10.937]                 for (kk in seq_along(NAMES)) {
[10:21:10.937]                   name <- removed[[kk]]
[10:21:10.937]                   NAME <- NAMES[[kk]]
[10:21:10.937]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:10.937]                     next
[10:21:10.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:10.937]                 }
[10:21:10.937]                 if (length(args) > 0) 
[10:21:10.937]                   base::do.call(base::Sys.setenv, args = args)
[10:21:10.937]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:10.937]             }
[10:21:10.937]             else {
[10:21:10.937]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:10.937]             }
[10:21:10.937]             {
[10:21:10.937]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:10.937]                   0L) {
[10:21:10.937]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:10.937]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:10.937]                   base::options(opts)
[10:21:10.937]                 }
[10:21:10.937]                 {
[10:21:10.937]                   {
[10:21:10.937]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:10.937]                     NULL
[10:21:10.937]                   }
[10:21:10.937]                   options(future.plan = NULL)
[10:21:10.937]                   if (is.na(NA_character_)) 
[10:21:10.937]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:10.937]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:10.937]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:10.937]                     .init = FALSE)
[10:21:10.937]                 }
[10:21:10.937]             }
[10:21:10.937]         }
[10:21:10.937]     })
[10:21:10.937]     if (TRUE) {
[10:21:10.937]         base::sink(type = "output", split = FALSE)
[10:21:10.937]         if (TRUE) {
[10:21:10.937]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:10.937]         }
[10:21:10.937]         else {
[10:21:10.937]             ...future.result["stdout"] <- base::list(NULL)
[10:21:10.937]         }
[10:21:10.937]         base::close(...future.stdout)
[10:21:10.937]         ...future.stdout <- NULL
[10:21:10.937]     }
[10:21:10.937]     ...future.result$conditions <- ...future.conditions
[10:21:10.937]     ...future.result$finished <- base::Sys.time()
[10:21:10.937]     ...future.result
[10:21:10.937] }
[10:21:10.939] assign_globals() ...
[10:21:10.939] List of 1
[10:21:10.939]  $ a: num 10
[10:21:10.939]  - attr(*, "where")=List of 1
[10:21:10.939]   ..$ a:<environment: R_EmptyEnv> 
[10:21:10.939]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:10.939]  - attr(*, "resolved")= logi FALSE
[10:21:10.939]  - attr(*, "total_size")= num 39
[10:21:10.939]  - attr(*, "already-done")= logi TRUE
[10:21:10.942] - copied ‘a’ to environment
[10:21:10.942] assign_globals() ... done
[10:21:10.942] requestCore(): workers = 2
[10:21:10.944] MulticoreFuture started
[10:21:10.944] - Launch lazy future ... done
[10:21:10.945] run() for ‘MulticoreFuture’ ... done
[10:21:10.945] plan(): Setting new future strategy stack:
[10:21:10.945] result() for MulticoreFuture ...
[10:21:10.945] List of future strategies:
[10:21:10.945] 1. sequential:
[10:21:10.945]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:10.945]    - tweaked: FALSE
[10:21:10.945]    - call: NULL
[10:21:10.946] plan(): nbrOfWorkers() = 1
[10:21:10.948] plan(): Setting new future strategy stack:
[10:21:10.949] List of future strategies:
[10:21:10.949] 1. multicore:
[10:21:10.949]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:10.949]    - tweaked: FALSE
[10:21:10.949]    - call: plan(strategy)
[10:21:10.952] plan(): nbrOfWorkers() = 2
[10:21:10.953] result() for MulticoreFuture ...
[10:21:10.953] result() for MulticoreFuture ... done
[10:21:10.953] result() for MulticoreFuture ... done
[10:21:10.953] result() for MulticoreFuture ...
[10:21:10.953] result() for MulticoreFuture ... done
b = 11
*** %<-% with ‘multicore’ futures ... DONE
*** %<-% with ‘multisession’ futures ...
[10:21:10.954] plan(): Setting new future strategy stack:
[10:21:10.954] List of future strategies:
[10:21:10.954] 1. multisession:
[10:21:10.954]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:10.954]    - tweaked: FALSE
[10:21:10.954]    - call: plan(strategy)
[10:21:10.955] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:21:10.955] multisession:
[10:21:10.955] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:10.955] - tweaked: FALSE
[10:21:10.955] - call: plan(strategy)
[10:21:10.960] getGlobalsAndPackages() ...
[10:21:10.960] Not searching for globals
[10:21:10.960] - globals: [0] <none>
[10:21:10.960] getGlobalsAndPackages() ... DONE
[10:21:11.452] Packages needed by the future expression (n = 0): <none>
[10:21:11.453] Packages needed by future strategies (n = 0): <none>
[10:21:11.453] {
[10:21:11.453]     {
[10:21:11.453]         {
[10:21:11.453]             ...future.startTime <- base::Sys.time()
[10:21:11.453]             {
[10:21:11.453]                 {
[10:21:11.453]                   {
[10:21:11.453]                     {
[10:21:11.453]                       base::local({
[10:21:11.453]                         has_future <- base::requireNamespace("future", 
[10:21:11.453]                           quietly = TRUE)
[10:21:11.453]                         if (has_future) {
[10:21:11.453]                           ns <- base::getNamespace("future")
[10:21:11.453]                           version <- ns[[".package"]][["version"]]
[10:21:11.453]                           if (is.null(version)) 
[10:21:11.453]                             version <- utils::packageVersion("future")
[10:21:11.453]                         }
[10:21:11.453]                         else {
[10:21:11.453]                           version <- NULL
[10:21:11.453]                         }
[10:21:11.453]                         if (!has_future || version < "1.8.0") {
[10:21:11.453]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:11.453]                             "", base::R.version$version.string), 
[10:21:11.453]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:11.453]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:11.453]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:11.453]                               "release", "version")], collapse = " "), 
[10:21:11.453]                             hostname = base::Sys.info()[["nodename"]])
[10:21:11.453]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:11.453]                             info)
[10:21:11.453]                           info <- base::paste(info, collapse = "; ")
[10:21:11.453]                           if (!has_future) {
[10:21:11.453]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:11.453]                               info)
[10:21:11.453]                           }
[10:21:11.453]                           else {
[10:21:11.453]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:11.453]                               info, version)
[10:21:11.453]                           }
[10:21:11.453]                           base::stop(msg)
[10:21:11.453]                         }
[10:21:11.453]                       })
[10:21:11.453]                     }
[10:21:11.453]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:11.453]                     base::options(mc.cores = 1L)
[10:21:11.453]                   }
[10:21:11.453]                   ...future.strategy.old <- future::plan("list")
[10:21:11.453]                   options(future.plan = NULL)
[10:21:11.453]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:11.453]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:11.453]                 }
[10:21:11.453]                 ...future.workdir <- getwd()
[10:21:11.453]             }
[10:21:11.453]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:11.453]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:11.453]         }
[10:21:11.453]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:11.453]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:11.453]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:11.453]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:11.453]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:11.453]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:11.453]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:11.453]             base::names(...future.oldOptions))
[10:21:11.453]     }
[10:21:11.453]     if (FALSE) {
[10:21:11.453]     }
[10:21:11.453]     else {
[10:21:11.453]         if (TRUE) {
[10:21:11.453]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:11.453]                 open = "w")
[10:21:11.453]         }
[10:21:11.453]         else {
[10:21:11.453]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:11.453]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:11.453]         }
[10:21:11.453]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:11.453]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:11.453]             base::sink(type = "output", split = FALSE)
[10:21:11.453]             base::close(...future.stdout)
[10:21:11.453]         }, add = TRUE)
[10:21:11.453]     }
[10:21:11.453]     ...future.frame <- base::sys.nframe()
[10:21:11.453]     ...future.conditions <- base::list()
[10:21:11.453]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:11.453]     if (FALSE) {
[10:21:11.453]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:11.453]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:11.453]     }
[10:21:11.453]     ...future.result <- base::tryCatch({
[10:21:11.453]         base::withCallingHandlers({
[10:21:11.453]             ...future.value <- base::withVisible(base::local({
[10:21:11.453]                 ...future.makeSendCondition <- base::local({
[10:21:11.453]                   sendCondition <- NULL
[10:21:11.453]                   function(frame = 1L) {
[10:21:11.453]                     if (is.function(sendCondition)) 
[10:21:11.453]                       return(sendCondition)
[10:21:11.453]                     ns <- getNamespace("parallel")
[10:21:11.453]                     if (exists("sendData", mode = "function", 
[10:21:11.453]                       envir = ns)) {
[10:21:11.453]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:11.453]                         envir = ns)
[10:21:11.453]                       envir <- sys.frame(frame)
[10:21:11.453]                       master <- NULL
[10:21:11.453]                       while (!identical(envir, .GlobalEnv) && 
[10:21:11.453]                         !identical(envir, emptyenv())) {
[10:21:11.453]                         if (exists("master", mode = "list", envir = envir, 
[10:21:11.453]                           inherits = FALSE)) {
[10:21:11.453]                           master <- get("master", mode = "list", 
[10:21:11.453]                             envir = envir, inherits = FALSE)
[10:21:11.453]                           if (inherits(master, c("SOCKnode", 
[10:21:11.453]                             "SOCK0node"))) {
[10:21:11.453]                             sendCondition <<- function(cond) {
[10:21:11.453]                               data <- list(type = "VALUE", value = cond, 
[10:21:11.453]                                 success = TRUE)
[10:21:11.453]                               parallel_sendData(master, data)
[10:21:11.453]                             }
[10:21:11.453]                             return(sendCondition)
[10:21:11.453]                           }
[10:21:11.453]                         }
[10:21:11.453]                         frame <- frame + 1L
[10:21:11.453]                         envir <- sys.frame(frame)
[10:21:11.453]                       }
[10:21:11.453]                     }
[10:21:11.453]                     sendCondition <<- function(cond) NULL
[10:21:11.453]                   }
[10:21:11.453]                 })
[10:21:11.453]                 withCallingHandlers({
[10:21:11.453]                   NA
[10:21:11.453]                 }, immediateCondition = function(cond) {
[10:21:11.453]                   sendCondition <- ...future.makeSendCondition()
[10:21:11.453]                   sendCondition(cond)
[10:21:11.453]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.453]                   {
[10:21:11.453]                     inherits <- base::inherits
[10:21:11.453]                     invokeRestart <- base::invokeRestart
[10:21:11.453]                     is.null <- base::is.null
[10:21:11.453]                     muffled <- FALSE
[10:21:11.453]                     if (inherits(cond, "message")) {
[10:21:11.453]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:11.453]                       if (muffled) 
[10:21:11.453]                         invokeRestart("muffleMessage")
[10:21:11.453]                     }
[10:21:11.453]                     else if (inherits(cond, "warning")) {
[10:21:11.453]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:11.453]                       if (muffled) 
[10:21:11.453]                         invokeRestart("muffleWarning")
[10:21:11.453]                     }
[10:21:11.453]                     else if (inherits(cond, "condition")) {
[10:21:11.453]                       if (!is.null(pattern)) {
[10:21:11.453]                         computeRestarts <- base::computeRestarts
[10:21:11.453]                         grepl <- base::grepl
[10:21:11.453]                         restarts <- computeRestarts(cond)
[10:21:11.453]                         for (restart in restarts) {
[10:21:11.453]                           name <- restart$name
[10:21:11.453]                           if (is.null(name)) 
[10:21:11.453]                             next
[10:21:11.453]                           if (!grepl(pattern, name)) 
[10:21:11.453]                             next
[10:21:11.453]                           invokeRestart(restart)
[10:21:11.453]                           muffled <- TRUE
[10:21:11.453]                           break
[10:21:11.453]                         }
[10:21:11.453]                       }
[10:21:11.453]                     }
[10:21:11.453]                     invisible(muffled)
[10:21:11.453]                   }
[10:21:11.453]                   muffleCondition(cond)
[10:21:11.453]                 })
[10:21:11.453]             }))
[10:21:11.453]             future::FutureResult(value = ...future.value$value, 
[10:21:11.453]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:11.453]                   ...future.rng), globalenv = if (FALSE) 
[10:21:11.453]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:11.453]                     ...future.globalenv.names))
[10:21:11.453]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:11.453]         }, condition = base::local({
[10:21:11.453]             c <- base::c
[10:21:11.453]             inherits <- base::inherits
[10:21:11.453]             invokeRestart <- base::invokeRestart
[10:21:11.453]             length <- base::length
[10:21:11.453]             list <- base::list
[10:21:11.453]             seq.int <- base::seq.int
[10:21:11.453]             signalCondition <- base::signalCondition
[10:21:11.453]             sys.calls <- base::sys.calls
[10:21:11.453]             `[[` <- base::`[[`
[10:21:11.453]             `+` <- base::`+`
[10:21:11.453]             `<<-` <- base::`<<-`
[10:21:11.453]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:11.453]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:11.453]                   3L)]
[10:21:11.453]             }
[10:21:11.453]             function(cond) {
[10:21:11.453]                 is_error <- inherits(cond, "error")
[10:21:11.453]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:11.453]                   NULL)
[10:21:11.453]                 if (is_error) {
[10:21:11.453]                   sessionInformation <- function() {
[10:21:11.453]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:11.453]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:11.453]                       search = base::search(), system = base::Sys.info())
[10:21:11.453]                   }
[10:21:11.453]                   ...future.conditions[[length(...future.conditions) + 
[10:21:11.453]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:11.453]                     cond$call), session = sessionInformation(), 
[10:21:11.453]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:11.453]                   signalCondition(cond)
[10:21:11.453]                 }
[10:21:11.453]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:11.453]                 "immediateCondition"))) {
[10:21:11.453]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:11.453]                   ...future.conditions[[length(...future.conditions) + 
[10:21:11.453]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:11.453]                   if (TRUE && !signal) {
[10:21:11.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.453]                     {
[10:21:11.453]                       inherits <- base::inherits
[10:21:11.453]                       invokeRestart <- base::invokeRestart
[10:21:11.453]                       is.null <- base::is.null
[10:21:11.453]                       muffled <- FALSE
[10:21:11.453]                       if (inherits(cond, "message")) {
[10:21:11.453]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:11.453]                         if (muffled) 
[10:21:11.453]                           invokeRestart("muffleMessage")
[10:21:11.453]                       }
[10:21:11.453]                       else if (inherits(cond, "warning")) {
[10:21:11.453]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:11.453]                         if (muffled) 
[10:21:11.453]                           invokeRestart("muffleWarning")
[10:21:11.453]                       }
[10:21:11.453]                       else if (inherits(cond, "condition")) {
[10:21:11.453]                         if (!is.null(pattern)) {
[10:21:11.453]                           computeRestarts <- base::computeRestarts
[10:21:11.453]                           grepl <- base::grepl
[10:21:11.453]                           restarts <- computeRestarts(cond)
[10:21:11.453]                           for (restart in restarts) {
[10:21:11.453]                             name <- restart$name
[10:21:11.453]                             if (is.null(name)) 
[10:21:11.453]                               next
[10:21:11.453]                             if (!grepl(pattern, name)) 
[10:21:11.453]                               next
[10:21:11.453]                             invokeRestart(restart)
[10:21:11.453]                             muffled <- TRUE
[10:21:11.453]                             break
[10:21:11.453]                           }
[10:21:11.453]                         }
[10:21:11.453]                       }
[10:21:11.453]                       invisible(muffled)
[10:21:11.453]                     }
[10:21:11.453]                     muffleCondition(cond, pattern = "^muffle")
[10:21:11.453]                   }
[10:21:11.453]                 }
[10:21:11.453]                 else {
[10:21:11.453]                   if (TRUE) {
[10:21:11.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.453]                     {
[10:21:11.453]                       inherits <- base::inherits
[10:21:11.453]                       invokeRestart <- base::invokeRestart
[10:21:11.453]                       is.null <- base::is.null
[10:21:11.453]                       muffled <- FALSE
[10:21:11.453]                       if (inherits(cond, "message")) {
[10:21:11.453]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:11.453]                         if (muffled) 
[10:21:11.453]                           invokeRestart("muffleMessage")
[10:21:11.453]                       }
[10:21:11.453]                       else if (inherits(cond, "warning")) {
[10:21:11.453]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:11.453]                         if (muffled) 
[10:21:11.453]                           invokeRestart("muffleWarning")
[10:21:11.453]                       }
[10:21:11.453]                       else if (inherits(cond, "condition")) {
[10:21:11.453]                         if (!is.null(pattern)) {
[10:21:11.453]                           computeRestarts <- base::computeRestarts
[10:21:11.453]                           grepl <- base::grepl
[10:21:11.453]                           restarts <- computeRestarts(cond)
[10:21:11.453]                           for (restart in restarts) {
[10:21:11.453]                             name <- restart$name
[10:21:11.453]                             if (is.null(name)) 
[10:21:11.453]                               next
[10:21:11.453]                             if (!grepl(pattern, name)) 
[10:21:11.453]                               next
[10:21:11.453]                             invokeRestart(restart)
[10:21:11.453]                             muffled <- TRUE
[10:21:11.453]                             break
[10:21:11.453]                           }
[10:21:11.453]                         }
[10:21:11.453]                       }
[10:21:11.453]                       invisible(muffled)
[10:21:11.453]                     }
[10:21:11.453]                     muffleCondition(cond, pattern = "^muffle")
[10:21:11.453]                   }
[10:21:11.453]                 }
[10:21:11.453]             }
[10:21:11.453]         }))
[10:21:11.453]     }, error = function(ex) {
[10:21:11.453]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:11.453]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:11.453]                 ...future.rng), started = ...future.startTime, 
[10:21:11.453]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:11.453]             version = "1.8"), class = "FutureResult")
[10:21:11.453]     }, finally = {
[10:21:11.453]         if (!identical(...future.workdir, getwd())) 
[10:21:11.453]             setwd(...future.workdir)
[10:21:11.453]         {
[10:21:11.453]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:11.453]                 ...future.oldOptions$nwarnings <- NULL
[10:21:11.453]             }
[10:21:11.453]             base::options(...future.oldOptions)
[10:21:11.453]             if (.Platform$OS.type == "windows") {
[10:21:11.453]                 old_names <- names(...future.oldEnvVars)
[10:21:11.453]                 envs <- base::Sys.getenv()
[10:21:11.453]                 names <- names(envs)
[10:21:11.453]                 common <- intersect(names, old_names)
[10:21:11.453]                 added <- setdiff(names, old_names)
[10:21:11.453]                 removed <- setdiff(old_names, names)
[10:21:11.453]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:11.453]                   envs[common]]
[10:21:11.453]                 NAMES <- toupper(changed)
[10:21:11.453]                 args <- list()
[10:21:11.453]                 for (kk in seq_along(NAMES)) {
[10:21:11.453]                   name <- changed[[kk]]
[10:21:11.453]                   NAME <- NAMES[[kk]]
[10:21:11.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.453]                     next
[10:21:11.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:11.453]                 }
[10:21:11.453]                 NAMES <- toupper(added)
[10:21:11.453]                 for (kk in seq_along(NAMES)) {
[10:21:11.453]                   name <- added[[kk]]
[10:21:11.453]                   NAME <- NAMES[[kk]]
[10:21:11.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.453]                     next
[10:21:11.453]                   args[[name]] <- ""
[10:21:11.453]                 }
[10:21:11.453]                 NAMES <- toupper(removed)
[10:21:11.453]                 for (kk in seq_along(NAMES)) {
[10:21:11.453]                   name <- removed[[kk]]
[10:21:11.453]                   NAME <- NAMES[[kk]]
[10:21:11.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.453]                     next
[10:21:11.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:11.453]                 }
[10:21:11.453]                 if (length(args) > 0) 
[10:21:11.453]                   base::do.call(base::Sys.setenv, args = args)
[10:21:11.453]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:11.453]             }
[10:21:11.453]             else {
[10:21:11.453]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:11.453]             }
[10:21:11.453]             {
[10:21:11.453]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:11.453]                   0L) {
[10:21:11.453]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:11.453]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:11.453]                   base::options(opts)
[10:21:11.453]                 }
[10:21:11.453]                 {
[10:21:11.453]                   {
[10:21:11.453]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:11.453]                     NULL
[10:21:11.453]                   }
[10:21:11.453]                   options(future.plan = NULL)
[10:21:11.453]                   if (is.na(NA_character_)) 
[10:21:11.453]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:11.453]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:11.453]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:11.453]                     .init = FALSE)
[10:21:11.453]                 }
[10:21:11.453]             }
[10:21:11.453]         }
[10:21:11.453]     })
[10:21:11.453]     if (TRUE) {
[10:21:11.453]         base::sink(type = "output", split = FALSE)
[10:21:11.453]         if (TRUE) {
[10:21:11.453]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:11.453]         }
[10:21:11.453]         else {
[10:21:11.453]             ...future.result["stdout"] <- base::list(NULL)
[10:21:11.453]         }
[10:21:11.453]         base::close(...future.stdout)
[10:21:11.453]         ...future.stdout <- NULL
[10:21:11.453]     }
[10:21:11.453]     ...future.result$conditions <- ...future.conditions
[10:21:11.453]     ...future.result$finished <- base::Sys.time()
[10:21:11.453]     ...future.result
[10:21:11.453] }
[10:21:11.506] MultisessionFuture started
[10:21:11.506] result() for ClusterFuture ...
[10:21:11.507] receiveMessageFromWorker() for ClusterFuture ...
[10:21:11.507] - Validating connection of MultisessionFuture
[10:21:11.538] - received message: FutureResult
[10:21:11.538] - Received FutureResult
[10:21:11.538] - Erased future from FutureRegistry
[10:21:11.538] result() for ClusterFuture ...
[10:21:11.538] - result already collected: FutureResult
[10:21:11.538] result() for ClusterFuture ... done
[10:21:11.538] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:11.538] result() for ClusterFuture ... done
[10:21:11.538] result() for ClusterFuture ...
[10:21:11.539] - result already collected: FutureResult
[10:21:11.539] result() for ClusterFuture ... done
[10:21:11.539] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:21:11.540] plan(): nbrOfWorkers() = 2
** Future evaluation without globals
[10:21:11.541] getGlobalsAndPackages() ...
[10:21:11.541] Searching for globals...
[10:21:11.542] - globals found: [2] ‘{’, ‘<-’
[10:21:11.542] Searching for globals ... DONE
[10:21:11.542] Resolving globals: FALSE
[10:21:11.542] 
[10:21:11.542] 
[10:21:11.542] getGlobalsAndPackages() ... DONE
[10:21:11.543] run() for ‘Future’ ...
[10:21:11.543] - state: ‘created’
[10:21:11.543] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:11.557] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:11.557] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:11.557]   - Field: ‘node’
[10:21:11.557]   - Field: ‘label’
[10:21:11.557]   - Field: ‘local’
[10:21:11.557]   - Field: ‘owner’
[10:21:11.557]   - Field: ‘envir’
[10:21:11.557]   - Field: ‘workers’
[10:21:11.557]   - Field: ‘packages’
[10:21:11.557]   - Field: ‘gc’
[10:21:11.558]   - Field: ‘conditions’
[10:21:11.558]   - Field: ‘persistent’
[10:21:11.558]   - Field: ‘expr’
[10:21:11.558]   - Field: ‘uuid’
[10:21:11.558]   - Field: ‘seed’
[10:21:11.558]   - Field: ‘version’
[10:21:11.558]   - Field: ‘result’
[10:21:11.558]   - Field: ‘asynchronous’
[10:21:11.558]   - Field: ‘calls’
[10:21:11.558]   - Field: ‘globals’
[10:21:11.558]   - Field: ‘stdout’
[10:21:11.558]   - Field: ‘earlySignal’
[10:21:11.559]   - Field: ‘lazy’
[10:21:11.559]   - Field: ‘state’
[10:21:11.559] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:11.559] - Launch lazy future ...
[10:21:11.559] Packages needed by the future expression (n = 0): <none>
[10:21:11.559] Packages needed by future strategies (n = 0): <none>
[10:21:11.560] {
[10:21:11.560]     {
[10:21:11.560]         {
[10:21:11.560]             ...future.startTime <- base::Sys.time()
[10:21:11.560]             {
[10:21:11.560]                 {
[10:21:11.560]                   {
[10:21:11.560]                     {
[10:21:11.560]                       base::local({
[10:21:11.560]                         has_future <- base::requireNamespace("future", 
[10:21:11.560]                           quietly = TRUE)
[10:21:11.560]                         if (has_future) {
[10:21:11.560]                           ns <- base::getNamespace("future")
[10:21:11.560]                           version <- ns[[".package"]][["version"]]
[10:21:11.560]                           if (is.null(version)) 
[10:21:11.560]                             version <- utils::packageVersion("future")
[10:21:11.560]                         }
[10:21:11.560]                         else {
[10:21:11.560]                           version <- NULL
[10:21:11.560]                         }
[10:21:11.560]                         if (!has_future || version < "1.8.0") {
[10:21:11.560]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:11.560]                             "", base::R.version$version.string), 
[10:21:11.560]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:11.560]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:11.560]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:11.560]                               "release", "version")], collapse = " "), 
[10:21:11.560]                             hostname = base::Sys.info()[["nodename"]])
[10:21:11.560]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:11.560]                             info)
[10:21:11.560]                           info <- base::paste(info, collapse = "; ")
[10:21:11.560]                           if (!has_future) {
[10:21:11.560]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:11.560]                               info)
[10:21:11.560]                           }
[10:21:11.560]                           else {
[10:21:11.560]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:11.560]                               info, version)
[10:21:11.560]                           }
[10:21:11.560]                           base::stop(msg)
[10:21:11.560]                         }
[10:21:11.560]                       })
[10:21:11.560]                     }
[10:21:11.560]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:11.560]                     base::options(mc.cores = 1L)
[10:21:11.560]                   }
[10:21:11.560]                   ...future.strategy.old <- future::plan("list")
[10:21:11.560]                   options(future.plan = NULL)
[10:21:11.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:11.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:11.560]                 }
[10:21:11.560]                 ...future.workdir <- getwd()
[10:21:11.560]             }
[10:21:11.560]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:11.560]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:11.560]         }
[10:21:11.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:11.560]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:11.560]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:11.560]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:11.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:11.560]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:11.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:11.560]             base::names(...future.oldOptions))
[10:21:11.560]     }
[10:21:11.560]     if (FALSE) {
[10:21:11.560]     }
[10:21:11.560]     else {
[10:21:11.560]         if (TRUE) {
[10:21:11.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:11.560]                 open = "w")
[10:21:11.560]         }
[10:21:11.560]         else {
[10:21:11.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:11.560]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:11.560]         }
[10:21:11.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:11.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:11.560]             base::sink(type = "output", split = FALSE)
[10:21:11.560]             base::close(...future.stdout)
[10:21:11.560]         }, add = TRUE)
[10:21:11.560]     }
[10:21:11.560]     ...future.frame <- base::sys.nframe()
[10:21:11.560]     ...future.conditions <- base::list()
[10:21:11.560]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:11.560]     if (FALSE) {
[10:21:11.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:11.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:11.560]     }
[10:21:11.560]     ...future.result <- base::tryCatch({
[10:21:11.560]         base::withCallingHandlers({
[10:21:11.560]             ...future.value <- base::withVisible(base::local({
[10:21:11.560]                 ...future.makeSendCondition <- base::local({
[10:21:11.560]                   sendCondition <- NULL
[10:21:11.560]                   function(frame = 1L) {
[10:21:11.560]                     if (is.function(sendCondition)) 
[10:21:11.560]                       return(sendCondition)
[10:21:11.560]                     ns <- getNamespace("parallel")
[10:21:11.560]                     if (exists("sendData", mode = "function", 
[10:21:11.560]                       envir = ns)) {
[10:21:11.560]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:11.560]                         envir = ns)
[10:21:11.560]                       envir <- sys.frame(frame)
[10:21:11.560]                       master <- NULL
[10:21:11.560]                       while (!identical(envir, .GlobalEnv) && 
[10:21:11.560]                         !identical(envir, emptyenv())) {
[10:21:11.560]                         if (exists("master", mode = "list", envir = envir, 
[10:21:11.560]                           inherits = FALSE)) {
[10:21:11.560]                           master <- get("master", mode = "list", 
[10:21:11.560]                             envir = envir, inherits = FALSE)
[10:21:11.560]                           if (inherits(master, c("SOCKnode", 
[10:21:11.560]                             "SOCK0node"))) {
[10:21:11.560]                             sendCondition <<- function(cond) {
[10:21:11.560]                               data <- list(type = "VALUE", value = cond, 
[10:21:11.560]                                 success = TRUE)
[10:21:11.560]                               parallel_sendData(master, data)
[10:21:11.560]                             }
[10:21:11.560]                             return(sendCondition)
[10:21:11.560]                           }
[10:21:11.560]                         }
[10:21:11.560]                         frame <- frame + 1L
[10:21:11.560]                         envir <- sys.frame(frame)
[10:21:11.560]                       }
[10:21:11.560]                     }
[10:21:11.560]                     sendCondition <<- function(cond) NULL
[10:21:11.560]                   }
[10:21:11.560]                 })
[10:21:11.560]                 withCallingHandlers({
[10:21:11.560]                   {
[10:21:11.560]                     x <- 1
[10:21:11.560]                   }
[10:21:11.560]                 }, immediateCondition = function(cond) {
[10:21:11.560]                   sendCondition <- ...future.makeSendCondition()
[10:21:11.560]                   sendCondition(cond)
[10:21:11.560]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.560]                   {
[10:21:11.560]                     inherits <- base::inherits
[10:21:11.560]                     invokeRestart <- base::invokeRestart
[10:21:11.560]                     is.null <- base::is.null
[10:21:11.560]                     muffled <- FALSE
[10:21:11.560]                     if (inherits(cond, "message")) {
[10:21:11.560]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:11.560]                       if (muffled) 
[10:21:11.560]                         invokeRestart("muffleMessage")
[10:21:11.560]                     }
[10:21:11.560]                     else if (inherits(cond, "warning")) {
[10:21:11.560]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:11.560]                       if (muffled) 
[10:21:11.560]                         invokeRestart("muffleWarning")
[10:21:11.560]                     }
[10:21:11.560]                     else if (inherits(cond, "condition")) {
[10:21:11.560]                       if (!is.null(pattern)) {
[10:21:11.560]                         computeRestarts <- base::computeRestarts
[10:21:11.560]                         grepl <- base::grepl
[10:21:11.560]                         restarts <- computeRestarts(cond)
[10:21:11.560]                         for (restart in restarts) {
[10:21:11.560]                           name <- restart$name
[10:21:11.560]                           if (is.null(name)) 
[10:21:11.560]                             next
[10:21:11.560]                           if (!grepl(pattern, name)) 
[10:21:11.560]                             next
[10:21:11.560]                           invokeRestart(restart)
[10:21:11.560]                           muffled <- TRUE
[10:21:11.560]                           break
[10:21:11.560]                         }
[10:21:11.560]                       }
[10:21:11.560]                     }
[10:21:11.560]                     invisible(muffled)
[10:21:11.560]                   }
[10:21:11.560]                   muffleCondition(cond)
[10:21:11.560]                 })
[10:21:11.560]             }))
[10:21:11.560]             future::FutureResult(value = ...future.value$value, 
[10:21:11.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:11.560]                   ...future.rng), globalenv = if (FALSE) 
[10:21:11.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:11.560]                     ...future.globalenv.names))
[10:21:11.560]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:11.560]         }, condition = base::local({
[10:21:11.560]             c <- base::c
[10:21:11.560]             inherits <- base::inherits
[10:21:11.560]             invokeRestart <- base::invokeRestart
[10:21:11.560]             length <- base::length
[10:21:11.560]             list <- base::list
[10:21:11.560]             seq.int <- base::seq.int
[10:21:11.560]             signalCondition <- base::signalCondition
[10:21:11.560]             sys.calls <- base::sys.calls
[10:21:11.560]             `[[` <- base::`[[`
[10:21:11.560]             `+` <- base::`+`
[10:21:11.560]             `<<-` <- base::`<<-`
[10:21:11.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:11.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:11.560]                   3L)]
[10:21:11.560]             }
[10:21:11.560]             function(cond) {
[10:21:11.560]                 is_error <- inherits(cond, "error")
[10:21:11.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:11.560]                   NULL)
[10:21:11.560]                 if (is_error) {
[10:21:11.560]                   sessionInformation <- function() {
[10:21:11.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:11.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:11.560]                       search = base::search(), system = base::Sys.info())
[10:21:11.560]                   }
[10:21:11.560]                   ...future.conditions[[length(...future.conditions) + 
[10:21:11.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:11.560]                     cond$call), session = sessionInformation(), 
[10:21:11.560]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:11.560]                   signalCondition(cond)
[10:21:11.560]                 }
[10:21:11.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:11.560]                 "immediateCondition"))) {
[10:21:11.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:11.560]                   ...future.conditions[[length(...future.conditions) + 
[10:21:11.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:11.560]                   if (TRUE && !signal) {
[10:21:11.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.560]                     {
[10:21:11.560]                       inherits <- base::inherits
[10:21:11.560]                       invokeRestart <- base::invokeRestart
[10:21:11.560]                       is.null <- base::is.null
[10:21:11.560]                       muffled <- FALSE
[10:21:11.560]                       if (inherits(cond, "message")) {
[10:21:11.560]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:11.560]                         if (muffled) 
[10:21:11.560]                           invokeRestart("muffleMessage")
[10:21:11.560]                       }
[10:21:11.560]                       else if (inherits(cond, "warning")) {
[10:21:11.560]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:11.560]                         if (muffled) 
[10:21:11.560]                           invokeRestart("muffleWarning")
[10:21:11.560]                       }
[10:21:11.560]                       else if (inherits(cond, "condition")) {
[10:21:11.560]                         if (!is.null(pattern)) {
[10:21:11.560]                           computeRestarts <- base::computeRestarts
[10:21:11.560]                           grepl <- base::grepl
[10:21:11.560]                           restarts <- computeRestarts(cond)
[10:21:11.560]                           for (restart in restarts) {
[10:21:11.560]                             name <- restart$name
[10:21:11.560]                             if (is.null(name)) 
[10:21:11.560]                               next
[10:21:11.560]                             if (!grepl(pattern, name)) 
[10:21:11.560]                               next
[10:21:11.560]                             invokeRestart(restart)
[10:21:11.560]                             muffled <- TRUE
[10:21:11.560]                             break
[10:21:11.560]                           }
[10:21:11.560]                         }
[10:21:11.560]                       }
[10:21:11.560]                       invisible(muffled)
[10:21:11.560]                     }
[10:21:11.560]                     muffleCondition(cond, pattern = "^muffle")
[10:21:11.560]                   }
[10:21:11.560]                 }
[10:21:11.560]                 else {
[10:21:11.560]                   if (TRUE) {
[10:21:11.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.560]                     {
[10:21:11.560]                       inherits <- base::inherits
[10:21:11.560]                       invokeRestart <- base::invokeRestart
[10:21:11.560]                       is.null <- base::is.null
[10:21:11.560]                       muffled <- FALSE
[10:21:11.560]                       if (inherits(cond, "message")) {
[10:21:11.560]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:11.560]                         if (muffled) 
[10:21:11.560]                           invokeRestart("muffleMessage")
[10:21:11.560]                       }
[10:21:11.560]                       else if (inherits(cond, "warning")) {
[10:21:11.560]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:11.560]                         if (muffled) 
[10:21:11.560]                           invokeRestart("muffleWarning")
[10:21:11.560]                       }
[10:21:11.560]                       else if (inherits(cond, "condition")) {
[10:21:11.560]                         if (!is.null(pattern)) {
[10:21:11.560]                           computeRestarts <- base::computeRestarts
[10:21:11.560]                           grepl <- base::grepl
[10:21:11.560]                           restarts <- computeRestarts(cond)
[10:21:11.560]                           for (restart in restarts) {
[10:21:11.560]                             name <- restart$name
[10:21:11.560]                             if (is.null(name)) 
[10:21:11.560]                               next
[10:21:11.560]                             if (!grepl(pattern, name)) 
[10:21:11.560]                               next
[10:21:11.560]                             invokeRestart(restart)
[10:21:11.560]                             muffled <- TRUE
[10:21:11.560]                             break
[10:21:11.560]                           }
[10:21:11.560]                         }
[10:21:11.560]                       }
[10:21:11.560]                       invisible(muffled)
[10:21:11.560]                     }
[10:21:11.560]                     muffleCondition(cond, pattern = "^muffle")
[10:21:11.560]                   }
[10:21:11.560]                 }
[10:21:11.560]             }
[10:21:11.560]         }))
[10:21:11.560]     }, error = function(ex) {
[10:21:11.560]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:11.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:11.560]                 ...future.rng), started = ...future.startTime, 
[10:21:11.560]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:11.560]             version = "1.8"), class = "FutureResult")
[10:21:11.560]     }, finally = {
[10:21:11.560]         if (!identical(...future.workdir, getwd())) 
[10:21:11.560]             setwd(...future.workdir)
[10:21:11.560]         {
[10:21:11.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:11.560]                 ...future.oldOptions$nwarnings <- NULL
[10:21:11.560]             }
[10:21:11.560]             base::options(...future.oldOptions)
[10:21:11.560]             if (.Platform$OS.type == "windows") {
[10:21:11.560]                 old_names <- names(...future.oldEnvVars)
[10:21:11.560]                 envs <- base::Sys.getenv()
[10:21:11.560]                 names <- names(envs)
[10:21:11.560]                 common <- intersect(names, old_names)
[10:21:11.560]                 added <- setdiff(names, old_names)
[10:21:11.560]                 removed <- setdiff(old_names, names)
[10:21:11.560]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:11.560]                   envs[common]]
[10:21:11.560]                 NAMES <- toupper(changed)
[10:21:11.560]                 args <- list()
[10:21:11.560]                 for (kk in seq_along(NAMES)) {
[10:21:11.560]                   name <- changed[[kk]]
[10:21:11.560]                   NAME <- NAMES[[kk]]
[10:21:11.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.560]                     next
[10:21:11.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:11.560]                 }
[10:21:11.560]                 NAMES <- toupper(added)
[10:21:11.560]                 for (kk in seq_along(NAMES)) {
[10:21:11.560]                   name <- added[[kk]]
[10:21:11.560]                   NAME <- NAMES[[kk]]
[10:21:11.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.560]                     next
[10:21:11.560]                   args[[name]] <- ""
[10:21:11.560]                 }
[10:21:11.560]                 NAMES <- toupper(removed)
[10:21:11.560]                 for (kk in seq_along(NAMES)) {
[10:21:11.560]                   name <- removed[[kk]]
[10:21:11.560]                   NAME <- NAMES[[kk]]
[10:21:11.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.560]                     next
[10:21:11.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:11.560]                 }
[10:21:11.560]                 if (length(args) > 0) 
[10:21:11.560]                   base::do.call(base::Sys.setenv, args = args)
[10:21:11.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:11.560]             }
[10:21:11.560]             else {
[10:21:11.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:11.560]             }
[10:21:11.560]             {
[10:21:11.560]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:11.560]                   0L) {
[10:21:11.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:11.560]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:11.560]                   base::options(opts)
[10:21:11.560]                 }
[10:21:11.560]                 {
[10:21:11.560]                   {
[10:21:11.560]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:11.560]                     NULL
[10:21:11.560]                   }
[10:21:11.560]                   options(future.plan = NULL)
[10:21:11.560]                   if (is.na(NA_character_)) 
[10:21:11.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:11.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:11.560]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:11.560]                     .init = FALSE)
[10:21:11.560]                 }
[10:21:11.560]             }
[10:21:11.560]         }
[10:21:11.560]     })
[10:21:11.560]     if (TRUE) {
[10:21:11.560]         base::sink(type = "output", split = FALSE)
[10:21:11.560]         if (TRUE) {
[10:21:11.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:11.560]         }
[10:21:11.560]         else {
[10:21:11.560]             ...future.result["stdout"] <- base::list(NULL)
[10:21:11.560]         }
[10:21:11.560]         base::close(...future.stdout)
[10:21:11.560]         ...future.stdout <- NULL
[10:21:11.560]     }
[10:21:11.560]     ...future.result$conditions <- ...future.conditions
[10:21:11.560]     ...future.result$finished <- base::Sys.time()
[10:21:11.560]     ...future.result
[10:21:11.560] }
[10:21:11.563] MultisessionFuture started
[10:21:11.563] - Launch lazy future ... done
[10:21:11.563] run() for ‘MultisessionFuture’ ... done
[10:21:11.563] result() for ClusterFuture ...
[10:21:11.563] receiveMessageFromWorker() for ClusterFuture ...
[10:21:11.563] - Validating connection of MultisessionFuture
[10:21:11.605] - received message: FutureResult
[10:21:11.605] - Received FutureResult
[10:21:11.605] - Erased future from FutureRegistry
[10:21:11.605] result() for ClusterFuture ...
[10:21:11.605] - result already collected: FutureResult
[10:21:11.606] result() for ClusterFuture ... done
[10:21:11.606] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:11.606] result() for ClusterFuture ... done
[10:21:11.606] result() for ClusterFuture ...
[10:21:11.606] - result already collected: FutureResult
[10:21:11.606] result() for ClusterFuture ... done
** Future evaluation with globals
[10:21:11.606] getGlobalsAndPackages() ...
[10:21:11.606] Searching for globals...
[10:21:11.607] - globals found: [3] ‘{’, ‘<-’, ‘a’
[10:21:11.608] Searching for globals ... DONE
[10:21:11.608] Resolving globals: FALSE
[10:21:11.608] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:11.608] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:11.608] - globals: [1] ‘a’
[10:21:11.609] 
[10:21:11.609] getGlobalsAndPackages() ... DONE
[10:21:11.609] run() for ‘Future’ ...
[10:21:11.609] - state: ‘created’
[10:21:11.609] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:11.624] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:11.624] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:11.624]   - Field: ‘node’
[10:21:11.625]   - Field: ‘label’
[10:21:11.625]   - Field: ‘local’
[10:21:11.625]   - Field: ‘owner’
[10:21:11.625]   - Field: ‘envir’
[10:21:11.625]   - Field: ‘workers’
[10:21:11.625]   - Field: ‘packages’
[10:21:11.625]   - Field: ‘gc’
[10:21:11.625]   - Field: ‘conditions’
[10:21:11.625]   - Field: ‘persistent’
[10:21:11.625]   - Field: ‘expr’
[10:21:11.626]   - Field: ‘uuid’
[10:21:11.626]   - Field: ‘seed’
[10:21:11.626]   - Field: ‘version’
[10:21:11.626]   - Field: ‘result’
[10:21:11.626]   - Field: ‘asynchronous’
[10:21:11.626]   - Field: ‘calls’
[10:21:11.626]   - Field: ‘globals’
[10:21:11.626]   - Field: ‘stdout’
[10:21:11.626]   - Field: ‘earlySignal’
[10:21:11.627]   - Field: ‘lazy’
[10:21:11.627]   - Field: ‘state’
[10:21:11.627] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:11.627] - Launch lazy future ...
[10:21:11.627] Packages needed by the future expression (n = 0): <none>
[10:21:11.627] Packages needed by future strategies (n = 0): <none>
[10:21:11.628] {
[10:21:11.628]     {
[10:21:11.628]         {
[10:21:11.628]             ...future.startTime <- base::Sys.time()
[10:21:11.628]             {
[10:21:11.628]                 {
[10:21:11.628]                   {
[10:21:11.628]                     {
[10:21:11.628]                       base::local({
[10:21:11.628]                         has_future <- base::requireNamespace("future", 
[10:21:11.628]                           quietly = TRUE)
[10:21:11.628]                         if (has_future) {
[10:21:11.628]                           ns <- base::getNamespace("future")
[10:21:11.628]                           version <- ns[[".package"]][["version"]]
[10:21:11.628]                           if (is.null(version)) 
[10:21:11.628]                             version <- utils::packageVersion("future")
[10:21:11.628]                         }
[10:21:11.628]                         else {
[10:21:11.628]                           version <- NULL
[10:21:11.628]                         }
[10:21:11.628]                         if (!has_future || version < "1.8.0") {
[10:21:11.628]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:11.628]                             "", base::R.version$version.string), 
[10:21:11.628]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:11.628]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:11.628]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:11.628]                               "release", "version")], collapse = " "), 
[10:21:11.628]                             hostname = base::Sys.info()[["nodename"]])
[10:21:11.628]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:11.628]                             info)
[10:21:11.628]                           info <- base::paste(info, collapse = "; ")
[10:21:11.628]                           if (!has_future) {
[10:21:11.628]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:11.628]                               info)
[10:21:11.628]                           }
[10:21:11.628]                           else {
[10:21:11.628]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:11.628]                               info, version)
[10:21:11.628]                           }
[10:21:11.628]                           base::stop(msg)
[10:21:11.628]                         }
[10:21:11.628]                       })
[10:21:11.628]                     }
[10:21:11.628]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:11.628]                     base::options(mc.cores = 1L)
[10:21:11.628]                   }
[10:21:11.628]                   ...future.strategy.old <- future::plan("list")
[10:21:11.628]                   options(future.plan = NULL)
[10:21:11.628]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:11.628]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:11.628]                 }
[10:21:11.628]                 ...future.workdir <- getwd()
[10:21:11.628]             }
[10:21:11.628]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:11.628]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:11.628]         }
[10:21:11.628]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:11.628]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:11.628]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:11.628]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:11.628]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:11.628]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:11.628]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:11.628]             base::names(...future.oldOptions))
[10:21:11.628]     }
[10:21:11.628]     if (FALSE) {
[10:21:11.628]     }
[10:21:11.628]     else {
[10:21:11.628]         if (TRUE) {
[10:21:11.628]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:11.628]                 open = "w")
[10:21:11.628]         }
[10:21:11.628]         else {
[10:21:11.628]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:11.628]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:11.628]         }
[10:21:11.628]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:11.628]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:11.628]             base::sink(type = "output", split = FALSE)
[10:21:11.628]             base::close(...future.stdout)
[10:21:11.628]         }, add = TRUE)
[10:21:11.628]     }
[10:21:11.628]     ...future.frame <- base::sys.nframe()
[10:21:11.628]     ...future.conditions <- base::list()
[10:21:11.628]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:11.628]     if (FALSE) {
[10:21:11.628]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:11.628]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:11.628]     }
[10:21:11.628]     ...future.result <- base::tryCatch({
[10:21:11.628]         base::withCallingHandlers({
[10:21:11.628]             ...future.value <- base::withVisible(base::local({
[10:21:11.628]                 ...future.makeSendCondition <- base::local({
[10:21:11.628]                   sendCondition <- NULL
[10:21:11.628]                   function(frame = 1L) {
[10:21:11.628]                     if (is.function(sendCondition)) 
[10:21:11.628]                       return(sendCondition)
[10:21:11.628]                     ns <- getNamespace("parallel")
[10:21:11.628]                     if (exists("sendData", mode = "function", 
[10:21:11.628]                       envir = ns)) {
[10:21:11.628]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:11.628]                         envir = ns)
[10:21:11.628]                       envir <- sys.frame(frame)
[10:21:11.628]                       master <- NULL
[10:21:11.628]                       while (!identical(envir, .GlobalEnv) && 
[10:21:11.628]                         !identical(envir, emptyenv())) {
[10:21:11.628]                         if (exists("master", mode = "list", envir = envir, 
[10:21:11.628]                           inherits = FALSE)) {
[10:21:11.628]                           master <- get("master", mode = "list", 
[10:21:11.628]                             envir = envir, inherits = FALSE)
[10:21:11.628]                           if (inherits(master, c("SOCKnode", 
[10:21:11.628]                             "SOCK0node"))) {
[10:21:11.628]                             sendCondition <<- function(cond) {
[10:21:11.628]                               data <- list(type = "VALUE", value = cond, 
[10:21:11.628]                                 success = TRUE)
[10:21:11.628]                               parallel_sendData(master, data)
[10:21:11.628]                             }
[10:21:11.628]                             return(sendCondition)
[10:21:11.628]                           }
[10:21:11.628]                         }
[10:21:11.628]                         frame <- frame + 1L
[10:21:11.628]                         envir <- sys.frame(frame)
[10:21:11.628]                       }
[10:21:11.628]                     }
[10:21:11.628]                     sendCondition <<- function(cond) NULL
[10:21:11.628]                   }
[10:21:11.628]                 })
[10:21:11.628]                 withCallingHandlers({
[10:21:11.628]                   {
[10:21:11.628]                     x <- a
[10:21:11.628]                   }
[10:21:11.628]                 }, immediateCondition = function(cond) {
[10:21:11.628]                   sendCondition <- ...future.makeSendCondition()
[10:21:11.628]                   sendCondition(cond)
[10:21:11.628]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.628]                   {
[10:21:11.628]                     inherits <- base::inherits
[10:21:11.628]                     invokeRestart <- base::invokeRestart
[10:21:11.628]                     is.null <- base::is.null
[10:21:11.628]                     muffled <- FALSE
[10:21:11.628]                     if (inherits(cond, "message")) {
[10:21:11.628]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:11.628]                       if (muffled) 
[10:21:11.628]                         invokeRestart("muffleMessage")
[10:21:11.628]                     }
[10:21:11.628]                     else if (inherits(cond, "warning")) {
[10:21:11.628]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:11.628]                       if (muffled) 
[10:21:11.628]                         invokeRestart("muffleWarning")
[10:21:11.628]                     }
[10:21:11.628]                     else if (inherits(cond, "condition")) {
[10:21:11.628]                       if (!is.null(pattern)) {
[10:21:11.628]                         computeRestarts <- base::computeRestarts
[10:21:11.628]                         grepl <- base::grepl
[10:21:11.628]                         restarts <- computeRestarts(cond)
[10:21:11.628]                         for (restart in restarts) {
[10:21:11.628]                           name <- restart$name
[10:21:11.628]                           if (is.null(name)) 
[10:21:11.628]                             next
[10:21:11.628]                           if (!grepl(pattern, name)) 
[10:21:11.628]                             next
[10:21:11.628]                           invokeRestart(restart)
[10:21:11.628]                           muffled <- TRUE
[10:21:11.628]                           break
[10:21:11.628]                         }
[10:21:11.628]                       }
[10:21:11.628]                     }
[10:21:11.628]                     invisible(muffled)
[10:21:11.628]                   }
[10:21:11.628]                   muffleCondition(cond)
[10:21:11.628]                 })
[10:21:11.628]             }))
[10:21:11.628]             future::FutureResult(value = ...future.value$value, 
[10:21:11.628]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:11.628]                   ...future.rng), globalenv = if (FALSE) 
[10:21:11.628]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:11.628]                     ...future.globalenv.names))
[10:21:11.628]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:11.628]         }, condition = base::local({
[10:21:11.628]             c <- base::c
[10:21:11.628]             inherits <- base::inherits
[10:21:11.628]             invokeRestart <- base::invokeRestart
[10:21:11.628]             length <- base::length
[10:21:11.628]             list <- base::list
[10:21:11.628]             seq.int <- base::seq.int
[10:21:11.628]             signalCondition <- base::signalCondition
[10:21:11.628]             sys.calls <- base::sys.calls
[10:21:11.628]             `[[` <- base::`[[`
[10:21:11.628]             `+` <- base::`+`
[10:21:11.628]             `<<-` <- base::`<<-`
[10:21:11.628]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:11.628]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:11.628]                   3L)]
[10:21:11.628]             }
[10:21:11.628]             function(cond) {
[10:21:11.628]                 is_error <- inherits(cond, "error")
[10:21:11.628]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:11.628]                   NULL)
[10:21:11.628]                 if (is_error) {
[10:21:11.628]                   sessionInformation <- function() {
[10:21:11.628]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:11.628]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:11.628]                       search = base::search(), system = base::Sys.info())
[10:21:11.628]                   }
[10:21:11.628]                   ...future.conditions[[length(...future.conditions) + 
[10:21:11.628]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:11.628]                     cond$call), session = sessionInformation(), 
[10:21:11.628]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:11.628]                   signalCondition(cond)
[10:21:11.628]                 }
[10:21:11.628]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:11.628]                 "immediateCondition"))) {
[10:21:11.628]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:11.628]                   ...future.conditions[[length(...future.conditions) + 
[10:21:11.628]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:11.628]                   if (TRUE && !signal) {
[10:21:11.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.628]                     {
[10:21:11.628]                       inherits <- base::inherits
[10:21:11.628]                       invokeRestart <- base::invokeRestart
[10:21:11.628]                       is.null <- base::is.null
[10:21:11.628]                       muffled <- FALSE
[10:21:11.628]                       if (inherits(cond, "message")) {
[10:21:11.628]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:11.628]                         if (muffled) 
[10:21:11.628]                           invokeRestart("muffleMessage")
[10:21:11.628]                       }
[10:21:11.628]                       else if (inherits(cond, "warning")) {
[10:21:11.628]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:11.628]                         if (muffled) 
[10:21:11.628]                           invokeRestart("muffleWarning")
[10:21:11.628]                       }
[10:21:11.628]                       else if (inherits(cond, "condition")) {
[10:21:11.628]                         if (!is.null(pattern)) {
[10:21:11.628]                           computeRestarts <- base::computeRestarts
[10:21:11.628]                           grepl <- base::grepl
[10:21:11.628]                           restarts <- computeRestarts(cond)
[10:21:11.628]                           for (restart in restarts) {
[10:21:11.628]                             name <- restart$name
[10:21:11.628]                             if (is.null(name)) 
[10:21:11.628]                               next
[10:21:11.628]                             if (!grepl(pattern, name)) 
[10:21:11.628]                               next
[10:21:11.628]                             invokeRestart(restart)
[10:21:11.628]                             muffled <- TRUE
[10:21:11.628]                             break
[10:21:11.628]                           }
[10:21:11.628]                         }
[10:21:11.628]                       }
[10:21:11.628]                       invisible(muffled)
[10:21:11.628]                     }
[10:21:11.628]                     muffleCondition(cond, pattern = "^muffle")
[10:21:11.628]                   }
[10:21:11.628]                 }
[10:21:11.628]                 else {
[10:21:11.628]                   if (TRUE) {
[10:21:11.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.628]                     {
[10:21:11.628]                       inherits <- base::inherits
[10:21:11.628]                       invokeRestart <- base::invokeRestart
[10:21:11.628]                       is.null <- base::is.null
[10:21:11.628]                       muffled <- FALSE
[10:21:11.628]                       if (inherits(cond, "message")) {
[10:21:11.628]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:11.628]                         if (muffled) 
[10:21:11.628]                           invokeRestart("muffleMessage")
[10:21:11.628]                       }
[10:21:11.628]                       else if (inherits(cond, "warning")) {
[10:21:11.628]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:11.628]                         if (muffled) 
[10:21:11.628]                           invokeRestart("muffleWarning")
[10:21:11.628]                       }
[10:21:11.628]                       else if (inherits(cond, "condition")) {
[10:21:11.628]                         if (!is.null(pattern)) {
[10:21:11.628]                           computeRestarts <- base::computeRestarts
[10:21:11.628]                           grepl <- base::grepl
[10:21:11.628]                           restarts <- computeRestarts(cond)
[10:21:11.628]                           for (restart in restarts) {
[10:21:11.628]                             name <- restart$name
[10:21:11.628]                             if (is.null(name)) 
[10:21:11.628]                               next
[10:21:11.628]                             if (!grepl(pattern, name)) 
[10:21:11.628]                               next
[10:21:11.628]                             invokeRestart(restart)
[10:21:11.628]                             muffled <- TRUE
[10:21:11.628]                             break
[10:21:11.628]                           }
[10:21:11.628]                         }
[10:21:11.628]                       }
[10:21:11.628]                       invisible(muffled)
[10:21:11.628]                     }
[10:21:11.628]                     muffleCondition(cond, pattern = "^muffle")
[10:21:11.628]                   }
[10:21:11.628]                 }
[10:21:11.628]             }
[10:21:11.628]         }))
[10:21:11.628]     }, error = function(ex) {
[10:21:11.628]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:11.628]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:11.628]                 ...future.rng), started = ...future.startTime, 
[10:21:11.628]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:11.628]             version = "1.8"), class = "FutureResult")
[10:21:11.628]     }, finally = {
[10:21:11.628]         if (!identical(...future.workdir, getwd())) 
[10:21:11.628]             setwd(...future.workdir)
[10:21:11.628]         {
[10:21:11.628]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:11.628]                 ...future.oldOptions$nwarnings <- NULL
[10:21:11.628]             }
[10:21:11.628]             base::options(...future.oldOptions)
[10:21:11.628]             if (.Platform$OS.type == "windows") {
[10:21:11.628]                 old_names <- names(...future.oldEnvVars)
[10:21:11.628]                 envs <- base::Sys.getenv()
[10:21:11.628]                 names <- names(envs)
[10:21:11.628]                 common <- intersect(names, old_names)
[10:21:11.628]                 added <- setdiff(names, old_names)
[10:21:11.628]                 removed <- setdiff(old_names, names)
[10:21:11.628]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:11.628]                   envs[common]]
[10:21:11.628]                 NAMES <- toupper(changed)
[10:21:11.628]                 args <- list()
[10:21:11.628]                 for (kk in seq_along(NAMES)) {
[10:21:11.628]                   name <- changed[[kk]]
[10:21:11.628]                   NAME <- NAMES[[kk]]
[10:21:11.628]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.628]                     next
[10:21:11.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:11.628]                 }
[10:21:11.628]                 NAMES <- toupper(added)
[10:21:11.628]                 for (kk in seq_along(NAMES)) {
[10:21:11.628]                   name <- added[[kk]]
[10:21:11.628]                   NAME <- NAMES[[kk]]
[10:21:11.628]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.628]                     next
[10:21:11.628]                   args[[name]] <- ""
[10:21:11.628]                 }
[10:21:11.628]                 NAMES <- toupper(removed)
[10:21:11.628]                 for (kk in seq_along(NAMES)) {
[10:21:11.628]                   name <- removed[[kk]]
[10:21:11.628]                   NAME <- NAMES[[kk]]
[10:21:11.628]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.628]                     next
[10:21:11.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:11.628]                 }
[10:21:11.628]                 if (length(args) > 0) 
[10:21:11.628]                   base::do.call(base::Sys.setenv, args = args)
[10:21:11.628]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:11.628]             }
[10:21:11.628]             else {
[10:21:11.628]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:11.628]             }
[10:21:11.628]             {
[10:21:11.628]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:11.628]                   0L) {
[10:21:11.628]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:11.628]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:11.628]                   base::options(opts)
[10:21:11.628]                 }
[10:21:11.628]                 {
[10:21:11.628]                   {
[10:21:11.628]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:11.628]                     NULL
[10:21:11.628]                   }
[10:21:11.628]                   options(future.plan = NULL)
[10:21:11.628]                   if (is.na(NA_character_)) 
[10:21:11.628]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:11.628]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:11.628]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:11.628]                     .init = FALSE)
[10:21:11.628]                 }
[10:21:11.628]             }
[10:21:11.628]         }
[10:21:11.628]     })
[10:21:11.628]     if (TRUE) {
[10:21:11.628]         base::sink(type = "output", split = FALSE)
[10:21:11.628]         if (TRUE) {
[10:21:11.628]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:11.628]         }
[10:21:11.628]         else {
[10:21:11.628]             ...future.result["stdout"] <- base::list(NULL)
[10:21:11.628]         }
[10:21:11.628]         base::close(...future.stdout)
[10:21:11.628]         ...future.stdout <- NULL
[10:21:11.628]     }
[10:21:11.628]     ...future.result$conditions <- ...future.conditions
[10:21:11.628]     ...future.result$finished <- base::Sys.time()
[10:21:11.628]     ...future.result
[10:21:11.628] }
[10:21:11.631] Exporting 1 global objects (346 bytes) to cluster node #1 ...
[10:21:11.631] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[10:21:11.635] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[10:21:11.635] Exporting 1 global objects (346 bytes) to cluster node #1 ... DONE
[10:21:11.635] MultisessionFuture started
[10:21:11.636] - Launch lazy future ... done
[10:21:11.636] run() for ‘MultisessionFuture’ ... done
[10:21:11.636] result() for ClusterFuture ...
[10:21:11.636] receiveMessageFromWorker() for ClusterFuture ...
[10:21:11.636] - Validating connection of MultisessionFuture
[10:21:11.677] - received message: FutureResult
[10:21:11.677] - Received FutureResult
[10:21:11.677] - Erased future from FutureRegistry
[10:21:11.677] result() for ClusterFuture ...
[10:21:11.677] - result already collected: FutureResult
[10:21:11.677] result() for ClusterFuture ... done
[10:21:11.678] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:11.678] result() for ClusterFuture ... done
[10:21:11.678] result() for ClusterFuture ...
[10:21:11.678] - result already collected: FutureResult
[10:21:11.678] result() for ClusterFuture ... done
** Future evaluation with errors
[10:21:11.679] getGlobalsAndPackages() ...
[10:21:11.679] Searching for globals...
[10:21:11.680] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[10:21:11.681] Searching for globals ... DONE
[10:21:11.681] Resolving globals: FALSE
[10:21:11.681] 
[10:21:11.681] 
[10:21:11.681] getGlobalsAndPackages() ... DONE
[10:21:11.682] run() for ‘Future’ ...
[10:21:11.682] - state: ‘created’
[10:21:11.682] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:11.696] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:11.697] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:11.697]   - Field: ‘node’
[10:21:11.697]   - Field: ‘label’
[10:21:11.697]   - Field: ‘local’
[10:21:11.697]   - Field: ‘owner’
[10:21:11.697]   - Field: ‘envir’
[10:21:11.697]   - Field: ‘workers’
[10:21:11.697]   - Field: ‘packages’
[10:21:11.697]   - Field: ‘gc’
[10:21:11.697]   - Field: ‘conditions’
[10:21:11.697]   - Field: ‘persistent’
[10:21:11.698]   - Field: ‘expr’
[10:21:11.698]   - Field: ‘uuid’
[10:21:11.698]   - Field: ‘seed’
[10:21:11.698]   - Field: ‘version’
[10:21:11.698]   - Field: ‘result’
[10:21:11.698]   - Field: ‘asynchronous’
[10:21:11.698]   - Field: ‘calls’
[10:21:11.698]   - Field: ‘globals’
[10:21:11.698]   - Field: ‘stdout’
[10:21:11.699]   - Field: ‘earlySignal’
[10:21:11.699]   - Field: ‘lazy’
[10:21:11.699]   - Field: ‘state’
[10:21:11.699] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:11.699] - Launch lazy future ...
[10:21:11.699] Packages needed by the future expression (n = 0): <none>
[10:21:11.699] Packages needed by future strategies (n = 0): <none>
[10:21:11.700] {
[10:21:11.700]     {
[10:21:11.700]         {
[10:21:11.700]             ...future.startTime <- base::Sys.time()
[10:21:11.700]             {
[10:21:11.700]                 {
[10:21:11.700]                   {
[10:21:11.700]                     {
[10:21:11.700]                       base::local({
[10:21:11.700]                         has_future <- base::requireNamespace("future", 
[10:21:11.700]                           quietly = TRUE)
[10:21:11.700]                         if (has_future) {
[10:21:11.700]                           ns <- base::getNamespace("future")
[10:21:11.700]                           version <- ns[[".package"]][["version"]]
[10:21:11.700]                           if (is.null(version)) 
[10:21:11.700]                             version <- utils::packageVersion("future")
[10:21:11.700]                         }
[10:21:11.700]                         else {
[10:21:11.700]                           version <- NULL
[10:21:11.700]                         }
[10:21:11.700]                         if (!has_future || version < "1.8.0") {
[10:21:11.700]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:11.700]                             "", base::R.version$version.string), 
[10:21:11.700]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:11.700]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:11.700]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:11.700]                               "release", "version")], collapse = " "), 
[10:21:11.700]                             hostname = base::Sys.info()[["nodename"]])
[10:21:11.700]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:11.700]                             info)
[10:21:11.700]                           info <- base::paste(info, collapse = "; ")
[10:21:11.700]                           if (!has_future) {
[10:21:11.700]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:11.700]                               info)
[10:21:11.700]                           }
[10:21:11.700]                           else {
[10:21:11.700]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:11.700]                               info, version)
[10:21:11.700]                           }
[10:21:11.700]                           base::stop(msg)
[10:21:11.700]                         }
[10:21:11.700]                       })
[10:21:11.700]                     }
[10:21:11.700]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:11.700]                     base::options(mc.cores = 1L)
[10:21:11.700]                   }
[10:21:11.700]                   ...future.strategy.old <- future::plan("list")
[10:21:11.700]                   options(future.plan = NULL)
[10:21:11.700]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:11.700]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:11.700]                 }
[10:21:11.700]                 ...future.workdir <- getwd()
[10:21:11.700]             }
[10:21:11.700]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:11.700]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:11.700]         }
[10:21:11.700]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:11.700]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:11.700]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:11.700]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:11.700]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:11.700]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:11.700]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:11.700]             base::names(...future.oldOptions))
[10:21:11.700]     }
[10:21:11.700]     if (FALSE) {
[10:21:11.700]     }
[10:21:11.700]     else {
[10:21:11.700]         if (TRUE) {
[10:21:11.700]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:11.700]                 open = "w")
[10:21:11.700]         }
[10:21:11.700]         else {
[10:21:11.700]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:11.700]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:11.700]         }
[10:21:11.700]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:11.700]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:11.700]             base::sink(type = "output", split = FALSE)
[10:21:11.700]             base::close(...future.stdout)
[10:21:11.700]         }, add = TRUE)
[10:21:11.700]     }
[10:21:11.700]     ...future.frame <- base::sys.nframe()
[10:21:11.700]     ...future.conditions <- base::list()
[10:21:11.700]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:11.700]     if (FALSE) {
[10:21:11.700]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:11.700]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:11.700]     }
[10:21:11.700]     ...future.result <- base::tryCatch({
[10:21:11.700]         base::withCallingHandlers({
[10:21:11.700]             ...future.value <- base::withVisible(base::local({
[10:21:11.700]                 ...future.makeSendCondition <- base::local({
[10:21:11.700]                   sendCondition <- NULL
[10:21:11.700]                   function(frame = 1L) {
[10:21:11.700]                     if (is.function(sendCondition)) 
[10:21:11.700]                       return(sendCondition)
[10:21:11.700]                     ns <- getNamespace("parallel")
[10:21:11.700]                     if (exists("sendData", mode = "function", 
[10:21:11.700]                       envir = ns)) {
[10:21:11.700]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:11.700]                         envir = ns)
[10:21:11.700]                       envir <- sys.frame(frame)
[10:21:11.700]                       master <- NULL
[10:21:11.700]                       while (!identical(envir, .GlobalEnv) && 
[10:21:11.700]                         !identical(envir, emptyenv())) {
[10:21:11.700]                         if (exists("master", mode = "list", envir = envir, 
[10:21:11.700]                           inherits = FALSE)) {
[10:21:11.700]                           master <- get("master", mode = "list", 
[10:21:11.700]                             envir = envir, inherits = FALSE)
[10:21:11.700]                           if (inherits(master, c("SOCKnode", 
[10:21:11.700]                             "SOCK0node"))) {
[10:21:11.700]                             sendCondition <<- function(cond) {
[10:21:11.700]                               data <- list(type = "VALUE", value = cond, 
[10:21:11.700]                                 success = TRUE)
[10:21:11.700]                               parallel_sendData(master, data)
[10:21:11.700]                             }
[10:21:11.700]                             return(sendCondition)
[10:21:11.700]                           }
[10:21:11.700]                         }
[10:21:11.700]                         frame <- frame + 1L
[10:21:11.700]                         envir <- sys.frame(frame)
[10:21:11.700]                       }
[10:21:11.700]                     }
[10:21:11.700]                     sendCondition <<- function(cond) NULL
[10:21:11.700]                   }
[10:21:11.700]                 })
[10:21:11.700]                 withCallingHandlers({
[10:21:11.700]                   {
[10:21:11.700]                     x <- 3
[10:21:11.700]                     stop("Woops!")
[10:21:11.700]                     x
[10:21:11.700]                   }
[10:21:11.700]                 }, immediateCondition = function(cond) {
[10:21:11.700]                   sendCondition <- ...future.makeSendCondition()
[10:21:11.700]                   sendCondition(cond)
[10:21:11.700]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.700]                   {
[10:21:11.700]                     inherits <- base::inherits
[10:21:11.700]                     invokeRestart <- base::invokeRestart
[10:21:11.700]                     is.null <- base::is.null
[10:21:11.700]                     muffled <- FALSE
[10:21:11.700]                     if (inherits(cond, "message")) {
[10:21:11.700]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:11.700]                       if (muffled) 
[10:21:11.700]                         invokeRestart("muffleMessage")
[10:21:11.700]                     }
[10:21:11.700]                     else if (inherits(cond, "warning")) {
[10:21:11.700]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:11.700]                       if (muffled) 
[10:21:11.700]                         invokeRestart("muffleWarning")
[10:21:11.700]                     }
[10:21:11.700]                     else if (inherits(cond, "condition")) {
[10:21:11.700]                       if (!is.null(pattern)) {
[10:21:11.700]                         computeRestarts <- base::computeRestarts
[10:21:11.700]                         grepl <- base::grepl
[10:21:11.700]                         restarts <- computeRestarts(cond)
[10:21:11.700]                         for (restart in restarts) {
[10:21:11.700]                           name <- restart$name
[10:21:11.700]                           if (is.null(name)) 
[10:21:11.700]                             next
[10:21:11.700]                           if (!grepl(pattern, name)) 
[10:21:11.700]                             next
[10:21:11.700]                           invokeRestart(restart)
[10:21:11.700]                           muffled <- TRUE
[10:21:11.700]                           break
[10:21:11.700]                         }
[10:21:11.700]                       }
[10:21:11.700]                     }
[10:21:11.700]                     invisible(muffled)
[10:21:11.700]                   }
[10:21:11.700]                   muffleCondition(cond)
[10:21:11.700]                 })
[10:21:11.700]             }))
[10:21:11.700]             future::FutureResult(value = ...future.value$value, 
[10:21:11.700]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:11.700]                   ...future.rng), globalenv = if (FALSE) 
[10:21:11.700]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:11.700]                     ...future.globalenv.names))
[10:21:11.700]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:11.700]         }, condition = base::local({
[10:21:11.700]             c <- base::c
[10:21:11.700]             inherits <- base::inherits
[10:21:11.700]             invokeRestart <- base::invokeRestart
[10:21:11.700]             length <- base::length
[10:21:11.700]             list <- base::list
[10:21:11.700]             seq.int <- base::seq.int
[10:21:11.700]             signalCondition <- base::signalCondition
[10:21:11.700]             sys.calls <- base::sys.calls
[10:21:11.700]             `[[` <- base::`[[`
[10:21:11.700]             `+` <- base::`+`
[10:21:11.700]             `<<-` <- base::`<<-`
[10:21:11.700]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:11.700]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:11.700]                   3L)]
[10:21:11.700]             }
[10:21:11.700]             function(cond) {
[10:21:11.700]                 is_error <- inherits(cond, "error")
[10:21:11.700]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:11.700]                   NULL)
[10:21:11.700]                 if (is_error) {
[10:21:11.700]                   sessionInformation <- function() {
[10:21:11.700]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:11.700]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:11.700]                       search = base::search(), system = base::Sys.info())
[10:21:11.700]                   }
[10:21:11.700]                   ...future.conditions[[length(...future.conditions) + 
[10:21:11.700]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:11.700]                     cond$call), session = sessionInformation(), 
[10:21:11.700]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:11.700]                   signalCondition(cond)
[10:21:11.700]                 }
[10:21:11.700]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:11.700]                 "immediateCondition"))) {
[10:21:11.700]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:11.700]                   ...future.conditions[[length(...future.conditions) + 
[10:21:11.700]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:11.700]                   if (TRUE && !signal) {
[10:21:11.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.700]                     {
[10:21:11.700]                       inherits <- base::inherits
[10:21:11.700]                       invokeRestart <- base::invokeRestart
[10:21:11.700]                       is.null <- base::is.null
[10:21:11.700]                       muffled <- FALSE
[10:21:11.700]                       if (inherits(cond, "message")) {
[10:21:11.700]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:11.700]                         if (muffled) 
[10:21:11.700]                           invokeRestart("muffleMessage")
[10:21:11.700]                       }
[10:21:11.700]                       else if (inherits(cond, "warning")) {
[10:21:11.700]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:11.700]                         if (muffled) 
[10:21:11.700]                           invokeRestart("muffleWarning")
[10:21:11.700]                       }
[10:21:11.700]                       else if (inherits(cond, "condition")) {
[10:21:11.700]                         if (!is.null(pattern)) {
[10:21:11.700]                           computeRestarts <- base::computeRestarts
[10:21:11.700]                           grepl <- base::grepl
[10:21:11.700]                           restarts <- computeRestarts(cond)
[10:21:11.700]                           for (restart in restarts) {
[10:21:11.700]                             name <- restart$name
[10:21:11.700]                             if (is.null(name)) 
[10:21:11.700]                               next
[10:21:11.700]                             if (!grepl(pattern, name)) 
[10:21:11.700]                               next
[10:21:11.700]                             invokeRestart(restart)
[10:21:11.700]                             muffled <- TRUE
[10:21:11.700]                             break
[10:21:11.700]                           }
[10:21:11.700]                         }
[10:21:11.700]                       }
[10:21:11.700]                       invisible(muffled)
[10:21:11.700]                     }
[10:21:11.700]                     muffleCondition(cond, pattern = "^muffle")
[10:21:11.700]                   }
[10:21:11.700]                 }
[10:21:11.700]                 else {
[10:21:11.700]                   if (TRUE) {
[10:21:11.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.700]                     {
[10:21:11.700]                       inherits <- base::inherits
[10:21:11.700]                       invokeRestart <- base::invokeRestart
[10:21:11.700]                       is.null <- base::is.null
[10:21:11.700]                       muffled <- FALSE
[10:21:11.700]                       if (inherits(cond, "message")) {
[10:21:11.700]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:11.700]                         if (muffled) 
[10:21:11.700]                           invokeRestart("muffleMessage")
[10:21:11.700]                       }
[10:21:11.700]                       else if (inherits(cond, "warning")) {
[10:21:11.700]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:11.700]                         if (muffled) 
[10:21:11.700]                           invokeRestart("muffleWarning")
[10:21:11.700]                       }
[10:21:11.700]                       else if (inherits(cond, "condition")) {
[10:21:11.700]                         if (!is.null(pattern)) {
[10:21:11.700]                           computeRestarts <- base::computeRestarts
[10:21:11.700]                           grepl <- base::grepl
[10:21:11.700]                           restarts <- computeRestarts(cond)
[10:21:11.700]                           for (restart in restarts) {
[10:21:11.700]                             name <- restart$name
[10:21:11.700]                             if (is.null(name)) 
[10:21:11.700]                               next
[10:21:11.700]                             if (!grepl(pattern, name)) 
[10:21:11.700]                               next
[10:21:11.700]                             invokeRestart(restart)
[10:21:11.700]                             muffled <- TRUE
[10:21:11.700]                             break
[10:21:11.700]                           }
[10:21:11.700]                         }
[10:21:11.700]                       }
[10:21:11.700]                       invisible(muffled)
[10:21:11.700]                     }
[10:21:11.700]                     muffleCondition(cond, pattern = "^muffle")
[10:21:11.700]                   }
[10:21:11.700]                 }
[10:21:11.700]             }
[10:21:11.700]         }))
[10:21:11.700]     }, error = function(ex) {
[10:21:11.700]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:11.700]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:11.700]                 ...future.rng), started = ...future.startTime, 
[10:21:11.700]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:11.700]             version = "1.8"), class = "FutureResult")
[10:21:11.700]     }, finally = {
[10:21:11.700]         if (!identical(...future.workdir, getwd())) 
[10:21:11.700]             setwd(...future.workdir)
[10:21:11.700]         {
[10:21:11.700]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:11.700]                 ...future.oldOptions$nwarnings <- NULL
[10:21:11.700]             }
[10:21:11.700]             base::options(...future.oldOptions)
[10:21:11.700]             if (.Platform$OS.type == "windows") {
[10:21:11.700]                 old_names <- names(...future.oldEnvVars)
[10:21:11.700]                 envs <- base::Sys.getenv()
[10:21:11.700]                 names <- names(envs)
[10:21:11.700]                 common <- intersect(names, old_names)
[10:21:11.700]                 added <- setdiff(names, old_names)
[10:21:11.700]                 removed <- setdiff(old_names, names)
[10:21:11.700]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:11.700]                   envs[common]]
[10:21:11.700]                 NAMES <- toupper(changed)
[10:21:11.700]                 args <- list()
[10:21:11.700]                 for (kk in seq_along(NAMES)) {
[10:21:11.700]                   name <- changed[[kk]]
[10:21:11.700]                   NAME <- NAMES[[kk]]
[10:21:11.700]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.700]                     next
[10:21:11.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:11.700]                 }
[10:21:11.700]                 NAMES <- toupper(added)
[10:21:11.700]                 for (kk in seq_along(NAMES)) {
[10:21:11.700]                   name <- added[[kk]]
[10:21:11.700]                   NAME <- NAMES[[kk]]
[10:21:11.700]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.700]                     next
[10:21:11.700]                   args[[name]] <- ""
[10:21:11.700]                 }
[10:21:11.700]                 NAMES <- toupper(removed)
[10:21:11.700]                 for (kk in seq_along(NAMES)) {
[10:21:11.700]                   name <- removed[[kk]]
[10:21:11.700]                   NAME <- NAMES[[kk]]
[10:21:11.700]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.700]                     next
[10:21:11.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:11.700]                 }
[10:21:11.700]                 if (length(args) > 0) 
[10:21:11.700]                   base::do.call(base::Sys.setenv, args = args)
[10:21:11.700]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:11.700]             }
[10:21:11.700]             else {
[10:21:11.700]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:11.700]             }
[10:21:11.700]             {
[10:21:11.700]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:11.700]                   0L) {
[10:21:11.700]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:11.700]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:11.700]                   base::options(opts)
[10:21:11.700]                 }
[10:21:11.700]                 {
[10:21:11.700]                   {
[10:21:11.700]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:11.700]                     NULL
[10:21:11.700]                   }
[10:21:11.700]                   options(future.plan = NULL)
[10:21:11.700]                   if (is.na(NA_character_)) 
[10:21:11.700]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:11.700]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:11.700]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:11.700]                     .init = FALSE)
[10:21:11.700]                 }
[10:21:11.700]             }
[10:21:11.700]         }
[10:21:11.700]     })
[10:21:11.700]     if (TRUE) {
[10:21:11.700]         base::sink(type = "output", split = FALSE)
[10:21:11.700]         if (TRUE) {
[10:21:11.700]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:11.700]         }
[10:21:11.700]         else {
[10:21:11.700]             ...future.result["stdout"] <- base::list(NULL)
[10:21:11.700]         }
[10:21:11.700]         base::close(...future.stdout)
[10:21:11.700]         ...future.stdout <- NULL
[10:21:11.700]     }
[10:21:11.700]     ...future.result$conditions <- ...future.conditions
[10:21:11.700]     ...future.result$finished <- base::Sys.time()
[10:21:11.700]     ...future.result
[10:21:11.700] }
[10:21:11.703] MultisessionFuture started
[10:21:11.703] - Launch lazy future ... done
[10:21:11.704] run() for ‘MultisessionFuture’ ... done
[10:21:11.704] result() for ClusterFuture ...
[10:21:11.704] receiveMessageFromWorker() for ClusterFuture ...
[10:21:11.704] - Validating connection of MultisessionFuture
[10:21:11.746] - received message: FutureResult
[10:21:11.746] - Received FutureResult
[10:21:11.746] - Erased future from FutureRegistry
[10:21:11.746] result() for ClusterFuture ...
[10:21:11.746] - result already collected: FutureResult
[10:21:11.746] result() for ClusterFuture ... done
[10:21:11.746] signalConditions() ...
[10:21:11.747]  - include = ‘immediateCondition’
[10:21:11.747]  - exclude = 
[10:21:11.747]  - resignal = FALSE
[10:21:11.747]  - Number of conditions: 1
[10:21:11.747] signalConditions() ... done
[10:21:11.747] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:11.747] result() for ClusterFuture ... done
[10:21:11.747] result() for ClusterFuture ...
[10:21:11.747] - result already collected: FutureResult
[10:21:11.748] result() for ClusterFuture ... done
[10:21:11.748] signalConditions() ...
[10:21:11.748]  - include = ‘immediateCondition’
[10:21:11.748]  - exclude = 
[10:21:11.748]  - resignal = FALSE
[10:21:11.748]  - Number of conditions: 1
[10:21:11.748] signalConditions() ... done
[10:21:11.748] Future state: ‘finished’
[10:21:11.748] result() for ClusterFuture ...
[10:21:11.749] - result already collected: FutureResult
[10:21:11.749] result() for ClusterFuture ... done
[10:21:11.749] signalConditions() ...
[10:21:11.749]  - include = ‘condition’
[10:21:11.749]  - exclude = ‘immediateCondition’
[10:21:11.749]  - resignal = TRUE
[10:21:11.749]  - Number of conditions: 1
[10:21:11.749]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:11.749] signalConditions() ... done
[10:21:11.750] getGlobalsAndPackages() ...
[10:21:11.750] Searching for globals...
[10:21:11.752] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[10:21:11.752] Searching for globals ... DONE
[10:21:11.752] Resolving globals: FALSE
[10:21:11.753] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:11.753] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:11.753] - globals: [1] ‘ii’
[10:21:11.753] 
[10:21:11.753] getGlobalsAndPackages() ... DONE
[10:21:11.754] run() for ‘Future’ ...
[10:21:11.754] - state: ‘created’
[10:21:11.754] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:11.769] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:11.769] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:11.769]   - Field: ‘node’
[10:21:11.769]   - Field: ‘label’
[10:21:11.769]   - Field: ‘local’
[10:21:11.769]   - Field: ‘owner’
[10:21:11.769]   - Field: ‘envir’
[10:21:11.769]   - Field: ‘workers’
[10:21:11.769]   - Field: ‘packages’
[10:21:11.769]   - Field: ‘gc’
[10:21:11.770]   - Field: ‘conditions’
[10:21:11.770]   - Field: ‘persistent’
[10:21:11.770]   - Field: ‘expr’
[10:21:11.770]   - Field: ‘uuid’
[10:21:11.770]   - Field: ‘seed’
[10:21:11.770]   - Field: ‘version’
[10:21:11.770]   - Field: ‘result’
[10:21:11.770]   - Field: ‘asynchronous’
[10:21:11.770]   - Field: ‘calls’
[10:21:11.771]   - Field: ‘globals’
[10:21:11.771]   - Field: ‘stdout’
[10:21:11.771]   - Field: ‘earlySignal’
[10:21:11.771]   - Field: ‘lazy’
[10:21:11.771]   - Field: ‘state’
[10:21:11.771] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:11.771] - Launch lazy future ...
[10:21:11.772] Packages needed by the future expression (n = 0): <none>
[10:21:11.772] Packages needed by future strategies (n = 0): <none>
[10:21:11.772] {
[10:21:11.772]     {
[10:21:11.772]         {
[10:21:11.772]             ...future.startTime <- base::Sys.time()
[10:21:11.772]             {
[10:21:11.772]                 {
[10:21:11.772]                   {
[10:21:11.772]                     {
[10:21:11.772]                       base::local({
[10:21:11.772]                         has_future <- base::requireNamespace("future", 
[10:21:11.772]                           quietly = TRUE)
[10:21:11.772]                         if (has_future) {
[10:21:11.772]                           ns <- base::getNamespace("future")
[10:21:11.772]                           version <- ns[[".package"]][["version"]]
[10:21:11.772]                           if (is.null(version)) 
[10:21:11.772]                             version <- utils::packageVersion("future")
[10:21:11.772]                         }
[10:21:11.772]                         else {
[10:21:11.772]                           version <- NULL
[10:21:11.772]                         }
[10:21:11.772]                         if (!has_future || version < "1.8.0") {
[10:21:11.772]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:11.772]                             "", base::R.version$version.string), 
[10:21:11.772]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:11.772]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:11.772]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:11.772]                               "release", "version")], collapse = " "), 
[10:21:11.772]                             hostname = base::Sys.info()[["nodename"]])
[10:21:11.772]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:11.772]                             info)
[10:21:11.772]                           info <- base::paste(info, collapse = "; ")
[10:21:11.772]                           if (!has_future) {
[10:21:11.772]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:11.772]                               info)
[10:21:11.772]                           }
[10:21:11.772]                           else {
[10:21:11.772]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:11.772]                               info, version)
[10:21:11.772]                           }
[10:21:11.772]                           base::stop(msg)
[10:21:11.772]                         }
[10:21:11.772]                       })
[10:21:11.772]                     }
[10:21:11.772]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:11.772]                     base::options(mc.cores = 1L)
[10:21:11.772]                   }
[10:21:11.772]                   ...future.strategy.old <- future::plan("list")
[10:21:11.772]                   options(future.plan = NULL)
[10:21:11.772]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:11.772]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:11.772]                 }
[10:21:11.772]                 ...future.workdir <- getwd()
[10:21:11.772]             }
[10:21:11.772]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:11.772]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:11.772]         }
[10:21:11.772]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:11.772]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:11.772]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:11.772]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:11.772]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:11.772]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:11.772]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:11.772]             base::names(...future.oldOptions))
[10:21:11.772]     }
[10:21:11.772]     if (FALSE) {
[10:21:11.772]     }
[10:21:11.772]     else {
[10:21:11.772]         if (TRUE) {
[10:21:11.772]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:11.772]                 open = "w")
[10:21:11.772]         }
[10:21:11.772]         else {
[10:21:11.772]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:11.772]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:11.772]         }
[10:21:11.772]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:11.772]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:11.772]             base::sink(type = "output", split = FALSE)
[10:21:11.772]             base::close(...future.stdout)
[10:21:11.772]         }, add = TRUE)
[10:21:11.772]     }
[10:21:11.772]     ...future.frame <- base::sys.nframe()
[10:21:11.772]     ...future.conditions <- base::list()
[10:21:11.772]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:11.772]     if (FALSE) {
[10:21:11.772]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:11.772]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:11.772]     }
[10:21:11.772]     ...future.result <- base::tryCatch({
[10:21:11.772]         base::withCallingHandlers({
[10:21:11.772]             ...future.value <- base::withVisible(base::local({
[10:21:11.772]                 ...future.makeSendCondition <- base::local({
[10:21:11.772]                   sendCondition <- NULL
[10:21:11.772]                   function(frame = 1L) {
[10:21:11.772]                     if (is.function(sendCondition)) 
[10:21:11.772]                       return(sendCondition)
[10:21:11.772]                     ns <- getNamespace("parallel")
[10:21:11.772]                     if (exists("sendData", mode = "function", 
[10:21:11.772]                       envir = ns)) {
[10:21:11.772]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:11.772]                         envir = ns)
[10:21:11.772]                       envir <- sys.frame(frame)
[10:21:11.772]                       master <- NULL
[10:21:11.772]                       while (!identical(envir, .GlobalEnv) && 
[10:21:11.772]                         !identical(envir, emptyenv())) {
[10:21:11.772]                         if (exists("master", mode = "list", envir = envir, 
[10:21:11.772]                           inherits = FALSE)) {
[10:21:11.772]                           master <- get("master", mode = "list", 
[10:21:11.772]                             envir = envir, inherits = FALSE)
[10:21:11.772]                           if (inherits(master, c("SOCKnode", 
[10:21:11.772]                             "SOCK0node"))) {
[10:21:11.772]                             sendCondition <<- function(cond) {
[10:21:11.772]                               data <- list(type = "VALUE", value = cond, 
[10:21:11.772]                                 success = TRUE)
[10:21:11.772]                               parallel_sendData(master, data)
[10:21:11.772]                             }
[10:21:11.772]                             return(sendCondition)
[10:21:11.772]                           }
[10:21:11.772]                         }
[10:21:11.772]                         frame <- frame + 1L
[10:21:11.772]                         envir <- sys.frame(frame)
[10:21:11.772]                       }
[10:21:11.772]                     }
[10:21:11.772]                     sendCondition <<- function(cond) NULL
[10:21:11.772]                   }
[10:21:11.772]                 })
[10:21:11.772]                 withCallingHandlers({
[10:21:11.772]                   {
[10:21:11.772]                     if (ii%%2 == 0) 
[10:21:11.772]                       stop("Woops!")
[10:21:11.772]                     ii
[10:21:11.772]                   }
[10:21:11.772]                 }, immediateCondition = function(cond) {
[10:21:11.772]                   sendCondition <- ...future.makeSendCondition()
[10:21:11.772]                   sendCondition(cond)
[10:21:11.772]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.772]                   {
[10:21:11.772]                     inherits <- base::inherits
[10:21:11.772]                     invokeRestart <- base::invokeRestart
[10:21:11.772]                     is.null <- base::is.null
[10:21:11.772]                     muffled <- FALSE
[10:21:11.772]                     if (inherits(cond, "message")) {
[10:21:11.772]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:11.772]                       if (muffled) 
[10:21:11.772]                         invokeRestart("muffleMessage")
[10:21:11.772]                     }
[10:21:11.772]                     else if (inherits(cond, "warning")) {
[10:21:11.772]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:11.772]                       if (muffled) 
[10:21:11.772]                         invokeRestart("muffleWarning")
[10:21:11.772]                     }
[10:21:11.772]                     else if (inherits(cond, "condition")) {
[10:21:11.772]                       if (!is.null(pattern)) {
[10:21:11.772]                         computeRestarts <- base::computeRestarts
[10:21:11.772]                         grepl <- base::grepl
[10:21:11.772]                         restarts <- computeRestarts(cond)
[10:21:11.772]                         for (restart in restarts) {
[10:21:11.772]                           name <- restart$name
[10:21:11.772]                           if (is.null(name)) 
[10:21:11.772]                             next
[10:21:11.772]                           if (!grepl(pattern, name)) 
[10:21:11.772]                             next
[10:21:11.772]                           invokeRestart(restart)
[10:21:11.772]                           muffled <- TRUE
[10:21:11.772]                           break
[10:21:11.772]                         }
[10:21:11.772]                       }
[10:21:11.772]                     }
[10:21:11.772]                     invisible(muffled)
[10:21:11.772]                   }
[10:21:11.772]                   muffleCondition(cond)
[10:21:11.772]                 })
[10:21:11.772]             }))
[10:21:11.772]             future::FutureResult(value = ...future.value$value, 
[10:21:11.772]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:11.772]                   ...future.rng), globalenv = if (FALSE) 
[10:21:11.772]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:11.772]                     ...future.globalenv.names))
[10:21:11.772]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:11.772]         }, condition = base::local({
[10:21:11.772]             c <- base::c
[10:21:11.772]             inherits <- base::inherits
[10:21:11.772]             invokeRestart <- base::invokeRestart
[10:21:11.772]             length <- base::length
[10:21:11.772]             list <- base::list
[10:21:11.772]             seq.int <- base::seq.int
[10:21:11.772]             signalCondition <- base::signalCondition
[10:21:11.772]             sys.calls <- base::sys.calls
[10:21:11.772]             `[[` <- base::`[[`
[10:21:11.772]             `+` <- base::`+`
[10:21:11.772]             `<<-` <- base::`<<-`
[10:21:11.772]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:11.772]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:11.772]                   3L)]
[10:21:11.772]             }
[10:21:11.772]             function(cond) {
[10:21:11.772]                 is_error <- inherits(cond, "error")
[10:21:11.772]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:11.772]                   NULL)
[10:21:11.772]                 if (is_error) {
[10:21:11.772]                   sessionInformation <- function() {
[10:21:11.772]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:11.772]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:11.772]                       search = base::search(), system = base::Sys.info())
[10:21:11.772]                   }
[10:21:11.772]                   ...future.conditions[[length(...future.conditions) + 
[10:21:11.772]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:11.772]                     cond$call), session = sessionInformation(), 
[10:21:11.772]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:11.772]                   signalCondition(cond)
[10:21:11.772]                 }
[10:21:11.772]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:11.772]                 "immediateCondition"))) {
[10:21:11.772]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:11.772]                   ...future.conditions[[length(...future.conditions) + 
[10:21:11.772]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:11.772]                   if (TRUE && !signal) {
[10:21:11.772]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.772]                     {
[10:21:11.772]                       inherits <- base::inherits
[10:21:11.772]                       invokeRestart <- base::invokeRestart
[10:21:11.772]                       is.null <- base::is.null
[10:21:11.772]                       muffled <- FALSE
[10:21:11.772]                       if (inherits(cond, "message")) {
[10:21:11.772]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:11.772]                         if (muffled) 
[10:21:11.772]                           invokeRestart("muffleMessage")
[10:21:11.772]                       }
[10:21:11.772]                       else if (inherits(cond, "warning")) {
[10:21:11.772]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:11.772]                         if (muffled) 
[10:21:11.772]                           invokeRestart("muffleWarning")
[10:21:11.772]                       }
[10:21:11.772]                       else if (inherits(cond, "condition")) {
[10:21:11.772]                         if (!is.null(pattern)) {
[10:21:11.772]                           computeRestarts <- base::computeRestarts
[10:21:11.772]                           grepl <- base::grepl
[10:21:11.772]                           restarts <- computeRestarts(cond)
[10:21:11.772]                           for (restart in restarts) {
[10:21:11.772]                             name <- restart$name
[10:21:11.772]                             if (is.null(name)) 
[10:21:11.772]                               next
[10:21:11.772]                             if (!grepl(pattern, name)) 
[10:21:11.772]                               next
[10:21:11.772]                             invokeRestart(restart)
[10:21:11.772]                             muffled <- TRUE
[10:21:11.772]                             break
[10:21:11.772]                           }
[10:21:11.772]                         }
[10:21:11.772]                       }
[10:21:11.772]                       invisible(muffled)
[10:21:11.772]                     }
[10:21:11.772]                     muffleCondition(cond, pattern = "^muffle")
[10:21:11.772]                   }
[10:21:11.772]                 }
[10:21:11.772]                 else {
[10:21:11.772]                   if (TRUE) {
[10:21:11.772]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.772]                     {
[10:21:11.772]                       inherits <- base::inherits
[10:21:11.772]                       invokeRestart <- base::invokeRestart
[10:21:11.772]                       is.null <- base::is.null
[10:21:11.772]                       muffled <- FALSE
[10:21:11.772]                       if (inherits(cond, "message")) {
[10:21:11.772]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:11.772]                         if (muffled) 
[10:21:11.772]                           invokeRestart("muffleMessage")
[10:21:11.772]                       }
[10:21:11.772]                       else if (inherits(cond, "warning")) {
[10:21:11.772]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:11.772]                         if (muffled) 
[10:21:11.772]                           invokeRestart("muffleWarning")
[10:21:11.772]                       }
[10:21:11.772]                       else if (inherits(cond, "condition")) {
[10:21:11.772]                         if (!is.null(pattern)) {
[10:21:11.772]                           computeRestarts <- base::computeRestarts
[10:21:11.772]                           grepl <- base::grepl
[10:21:11.772]                           restarts <- computeRestarts(cond)
[10:21:11.772]                           for (restart in restarts) {
[10:21:11.772]                             name <- restart$name
[10:21:11.772]                             if (is.null(name)) 
[10:21:11.772]                               next
[10:21:11.772]                             if (!grepl(pattern, name)) 
[10:21:11.772]                               next
[10:21:11.772]                             invokeRestart(restart)
[10:21:11.772]                             muffled <- TRUE
[10:21:11.772]                             break
[10:21:11.772]                           }
[10:21:11.772]                         }
[10:21:11.772]                       }
[10:21:11.772]                       invisible(muffled)
[10:21:11.772]                     }
[10:21:11.772]                     muffleCondition(cond, pattern = "^muffle")
[10:21:11.772]                   }
[10:21:11.772]                 }
[10:21:11.772]             }
[10:21:11.772]         }))
[10:21:11.772]     }, error = function(ex) {
[10:21:11.772]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:11.772]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:11.772]                 ...future.rng), started = ...future.startTime, 
[10:21:11.772]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:11.772]             version = "1.8"), class = "FutureResult")
[10:21:11.772]     }, finally = {
[10:21:11.772]         if (!identical(...future.workdir, getwd())) 
[10:21:11.772]             setwd(...future.workdir)
[10:21:11.772]         {
[10:21:11.772]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:11.772]                 ...future.oldOptions$nwarnings <- NULL
[10:21:11.772]             }
[10:21:11.772]             base::options(...future.oldOptions)
[10:21:11.772]             if (.Platform$OS.type == "windows") {
[10:21:11.772]                 old_names <- names(...future.oldEnvVars)
[10:21:11.772]                 envs <- base::Sys.getenv()
[10:21:11.772]                 names <- names(envs)
[10:21:11.772]                 common <- intersect(names, old_names)
[10:21:11.772]                 added <- setdiff(names, old_names)
[10:21:11.772]                 removed <- setdiff(old_names, names)
[10:21:11.772]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:11.772]                   envs[common]]
[10:21:11.772]                 NAMES <- toupper(changed)
[10:21:11.772]                 args <- list()
[10:21:11.772]                 for (kk in seq_along(NAMES)) {
[10:21:11.772]                   name <- changed[[kk]]
[10:21:11.772]                   NAME <- NAMES[[kk]]
[10:21:11.772]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.772]                     next
[10:21:11.772]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:11.772]                 }
[10:21:11.772]                 NAMES <- toupper(added)
[10:21:11.772]                 for (kk in seq_along(NAMES)) {
[10:21:11.772]                   name <- added[[kk]]
[10:21:11.772]                   NAME <- NAMES[[kk]]
[10:21:11.772]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.772]                     next
[10:21:11.772]                   args[[name]] <- ""
[10:21:11.772]                 }
[10:21:11.772]                 NAMES <- toupper(removed)
[10:21:11.772]                 for (kk in seq_along(NAMES)) {
[10:21:11.772]                   name <- removed[[kk]]
[10:21:11.772]                   NAME <- NAMES[[kk]]
[10:21:11.772]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.772]                     next
[10:21:11.772]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:11.772]                 }
[10:21:11.772]                 if (length(args) > 0) 
[10:21:11.772]                   base::do.call(base::Sys.setenv, args = args)
[10:21:11.772]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:11.772]             }
[10:21:11.772]             else {
[10:21:11.772]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:11.772]             }
[10:21:11.772]             {
[10:21:11.772]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:11.772]                   0L) {
[10:21:11.772]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:11.772]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:11.772]                   base::options(opts)
[10:21:11.772]                 }
[10:21:11.772]                 {
[10:21:11.772]                   {
[10:21:11.772]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:11.772]                     NULL
[10:21:11.772]                   }
[10:21:11.772]                   options(future.plan = NULL)
[10:21:11.772]                   if (is.na(NA_character_)) 
[10:21:11.772]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:11.772]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:11.772]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:11.772]                     .init = FALSE)
[10:21:11.772]                 }
[10:21:11.772]             }
[10:21:11.772]         }
[10:21:11.772]     })
[10:21:11.772]     if (TRUE) {
[10:21:11.772]         base::sink(type = "output", split = FALSE)
[10:21:11.772]         if (TRUE) {
[10:21:11.772]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:11.772]         }
[10:21:11.772]         else {
[10:21:11.772]             ...future.result["stdout"] <- base::list(NULL)
[10:21:11.772]         }
[10:21:11.772]         base::close(...future.stdout)
[10:21:11.772]         ...future.stdout <- NULL
[10:21:11.772]     }
[10:21:11.772]     ...future.result$conditions <- ...future.conditions
[10:21:11.772]     ...future.result$finished <- base::Sys.time()
[10:21:11.772]     ...future.result
[10:21:11.772] }
[10:21:11.775] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[10:21:11.775] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[10:21:11.776] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[10:21:11.776] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[10:21:11.776] MultisessionFuture started
[10:21:11.777] - Launch lazy future ... done
[10:21:11.777] run() for ‘MultisessionFuture’ ... done
[10:21:11.777] getGlobalsAndPackages() ...
[10:21:11.777] Searching for globals...
[10:21:11.779] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[10:21:11.779] Searching for globals ... DONE
[10:21:11.779] Resolving globals: FALSE
[10:21:11.780] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:11.780] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:11.780] - globals: [1] ‘ii’
[10:21:11.781] 
[10:21:11.781] getGlobalsAndPackages() ... DONE
[10:21:11.781] run() for ‘Future’ ...
[10:21:11.781] - state: ‘created’
[10:21:11.781] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:11.796] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:11.796] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:11.796]   - Field: ‘node’
[10:21:11.796]   - Field: ‘label’
[10:21:11.796]   - Field: ‘local’
[10:21:11.796]   - Field: ‘owner’
[10:21:11.796]   - Field: ‘envir’
[10:21:11.796]   - Field: ‘workers’
[10:21:11.796]   - Field: ‘packages’
[10:21:11.797]   - Field: ‘gc’
[10:21:11.797]   - Field: ‘conditions’
[10:21:11.797]   - Field: ‘persistent’
[10:21:11.797]   - Field: ‘expr’
[10:21:11.797]   - Field: ‘uuid’
[10:21:11.797]   - Field: ‘seed’
[10:21:11.797]   - Field: ‘version’
[10:21:11.797]   - Field: ‘result’
[10:21:11.797]   - Field: ‘asynchronous’
[10:21:11.798]   - Field: ‘calls’
[10:21:11.798]   - Field: ‘globals’
[10:21:11.798]   - Field: ‘stdout’
[10:21:11.798]   - Field: ‘earlySignal’
[10:21:11.798]   - Field: ‘lazy’
[10:21:11.798]   - Field: ‘state’
[10:21:11.798] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:11.798] - Launch lazy future ...
[10:21:11.799] Packages needed by the future expression (n = 0): <none>
[10:21:11.799] Packages needed by future strategies (n = 0): <none>
[10:21:11.799] {
[10:21:11.799]     {
[10:21:11.799]         {
[10:21:11.799]             ...future.startTime <- base::Sys.time()
[10:21:11.799]             {
[10:21:11.799]                 {
[10:21:11.799]                   {
[10:21:11.799]                     {
[10:21:11.799]                       base::local({
[10:21:11.799]                         has_future <- base::requireNamespace("future", 
[10:21:11.799]                           quietly = TRUE)
[10:21:11.799]                         if (has_future) {
[10:21:11.799]                           ns <- base::getNamespace("future")
[10:21:11.799]                           version <- ns[[".package"]][["version"]]
[10:21:11.799]                           if (is.null(version)) 
[10:21:11.799]                             version <- utils::packageVersion("future")
[10:21:11.799]                         }
[10:21:11.799]                         else {
[10:21:11.799]                           version <- NULL
[10:21:11.799]                         }
[10:21:11.799]                         if (!has_future || version < "1.8.0") {
[10:21:11.799]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:11.799]                             "", base::R.version$version.string), 
[10:21:11.799]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:11.799]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:11.799]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:11.799]                               "release", "version")], collapse = " "), 
[10:21:11.799]                             hostname = base::Sys.info()[["nodename"]])
[10:21:11.799]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:11.799]                             info)
[10:21:11.799]                           info <- base::paste(info, collapse = "; ")
[10:21:11.799]                           if (!has_future) {
[10:21:11.799]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:11.799]                               info)
[10:21:11.799]                           }
[10:21:11.799]                           else {
[10:21:11.799]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:11.799]                               info, version)
[10:21:11.799]                           }
[10:21:11.799]                           base::stop(msg)
[10:21:11.799]                         }
[10:21:11.799]                       })
[10:21:11.799]                     }
[10:21:11.799]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:11.799]                     base::options(mc.cores = 1L)
[10:21:11.799]                   }
[10:21:11.799]                   ...future.strategy.old <- future::plan("list")
[10:21:11.799]                   options(future.plan = NULL)
[10:21:11.799]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:11.799]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:11.799]                 }
[10:21:11.799]                 ...future.workdir <- getwd()
[10:21:11.799]             }
[10:21:11.799]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:11.799]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:11.799]         }
[10:21:11.799]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:11.799]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:11.799]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:11.799]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:11.799]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:11.799]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:11.799]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:11.799]             base::names(...future.oldOptions))
[10:21:11.799]     }
[10:21:11.799]     if (FALSE) {
[10:21:11.799]     }
[10:21:11.799]     else {
[10:21:11.799]         if (TRUE) {
[10:21:11.799]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:11.799]                 open = "w")
[10:21:11.799]         }
[10:21:11.799]         else {
[10:21:11.799]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:11.799]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:11.799]         }
[10:21:11.799]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:11.799]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:11.799]             base::sink(type = "output", split = FALSE)
[10:21:11.799]             base::close(...future.stdout)
[10:21:11.799]         }, add = TRUE)
[10:21:11.799]     }
[10:21:11.799]     ...future.frame <- base::sys.nframe()
[10:21:11.799]     ...future.conditions <- base::list()
[10:21:11.799]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:11.799]     if (FALSE) {
[10:21:11.799]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:11.799]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:11.799]     }
[10:21:11.799]     ...future.result <- base::tryCatch({
[10:21:11.799]         base::withCallingHandlers({
[10:21:11.799]             ...future.value <- base::withVisible(base::local({
[10:21:11.799]                 ...future.makeSendCondition <- base::local({
[10:21:11.799]                   sendCondition <- NULL
[10:21:11.799]                   function(frame = 1L) {
[10:21:11.799]                     if (is.function(sendCondition)) 
[10:21:11.799]                       return(sendCondition)
[10:21:11.799]                     ns <- getNamespace("parallel")
[10:21:11.799]                     if (exists("sendData", mode = "function", 
[10:21:11.799]                       envir = ns)) {
[10:21:11.799]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:11.799]                         envir = ns)
[10:21:11.799]                       envir <- sys.frame(frame)
[10:21:11.799]                       master <- NULL
[10:21:11.799]                       while (!identical(envir, .GlobalEnv) && 
[10:21:11.799]                         !identical(envir, emptyenv())) {
[10:21:11.799]                         if (exists("master", mode = "list", envir = envir, 
[10:21:11.799]                           inherits = FALSE)) {
[10:21:11.799]                           master <- get("master", mode = "list", 
[10:21:11.799]                             envir = envir, inherits = FALSE)
[10:21:11.799]                           if (inherits(master, c("SOCKnode", 
[10:21:11.799]                             "SOCK0node"))) {
[10:21:11.799]                             sendCondition <<- function(cond) {
[10:21:11.799]                               data <- list(type = "VALUE", value = cond, 
[10:21:11.799]                                 success = TRUE)
[10:21:11.799]                               parallel_sendData(master, data)
[10:21:11.799]                             }
[10:21:11.799]                             return(sendCondition)
[10:21:11.799]                           }
[10:21:11.799]                         }
[10:21:11.799]                         frame <- frame + 1L
[10:21:11.799]                         envir <- sys.frame(frame)
[10:21:11.799]                       }
[10:21:11.799]                     }
[10:21:11.799]                     sendCondition <<- function(cond) NULL
[10:21:11.799]                   }
[10:21:11.799]                 })
[10:21:11.799]                 withCallingHandlers({
[10:21:11.799]                   {
[10:21:11.799]                     if (ii%%2 == 0) 
[10:21:11.799]                       stop("Woops!")
[10:21:11.799]                     ii
[10:21:11.799]                   }
[10:21:11.799]                 }, immediateCondition = function(cond) {
[10:21:11.799]                   sendCondition <- ...future.makeSendCondition()
[10:21:11.799]                   sendCondition(cond)
[10:21:11.799]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.799]                   {
[10:21:11.799]                     inherits <- base::inherits
[10:21:11.799]                     invokeRestart <- base::invokeRestart
[10:21:11.799]                     is.null <- base::is.null
[10:21:11.799]                     muffled <- FALSE
[10:21:11.799]                     if (inherits(cond, "message")) {
[10:21:11.799]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:11.799]                       if (muffled) 
[10:21:11.799]                         invokeRestart("muffleMessage")
[10:21:11.799]                     }
[10:21:11.799]                     else if (inherits(cond, "warning")) {
[10:21:11.799]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:11.799]                       if (muffled) 
[10:21:11.799]                         invokeRestart("muffleWarning")
[10:21:11.799]                     }
[10:21:11.799]                     else if (inherits(cond, "condition")) {
[10:21:11.799]                       if (!is.null(pattern)) {
[10:21:11.799]                         computeRestarts <- base::computeRestarts
[10:21:11.799]                         grepl <- base::grepl
[10:21:11.799]                         restarts <- computeRestarts(cond)
[10:21:11.799]                         for (restart in restarts) {
[10:21:11.799]                           name <- restart$name
[10:21:11.799]                           if (is.null(name)) 
[10:21:11.799]                             next
[10:21:11.799]                           if (!grepl(pattern, name)) 
[10:21:11.799]                             next
[10:21:11.799]                           invokeRestart(restart)
[10:21:11.799]                           muffled <- TRUE
[10:21:11.799]                           break
[10:21:11.799]                         }
[10:21:11.799]                       }
[10:21:11.799]                     }
[10:21:11.799]                     invisible(muffled)
[10:21:11.799]                   }
[10:21:11.799]                   muffleCondition(cond)
[10:21:11.799]                 })
[10:21:11.799]             }))
[10:21:11.799]             future::FutureResult(value = ...future.value$value, 
[10:21:11.799]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:11.799]                   ...future.rng), globalenv = if (FALSE) 
[10:21:11.799]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:11.799]                     ...future.globalenv.names))
[10:21:11.799]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:11.799]         }, condition = base::local({
[10:21:11.799]             c <- base::c
[10:21:11.799]             inherits <- base::inherits
[10:21:11.799]             invokeRestart <- base::invokeRestart
[10:21:11.799]             length <- base::length
[10:21:11.799]             list <- base::list
[10:21:11.799]             seq.int <- base::seq.int
[10:21:11.799]             signalCondition <- base::signalCondition
[10:21:11.799]             sys.calls <- base::sys.calls
[10:21:11.799]             `[[` <- base::`[[`
[10:21:11.799]             `+` <- base::`+`
[10:21:11.799]             `<<-` <- base::`<<-`
[10:21:11.799]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:11.799]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:11.799]                   3L)]
[10:21:11.799]             }
[10:21:11.799]             function(cond) {
[10:21:11.799]                 is_error <- inherits(cond, "error")
[10:21:11.799]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:11.799]                   NULL)
[10:21:11.799]                 if (is_error) {
[10:21:11.799]                   sessionInformation <- function() {
[10:21:11.799]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:11.799]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:11.799]                       search = base::search(), system = base::Sys.info())
[10:21:11.799]                   }
[10:21:11.799]                   ...future.conditions[[length(...future.conditions) + 
[10:21:11.799]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:11.799]                     cond$call), session = sessionInformation(), 
[10:21:11.799]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:11.799]                   signalCondition(cond)
[10:21:11.799]                 }
[10:21:11.799]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:11.799]                 "immediateCondition"))) {
[10:21:11.799]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:11.799]                   ...future.conditions[[length(...future.conditions) + 
[10:21:11.799]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:11.799]                   if (TRUE && !signal) {
[10:21:11.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.799]                     {
[10:21:11.799]                       inherits <- base::inherits
[10:21:11.799]                       invokeRestart <- base::invokeRestart
[10:21:11.799]                       is.null <- base::is.null
[10:21:11.799]                       muffled <- FALSE
[10:21:11.799]                       if (inherits(cond, "message")) {
[10:21:11.799]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:11.799]                         if (muffled) 
[10:21:11.799]                           invokeRestart("muffleMessage")
[10:21:11.799]                       }
[10:21:11.799]                       else if (inherits(cond, "warning")) {
[10:21:11.799]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:11.799]                         if (muffled) 
[10:21:11.799]                           invokeRestart("muffleWarning")
[10:21:11.799]                       }
[10:21:11.799]                       else if (inherits(cond, "condition")) {
[10:21:11.799]                         if (!is.null(pattern)) {
[10:21:11.799]                           computeRestarts <- base::computeRestarts
[10:21:11.799]                           grepl <- base::grepl
[10:21:11.799]                           restarts <- computeRestarts(cond)
[10:21:11.799]                           for (restart in restarts) {
[10:21:11.799]                             name <- restart$name
[10:21:11.799]                             if (is.null(name)) 
[10:21:11.799]                               next
[10:21:11.799]                             if (!grepl(pattern, name)) 
[10:21:11.799]                               next
[10:21:11.799]                             invokeRestart(restart)
[10:21:11.799]                             muffled <- TRUE
[10:21:11.799]                             break
[10:21:11.799]                           }
[10:21:11.799]                         }
[10:21:11.799]                       }
[10:21:11.799]                       invisible(muffled)
[10:21:11.799]                     }
[10:21:11.799]                     muffleCondition(cond, pattern = "^muffle")
[10:21:11.799]                   }
[10:21:11.799]                 }
[10:21:11.799]                 else {
[10:21:11.799]                   if (TRUE) {
[10:21:11.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.799]                     {
[10:21:11.799]                       inherits <- base::inherits
[10:21:11.799]                       invokeRestart <- base::invokeRestart
[10:21:11.799]                       is.null <- base::is.null
[10:21:11.799]                       muffled <- FALSE
[10:21:11.799]                       if (inherits(cond, "message")) {
[10:21:11.799]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:11.799]                         if (muffled) 
[10:21:11.799]                           invokeRestart("muffleMessage")
[10:21:11.799]                       }
[10:21:11.799]                       else if (inherits(cond, "warning")) {
[10:21:11.799]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:11.799]                         if (muffled) 
[10:21:11.799]                           invokeRestart("muffleWarning")
[10:21:11.799]                       }
[10:21:11.799]                       else if (inherits(cond, "condition")) {
[10:21:11.799]                         if (!is.null(pattern)) {
[10:21:11.799]                           computeRestarts <- base::computeRestarts
[10:21:11.799]                           grepl <- base::grepl
[10:21:11.799]                           restarts <- computeRestarts(cond)
[10:21:11.799]                           for (restart in restarts) {
[10:21:11.799]                             name <- restart$name
[10:21:11.799]                             if (is.null(name)) 
[10:21:11.799]                               next
[10:21:11.799]                             if (!grepl(pattern, name)) 
[10:21:11.799]                               next
[10:21:11.799]                             invokeRestart(restart)
[10:21:11.799]                             muffled <- TRUE
[10:21:11.799]                             break
[10:21:11.799]                           }
[10:21:11.799]                         }
[10:21:11.799]                       }
[10:21:11.799]                       invisible(muffled)
[10:21:11.799]                     }
[10:21:11.799]                     muffleCondition(cond, pattern = "^muffle")
[10:21:11.799]                   }
[10:21:11.799]                 }
[10:21:11.799]             }
[10:21:11.799]         }))
[10:21:11.799]     }, error = function(ex) {
[10:21:11.799]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:11.799]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:11.799]                 ...future.rng), started = ...future.startTime, 
[10:21:11.799]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:11.799]             version = "1.8"), class = "FutureResult")
[10:21:11.799]     }, finally = {
[10:21:11.799]         if (!identical(...future.workdir, getwd())) 
[10:21:11.799]             setwd(...future.workdir)
[10:21:11.799]         {
[10:21:11.799]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:11.799]                 ...future.oldOptions$nwarnings <- NULL
[10:21:11.799]             }
[10:21:11.799]             base::options(...future.oldOptions)
[10:21:11.799]             if (.Platform$OS.type == "windows") {
[10:21:11.799]                 old_names <- names(...future.oldEnvVars)
[10:21:11.799]                 envs <- base::Sys.getenv()
[10:21:11.799]                 names <- names(envs)
[10:21:11.799]                 common <- intersect(names, old_names)
[10:21:11.799]                 added <- setdiff(names, old_names)
[10:21:11.799]                 removed <- setdiff(old_names, names)
[10:21:11.799]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:11.799]                   envs[common]]
[10:21:11.799]                 NAMES <- toupper(changed)
[10:21:11.799]                 args <- list()
[10:21:11.799]                 for (kk in seq_along(NAMES)) {
[10:21:11.799]                   name <- changed[[kk]]
[10:21:11.799]                   NAME <- NAMES[[kk]]
[10:21:11.799]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.799]                     next
[10:21:11.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:11.799]                 }
[10:21:11.799]                 NAMES <- toupper(added)
[10:21:11.799]                 for (kk in seq_along(NAMES)) {
[10:21:11.799]                   name <- added[[kk]]
[10:21:11.799]                   NAME <- NAMES[[kk]]
[10:21:11.799]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.799]                     next
[10:21:11.799]                   args[[name]] <- ""
[10:21:11.799]                 }
[10:21:11.799]                 NAMES <- toupper(removed)
[10:21:11.799]                 for (kk in seq_along(NAMES)) {
[10:21:11.799]                   name <- removed[[kk]]
[10:21:11.799]                   NAME <- NAMES[[kk]]
[10:21:11.799]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.799]                     next
[10:21:11.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:11.799]                 }
[10:21:11.799]                 if (length(args) > 0) 
[10:21:11.799]                   base::do.call(base::Sys.setenv, args = args)
[10:21:11.799]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:11.799]             }
[10:21:11.799]             else {
[10:21:11.799]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:11.799]             }
[10:21:11.799]             {
[10:21:11.799]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:11.799]                   0L) {
[10:21:11.799]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:11.799]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:11.799]                   base::options(opts)
[10:21:11.799]                 }
[10:21:11.799]                 {
[10:21:11.799]                   {
[10:21:11.799]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:11.799]                     NULL
[10:21:11.799]                   }
[10:21:11.799]                   options(future.plan = NULL)
[10:21:11.799]                   if (is.na(NA_character_)) 
[10:21:11.799]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:11.799]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:11.799]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:11.799]                     .init = FALSE)
[10:21:11.799]                 }
[10:21:11.799]             }
[10:21:11.799]         }
[10:21:11.799]     })
[10:21:11.799]     if (TRUE) {
[10:21:11.799]         base::sink(type = "output", split = FALSE)
[10:21:11.799]         if (TRUE) {
[10:21:11.799]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:11.799]         }
[10:21:11.799]         else {
[10:21:11.799]             ...future.result["stdout"] <- base::list(NULL)
[10:21:11.799]         }
[10:21:11.799]         base::close(...future.stdout)
[10:21:11.799]         ...future.stdout <- NULL
[10:21:11.799]     }
[10:21:11.799]     ...future.result$conditions <- ...future.conditions
[10:21:11.799]     ...future.result$finished <- base::Sys.time()
[10:21:11.799]     ...future.result
[10:21:11.799] }
[10:21:11.851] Exporting 1 global objects (344 bytes) to cluster node #2 ...
[10:21:11.852] Exporting ‘ii’ (35 bytes) to cluster node #2 ...
[10:21:11.852] Exporting ‘ii’ (35 bytes) to cluster node #2 ... DONE
[10:21:11.852] Exporting 1 global objects (344 bytes) to cluster node #2 ... DONE
[10:21:11.853] MultisessionFuture started
[10:21:11.853] - Launch lazy future ... done
[10:21:11.853] run() for ‘MultisessionFuture’ ... done
[10:21:11.854] getGlobalsAndPackages() ...
[10:21:11.854] Searching for globals...
[10:21:11.856] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[10:21:11.856] Searching for globals ... DONE
[10:21:11.856] Resolving globals: FALSE
[10:21:11.857] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:11.857] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:11.857] - globals: [1] ‘ii’
[10:21:11.857] 
[10:21:11.858] getGlobalsAndPackages() ... DONE
[10:21:11.858] run() for ‘Future’ ...
[10:21:11.858] - state: ‘created’
[10:21:11.858] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:11.873] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:11.873] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:11.873]   - Field: ‘node’
[10:21:11.873]   - Field: ‘label’
[10:21:11.873]   - Field: ‘local’
[10:21:11.873]   - Field: ‘owner’
[10:21:11.873]   - Field: ‘envir’
[10:21:11.874]   - Field: ‘workers’
[10:21:11.874]   - Field: ‘packages’
[10:21:11.874]   - Field: ‘gc’
[10:21:11.874]   - Field: ‘conditions’
[10:21:11.874]   - Field: ‘persistent’
[10:21:11.874]   - Field: ‘expr’
[10:21:11.874]   - Field: ‘uuid’
[10:21:11.876]   - Field: ‘seed’
[10:21:11.877]   - Field: ‘version’
[10:21:11.877]   - Field: ‘result’
[10:21:11.877]   - Field: ‘asynchronous’
[10:21:11.877]   - Field: ‘calls’
[10:21:11.877]   - Field: ‘globals’
[10:21:11.877]   - Field: ‘stdout’
[10:21:11.877]   - Field: ‘earlySignal’
[10:21:11.877]   - Field: ‘lazy’
[10:21:11.877]   - Field: ‘state’
[10:21:11.877] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:11.877] - Launch lazy future ...
[10:21:11.878] Packages needed by the future expression (n = 0): <none>
[10:21:11.878] Packages needed by future strategies (n = 0): <none>
[10:21:11.878] {
[10:21:11.878]     {
[10:21:11.878]         {
[10:21:11.878]             ...future.startTime <- base::Sys.time()
[10:21:11.878]             {
[10:21:11.878]                 {
[10:21:11.878]                   {
[10:21:11.878]                     {
[10:21:11.878]                       base::local({
[10:21:11.878]                         has_future <- base::requireNamespace("future", 
[10:21:11.878]                           quietly = TRUE)
[10:21:11.878]                         if (has_future) {
[10:21:11.878]                           ns <- base::getNamespace("future")
[10:21:11.878]                           version <- ns[[".package"]][["version"]]
[10:21:11.878]                           if (is.null(version)) 
[10:21:11.878]                             version <- utils::packageVersion("future")
[10:21:11.878]                         }
[10:21:11.878]                         else {
[10:21:11.878]                           version <- NULL
[10:21:11.878]                         }
[10:21:11.878]                         if (!has_future || version < "1.8.0") {
[10:21:11.878]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:11.878]                             "", base::R.version$version.string), 
[10:21:11.878]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:11.878]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:11.878]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:11.878]                               "release", "version")], collapse = " "), 
[10:21:11.878]                             hostname = base::Sys.info()[["nodename"]])
[10:21:11.878]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:11.878]                             info)
[10:21:11.878]                           info <- base::paste(info, collapse = "; ")
[10:21:11.878]                           if (!has_future) {
[10:21:11.878]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:11.878]                               info)
[10:21:11.878]                           }
[10:21:11.878]                           else {
[10:21:11.878]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:11.878]                               info, version)
[10:21:11.878]                           }
[10:21:11.878]                           base::stop(msg)
[10:21:11.878]                         }
[10:21:11.878]                       })
[10:21:11.878]                     }
[10:21:11.878]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:11.878]                     base::options(mc.cores = 1L)
[10:21:11.878]                   }
[10:21:11.878]                   ...future.strategy.old <- future::plan("list")
[10:21:11.878]                   options(future.plan = NULL)
[10:21:11.878]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:11.878]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:11.878]                 }
[10:21:11.878]                 ...future.workdir <- getwd()
[10:21:11.878]             }
[10:21:11.878]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:11.878]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:11.878]         }
[10:21:11.878]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:11.878]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:11.878]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:11.878]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:11.878]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:11.878]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:11.878]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:11.878]             base::names(...future.oldOptions))
[10:21:11.878]     }
[10:21:11.878]     if (FALSE) {
[10:21:11.878]     }
[10:21:11.878]     else {
[10:21:11.878]         if (TRUE) {
[10:21:11.878]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:11.878]                 open = "w")
[10:21:11.878]         }
[10:21:11.878]         else {
[10:21:11.878]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:11.878]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:11.878]         }
[10:21:11.878]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:11.878]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:11.878]             base::sink(type = "output", split = FALSE)
[10:21:11.878]             base::close(...future.stdout)
[10:21:11.878]         }, add = TRUE)
[10:21:11.878]     }
[10:21:11.878]     ...future.frame <- base::sys.nframe()
[10:21:11.878]     ...future.conditions <- base::list()
[10:21:11.878]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:11.878]     if (FALSE) {
[10:21:11.878]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:11.878]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:11.878]     }
[10:21:11.878]     ...future.result <- base::tryCatch({
[10:21:11.878]         base::withCallingHandlers({
[10:21:11.878]             ...future.value <- base::withVisible(base::local({
[10:21:11.878]                 ...future.makeSendCondition <- base::local({
[10:21:11.878]                   sendCondition <- NULL
[10:21:11.878]                   function(frame = 1L) {
[10:21:11.878]                     if (is.function(sendCondition)) 
[10:21:11.878]                       return(sendCondition)
[10:21:11.878]                     ns <- getNamespace("parallel")
[10:21:11.878]                     if (exists("sendData", mode = "function", 
[10:21:11.878]                       envir = ns)) {
[10:21:11.878]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:11.878]                         envir = ns)
[10:21:11.878]                       envir <- sys.frame(frame)
[10:21:11.878]                       master <- NULL
[10:21:11.878]                       while (!identical(envir, .GlobalEnv) && 
[10:21:11.878]                         !identical(envir, emptyenv())) {
[10:21:11.878]                         if (exists("master", mode = "list", envir = envir, 
[10:21:11.878]                           inherits = FALSE)) {
[10:21:11.878]                           master <- get("master", mode = "list", 
[10:21:11.878]                             envir = envir, inherits = FALSE)
[10:21:11.878]                           if (inherits(master, c("SOCKnode", 
[10:21:11.878]                             "SOCK0node"))) {
[10:21:11.878]                             sendCondition <<- function(cond) {
[10:21:11.878]                               data <- list(type = "VALUE", value = cond, 
[10:21:11.878]                                 success = TRUE)
[10:21:11.878]                               parallel_sendData(master, data)
[10:21:11.878]                             }
[10:21:11.878]                             return(sendCondition)
[10:21:11.878]                           }
[10:21:11.878]                         }
[10:21:11.878]                         frame <- frame + 1L
[10:21:11.878]                         envir <- sys.frame(frame)
[10:21:11.878]                       }
[10:21:11.878]                     }
[10:21:11.878]                     sendCondition <<- function(cond) NULL
[10:21:11.878]                   }
[10:21:11.878]                 })
[10:21:11.878]                 withCallingHandlers({
[10:21:11.878]                   {
[10:21:11.878]                     if (ii%%2 == 0) 
[10:21:11.878]                       stop("Woops!")
[10:21:11.878]                     ii
[10:21:11.878]                   }
[10:21:11.878]                 }, immediateCondition = function(cond) {
[10:21:11.878]                   sendCondition <- ...future.makeSendCondition()
[10:21:11.878]                   sendCondition(cond)
[10:21:11.878]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.878]                   {
[10:21:11.878]                     inherits <- base::inherits
[10:21:11.878]                     invokeRestart <- base::invokeRestart
[10:21:11.878]                     is.null <- base::is.null
[10:21:11.878]                     muffled <- FALSE
[10:21:11.878]                     if (inherits(cond, "message")) {
[10:21:11.878]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:11.878]                       if (muffled) 
[10:21:11.878]                         invokeRestart("muffleMessage")
[10:21:11.878]                     }
[10:21:11.878]                     else if (inherits(cond, "warning")) {
[10:21:11.878]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:11.878]                       if (muffled) 
[10:21:11.878]                         invokeRestart("muffleWarning")
[10:21:11.878]                     }
[10:21:11.878]                     else if (inherits(cond, "condition")) {
[10:21:11.878]                       if (!is.null(pattern)) {
[10:21:11.878]                         computeRestarts <- base::computeRestarts
[10:21:11.878]                         grepl <- base::grepl
[10:21:11.878]                         restarts <- computeRestarts(cond)
[10:21:11.878]                         for (restart in restarts) {
[10:21:11.878]                           name <- restart$name
[10:21:11.878]                           if (is.null(name)) 
[10:21:11.878]                             next
[10:21:11.878]                           if (!grepl(pattern, name)) 
[10:21:11.878]                             next
[10:21:11.878]                           invokeRestart(restart)
[10:21:11.878]                           muffled <- TRUE
[10:21:11.878]                           break
[10:21:11.878]                         }
[10:21:11.878]                       }
[10:21:11.878]                     }
[10:21:11.878]                     invisible(muffled)
[10:21:11.878]                   }
[10:21:11.878]                   muffleCondition(cond)
[10:21:11.878]                 })
[10:21:11.878]             }))
[10:21:11.878]             future::FutureResult(value = ...future.value$value, 
[10:21:11.878]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:11.878]                   ...future.rng), globalenv = if (FALSE) 
[10:21:11.878]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:11.878]                     ...future.globalenv.names))
[10:21:11.878]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:11.878]         }, condition = base::local({
[10:21:11.878]             c <- base::c
[10:21:11.878]             inherits <- base::inherits
[10:21:11.878]             invokeRestart <- base::invokeRestart
[10:21:11.878]             length <- base::length
[10:21:11.878]             list <- base::list
[10:21:11.878]             seq.int <- base::seq.int
[10:21:11.878]             signalCondition <- base::signalCondition
[10:21:11.878]             sys.calls <- base::sys.calls
[10:21:11.878]             `[[` <- base::`[[`
[10:21:11.878]             `+` <- base::`+`
[10:21:11.878]             `<<-` <- base::`<<-`
[10:21:11.878]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:11.878]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:11.878]                   3L)]
[10:21:11.878]             }
[10:21:11.878]             function(cond) {
[10:21:11.878]                 is_error <- inherits(cond, "error")
[10:21:11.878]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:11.878]                   NULL)
[10:21:11.878]                 if (is_error) {
[10:21:11.878]                   sessionInformation <- function() {
[10:21:11.878]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:11.878]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:11.878]                       search = base::search(), system = base::Sys.info())
[10:21:11.878]                   }
[10:21:11.878]                   ...future.conditions[[length(...future.conditions) + 
[10:21:11.878]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:11.878]                     cond$call), session = sessionInformation(), 
[10:21:11.878]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:11.878]                   signalCondition(cond)
[10:21:11.878]                 }
[10:21:11.878]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:11.878]                 "immediateCondition"))) {
[10:21:11.878]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:11.878]                   ...future.conditions[[length(...future.conditions) + 
[10:21:11.878]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:11.878]                   if (TRUE && !signal) {
[10:21:11.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.878]                     {
[10:21:11.878]                       inherits <- base::inherits
[10:21:11.878]                       invokeRestart <- base::invokeRestart
[10:21:11.878]                       is.null <- base::is.null
[10:21:11.878]                       muffled <- FALSE
[10:21:11.878]                       if (inherits(cond, "message")) {
[10:21:11.878]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:11.878]                         if (muffled) 
[10:21:11.878]                           invokeRestart("muffleMessage")
[10:21:11.878]                       }
[10:21:11.878]                       else if (inherits(cond, "warning")) {
[10:21:11.878]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:11.878]                         if (muffled) 
[10:21:11.878]                           invokeRestart("muffleWarning")
[10:21:11.878]                       }
[10:21:11.878]                       else if (inherits(cond, "condition")) {
[10:21:11.878]                         if (!is.null(pattern)) {
[10:21:11.878]                           computeRestarts <- base::computeRestarts
[10:21:11.878]                           grepl <- base::grepl
[10:21:11.878]                           restarts <- computeRestarts(cond)
[10:21:11.878]                           for (restart in restarts) {
[10:21:11.878]                             name <- restart$name
[10:21:11.878]                             if (is.null(name)) 
[10:21:11.878]                               next
[10:21:11.878]                             if (!grepl(pattern, name)) 
[10:21:11.878]                               next
[10:21:11.878]                             invokeRestart(restart)
[10:21:11.878]                             muffled <- TRUE
[10:21:11.878]                             break
[10:21:11.878]                           }
[10:21:11.878]                         }
[10:21:11.878]                       }
[10:21:11.878]                       invisible(muffled)
[10:21:11.878]                     }
[10:21:11.878]                     muffleCondition(cond, pattern = "^muffle")
[10:21:11.878]                   }
[10:21:11.878]                 }
[10:21:11.878]                 else {
[10:21:11.878]                   if (TRUE) {
[10:21:11.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.878]                     {
[10:21:11.878]                       inherits <- base::inherits
[10:21:11.878]                       invokeRestart <- base::invokeRestart
[10:21:11.878]                       is.null <- base::is.null
[10:21:11.878]                       muffled <- FALSE
[10:21:11.878]                       if (inherits(cond, "message")) {
[10:21:11.878]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:11.878]                         if (muffled) 
[10:21:11.878]                           invokeRestart("muffleMessage")
[10:21:11.878]                       }
[10:21:11.878]                       else if (inherits(cond, "warning")) {
[10:21:11.878]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:11.878]                         if (muffled) 
[10:21:11.878]                           invokeRestart("muffleWarning")
[10:21:11.878]                       }
[10:21:11.878]                       else if (inherits(cond, "condition")) {
[10:21:11.878]                         if (!is.null(pattern)) {
[10:21:11.878]                           computeRestarts <- base::computeRestarts
[10:21:11.878]                           grepl <- base::grepl
[10:21:11.878]                           restarts <- computeRestarts(cond)
[10:21:11.878]                           for (restart in restarts) {
[10:21:11.878]                             name <- restart$name
[10:21:11.878]                             if (is.null(name)) 
[10:21:11.878]                               next
[10:21:11.878]                             if (!grepl(pattern, name)) 
[10:21:11.878]                               next
[10:21:11.878]                             invokeRestart(restart)
[10:21:11.878]                             muffled <- TRUE
[10:21:11.878]                             break
[10:21:11.878]                           }
[10:21:11.878]                         }
[10:21:11.878]                       }
[10:21:11.878]                       invisible(muffled)
[10:21:11.878]                     }
[10:21:11.878]                     muffleCondition(cond, pattern = "^muffle")
[10:21:11.878]                   }
[10:21:11.878]                 }
[10:21:11.878]             }
[10:21:11.878]         }))
[10:21:11.878]     }, error = function(ex) {
[10:21:11.878]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:11.878]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:11.878]                 ...future.rng), started = ...future.startTime, 
[10:21:11.878]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:11.878]             version = "1.8"), class = "FutureResult")
[10:21:11.878]     }, finally = {
[10:21:11.878]         if (!identical(...future.workdir, getwd())) 
[10:21:11.878]             setwd(...future.workdir)
[10:21:11.878]         {
[10:21:11.878]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:11.878]                 ...future.oldOptions$nwarnings <- NULL
[10:21:11.878]             }
[10:21:11.878]             base::options(...future.oldOptions)
[10:21:11.878]             if (.Platform$OS.type == "windows") {
[10:21:11.878]                 old_names <- names(...future.oldEnvVars)
[10:21:11.878]                 envs <- base::Sys.getenv()
[10:21:11.878]                 names <- names(envs)
[10:21:11.878]                 common <- intersect(names, old_names)
[10:21:11.878]                 added <- setdiff(names, old_names)
[10:21:11.878]                 removed <- setdiff(old_names, names)
[10:21:11.878]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:11.878]                   envs[common]]
[10:21:11.878]                 NAMES <- toupper(changed)
[10:21:11.878]                 args <- list()
[10:21:11.878]                 for (kk in seq_along(NAMES)) {
[10:21:11.878]                   name <- changed[[kk]]
[10:21:11.878]                   NAME <- NAMES[[kk]]
[10:21:11.878]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.878]                     next
[10:21:11.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:11.878]                 }
[10:21:11.878]                 NAMES <- toupper(added)
[10:21:11.878]                 for (kk in seq_along(NAMES)) {
[10:21:11.878]                   name <- added[[kk]]
[10:21:11.878]                   NAME <- NAMES[[kk]]
[10:21:11.878]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.878]                     next
[10:21:11.878]                   args[[name]] <- ""
[10:21:11.878]                 }
[10:21:11.878]                 NAMES <- toupper(removed)
[10:21:11.878]                 for (kk in seq_along(NAMES)) {
[10:21:11.878]                   name <- removed[[kk]]
[10:21:11.878]                   NAME <- NAMES[[kk]]
[10:21:11.878]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.878]                     next
[10:21:11.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:11.878]                 }
[10:21:11.878]                 if (length(args) > 0) 
[10:21:11.878]                   base::do.call(base::Sys.setenv, args = args)
[10:21:11.878]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:11.878]             }
[10:21:11.878]             else {
[10:21:11.878]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:11.878]             }
[10:21:11.878]             {
[10:21:11.878]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:11.878]                   0L) {
[10:21:11.878]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:11.878]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:11.878]                   base::options(opts)
[10:21:11.878]                 }
[10:21:11.878]                 {
[10:21:11.878]                   {
[10:21:11.878]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:11.878]                     NULL
[10:21:11.878]                   }
[10:21:11.878]                   options(future.plan = NULL)
[10:21:11.878]                   if (is.na(NA_character_)) 
[10:21:11.878]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:11.878]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:11.878]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:11.878]                     .init = FALSE)
[10:21:11.878]                 }
[10:21:11.878]             }
[10:21:11.878]         }
[10:21:11.878]     })
[10:21:11.878]     if (TRUE) {
[10:21:11.878]         base::sink(type = "output", split = FALSE)
[10:21:11.878]         if (TRUE) {
[10:21:11.878]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:11.878]         }
[10:21:11.878]         else {
[10:21:11.878]             ...future.result["stdout"] <- base::list(NULL)
[10:21:11.878]         }
[10:21:11.878]         base::close(...future.stdout)
[10:21:11.878]         ...future.stdout <- NULL
[10:21:11.878]     }
[10:21:11.878]     ...future.result$conditions <- ...future.conditions
[10:21:11.878]     ...future.result$finished <- base::Sys.time()
[10:21:11.878]     ...future.result
[10:21:11.878] }
[10:21:11.880] Poll #1 (0): usedNodes() = 2, workers = 2
[10:21:11.899] receiveMessageFromWorker() for ClusterFuture ...
[10:21:11.899] - Validating connection of MultisessionFuture
[10:21:11.900] - received message: FutureResult
[10:21:11.900] - Received FutureResult
[10:21:11.900] - Erased future from FutureRegistry
[10:21:11.900] result() for ClusterFuture ...
[10:21:11.900] - result already collected: FutureResult
[10:21:11.900] result() for ClusterFuture ... done
[10:21:11.900] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:11.900] result() for ClusterFuture ...
[10:21:11.900] - result already collected: FutureResult
[10:21:11.900] result() for ClusterFuture ... done
[10:21:11.900] result() for ClusterFuture ...
[10:21:11.901] - result already collected: FutureResult
[10:21:11.901] result() for ClusterFuture ... done
[10:21:11.901] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[10:21:11.901] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[10:21:11.902] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[10:21:11.902] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[10:21:11.902] MultisessionFuture started
[10:21:11.903] - Launch lazy future ... done
[10:21:11.903] run() for ‘MultisessionFuture’ ... done
[10:21:11.903] result() for ClusterFuture ...
[10:21:11.903] - result already collected: FutureResult
[10:21:11.903] result() for ClusterFuture ... done
[10:21:11.903] result() for ClusterFuture ...
[10:21:11.903] - result already collected: FutureResult
[10:21:11.903] result() for ClusterFuture ... done
[10:21:11.903] result() for ClusterFuture ...
[10:21:11.904] receiveMessageFromWorker() for ClusterFuture ...
[10:21:11.904] - Validating connection of MultisessionFuture
[10:21:11.925] - received message: FutureResult
[10:21:11.926] - Received FutureResult
[10:21:11.926] - Erased future from FutureRegistry
[10:21:11.926] result() for ClusterFuture ...
[10:21:11.926] - result already collected: FutureResult
[10:21:11.926] result() for ClusterFuture ... done
[10:21:11.926] signalConditions() ...
[10:21:11.926]  - include = ‘immediateCondition’
[10:21:11.926]  - exclude = 
[10:21:11.926]  - resignal = FALSE
[10:21:11.926]  - Number of conditions: 1
[10:21:11.926] signalConditions() ... done
[10:21:11.926] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:11.927] result() for ClusterFuture ... done
[10:21:11.927] result() for ClusterFuture ...
[10:21:11.927] - result already collected: FutureResult
[10:21:11.927] result() for ClusterFuture ... done
[10:21:11.927] signalConditions() ...
[10:21:11.927]  - include = ‘immediateCondition’
[10:21:11.927]  - exclude = 
[10:21:11.927]  - resignal = FALSE
[10:21:11.927]  - Number of conditions: 1
[10:21:11.927] signalConditions() ... done
[10:21:11.927] Future state: ‘finished’
[10:21:11.928] result() for ClusterFuture ...
[10:21:11.928] - result already collected: FutureResult
[10:21:11.928] result() for ClusterFuture ... done
[10:21:11.928] signalConditions() ...
[10:21:11.928]  - include = ‘condition’
[10:21:11.928]  - exclude = ‘immediateCondition’
[10:21:11.928]  - resignal = TRUE
[10:21:11.928]  - Number of conditions: 1
[10:21:11.928]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:11.928] signalConditions() ... done
[10:21:11.929] result() for ClusterFuture ...
[10:21:11.929] receiveMessageFromWorker() for ClusterFuture ...
[10:21:11.929] - Validating connection of MultisessionFuture
[10:21:11.945] - received message: FutureResult
[10:21:11.945] - Received FutureResult
[10:21:11.945] - Erased future from FutureRegistry
[10:21:11.945] result() for ClusterFuture ...
[10:21:11.946] - result already collected: FutureResult
[10:21:11.946] result() for ClusterFuture ... done
[10:21:11.946] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:11.946] result() for ClusterFuture ... done
[10:21:11.946] result() for ClusterFuture ...
[10:21:11.946] - result already collected: FutureResult
[10:21:11.946] result() for ClusterFuture ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[10:21:11.946] result() for ClusterFuture ...
[10:21:11.947] - result already collected: FutureResult
[10:21:11.947] result() for ClusterFuture ... done
[10:21:11.947] result() for ClusterFuture ...
[10:21:11.947] - result already collected: FutureResult
[10:21:11.947] result() for ClusterFuture ... done
[10:21:11.947] signalConditions() ...
[10:21:11.947]  - include = ‘immediateCondition’
[10:21:11.947]  - exclude = 
[10:21:11.947]  - resignal = FALSE
[10:21:11.947]  - Number of conditions: 1
[10:21:11.947] signalConditions() ... done
[10:21:11.947] Future state: ‘finished’
[10:21:11.948] result() for ClusterFuture ...
[10:21:11.948] - result already collected: FutureResult
[10:21:11.948] result() for ClusterFuture ... done
[10:21:11.948] signalConditions() ...
[10:21:11.948]  - include = ‘condition’
[10:21:11.948]  - exclude = ‘immediateCondition’
[10:21:11.948]  - resignal = TRUE
[10:21:11.948]  - Number of conditions: 1
[10:21:11.948]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:11.948] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[10:21:11.949] result() for ClusterFuture ...
[10:21:11.949] - result already collected: FutureResult
[10:21:11.949] result() for ClusterFuture ... done
[10:21:11.949] result() for ClusterFuture ...
[10:21:11.949] - result already collected: FutureResult
[10:21:11.949] result() for ClusterFuture ... done
[10:21:11.949] signalConditions() ...
[10:21:11.949]  - include = ‘immediateCondition’
[10:21:11.949]  - exclude = 
[10:21:11.949]  - resignal = FALSE
[10:21:11.950]  - Number of conditions: 1
[10:21:11.950] signalConditions() ... done
[10:21:11.950] Future state: ‘finished’
[10:21:11.950] result() for ClusterFuture ...
[10:21:11.950] - result already collected: FutureResult
[10:21:11.950] result() for ClusterFuture ... done
[10:21:11.950] signalConditions() ...
[10:21:11.950]  - include = ‘condition’
[10:21:11.950]  - exclude = ‘immediateCondition’
[10:21:11.950]  - resignal = TRUE
[10:21:11.950]  - Number of conditions: 1
[10:21:11.950]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:11.951] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[10:21:11.951] getGlobalsAndPackages() ...
[10:21:11.951] Searching for globals...
[10:21:11.953] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[10:21:11.953] Searching for globals ... DONE
[10:21:11.953] Resolving globals: FALSE
[10:21:11.954] 
[10:21:11.954] 
[10:21:11.954] getGlobalsAndPackages() ... DONE
[10:21:11.954] run() for ‘Future’ ...
[10:21:11.954] - state: ‘created’
[10:21:11.954] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:11.968] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:11.969] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:11.969]   - Field: ‘node’
[10:21:11.969]   - Field: ‘label’
[10:21:11.969]   - Field: ‘local’
[10:21:11.969]   - Field: ‘owner’
[10:21:11.969]   - Field: ‘envir’
[10:21:11.969]   - Field: ‘workers’
[10:21:11.969]   - Field: ‘packages’
[10:21:11.969]   - Field: ‘gc’
[10:21:11.969]   - Field: ‘conditions’
[10:21:11.970]   - Field: ‘persistent’
[10:21:11.970]   - Field: ‘expr’
[10:21:11.970]   - Field: ‘uuid’
[10:21:11.970]   - Field: ‘seed’
[10:21:11.970]   - Field: ‘version’
[10:21:11.970]   - Field: ‘result’
[10:21:11.970]   - Field: ‘asynchronous’
[10:21:11.970]   - Field: ‘calls’
[10:21:11.970]   - Field: ‘globals’
[10:21:11.970]   - Field: ‘stdout’
[10:21:11.970]   - Field: ‘earlySignal’
[10:21:11.970]   - Field: ‘lazy’
[10:21:11.971]   - Field: ‘state’
[10:21:11.971] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:11.971] - Launch lazy future ...
[10:21:11.971] Packages needed by the future expression (n = 0): <none>
[10:21:11.971] Packages needed by future strategies (n = 0): <none>
[10:21:11.972] {
[10:21:11.972]     {
[10:21:11.972]         {
[10:21:11.972]             ...future.startTime <- base::Sys.time()
[10:21:11.972]             {
[10:21:11.972]                 {
[10:21:11.972]                   {
[10:21:11.972]                     {
[10:21:11.972]                       base::local({
[10:21:11.972]                         has_future <- base::requireNamespace("future", 
[10:21:11.972]                           quietly = TRUE)
[10:21:11.972]                         if (has_future) {
[10:21:11.972]                           ns <- base::getNamespace("future")
[10:21:11.972]                           version <- ns[[".package"]][["version"]]
[10:21:11.972]                           if (is.null(version)) 
[10:21:11.972]                             version <- utils::packageVersion("future")
[10:21:11.972]                         }
[10:21:11.972]                         else {
[10:21:11.972]                           version <- NULL
[10:21:11.972]                         }
[10:21:11.972]                         if (!has_future || version < "1.8.0") {
[10:21:11.972]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:11.972]                             "", base::R.version$version.string), 
[10:21:11.972]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:11.972]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:11.972]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:11.972]                               "release", "version")], collapse = " "), 
[10:21:11.972]                             hostname = base::Sys.info()[["nodename"]])
[10:21:11.972]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:11.972]                             info)
[10:21:11.972]                           info <- base::paste(info, collapse = "; ")
[10:21:11.972]                           if (!has_future) {
[10:21:11.972]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:11.972]                               info)
[10:21:11.972]                           }
[10:21:11.972]                           else {
[10:21:11.972]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:11.972]                               info, version)
[10:21:11.972]                           }
[10:21:11.972]                           base::stop(msg)
[10:21:11.972]                         }
[10:21:11.972]                       })
[10:21:11.972]                     }
[10:21:11.972]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:11.972]                     base::options(mc.cores = 1L)
[10:21:11.972]                   }
[10:21:11.972]                   ...future.strategy.old <- future::plan("list")
[10:21:11.972]                   options(future.plan = NULL)
[10:21:11.972]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:11.972]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:11.972]                 }
[10:21:11.972]                 ...future.workdir <- getwd()
[10:21:11.972]             }
[10:21:11.972]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:11.972]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:11.972]         }
[10:21:11.972]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:11.972]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:11.972]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:11.972]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:11.972]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:11.972]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:11.972]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:11.972]             base::names(...future.oldOptions))
[10:21:11.972]     }
[10:21:11.972]     if (FALSE) {
[10:21:11.972]     }
[10:21:11.972]     else {
[10:21:11.972]         if (TRUE) {
[10:21:11.972]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:11.972]                 open = "w")
[10:21:11.972]         }
[10:21:11.972]         else {
[10:21:11.972]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:11.972]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:11.972]         }
[10:21:11.972]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:11.972]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:11.972]             base::sink(type = "output", split = FALSE)
[10:21:11.972]             base::close(...future.stdout)
[10:21:11.972]         }, add = TRUE)
[10:21:11.972]     }
[10:21:11.972]     ...future.frame <- base::sys.nframe()
[10:21:11.972]     ...future.conditions <- base::list()
[10:21:11.972]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:11.972]     if (FALSE) {
[10:21:11.972]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:11.972]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:11.972]     }
[10:21:11.972]     ...future.result <- base::tryCatch({
[10:21:11.972]         base::withCallingHandlers({
[10:21:11.972]             ...future.value <- base::withVisible(base::local({
[10:21:11.972]                 ...future.makeSendCondition <- base::local({
[10:21:11.972]                   sendCondition <- NULL
[10:21:11.972]                   function(frame = 1L) {
[10:21:11.972]                     if (is.function(sendCondition)) 
[10:21:11.972]                       return(sendCondition)
[10:21:11.972]                     ns <- getNamespace("parallel")
[10:21:11.972]                     if (exists("sendData", mode = "function", 
[10:21:11.972]                       envir = ns)) {
[10:21:11.972]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:11.972]                         envir = ns)
[10:21:11.972]                       envir <- sys.frame(frame)
[10:21:11.972]                       master <- NULL
[10:21:11.972]                       while (!identical(envir, .GlobalEnv) && 
[10:21:11.972]                         !identical(envir, emptyenv())) {
[10:21:11.972]                         if (exists("master", mode = "list", envir = envir, 
[10:21:11.972]                           inherits = FALSE)) {
[10:21:11.972]                           master <- get("master", mode = "list", 
[10:21:11.972]                             envir = envir, inherits = FALSE)
[10:21:11.972]                           if (inherits(master, c("SOCKnode", 
[10:21:11.972]                             "SOCK0node"))) {
[10:21:11.972]                             sendCondition <<- function(cond) {
[10:21:11.972]                               data <- list(type = "VALUE", value = cond, 
[10:21:11.972]                                 success = TRUE)
[10:21:11.972]                               parallel_sendData(master, data)
[10:21:11.972]                             }
[10:21:11.972]                             return(sendCondition)
[10:21:11.972]                           }
[10:21:11.972]                         }
[10:21:11.972]                         frame <- frame + 1L
[10:21:11.972]                         envir <- sys.frame(frame)
[10:21:11.972]                       }
[10:21:11.972]                     }
[10:21:11.972]                     sendCondition <<- function(cond) NULL
[10:21:11.972]                   }
[10:21:11.972]                 })
[10:21:11.972]                 withCallingHandlers({
[10:21:11.972]                   {
[10:21:11.972]                     cat("Processing: ")
[10:21:11.972]                     for (ii in 1:10) {
[10:21:11.972]                       cat(".")
[10:21:11.972]                     }
[10:21:11.972]                     cat(" [100%]\n")
[10:21:11.972]                     4
[10:21:11.972]                   }
[10:21:11.972]                 }, immediateCondition = function(cond) {
[10:21:11.972]                   sendCondition <- ...future.makeSendCondition()
[10:21:11.972]                   sendCondition(cond)
[10:21:11.972]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.972]                   {
[10:21:11.972]                     inherits <- base::inherits
[10:21:11.972]                     invokeRestart <- base::invokeRestart
[10:21:11.972]                     is.null <- base::is.null
[10:21:11.972]                     muffled <- FALSE
[10:21:11.972]                     if (inherits(cond, "message")) {
[10:21:11.972]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:11.972]                       if (muffled) 
[10:21:11.972]                         invokeRestart("muffleMessage")
[10:21:11.972]                     }
[10:21:11.972]                     else if (inherits(cond, "warning")) {
[10:21:11.972]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:11.972]                       if (muffled) 
[10:21:11.972]                         invokeRestart("muffleWarning")
[10:21:11.972]                     }
[10:21:11.972]                     else if (inherits(cond, "condition")) {
[10:21:11.972]                       if (!is.null(pattern)) {
[10:21:11.972]                         computeRestarts <- base::computeRestarts
[10:21:11.972]                         grepl <- base::grepl
[10:21:11.972]                         restarts <- computeRestarts(cond)
[10:21:11.972]                         for (restart in restarts) {
[10:21:11.972]                           name <- restart$name
[10:21:11.972]                           if (is.null(name)) 
[10:21:11.972]                             next
[10:21:11.972]                           if (!grepl(pattern, name)) 
[10:21:11.972]                             next
[10:21:11.972]                           invokeRestart(restart)
[10:21:11.972]                           muffled <- TRUE
[10:21:11.972]                           break
[10:21:11.972]                         }
[10:21:11.972]                       }
[10:21:11.972]                     }
[10:21:11.972]                     invisible(muffled)
[10:21:11.972]                   }
[10:21:11.972]                   muffleCondition(cond)
[10:21:11.972]                 })
[10:21:11.972]             }))
[10:21:11.972]             future::FutureResult(value = ...future.value$value, 
[10:21:11.972]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:11.972]                   ...future.rng), globalenv = if (FALSE) 
[10:21:11.972]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:11.972]                     ...future.globalenv.names))
[10:21:11.972]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:11.972]         }, condition = base::local({
[10:21:11.972]             c <- base::c
[10:21:11.972]             inherits <- base::inherits
[10:21:11.972]             invokeRestart <- base::invokeRestart
[10:21:11.972]             length <- base::length
[10:21:11.972]             list <- base::list
[10:21:11.972]             seq.int <- base::seq.int
[10:21:11.972]             signalCondition <- base::signalCondition
[10:21:11.972]             sys.calls <- base::sys.calls
[10:21:11.972]             `[[` <- base::`[[`
[10:21:11.972]             `+` <- base::`+`
[10:21:11.972]             `<<-` <- base::`<<-`
[10:21:11.972]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:11.972]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:11.972]                   3L)]
[10:21:11.972]             }
[10:21:11.972]             function(cond) {
[10:21:11.972]                 is_error <- inherits(cond, "error")
[10:21:11.972]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:11.972]                   NULL)
[10:21:11.972]                 if (is_error) {
[10:21:11.972]                   sessionInformation <- function() {
[10:21:11.972]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:11.972]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:11.972]                       search = base::search(), system = base::Sys.info())
[10:21:11.972]                   }
[10:21:11.972]                   ...future.conditions[[length(...future.conditions) + 
[10:21:11.972]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:11.972]                     cond$call), session = sessionInformation(), 
[10:21:11.972]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:11.972]                   signalCondition(cond)
[10:21:11.972]                 }
[10:21:11.972]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:11.972]                 "immediateCondition"))) {
[10:21:11.972]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:11.972]                   ...future.conditions[[length(...future.conditions) + 
[10:21:11.972]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:11.972]                   if (TRUE && !signal) {
[10:21:11.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.972]                     {
[10:21:11.972]                       inherits <- base::inherits
[10:21:11.972]                       invokeRestart <- base::invokeRestart
[10:21:11.972]                       is.null <- base::is.null
[10:21:11.972]                       muffled <- FALSE
[10:21:11.972]                       if (inherits(cond, "message")) {
[10:21:11.972]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:11.972]                         if (muffled) 
[10:21:11.972]                           invokeRestart("muffleMessage")
[10:21:11.972]                       }
[10:21:11.972]                       else if (inherits(cond, "warning")) {
[10:21:11.972]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:11.972]                         if (muffled) 
[10:21:11.972]                           invokeRestart("muffleWarning")
[10:21:11.972]                       }
[10:21:11.972]                       else if (inherits(cond, "condition")) {
[10:21:11.972]                         if (!is.null(pattern)) {
[10:21:11.972]                           computeRestarts <- base::computeRestarts
[10:21:11.972]                           grepl <- base::grepl
[10:21:11.972]                           restarts <- computeRestarts(cond)
[10:21:11.972]                           for (restart in restarts) {
[10:21:11.972]                             name <- restart$name
[10:21:11.972]                             if (is.null(name)) 
[10:21:11.972]                               next
[10:21:11.972]                             if (!grepl(pattern, name)) 
[10:21:11.972]                               next
[10:21:11.972]                             invokeRestart(restart)
[10:21:11.972]                             muffled <- TRUE
[10:21:11.972]                             break
[10:21:11.972]                           }
[10:21:11.972]                         }
[10:21:11.972]                       }
[10:21:11.972]                       invisible(muffled)
[10:21:11.972]                     }
[10:21:11.972]                     muffleCondition(cond, pattern = "^muffle")
[10:21:11.972]                   }
[10:21:11.972]                 }
[10:21:11.972]                 else {
[10:21:11.972]                   if (TRUE) {
[10:21:11.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:11.972]                     {
[10:21:11.972]                       inherits <- base::inherits
[10:21:11.972]                       invokeRestart <- base::invokeRestart
[10:21:11.972]                       is.null <- base::is.null
[10:21:11.972]                       muffled <- FALSE
[10:21:11.972]                       if (inherits(cond, "message")) {
[10:21:11.972]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:11.972]                         if (muffled) 
[10:21:11.972]                           invokeRestart("muffleMessage")
[10:21:11.972]                       }
[10:21:11.972]                       else if (inherits(cond, "warning")) {
[10:21:11.972]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:11.972]                         if (muffled) 
[10:21:11.972]                           invokeRestart("muffleWarning")
[10:21:11.972]                       }
[10:21:11.972]                       else if (inherits(cond, "condition")) {
[10:21:11.972]                         if (!is.null(pattern)) {
[10:21:11.972]                           computeRestarts <- base::computeRestarts
[10:21:11.972]                           grepl <- base::grepl
[10:21:11.972]                           restarts <- computeRestarts(cond)
[10:21:11.972]                           for (restart in restarts) {
[10:21:11.972]                             name <- restart$name
[10:21:11.972]                             if (is.null(name)) 
[10:21:11.972]                               next
[10:21:11.972]                             if (!grepl(pattern, name)) 
[10:21:11.972]                               next
[10:21:11.972]                             invokeRestart(restart)
[10:21:11.972]                             muffled <- TRUE
[10:21:11.972]                             break
[10:21:11.972]                           }
[10:21:11.972]                         }
[10:21:11.972]                       }
[10:21:11.972]                       invisible(muffled)
[10:21:11.972]                     }
[10:21:11.972]                     muffleCondition(cond, pattern = "^muffle")
[10:21:11.972]                   }
[10:21:11.972]                 }
[10:21:11.972]             }
[10:21:11.972]         }))
[10:21:11.972]     }, error = function(ex) {
[10:21:11.972]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:11.972]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:11.972]                 ...future.rng), started = ...future.startTime, 
[10:21:11.972]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:11.972]             version = "1.8"), class = "FutureResult")
[10:21:11.972]     }, finally = {
[10:21:11.972]         if (!identical(...future.workdir, getwd())) 
[10:21:11.972]             setwd(...future.workdir)
[10:21:11.972]         {
[10:21:11.972]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:11.972]                 ...future.oldOptions$nwarnings <- NULL
[10:21:11.972]             }
[10:21:11.972]             base::options(...future.oldOptions)
[10:21:11.972]             if (.Platform$OS.type == "windows") {
[10:21:11.972]                 old_names <- names(...future.oldEnvVars)
[10:21:11.972]                 envs <- base::Sys.getenv()
[10:21:11.972]                 names <- names(envs)
[10:21:11.972]                 common <- intersect(names, old_names)
[10:21:11.972]                 added <- setdiff(names, old_names)
[10:21:11.972]                 removed <- setdiff(old_names, names)
[10:21:11.972]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:11.972]                   envs[common]]
[10:21:11.972]                 NAMES <- toupper(changed)
[10:21:11.972]                 args <- list()
[10:21:11.972]                 for (kk in seq_along(NAMES)) {
[10:21:11.972]                   name <- changed[[kk]]
[10:21:11.972]                   NAME <- NAMES[[kk]]
[10:21:11.972]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.972]                     next
[10:21:11.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:11.972]                 }
[10:21:11.972]                 NAMES <- toupper(added)
[10:21:11.972]                 for (kk in seq_along(NAMES)) {
[10:21:11.972]                   name <- added[[kk]]
[10:21:11.972]                   NAME <- NAMES[[kk]]
[10:21:11.972]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.972]                     next
[10:21:11.972]                   args[[name]] <- ""
[10:21:11.972]                 }
[10:21:11.972]                 NAMES <- toupper(removed)
[10:21:11.972]                 for (kk in seq_along(NAMES)) {
[10:21:11.972]                   name <- removed[[kk]]
[10:21:11.972]                   NAME <- NAMES[[kk]]
[10:21:11.972]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:11.972]                     next
[10:21:11.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:11.972]                 }
[10:21:11.972]                 if (length(args) > 0) 
[10:21:11.972]                   base::do.call(base::Sys.setenv, args = args)
[10:21:11.972]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:11.972]             }
[10:21:11.972]             else {
[10:21:11.972]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:11.972]             }
[10:21:11.972]             {
[10:21:11.972]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:11.972]                   0L) {
[10:21:11.972]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:11.972]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:11.972]                   base::options(opts)
[10:21:11.972]                 }
[10:21:11.972]                 {
[10:21:11.972]                   {
[10:21:11.972]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:11.972]                     NULL
[10:21:11.972]                   }
[10:21:11.972]                   options(future.plan = NULL)
[10:21:11.972]                   if (is.na(NA_character_)) 
[10:21:11.972]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:11.972]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:11.972]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:11.972]                     .init = FALSE)
[10:21:11.972]                 }
[10:21:11.972]             }
[10:21:11.972]         }
[10:21:11.972]     })
[10:21:11.972]     if (TRUE) {
[10:21:11.972]         base::sink(type = "output", split = FALSE)
[10:21:11.972]         if (TRUE) {
[10:21:11.972]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:11.972]         }
[10:21:11.972]         else {
[10:21:11.972]             ...future.result["stdout"] <- base::list(NULL)
[10:21:11.972]         }
[10:21:11.972]         base::close(...future.stdout)
[10:21:11.972]         ...future.stdout <- NULL
[10:21:11.972]     }
[10:21:11.972]     ...future.result$conditions <- ...future.conditions
[10:21:11.972]     ...future.result$finished <- base::Sys.time()
[10:21:11.972]     ...future.result
[10:21:11.972] }
[10:21:11.975] MultisessionFuture started
[10:21:11.975] - Launch lazy future ... done
[10:21:11.975] run() for ‘MultisessionFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[10:21:11.975] result() for ClusterFuture ...
[10:21:11.975] - result already collected: FutureResult
[10:21:11.975] result() for ClusterFuture ... done
[10:21:11.976] result() for ClusterFuture ...
[10:21:11.976] - result already collected: FutureResult
[10:21:11.976] result() for ClusterFuture ... done
[10:21:11.976] signalConditions() ...
[10:21:11.976]  - include = ‘immediateCondition’
[10:21:11.976]  - exclude = 
[10:21:11.976]  - resignal = FALSE
[10:21:11.976]  - Number of conditions: 1
[10:21:11.976] signalConditions() ... done
[10:21:11.976] Future state: ‘finished’
[10:21:11.976] result() for ClusterFuture ...
[10:21:11.977] - result already collected: FutureResult
[10:21:11.977] result() for ClusterFuture ... done
[10:21:11.977] signalConditions() ...
[10:21:11.977]  - include = ‘condition’
[10:21:11.977]  - exclude = ‘immediateCondition’
[10:21:11.977]  - resignal = TRUE
[10:21:11.977]  - Number of conditions: 1
[10:21:11.977]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:11.977] signalConditions() ... done
v3: <simpleError> (as expect)
[10:21:11.977] result() for ClusterFuture ...
[10:21:11.977] receiveMessageFromWorker() for ClusterFuture ...
[10:21:11.978] - Validating connection of MultisessionFuture
[10:21:12.017] - received message: FutureResult
[10:21:12.017] - Received FutureResult
[10:21:12.017] - Erased future from FutureRegistry
[10:21:12.017] result() for ClusterFuture ...
[10:21:12.018] - result already collected: FutureResult
[10:21:12.018] result() for ClusterFuture ... done
[10:21:12.018] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:12.018] result() for ClusterFuture ... done
[10:21:12.018] result() for ClusterFuture ...
[10:21:12.018] - result already collected: FutureResult
[10:21:12.018] result() for ClusterFuture ... done
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[10:21:12.018] getGlobalsAndPackages() ...
[10:21:12.019] Searching for globals...
[10:21:12.019] 
[10:21:12.019] Searching for globals ... DONE
[10:21:12.019] - globals: [0] <none>
[10:21:12.019] getGlobalsAndPackages() ... DONE
[10:21:12.019] run() for ‘Future’ ...
[10:21:12.020] - state: ‘created’
[10:21:12.020] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:12.033] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:12.034] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:12.034]   - Field: ‘node’
[10:21:12.034]   - Field: ‘label’
[10:21:12.034]   - Field: ‘local’
[10:21:12.034]   - Field: ‘owner’
[10:21:12.034]   - Field: ‘envir’
[10:21:12.034]   - Field: ‘workers’
[10:21:12.034]   - Field: ‘packages’
[10:21:12.034]   - Field: ‘gc’
[10:21:12.034]   - Field: ‘conditions’
[10:21:12.035]   - Field: ‘persistent’
[10:21:12.035]   - Field: ‘expr’
[10:21:12.035]   - Field: ‘uuid’
[10:21:12.035]   - Field: ‘seed’
[10:21:12.035]   - Field: ‘version’
[10:21:12.035]   - Field: ‘result’
[10:21:12.035]   - Field: ‘asynchronous’
[10:21:12.035]   - Field: ‘calls’
[10:21:12.035]   - Field: ‘globals’
[10:21:12.035]   - Field: ‘stdout’
[10:21:12.035]   - Field: ‘earlySignal’
[10:21:12.035]   - Field: ‘lazy’
[10:21:12.036]   - Field: ‘state’
[10:21:12.036] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:12.036] - Launch lazy future ...
[10:21:12.036] Packages needed by the future expression (n = 0): <none>
[10:21:12.036] Packages needed by future strategies (n = 0): <none>
[10:21:12.037] {
[10:21:12.037]     {
[10:21:12.037]         {
[10:21:12.037]             ...future.startTime <- base::Sys.time()
[10:21:12.037]             {
[10:21:12.037]                 {
[10:21:12.037]                   {
[10:21:12.037]                     {
[10:21:12.037]                       base::local({
[10:21:12.037]                         has_future <- base::requireNamespace("future", 
[10:21:12.037]                           quietly = TRUE)
[10:21:12.037]                         if (has_future) {
[10:21:12.037]                           ns <- base::getNamespace("future")
[10:21:12.037]                           version <- ns[[".package"]][["version"]]
[10:21:12.037]                           if (is.null(version)) 
[10:21:12.037]                             version <- utils::packageVersion("future")
[10:21:12.037]                         }
[10:21:12.037]                         else {
[10:21:12.037]                           version <- NULL
[10:21:12.037]                         }
[10:21:12.037]                         if (!has_future || version < "1.8.0") {
[10:21:12.037]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:12.037]                             "", base::R.version$version.string), 
[10:21:12.037]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:12.037]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:12.037]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:12.037]                               "release", "version")], collapse = " "), 
[10:21:12.037]                             hostname = base::Sys.info()[["nodename"]])
[10:21:12.037]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:12.037]                             info)
[10:21:12.037]                           info <- base::paste(info, collapse = "; ")
[10:21:12.037]                           if (!has_future) {
[10:21:12.037]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:12.037]                               info)
[10:21:12.037]                           }
[10:21:12.037]                           else {
[10:21:12.037]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:12.037]                               info, version)
[10:21:12.037]                           }
[10:21:12.037]                           base::stop(msg)
[10:21:12.037]                         }
[10:21:12.037]                       })
[10:21:12.037]                     }
[10:21:12.037]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:12.037]                     base::options(mc.cores = 1L)
[10:21:12.037]                   }
[10:21:12.037]                   ...future.strategy.old <- future::plan("list")
[10:21:12.037]                   options(future.plan = NULL)
[10:21:12.037]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.037]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:12.037]                 }
[10:21:12.037]                 ...future.workdir <- getwd()
[10:21:12.037]             }
[10:21:12.037]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:12.037]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:12.037]         }
[10:21:12.037]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:12.037]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:12.037]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:12.037]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:12.037]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:12.037]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:12.037]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:12.037]             base::names(...future.oldOptions))
[10:21:12.037]     }
[10:21:12.037]     if (FALSE) {
[10:21:12.037]     }
[10:21:12.037]     else {
[10:21:12.037]         if (TRUE) {
[10:21:12.037]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:12.037]                 open = "w")
[10:21:12.037]         }
[10:21:12.037]         else {
[10:21:12.037]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:12.037]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:12.037]         }
[10:21:12.037]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:12.037]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:12.037]             base::sink(type = "output", split = FALSE)
[10:21:12.037]             base::close(...future.stdout)
[10:21:12.037]         }, add = TRUE)
[10:21:12.037]     }
[10:21:12.037]     ...future.frame <- base::sys.nframe()
[10:21:12.037]     ...future.conditions <- base::list()
[10:21:12.037]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:12.037]     if (FALSE) {
[10:21:12.037]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:12.037]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:12.037]     }
[10:21:12.037]     ...future.result <- base::tryCatch({
[10:21:12.037]         base::withCallingHandlers({
[10:21:12.037]             ...future.value <- base::withVisible(base::local({
[10:21:12.037]                 ...future.makeSendCondition <- base::local({
[10:21:12.037]                   sendCondition <- NULL
[10:21:12.037]                   function(frame = 1L) {
[10:21:12.037]                     if (is.function(sendCondition)) 
[10:21:12.037]                       return(sendCondition)
[10:21:12.037]                     ns <- getNamespace("parallel")
[10:21:12.037]                     if (exists("sendData", mode = "function", 
[10:21:12.037]                       envir = ns)) {
[10:21:12.037]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:12.037]                         envir = ns)
[10:21:12.037]                       envir <- sys.frame(frame)
[10:21:12.037]                       master <- NULL
[10:21:12.037]                       while (!identical(envir, .GlobalEnv) && 
[10:21:12.037]                         !identical(envir, emptyenv())) {
[10:21:12.037]                         if (exists("master", mode = "list", envir = envir, 
[10:21:12.037]                           inherits = FALSE)) {
[10:21:12.037]                           master <- get("master", mode = "list", 
[10:21:12.037]                             envir = envir, inherits = FALSE)
[10:21:12.037]                           if (inherits(master, c("SOCKnode", 
[10:21:12.037]                             "SOCK0node"))) {
[10:21:12.037]                             sendCondition <<- function(cond) {
[10:21:12.037]                               data <- list(type = "VALUE", value = cond, 
[10:21:12.037]                                 success = TRUE)
[10:21:12.037]                               parallel_sendData(master, data)
[10:21:12.037]                             }
[10:21:12.037]                             return(sendCondition)
[10:21:12.037]                           }
[10:21:12.037]                         }
[10:21:12.037]                         frame <- frame + 1L
[10:21:12.037]                         envir <- sys.frame(frame)
[10:21:12.037]                       }
[10:21:12.037]                     }
[10:21:12.037]                     sendCondition <<- function(cond) NULL
[10:21:12.037]                   }
[10:21:12.037]                 })
[10:21:12.037]                 withCallingHandlers({
[10:21:12.037]                   1
[10:21:12.037]                 }, immediateCondition = function(cond) {
[10:21:12.037]                   sendCondition <- ...future.makeSendCondition()
[10:21:12.037]                   sendCondition(cond)
[10:21:12.037]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.037]                   {
[10:21:12.037]                     inherits <- base::inherits
[10:21:12.037]                     invokeRestart <- base::invokeRestart
[10:21:12.037]                     is.null <- base::is.null
[10:21:12.037]                     muffled <- FALSE
[10:21:12.037]                     if (inherits(cond, "message")) {
[10:21:12.037]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:12.037]                       if (muffled) 
[10:21:12.037]                         invokeRestart("muffleMessage")
[10:21:12.037]                     }
[10:21:12.037]                     else if (inherits(cond, "warning")) {
[10:21:12.037]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:12.037]                       if (muffled) 
[10:21:12.037]                         invokeRestart("muffleWarning")
[10:21:12.037]                     }
[10:21:12.037]                     else if (inherits(cond, "condition")) {
[10:21:12.037]                       if (!is.null(pattern)) {
[10:21:12.037]                         computeRestarts <- base::computeRestarts
[10:21:12.037]                         grepl <- base::grepl
[10:21:12.037]                         restarts <- computeRestarts(cond)
[10:21:12.037]                         for (restart in restarts) {
[10:21:12.037]                           name <- restart$name
[10:21:12.037]                           if (is.null(name)) 
[10:21:12.037]                             next
[10:21:12.037]                           if (!grepl(pattern, name)) 
[10:21:12.037]                             next
[10:21:12.037]                           invokeRestart(restart)
[10:21:12.037]                           muffled <- TRUE
[10:21:12.037]                           break
[10:21:12.037]                         }
[10:21:12.037]                       }
[10:21:12.037]                     }
[10:21:12.037]                     invisible(muffled)
[10:21:12.037]                   }
[10:21:12.037]                   muffleCondition(cond)
[10:21:12.037]                 })
[10:21:12.037]             }))
[10:21:12.037]             future::FutureResult(value = ...future.value$value, 
[10:21:12.037]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.037]                   ...future.rng), globalenv = if (FALSE) 
[10:21:12.037]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:12.037]                     ...future.globalenv.names))
[10:21:12.037]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:12.037]         }, condition = base::local({
[10:21:12.037]             c <- base::c
[10:21:12.037]             inherits <- base::inherits
[10:21:12.037]             invokeRestart <- base::invokeRestart
[10:21:12.037]             length <- base::length
[10:21:12.037]             list <- base::list
[10:21:12.037]             seq.int <- base::seq.int
[10:21:12.037]             signalCondition <- base::signalCondition
[10:21:12.037]             sys.calls <- base::sys.calls
[10:21:12.037]             `[[` <- base::`[[`
[10:21:12.037]             `+` <- base::`+`
[10:21:12.037]             `<<-` <- base::`<<-`
[10:21:12.037]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:12.037]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:12.037]                   3L)]
[10:21:12.037]             }
[10:21:12.037]             function(cond) {
[10:21:12.037]                 is_error <- inherits(cond, "error")
[10:21:12.037]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:12.037]                   NULL)
[10:21:12.037]                 if (is_error) {
[10:21:12.037]                   sessionInformation <- function() {
[10:21:12.037]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:12.037]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:12.037]                       search = base::search(), system = base::Sys.info())
[10:21:12.037]                   }
[10:21:12.037]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.037]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:12.037]                     cond$call), session = sessionInformation(), 
[10:21:12.037]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:12.037]                   signalCondition(cond)
[10:21:12.037]                 }
[10:21:12.037]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:12.037]                 "immediateCondition"))) {
[10:21:12.037]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:12.037]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.037]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:12.037]                   if (TRUE && !signal) {
[10:21:12.037]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.037]                     {
[10:21:12.037]                       inherits <- base::inherits
[10:21:12.037]                       invokeRestart <- base::invokeRestart
[10:21:12.037]                       is.null <- base::is.null
[10:21:12.037]                       muffled <- FALSE
[10:21:12.037]                       if (inherits(cond, "message")) {
[10:21:12.037]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.037]                         if (muffled) 
[10:21:12.037]                           invokeRestart("muffleMessage")
[10:21:12.037]                       }
[10:21:12.037]                       else if (inherits(cond, "warning")) {
[10:21:12.037]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.037]                         if (muffled) 
[10:21:12.037]                           invokeRestart("muffleWarning")
[10:21:12.037]                       }
[10:21:12.037]                       else if (inherits(cond, "condition")) {
[10:21:12.037]                         if (!is.null(pattern)) {
[10:21:12.037]                           computeRestarts <- base::computeRestarts
[10:21:12.037]                           grepl <- base::grepl
[10:21:12.037]                           restarts <- computeRestarts(cond)
[10:21:12.037]                           for (restart in restarts) {
[10:21:12.037]                             name <- restart$name
[10:21:12.037]                             if (is.null(name)) 
[10:21:12.037]                               next
[10:21:12.037]                             if (!grepl(pattern, name)) 
[10:21:12.037]                               next
[10:21:12.037]                             invokeRestart(restart)
[10:21:12.037]                             muffled <- TRUE
[10:21:12.037]                             break
[10:21:12.037]                           }
[10:21:12.037]                         }
[10:21:12.037]                       }
[10:21:12.037]                       invisible(muffled)
[10:21:12.037]                     }
[10:21:12.037]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.037]                   }
[10:21:12.037]                 }
[10:21:12.037]                 else {
[10:21:12.037]                   if (TRUE) {
[10:21:12.037]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.037]                     {
[10:21:12.037]                       inherits <- base::inherits
[10:21:12.037]                       invokeRestart <- base::invokeRestart
[10:21:12.037]                       is.null <- base::is.null
[10:21:12.037]                       muffled <- FALSE
[10:21:12.037]                       if (inherits(cond, "message")) {
[10:21:12.037]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.037]                         if (muffled) 
[10:21:12.037]                           invokeRestart("muffleMessage")
[10:21:12.037]                       }
[10:21:12.037]                       else if (inherits(cond, "warning")) {
[10:21:12.037]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.037]                         if (muffled) 
[10:21:12.037]                           invokeRestart("muffleWarning")
[10:21:12.037]                       }
[10:21:12.037]                       else if (inherits(cond, "condition")) {
[10:21:12.037]                         if (!is.null(pattern)) {
[10:21:12.037]                           computeRestarts <- base::computeRestarts
[10:21:12.037]                           grepl <- base::grepl
[10:21:12.037]                           restarts <- computeRestarts(cond)
[10:21:12.037]                           for (restart in restarts) {
[10:21:12.037]                             name <- restart$name
[10:21:12.037]                             if (is.null(name)) 
[10:21:12.037]                               next
[10:21:12.037]                             if (!grepl(pattern, name)) 
[10:21:12.037]                               next
[10:21:12.037]                             invokeRestart(restart)
[10:21:12.037]                             muffled <- TRUE
[10:21:12.037]                             break
[10:21:12.037]                           }
[10:21:12.037]                         }
[10:21:12.037]                       }
[10:21:12.037]                       invisible(muffled)
[10:21:12.037]                     }
[10:21:12.037]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.037]                   }
[10:21:12.037]                 }
[10:21:12.037]             }
[10:21:12.037]         }))
[10:21:12.037]     }, error = function(ex) {
[10:21:12.037]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:12.037]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.037]                 ...future.rng), started = ...future.startTime, 
[10:21:12.037]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:12.037]             version = "1.8"), class = "FutureResult")
[10:21:12.037]     }, finally = {
[10:21:12.037]         if (!identical(...future.workdir, getwd())) 
[10:21:12.037]             setwd(...future.workdir)
[10:21:12.037]         {
[10:21:12.037]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:12.037]                 ...future.oldOptions$nwarnings <- NULL
[10:21:12.037]             }
[10:21:12.037]             base::options(...future.oldOptions)
[10:21:12.037]             if (.Platform$OS.type == "windows") {
[10:21:12.037]                 old_names <- names(...future.oldEnvVars)
[10:21:12.037]                 envs <- base::Sys.getenv()
[10:21:12.037]                 names <- names(envs)
[10:21:12.037]                 common <- intersect(names, old_names)
[10:21:12.037]                 added <- setdiff(names, old_names)
[10:21:12.037]                 removed <- setdiff(old_names, names)
[10:21:12.037]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:12.037]                   envs[common]]
[10:21:12.037]                 NAMES <- toupper(changed)
[10:21:12.037]                 args <- list()
[10:21:12.037]                 for (kk in seq_along(NAMES)) {
[10:21:12.037]                   name <- changed[[kk]]
[10:21:12.037]                   NAME <- NAMES[[kk]]
[10:21:12.037]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.037]                     next
[10:21:12.037]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.037]                 }
[10:21:12.037]                 NAMES <- toupper(added)
[10:21:12.037]                 for (kk in seq_along(NAMES)) {
[10:21:12.037]                   name <- added[[kk]]
[10:21:12.037]                   NAME <- NAMES[[kk]]
[10:21:12.037]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.037]                     next
[10:21:12.037]                   args[[name]] <- ""
[10:21:12.037]                 }
[10:21:12.037]                 NAMES <- toupper(removed)
[10:21:12.037]                 for (kk in seq_along(NAMES)) {
[10:21:12.037]                   name <- removed[[kk]]
[10:21:12.037]                   NAME <- NAMES[[kk]]
[10:21:12.037]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.037]                     next
[10:21:12.037]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.037]                 }
[10:21:12.037]                 if (length(args) > 0) 
[10:21:12.037]                   base::do.call(base::Sys.setenv, args = args)
[10:21:12.037]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:12.037]             }
[10:21:12.037]             else {
[10:21:12.037]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:12.037]             }
[10:21:12.037]             {
[10:21:12.037]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:12.037]                   0L) {
[10:21:12.037]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:12.037]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:12.037]                   base::options(opts)
[10:21:12.037]                 }
[10:21:12.037]                 {
[10:21:12.037]                   {
[10:21:12.037]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:12.037]                     NULL
[10:21:12.037]                   }
[10:21:12.037]                   options(future.plan = NULL)
[10:21:12.037]                   if (is.na(NA_character_)) 
[10:21:12.037]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.037]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:12.037]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:12.037]                     .init = FALSE)
[10:21:12.037]                 }
[10:21:12.037]             }
[10:21:12.037]         }
[10:21:12.037]     })
[10:21:12.037]     if (TRUE) {
[10:21:12.037]         base::sink(type = "output", split = FALSE)
[10:21:12.037]         if (TRUE) {
[10:21:12.037]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:12.037]         }
[10:21:12.037]         else {
[10:21:12.037]             ...future.result["stdout"] <- base::list(NULL)
[10:21:12.037]         }
[10:21:12.037]         base::close(...future.stdout)
[10:21:12.037]         ...future.stdout <- NULL
[10:21:12.037]     }
[10:21:12.037]     ...future.result$conditions <- ...future.conditions
[10:21:12.037]     ...future.result$finished <- base::Sys.time()
[10:21:12.037]     ...future.result
[10:21:12.037] }
[10:21:12.039] MultisessionFuture started
[10:21:12.040] - Launch lazy future ... done
[10:21:12.040] run() for ‘MultisessionFuture’ ... done
[10:21:12.040] result() for ClusterFuture ...
[10:21:12.040] receiveMessageFromWorker() for ClusterFuture ...
[10:21:12.040] - Validating connection of MultisessionFuture
[10:21:12.082] - received message: FutureResult
[10:21:12.082] - Received FutureResult
[10:21:12.082] - Erased future from FutureRegistry
[10:21:12.082] result() for ClusterFuture ...
[10:21:12.083] - result already collected: FutureResult
[10:21:12.083] result() for ClusterFuture ... done
[10:21:12.083] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:12.083] result() for ClusterFuture ... done
[10:21:12.083] result() for ClusterFuture ...
[10:21:12.083] - result already collected: FutureResult
[10:21:12.083] result() for ClusterFuture ... done
c = 1
[10:21:12.083] getGlobalsAndPackages() ...
[10:21:12.083] Searching for globals...
[10:21:12.084] 
[10:21:12.084] Searching for globals ... DONE
[10:21:12.084] - globals: [0] <none>
[10:21:12.084] getGlobalsAndPackages() ... DONE
[10:21:12.084] run() for ‘Future’ ...
[10:21:12.084] - state: ‘created’
[10:21:12.085] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:12.099] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:12.099] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:12.099]   - Field: ‘node’
[10:21:12.099]   - Field: ‘label’
[10:21:12.099]   - Field: ‘local’
[10:21:12.099]   - Field: ‘owner’
[10:21:12.099]   - Field: ‘envir’
[10:21:12.099]   - Field: ‘workers’
[10:21:12.099]   - Field: ‘packages’
[10:21:12.099]   - Field: ‘gc’
[10:21:12.100]   - Field: ‘conditions’
[10:21:12.100]   - Field: ‘persistent’
[10:21:12.100]   - Field: ‘expr’
[10:21:12.100]   - Field: ‘uuid’
[10:21:12.100]   - Field: ‘seed’
[10:21:12.100]   - Field: ‘version’
[10:21:12.100]   - Field: ‘result’
[10:21:12.100]   - Field: ‘asynchronous’
[10:21:12.100]   - Field: ‘calls’
[10:21:12.100]   - Field: ‘globals’
[10:21:12.100]   - Field: ‘stdout’
[10:21:12.101]   - Field: ‘earlySignal’
[10:21:12.101]   - Field: ‘lazy’
[10:21:12.101]   - Field: ‘state’
[10:21:12.101] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:12.101] - Launch lazy future ...
[10:21:12.101] Packages needed by the future expression (n = 0): <none>
[10:21:12.101] Packages needed by future strategies (n = 0): <none>
[10:21:12.102] {
[10:21:12.102]     {
[10:21:12.102]         {
[10:21:12.102]             ...future.startTime <- base::Sys.time()
[10:21:12.102]             {
[10:21:12.102]                 {
[10:21:12.102]                   {
[10:21:12.102]                     {
[10:21:12.102]                       base::local({
[10:21:12.102]                         has_future <- base::requireNamespace("future", 
[10:21:12.102]                           quietly = TRUE)
[10:21:12.102]                         if (has_future) {
[10:21:12.102]                           ns <- base::getNamespace("future")
[10:21:12.102]                           version <- ns[[".package"]][["version"]]
[10:21:12.102]                           if (is.null(version)) 
[10:21:12.102]                             version <- utils::packageVersion("future")
[10:21:12.102]                         }
[10:21:12.102]                         else {
[10:21:12.102]                           version <- NULL
[10:21:12.102]                         }
[10:21:12.102]                         if (!has_future || version < "1.8.0") {
[10:21:12.102]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:12.102]                             "", base::R.version$version.string), 
[10:21:12.102]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:12.102]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:12.102]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:12.102]                               "release", "version")], collapse = " "), 
[10:21:12.102]                             hostname = base::Sys.info()[["nodename"]])
[10:21:12.102]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:12.102]                             info)
[10:21:12.102]                           info <- base::paste(info, collapse = "; ")
[10:21:12.102]                           if (!has_future) {
[10:21:12.102]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:12.102]                               info)
[10:21:12.102]                           }
[10:21:12.102]                           else {
[10:21:12.102]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:12.102]                               info, version)
[10:21:12.102]                           }
[10:21:12.102]                           base::stop(msg)
[10:21:12.102]                         }
[10:21:12.102]                       })
[10:21:12.102]                     }
[10:21:12.102]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:12.102]                     base::options(mc.cores = 1L)
[10:21:12.102]                   }
[10:21:12.102]                   ...future.strategy.old <- future::plan("list")
[10:21:12.102]                   options(future.plan = NULL)
[10:21:12.102]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.102]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:12.102]                 }
[10:21:12.102]                 ...future.workdir <- getwd()
[10:21:12.102]             }
[10:21:12.102]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:12.102]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:12.102]         }
[10:21:12.102]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:12.102]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:12.102]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:12.102]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:12.102]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:12.102]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:12.102]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:12.102]             base::names(...future.oldOptions))
[10:21:12.102]     }
[10:21:12.102]     if (FALSE) {
[10:21:12.102]     }
[10:21:12.102]     else {
[10:21:12.102]         if (TRUE) {
[10:21:12.102]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:12.102]                 open = "w")
[10:21:12.102]         }
[10:21:12.102]         else {
[10:21:12.102]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:12.102]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:12.102]         }
[10:21:12.102]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:12.102]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:12.102]             base::sink(type = "output", split = FALSE)
[10:21:12.102]             base::close(...future.stdout)
[10:21:12.102]         }, add = TRUE)
[10:21:12.102]     }
[10:21:12.102]     ...future.frame <- base::sys.nframe()
[10:21:12.102]     ...future.conditions <- base::list()
[10:21:12.102]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:12.102]     if (FALSE) {
[10:21:12.102]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:12.102]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:12.102]     }
[10:21:12.102]     ...future.result <- base::tryCatch({
[10:21:12.102]         base::withCallingHandlers({
[10:21:12.102]             ...future.value <- base::withVisible(base::local({
[10:21:12.102]                 ...future.makeSendCondition <- base::local({
[10:21:12.102]                   sendCondition <- NULL
[10:21:12.102]                   function(frame = 1L) {
[10:21:12.102]                     if (is.function(sendCondition)) 
[10:21:12.102]                       return(sendCondition)
[10:21:12.102]                     ns <- getNamespace("parallel")
[10:21:12.102]                     if (exists("sendData", mode = "function", 
[10:21:12.102]                       envir = ns)) {
[10:21:12.102]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:12.102]                         envir = ns)
[10:21:12.102]                       envir <- sys.frame(frame)
[10:21:12.102]                       master <- NULL
[10:21:12.102]                       while (!identical(envir, .GlobalEnv) && 
[10:21:12.102]                         !identical(envir, emptyenv())) {
[10:21:12.102]                         if (exists("master", mode = "list", envir = envir, 
[10:21:12.102]                           inherits = FALSE)) {
[10:21:12.102]                           master <- get("master", mode = "list", 
[10:21:12.102]                             envir = envir, inherits = FALSE)
[10:21:12.102]                           if (inherits(master, c("SOCKnode", 
[10:21:12.102]                             "SOCK0node"))) {
[10:21:12.102]                             sendCondition <<- function(cond) {
[10:21:12.102]                               data <- list(type = "VALUE", value = cond, 
[10:21:12.102]                                 success = TRUE)
[10:21:12.102]                               parallel_sendData(master, data)
[10:21:12.102]                             }
[10:21:12.102]                             return(sendCondition)
[10:21:12.102]                           }
[10:21:12.102]                         }
[10:21:12.102]                         frame <- frame + 1L
[10:21:12.102]                         envir <- sys.frame(frame)
[10:21:12.102]                       }
[10:21:12.102]                     }
[10:21:12.102]                     sendCondition <<- function(cond) NULL
[10:21:12.102]                   }
[10:21:12.102]                 })
[10:21:12.102]                 withCallingHandlers({
[10:21:12.102]                   1
[10:21:12.102]                 }, immediateCondition = function(cond) {
[10:21:12.102]                   sendCondition <- ...future.makeSendCondition()
[10:21:12.102]                   sendCondition(cond)
[10:21:12.102]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.102]                   {
[10:21:12.102]                     inherits <- base::inherits
[10:21:12.102]                     invokeRestart <- base::invokeRestart
[10:21:12.102]                     is.null <- base::is.null
[10:21:12.102]                     muffled <- FALSE
[10:21:12.102]                     if (inherits(cond, "message")) {
[10:21:12.102]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:12.102]                       if (muffled) 
[10:21:12.102]                         invokeRestart("muffleMessage")
[10:21:12.102]                     }
[10:21:12.102]                     else if (inherits(cond, "warning")) {
[10:21:12.102]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:12.102]                       if (muffled) 
[10:21:12.102]                         invokeRestart("muffleWarning")
[10:21:12.102]                     }
[10:21:12.102]                     else if (inherits(cond, "condition")) {
[10:21:12.102]                       if (!is.null(pattern)) {
[10:21:12.102]                         computeRestarts <- base::computeRestarts
[10:21:12.102]                         grepl <- base::grepl
[10:21:12.102]                         restarts <- computeRestarts(cond)
[10:21:12.102]                         for (restart in restarts) {
[10:21:12.102]                           name <- restart$name
[10:21:12.102]                           if (is.null(name)) 
[10:21:12.102]                             next
[10:21:12.102]                           if (!grepl(pattern, name)) 
[10:21:12.102]                             next
[10:21:12.102]                           invokeRestart(restart)
[10:21:12.102]                           muffled <- TRUE
[10:21:12.102]                           break
[10:21:12.102]                         }
[10:21:12.102]                       }
[10:21:12.102]                     }
[10:21:12.102]                     invisible(muffled)
[10:21:12.102]                   }
[10:21:12.102]                   muffleCondition(cond)
[10:21:12.102]                 })
[10:21:12.102]             }))
[10:21:12.102]             future::FutureResult(value = ...future.value$value, 
[10:21:12.102]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.102]                   ...future.rng), globalenv = if (FALSE) 
[10:21:12.102]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:12.102]                     ...future.globalenv.names))
[10:21:12.102]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:12.102]         }, condition = base::local({
[10:21:12.102]             c <- base::c
[10:21:12.102]             inherits <- base::inherits
[10:21:12.102]             invokeRestart <- base::invokeRestart
[10:21:12.102]             length <- base::length
[10:21:12.102]             list <- base::list
[10:21:12.102]             seq.int <- base::seq.int
[10:21:12.102]             signalCondition <- base::signalCondition
[10:21:12.102]             sys.calls <- base::sys.calls
[10:21:12.102]             `[[` <- base::`[[`
[10:21:12.102]             `+` <- base::`+`
[10:21:12.102]             `<<-` <- base::`<<-`
[10:21:12.102]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:12.102]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:12.102]                   3L)]
[10:21:12.102]             }
[10:21:12.102]             function(cond) {
[10:21:12.102]                 is_error <- inherits(cond, "error")
[10:21:12.102]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:12.102]                   NULL)
[10:21:12.102]                 if (is_error) {
[10:21:12.102]                   sessionInformation <- function() {
[10:21:12.102]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:12.102]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:12.102]                       search = base::search(), system = base::Sys.info())
[10:21:12.102]                   }
[10:21:12.102]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.102]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:12.102]                     cond$call), session = sessionInformation(), 
[10:21:12.102]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:12.102]                   signalCondition(cond)
[10:21:12.102]                 }
[10:21:12.102]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:12.102]                 "immediateCondition"))) {
[10:21:12.102]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:12.102]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.102]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:12.102]                   if (TRUE && !signal) {
[10:21:12.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.102]                     {
[10:21:12.102]                       inherits <- base::inherits
[10:21:12.102]                       invokeRestart <- base::invokeRestart
[10:21:12.102]                       is.null <- base::is.null
[10:21:12.102]                       muffled <- FALSE
[10:21:12.102]                       if (inherits(cond, "message")) {
[10:21:12.102]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.102]                         if (muffled) 
[10:21:12.102]                           invokeRestart("muffleMessage")
[10:21:12.102]                       }
[10:21:12.102]                       else if (inherits(cond, "warning")) {
[10:21:12.102]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.102]                         if (muffled) 
[10:21:12.102]                           invokeRestart("muffleWarning")
[10:21:12.102]                       }
[10:21:12.102]                       else if (inherits(cond, "condition")) {
[10:21:12.102]                         if (!is.null(pattern)) {
[10:21:12.102]                           computeRestarts <- base::computeRestarts
[10:21:12.102]                           grepl <- base::grepl
[10:21:12.102]                           restarts <- computeRestarts(cond)
[10:21:12.102]                           for (restart in restarts) {
[10:21:12.102]                             name <- restart$name
[10:21:12.102]                             if (is.null(name)) 
[10:21:12.102]                               next
[10:21:12.102]                             if (!grepl(pattern, name)) 
[10:21:12.102]                               next
[10:21:12.102]                             invokeRestart(restart)
[10:21:12.102]                             muffled <- TRUE
[10:21:12.102]                             break
[10:21:12.102]                           }
[10:21:12.102]                         }
[10:21:12.102]                       }
[10:21:12.102]                       invisible(muffled)
[10:21:12.102]                     }
[10:21:12.102]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.102]                   }
[10:21:12.102]                 }
[10:21:12.102]                 else {
[10:21:12.102]                   if (TRUE) {
[10:21:12.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.102]                     {
[10:21:12.102]                       inherits <- base::inherits
[10:21:12.102]                       invokeRestart <- base::invokeRestart
[10:21:12.102]                       is.null <- base::is.null
[10:21:12.102]                       muffled <- FALSE
[10:21:12.102]                       if (inherits(cond, "message")) {
[10:21:12.102]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.102]                         if (muffled) 
[10:21:12.102]                           invokeRestart("muffleMessage")
[10:21:12.102]                       }
[10:21:12.102]                       else if (inherits(cond, "warning")) {
[10:21:12.102]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.102]                         if (muffled) 
[10:21:12.102]                           invokeRestart("muffleWarning")
[10:21:12.102]                       }
[10:21:12.102]                       else if (inherits(cond, "condition")) {
[10:21:12.102]                         if (!is.null(pattern)) {
[10:21:12.102]                           computeRestarts <- base::computeRestarts
[10:21:12.102]                           grepl <- base::grepl
[10:21:12.102]                           restarts <- computeRestarts(cond)
[10:21:12.102]                           for (restart in restarts) {
[10:21:12.102]                             name <- restart$name
[10:21:12.102]                             if (is.null(name)) 
[10:21:12.102]                               next
[10:21:12.102]                             if (!grepl(pattern, name)) 
[10:21:12.102]                               next
[10:21:12.102]                             invokeRestart(restart)
[10:21:12.102]                             muffled <- TRUE
[10:21:12.102]                             break
[10:21:12.102]                           }
[10:21:12.102]                         }
[10:21:12.102]                       }
[10:21:12.102]                       invisible(muffled)
[10:21:12.102]                     }
[10:21:12.102]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.102]                   }
[10:21:12.102]                 }
[10:21:12.102]             }
[10:21:12.102]         }))
[10:21:12.102]     }, error = function(ex) {
[10:21:12.102]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:12.102]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.102]                 ...future.rng), started = ...future.startTime, 
[10:21:12.102]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:12.102]             version = "1.8"), class = "FutureResult")
[10:21:12.102]     }, finally = {
[10:21:12.102]         if (!identical(...future.workdir, getwd())) 
[10:21:12.102]             setwd(...future.workdir)
[10:21:12.102]         {
[10:21:12.102]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:12.102]                 ...future.oldOptions$nwarnings <- NULL
[10:21:12.102]             }
[10:21:12.102]             base::options(...future.oldOptions)
[10:21:12.102]             if (.Platform$OS.type == "windows") {
[10:21:12.102]                 old_names <- names(...future.oldEnvVars)
[10:21:12.102]                 envs <- base::Sys.getenv()
[10:21:12.102]                 names <- names(envs)
[10:21:12.102]                 common <- intersect(names, old_names)
[10:21:12.102]                 added <- setdiff(names, old_names)
[10:21:12.102]                 removed <- setdiff(old_names, names)
[10:21:12.102]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:12.102]                   envs[common]]
[10:21:12.102]                 NAMES <- toupper(changed)
[10:21:12.102]                 args <- list()
[10:21:12.102]                 for (kk in seq_along(NAMES)) {
[10:21:12.102]                   name <- changed[[kk]]
[10:21:12.102]                   NAME <- NAMES[[kk]]
[10:21:12.102]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.102]                     next
[10:21:12.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.102]                 }
[10:21:12.102]                 NAMES <- toupper(added)
[10:21:12.102]                 for (kk in seq_along(NAMES)) {
[10:21:12.102]                   name <- added[[kk]]
[10:21:12.102]                   NAME <- NAMES[[kk]]
[10:21:12.102]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.102]                     next
[10:21:12.102]                   args[[name]] <- ""
[10:21:12.102]                 }
[10:21:12.102]                 NAMES <- toupper(removed)
[10:21:12.102]                 for (kk in seq_along(NAMES)) {
[10:21:12.102]                   name <- removed[[kk]]
[10:21:12.102]                   NAME <- NAMES[[kk]]
[10:21:12.102]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.102]                     next
[10:21:12.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.102]                 }
[10:21:12.102]                 if (length(args) > 0) 
[10:21:12.102]                   base::do.call(base::Sys.setenv, args = args)
[10:21:12.102]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:12.102]             }
[10:21:12.102]             else {
[10:21:12.102]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:12.102]             }
[10:21:12.102]             {
[10:21:12.102]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:12.102]                   0L) {
[10:21:12.102]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:12.102]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:12.102]                   base::options(opts)
[10:21:12.102]                 }
[10:21:12.102]                 {
[10:21:12.102]                   {
[10:21:12.102]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:12.102]                     NULL
[10:21:12.102]                   }
[10:21:12.102]                   options(future.plan = NULL)
[10:21:12.102]                   if (is.na(NA_character_)) 
[10:21:12.102]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.102]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:12.102]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:12.102]                     .init = FALSE)
[10:21:12.102]                 }
[10:21:12.102]             }
[10:21:12.102]         }
[10:21:12.102]     })
[10:21:12.102]     if (TRUE) {
[10:21:12.102]         base::sink(type = "output", split = FALSE)
[10:21:12.102]         if (TRUE) {
[10:21:12.102]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:12.102]         }
[10:21:12.102]         else {
[10:21:12.102]             ...future.result["stdout"] <- base::list(NULL)
[10:21:12.102]         }
[10:21:12.102]         base::close(...future.stdout)
[10:21:12.102]         ...future.stdout <- NULL
[10:21:12.102]     }
[10:21:12.102]     ...future.result$conditions <- ...future.conditions
[10:21:12.102]     ...future.result$finished <- base::Sys.time()
[10:21:12.102]     ...future.result
[10:21:12.102] }
[10:21:12.105] MultisessionFuture started
[10:21:12.105] - Launch lazy future ... done
[10:21:12.105] run() for ‘MultisessionFuture’ ... done
[10:21:12.105] result() for ClusterFuture ...
[10:21:12.105] receiveMessageFromWorker() for ClusterFuture ...
[10:21:12.105] - Validating connection of MultisessionFuture
[10:21:12.147] - received message: FutureResult
[10:21:12.147] - Received FutureResult
[10:21:12.147] - Erased future from FutureRegistry
[10:21:12.147] result() for ClusterFuture ...
[10:21:12.148] - result already collected: FutureResult
[10:21:12.148] result() for ClusterFuture ... done
[10:21:12.148] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:12.148] result() for ClusterFuture ... done
[10:21:12.148] result() for ClusterFuture ...
[10:21:12.148] - result already collected: FutureResult
[10:21:12.148] result() for ClusterFuture ... done
d = 1
** Nested future assignments
[10:21:12.148] getGlobalsAndPackages() ...
[10:21:12.149] Searching for globals...
[10:21:12.152] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[10:21:12.152] Searching for globals ... DONE
[10:21:12.152] Resolving globals: FALSE
[10:21:12.153] 
[10:21:12.153] - packages: [1] ‘future’
[10:21:12.153] getGlobalsAndPackages() ... DONE
[10:21:12.153] run() for ‘Future’ ...
[10:21:12.153] - state: ‘created’
[10:21:12.153] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:12.167] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:12.168] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:12.168]   - Field: ‘node’
[10:21:12.168]   - Field: ‘label’
[10:21:12.168]   - Field: ‘local’
[10:21:12.168]   - Field: ‘owner’
[10:21:12.168]   - Field: ‘envir’
[10:21:12.168]   - Field: ‘workers’
[10:21:12.168]   - Field: ‘packages’
[10:21:12.168]   - Field: ‘gc’
[10:21:12.168]   - Field: ‘conditions’
[10:21:12.168]   - Field: ‘persistent’
[10:21:12.169]   - Field: ‘expr’
[10:21:12.169]   - Field: ‘uuid’
[10:21:12.169]   - Field: ‘seed’
[10:21:12.169]   - Field: ‘version’
[10:21:12.169]   - Field: ‘result’
[10:21:12.169]   - Field: ‘asynchronous’
[10:21:12.169]   - Field: ‘calls’
[10:21:12.169]   - Field: ‘globals’
[10:21:12.169]   - Field: ‘stdout’
[10:21:12.169]   - Field: ‘earlySignal’
[10:21:12.169]   - Field: ‘lazy’
[10:21:12.169]   - Field: ‘state’
[10:21:12.170] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:12.170] - Launch lazy future ...
[10:21:12.170] Packages needed by the future expression (n = 1): ‘future’
[10:21:12.170] Packages needed by future strategies (n = 0): <none>
[10:21:12.171] {
[10:21:12.171]     {
[10:21:12.171]         {
[10:21:12.171]             ...future.startTime <- base::Sys.time()
[10:21:12.171]             {
[10:21:12.171]                 {
[10:21:12.171]                   {
[10:21:12.171]                     {
[10:21:12.171]                       {
[10:21:12.171]                         base::local({
[10:21:12.171]                           has_future <- base::requireNamespace("future", 
[10:21:12.171]                             quietly = TRUE)
[10:21:12.171]                           if (has_future) {
[10:21:12.171]                             ns <- base::getNamespace("future")
[10:21:12.171]                             version <- ns[[".package"]][["version"]]
[10:21:12.171]                             if (is.null(version)) 
[10:21:12.171]                               version <- utils::packageVersion("future")
[10:21:12.171]                           }
[10:21:12.171]                           else {
[10:21:12.171]                             version <- NULL
[10:21:12.171]                           }
[10:21:12.171]                           if (!has_future || version < "1.8.0") {
[10:21:12.171]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:12.171]                               "", base::R.version$version.string), 
[10:21:12.171]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:12.171]                                 base::R.version$platform, 8 * 
[10:21:12.171]                                   base::.Machine$sizeof.pointer), 
[10:21:12.171]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:12.171]                                 "release", "version")], collapse = " "), 
[10:21:12.171]                               hostname = base::Sys.info()[["nodename"]])
[10:21:12.171]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:12.171]                               info)
[10:21:12.171]                             info <- base::paste(info, collapse = "; ")
[10:21:12.171]                             if (!has_future) {
[10:21:12.171]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:12.171]                                 info)
[10:21:12.171]                             }
[10:21:12.171]                             else {
[10:21:12.171]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:12.171]                                 info, version)
[10:21:12.171]                             }
[10:21:12.171]                             base::stop(msg)
[10:21:12.171]                           }
[10:21:12.171]                         })
[10:21:12.171]                       }
[10:21:12.171]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:12.171]                       base::options(mc.cores = 1L)
[10:21:12.171]                     }
[10:21:12.171]                     base::local({
[10:21:12.171]                       for (pkg in "future") {
[10:21:12.171]                         base::loadNamespace(pkg)
[10:21:12.171]                         base::library(pkg, character.only = TRUE)
[10:21:12.171]                       }
[10:21:12.171]                     })
[10:21:12.171]                   }
[10:21:12.171]                   ...future.strategy.old <- future::plan("list")
[10:21:12.171]                   options(future.plan = NULL)
[10:21:12.171]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.171]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:12.171]                 }
[10:21:12.171]                 ...future.workdir <- getwd()
[10:21:12.171]             }
[10:21:12.171]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:12.171]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:12.171]         }
[10:21:12.171]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:12.171]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:12.171]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:12.171]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:12.171]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:12.171]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:12.171]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:12.171]             base::names(...future.oldOptions))
[10:21:12.171]     }
[10:21:12.171]     if (FALSE) {
[10:21:12.171]     }
[10:21:12.171]     else {
[10:21:12.171]         if (TRUE) {
[10:21:12.171]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:12.171]                 open = "w")
[10:21:12.171]         }
[10:21:12.171]         else {
[10:21:12.171]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:12.171]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:12.171]         }
[10:21:12.171]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:12.171]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:12.171]             base::sink(type = "output", split = FALSE)
[10:21:12.171]             base::close(...future.stdout)
[10:21:12.171]         }, add = TRUE)
[10:21:12.171]     }
[10:21:12.171]     ...future.frame <- base::sys.nframe()
[10:21:12.171]     ...future.conditions <- base::list()
[10:21:12.171]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:12.171]     if (FALSE) {
[10:21:12.171]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:12.171]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:12.171]     }
[10:21:12.171]     ...future.result <- base::tryCatch({
[10:21:12.171]         base::withCallingHandlers({
[10:21:12.171]             ...future.value <- base::withVisible(base::local({
[10:21:12.171]                 ...future.makeSendCondition <- base::local({
[10:21:12.171]                   sendCondition <- NULL
[10:21:12.171]                   function(frame = 1L) {
[10:21:12.171]                     if (is.function(sendCondition)) 
[10:21:12.171]                       return(sendCondition)
[10:21:12.171]                     ns <- getNamespace("parallel")
[10:21:12.171]                     if (exists("sendData", mode = "function", 
[10:21:12.171]                       envir = ns)) {
[10:21:12.171]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:12.171]                         envir = ns)
[10:21:12.171]                       envir <- sys.frame(frame)
[10:21:12.171]                       master <- NULL
[10:21:12.171]                       while (!identical(envir, .GlobalEnv) && 
[10:21:12.171]                         !identical(envir, emptyenv())) {
[10:21:12.171]                         if (exists("master", mode = "list", envir = envir, 
[10:21:12.171]                           inherits = FALSE)) {
[10:21:12.171]                           master <- get("master", mode = "list", 
[10:21:12.171]                             envir = envir, inherits = FALSE)
[10:21:12.171]                           if (inherits(master, c("SOCKnode", 
[10:21:12.171]                             "SOCK0node"))) {
[10:21:12.171]                             sendCondition <<- function(cond) {
[10:21:12.171]                               data <- list(type = "VALUE", value = cond, 
[10:21:12.171]                                 success = TRUE)
[10:21:12.171]                               parallel_sendData(master, data)
[10:21:12.171]                             }
[10:21:12.171]                             return(sendCondition)
[10:21:12.171]                           }
[10:21:12.171]                         }
[10:21:12.171]                         frame <- frame + 1L
[10:21:12.171]                         envir <- sys.frame(frame)
[10:21:12.171]                       }
[10:21:12.171]                     }
[10:21:12.171]                     sendCondition <<- function(cond) NULL
[10:21:12.171]                   }
[10:21:12.171]                 })
[10:21:12.171]                 withCallingHandlers({
[10:21:12.171]                   {
[10:21:12.171]                     b <- 1
[10:21:12.171]                     c %<-% 2
[10:21:12.171]                     d <- 3
[10:21:12.171]                     4 %->% e
[10:21:12.171]                     b + c + d + e
[10:21:12.171]                   }
[10:21:12.171]                 }, immediateCondition = function(cond) {
[10:21:12.171]                   sendCondition <- ...future.makeSendCondition()
[10:21:12.171]                   sendCondition(cond)
[10:21:12.171]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.171]                   {
[10:21:12.171]                     inherits <- base::inherits
[10:21:12.171]                     invokeRestart <- base::invokeRestart
[10:21:12.171]                     is.null <- base::is.null
[10:21:12.171]                     muffled <- FALSE
[10:21:12.171]                     if (inherits(cond, "message")) {
[10:21:12.171]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:12.171]                       if (muffled) 
[10:21:12.171]                         invokeRestart("muffleMessage")
[10:21:12.171]                     }
[10:21:12.171]                     else if (inherits(cond, "warning")) {
[10:21:12.171]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:12.171]                       if (muffled) 
[10:21:12.171]                         invokeRestart("muffleWarning")
[10:21:12.171]                     }
[10:21:12.171]                     else if (inherits(cond, "condition")) {
[10:21:12.171]                       if (!is.null(pattern)) {
[10:21:12.171]                         computeRestarts <- base::computeRestarts
[10:21:12.171]                         grepl <- base::grepl
[10:21:12.171]                         restarts <- computeRestarts(cond)
[10:21:12.171]                         for (restart in restarts) {
[10:21:12.171]                           name <- restart$name
[10:21:12.171]                           if (is.null(name)) 
[10:21:12.171]                             next
[10:21:12.171]                           if (!grepl(pattern, name)) 
[10:21:12.171]                             next
[10:21:12.171]                           invokeRestart(restart)
[10:21:12.171]                           muffled <- TRUE
[10:21:12.171]                           break
[10:21:12.171]                         }
[10:21:12.171]                       }
[10:21:12.171]                     }
[10:21:12.171]                     invisible(muffled)
[10:21:12.171]                   }
[10:21:12.171]                   muffleCondition(cond)
[10:21:12.171]                 })
[10:21:12.171]             }))
[10:21:12.171]             future::FutureResult(value = ...future.value$value, 
[10:21:12.171]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.171]                   ...future.rng), globalenv = if (FALSE) 
[10:21:12.171]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:12.171]                     ...future.globalenv.names))
[10:21:12.171]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:12.171]         }, condition = base::local({
[10:21:12.171]             c <- base::c
[10:21:12.171]             inherits <- base::inherits
[10:21:12.171]             invokeRestart <- base::invokeRestart
[10:21:12.171]             length <- base::length
[10:21:12.171]             list <- base::list
[10:21:12.171]             seq.int <- base::seq.int
[10:21:12.171]             signalCondition <- base::signalCondition
[10:21:12.171]             sys.calls <- base::sys.calls
[10:21:12.171]             `[[` <- base::`[[`
[10:21:12.171]             `+` <- base::`+`
[10:21:12.171]             `<<-` <- base::`<<-`
[10:21:12.171]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:12.171]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:12.171]                   3L)]
[10:21:12.171]             }
[10:21:12.171]             function(cond) {
[10:21:12.171]                 is_error <- inherits(cond, "error")
[10:21:12.171]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:12.171]                   NULL)
[10:21:12.171]                 if (is_error) {
[10:21:12.171]                   sessionInformation <- function() {
[10:21:12.171]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:12.171]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:12.171]                       search = base::search(), system = base::Sys.info())
[10:21:12.171]                   }
[10:21:12.171]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.171]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:12.171]                     cond$call), session = sessionInformation(), 
[10:21:12.171]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:12.171]                   signalCondition(cond)
[10:21:12.171]                 }
[10:21:12.171]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:12.171]                 "immediateCondition"))) {
[10:21:12.171]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:12.171]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.171]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:12.171]                   if (TRUE && !signal) {
[10:21:12.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.171]                     {
[10:21:12.171]                       inherits <- base::inherits
[10:21:12.171]                       invokeRestart <- base::invokeRestart
[10:21:12.171]                       is.null <- base::is.null
[10:21:12.171]                       muffled <- FALSE
[10:21:12.171]                       if (inherits(cond, "message")) {
[10:21:12.171]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.171]                         if (muffled) 
[10:21:12.171]                           invokeRestart("muffleMessage")
[10:21:12.171]                       }
[10:21:12.171]                       else if (inherits(cond, "warning")) {
[10:21:12.171]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.171]                         if (muffled) 
[10:21:12.171]                           invokeRestart("muffleWarning")
[10:21:12.171]                       }
[10:21:12.171]                       else if (inherits(cond, "condition")) {
[10:21:12.171]                         if (!is.null(pattern)) {
[10:21:12.171]                           computeRestarts <- base::computeRestarts
[10:21:12.171]                           grepl <- base::grepl
[10:21:12.171]                           restarts <- computeRestarts(cond)
[10:21:12.171]                           for (restart in restarts) {
[10:21:12.171]                             name <- restart$name
[10:21:12.171]                             if (is.null(name)) 
[10:21:12.171]                               next
[10:21:12.171]                             if (!grepl(pattern, name)) 
[10:21:12.171]                               next
[10:21:12.171]                             invokeRestart(restart)
[10:21:12.171]                             muffled <- TRUE
[10:21:12.171]                             break
[10:21:12.171]                           }
[10:21:12.171]                         }
[10:21:12.171]                       }
[10:21:12.171]                       invisible(muffled)
[10:21:12.171]                     }
[10:21:12.171]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.171]                   }
[10:21:12.171]                 }
[10:21:12.171]                 else {
[10:21:12.171]                   if (TRUE) {
[10:21:12.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.171]                     {
[10:21:12.171]                       inherits <- base::inherits
[10:21:12.171]                       invokeRestart <- base::invokeRestart
[10:21:12.171]                       is.null <- base::is.null
[10:21:12.171]                       muffled <- FALSE
[10:21:12.171]                       if (inherits(cond, "message")) {
[10:21:12.171]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.171]                         if (muffled) 
[10:21:12.171]                           invokeRestart("muffleMessage")
[10:21:12.171]                       }
[10:21:12.171]                       else if (inherits(cond, "warning")) {
[10:21:12.171]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.171]                         if (muffled) 
[10:21:12.171]                           invokeRestart("muffleWarning")
[10:21:12.171]                       }
[10:21:12.171]                       else if (inherits(cond, "condition")) {
[10:21:12.171]                         if (!is.null(pattern)) {
[10:21:12.171]                           computeRestarts <- base::computeRestarts
[10:21:12.171]                           grepl <- base::grepl
[10:21:12.171]                           restarts <- computeRestarts(cond)
[10:21:12.171]                           for (restart in restarts) {
[10:21:12.171]                             name <- restart$name
[10:21:12.171]                             if (is.null(name)) 
[10:21:12.171]                               next
[10:21:12.171]                             if (!grepl(pattern, name)) 
[10:21:12.171]                               next
[10:21:12.171]                             invokeRestart(restart)
[10:21:12.171]                             muffled <- TRUE
[10:21:12.171]                             break
[10:21:12.171]                           }
[10:21:12.171]                         }
[10:21:12.171]                       }
[10:21:12.171]                       invisible(muffled)
[10:21:12.171]                     }
[10:21:12.171]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.171]                   }
[10:21:12.171]                 }
[10:21:12.171]             }
[10:21:12.171]         }))
[10:21:12.171]     }, error = function(ex) {
[10:21:12.171]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:12.171]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.171]                 ...future.rng), started = ...future.startTime, 
[10:21:12.171]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:12.171]             version = "1.8"), class = "FutureResult")
[10:21:12.171]     }, finally = {
[10:21:12.171]         if (!identical(...future.workdir, getwd())) 
[10:21:12.171]             setwd(...future.workdir)
[10:21:12.171]         {
[10:21:12.171]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:12.171]                 ...future.oldOptions$nwarnings <- NULL
[10:21:12.171]             }
[10:21:12.171]             base::options(...future.oldOptions)
[10:21:12.171]             if (.Platform$OS.type == "windows") {
[10:21:12.171]                 old_names <- names(...future.oldEnvVars)
[10:21:12.171]                 envs <- base::Sys.getenv()
[10:21:12.171]                 names <- names(envs)
[10:21:12.171]                 common <- intersect(names, old_names)
[10:21:12.171]                 added <- setdiff(names, old_names)
[10:21:12.171]                 removed <- setdiff(old_names, names)
[10:21:12.171]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:12.171]                   envs[common]]
[10:21:12.171]                 NAMES <- toupper(changed)
[10:21:12.171]                 args <- list()
[10:21:12.171]                 for (kk in seq_along(NAMES)) {
[10:21:12.171]                   name <- changed[[kk]]
[10:21:12.171]                   NAME <- NAMES[[kk]]
[10:21:12.171]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.171]                     next
[10:21:12.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.171]                 }
[10:21:12.171]                 NAMES <- toupper(added)
[10:21:12.171]                 for (kk in seq_along(NAMES)) {
[10:21:12.171]                   name <- added[[kk]]
[10:21:12.171]                   NAME <- NAMES[[kk]]
[10:21:12.171]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.171]                     next
[10:21:12.171]                   args[[name]] <- ""
[10:21:12.171]                 }
[10:21:12.171]                 NAMES <- toupper(removed)
[10:21:12.171]                 for (kk in seq_along(NAMES)) {
[10:21:12.171]                   name <- removed[[kk]]
[10:21:12.171]                   NAME <- NAMES[[kk]]
[10:21:12.171]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.171]                     next
[10:21:12.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.171]                 }
[10:21:12.171]                 if (length(args) > 0) 
[10:21:12.171]                   base::do.call(base::Sys.setenv, args = args)
[10:21:12.171]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:12.171]             }
[10:21:12.171]             else {
[10:21:12.171]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:12.171]             }
[10:21:12.171]             {
[10:21:12.171]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:12.171]                   0L) {
[10:21:12.171]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:12.171]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:12.171]                   base::options(opts)
[10:21:12.171]                 }
[10:21:12.171]                 {
[10:21:12.171]                   {
[10:21:12.171]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:12.171]                     NULL
[10:21:12.171]                   }
[10:21:12.171]                   options(future.plan = NULL)
[10:21:12.171]                   if (is.na(NA_character_)) 
[10:21:12.171]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.171]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:12.171]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:12.171]                     .init = FALSE)
[10:21:12.171]                 }
[10:21:12.171]             }
[10:21:12.171]         }
[10:21:12.171]     })
[10:21:12.171]     if (TRUE) {
[10:21:12.171]         base::sink(type = "output", split = FALSE)
[10:21:12.171]         if (TRUE) {
[10:21:12.171]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:12.171]         }
[10:21:12.171]         else {
[10:21:12.171]             ...future.result["stdout"] <- base::list(NULL)
[10:21:12.171]         }
[10:21:12.171]         base::close(...future.stdout)
[10:21:12.171]         ...future.stdout <- NULL
[10:21:12.171]     }
[10:21:12.171]     ...future.result$conditions <- ...future.conditions
[10:21:12.171]     ...future.result$finished <- base::Sys.time()
[10:21:12.171]     ...future.result
[10:21:12.171] }
[10:21:12.174] MultisessionFuture started
[10:21:12.174] - Launch lazy future ... done
[10:21:12.174] run() for ‘MultisessionFuture’ ... done
[10:21:12.174] result() for ClusterFuture ...
[10:21:12.174] receiveMessageFromWorker() for ClusterFuture ...
[10:21:12.174] - Validating connection of MultisessionFuture
[10:21:12.229] - received message: FutureResult
[10:21:12.230] - Received FutureResult
[10:21:12.230] - Erased future from FutureRegistry
[10:21:12.230] result() for ClusterFuture ...
[10:21:12.230] - result already collected: FutureResult
[10:21:12.230] result() for ClusterFuture ... done
[10:21:12.230] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:12.230] result() for ClusterFuture ... done
[10:21:12.230] result() for ClusterFuture ...
[10:21:12.231] - result already collected: FutureResult
[10:21:12.231] result() for ClusterFuture ... done
a = 10
[10:21:12.231] getGlobalsAndPackages() ...
[10:21:12.231] Searching for globals...
[10:21:12.238] - globals found: [3] ‘{’, ‘+’, ‘a’
[10:21:12.238] Searching for globals ... DONE
[10:21:12.238] Resolving globals: FALSE
[10:21:12.239] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:12.239] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:12.239] - globals: [1] ‘a’
[10:21:12.239] 
[10:21:12.239] getGlobalsAndPackages() ... DONE
[10:21:12.240] run() for ‘Future’ ...
[10:21:12.240] - state: ‘created’
[10:21:12.240] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:12.254] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:12.254] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:12.254]   - Field: ‘node’
[10:21:12.254]   - Field: ‘label’
[10:21:12.254]   - Field: ‘local’
[10:21:12.254]   - Field: ‘owner’
[10:21:12.254]   - Field: ‘envir’
[10:21:12.254]   - Field: ‘workers’
[10:21:12.254]   - Field: ‘packages’
[10:21:12.255]   - Field: ‘gc’
[10:21:12.255]   - Field: ‘conditions’
[10:21:12.255]   - Field: ‘persistent’
[10:21:12.255]   - Field: ‘expr’
[10:21:12.255]   - Field: ‘uuid’
[10:21:12.255]   - Field: ‘seed’
[10:21:12.255]   - Field: ‘version’
[10:21:12.255]   - Field: ‘result’
[10:21:12.255]   - Field: ‘asynchronous’
[10:21:12.255]   - Field: ‘calls’
[10:21:12.255]   - Field: ‘globals’
[10:21:12.255]   - Field: ‘stdout’
[10:21:12.256]   - Field: ‘earlySignal’
[10:21:12.256]   - Field: ‘lazy’
[10:21:12.256]   - Field: ‘state’
[10:21:12.256] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:12.256] - Launch lazy future ...
[10:21:12.256] Packages needed by the future expression (n = 0): <none>
[10:21:12.256] Packages needed by future strategies (n = 0): <none>
[10:21:12.257] {
[10:21:12.257]     {
[10:21:12.257]         {
[10:21:12.257]             ...future.startTime <- base::Sys.time()
[10:21:12.257]             {
[10:21:12.257]                 {
[10:21:12.257]                   {
[10:21:12.257]                     {
[10:21:12.257]                       base::local({
[10:21:12.257]                         has_future <- base::requireNamespace("future", 
[10:21:12.257]                           quietly = TRUE)
[10:21:12.257]                         if (has_future) {
[10:21:12.257]                           ns <- base::getNamespace("future")
[10:21:12.257]                           version <- ns[[".package"]][["version"]]
[10:21:12.257]                           if (is.null(version)) 
[10:21:12.257]                             version <- utils::packageVersion("future")
[10:21:12.257]                         }
[10:21:12.257]                         else {
[10:21:12.257]                           version <- NULL
[10:21:12.257]                         }
[10:21:12.257]                         if (!has_future || version < "1.8.0") {
[10:21:12.257]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:12.257]                             "", base::R.version$version.string), 
[10:21:12.257]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:12.257]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:12.257]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:12.257]                               "release", "version")], collapse = " "), 
[10:21:12.257]                             hostname = base::Sys.info()[["nodename"]])
[10:21:12.257]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:12.257]                             info)
[10:21:12.257]                           info <- base::paste(info, collapse = "; ")
[10:21:12.257]                           if (!has_future) {
[10:21:12.257]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:12.257]                               info)
[10:21:12.257]                           }
[10:21:12.257]                           else {
[10:21:12.257]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:12.257]                               info, version)
[10:21:12.257]                           }
[10:21:12.257]                           base::stop(msg)
[10:21:12.257]                         }
[10:21:12.257]                       })
[10:21:12.257]                     }
[10:21:12.257]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:12.257]                     base::options(mc.cores = 1L)
[10:21:12.257]                   }
[10:21:12.257]                   ...future.strategy.old <- future::plan("list")
[10:21:12.257]                   options(future.plan = NULL)
[10:21:12.257]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.257]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:12.257]                 }
[10:21:12.257]                 ...future.workdir <- getwd()
[10:21:12.257]             }
[10:21:12.257]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:12.257]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:12.257]         }
[10:21:12.257]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:12.257]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:12.257]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:12.257]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:12.257]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:12.257]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:12.257]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:12.257]             base::names(...future.oldOptions))
[10:21:12.257]     }
[10:21:12.257]     if (FALSE) {
[10:21:12.257]     }
[10:21:12.257]     else {
[10:21:12.257]         if (TRUE) {
[10:21:12.257]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:12.257]                 open = "w")
[10:21:12.257]         }
[10:21:12.257]         else {
[10:21:12.257]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:12.257]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:12.257]         }
[10:21:12.257]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:12.257]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:12.257]             base::sink(type = "output", split = FALSE)
[10:21:12.257]             base::close(...future.stdout)
[10:21:12.257]         }, add = TRUE)
[10:21:12.257]     }
[10:21:12.257]     ...future.frame <- base::sys.nframe()
[10:21:12.257]     ...future.conditions <- base::list()
[10:21:12.257]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:12.257]     if (FALSE) {
[10:21:12.257]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:12.257]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:12.257]     }
[10:21:12.257]     ...future.result <- base::tryCatch({
[10:21:12.257]         base::withCallingHandlers({
[10:21:12.257]             ...future.value <- base::withVisible(base::local({
[10:21:12.257]                 ...future.makeSendCondition <- base::local({
[10:21:12.257]                   sendCondition <- NULL
[10:21:12.257]                   function(frame = 1L) {
[10:21:12.257]                     if (is.function(sendCondition)) 
[10:21:12.257]                       return(sendCondition)
[10:21:12.257]                     ns <- getNamespace("parallel")
[10:21:12.257]                     if (exists("sendData", mode = "function", 
[10:21:12.257]                       envir = ns)) {
[10:21:12.257]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:12.257]                         envir = ns)
[10:21:12.257]                       envir <- sys.frame(frame)
[10:21:12.257]                       master <- NULL
[10:21:12.257]                       while (!identical(envir, .GlobalEnv) && 
[10:21:12.257]                         !identical(envir, emptyenv())) {
[10:21:12.257]                         if (exists("master", mode = "list", envir = envir, 
[10:21:12.257]                           inherits = FALSE)) {
[10:21:12.257]                           master <- get("master", mode = "list", 
[10:21:12.257]                             envir = envir, inherits = FALSE)
[10:21:12.257]                           if (inherits(master, c("SOCKnode", 
[10:21:12.257]                             "SOCK0node"))) {
[10:21:12.257]                             sendCondition <<- function(cond) {
[10:21:12.257]                               data <- list(type = "VALUE", value = cond, 
[10:21:12.257]                                 success = TRUE)
[10:21:12.257]                               parallel_sendData(master, data)
[10:21:12.257]                             }
[10:21:12.257]                             return(sendCondition)
[10:21:12.257]                           }
[10:21:12.257]                         }
[10:21:12.257]                         frame <- frame + 1L
[10:21:12.257]                         envir <- sys.frame(frame)
[10:21:12.257]                       }
[10:21:12.257]                     }
[10:21:12.257]                     sendCondition <<- function(cond) NULL
[10:21:12.257]                   }
[10:21:12.257]                 })
[10:21:12.257]                 withCallingHandlers({
[10:21:12.257]                   {
[10:21:12.257]                     a + 1
[10:21:12.257]                   }
[10:21:12.257]                 }, immediateCondition = function(cond) {
[10:21:12.257]                   sendCondition <- ...future.makeSendCondition()
[10:21:12.257]                   sendCondition(cond)
[10:21:12.257]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.257]                   {
[10:21:12.257]                     inherits <- base::inherits
[10:21:12.257]                     invokeRestart <- base::invokeRestart
[10:21:12.257]                     is.null <- base::is.null
[10:21:12.257]                     muffled <- FALSE
[10:21:12.257]                     if (inherits(cond, "message")) {
[10:21:12.257]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:12.257]                       if (muffled) 
[10:21:12.257]                         invokeRestart("muffleMessage")
[10:21:12.257]                     }
[10:21:12.257]                     else if (inherits(cond, "warning")) {
[10:21:12.257]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:12.257]                       if (muffled) 
[10:21:12.257]                         invokeRestart("muffleWarning")
[10:21:12.257]                     }
[10:21:12.257]                     else if (inherits(cond, "condition")) {
[10:21:12.257]                       if (!is.null(pattern)) {
[10:21:12.257]                         computeRestarts <- base::computeRestarts
[10:21:12.257]                         grepl <- base::grepl
[10:21:12.257]                         restarts <- computeRestarts(cond)
[10:21:12.257]                         for (restart in restarts) {
[10:21:12.257]                           name <- restart$name
[10:21:12.257]                           if (is.null(name)) 
[10:21:12.257]                             next
[10:21:12.257]                           if (!grepl(pattern, name)) 
[10:21:12.257]                             next
[10:21:12.257]                           invokeRestart(restart)
[10:21:12.257]                           muffled <- TRUE
[10:21:12.257]                           break
[10:21:12.257]                         }
[10:21:12.257]                       }
[10:21:12.257]                     }
[10:21:12.257]                     invisible(muffled)
[10:21:12.257]                   }
[10:21:12.257]                   muffleCondition(cond)
[10:21:12.257]                 })
[10:21:12.257]             }))
[10:21:12.257]             future::FutureResult(value = ...future.value$value, 
[10:21:12.257]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.257]                   ...future.rng), globalenv = if (FALSE) 
[10:21:12.257]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:12.257]                     ...future.globalenv.names))
[10:21:12.257]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:12.257]         }, condition = base::local({
[10:21:12.257]             c <- base::c
[10:21:12.257]             inherits <- base::inherits
[10:21:12.257]             invokeRestart <- base::invokeRestart
[10:21:12.257]             length <- base::length
[10:21:12.257]             list <- base::list
[10:21:12.257]             seq.int <- base::seq.int
[10:21:12.257]             signalCondition <- base::signalCondition
[10:21:12.257]             sys.calls <- base::sys.calls
[10:21:12.257]             `[[` <- base::`[[`
[10:21:12.257]             `+` <- base::`+`
[10:21:12.257]             `<<-` <- base::`<<-`
[10:21:12.257]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:12.257]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:12.257]                   3L)]
[10:21:12.257]             }
[10:21:12.257]             function(cond) {
[10:21:12.257]                 is_error <- inherits(cond, "error")
[10:21:12.257]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:12.257]                   NULL)
[10:21:12.257]                 if (is_error) {
[10:21:12.257]                   sessionInformation <- function() {
[10:21:12.257]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:12.257]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:12.257]                       search = base::search(), system = base::Sys.info())
[10:21:12.257]                   }
[10:21:12.257]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.257]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:12.257]                     cond$call), session = sessionInformation(), 
[10:21:12.257]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:12.257]                   signalCondition(cond)
[10:21:12.257]                 }
[10:21:12.257]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:12.257]                 "immediateCondition"))) {
[10:21:12.257]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:12.257]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.257]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:12.257]                   if (TRUE && !signal) {
[10:21:12.257]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.257]                     {
[10:21:12.257]                       inherits <- base::inherits
[10:21:12.257]                       invokeRestart <- base::invokeRestart
[10:21:12.257]                       is.null <- base::is.null
[10:21:12.257]                       muffled <- FALSE
[10:21:12.257]                       if (inherits(cond, "message")) {
[10:21:12.257]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.257]                         if (muffled) 
[10:21:12.257]                           invokeRestart("muffleMessage")
[10:21:12.257]                       }
[10:21:12.257]                       else if (inherits(cond, "warning")) {
[10:21:12.257]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.257]                         if (muffled) 
[10:21:12.257]                           invokeRestart("muffleWarning")
[10:21:12.257]                       }
[10:21:12.257]                       else if (inherits(cond, "condition")) {
[10:21:12.257]                         if (!is.null(pattern)) {
[10:21:12.257]                           computeRestarts <- base::computeRestarts
[10:21:12.257]                           grepl <- base::grepl
[10:21:12.257]                           restarts <- computeRestarts(cond)
[10:21:12.257]                           for (restart in restarts) {
[10:21:12.257]                             name <- restart$name
[10:21:12.257]                             if (is.null(name)) 
[10:21:12.257]                               next
[10:21:12.257]                             if (!grepl(pattern, name)) 
[10:21:12.257]                               next
[10:21:12.257]                             invokeRestart(restart)
[10:21:12.257]                             muffled <- TRUE
[10:21:12.257]                             break
[10:21:12.257]                           }
[10:21:12.257]                         }
[10:21:12.257]                       }
[10:21:12.257]                       invisible(muffled)
[10:21:12.257]                     }
[10:21:12.257]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.257]                   }
[10:21:12.257]                 }
[10:21:12.257]                 else {
[10:21:12.257]                   if (TRUE) {
[10:21:12.257]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.257]                     {
[10:21:12.257]                       inherits <- base::inherits
[10:21:12.257]                       invokeRestart <- base::invokeRestart
[10:21:12.257]                       is.null <- base::is.null
[10:21:12.257]                       muffled <- FALSE
[10:21:12.257]                       if (inherits(cond, "message")) {
[10:21:12.257]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.257]                         if (muffled) 
[10:21:12.257]                           invokeRestart("muffleMessage")
[10:21:12.257]                       }
[10:21:12.257]                       else if (inherits(cond, "warning")) {
[10:21:12.257]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.257]                         if (muffled) 
[10:21:12.257]                           invokeRestart("muffleWarning")
[10:21:12.257]                       }
[10:21:12.257]                       else if (inherits(cond, "condition")) {
[10:21:12.257]                         if (!is.null(pattern)) {
[10:21:12.257]                           computeRestarts <- base::computeRestarts
[10:21:12.257]                           grepl <- base::grepl
[10:21:12.257]                           restarts <- computeRestarts(cond)
[10:21:12.257]                           for (restart in restarts) {
[10:21:12.257]                             name <- restart$name
[10:21:12.257]                             if (is.null(name)) 
[10:21:12.257]                               next
[10:21:12.257]                             if (!grepl(pattern, name)) 
[10:21:12.257]                               next
[10:21:12.257]                             invokeRestart(restart)
[10:21:12.257]                             muffled <- TRUE
[10:21:12.257]                             break
[10:21:12.257]                           }
[10:21:12.257]                         }
[10:21:12.257]                       }
[10:21:12.257]                       invisible(muffled)
[10:21:12.257]                     }
[10:21:12.257]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.257]                   }
[10:21:12.257]                 }
[10:21:12.257]             }
[10:21:12.257]         }))
[10:21:12.257]     }, error = function(ex) {
[10:21:12.257]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:12.257]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.257]                 ...future.rng), started = ...future.startTime, 
[10:21:12.257]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:12.257]             version = "1.8"), class = "FutureResult")
[10:21:12.257]     }, finally = {
[10:21:12.257]         if (!identical(...future.workdir, getwd())) 
[10:21:12.257]             setwd(...future.workdir)
[10:21:12.257]         {
[10:21:12.257]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:12.257]                 ...future.oldOptions$nwarnings <- NULL
[10:21:12.257]             }
[10:21:12.257]             base::options(...future.oldOptions)
[10:21:12.257]             if (.Platform$OS.type == "windows") {
[10:21:12.257]                 old_names <- names(...future.oldEnvVars)
[10:21:12.257]                 envs <- base::Sys.getenv()
[10:21:12.257]                 names <- names(envs)
[10:21:12.257]                 common <- intersect(names, old_names)
[10:21:12.257]                 added <- setdiff(names, old_names)
[10:21:12.257]                 removed <- setdiff(old_names, names)
[10:21:12.257]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:12.257]                   envs[common]]
[10:21:12.257]                 NAMES <- toupper(changed)
[10:21:12.257]                 args <- list()
[10:21:12.257]                 for (kk in seq_along(NAMES)) {
[10:21:12.257]                   name <- changed[[kk]]
[10:21:12.257]                   NAME <- NAMES[[kk]]
[10:21:12.257]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.257]                     next
[10:21:12.257]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.257]                 }
[10:21:12.257]                 NAMES <- toupper(added)
[10:21:12.257]                 for (kk in seq_along(NAMES)) {
[10:21:12.257]                   name <- added[[kk]]
[10:21:12.257]                   NAME <- NAMES[[kk]]
[10:21:12.257]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.257]                     next
[10:21:12.257]                   args[[name]] <- ""
[10:21:12.257]                 }
[10:21:12.257]                 NAMES <- toupper(removed)
[10:21:12.257]                 for (kk in seq_along(NAMES)) {
[10:21:12.257]                   name <- removed[[kk]]
[10:21:12.257]                   NAME <- NAMES[[kk]]
[10:21:12.257]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.257]                     next
[10:21:12.257]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.257]                 }
[10:21:12.257]                 if (length(args) > 0) 
[10:21:12.257]                   base::do.call(base::Sys.setenv, args = args)
[10:21:12.257]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:12.257]             }
[10:21:12.257]             else {
[10:21:12.257]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:12.257]             }
[10:21:12.257]             {
[10:21:12.257]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:12.257]                   0L) {
[10:21:12.257]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:12.257]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:12.257]                   base::options(opts)
[10:21:12.257]                 }
[10:21:12.257]                 {
[10:21:12.257]                   {
[10:21:12.257]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:12.257]                     NULL
[10:21:12.257]                   }
[10:21:12.257]                   options(future.plan = NULL)
[10:21:12.257]                   if (is.na(NA_character_)) 
[10:21:12.257]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.257]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:12.257]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:12.257]                     .init = FALSE)
[10:21:12.257]                 }
[10:21:12.257]             }
[10:21:12.257]         }
[10:21:12.257]     })
[10:21:12.257]     if (TRUE) {
[10:21:12.257]         base::sink(type = "output", split = FALSE)
[10:21:12.257]         if (TRUE) {
[10:21:12.257]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:12.257]         }
[10:21:12.257]         else {
[10:21:12.257]             ...future.result["stdout"] <- base::list(NULL)
[10:21:12.257]         }
[10:21:12.257]         base::close(...future.stdout)
[10:21:12.257]         ...future.stdout <- NULL
[10:21:12.257]     }
[10:21:12.257]     ...future.result$conditions <- ...future.conditions
[10:21:12.257]     ...future.result$finished <- base::Sys.time()
[10:21:12.257]     ...future.result
[10:21:12.257] }
[10:21:12.259] Exporting 1 global objects (346 bytes) to cluster node #1 ...
[10:21:12.260] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[10:21:12.260] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[10:21:12.260] Exporting 1 global objects (346 bytes) to cluster node #1 ... DONE
[10:21:12.261] MultisessionFuture started
[10:21:12.261] - Launch lazy future ... done
[10:21:12.261] run() for ‘MultisessionFuture’ ... done
[10:21:12.261] result() for ClusterFuture ...
[10:21:12.261] receiveMessageFromWorker() for ClusterFuture ...
[10:21:12.261] - Validating connection of MultisessionFuture
[10:21:12.303] - received message: FutureResult
[10:21:12.303] - Received FutureResult
[10:21:12.303] - Erased future from FutureRegistry
[10:21:12.303] result() for ClusterFuture ...
[10:21:12.303] - result already collected: FutureResult
[10:21:12.304] result() for ClusterFuture ... done
[10:21:12.304] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:12.304] result() for ClusterFuture ... done
[10:21:12.304] result() for ClusterFuture ...
[10:21:12.304] - result already collected: FutureResult
[10:21:12.304] result() for ClusterFuture ... done
b = 11
*** %<-% with ‘multisession’ futures ... DONE
Testing with 2 cores ... DONE
> 
> message("*** %<-% ... DONE")
*** %<-% ... DONE
> 
> source("incl/end.R")
[10:21:12.305] plan(): Setting new future strategy stack:
[10:21:12.305] List of future strategies:
[10:21:12.305] 1. FutureStrategy:
[10:21:12.305]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.305]    - tweaked: FALSE
[10:21:12.305]    - call: future::plan(oplan)
[10:21:12.306] plan(): nbrOfWorkers() = 1
> 
