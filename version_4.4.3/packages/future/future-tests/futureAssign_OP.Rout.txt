
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[11:01:19.887] plan(): Setting new future strategy stack:
[11:01:19.888] List of future strategies:
[11:01:19.888] 1. sequential:
[11:01:19.888]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:19.888]    - tweaked: FALSE
[11:01:19.888]    - call: future::plan("sequential")
[11:01:19.901] plan(): nbrOfWorkers() = 1
> 
> message("*** %<-% ...")
*** %<-% ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("*** %%<-%% with %s futures ...", sQuote(strategy)))
+     plan(strategy)
+ 
+     rm(list = intersect(c("x", "y"), ls()))
+ 
+     message("** Future evaluation without globals")
+     v1 %<-% { x <- 1 }
+     stopifnot(!exists("x", inherits = FALSE), identical(v1, 1))
+ 
+     message("** Future evaluation with globals")
+     a <- 2
+     v2 %<-% { x <- a }
+     stopifnot(!exists("x", inherits = FALSE), identical(v2, a))
+ 
+     message("** Future evaluation with errors")
+     v3 %<-% {
+       x <- 3
+       stop("Woops!")
+       x
+     }
+     stopifnot(!exists("x", inherits = FALSE))
+     res <- tryCatch(identical(v3, 3), error = identity)
+     stopifnot(inherits(res, "error"))
+ 
+ 
+     y <- listenv::listenv()
+     for (ii in 1:3) {
+       y[[ii]] %<-% {
+         if (ii %% 2 == 0) stop("Woops!")
+         ii
+       }
+     }
+     res <- tryCatch(as.list(y), error = identity)
+     stopifnot(inherits(res, "error"))
+     z <- y[c(1, 3)]
+     z <- unlist(z)
+     stopifnot(all(z == c(1, 3)))
+     res <- tryCatch(y[[2]], error = identity)
+     stopifnot(inherits(res, "error"))
+     res <- tryCatch(y[1:2], error = identity)
+     stopifnot(inherits(res, "error"))
+ 
+ 
+     message("** Future evaluation with a poor-man's \"progress bar\"")
+     v4 %<-% {
+       cat("Processing: ")
+       for (ii in 1:10) { cat(".") }
+       cat(" [100%]\n")
+       4
+     }
+ 
+ 
+     message("** Collecting results")
+     printf("v1 = %s\n", v1)
+     stopifnot(v1 == 1)
+ 
+     printf("v2 = %s\n", v2)
+     stopifnot(v2 == a)
+ 
+     stopifnot(tryCatch({
+       printf("v3 = %s\n", v3)
+     }, error = function(ex) {
+       printf("v3: <%s> (as expect)\n", class(ex)[1])
+       TRUE
+     }))
+ 
+     printf("v4 = %s\n", v4)
+     #stopifnot(v4 == 4)
+ 
+ 
+     message("** Left-to-right and right-to-left future assignments")
+     c %<-% 1
+     printf("c = %s\n", c)
+     1 %->% d
+     printf("d = %s\n", d)
+     stopifnot(d == c)
+ 
+ 
+ 
+     message("** Nested future assignments")
+     a %<-% {
+       b <- 1
+       c %<-% 2
+       3 -> d
+       4 %->% e
+       b + c + d + e
+     }
+     printf("a = %s\n", a)
+     stopifnot(a == 10)
+ 
+     { a + 1 } %->% b
+     printf("b = %s\n", b)
+     stopifnot(b == a + 1)
+ 
+     message(sprintf("*** %%<-%% with %s futures ... DONE", sQuote(strategy)))
+   } # for (strategy in ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** %<-% with ‘sequential’ futures ...
[11:01:19.958] plan(): Setting new future strategy stack:
[11:01:19.958] List of future strategies:
[11:01:19.958] 1. sequential:
[11:01:19.958]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:19.958]    - tweaked: FALSE
[11:01:19.958]    - call: plan(strategy)
[11:01:19.969] plan(): nbrOfWorkers() = 1
** Future evaluation without globals
[11:01:19.971] getGlobalsAndPackages() ...
[11:01:19.971] Searching for globals...
[11:01:19.975] - globals found: [2] ‘{’, ‘<-’
[11:01:19.975] Searching for globals ... DONE
[11:01:19.975] Resolving globals: FALSE
[11:01:19.975] 
[11:01:19.975] 
[11:01:19.976] getGlobalsAndPackages() ... DONE
[11:01:19.976] run() for ‘Future’ ...
[11:01:19.976] - state: ‘created’
[11:01:19.976] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:19.977] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:19.977] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:19.977]   - Field: ‘label’
[11:01:19.977]   - Field: ‘local’
[11:01:19.977]   - Field: ‘owner’
[11:01:19.977]   - Field: ‘envir’
[11:01:19.977]   - Field: ‘packages’
[11:01:19.977]   - Field: ‘gc’
[11:01:19.977]   - Field: ‘conditions’
[11:01:19.977]   - Field: ‘expr’
[11:01:19.978]   - Field: ‘uuid’
[11:01:19.978]   - Field: ‘seed’
[11:01:19.978]   - Field: ‘version’
[11:01:19.978]   - Field: ‘result’
[11:01:19.978]   - Field: ‘asynchronous’
[11:01:19.978]   - Field: ‘calls’
[11:01:19.978]   - Field: ‘globals’
[11:01:19.978]   - Field: ‘stdout’
[11:01:19.978]   - Field: ‘earlySignal’
[11:01:19.978]   - Field: ‘lazy’
[11:01:19.978]   - Field: ‘state’
[11:01:19.978] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:19.979] - Launch lazy future ...
[11:01:19.979] Packages needed by the future expression (n = 0): <none>
[11:01:19.979] Packages needed by future strategies (n = 0): <none>
[11:01:19.980] {
[11:01:19.980]     {
[11:01:19.980]         {
[11:01:19.980]             ...future.startTime <- base::Sys.time()
[11:01:19.980]             {
[11:01:19.980]                 {
[11:01:19.980]                   {
[11:01:19.980]                     base::local({
[11:01:19.980]                       has_future <- base::requireNamespace("future", 
[11:01:19.980]                         quietly = TRUE)
[11:01:19.980]                       if (has_future) {
[11:01:19.980]                         ns <- base::getNamespace("future")
[11:01:19.980]                         version <- ns[[".package"]][["version"]]
[11:01:19.980]                         if (is.null(version)) 
[11:01:19.980]                           version <- utils::packageVersion("future")
[11:01:19.980]                       }
[11:01:19.980]                       else {
[11:01:19.980]                         version <- NULL
[11:01:19.980]                       }
[11:01:19.980]                       if (!has_future || version < "1.8.0") {
[11:01:19.980]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:19.980]                           "", base::R.version$version.string), 
[11:01:19.980]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:19.980]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:19.980]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:19.980]                             "release", "version")], collapse = " "), 
[11:01:19.980]                           hostname = base::Sys.info()[["nodename"]])
[11:01:19.980]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:19.980]                           info)
[11:01:19.980]                         info <- base::paste(info, collapse = "; ")
[11:01:19.980]                         if (!has_future) {
[11:01:19.980]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:19.980]                             info)
[11:01:19.980]                         }
[11:01:19.980]                         else {
[11:01:19.980]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:19.980]                             info, version)
[11:01:19.980]                         }
[11:01:19.980]                         base::stop(msg)
[11:01:19.980]                       }
[11:01:19.980]                     })
[11:01:19.980]                   }
[11:01:19.980]                   ...future.strategy.old <- future::plan("list")
[11:01:19.980]                   options(future.plan = NULL)
[11:01:19.980]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:19.980]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:19.980]                 }
[11:01:19.980]                 ...future.workdir <- getwd()
[11:01:19.980]             }
[11:01:19.980]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:19.980]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:19.980]         }
[11:01:19.980]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:19.980]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:19.980]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:19.980]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:19.980]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:19.980]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:19.980]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:19.980]             base::names(...future.oldOptions))
[11:01:19.980]     }
[11:01:19.980]     if (FALSE) {
[11:01:19.980]     }
[11:01:19.980]     else {
[11:01:19.980]         if (TRUE) {
[11:01:19.980]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:19.980]                 open = "w")
[11:01:19.980]         }
[11:01:19.980]         else {
[11:01:19.980]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:19.980]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:19.980]         }
[11:01:19.980]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:19.980]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:19.980]             base::sink(type = "output", split = FALSE)
[11:01:19.980]             base::close(...future.stdout)
[11:01:19.980]         }, add = TRUE)
[11:01:19.980]     }
[11:01:19.980]     ...future.frame <- base::sys.nframe()
[11:01:19.980]     ...future.conditions <- base::list()
[11:01:19.980]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:19.980]     if (FALSE) {
[11:01:19.980]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:19.980]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:19.980]     }
[11:01:19.980]     ...future.result <- base::tryCatch({
[11:01:19.980]         base::withCallingHandlers({
[11:01:19.980]             ...future.value <- base::withVisible(base::local({
[11:01:19.980]                 x <- 1
[11:01:19.980]             }))
[11:01:19.980]             future::FutureResult(value = ...future.value$value, 
[11:01:19.980]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:19.980]                   ...future.rng), globalenv = if (FALSE) 
[11:01:19.980]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:19.980]                     ...future.globalenv.names))
[11:01:19.980]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:19.980]         }, condition = base::local({
[11:01:19.980]             c <- base::c
[11:01:19.980]             inherits <- base::inherits
[11:01:19.980]             invokeRestart <- base::invokeRestart
[11:01:19.980]             length <- base::length
[11:01:19.980]             list <- base::list
[11:01:19.980]             seq.int <- base::seq.int
[11:01:19.980]             signalCondition <- base::signalCondition
[11:01:19.980]             sys.calls <- base::sys.calls
[11:01:19.980]             `[[` <- base::`[[`
[11:01:19.980]             `+` <- base::`+`
[11:01:19.980]             `<<-` <- base::`<<-`
[11:01:19.980]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:19.980]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:19.980]                   3L)]
[11:01:19.980]             }
[11:01:19.980]             function(cond) {
[11:01:19.980]                 is_error <- inherits(cond, "error")
[11:01:19.980]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:19.980]                   NULL)
[11:01:19.980]                 if (is_error) {
[11:01:19.980]                   sessionInformation <- function() {
[11:01:19.980]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:19.980]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:19.980]                       search = base::search(), system = base::Sys.info())
[11:01:19.980]                   }
[11:01:19.980]                   ...future.conditions[[length(...future.conditions) + 
[11:01:19.980]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:19.980]                     cond$call), session = sessionInformation(), 
[11:01:19.980]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:19.980]                   signalCondition(cond)
[11:01:19.980]                 }
[11:01:19.980]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:19.980]                 "immediateCondition"))) {
[11:01:19.980]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:19.980]                   ...future.conditions[[length(...future.conditions) + 
[11:01:19.980]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:19.980]                   if (TRUE && !signal) {
[11:01:19.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:19.980]                     {
[11:01:19.980]                       inherits <- base::inherits
[11:01:19.980]                       invokeRestart <- base::invokeRestart
[11:01:19.980]                       is.null <- base::is.null
[11:01:19.980]                       muffled <- FALSE
[11:01:19.980]                       if (inherits(cond, "message")) {
[11:01:19.980]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:19.980]                         if (muffled) 
[11:01:19.980]                           invokeRestart("muffleMessage")
[11:01:19.980]                       }
[11:01:19.980]                       else if (inherits(cond, "warning")) {
[11:01:19.980]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:19.980]                         if (muffled) 
[11:01:19.980]                           invokeRestart("muffleWarning")
[11:01:19.980]                       }
[11:01:19.980]                       else if (inherits(cond, "condition")) {
[11:01:19.980]                         if (!is.null(pattern)) {
[11:01:19.980]                           computeRestarts <- base::computeRestarts
[11:01:19.980]                           grepl <- base::grepl
[11:01:19.980]                           restarts <- computeRestarts(cond)
[11:01:19.980]                           for (restart in restarts) {
[11:01:19.980]                             name <- restart$name
[11:01:19.980]                             if (is.null(name)) 
[11:01:19.980]                               next
[11:01:19.980]                             if (!grepl(pattern, name)) 
[11:01:19.980]                               next
[11:01:19.980]                             invokeRestart(restart)
[11:01:19.980]                             muffled <- TRUE
[11:01:19.980]                             break
[11:01:19.980]                           }
[11:01:19.980]                         }
[11:01:19.980]                       }
[11:01:19.980]                       invisible(muffled)
[11:01:19.980]                     }
[11:01:19.980]                     muffleCondition(cond, pattern = "^muffle")
[11:01:19.980]                   }
[11:01:19.980]                 }
[11:01:19.980]                 else {
[11:01:19.980]                   if (TRUE) {
[11:01:19.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:19.980]                     {
[11:01:19.980]                       inherits <- base::inherits
[11:01:19.980]                       invokeRestart <- base::invokeRestart
[11:01:19.980]                       is.null <- base::is.null
[11:01:19.980]                       muffled <- FALSE
[11:01:19.980]                       if (inherits(cond, "message")) {
[11:01:19.980]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:19.980]                         if (muffled) 
[11:01:19.980]                           invokeRestart("muffleMessage")
[11:01:19.980]                       }
[11:01:19.980]                       else if (inherits(cond, "warning")) {
[11:01:19.980]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:19.980]                         if (muffled) 
[11:01:19.980]                           invokeRestart("muffleWarning")
[11:01:19.980]                       }
[11:01:19.980]                       else if (inherits(cond, "condition")) {
[11:01:19.980]                         if (!is.null(pattern)) {
[11:01:19.980]                           computeRestarts <- base::computeRestarts
[11:01:19.980]                           grepl <- base::grepl
[11:01:19.980]                           restarts <- computeRestarts(cond)
[11:01:19.980]                           for (restart in restarts) {
[11:01:19.980]                             name <- restart$name
[11:01:19.980]                             if (is.null(name)) 
[11:01:19.980]                               next
[11:01:19.980]                             if (!grepl(pattern, name)) 
[11:01:19.980]                               next
[11:01:19.980]                             invokeRestart(restart)
[11:01:19.980]                             muffled <- TRUE
[11:01:19.980]                             break
[11:01:19.980]                           }
[11:01:19.980]                         }
[11:01:19.980]                       }
[11:01:19.980]                       invisible(muffled)
[11:01:19.980]                     }
[11:01:19.980]                     muffleCondition(cond, pattern = "^muffle")
[11:01:19.980]                   }
[11:01:19.980]                 }
[11:01:19.980]             }
[11:01:19.980]         }))
[11:01:19.980]     }, error = function(ex) {
[11:01:19.980]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:19.980]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:19.980]                 ...future.rng), started = ...future.startTime, 
[11:01:19.980]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:19.980]             version = "1.8"), class = "FutureResult")
[11:01:19.980]     }, finally = {
[11:01:19.980]         if (!identical(...future.workdir, getwd())) 
[11:01:19.980]             setwd(...future.workdir)
[11:01:19.980]         {
[11:01:19.980]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:19.980]                 ...future.oldOptions$nwarnings <- NULL
[11:01:19.980]             }
[11:01:19.980]             base::options(...future.oldOptions)
[11:01:19.980]             if (.Platform$OS.type == "windows") {
[11:01:19.980]                 old_names <- names(...future.oldEnvVars)
[11:01:19.980]                 envs <- base::Sys.getenv()
[11:01:19.980]                 names <- names(envs)
[11:01:19.980]                 common <- intersect(names, old_names)
[11:01:19.980]                 added <- setdiff(names, old_names)
[11:01:19.980]                 removed <- setdiff(old_names, names)
[11:01:19.980]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:19.980]                   envs[common]]
[11:01:19.980]                 NAMES <- toupper(changed)
[11:01:19.980]                 args <- list()
[11:01:19.980]                 for (kk in seq_along(NAMES)) {
[11:01:19.980]                   name <- changed[[kk]]
[11:01:19.980]                   NAME <- NAMES[[kk]]
[11:01:19.980]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:19.980]                     next
[11:01:19.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:19.980]                 }
[11:01:19.980]                 NAMES <- toupper(added)
[11:01:19.980]                 for (kk in seq_along(NAMES)) {
[11:01:19.980]                   name <- added[[kk]]
[11:01:19.980]                   NAME <- NAMES[[kk]]
[11:01:19.980]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:19.980]                     next
[11:01:19.980]                   args[[name]] <- ""
[11:01:19.980]                 }
[11:01:19.980]                 NAMES <- toupper(removed)
[11:01:19.980]                 for (kk in seq_along(NAMES)) {
[11:01:19.980]                   name <- removed[[kk]]
[11:01:19.980]                   NAME <- NAMES[[kk]]
[11:01:19.980]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:19.980]                     next
[11:01:19.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:19.980]                 }
[11:01:19.980]                 if (length(args) > 0) 
[11:01:19.980]                   base::do.call(base::Sys.setenv, args = args)
[11:01:19.980]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:19.980]             }
[11:01:19.980]             else {
[11:01:19.980]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:19.980]             }
[11:01:19.980]             {
[11:01:19.980]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:19.980]                   0L) {
[11:01:19.980]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:19.980]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:19.980]                   base::options(opts)
[11:01:19.980]                 }
[11:01:19.980]                 {
[11:01:19.980]                   {
[11:01:19.980]                     NULL
[11:01:19.980]                     RNGkind("Mersenne-Twister")
[11:01:19.980]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:19.980]                       inherits = FALSE)
[11:01:19.980]                   }
[11:01:19.980]                   options(future.plan = NULL)
[11:01:19.980]                   if (is.na(NA_character_)) 
[11:01:19.980]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:19.980]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:19.980]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:19.980]                     .init = FALSE)
[11:01:19.980]                 }
[11:01:19.980]             }
[11:01:19.980]         }
[11:01:19.980]     })
[11:01:19.980]     if (TRUE) {
[11:01:19.980]         base::sink(type = "output", split = FALSE)
[11:01:19.980]         if (TRUE) {
[11:01:19.980]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:19.980]         }
[11:01:19.980]         else {
[11:01:19.980]             ...future.result["stdout"] <- base::list(NULL)
[11:01:19.980]         }
[11:01:19.980]         base::close(...future.stdout)
[11:01:19.980]         ...future.stdout <- NULL
[11:01:19.980]     }
[11:01:19.980]     ...future.result$conditions <- ...future.conditions
[11:01:19.980]     ...future.result$finished <- base::Sys.time()
[11:01:19.980]     ...future.result
[11:01:19.980] }
[11:01:19.982] plan(): Setting new future strategy stack:
[11:01:19.982] List of future strategies:
[11:01:19.982] 1. sequential:
[11:01:19.982]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:19.982]    - tweaked: FALSE
[11:01:19.982]    - call: NULL
[11:01:19.982] plan(): nbrOfWorkers() = 1
[11:01:19.983] plan(): Setting new future strategy stack:
[11:01:19.983] List of future strategies:
[11:01:19.983] 1. sequential:
[11:01:19.983]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:19.983]    - tweaked: FALSE
[11:01:19.983]    - call: plan(strategy)
[11:01:19.984] plan(): nbrOfWorkers() = 1
[11:01:19.984] SequentialFuture started (and completed)
[11:01:19.984] - Launch lazy future ... done
[11:01:19.985] run() for ‘SequentialFuture’ ... done
** Future evaluation with globals
[11:01:19.985] getGlobalsAndPackages() ...
[11:01:19.985] Searching for globals...
[11:01:19.986] - globals found: [3] ‘{’, ‘<-’, ‘a’
[11:01:19.986] Searching for globals ... DONE
[11:01:19.986] Resolving globals: FALSE
[11:01:19.987] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:19.987] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:19.987] - globals: [1] ‘a’
[11:01:19.987] 
[11:01:19.988] getGlobalsAndPackages() ... DONE
[11:01:19.988] run() for ‘Future’ ...
[11:01:19.988] - state: ‘created’
[11:01:19.988] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:19.988] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:19.988] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:19.988]   - Field: ‘label’
[11:01:19.988]   - Field: ‘local’
[11:01:19.989]   - Field: ‘owner’
[11:01:19.989]   - Field: ‘envir’
[11:01:19.989]   - Field: ‘packages’
[11:01:19.989]   - Field: ‘gc’
[11:01:19.989]   - Field: ‘conditions’
[11:01:19.989]   - Field: ‘expr’
[11:01:19.989]   - Field: ‘uuid’
[11:01:19.989]   - Field: ‘seed’
[11:01:19.989]   - Field: ‘version’
[11:01:19.989]   - Field: ‘result’
[11:01:19.989]   - Field: ‘asynchronous’
[11:01:19.989]   - Field: ‘calls’
[11:01:19.990]   - Field: ‘globals’
[11:01:19.990]   - Field: ‘stdout’
[11:01:19.990]   - Field: ‘earlySignal’
[11:01:19.990]   - Field: ‘lazy’
[11:01:19.990]   - Field: ‘state’
[11:01:19.990] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:19.990] - Launch lazy future ...
[11:01:19.990] Packages needed by the future expression (n = 0): <none>
[11:01:19.990] Packages needed by future strategies (n = 0): <none>
[11:01:19.991] {
[11:01:19.991]     {
[11:01:19.991]         {
[11:01:19.991]             ...future.startTime <- base::Sys.time()
[11:01:19.991]             {
[11:01:19.991]                 {
[11:01:19.991]                   {
[11:01:19.991]                     base::local({
[11:01:19.991]                       has_future <- base::requireNamespace("future", 
[11:01:19.991]                         quietly = TRUE)
[11:01:19.991]                       if (has_future) {
[11:01:19.991]                         ns <- base::getNamespace("future")
[11:01:19.991]                         version <- ns[[".package"]][["version"]]
[11:01:19.991]                         if (is.null(version)) 
[11:01:19.991]                           version <- utils::packageVersion("future")
[11:01:19.991]                       }
[11:01:19.991]                       else {
[11:01:19.991]                         version <- NULL
[11:01:19.991]                       }
[11:01:19.991]                       if (!has_future || version < "1.8.0") {
[11:01:19.991]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:19.991]                           "", base::R.version$version.string), 
[11:01:19.991]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:19.991]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:19.991]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:19.991]                             "release", "version")], collapse = " "), 
[11:01:19.991]                           hostname = base::Sys.info()[["nodename"]])
[11:01:19.991]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:19.991]                           info)
[11:01:19.991]                         info <- base::paste(info, collapse = "; ")
[11:01:19.991]                         if (!has_future) {
[11:01:19.991]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:19.991]                             info)
[11:01:19.991]                         }
[11:01:19.991]                         else {
[11:01:19.991]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:19.991]                             info, version)
[11:01:19.991]                         }
[11:01:19.991]                         base::stop(msg)
[11:01:19.991]                       }
[11:01:19.991]                     })
[11:01:19.991]                   }
[11:01:19.991]                   ...future.strategy.old <- future::plan("list")
[11:01:19.991]                   options(future.plan = NULL)
[11:01:19.991]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:19.991]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:19.991]                 }
[11:01:19.991]                 ...future.workdir <- getwd()
[11:01:19.991]             }
[11:01:19.991]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:19.991]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:19.991]         }
[11:01:19.991]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:19.991]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:19.991]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:19.991]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:19.991]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:19.991]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:19.991]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:19.991]             base::names(...future.oldOptions))
[11:01:19.991]     }
[11:01:19.991]     if (FALSE) {
[11:01:19.991]     }
[11:01:19.991]     else {
[11:01:19.991]         if (TRUE) {
[11:01:19.991]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:19.991]                 open = "w")
[11:01:19.991]         }
[11:01:19.991]         else {
[11:01:19.991]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:19.991]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:19.991]         }
[11:01:19.991]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:19.991]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:19.991]             base::sink(type = "output", split = FALSE)
[11:01:19.991]             base::close(...future.stdout)
[11:01:19.991]         }, add = TRUE)
[11:01:19.991]     }
[11:01:19.991]     ...future.frame <- base::sys.nframe()
[11:01:19.991]     ...future.conditions <- base::list()
[11:01:19.991]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:19.991]     if (FALSE) {
[11:01:19.991]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:19.991]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:19.991]     }
[11:01:19.991]     ...future.result <- base::tryCatch({
[11:01:19.991]         base::withCallingHandlers({
[11:01:19.991]             ...future.value <- base::withVisible(base::local({
[11:01:19.991]                 x <- a
[11:01:19.991]             }))
[11:01:19.991]             future::FutureResult(value = ...future.value$value, 
[11:01:19.991]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:19.991]                   ...future.rng), globalenv = if (FALSE) 
[11:01:19.991]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:19.991]                     ...future.globalenv.names))
[11:01:19.991]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:19.991]         }, condition = base::local({
[11:01:19.991]             c <- base::c
[11:01:19.991]             inherits <- base::inherits
[11:01:19.991]             invokeRestart <- base::invokeRestart
[11:01:19.991]             length <- base::length
[11:01:19.991]             list <- base::list
[11:01:19.991]             seq.int <- base::seq.int
[11:01:19.991]             signalCondition <- base::signalCondition
[11:01:19.991]             sys.calls <- base::sys.calls
[11:01:19.991]             `[[` <- base::`[[`
[11:01:19.991]             `+` <- base::`+`
[11:01:19.991]             `<<-` <- base::`<<-`
[11:01:19.991]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:19.991]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:19.991]                   3L)]
[11:01:19.991]             }
[11:01:19.991]             function(cond) {
[11:01:19.991]                 is_error <- inherits(cond, "error")
[11:01:19.991]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:19.991]                   NULL)
[11:01:19.991]                 if (is_error) {
[11:01:19.991]                   sessionInformation <- function() {
[11:01:19.991]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:19.991]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:19.991]                       search = base::search(), system = base::Sys.info())
[11:01:19.991]                   }
[11:01:19.991]                   ...future.conditions[[length(...future.conditions) + 
[11:01:19.991]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:19.991]                     cond$call), session = sessionInformation(), 
[11:01:19.991]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:19.991]                   signalCondition(cond)
[11:01:19.991]                 }
[11:01:19.991]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:19.991]                 "immediateCondition"))) {
[11:01:19.991]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:19.991]                   ...future.conditions[[length(...future.conditions) + 
[11:01:19.991]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:19.991]                   if (TRUE && !signal) {
[11:01:19.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:19.991]                     {
[11:01:19.991]                       inherits <- base::inherits
[11:01:19.991]                       invokeRestart <- base::invokeRestart
[11:01:19.991]                       is.null <- base::is.null
[11:01:19.991]                       muffled <- FALSE
[11:01:19.991]                       if (inherits(cond, "message")) {
[11:01:19.991]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:19.991]                         if (muffled) 
[11:01:19.991]                           invokeRestart("muffleMessage")
[11:01:19.991]                       }
[11:01:19.991]                       else if (inherits(cond, "warning")) {
[11:01:19.991]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:19.991]                         if (muffled) 
[11:01:19.991]                           invokeRestart("muffleWarning")
[11:01:19.991]                       }
[11:01:19.991]                       else if (inherits(cond, "condition")) {
[11:01:19.991]                         if (!is.null(pattern)) {
[11:01:19.991]                           computeRestarts <- base::computeRestarts
[11:01:19.991]                           grepl <- base::grepl
[11:01:19.991]                           restarts <- computeRestarts(cond)
[11:01:19.991]                           for (restart in restarts) {
[11:01:19.991]                             name <- restart$name
[11:01:19.991]                             if (is.null(name)) 
[11:01:19.991]                               next
[11:01:19.991]                             if (!grepl(pattern, name)) 
[11:01:19.991]                               next
[11:01:19.991]                             invokeRestart(restart)
[11:01:19.991]                             muffled <- TRUE
[11:01:19.991]                             break
[11:01:19.991]                           }
[11:01:19.991]                         }
[11:01:19.991]                       }
[11:01:19.991]                       invisible(muffled)
[11:01:19.991]                     }
[11:01:19.991]                     muffleCondition(cond, pattern = "^muffle")
[11:01:19.991]                   }
[11:01:19.991]                 }
[11:01:19.991]                 else {
[11:01:19.991]                   if (TRUE) {
[11:01:19.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:19.991]                     {
[11:01:19.991]                       inherits <- base::inherits
[11:01:19.991]                       invokeRestart <- base::invokeRestart
[11:01:19.991]                       is.null <- base::is.null
[11:01:19.991]                       muffled <- FALSE
[11:01:19.991]                       if (inherits(cond, "message")) {
[11:01:19.991]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:19.991]                         if (muffled) 
[11:01:19.991]                           invokeRestart("muffleMessage")
[11:01:19.991]                       }
[11:01:19.991]                       else if (inherits(cond, "warning")) {
[11:01:19.991]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:19.991]                         if (muffled) 
[11:01:19.991]                           invokeRestart("muffleWarning")
[11:01:19.991]                       }
[11:01:19.991]                       else if (inherits(cond, "condition")) {
[11:01:19.991]                         if (!is.null(pattern)) {
[11:01:19.991]                           computeRestarts <- base::computeRestarts
[11:01:19.991]                           grepl <- base::grepl
[11:01:19.991]                           restarts <- computeRestarts(cond)
[11:01:19.991]                           for (restart in restarts) {
[11:01:19.991]                             name <- restart$name
[11:01:19.991]                             if (is.null(name)) 
[11:01:19.991]                               next
[11:01:19.991]                             if (!grepl(pattern, name)) 
[11:01:19.991]                               next
[11:01:19.991]                             invokeRestart(restart)
[11:01:19.991]                             muffled <- TRUE
[11:01:19.991]                             break
[11:01:19.991]                           }
[11:01:19.991]                         }
[11:01:19.991]                       }
[11:01:19.991]                       invisible(muffled)
[11:01:19.991]                     }
[11:01:19.991]                     muffleCondition(cond, pattern = "^muffle")
[11:01:19.991]                   }
[11:01:19.991]                 }
[11:01:19.991]             }
[11:01:19.991]         }))
[11:01:19.991]     }, error = function(ex) {
[11:01:19.991]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:19.991]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:19.991]                 ...future.rng), started = ...future.startTime, 
[11:01:19.991]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:19.991]             version = "1.8"), class = "FutureResult")
[11:01:19.991]     }, finally = {
[11:01:19.991]         if (!identical(...future.workdir, getwd())) 
[11:01:19.991]             setwd(...future.workdir)
[11:01:19.991]         {
[11:01:19.991]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:19.991]                 ...future.oldOptions$nwarnings <- NULL
[11:01:19.991]             }
[11:01:19.991]             base::options(...future.oldOptions)
[11:01:19.991]             if (.Platform$OS.type == "windows") {
[11:01:19.991]                 old_names <- names(...future.oldEnvVars)
[11:01:19.991]                 envs <- base::Sys.getenv()
[11:01:19.991]                 names <- names(envs)
[11:01:19.991]                 common <- intersect(names, old_names)
[11:01:19.991]                 added <- setdiff(names, old_names)
[11:01:19.991]                 removed <- setdiff(old_names, names)
[11:01:19.991]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:19.991]                   envs[common]]
[11:01:19.991]                 NAMES <- toupper(changed)
[11:01:19.991]                 args <- list()
[11:01:19.991]                 for (kk in seq_along(NAMES)) {
[11:01:19.991]                   name <- changed[[kk]]
[11:01:19.991]                   NAME <- NAMES[[kk]]
[11:01:19.991]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:19.991]                     next
[11:01:19.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:19.991]                 }
[11:01:19.991]                 NAMES <- toupper(added)
[11:01:19.991]                 for (kk in seq_along(NAMES)) {
[11:01:19.991]                   name <- added[[kk]]
[11:01:19.991]                   NAME <- NAMES[[kk]]
[11:01:19.991]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:19.991]                     next
[11:01:19.991]                   args[[name]] <- ""
[11:01:19.991]                 }
[11:01:19.991]                 NAMES <- toupper(removed)
[11:01:19.991]                 for (kk in seq_along(NAMES)) {
[11:01:19.991]                   name <- removed[[kk]]
[11:01:19.991]                   NAME <- NAMES[[kk]]
[11:01:19.991]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:19.991]                     next
[11:01:19.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:19.991]                 }
[11:01:19.991]                 if (length(args) > 0) 
[11:01:19.991]                   base::do.call(base::Sys.setenv, args = args)
[11:01:19.991]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:19.991]             }
[11:01:19.991]             else {
[11:01:19.991]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:19.991]             }
[11:01:19.991]             {
[11:01:19.991]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:19.991]                   0L) {
[11:01:19.991]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:19.991]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:19.991]                   base::options(opts)
[11:01:19.991]                 }
[11:01:19.991]                 {
[11:01:19.991]                   {
[11:01:19.991]                     NULL
[11:01:19.991]                     RNGkind("Mersenne-Twister")
[11:01:19.991]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:19.991]                       inherits = FALSE)
[11:01:19.991]                   }
[11:01:19.991]                   options(future.plan = NULL)
[11:01:19.991]                   if (is.na(NA_character_)) 
[11:01:19.991]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:19.991]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:19.991]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:19.991]                     .init = FALSE)
[11:01:19.991]                 }
[11:01:19.991]             }
[11:01:19.991]         }
[11:01:19.991]     })
[11:01:19.991]     if (TRUE) {
[11:01:19.991]         base::sink(type = "output", split = FALSE)
[11:01:19.991]         if (TRUE) {
[11:01:19.991]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:19.991]         }
[11:01:19.991]         else {
[11:01:19.991]             ...future.result["stdout"] <- base::list(NULL)
[11:01:19.991]         }
[11:01:19.991]         base::close(...future.stdout)
[11:01:19.991]         ...future.stdout <- NULL
[11:01:19.991]     }
[11:01:19.991]     ...future.result$conditions <- ...future.conditions
[11:01:19.991]     ...future.result$finished <- base::Sys.time()
[11:01:19.991]     ...future.result
[11:01:19.991] }
[11:01:19.993] assign_globals() ...
[11:01:19.993] List of 1
[11:01:19.993]  $ a: num 2
[11:01:19.993]  - attr(*, "where")=List of 1
[11:01:19.993]   ..$ a:<environment: R_EmptyEnv> 
[11:01:19.993]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:19.993]  - attr(*, "resolved")= logi FALSE
[11:01:19.993]  - attr(*, "total_size")= num 39
[11:01:19.993]  - attr(*, "already-done")= logi TRUE
[11:01:20.003] - copied ‘a’ to environment
[11:01:20.003] assign_globals() ... done
[11:01:20.003] plan(): Setting new future strategy stack:
[11:01:20.003] List of future strategies:
[11:01:20.003] 1. sequential:
[11:01:20.003]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.003]    - tweaked: FALSE
[11:01:20.003]    - call: NULL
[11:01:20.004] plan(): nbrOfWorkers() = 1
[11:01:20.005] plan(): Setting new future strategy stack:
[11:01:20.005] List of future strategies:
[11:01:20.005] 1. sequential:
[11:01:20.005]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.005]    - tweaked: FALSE
[11:01:20.005]    - call: plan(strategy)
[11:01:20.006] plan(): nbrOfWorkers() = 1
[11:01:20.006] SequentialFuture started (and completed)
[11:01:20.006] - Launch lazy future ... done
[11:01:20.006] run() for ‘SequentialFuture’ ... done
** Future evaluation with errors
[11:01:20.007] getGlobalsAndPackages() ...
[11:01:20.007] Searching for globals...
[11:01:20.010] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[11:01:20.010] Searching for globals ... DONE
[11:01:20.010] Resolving globals: FALSE
[11:01:20.010] 
[11:01:20.010] 
[11:01:20.011] getGlobalsAndPackages() ... DONE
[11:01:20.011] run() for ‘Future’ ...
[11:01:20.011] - state: ‘created’
[11:01:20.011] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:20.011] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:20.011] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:20.011]   - Field: ‘label’
[11:01:20.012]   - Field: ‘local’
[11:01:20.012]   - Field: ‘owner’
[11:01:20.012]   - Field: ‘envir’
[11:01:20.012]   - Field: ‘packages’
[11:01:20.012]   - Field: ‘gc’
[11:01:20.012]   - Field: ‘conditions’
[11:01:20.012]   - Field: ‘expr’
[11:01:20.012]   - Field: ‘uuid’
[11:01:20.012]   - Field: ‘seed’
[11:01:20.012]   - Field: ‘version’
[11:01:20.012]   - Field: ‘result’
[11:01:20.012]   - Field: ‘asynchronous’
[11:01:20.013]   - Field: ‘calls’
[11:01:20.013]   - Field: ‘globals’
[11:01:20.013]   - Field: ‘stdout’
[11:01:20.013]   - Field: ‘earlySignal’
[11:01:20.013]   - Field: ‘lazy’
[11:01:20.013]   - Field: ‘state’
[11:01:20.013] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:20.013] - Launch lazy future ...
[11:01:20.013] Packages needed by the future expression (n = 0): <none>
[11:01:20.013] Packages needed by future strategies (n = 0): <none>
[11:01:20.014] {
[11:01:20.014]     {
[11:01:20.014]         {
[11:01:20.014]             ...future.startTime <- base::Sys.time()
[11:01:20.014]             {
[11:01:20.014]                 {
[11:01:20.014]                   {
[11:01:20.014]                     base::local({
[11:01:20.014]                       has_future <- base::requireNamespace("future", 
[11:01:20.014]                         quietly = TRUE)
[11:01:20.014]                       if (has_future) {
[11:01:20.014]                         ns <- base::getNamespace("future")
[11:01:20.014]                         version <- ns[[".package"]][["version"]]
[11:01:20.014]                         if (is.null(version)) 
[11:01:20.014]                           version <- utils::packageVersion("future")
[11:01:20.014]                       }
[11:01:20.014]                       else {
[11:01:20.014]                         version <- NULL
[11:01:20.014]                       }
[11:01:20.014]                       if (!has_future || version < "1.8.0") {
[11:01:20.014]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.014]                           "", base::R.version$version.string), 
[11:01:20.014]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:20.014]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.014]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.014]                             "release", "version")], collapse = " "), 
[11:01:20.014]                           hostname = base::Sys.info()[["nodename"]])
[11:01:20.014]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.014]                           info)
[11:01:20.014]                         info <- base::paste(info, collapse = "; ")
[11:01:20.014]                         if (!has_future) {
[11:01:20.014]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.014]                             info)
[11:01:20.014]                         }
[11:01:20.014]                         else {
[11:01:20.014]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.014]                             info, version)
[11:01:20.014]                         }
[11:01:20.014]                         base::stop(msg)
[11:01:20.014]                       }
[11:01:20.014]                     })
[11:01:20.014]                   }
[11:01:20.014]                   ...future.strategy.old <- future::plan("list")
[11:01:20.014]                   options(future.plan = NULL)
[11:01:20.014]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.014]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.014]                 }
[11:01:20.014]                 ...future.workdir <- getwd()
[11:01:20.014]             }
[11:01:20.014]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.014]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.014]         }
[11:01:20.014]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.014]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.014]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.014]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.014]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.014]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.014]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.014]             base::names(...future.oldOptions))
[11:01:20.014]     }
[11:01:20.014]     if (FALSE) {
[11:01:20.014]     }
[11:01:20.014]     else {
[11:01:20.014]         if (TRUE) {
[11:01:20.014]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.014]                 open = "w")
[11:01:20.014]         }
[11:01:20.014]         else {
[11:01:20.014]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.014]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.014]         }
[11:01:20.014]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.014]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.014]             base::sink(type = "output", split = FALSE)
[11:01:20.014]             base::close(...future.stdout)
[11:01:20.014]         }, add = TRUE)
[11:01:20.014]     }
[11:01:20.014]     ...future.frame <- base::sys.nframe()
[11:01:20.014]     ...future.conditions <- base::list()
[11:01:20.014]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.014]     if (FALSE) {
[11:01:20.014]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.014]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.014]     }
[11:01:20.014]     ...future.result <- base::tryCatch({
[11:01:20.014]         base::withCallingHandlers({
[11:01:20.014]             ...future.value <- base::withVisible(base::local({
[11:01:20.014]                 x <- 3
[11:01:20.014]                 stop("Woops!")
[11:01:20.014]                 x
[11:01:20.014]             }))
[11:01:20.014]             future::FutureResult(value = ...future.value$value, 
[11:01:20.014]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.014]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.014]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.014]                     ...future.globalenv.names))
[11:01:20.014]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.014]         }, condition = base::local({
[11:01:20.014]             c <- base::c
[11:01:20.014]             inherits <- base::inherits
[11:01:20.014]             invokeRestart <- base::invokeRestart
[11:01:20.014]             length <- base::length
[11:01:20.014]             list <- base::list
[11:01:20.014]             seq.int <- base::seq.int
[11:01:20.014]             signalCondition <- base::signalCondition
[11:01:20.014]             sys.calls <- base::sys.calls
[11:01:20.014]             `[[` <- base::`[[`
[11:01:20.014]             `+` <- base::`+`
[11:01:20.014]             `<<-` <- base::`<<-`
[11:01:20.014]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.014]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.014]                   3L)]
[11:01:20.014]             }
[11:01:20.014]             function(cond) {
[11:01:20.014]                 is_error <- inherits(cond, "error")
[11:01:20.014]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.014]                   NULL)
[11:01:20.014]                 if (is_error) {
[11:01:20.014]                   sessionInformation <- function() {
[11:01:20.014]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.014]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.014]                       search = base::search(), system = base::Sys.info())
[11:01:20.014]                   }
[11:01:20.014]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.014]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.014]                     cond$call), session = sessionInformation(), 
[11:01:20.014]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.014]                   signalCondition(cond)
[11:01:20.014]                 }
[11:01:20.014]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.014]                 "immediateCondition"))) {
[11:01:20.014]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.014]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.014]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.014]                   if (TRUE && !signal) {
[11:01:20.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.014]                     {
[11:01:20.014]                       inherits <- base::inherits
[11:01:20.014]                       invokeRestart <- base::invokeRestart
[11:01:20.014]                       is.null <- base::is.null
[11:01:20.014]                       muffled <- FALSE
[11:01:20.014]                       if (inherits(cond, "message")) {
[11:01:20.014]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.014]                         if (muffled) 
[11:01:20.014]                           invokeRestart("muffleMessage")
[11:01:20.014]                       }
[11:01:20.014]                       else if (inherits(cond, "warning")) {
[11:01:20.014]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.014]                         if (muffled) 
[11:01:20.014]                           invokeRestart("muffleWarning")
[11:01:20.014]                       }
[11:01:20.014]                       else if (inherits(cond, "condition")) {
[11:01:20.014]                         if (!is.null(pattern)) {
[11:01:20.014]                           computeRestarts <- base::computeRestarts
[11:01:20.014]                           grepl <- base::grepl
[11:01:20.014]                           restarts <- computeRestarts(cond)
[11:01:20.014]                           for (restart in restarts) {
[11:01:20.014]                             name <- restart$name
[11:01:20.014]                             if (is.null(name)) 
[11:01:20.014]                               next
[11:01:20.014]                             if (!grepl(pattern, name)) 
[11:01:20.014]                               next
[11:01:20.014]                             invokeRestart(restart)
[11:01:20.014]                             muffled <- TRUE
[11:01:20.014]                             break
[11:01:20.014]                           }
[11:01:20.014]                         }
[11:01:20.014]                       }
[11:01:20.014]                       invisible(muffled)
[11:01:20.014]                     }
[11:01:20.014]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.014]                   }
[11:01:20.014]                 }
[11:01:20.014]                 else {
[11:01:20.014]                   if (TRUE) {
[11:01:20.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.014]                     {
[11:01:20.014]                       inherits <- base::inherits
[11:01:20.014]                       invokeRestart <- base::invokeRestart
[11:01:20.014]                       is.null <- base::is.null
[11:01:20.014]                       muffled <- FALSE
[11:01:20.014]                       if (inherits(cond, "message")) {
[11:01:20.014]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.014]                         if (muffled) 
[11:01:20.014]                           invokeRestart("muffleMessage")
[11:01:20.014]                       }
[11:01:20.014]                       else if (inherits(cond, "warning")) {
[11:01:20.014]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.014]                         if (muffled) 
[11:01:20.014]                           invokeRestart("muffleWarning")
[11:01:20.014]                       }
[11:01:20.014]                       else if (inherits(cond, "condition")) {
[11:01:20.014]                         if (!is.null(pattern)) {
[11:01:20.014]                           computeRestarts <- base::computeRestarts
[11:01:20.014]                           grepl <- base::grepl
[11:01:20.014]                           restarts <- computeRestarts(cond)
[11:01:20.014]                           for (restart in restarts) {
[11:01:20.014]                             name <- restart$name
[11:01:20.014]                             if (is.null(name)) 
[11:01:20.014]                               next
[11:01:20.014]                             if (!grepl(pattern, name)) 
[11:01:20.014]                               next
[11:01:20.014]                             invokeRestart(restart)
[11:01:20.014]                             muffled <- TRUE
[11:01:20.014]                             break
[11:01:20.014]                           }
[11:01:20.014]                         }
[11:01:20.014]                       }
[11:01:20.014]                       invisible(muffled)
[11:01:20.014]                     }
[11:01:20.014]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.014]                   }
[11:01:20.014]                 }
[11:01:20.014]             }
[11:01:20.014]         }))
[11:01:20.014]     }, error = function(ex) {
[11:01:20.014]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.014]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.014]                 ...future.rng), started = ...future.startTime, 
[11:01:20.014]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.014]             version = "1.8"), class = "FutureResult")
[11:01:20.014]     }, finally = {
[11:01:20.014]         if (!identical(...future.workdir, getwd())) 
[11:01:20.014]             setwd(...future.workdir)
[11:01:20.014]         {
[11:01:20.014]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.014]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.014]             }
[11:01:20.014]             base::options(...future.oldOptions)
[11:01:20.014]             if (.Platform$OS.type == "windows") {
[11:01:20.014]                 old_names <- names(...future.oldEnvVars)
[11:01:20.014]                 envs <- base::Sys.getenv()
[11:01:20.014]                 names <- names(envs)
[11:01:20.014]                 common <- intersect(names, old_names)
[11:01:20.014]                 added <- setdiff(names, old_names)
[11:01:20.014]                 removed <- setdiff(old_names, names)
[11:01:20.014]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.014]                   envs[common]]
[11:01:20.014]                 NAMES <- toupper(changed)
[11:01:20.014]                 args <- list()
[11:01:20.014]                 for (kk in seq_along(NAMES)) {
[11:01:20.014]                   name <- changed[[kk]]
[11:01:20.014]                   NAME <- NAMES[[kk]]
[11:01:20.014]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.014]                     next
[11:01:20.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.014]                 }
[11:01:20.014]                 NAMES <- toupper(added)
[11:01:20.014]                 for (kk in seq_along(NAMES)) {
[11:01:20.014]                   name <- added[[kk]]
[11:01:20.014]                   NAME <- NAMES[[kk]]
[11:01:20.014]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.014]                     next
[11:01:20.014]                   args[[name]] <- ""
[11:01:20.014]                 }
[11:01:20.014]                 NAMES <- toupper(removed)
[11:01:20.014]                 for (kk in seq_along(NAMES)) {
[11:01:20.014]                   name <- removed[[kk]]
[11:01:20.014]                   NAME <- NAMES[[kk]]
[11:01:20.014]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.014]                     next
[11:01:20.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.014]                 }
[11:01:20.014]                 if (length(args) > 0) 
[11:01:20.014]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.014]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.014]             }
[11:01:20.014]             else {
[11:01:20.014]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.014]             }
[11:01:20.014]             {
[11:01:20.014]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.014]                   0L) {
[11:01:20.014]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.014]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.014]                   base::options(opts)
[11:01:20.014]                 }
[11:01:20.014]                 {
[11:01:20.014]                   {
[11:01:20.014]                     NULL
[11:01:20.014]                     RNGkind("Mersenne-Twister")
[11:01:20.014]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:20.014]                       inherits = FALSE)
[11:01:20.014]                   }
[11:01:20.014]                   options(future.plan = NULL)
[11:01:20.014]                   if (is.na(NA_character_)) 
[11:01:20.014]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.014]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.014]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.014]                     .init = FALSE)
[11:01:20.014]                 }
[11:01:20.014]             }
[11:01:20.014]         }
[11:01:20.014]     })
[11:01:20.014]     if (TRUE) {
[11:01:20.014]         base::sink(type = "output", split = FALSE)
[11:01:20.014]         if (TRUE) {
[11:01:20.014]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.014]         }
[11:01:20.014]         else {
[11:01:20.014]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.014]         }
[11:01:20.014]         base::close(...future.stdout)
[11:01:20.014]         ...future.stdout <- NULL
[11:01:20.014]     }
[11:01:20.014]     ...future.result$conditions <- ...future.conditions
[11:01:20.014]     ...future.result$finished <- base::Sys.time()
[11:01:20.014]     ...future.result
[11:01:20.014] }
[11:01:20.016] plan(): Setting new future strategy stack:
[11:01:20.016] List of future strategies:
[11:01:20.016] 1. sequential:
[11:01:20.016]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.016]    - tweaked: FALSE
[11:01:20.016]    - call: NULL
[11:01:20.016] plan(): nbrOfWorkers() = 1
[11:01:20.017] plan(): Setting new future strategy stack:
[11:01:20.017] List of future strategies:
[11:01:20.017] 1. sequential:
[11:01:20.017]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.017]    - tweaked: FALSE
[11:01:20.017]    - call: plan(strategy)
[11:01:20.017] plan(): nbrOfWorkers() = 1
[11:01:20.018] SequentialFuture started (and completed)
[11:01:20.018] signalConditions() ...
[11:01:20.018]  - include = ‘immediateCondition’
[11:01:20.018]  - exclude = 
[11:01:20.018]  - resignal = FALSE
[11:01:20.018]  - Number of conditions: 1
[11:01:20.018] signalConditions() ... done
[11:01:20.018] - Launch lazy future ... done
[11:01:20.018] run() for ‘SequentialFuture’ ... done
[11:01:20.019] signalConditions() ...
[11:01:20.019]  - include = ‘immediateCondition’
[11:01:20.019]  - exclude = 
[11:01:20.019]  - resignal = FALSE
[11:01:20.019]  - Number of conditions: 1
[11:01:20.019] signalConditions() ... done
[11:01:20.019] Future state: ‘finished’
[11:01:20.019] signalConditions() ...
[11:01:20.019]  - include = ‘condition’
[11:01:20.019]  - exclude = ‘immediateCondition’
[11:01:20.019]  - resignal = TRUE
[11:01:20.019]  - Number of conditions: 1
[11:01:20.020]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:20.020] signalConditions() ... done
[11:01:20.020] getGlobalsAndPackages() ...
[11:01:20.020] Searching for globals...
[11:01:20.022] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[11:01:20.022] Searching for globals ... DONE
[11:01:20.022] Resolving globals: FALSE
[11:01:20.023] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:20.023] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:20.023] - globals: [1] ‘ii’
[11:01:20.023] 
[11:01:20.023] getGlobalsAndPackages() ... DONE
[11:01:20.024] run() for ‘Future’ ...
[11:01:20.024] - state: ‘created’
[11:01:20.024] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:20.024] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:20.024] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:20.024]   - Field: ‘label’
[11:01:20.024]   - Field: ‘local’
[11:01:20.024]   - Field: ‘owner’
[11:01:20.024]   - Field: ‘envir’
[11:01:20.025]   - Field: ‘packages’
[11:01:20.025]   - Field: ‘gc’
[11:01:20.025]   - Field: ‘conditions’
[11:01:20.025]   - Field: ‘expr’
[11:01:20.025]   - Field: ‘uuid’
[11:01:20.025]   - Field: ‘seed’
[11:01:20.025]   - Field: ‘version’
[11:01:20.025]   - Field: ‘result’
[11:01:20.025]   - Field: ‘asynchronous’
[11:01:20.025]   - Field: ‘calls’
[11:01:20.025]   - Field: ‘globals’
[11:01:20.025]   - Field: ‘stdout’
[11:01:20.026]   - Field: ‘earlySignal’
[11:01:20.026]   - Field: ‘lazy’
[11:01:20.026]   - Field: ‘state’
[11:01:20.026] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:20.026] - Launch lazy future ...
[11:01:20.026] Packages needed by the future expression (n = 0): <none>
[11:01:20.026] Packages needed by future strategies (n = 0): <none>
[11:01:20.027] {
[11:01:20.027]     {
[11:01:20.027]         {
[11:01:20.027]             ...future.startTime <- base::Sys.time()
[11:01:20.027]             {
[11:01:20.027]                 {
[11:01:20.027]                   {
[11:01:20.027]                     base::local({
[11:01:20.027]                       has_future <- base::requireNamespace("future", 
[11:01:20.027]                         quietly = TRUE)
[11:01:20.027]                       if (has_future) {
[11:01:20.027]                         ns <- base::getNamespace("future")
[11:01:20.027]                         version <- ns[[".package"]][["version"]]
[11:01:20.027]                         if (is.null(version)) 
[11:01:20.027]                           version <- utils::packageVersion("future")
[11:01:20.027]                       }
[11:01:20.027]                       else {
[11:01:20.027]                         version <- NULL
[11:01:20.027]                       }
[11:01:20.027]                       if (!has_future || version < "1.8.0") {
[11:01:20.027]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.027]                           "", base::R.version$version.string), 
[11:01:20.027]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:20.027]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.027]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.027]                             "release", "version")], collapse = " "), 
[11:01:20.027]                           hostname = base::Sys.info()[["nodename"]])
[11:01:20.027]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.027]                           info)
[11:01:20.027]                         info <- base::paste(info, collapse = "; ")
[11:01:20.027]                         if (!has_future) {
[11:01:20.027]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.027]                             info)
[11:01:20.027]                         }
[11:01:20.027]                         else {
[11:01:20.027]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.027]                             info, version)
[11:01:20.027]                         }
[11:01:20.027]                         base::stop(msg)
[11:01:20.027]                       }
[11:01:20.027]                     })
[11:01:20.027]                   }
[11:01:20.027]                   ...future.strategy.old <- future::plan("list")
[11:01:20.027]                   options(future.plan = NULL)
[11:01:20.027]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.027]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.027]                 }
[11:01:20.027]                 ...future.workdir <- getwd()
[11:01:20.027]             }
[11:01:20.027]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.027]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.027]         }
[11:01:20.027]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.027]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.027]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.027]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.027]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.027]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.027]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.027]             base::names(...future.oldOptions))
[11:01:20.027]     }
[11:01:20.027]     if (FALSE) {
[11:01:20.027]     }
[11:01:20.027]     else {
[11:01:20.027]         if (TRUE) {
[11:01:20.027]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.027]                 open = "w")
[11:01:20.027]         }
[11:01:20.027]         else {
[11:01:20.027]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.027]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.027]         }
[11:01:20.027]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.027]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.027]             base::sink(type = "output", split = FALSE)
[11:01:20.027]             base::close(...future.stdout)
[11:01:20.027]         }, add = TRUE)
[11:01:20.027]     }
[11:01:20.027]     ...future.frame <- base::sys.nframe()
[11:01:20.027]     ...future.conditions <- base::list()
[11:01:20.027]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.027]     if (FALSE) {
[11:01:20.027]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.027]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.027]     }
[11:01:20.027]     ...future.result <- base::tryCatch({
[11:01:20.027]         base::withCallingHandlers({
[11:01:20.027]             ...future.value <- base::withVisible(base::local({
[11:01:20.027]                 if (ii%%2 == 0) 
[11:01:20.027]                   stop("Woops!")
[11:01:20.027]                 ii
[11:01:20.027]             }))
[11:01:20.027]             future::FutureResult(value = ...future.value$value, 
[11:01:20.027]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.027]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.027]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.027]                     ...future.globalenv.names))
[11:01:20.027]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.027]         }, condition = base::local({
[11:01:20.027]             c <- base::c
[11:01:20.027]             inherits <- base::inherits
[11:01:20.027]             invokeRestart <- base::invokeRestart
[11:01:20.027]             length <- base::length
[11:01:20.027]             list <- base::list
[11:01:20.027]             seq.int <- base::seq.int
[11:01:20.027]             signalCondition <- base::signalCondition
[11:01:20.027]             sys.calls <- base::sys.calls
[11:01:20.027]             `[[` <- base::`[[`
[11:01:20.027]             `+` <- base::`+`
[11:01:20.027]             `<<-` <- base::`<<-`
[11:01:20.027]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.027]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.027]                   3L)]
[11:01:20.027]             }
[11:01:20.027]             function(cond) {
[11:01:20.027]                 is_error <- inherits(cond, "error")
[11:01:20.027]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.027]                   NULL)
[11:01:20.027]                 if (is_error) {
[11:01:20.027]                   sessionInformation <- function() {
[11:01:20.027]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.027]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.027]                       search = base::search(), system = base::Sys.info())
[11:01:20.027]                   }
[11:01:20.027]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.027]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.027]                     cond$call), session = sessionInformation(), 
[11:01:20.027]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.027]                   signalCondition(cond)
[11:01:20.027]                 }
[11:01:20.027]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.027]                 "immediateCondition"))) {
[11:01:20.027]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.027]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.027]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.027]                   if (TRUE && !signal) {
[11:01:20.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.027]                     {
[11:01:20.027]                       inherits <- base::inherits
[11:01:20.027]                       invokeRestart <- base::invokeRestart
[11:01:20.027]                       is.null <- base::is.null
[11:01:20.027]                       muffled <- FALSE
[11:01:20.027]                       if (inherits(cond, "message")) {
[11:01:20.027]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.027]                         if (muffled) 
[11:01:20.027]                           invokeRestart("muffleMessage")
[11:01:20.027]                       }
[11:01:20.027]                       else if (inherits(cond, "warning")) {
[11:01:20.027]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.027]                         if (muffled) 
[11:01:20.027]                           invokeRestart("muffleWarning")
[11:01:20.027]                       }
[11:01:20.027]                       else if (inherits(cond, "condition")) {
[11:01:20.027]                         if (!is.null(pattern)) {
[11:01:20.027]                           computeRestarts <- base::computeRestarts
[11:01:20.027]                           grepl <- base::grepl
[11:01:20.027]                           restarts <- computeRestarts(cond)
[11:01:20.027]                           for (restart in restarts) {
[11:01:20.027]                             name <- restart$name
[11:01:20.027]                             if (is.null(name)) 
[11:01:20.027]                               next
[11:01:20.027]                             if (!grepl(pattern, name)) 
[11:01:20.027]                               next
[11:01:20.027]                             invokeRestart(restart)
[11:01:20.027]                             muffled <- TRUE
[11:01:20.027]                             break
[11:01:20.027]                           }
[11:01:20.027]                         }
[11:01:20.027]                       }
[11:01:20.027]                       invisible(muffled)
[11:01:20.027]                     }
[11:01:20.027]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.027]                   }
[11:01:20.027]                 }
[11:01:20.027]                 else {
[11:01:20.027]                   if (TRUE) {
[11:01:20.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.027]                     {
[11:01:20.027]                       inherits <- base::inherits
[11:01:20.027]                       invokeRestart <- base::invokeRestart
[11:01:20.027]                       is.null <- base::is.null
[11:01:20.027]                       muffled <- FALSE
[11:01:20.027]                       if (inherits(cond, "message")) {
[11:01:20.027]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.027]                         if (muffled) 
[11:01:20.027]                           invokeRestart("muffleMessage")
[11:01:20.027]                       }
[11:01:20.027]                       else if (inherits(cond, "warning")) {
[11:01:20.027]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.027]                         if (muffled) 
[11:01:20.027]                           invokeRestart("muffleWarning")
[11:01:20.027]                       }
[11:01:20.027]                       else if (inherits(cond, "condition")) {
[11:01:20.027]                         if (!is.null(pattern)) {
[11:01:20.027]                           computeRestarts <- base::computeRestarts
[11:01:20.027]                           grepl <- base::grepl
[11:01:20.027]                           restarts <- computeRestarts(cond)
[11:01:20.027]                           for (restart in restarts) {
[11:01:20.027]                             name <- restart$name
[11:01:20.027]                             if (is.null(name)) 
[11:01:20.027]                               next
[11:01:20.027]                             if (!grepl(pattern, name)) 
[11:01:20.027]                               next
[11:01:20.027]                             invokeRestart(restart)
[11:01:20.027]                             muffled <- TRUE
[11:01:20.027]                             break
[11:01:20.027]                           }
[11:01:20.027]                         }
[11:01:20.027]                       }
[11:01:20.027]                       invisible(muffled)
[11:01:20.027]                     }
[11:01:20.027]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.027]                   }
[11:01:20.027]                 }
[11:01:20.027]             }
[11:01:20.027]         }))
[11:01:20.027]     }, error = function(ex) {
[11:01:20.027]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.027]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.027]                 ...future.rng), started = ...future.startTime, 
[11:01:20.027]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.027]             version = "1.8"), class = "FutureResult")
[11:01:20.027]     }, finally = {
[11:01:20.027]         if (!identical(...future.workdir, getwd())) 
[11:01:20.027]             setwd(...future.workdir)
[11:01:20.027]         {
[11:01:20.027]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.027]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.027]             }
[11:01:20.027]             base::options(...future.oldOptions)
[11:01:20.027]             if (.Platform$OS.type == "windows") {
[11:01:20.027]                 old_names <- names(...future.oldEnvVars)
[11:01:20.027]                 envs <- base::Sys.getenv()
[11:01:20.027]                 names <- names(envs)
[11:01:20.027]                 common <- intersect(names, old_names)
[11:01:20.027]                 added <- setdiff(names, old_names)
[11:01:20.027]                 removed <- setdiff(old_names, names)
[11:01:20.027]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.027]                   envs[common]]
[11:01:20.027]                 NAMES <- toupper(changed)
[11:01:20.027]                 args <- list()
[11:01:20.027]                 for (kk in seq_along(NAMES)) {
[11:01:20.027]                   name <- changed[[kk]]
[11:01:20.027]                   NAME <- NAMES[[kk]]
[11:01:20.027]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.027]                     next
[11:01:20.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.027]                 }
[11:01:20.027]                 NAMES <- toupper(added)
[11:01:20.027]                 for (kk in seq_along(NAMES)) {
[11:01:20.027]                   name <- added[[kk]]
[11:01:20.027]                   NAME <- NAMES[[kk]]
[11:01:20.027]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.027]                     next
[11:01:20.027]                   args[[name]] <- ""
[11:01:20.027]                 }
[11:01:20.027]                 NAMES <- toupper(removed)
[11:01:20.027]                 for (kk in seq_along(NAMES)) {
[11:01:20.027]                   name <- removed[[kk]]
[11:01:20.027]                   NAME <- NAMES[[kk]]
[11:01:20.027]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.027]                     next
[11:01:20.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.027]                 }
[11:01:20.027]                 if (length(args) > 0) 
[11:01:20.027]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.027]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.027]             }
[11:01:20.027]             else {
[11:01:20.027]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.027]             }
[11:01:20.027]             {
[11:01:20.027]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.027]                   0L) {
[11:01:20.027]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.027]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.027]                   base::options(opts)
[11:01:20.027]                 }
[11:01:20.027]                 {
[11:01:20.027]                   {
[11:01:20.027]                     NULL
[11:01:20.027]                     RNGkind("Mersenne-Twister")
[11:01:20.027]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:20.027]                       inherits = FALSE)
[11:01:20.027]                   }
[11:01:20.027]                   options(future.plan = NULL)
[11:01:20.027]                   if (is.na(NA_character_)) 
[11:01:20.027]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.027]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.027]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.027]                     .init = FALSE)
[11:01:20.027]                 }
[11:01:20.027]             }
[11:01:20.027]         }
[11:01:20.027]     })
[11:01:20.027]     if (TRUE) {
[11:01:20.027]         base::sink(type = "output", split = FALSE)
[11:01:20.027]         if (TRUE) {
[11:01:20.027]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.027]         }
[11:01:20.027]         else {
[11:01:20.027]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.027]         }
[11:01:20.027]         base::close(...future.stdout)
[11:01:20.027]         ...future.stdout <- NULL
[11:01:20.027]     }
[11:01:20.027]     ...future.result$conditions <- ...future.conditions
[11:01:20.027]     ...future.result$finished <- base::Sys.time()
[11:01:20.027]     ...future.result
[11:01:20.027] }
[11:01:20.028] assign_globals() ...
[11:01:20.028] List of 1
[11:01:20.028]  $ ii: int 1
[11:01:20.028]  - attr(*, "where")=List of 1
[11:01:20.028]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:20.028]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:20.028]  - attr(*, "resolved")= logi FALSE
[11:01:20.028]  - attr(*, "total_size")= num 35
[11:01:20.028]  - attr(*, "already-done")= logi TRUE
[11:01:20.032] - copied ‘ii’ to environment
[11:01:20.032] assign_globals() ... done
[11:01:20.032] plan(): Setting new future strategy stack:
[11:01:20.032] List of future strategies:
[11:01:20.032] 1. sequential:
[11:01:20.032]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.032]    - tweaked: FALSE
[11:01:20.032]    - call: NULL
[11:01:20.033] plan(): nbrOfWorkers() = 1
[11:01:20.033] plan(): Setting new future strategy stack:
[11:01:20.033] List of future strategies:
[11:01:20.033] 1. sequential:
[11:01:20.033]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.033]    - tweaked: FALSE
[11:01:20.033]    - call: plan(strategy)
[11:01:20.034] plan(): nbrOfWorkers() = 1
[11:01:20.034] SequentialFuture started (and completed)
[11:01:20.034] - Launch lazy future ... done
[11:01:20.034] run() for ‘SequentialFuture’ ... done
[11:01:20.035] getGlobalsAndPackages() ...
[11:01:20.035] Searching for globals...
[11:01:20.036] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[11:01:20.036] Searching for globals ... DONE
[11:01:20.036] Resolving globals: FALSE
[11:01:20.037] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:20.037] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:20.037] - globals: [1] ‘ii’
[11:01:20.037] 
[11:01:20.037] getGlobalsAndPackages() ... DONE
[11:01:20.037] run() for ‘Future’ ...
[11:01:20.038] - state: ‘created’
[11:01:20.038] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:20.038] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:20.038] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:20.038]   - Field: ‘label’
[11:01:20.038]   - Field: ‘local’
[11:01:20.038]   - Field: ‘owner’
[11:01:20.038]   - Field: ‘envir’
[11:01:20.038]   - Field: ‘packages’
[11:01:20.039]   - Field: ‘gc’
[11:01:20.039]   - Field: ‘conditions’
[11:01:20.039]   - Field: ‘expr’
[11:01:20.039]   - Field: ‘uuid’
[11:01:20.039]   - Field: ‘seed’
[11:01:20.039]   - Field: ‘version’
[11:01:20.039]   - Field: ‘result’
[11:01:20.039]   - Field: ‘asynchronous’
[11:01:20.039]   - Field: ‘calls’
[11:01:20.039]   - Field: ‘globals’
[11:01:20.039]   - Field: ‘stdout’
[11:01:20.039]   - Field: ‘earlySignal’
[11:01:20.039]   - Field: ‘lazy’
[11:01:20.040]   - Field: ‘state’
[11:01:20.040] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:20.040] - Launch lazy future ...
[11:01:20.040] Packages needed by the future expression (n = 0): <none>
[11:01:20.040] Packages needed by future strategies (n = 0): <none>
[11:01:20.040] {
[11:01:20.040]     {
[11:01:20.040]         {
[11:01:20.040]             ...future.startTime <- base::Sys.time()
[11:01:20.040]             {
[11:01:20.040]                 {
[11:01:20.040]                   {
[11:01:20.040]                     base::local({
[11:01:20.040]                       has_future <- base::requireNamespace("future", 
[11:01:20.040]                         quietly = TRUE)
[11:01:20.040]                       if (has_future) {
[11:01:20.040]                         ns <- base::getNamespace("future")
[11:01:20.040]                         version <- ns[[".package"]][["version"]]
[11:01:20.040]                         if (is.null(version)) 
[11:01:20.040]                           version <- utils::packageVersion("future")
[11:01:20.040]                       }
[11:01:20.040]                       else {
[11:01:20.040]                         version <- NULL
[11:01:20.040]                       }
[11:01:20.040]                       if (!has_future || version < "1.8.0") {
[11:01:20.040]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.040]                           "", base::R.version$version.string), 
[11:01:20.040]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:20.040]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.040]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.040]                             "release", "version")], collapse = " "), 
[11:01:20.040]                           hostname = base::Sys.info()[["nodename"]])
[11:01:20.040]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.040]                           info)
[11:01:20.040]                         info <- base::paste(info, collapse = "; ")
[11:01:20.040]                         if (!has_future) {
[11:01:20.040]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.040]                             info)
[11:01:20.040]                         }
[11:01:20.040]                         else {
[11:01:20.040]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.040]                             info, version)
[11:01:20.040]                         }
[11:01:20.040]                         base::stop(msg)
[11:01:20.040]                       }
[11:01:20.040]                     })
[11:01:20.040]                   }
[11:01:20.040]                   ...future.strategy.old <- future::plan("list")
[11:01:20.040]                   options(future.plan = NULL)
[11:01:20.040]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.040]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.040]                 }
[11:01:20.040]                 ...future.workdir <- getwd()
[11:01:20.040]             }
[11:01:20.040]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.040]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.040]         }
[11:01:20.040]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.040]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.040]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.040]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.040]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.040]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.040]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.040]             base::names(...future.oldOptions))
[11:01:20.040]     }
[11:01:20.040]     if (FALSE) {
[11:01:20.040]     }
[11:01:20.040]     else {
[11:01:20.040]         if (TRUE) {
[11:01:20.040]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.040]                 open = "w")
[11:01:20.040]         }
[11:01:20.040]         else {
[11:01:20.040]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.040]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.040]         }
[11:01:20.040]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.040]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.040]             base::sink(type = "output", split = FALSE)
[11:01:20.040]             base::close(...future.stdout)
[11:01:20.040]         }, add = TRUE)
[11:01:20.040]     }
[11:01:20.040]     ...future.frame <- base::sys.nframe()
[11:01:20.040]     ...future.conditions <- base::list()
[11:01:20.040]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.040]     if (FALSE) {
[11:01:20.040]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.040]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.040]     }
[11:01:20.040]     ...future.result <- base::tryCatch({
[11:01:20.040]         base::withCallingHandlers({
[11:01:20.040]             ...future.value <- base::withVisible(base::local({
[11:01:20.040]                 if (ii%%2 == 0) 
[11:01:20.040]                   stop("Woops!")
[11:01:20.040]                 ii
[11:01:20.040]             }))
[11:01:20.040]             future::FutureResult(value = ...future.value$value, 
[11:01:20.040]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.040]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.040]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.040]                     ...future.globalenv.names))
[11:01:20.040]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.040]         }, condition = base::local({
[11:01:20.040]             c <- base::c
[11:01:20.040]             inherits <- base::inherits
[11:01:20.040]             invokeRestart <- base::invokeRestart
[11:01:20.040]             length <- base::length
[11:01:20.040]             list <- base::list
[11:01:20.040]             seq.int <- base::seq.int
[11:01:20.040]             signalCondition <- base::signalCondition
[11:01:20.040]             sys.calls <- base::sys.calls
[11:01:20.040]             `[[` <- base::`[[`
[11:01:20.040]             `+` <- base::`+`
[11:01:20.040]             `<<-` <- base::`<<-`
[11:01:20.040]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.040]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.040]                   3L)]
[11:01:20.040]             }
[11:01:20.040]             function(cond) {
[11:01:20.040]                 is_error <- inherits(cond, "error")
[11:01:20.040]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.040]                   NULL)
[11:01:20.040]                 if (is_error) {
[11:01:20.040]                   sessionInformation <- function() {
[11:01:20.040]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.040]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.040]                       search = base::search(), system = base::Sys.info())
[11:01:20.040]                   }
[11:01:20.040]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.040]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.040]                     cond$call), session = sessionInformation(), 
[11:01:20.040]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.040]                   signalCondition(cond)
[11:01:20.040]                 }
[11:01:20.040]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.040]                 "immediateCondition"))) {
[11:01:20.040]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.040]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.040]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.040]                   if (TRUE && !signal) {
[11:01:20.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.040]                     {
[11:01:20.040]                       inherits <- base::inherits
[11:01:20.040]                       invokeRestart <- base::invokeRestart
[11:01:20.040]                       is.null <- base::is.null
[11:01:20.040]                       muffled <- FALSE
[11:01:20.040]                       if (inherits(cond, "message")) {
[11:01:20.040]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.040]                         if (muffled) 
[11:01:20.040]                           invokeRestart("muffleMessage")
[11:01:20.040]                       }
[11:01:20.040]                       else if (inherits(cond, "warning")) {
[11:01:20.040]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.040]                         if (muffled) 
[11:01:20.040]                           invokeRestart("muffleWarning")
[11:01:20.040]                       }
[11:01:20.040]                       else if (inherits(cond, "condition")) {
[11:01:20.040]                         if (!is.null(pattern)) {
[11:01:20.040]                           computeRestarts <- base::computeRestarts
[11:01:20.040]                           grepl <- base::grepl
[11:01:20.040]                           restarts <- computeRestarts(cond)
[11:01:20.040]                           for (restart in restarts) {
[11:01:20.040]                             name <- restart$name
[11:01:20.040]                             if (is.null(name)) 
[11:01:20.040]                               next
[11:01:20.040]                             if (!grepl(pattern, name)) 
[11:01:20.040]                               next
[11:01:20.040]                             invokeRestart(restart)
[11:01:20.040]                             muffled <- TRUE
[11:01:20.040]                             break
[11:01:20.040]                           }
[11:01:20.040]                         }
[11:01:20.040]                       }
[11:01:20.040]                       invisible(muffled)
[11:01:20.040]                     }
[11:01:20.040]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.040]                   }
[11:01:20.040]                 }
[11:01:20.040]                 else {
[11:01:20.040]                   if (TRUE) {
[11:01:20.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.040]                     {
[11:01:20.040]                       inherits <- base::inherits
[11:01:20.040]                       invokeRestart <- base::invokeRestart
[11:01:20.040]                       is.null <- base::is.null
[11:01:20.040]                       muffled <- FALSE
[11:01:20.040]                       if (inherits(cond, "message")) {
[11:01:20.040]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.040]                         if (muffled) 
[11:01:20.040]                           invokeRestart("muffleMessage")
[11:01:20.040]                       }
[11:01:20.040]                       else if (inherits(cond, "warning")) {
[11:01:20.040]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.040]                         if (muffled) 
[11:01:20.040]                           invokeRestart("muffleWarning")
[11:01:20.040]                       }
[11:01:20.040]                       else if (inherits(cond, "condition")) {
[11:01:20.040]                         if (!is.null(pattern)) {
[11:01:20.040]                           computeRestarts <- base::computeRestarts
[11:01:20.040]                           grepl <- base::grepl
[11:01:20.040]                           restarts <- computeRestarts(cond)
[11:01:20.040]                           for (restart in restarts) {
[11:01:20.040]                             name <- restart$name
[11:01:20.040]                             if (is.null(name)) 
[11:01:20.040]                               next
[11:01:20.040]                             if (!grepl(pattern, name)) 
[11:01:20.040]                               next
[11:01:20.040]                             invokeRestart(restart)
[11:01:20.040]                             muffled <- TRUE
[11:01:20.040]                             break
[11:01:20.040]                           }
[11:01:20.040]                         }
[11:01:20.040]                       }
[11:01:20.040]                       invisible(muffled)
[11:01:20.040]                     }
[11:01:20.040]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.040]                   }
[11:01:20.040]                 }
[11:01:20.040]             }
[11:01:20.040]         }))
[11:01:20.040]     }, error = function(ex) {
[11:01:20.040]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.040]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.040]                 ...future.rng), started = ...future.startTime, 
[11:01:20.040]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.040]             version = "1.8"), class = "FutureResult")
[11:01:20.040]     }, finally = {
[11:01:20.040]         if (!identical(...future.workdir, getwd())) 
[11:01:20.040]             setwd(...future.workdir)
[11:01:20.040]         {
[11:01:20.040]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.040]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.040]             }
[11:01:20.040]             base::options(...future.oldOptions)
[11:01:20.040]             if (.Platform$OS.type == "windows") {
[11:01:20.040]                 old_names <- names(...future.oldEnvVars)
[11:01:20.040]                 envs <- base::Sys.getenv()
[11:01:20.040]                 names <- names(envs)
[11:01:20.040]                 common <- intersect(names, old_names)
[11:01:20.040]                 added <- setdiff(names, old_names)
[11:01:20.040]                 removed <- setdiff(old_names, names)
[11:01:20.040]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.040]                   envs[common]]
[11:01:20.040]                 NAMES <- toupper(changed)
[11:01:20.040]                 args <- list()
[11:01:20.040]                 for (kk in seq_along(NAMES)) {
[11:01:20.040]                   name <- changed[[kk]]
[11:01:20.040]                   NAME <- NAMES[[kk]]
[11:01:20.040]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.040]                     next
[11:01:20.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.040]                 }
[11:01:20.040]                 NAMES <- toupper(added)
[11:01:20.040]                 for (kk in seq_along(NAMES)) {
[11:01:20.040]                   name <- added[[kk]]
[11:01:20.040]                   NAME <- NAMES[[kk]]
[11:01:20.040]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.040]                     next
[11:01:20.040]                   args[[name]] <- ""
[11:01:20.040]                 }
[11:01:20.040]                 NAMES <- toupper(removed)
[11:01:20.040]                 for (kk in seq_along(NAMES)) {
[11:01:20.040]                   name <- removed[[kk]]
[11:01:20.040]                   NAME <- NAMES[[kk]]
[11:01:20.040]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.040]                     next
[11:01:20.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.040]                 }
[11:01:20.040]                 if (length(args) > 0) 
[11:01:20.040]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.040]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.040]             }
[11:01:20.040]             else {
[11:01:20.040]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.040]             }
[11:01:20.040]             {
[11:01:20.040]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.040]                   0L) {
[11:01:20.040]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.040]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.040]                   base::options(opts)
[11:01:20.040]                 }
[11:01:20.040]                 {
[11:01:20.040]                   {
[11:01:20.040]                     NULL
[11:01:20.040]                     RNGkind("Mersenne-Twister")
[11:01:20.040]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:20.040]                       inherits = FALSE)
[11:01:20.040]                   }
[11:01:20.040]                   options(future.plan = NULL)
[11:01:20.040]                   if (is.na(NA_character_)) 
[11:01:20.040]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.040]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.040]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.040]                     .init = FALSE)
[11:01:20.040]                 }
[11:01:20.040]             }
[11:01:20.040]         }
[11:01:20.040]     })
[11:01:20.040]     if (TRUE) {
[11:01:20.040]         base::sink(type = "output", split = FALSE)
[11:01:20.040]         if (TRUE) {
[11:01:20.040]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.040]         }
[11:01:20.040]         else {
[11:01:20.040]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.040]         }
[11:01:20.040]         base::close(...future.stdout)
[11:01:20.040]         ...future.stdout <- NULL
[11:01:20.040]     }
[11:01:20.040]     ...future.result$conditions <- ...future.conditions
[11:01:20.040]     ...future.result$finished <- base::Sys.time()
[11:01:20.040]     ...future.result
[11:01:20.040] }
[11:01:20.042] assign_globals() ...
[11:01:20.042] List of 1
[11:01:20.042]  $ ii: int 2
[11:01:20.042]  - attr(*, "where")=List of 1
[11:01:20.042]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:20.042]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:20.042]  - attr(*, "resolved")= logi FALSE
[11:01:20.042]  - attr(*, "total_size")= num 35
[11:01:20.042]  - attr(*, "already-done")= logi TRUE
[11:01:20.044] - copied ‘ii’ to environment
[11:01:20.044] assign_globals() ... done
[11:01:20.045] plan(): Setting new future strategy stack:
[11:01:20.045] List of future strategies:
[11:01:20.045] 1. sequential:
[11:01:20.045]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.045]    - tweaked: FALSE
[11:01:20.045]    - call: NULL
[11:01:20.045] plan(): nbrOfWorkers() = 1
[11:01:20.046] plan(): Setting new future strategy stack:
[11:01:20.046] List of future strategies:
[11:01:20.046] 1. sequential:
[11:01:20.046]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.046]    - tweaked: FALSE
[11:01:20.046]    - call: plan(strategy)
[11:01:20.046] plan(): nbrOfWorkers() = 1
[11:01:20.047] SequentialFuture started (and completed)
[11:01:20.047] signalConditions() ...
[11:01:20.047]  - include = ‘immediateCondition’
[11:01:20.047]  - exclude = 
[11:01:20.047]  - resignal = FALSE
[11:01:20.047]  - Number of conditions: 1
[11:01:20.047] signalConditions() ... done
[11:01:20.047] - Launch lazy future ... done
[11:01:20.047] run() for ‘SequentialFuture’ ... done
[11:01:20.048] getGlobalsAndPackages() ...
[11:01:20.048] Searching for globals...
[11:01:20.049] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[11:01:20.049] Searching for globals ... DONE
[11:01:20.049] Resolving globals: FALSE
[11:01:20.050] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:20.050] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:20.050] - globals: [1] ‘ii’
[11:01:20.050] 
[11:01:20.050] getGlobalsAndPackages() ... DONE
[11:01:20.051] run() for ‘Future’ ...
[11:01:20.051] - state: ‘created’
[11:01:20.051] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:20.051] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:20.051] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:20.051]   - Field: ‘label’
[11:01:20.051]   - Field: ‘local’
[11:01:20.051]   - Field: ‘owner’
[11:01:20.051]   - Field: ‘envir’
[11:01:20.052]   - Field: ‘packages’
[11:01:20.052]   - Field: ‘gc’
[11:01:20.052]   - Field: ‘conditions’
[11:01:20.052]   - Field: ‘expr’
[11:01:20.052]   - Field: ‘uuid’
[11:01:20.052]   - Field: ‘seed’
[11:01:20.052]   - Field: ‘version’
[11:01:20.052]   - Field: ‘result’
[11:01:20.052]   - Field: ‘asynchronous’
[11:01:20.052]   - Field: ‘calls’
[11:01:20.052]   - Field: ‘globals’
[11:01:20.052]   - Field: ‘stdout’
[11:01:20.053]   - Field: ‘earlySignal’
[11:01:20.053]   - Field: ‘lazy’
[11:01:20.053]   - Field: ‘state’
[11:01:20.053] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:20.053] - Launch lazy future ...
[11:01:20.053] Packages needed by the future expression (n = 0): <none>
[11:01:20.053] Packages needed by future strategies (n = 0): <none>
[11:01:20.053] {
[11:01:20.053]     {
[11:01:20.053]         {
[11:01:20.053]             ...future.startTime <- base::Sys.time()
[11:01:20.053]             {
[11:01:20.053]                 {
[11:01:20.053]                   {
[11:01:20.053]                     base::local({
[11:01:20.053]                       has_future <- base::requireNamespace("future", 
[11:01:20.053]                         quietly = TRUE)
[11:01:20.053]                       if (has_future) {
[11:01:20.053]                         ns <- base::getNamespace("future")
[11:01:20.053]                         version <- ns[[".package"]][["version"]]
[11:01:20.053]                         if (is.null(version)) 
[11:01:20.053]                           version <- utils::packageVersion("future")
[11:01:20.053]                       }
[11:01:20.053]                       else {
[11:01:20.053]                         version <- NULL
[11:01:20.053]                       }
[11:01:20.053]                       if (!has_future || version < "1.8.0") {
[11:01:20.053]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.053]                           "", base::R.version$version.string), 
[11:01:20.053]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:20.053]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.053]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.053]                             "release", "version")], collapse = " "), 
[11:01:20.053]                           hostname = base::Sys.info()[["nodename"]])
[11:01:20.053]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.053]                           info)
[11:01:20.053]                         info <- base::paste(info, collapse = "; ")
[11:01:20.053]                         if (!has_future) {
[11:01:20.053]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.053]                             info)
[11:01:20.053]                         }
[11:01:20.053]                         else {
[11:01:20.053]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.053]                             info, version)
[11:01:20.053]                         }
[11:01:20.053]                         base::stop(msg)
[11:01:20.053]                       }
[11:01:20.053]                     })
[11:01:20.053]                   }
[11:01:20.053]                   ...future.strategy.old <- future::plan("list")
[11:01:20.053]                   options(future.plan = NULL)
[11:01:20.053]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.053]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.053]                 }
[11:01:20.053]                 ...future.workdir <- getwd()
[11:01:20.053]             }
[11:01:20.053]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.053]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.053]         }
[11:01:20.053]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.053]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.053]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.053]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.053]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.053]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.053]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.053]             base::names(...future.oldOptions))
[11:01:20.053]     }
[11:01:20.053]     if (FALSE) {
[11:01:20.053]     }
[11:01:20.053]     else {
[11:01:20.053]         if (TRUE) {
[11:01:20.053]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.053]                 open = "w")
[11:01:20.053]         }
[11:01:20.053]         else {
[11:01:20.053]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.053]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.053]         }
[11:01:20.053]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.053]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.053]             base::sink(type = "output", split = FALSE)
[11:01:20.053]             base::close(...future.stdout)
[11:01:20.053]         }, add = TRUE)
[11:01:20.053]     }
[11:01:20.053]     ...future.frame <- base::sys.nframe()
[11:01:20.053]     ...future.conditions <- base::list()
[11:01:20.053]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.053]     if (FALSE) {
[11:01:20.053]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.053]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.053]     }
[11:01:20.053]     ...future.result <- base::tryCatch({
[11:01:20.053]         base::withCallingHandlers({
[11:01:20.053]             ...future.value <- base::withVisible(base::local({
[11:01:20.053]                 if (ii%%2 == 0) 
[11:01:20.053]                   stop("Woops!")
[11:01:20.053]                 ii
[11:01:20.053]             }))
[11:01:20.053]             future::FutureResult(value = ...future.value$value, 
[11:01:20.053]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.053]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.053]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.053]                     ...future.globalenv.names))
[11:01:20.053]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.053]         }, condition = base::local({
[11:01:20.053]             c <- base::c
[11:01:20.053]             inherits <- base::inherits
[11:01:20.053]             invokeRestart <- base::invokeRestart
[11:01:20.053]             length <- base::length
[11:01:20.053]             list <- base::list
[11:01:20.053]             seq.int <- base::seq.int
[11:01:20.053]             signalCondition <- base::signalCondition
[11:01:20.053]             sys.calls <- base::sys.calls
[11:01:20.053]             `[[` <- base::`[[`
[11:01:20.053]             `+` <- base::`+`
[11:01:20.053]             `<<-` <- base::`<<-`
[11:01:20.053]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.053]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.053]                   3L)]
[11:01:20.053]             }
[11:01:20.053]             function(cond) {
[11:01:20.053]                 is_error <- inherits(cond, "error")
[11:01:20.053]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.053]                   NULL)
[11:01:20.053]                 if (is_error) {
[11:01:20.053]                   sessionInformation <- function() {
[11:01:20.053]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.053]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.053]                       search = base::search(), system = base::Sys.info())
[11:01:20.053]                   }
[11:01:20.053]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.053]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.053]                     cond$call), session = sessionInformation(), 
[11:01:20.053]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.053]                   signalCondition(cond)
[11:01:20.053]                 }
[11:01:20.053]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.053]                 "immediateCondition"))) {
[11:01:20.053]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.053]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.053]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.053]                   if (TRUE && !signal) {
[11:01:20.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.053]                     {
[11:01:20.053]                       inherits <- base::inherits
[11:01:20.053]                       invokeRestart <- base::invokeRestart
[11:01:20.053]                       is.null <- base::is.null
[11:01:20.053]                       muffled <- FALSE
[11:01:20.053]                       if (inherits(cond, "message")) {
[11:01:20.053]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.053]                         if (muffled) 
[11:01:20.053]                           invokeRestart("muffleMessage")
[11:01:20.053]                       }
[11:01:20.053]                       else if (inherits(cond, "warning")) {
[11:01:20.053]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.053]                         if (muffled) 
[11:01:20.053]                           invokeRestart("muffleWarning")
[11:01:20.053]                       }
[11:01:20.053]                       else if (inherits(cond, "condition")) {
[11:01:20.053]                         if (!is.null(pattern)) {
[11:01:20.053]                           computeRestarts <- base::computeRestarts
[11:01:20.053]                           grepl <- base::grepl
[11:01:20.053]                           restarts <- computeRestarts(cond)
[11:01:20.053]                           for (restart in restarts) {
[11:01:20.053]                             name <- restart$name
[11:01:20.053]                             if (is.null(name)) 
[11:01:20.053]                               next
[11:01:20.053]                             if (!grepl(pattern, name)) 
[11:01:20.053]                               next
[11:01:20.053]                             invokeRestart(restart)
[11:01:20.053]                             muffled <- TRUE
[11:01:20.053]                             break
[11:01:20.053]                           }
[11:01:20.053]                         }
[11:01:20.053]                       }
[11:01:20.053]                       invisible(muffled)
[11:01:20.053]                     }
[11:01:20.053]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.053]                   }
[11:01:20.053]                 }
[11:01:20.053]                 else {
[11:01:20.053]                   if (TRUE) {
[11:01:20.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.053]                     {
[11:01:20.053]                       inherits <- base::inherits
[11:01:20.053]                       invokeRestart <- base::invokeRestart
[11:01:20.053]                       is.null <- base::is.null
[11:01:20.053]                       muffled <- FALSE
[11:01:20.053]                       if (inherits(cond, "message")) {
[11:01:20.053]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.053]                         if (muffled) 
[11:01:20.053]                           invokeRestart("muffleMessage")
[11:01:20.053]                       }
[11:01:20.053]                       else if (inherits(cond, "warning")) {
[11:01:20.053]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.053]                         if (muffled) 
[11:01:20.053]                           invokeRestart("muffleWarning")
[11:01:20.053]                       }
[11:01:20.053]                       else if (inherits(cond, "condition")) {
[11:01:20.053]                         if (!is.null(pattern)) {
[11:01:20.053]                           computeRestarts <- base::computeRestarts
[11:01:20.053]                           grepl <- base::grepl
[11:01:20.053]                           restarts <- computeRestarts(cond)
[11:01:20.053]                           for (restart in restarts) {
[11:01:20.053]                             name <- restart$name
[11:01:20.053]                             if (is.null(name)) 
[11:01:20.053]                               next
[11:01:20.053]                             if (!grepl(pattern, name)) 
[11:01:20.053]                               next
[11:01:20.053]                             invokeRestart(restart)
[11:01:20.053]                             muffled <- TRUE
[11:01:20.053]                             break
[11:01:20.053]                           }
[11:01:20.053]                         }
[11:01:20.053]                       }
[11:01:20.053]                       invisible(muffled)
[11:01:20.053]                     }
[11:01:20.053]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.053]                   }
[11:01:20.053]                 }
[11:01:20.053]             }
[11:01:20.053]         }))
[11:01:20.053]     }, error = function(ex) {
[11:01:20.053]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.053]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.053]                 ...future.rng), started = ...future.startTime, 
[11:01:20.053]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.053]             version = "1.8"), class = "FutureResult")
[11:01:20.053]     }, finally = {
[11:01:20.053]         if (!identical(...future.workdir, getwd())) 
[11:01:20.053]             setwd(...future.workdir)
[11:01:20.053]         {
[11:01:20.053]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.053]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.053]             }
[11:01:20.053]             base::options(...future.oldOptions)
[11:01:20.053]             if (.Platform$OS.type == "windows") {
[11:01:20.053]                 old_names <- names(...future.oldEnvVars)
[11:01:20.053]                 envs <- base::Sys.getenv()
[11:01:20.053]                 names <- names(envs)
[11:01:20.053]                 common <- intersect(names, old_names)
[11:01:20.053]                 added <- setdiff(names, old_names)
[11:01:20.053]                 removed <- setdiff(old_names, names)
[11:01:20.053]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.053]                   envs[common]]
[11:01:20.053]                 NAMES <- toupper(changed)
[11:01:20.053]                 args <- list()
[11:01:20.053]                 for (kk in seq_along(NAMES)) {
[11:01:20.053]                   name <- changed[[kk]]
[11:01:20.053]                   NAME <- NAMES[[kk]]
[11:01:20.053]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.053]                     next
[11:01:20.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.053]                 }
[11:01:20.053]                 NAMES <- toupper(added)
[11:01:20.053]                 for (kk in seq_along(NAMES)) {
[11:01:20.053]                   name <- added[[kk]]
[11:01:20.053]                   NAME <- NAMES[[kk]]
[11:01:20.053]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.053]                     next
[11:01:20.053]                   args[[name]] <- ""
[11:01:20.053]                 }
[11:01:20.053]                 NAMES <- toupper(removed)
[11:01:20.053]                 for (kk in seq_along(NAMES)) {
[11:01:20.053]                   name <- removed[[kk]]
[11:01:20.053]                   NAME <- NAMES[[kk]]
[11:01:20.053]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.053]                     next
[11:01:20.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.053]                 }
[11:01:20.053]                 if (length(args) > 0) 
[11:01:20.053]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.053]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.053]             }
[11:01:20.053]             else {
[11:01:20.053]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.053]             }
[11:01:20.053]             {
[11:01:20.053]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.053]                   0L) {
[11:01:20.053]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.053]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.053]                   base::options(opts)
[11:01:20.053]                 }
[11:01:20.053]                 {
[11:01:20.053]                   {
[11:01:20.053]                     NULL
[11:01:20.053]                     RNGkind("Mersenne-Twister")
[11:01:20.053]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:20.053]                       inherits = FALSE)
[11:01:20.053]                   }
[11:01:20.053]                   options(future.plan = NULL)
[11:01:20.053]                   if (is.na(NA_character_)) 
[11:01:20.053]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.053]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.053]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.053]                     .init = FALSE)
[11:01:20.053]                 }
[11:01:20.053]             }
[11:01:20.053]         }
[11:01:20.053]     })
[11:01:20.053]     if (TRUE) {
[11:01:20.053]         base::sink(type = "output", split = FALSE)
[11:01:20.053]         if (TRUE) {
[11:01:20.053]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.053]         }
[11:01:20.053]         else {
[11:01:20.053]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.053]         }
[11:01:20.053]         base::close(...future.stdout)
[11:01:20.053]         ...future.stdout <- NULL
[11:01:20.053]     }
[11:01:20.053]     ...future.result$conditions <- ...future.conditions
[11:01:20.053]     ...future.result$finished <- base::Sys.time()
[11:01:20.053]     ...future.result
[11:01:20.053] }
[11:01:20.055] assign_globals() ...
[11:01:20.055] List of 1
[11:01:20.055]  $ ii: int 3
[11:01:20.055]  - attr(*, "where")=List of 1
[11:01:20.055]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:20.055]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:20.055]  - attr(*, "resolved")= logi FALSE
[11:01:20.055]  - attr(*, "total_size")= num 35
[11:01:20.055]  - attr(*, "already-done")= logi TRUE
[11:01:20.059] - copied ‘ii’ to environment
[11:01:20.059] assign_globals() ... done
[11:01:20.059] plan(): Setting new future strategy stack:
[11:01:20.059] List of future strategies:
[11:01:20.059] 1. sequential:
[11:01:20.059]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.059]    - tweaked: FALSE
[11:01:20.059]    - call: NULL
[11:01:20.059] plan(): nbrOfWorkers() = 1
[11:01:20.060] plan(): Setting new future strategy stack:
[11:01:20.060] List of future strategies:
[11:01:20.060] 1. sequential:
[11:01:20.060]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.060]    - tweaked: FALSE
[11:01:20.060]    - call: plan(strategy)
[11:01:20.061] plan(): nbrOfWorkers() = 1
[11:01:20.061] SequentialFuture started (and completed)
[11:01:20.061] - Launch lazy future ... done
[11:01:20.061] run() for ‘SequentialFuture’ ... done
[11:01:20.061] signalConditions() ...
[11:01:20.061]  - include = ‘immediateCondition’
[11:01:20.061]  - exclude = 
[11:01:20.061]  - resignal = FALSE
[11:01:20.062]  - Number of conditions: 1
[11:01:20.062] signalConditions() ... done
[11:01:20.062] Future state: ‘finished’
[11:01:20.062] signalConditions() ...
[11:01:20.062]  - include = ‘condition’
[11:01:20.062]  - exclude = ‘immediateCondition’
[11:01:20.062]  - resignal = TRUE
[11:01:20.062]  - Number of conditions: 1
[11:01:20.062]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:20.062] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[11:01:20.063] signalConditions() ...
[11:01:20.063]  - include = ‘immediateCondition’
[11:01:20.063]  - exclude = 
[11:01:20.064]  - resignal = FALSE
[11:01:20.064]  - Number of conditions: 1
[11:01:20.064] signalConditions() ... done
[11:01:20.064] Future state: ‘finished’
[11:01:20.064] signalConditions() ...
[11:01:20.064]  - include = ‘condition’
[11:01:20.064]  - exclude = ‘immediateCondition’
[11:01:20.064]  - resignal = TRUE
[11:01:20.064]  - Number of conditions: 1
[11:01:20.064]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:20.064] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[11:01:20.065] signalConditions() ...
[11:01:20.065]  - include = ‘immediateCondition’
[11:01:20.065]  - exclude = 
[11:01:20.065]  - resignal = FALSE
[11:01:20.065]  - Number of conditions: 1
[11:01:20.065] signalConditions() ... done
[11:01:20.065] Future state: ‘finished’
[11:01:20.065] signalConditions() ...
[11:01:20.065]  - include = ‘condition’
[11:01:20.066]  - exclude = ‘immediateCondition’
[11:01:20.066]  - resignal = TRUE
[11:01:20.066]  - Number of conditions: 1
[11:01:20.066]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:20.066] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[11:01:20.066] getGlobalsAndPackages() ...
[11:01:20.066] Searching for globals...
[11:01:20.068] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[11:01:20.068] Searching for globals ... DONE
[11:01:20.068] Resolving globals: FALSE
[11:01:20.069] 
[11:01:20.069] 
[11:01:20.069] getGlobalsAndPackages() ... DONE
[11:01:20.069] run() for ‘Future’ ...
[11:01:20.069] - state: ‘created’
[11:01:20.069] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:20.069] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:20.070] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:20.070]   - Field: ‘label’
[11:01:20.070]   - Field: ‘local’
[11:01:20.070]   - Field: ‘owner’
[11:01:20.070]   - Field: ‘envir’
[11:01:20.070]   - Field: ‘packages’
[11:01:20.070]   - Field: ‘gc’
[11:01:20.070]   - Field: ‘conditions’
[11:01:20.070]   - Field: ‘expr’
[11:01:20.070]   - Field: ‘uuid’
[11:01:20.070]   - Field: ‘seed’
[11:01:20.070]   - Field: ‘version’
[11:01:20.071]   - Field: ‘result’
[11:01:20.071]   - Field: ‘asynchronous’
[11:01:20.071]   - Field: ‘calls’
[11:01:20.071]   - Field: ‘globals’
[11:01:20.071]   - Field: ‘stdout’
[11:01:20.071]   - Field: ‘earlySignal’
[11:01:20.071]   - Field: ‘lazy’
[11:01:20.071]   - Field: ‘state’
[11:01:20.071] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:20.071] - Launch lazy future ...
[11:01:20.071] Packages needed by the future expression (n = 0): <none>
[11:01:20.072] Packages needed by future strategies (n = 0): <none>
[11:01:20.072] {
[11:01:20.072]     {
[11:01:20.072]         {
[11:01:20.072]             ...future.startTime <- base::Sys.time()
[11:01:20.072]             {
[11:01:20.072]                 {
[11:01:20.072]                   {
[11:01:20.072]                     base::local({
[11:01:20.072]                       has_future <- base::requireNamespace("future", 
[11:01:20.072]                         quietly = TRUE)
[11:01:20.072]                       if (has_future) {
[11:01:20.072]                         ns <- base::getNamespace("future")
[11:01:20.072]                         version <- ns[[".package"]][["version"]]
[11:01:20.072]                         if (is.null(version)) 
[11:01:20.072]                           version <- utils::packageVersion("future")
[11:01:20.072]                       }
[11:01:20.072]                       else {
[11:01:20.072]                         version <- NULL
[11:01:20.072]                       }
[11:01:20.072]                       if (!has_future || version < "1.8.0") {
[11:01:20.072]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.072]                           "", base::R.version$version.string), 
[11:01:20.072]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:20.072]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.072]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.072]                             "release", "version")], collapse = " "), 
[11:01:20.072]                           hostname = base::Sys.info()[["nodename"]])
[11:01:20.072]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.072]                           info)
[11:01:20.072]                         info <- base::paste(info, collapse = "; ")
[11:01:20.072]                         if (!has_future) {
[11:01:20.072]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.072]                             info)
[11:01:20.072]                         }
[11:01:20.072]                         else {
[11:01:20.072]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.072]                             info, version)
[11:01:20.072]                         }
[11:01:20.072]                         base::stop(msg)
[11:01:20.072]                       }
[11:01:20.072]                     })
[11:01:20.072]                   }
[11:01:20.072]                   ...future.strategy.old <- future::plan("list")
[11:01:20.072]                   options(future.plan = NULL)
[11:01:20.072]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.072]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.072]                 }
[11:01:20.072]                 ...future.workdir <- getwd()
[11:01:20.072]             }
[11:01:20.072]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.072]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.072]         }
[11:01:20.072]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.072]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.072]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.072]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.072]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.072]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.072]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.072]             base::names(...future.oldOptions))
[11:01:20.072]     }
[11:01:20.072]     if (FALSE) {
[11:01:20.072]     }
[11:01:20.072]     else {
[11:01:20.072]         if (TRUE) {
[11:01:20.072]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.072]                 open = "w")
[11:01:20.072]         }
[11:01:20.072]         else {
[11:01:20.072]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.072]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.072]         }
[11:01:20.072]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.072]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.072]             base::sink(type = "output", split = FALSE)
[11:01:20.072]             base::close(...future.stdout)
[11:01:20.072]         }, add = TRUE)
[11:01:20.072]     }
[11:01:20.072]     ...future.frame <- base::sys.nframe()
[11:01:20.072]     ...future.conditions <- base::list()
[11:01:20.072]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.072]     if (FALSE) {
[11:01:20.072]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.072]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.072]     }
[11:01:20.072]     ...future.result <- base::tryCatch({
[11:01:20.072]         base::withCallingHandlers({
[11:01:20.072]             ...future.value <- base::withVisible(base::local({
[11:01:20.072]                 cat("Processing: ")
[11:01:20.072]                 for (ii in 1:10) {
[11:01:20.072]                   cat(".")
[11:01:20.072]                 }
[11:01:20.072]                 cat(" [100%]\n")
[11:01:20.072]                 4
[11:01:20.072]             }))
[11:01:20.072]             future::FutureResult(value = ...future.value$value, 
[11:01:20.072]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.072]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.072]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.072]                     ...future.globalenv.names))
[11:01:20.072]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.072]         }, condition = base::local({
[11:01:20.072]             c <- base::c
[11:01:20.072]             inherits <- base::inherits
[11:01:20.072]             invokeRestart <- base::invokeRestart
[11:01:20.072]             length <- base::length
[11:01:20.072]             list <- base::list
[11:01:20.072]             seq.int <- base::seq.int
[11:01:20.072]             signalCondition <- base::signalCondition
[11:01:20.072]             sys.calls <- base::sys.calls
[11:01:20.072]             `[[` <- base::`[[`
[11:01:20.072]             `+` <- base::`+`
[11:01:20.072]             `<<-` <- base::`<<-`
[11:01:20.072]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.072]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.072]                   3L)]
[11:01:20.072]             }
[11:01:20.072]             function(cond) {
[11:01:20.072]                 is_error <- inherits(cond, "error")
[11:01:20.072]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.072]                   NULL)
[11:01:20.072]                 if (is_error) {
[11:01:20.072]                   sessionInformation <- function() {
[11:01:20.072]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.072]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.072]                       search = base::search(), system = base::Sys.info())
[11:01:20.072]                   }
[11:01:20.072]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.072]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.072]                     cond$call), session = sessionInformation(), 
[11:01:20.072]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.072]                   signalCondition(cond)
[11:01:20.072]                 }
[11:01:20.072]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.072]                 "immediateCondition"))) {
[11:01:20.072]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.072]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.072]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.072]                   if (TRUE && !signal) {
[11:01:20.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.072]                     {
[11:01:20.072]                       inherits <- base::inherits
[11:01:20.072]                       invokeRestart <- base::invokeRestart
[11:01:20.072]                       is.null <- base::is.null
[11:01:20.072]                       muffled <- FALSE
[11:01:20.072]                       if (inherits(cond, "message")) {
[11:01:20.072]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.072]                         if (muffled) 
[11:01:20.072]                           invokeRestart("muffleMessage")
[11:01:20.072]                       }
[11:01:20.072]                       else if (inherits(cond, "warning")) {
[11:01:20.072]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.072]                         if (muffled) 
[11:01:20.072]                           invokeRestart("muffleWarning")
[11:01:20.072]                       }
[11:01:20.072]                       else if (inherits(cond, "condition")) {
[11:01:20.072]                         if (!is.null(pattern)) {
[11:01:20.072]                           computeRestarts <- base::computeRestarts
[11:01:20.072]                           grepl <- base::grepl
[11:01:20.072]                           restarts <- computeRestarts(cond)
[11:01:20.072]                           for (restart in restarts) {
[11:01:20.072]                             name <- restart$name
[11:01:20.072]                             if (is.null(name)) 
[11:01:20.072]                               next
[11:01:20.072]                             if (!grepl(pattern, name)) 
[11:01:20.072]                               next
[11:01:20.072]                             invokeRestart(restart)
[11:01:20.072]                             muffled <- TRUE
[11:01:20.072]                             break
[11:01:20.072]                           }
[11:01:20.072]                         }
[11:01:20.072]                       }
[11:01:20.072]                       invisible(muffled)
[11:01:20.072]                     }
[11:01:20.072]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.072]                   }
[11:01:20.072]                 }
[11:01:20.072]                 else {
[11:01:20.072]                   if (TRUE) {
[11:01:20.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.072]                     {
[11:01:20.072]                       inherits <- base::inherits
[11:01:20.072]                       invokeRestart <- base::invokeRestart
[11:01:20.072]                       is.null <- base::is.null
[11:01:20.072]                       muffled <- FALSE
[11:01:20.072]                       if (inherits(cond, "message")) {
[11:01:20.072]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.072]                         if (muffled) 
[11:01:20.072]                           invokeRestart("muffleMessage")
[11:01:20.072]                       }
[11:01:20.072]                       else if (inherits(cond, "warning")) {
[11:01:20.072]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.072]                         if (muffled) 
[11:01:20.072]                           invokeRestart("muffleWarning")
[11:01:20.072]                       }
[11:01:20.072]                       else if (inherits(cond, "condition")) {
[11:01:20.072]                         if (!is.null(pattern)) {
[11:01:20.072]                           computeRestarts <- base::computeRestarts
[11:01:20.072]                           grepl <- base::grepl
[11:01:20.072]                           restarts <- computeRestarts(cond)
[11:01:20.072]                           for (restart in restarts) {
[11:01:20.072]                             name <- restart$name
[11:01:20.072]                             if (is.null(name)) 
[11:01:20.072]                               next
[11:01:20.072]                             if (!grepl(pattern, name)) 
[11:01:20.072]                               next
[11:01:20.072]                             invokeRestart(restart)
[11:01:20.072]                             muffled <- TRUE
[11:01:20.072]                             break
[11:01:20.072]                           }
[11:01:20.072]                         }
[11:01:20.072]                       }
[11:01:20.072]                       invisible(muffled)
[11:01:20.072]                     }
[11:01:20.072]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.072]                   }
[11:01:20.072]                 }
[11:01:20.072]             }
[11:01:20.072]         }))
[11:01:20.072]     }, error = function(ex) {
[11:01:20.072]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.072]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.072]                 ...future.rng), started = ...future.startTime, 
[11:01:20.072]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.072]             version = "1.8"), class = "FutureResult")
[11:01:20.072]     }, finally = {
[11:01:20.072]         if (!identical(...future.workdir, getwd())) 
[11:01:20.072]             setwd(...future.workdir)
[11:01:20.072]         {
[11:01:20.072]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.072]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.072]             }
[11:01:20.072]             base::options(...future.oldOptions)
[11:01:20.072]             if (.Platform$OS.type == "windows") {
[11:01:20.072]                 old_names <- names(...future.oldEnvVars)
[11:01:20.072]                 envs <- base::Sys.getenv()
[11:01:20.072]                 names <- names(envs)
[11:01:20.072]                 common <- intersect(names, old_names)
[11:01:20.072]                 added <- setdiff(names, old_names)
[11:01:20.072]                 removed <- setdiff(old_names, names)
[11:01:20.072]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.072]                   envs[common]]
[11:01:20.072]                 NAMES <- toupper(changed)
[11:01:20.072]                 args <- list()
[11:01:20.072]                 for (kk in seq_along(NAMES)) {
[11:01:20.072]                   name <- changed[[kk]]
[11:01:20.072]                   NAME <- NAMES[[kk]]
[11:01:20.072]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.072]                     next
[11:01:20.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.072]                 }
[11:01:20.072]                 NAMES <- toupper(added)
[11:01:20.072]                 for (kk in seq_along(NAMES)) {
[11:01:20.072]                   name <- added[[kk]]
[11:01:20.072]                   NAME <- NAMES[[kk]]
[11:01:20.072]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.072]                     next
[11:01:20.072]                   args[[name]] <- ""
[11:01:20.072]                 }
[11:01:20.072]                 NAMES <- toupper(removed)
[11:01:20.072]                 for (kk in seq_along(NAMES)) {
[11:01:20.072]                   name <- removed[[kk]]
[11:01:20.072]                   NAME <- NAMES[[kk]]
[11:01:20.072]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.072]                     next
[11:01:20.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.072]                 }
[11:01:20.072]                 if (length(args) > 0) 
[11:01:20.072]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.072]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.072]             }
[11:01:20.072]             else {
[11:01:20.072]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.072]             }
[11:01:20.072]             {
[11:01:20.072]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.072]                   0L) {
[11:01:20.072]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.072]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.072]                   base::options(opts)
[11:01:20.072]                 }
[11:01:20.072]                 {
[11:01:20.072]                   {
[11:01:20.072]                     NULL
[11:01:20.072]                     RNGkind("Mersenne-Twister")
[11:01:20.072]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:20.072]                       inherits = FALSE)
[11:01:20.072]                   }
[11:01:20.072]                   options(future.plan = NULL)
[11:01:20.072]                   if (is.na(NA_character_)) 
[11:01:20.072]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.072]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.072]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.072]                     .init = FALSE)
[11:01:20.072]                 }
[11:01:20.072]             }
[11:01:20.072]         }
[11:01:20.072]     })
[11:01:20.072]     if (TRUE) {
[11:01:20.072]         base::sink(type = "output", split = FALSE)
[11:01:20.072]         if (TRUE) {
[11:01:20.072]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.072]         }
[11:01:20.072]         else {
[11:01:20.072]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.072]         }
[11:01:20.072]         base::close(...future.stdout)
[11:01:20.072]         ...future.stdout <- NULL
[11:01:20.072]     }
[11:01:20.072]     ...future.result$conditions <- ...future.conditions
[11:01:20.072]     ...future.result$finished <- base::Sys.time()
[11:01:20.072]     ...future.result
[11:01:20.072] }
[11:01:20.074] plan(): Setting new future strategy stack:
[11:01:20.074] List of future strategies:
[11:01:20.074] 1. sequential:
[11:01:20.074]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.074]    - tweaked: FALSE
[11:01:20.074]    - call: NULL
[11:01:20.074] plan(): nbrOfWorkers() = 1
[11:01:20.075] plan(): Setting new future strategy stack:
[11:01:20.075] List of future strategies:
[11:01:20.075] 1. sequential:
[11:01:20.075]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.075]    - tweaked: FALSE
[11:01:20.075]    - call: plan(strategy)
[11:01:20.075] plan(): nbrOfWorkers() = 1
[11:01:20.076] SequentialFuture started (and completed)
[11:01:20.076] - Launch lazy future ... done
[11:01:20.076] run() for ‘SequentialFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[11:01:20.077] signalConditions() ...
[11:01:20.077]  - include = ‘immediateCondition’
[11:01:20.077]  - exclude = 
[11:01:20.077]  - resignal = FALSE
[11:01:20.077]  - Number of conditions: 1
[11:01:20.077] signalConditions() ... done
[11:01:20.078] Future state: ‘finished’
[11:01:20.078] signalConditions() ...
[11:01:20.078]  - include = ‘condition’
[11:01:20.078]  - exclude = ‘immediateCondition’
[11:01:20.078]  - resignal = TRUE
[11:01:20.078]  - Number of conditions: 1
[11:01:20.078]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:20.078] signalConditions() ... done
v3: <simpleError> (as expect)
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[11:01:20.079] getGlobalsAndPackages() ...
[11:01:20.079] Searching for globals...
[11:01:20.079] 
[11:01:20.079] Searching for globals ... DONE
[11:01:20.079] - globals: [0] <none>
[11:01:20.079] getGlobalsAndPackages() ... DONE
[11:01:20.079] run() for ‘Future’ ...
[11:01:20.080] - state: ‘created’
[11:01:20.080] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:20.080] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:20.080] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:20.080]   - Field: ‘label’
[11:01:20.080]   - Field: ‘local’
[11:01:20.081]   - Field: ‘owner’
[11:01:20.081]   - Field: ‘envir’
[11:01:20.082]   - Field: ‘packages’
[11:01:20.082]   - Field: ‘gc’
[11:01:20.082]   - Field: ‘conditions’
[11:01:20.082]   - Field: ‘expr’
[11:01:20.082]   - Field: ‘uuid’
[11:01:20.082]   - Field: ‘seed’
[11:01:20.082]   - Field: ‘version’
[11:01:20.082]   - Field: ‘result’
[11:01:20.082]   - Field: ‘asynchronous’
[11:01:20.082]   - Field: ‘calls’
[11:01:20.082]   - Field: ‘globals’
[11:01:20.082]   - Field: ‘stdout’
[11:01:20.083]   - Field: ‘earlySignal’
[11:01:20.083]   - Field: ‘lazy’
[11:01:20.083]   - Field: ‘state’
[11:01:20.083] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:20.083] - Launch lazy future ...
[11:01:20.083] Packages needed by the future expression (n = 0): <none>
[11:01:20.083] Packages needed by future strategies (n = 0): <none>
[11:01:20.084] {
[11:01:20.084]     {
[11:01:20.084]         {
[11:01:20.084]             ...future.startTime <- base::Sys.time()
[11:01:20.084]             {
[11:01:20.084]                 {
[11:01:20.084]                   {
[11:01:20.084]                     base::local({
[11:01:20.084]                       has_future <- base::requireNamespace("future", 
[11:01:20.084]                         quietly = TRUE)
[11:01:20.084]                       if (has_future) {
[11:01:20.084]                         ns <- base::getNamespace("future")
[11:01:20.084]                         version <- ns[[".package"]][["version"]]
[11:01:20.084]                         if (is.null(version)) 
[11:01:20.084]                           version <- utils::packageVersion("future")
[11:01:20.084]                       }
[11:01:20.084]                       else {
[11:01:20.084]                         version <- NULL
[11:01:20.084]                       }
[11:01:20.084]                       if (!has_future || version < "1.8.0") {
[11:01:20.084]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.084]                           "", base::R.version$version.string), 
[11:01:20.084]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:20.084]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.084]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.084]                             "release", "version")], collapse = " "), 
[11:01:20.084]                           hostname = base::Sys.info()[["nodename"]])
[11:01:20.084]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.084]                           info)
[11:01:20.084]                         info <- base::paste(info, collapse = "; ")
[11:01:20.084]                         if (!has_future) {
[11:01:20.084]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.084]                             info)
[11:01:20.084]                         }
[11:01:20.084]                         else {
[11:01:20.084]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.084]                             info, version)
[11:01:20.084]                         }
[11:01:20.084]                         base::stop(msg)
[11:01:20.084]                       }
[11:01:20.084]                     })
[11:01:20.084]                   }
[11:01:20.084]                   ...future.strategy.old <- future::plan("list")
[11:01:20.084]                   options(future.plan = NULL)
[11:01:20.084]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.084]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.084]                 }
[11:01:20.084]                 ...future.workdir <- getwd()
[11:01:20.084]             }
[11:01:20.084]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.084]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.084]         }
[11:01:20.084]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.084]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.084]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.084]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.084]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.084]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.084]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.084]             base::names(...future.oldOptions))
[11:01:20.084]     }
[11:01:20.084]     if (FALSE) {
[11:01:20.084]     }
[11:01:20.084]     else {
[11:01:20.084]         if (TRUE) {
[11:01:20.084]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.084]                 open = "w")
[11:01:20.084]         }
[11:01:20.084]         else {
[11:01:20.084]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.084]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.084]         }
[11:01:20.084]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.084]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.084]             base::sink(type = "output", split = FALSE)
[11:01:20.084]             base::close(...future.stdout)
[11:01:20.084]         }, add = TRUE)
[11:01:20.084]     }
[11:01:20.084]     ...future.frame <- base::sys.nframe()
[11:01:20.084]     ...future.conditions <- base::list()
[11:01:20.084]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.084]     if (FALSE) {
[11:01:20.084]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.084]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.084]     }
[11:01:20.084]     ...future.result <- base::tryCatch({
[11:01:20.084]         base::withCallingHandlers({
[11:01:20.084]             ...future.value <- base::withVisible(base::local(1))
[11:01:20.084]             future::FutureResult(value = ...future.value$value, 
[11:01:20.084]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.084]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.084]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.084]                     ...future.globalenv.names))
[11:01:20.084]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.084]         }, condition = base::local({
[11:01:20.084]             c <- base::c
[11:01:20.084]             inherits <- base::inherits
[11:01:20.084]             invokeRestart <- base::invokeRestart
[11:01:20.084]             length <- base::length
[11:01:20.084]             list <- base::list
[11:01:20.084]             seq.int <- base::seq.int
[11:01:20.084]             signalCondition <- base::signalCondition
[11:01:20.084]             sys.calls <- base::sys.calls
[11:01:20.084]             `[[` <- base::`[[`
[11:01:20.084]             `+` <- base::`+`
[11:01:20.084]             `<<-` <- base::`<<-`
[11:01:20.084]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.084]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.084]                   3L)]
[11:01:20.084]             }
[11:01:20.084]             function(cond) {
[11:01:20.084]                 is_error <- inherits(cond, "error")
[11:01:20.084]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.084]                   NULL)
[11:01:20.084]                 if (is_error) {
[11:01:20.084]                   sessionInformation <- function() {
[11:01:20.084]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.084]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.084]                       search = base::search(), system = base::Sys.info())
[11:01:20.084]                   }
[11:01:20.084]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.084]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.084]                     cond$call), session = sessionInformation(), 
[11:01:20.084]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.084]                   signalCondition(cond)
[11:01:20.084]                 }
[11:01:20.084]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.084]                 "immediateCondition"))) {
[11:01:20.084]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.084]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.084]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.084]                   if (TRUE && !signal) {
[11:01:20.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.084]                     {
[11:01:20.084]                       inherits <- base::inherits
[11:01:20.084]                       invokeRestart <- base::invokeRestart
[11:01:20.084]                       is.null <- base::is.null
[11:01:20.084]                       muffled <- FALSE
[11:01:20.084]                       if (inherits(cond, "message")) {
[11:01:20.084]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.084]                         if (muffled) 
[11:01:20.084]                           invokeRestart("muffleMessage")
[11:01:20.084]                       }
[11:01:20.084]                       else if (inherits(cond, "warning")) {
[11:01:20.084]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.084]                         if (muffled) 
[11:01:20.084]                           invokeRestart("muffleWarning")
[11:01:20.084]                       }
[11:01:20.084]                       else if (inherits(cond, "condition")) {
[11:01:20.084]                         if (!is.null(pattern)) {
[11:01:20.084]                           computeRestarts <- base::computeRestarts
[11:01:20.084]                           grepl <- base::grepl
[11:01:20.084]                           restarts <- computeRestarts(cond)
[11:01:20.084]                           for (restart in restarts) {
[11:01:20.084]                             name <- restart$name
[11:01:20.084]                             if (is.null(name)) 
[11:01:20.084]                               next
[11:01:20.084]                             if (!grepl(pattern, name)) 
[11:01:20.084]                               next
[11:01:20.084]                             invokeRestart(restart)
[11:01:20.084]                             muffled <- TRUE
[11:01:20.084]                             break
[11:01:20.084]                           }
[11:01:20.084]                         }
[11:01:20.084]                       }
[11:01:20.084]                       invisible(muffled)
[11:01:20.084]                     }
[11:01:20.084]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.084]                   }
[11:01:20.084]                 }
[11:01:20.084]                 else {
[11:01:20.084]                   if (TRUE) {
[11:01:20.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.084]                     {
[11:01:20.084]                       inherits <- base::inherits
[11:01:20.084]                       invokeRestart <- base::invokeRestart
[11:01:20.084]                       is.null <- base::is.null
[11:01:20.084]                       muffled <- FALSE
[11:01:20.084]                       if (inherits(cond, "message")) {
[11:01:20.084]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.084]                         if (muffled) 
[11:01:20.084]                           invokeRestart("muffleMessage")
[11:01:20.084]                       }
[11:01:20.084]                       else if (inherits(cond, "warning")) {
[11:01:20.084]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.084]                         if (muffled) 
[11:01:20.084]                           invokeRestart("muffleWarning")
[11:01:20.084]                       }
[11:01:20.084]                       else if (inherits(cond, "condition")) {
[11:01:20.084]                         if (!is.null(pattern)) {
[11:01:20.084]                           computeRestarts <- base::computeRestarts
[11:01:20.084]                           grepl <- base::grepl
[11:01:20.084]                           restarts <- computeRestarts(cond)
[11:01:20.084]                           for (restart in restarts) {
[11:01:20.084]                             name <- restart$name
[11:01:20.084]                             if (is.null(name)) 
[11:01:20.084]                               next
[11:01:20.084]                             if (!grepl(pattern, name)) 
[11:01:20.084]                               next
[11:01:20.084]                             invokeRestart(restart)
[11:01:20.084]                             muffled <- TRUE
[11:01:20.084]                             break
[11:01:20.084]                           }
[11:01:20.084]                         }
[11:01:20.084]                       }
[11:01:20.084]                       invisible(muffled)
[11:01:20.084]                     }
[11:01:20.084]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.084]                   }
[11:01:20.084]                 }
[11:01:20.084]             }
[11:01:20.084]         }))
[11:01:20.084]     }, error = function(ex) {
[11:01:20.084]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.084]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.084]                 ...future.rng), started = ...future.startTime, 
[11:01:20.084]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.084]             version = "1.8"), class = "FutureResult")
[11:01:20.084]     }, finally = {
[11:01:20.084]         if (!identical(...future.workdir, getwd())) 
[11:01:20.084]             setwd(...future.workdir)
[11:01:20.084]         {
[11:01:20.084]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.084]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.084]             }
[11:01:20.084]             base::options(...future.oldOptions)
[11:01:20.084]             if (.Platform$OS.type == "windows") {
[11:01:20.084]                 old_names <- names(...future.oldEnvVars)
[11:01:20.084]                 envs <- base::Sys.getenv()
[11:01:20.084]                 names <- names(envs)
[11:01:20.084]                 common <- intersect(names, old_names)
[11:01:20.084]                 added <- setdiff(names, old_names)
[11:01:20.084]                 removed <- setdiff(old_names, names)
[11:01:20.084]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.084]                   envs[common]]
[11:01:20.084]                 NAMES <- toupper(changed)
[11:01:20.084]                 args <- list()
[11:01:20.084]                 for (kk in seq_along(NAMES)) {
[11:01:20.084]                   name <- changed[[kk]]
[11:01:20.084]                   NAME <- NAMES[[kk]]
[11:01:20.084]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.084]                     next
[11:01:20.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.084]                 }
[11:01:20.084]                 NAMES <- toupper(added)
[11:01:20.084]                 for (kk in seq_along(NAMES)) {
[11:01:20.084]                   name <- added[[kk]]
[11:01:20.084]                   NAME <- NAMES[[kk]]
[11:01:20.084]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.084]                     next
[11:01:20.084]                   args[[name]] <- ""
[11:01:20.084]                 }
[11:01:20.084]                 NAMES <- toupper(removed)
[11:01:20.084]                 for (kk in seq_along(NAMES)) {
[11:01:20.084]                   name <- removed[[kk]]
[11:01:20.084]                   NAME <- NAMES[[kk]]
[11:01:20.084]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.084]                     next
[11:01:20.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.084]                 }
[11:01:20.084]                 if (length(args) > 0) 
[11:01:20.084]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.084]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.084]             }
[11:01:20.084]             else {
[11:01:20.084]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.084]             }
[11:01:20.084]             {
[11:01:20.084]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.084]                   0L) {
[11:01:20.084]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.084]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.084]                   base::options(opts)
[11:01:20.084]                 }
[11:01:20.084]                 {
[11:01:20.084]                   {
[11:01:20.084]                     NULL
[11:01:20.084]                     RNGkind("Mersenne-Twister")
[11:01:20.084]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:20.084]                       inherits = FALSE)
[11:01:20.084]                   }
[11:01:20.084]                   options(future.plan = NULL)
[11:01:20.084]                   if (is.na(NA_character_)) 
[11:01:20.084]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.084]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.084]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.084]                     .init = FALSE)
[11:01:20.084]                 }
[11:01:20.084]             }
[11:01:20.084]         }
[11:01:20.084]     })
[11:01:20.084]     if (TRUE) {
[11:01:20.084]         base::sink(type = "output", split = FALSE)
[11:01:20.084]         if (TRUE) {
[11:01:20.084]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.084]         }
[11:01:20.084]         else {
[11:01:20.084]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.084]         }
[11:01:20.084]         base::close(...future.stdout)
[11:01:20.084]         ...future.stdout <- NULL
[11:01:20.084]     }
[11:01:20.084]     ...future.result$conditions <- ...future.conditions
[11:01:20.084]     ...future.result$finished <- base::Sys.time()
[11:01:20.084]     ...future.result
[11:01:20.084] }
[11:01:20.085] plan(): Setting new future strategy stack:
[11:01:20.085] List of future strategies:
[11:01:20.085] 1. sequential:
[11:01:20.085]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.085]    - tweaked: FALSE
[11:01:20.085]    - call: NULL
[11:01:20.086] plan(): nbrOfWorkers() = 1
[11:01:20.086] plan(): Setting new future strategy stack:
[11:01:20.087] List of future strategies:
[11:01:20.087] 1. sequential:
[11:01:20.087]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.087]    - tweaked: FALSE
[11:01:20.087]    - call: plan(strategy)
[11:01:20.087] plan(): nbrOfWorkers() = 1
[11:01:20.087] SequentialFuture started (and completed)
[11:01:20.087] - Launch lazy future ... done
[11:01:20.087] run() for ‘SequentialFuture’ ... done
c = 1
[11:01:20.088] getGlobalsAndPackages() ...
[11:01:20.088] Searching for globals...
[11:01:20.088] 
[11:01:20.088] Searching for globals ... DONE
[11:01:20.088] - globals: [0] <none>
[11:01:20.088] getGlobalsAndPackages() ... DONE
[11:01:20.088] run() for ‘Future’ ...
[11:01:20.089] - state: ‘created’
[11:01:20.089] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:20.089] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:20.089] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:20.089]   - Field: ‘label’
[11:01:20.089]   - Field: ‘local’
[11:01:20.089]   - Field: ‘owner’
[11:01:20.089]   - Field: ‘envir’
[11:01:20.089]   - Field: ‘packages’
[11:01:20.090]   - Field: ‘gc’
[11:01:20.090]   - Field: ‘conditions’
[11:01:20.090]   - Field: ‘expr’
[11:01:20.090]   - Field: ‘uuid’
[11:01:20.090]   - Field: ‘seed’
[11:01:20.090]   - Field: ‘version’
[11:01:20.090]   - Field: ‘result’
[11:01:20.090]   - Field: ‘asynchronous’
[11:01:20.090]   - Field: ‘calls’
[11:01:20.090]   - Field: ‘globals’
[11:01:20.090]   - Field: ‘stdout’
[11:01:20.090]   - Field: ‘earlySignal’
[11:01:20.091]   - Field: ‘lazy’
[11:01:20.091]   - Field: ‘state’
[11:01:20.091] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:20.091] - Launch lazy future ...
[11:01:20.091] Packages needed by the future expression (n = 0): <none>
[11:01:20.091] Packages needed by future strategies (n = 0): <none>
[11:01:20.091] {
[11:01:20.091]     {
[11:01:20.091]         {
[11:01:20.091]             ...future.startTime <- base::Sys.time()
[11:01:20.091]             {
[11:01:20.091]                 {
[11:01:20.091]                   {
[11:01:20.091]                     base::local({
[11:01:20.091]                       has_future <- base::requireNamespace("future", 
[11:01:20.091]                         quietly = TRUE)
[11:01:20.091]                       if (has_future) {
[11:01:20.091]                         ns <- base::getNamespace("future")
[11:01:20.091]                         version <- ns[[".package"]][["version"]]
[11:01:20.091]                         if (is.null(version)) 
[11:01:20.091]                           version <- utils::packageVersion("future")
[11:01:20.091]                       }
[11:01:20.091]                       else {
[11:01:20.091]                         version <- NULL
[11:01:20.091]                       }
[11:01:20.091]                       if (!has_future || version < "1.8.0") {
[11:01:20.091]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.091]                           "", base::R.version$version.string), 
[11:01:20.091]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:20.091]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.091]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.091]                             "release", "version")], collapse = " "), 
[11:01:20.091]                           hostname = base::Sys.info()[["nodename"]])
[11:01:20.091]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.091]                           info)
[11:01:20.091]                         info <- base::paste(info, collapse = "; ")
[11:01:20.091]                         if (!has_future) {
[11:01:20.091]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.091]                             info)
[11:01:20.091]                         }
[11:01:20.091]                         else {
[11:01:20.091]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.091]                             info, version)
[11:01:20.091]                         }
[11:01:20.091]                         base::stop(msg)
[11:01:20.091]                       }
[11:01:20.091]                     })
[11:01:20.091]                   }
[11:01:20.091]                   ...future.strategy.old <- future::plan("list")
[11:01:20.091]                   options(future.plan = NULL)
[11:01:20.091]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.091]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.091]                 }
[11:01:20.091]                 ...future.workdir <- getwd()
[11:01:20.091]             }
[11:01:20.091]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.091]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.091]         }
[11:01:20.091]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.091]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.091]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.091]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.091]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.091]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.091]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.091]             base::names(...future.oldOptions))
[11:01:20.091]     }
[11:01:20.091]     if (FALSE) {
[11:01:20.091]     }
[11:01:20.091]     else {
[11:01:20.091]         if (TRUE) {
[11:01:20.091]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.091]                 open = "w")
[11:01:20.091]         }
[11:01:20.091]         else {
[11:01:20.091]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.091]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.091]         }
[11:01:20.091]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.091]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.091]             base::sink(type = "output", split = FALSE)
[11:01:20.091]             base::close(...future.stdout)
[11:01:20.091]         }, add = TRUE)
[11:01:20.091]     }
[11:01:20.091]     ...future.frame <- base::sys.nframe()
[11:01:20.091]     ...future.conditions <- base::list()
[11:01:20.091]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.091]     if (FALSE) {
[11:01:20.091]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.091]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.091]     }
[11:01:20.091]     ...future.result <- base::tryCatch({
[11:01:20.091]         base::withCallingHandlers({
[11:01:20.091]             ...future.value <- base::withVisible(base::local(1))
[11:01:20.091]             future::FutureResult(value = ...future.value$value, 
[11:01:20.091]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.091]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.091]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.091]                     ...future.globalenv.names))
[11:01:20.091]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.091]         }, condition = base::local({
[11:01:20.091]             c <- base::c
[11:01:20.091]             inherits <- base::inherits
[11:01:20.091]             invokeRestart <- base::invokeRestart
[11:01:20.091]             length <- base::length
[11:01:20.091]             list <- base::list
[11:01:20.091]             seq.int <- base::seq.int
[11:01:20.091]             signalCondition <- base::signalCondition
[11:01:20.091]             sys.calls <- base::sys.calls
[11:01:20.091]             `[[` <- base::`[[`
[11:01:20.091]             `+` <- base::`+`
[11:01:20.091]             `<<-` <- base::`<<-`
[11:01:20.091]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.091]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.091]                   3L)]
[11:01:20.091]             }
[11:01:20.091]             function(cond) {
[11:01:20.091]                 is_error <- inherits(cond, "error")
[11:01:20.091]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.091]                   NULL)
[11:01:20.091]                 if (is_error) {
[11:01:20.091]                   sessionInformation <- function() {
[11:01:20.091]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.091]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.091]                       search = base::search(), system = base::Sys.info())
[11:01:20.091]                   }
[11:01:20.091]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.091]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.091]                     cond$call), session = sessionInformation(), 
[11:01:20.091]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.091]                   signalCondition(cond)
[11:01:20.091]                 }
[11:01:20.091]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.091]                 "immediateCondition"))) {
[11:01:20.091]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.091]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.091]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.091]                   if (TRUE && !signal) {
[11:01:20.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.091]                     {
[11:01:20.091]                       inherits <- base::inherits
[11:01:20.091]                       invokeRestart <- base::invokeRestart
[11:01:20.091]                       is.null <- base::is.null
[11:01:20.091]                       muffled <- FALSE
[11:01:20.091]                       if (inherits(cond, "message")) {
[11:01:20.091]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.091]                         if (muffled) 
[11:01:20.091]                           invokeRestart("muffleMessage")
[11:01:20.091]                       }
[11:01:20.091]                       else if (inherits(cond, "warning")) {
[11:01:20.091]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.091]                         if (muffled) 
[11:01:20.091]                           invokeRestart("muffleWarning")
[11:01:20.091]                       }
[11:01:20.091]                       else if (inherits(cond, "condition")) {
[11:01:20.091]                         if (!is.null(pattern)) {
[11:01:20.091]                           computeRestarts <- base::computeRestarts
[11:01:20.091]                           grepl <- base::grepl
[11:01:20.091]                           restarts <- computeRestarts(cond)
[11:01:20.091]                           for (restart in restarts) {
[11:01:20.091]                             name <- restart$name
[11:01:20.091]                             if (is.null(name)) 
[11:01:20.091]                               next
[11:01:20.091]                             if (!grepl(pattern, name)) 
[11:01:20.091]                               next
[11:01:20.091]                             invokeRestart(restart)
[11:01:20.091]                             muffled <- TRUE
[11:01:20.091]                             break
[11:01:20.091]                           }
[11:01:20.091]                         }
[11:01:20.091]                       }
[11:01:20.091]                       invisible(muffled)
[11:01:20.091]                     }
[11:01:20.091]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.091]                   }
[11:01:20.091]                 }
[11:01:20.091]                 else {
[11:01:20.091]                   if (TRUE) {
[11:01:20.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.091]                     {
[11:01:20.091]                       inherits <- base::inherits
[11:01:20.091]                       invokeRestart <- base::invokeRestart
[11:01:20.091]                       is.null <- base::is.null
[11:01:20.091]                       muffled <- FALSE
[11:01:20.091]                       if (inherits(cond, "message")) {
[11:01:20.091]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.091]                         if (muffled) 
[11:01:20.091]                           invokeRestart("muffleMessage")
[11:01:20.091]                       }
[11:01:20.091]                       else if (inherits(cond, "warning")) {
[11:01:20.091]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.091]                         if (muffled) 
[11:01:20.091]                           invokeRestart("muffleWarning")
[11:01:20.091]                       }
[11:01:20.091]                       else if (inherits(cond, "condition")) {
[11:01:20.091]                         if (!is.null(pattern)) {
[11:01:20.091]                           computeRestarts <- base::computeRestarts
[11:01:20.091]                           grepl <- base::grepl
[11:01:20.091]                           restarts <- computeRestarts(cond)
[11:01:20.091]                           for (restart in restarts) {
[11:01:20.091]                             name <- restart$name
[11:01:20.091]                             if (is.null(name)) 
[11:01:20.091]                               next
[11:01:20.091]                             if (!grepl(pattern, name)) 
[11:01:20.091]                               next
[11:01:20.091]                             invokeRestart(restart)
[11:01:20.091]                             muffled <- TRUE
[11:01:20.091]                             break
[11:01:20.091]                           }
[11:01:20.091]                         }
[11:01:20.091]                       }
[11:01:20.091]                       invisible(muffled)
[11:01:20.091]                     }
[11:01:20.091]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.091]                   }
[11:01:20.091]                 }
[11:01:20.091]             }
[11:01:20.091]         }))
[11:01:20.091]     }, error = function(ex) {
[11:01:20.091]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.091]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.091]                 ...future.rng), started = ...future.startTime, 
[11:01:20.091]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.091]             version = "1.8"), class = "FutureResult")
[11:01:20.091]     }, finally = {
[11:01:20.091]         if (!identical(...future.workdir, getwd())) 
[11:01:20.091]             setwd(...future.workdir)
[11:01:20.091]         {
[11:01:20.091]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.091]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.091]             }
[11:01:20.091]             base::options(...future.oldOptions)
[11:01:20.091]             if (.Platform$OS.type == "windows") {
[11:01:20.091]                 old_names <- names(...future.oldEnvVars)
[11:01:20.091]                 envs <- base::Sys.getenv()
[11:01:20.091]                 names <- names(envs)
[11:01:20.091]                 common <- intersect(names, old_names)
[11:01:20.091]                 added <- setdiff(names, old_names)
[11:01:20.091]                 removed <- setdiff(old_names, names)
[11:01:20.091]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.091]                   envs[common]]
[11:01:20.091]                 NAMES <- toupper(changed)
[11:01:20.091]                 args <- list()
[11:01:20.091]                 for (kk in seq_along(NAMES)) {
[11:01:20.091]                   name <- changed[[kk]]
[11:01:20.091]                   NAME <- NAMES[[kk]]
[11:01:20.091]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.091]                     next
[11:01:20.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.091]                 }
[11:01:20.091]                 NAMES <- toupper(added)
[11:01:20.091]                 for (kk in seq_along(NAMES)) {
[11:01:20.091]                   name <- added[[kk]]
[11:01:20.091]                   NAME <- NAMES[[kk]]
[11:01:20.091]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.091]                     next
[11:01:20.091]                   args[[name]] <- ""
[11:01:20.091]                 }
[11:01:20.091]                 NAMES <- toupper(removed)
[11:01:20.091]                 for (kk in seq_along(NAMES)) {
[11:01:20.091]                   name <- removed[[kk]]
[11:01:20.091]                   NAME <- NAMES[[kk]]
[11:01:20.091]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.091]                     next
[11:01:20.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.091]                 }
[11:01:20.091]                 if (length(args) > 0) 
[11:01:20.091]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.091]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.091]             }
[11:01:20.091]             else {
[11:01:20.091]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.091]             }
[11:01:20.091]             {
[11:01:20.091]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.091]                   0L) {
[11:01:20.091]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.091]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.091]                   base::options(opts)
[11:01:20.091]                 }
[11:01:20.091]                 {
[11:01:20.091]                   {
[11:01:20.091]                     NULL
[11:01:20.091]                     RNGkind("Mersenne-Twister")
[11:01:20.091]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:20.091]                       inherits = FALSE)
[11:01:20.091]                   }
[11:01:20.091]                   options(future.plan = NULL)
[11:01:20.091]                   if (is.na(NA_character_)) 
[11:01:20.091]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.091]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.091]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.091]                     .init = FALSE)
[11:01:20.091]                 }
[11:01:20.091]             }
[11:01:20.091]         }
[11:01:20.091]     })
[11:01:20.091]     if (TRUE) {
[11:01:20.091]         base::sink(type = "output", split = FALSE)
[11:01:20.091]         if (TRUE) {
[11:01:20.091]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.091]         }
[11:01:20.091]         else {
[11:01:20.091]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.091]         }
[11:01:20.091]         base::close(...future.stdout)
[11:01:20.091]         ...future.stdout <- NULL
[11:01:20.091]     }
[11:01:20.091]     ...future.result$conditions <- ...future.conditions
[11:01:20.091]     ...future.result$finished <- base::Sys.time()
[11:01:20.091]     ...future.result
[11:01:20.091] }
[11:01:20.093] plan(): Setting new future strategy stack:
[11:01:20.093] List of future strategies:
[11:01:20.093] 1. sequential:
[11:01:20.093]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.093]    - tweaked: FALSE
[11:01:20.093]    - call: NULL
[11:01:20.094] plan(): nbrOfWorkers() = 1
[11:01:20.094] plan(): Setting new future strategy stack:
[11:01:20.094] List of future strategies:
[11:01:20.094] 1. sequential:
[11:01:20.094]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.094]    - tweaked: FALSE
[11:01:20.094]    - call: plan(strategy)
[11:01:20.095] plan(): nbrOfWorkers() = 1
[11:01:20.095] SequentialFuture started (and completed)
[11:01:20.095] - Launch lazy future ... done
[11:01:20.095] run() for ‘SequentialFuture’ ... done
d = 1
** Nested future assignments
[11:01:20.096] getGlobalsAndPackages() ...
[11:01:20.096] Searching for globals...
[11:01:20.099] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[11:01:20.099] Searching for globals ... DONE
[11:01:20.099] Resolving globals: FALSE
[11:01:20.100] 
[11:01:20.100] - packages: [1] ‘future’
[11:01:20.100] getGlobalsAndPackages() ... DONE
[11:01:20.100] run() for ‘Future’ ...
[11:01:20.100] - state: ‘created’
[11:01:20.100] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:20.100] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:20.101] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:20.101]   - Field: ‘label’
[11:01:20.101]   - Field: ‘local’
[11:01:20.101]   - Field: ‘owner’
[11:01:20.101]   - Field: ‘envir’
[11:01:20.101]   - Field: ‘packages’
[11:01:20.101]   - Field: ‘gc’
[11:01:20.101]   - Field: ‘conditions’
[11:01:20.101]   - Field: ‘expr’
[11:01:20.101]   - Field: ‘uuid’
[11:01:20.102]   - Field: ‘seed’
[11:01:20.102]   - Field: ‘version’
[11:01:20.102]   - Field: ‘result’
[11:01:20.102]   - Field: ‘asynchronous’
[11:01:20.102]   - Field: ‘calls’
[11:01:20.102]   - Field: ‘globals’
[11:01:20.102]   - Field: ‘stdout’
[11:01:20.102]   - Field: ‘earlySignal’
[11:01:20.102]   - Field: ‘lazy’
[11:01:20.102]   - Field: ‘state’
[11:01:20.102] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:20.102] - Launch lazy future ...
[11:01:20.103] Packages needed by the future expression (n = 1): ‘future’
[11:01:20.103] Packages needed by future strategies (n = 0): <none>
[11:01:20.103] {
[11:01:20.103]     {
[11:01:20.103]         {
[11:01:20.103]             ...future.startTime <- base::Sys.time()
[11:01:20.103]             {
[11:01:20.103]                 {
[11:01:20.103]                   {
[11:01:20.103]                     {
[11:01:20.103]                       base::local({
[11:01:20.103]                         has_future <- base::requireNamespace("future", 
[11:01:20.103]                           quietly = TRUE)
[11:01:20.103]                         if (has_future) {
[11:01:20.103]                           ns <- base::getNamespace("future")
[11:01:20.103]                           version <- ns[[".package"]][["version"]]
[11:01:20.103]                           if (is.null(version)) 
[11:01:20.103]                             version <- utils::packageVersion("future")
[11:01:20.103]                         }
[11:01:20.103]                         else {
[11:01:20.103]                           version <- NULL
[11:01:20.103]                         }
[11:01:20.103]                         if (!has_future || version < "1.8.0") {
[11:01:20.103]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.103]                             "", base::R.version$version.string), 
[11:01:20.103]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:20.103]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.103]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.103]                               "release", "version")], collapse = " "), 
[11:01:20.103]                             hostname = base::Sys.info()[["nodename"]])
[11:01:20.103]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.103]                             info)
[11:01:20.103]                           info <- base::paste(info, collapse = "; ")
[11:01:20.103]                           if (!has_future) {
[11:01:20.103]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.103]                               info)
[11:01:20.103]                           }
[11:01:20.103]                           else {
[11:01:20.103]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.103]                               info, version)
[11:01:20.103]                           }
[11:01:20.103]                           base::stop(msg)
[11:01:20.103]                         }
[11:01:20.103]                       })
[11:01:20.103]                     }
[11:01:20.103]                     base::local({
[11:01:20.103]                       for (pkg in "future") {
[11:01:20.103]                         base::loadNamespace(pkg)
[11:01:20.103]                         base::library(pkg, character.only = TRUE)
[11:01:20.103]                       }
[11:01:20.103]                     })
[11:01:20.103]                   }
[11:01:20.103]                   ...future.strategy.old <- future::plan("list")
[11:01:20.103]                   options(future.plan = NULL)
[11:01:20.103]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.103]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.103]                 }
[11:01:20.103]                 ...future.workdir <- getwd()
[11:01:20.103]             }
[11:01:20.103]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.103]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.103]         }
[11:01:20.103]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.103]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.103]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.103]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.103]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.103]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.103]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.103]             base::names(...future.oldOptions))
[11:01:20.103]     }
[11:01:20.103]     if (FALSE) {
[11:01:20.103]     }
[11:01:20.103]     else {
[11:01:20.103]         if (TRUE) {
[11:01:20.103]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.103]                 open = "w")
[11:01:20.103]         }
[11:01:20.103]         else {
[11:01:20.103]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.103]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.103]         }
[11:01:20.103]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.103]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.103]             base::sink(type = "output", split = FALSE)
[11:01:20.103]             base::close(...future.stdout)
[11:01:20.103]         }, add = TRUE)
[11:01:20.103]     }
[11:01:20.103]     ...future.frame <- base::sys.nframe()
[11:01:20.103]     ...future.conditions <- base::list()
[11:01:20.103]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.103]     if (FALSE) {
[11:01:20.103]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.103]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.103]     }
[11:01:20.103]     ...future.result <- base::tryCatch({
[11:01:20.103]         base::withCallingHandlers({
[11:01:20.103]             ...future.value <- base::withVisible(base::local({
[11:01:20.103]                 b <- 1
[11:01:20.103]                 c %<-% 2
[11:01:20.103]                 d <- 3
[11:01:20.103]                 4 %->% e
[11:01:20.103]                 b + c + d + e
[11:01:20.103]             }))
[11:01:20.103]             future::FutureResult(value = ...future.value$value, 
[11:01:20.103]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.103]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.103]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.103]                     ...future.globalenv.names))
[11:01:20.103]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.103]         }, condition = base::local({
[11:01:20.103]             c <- base::c
[11:01:20.103]             inherits <- base::inherits
[11:01:20.103]             invokeRestart <- base::invokeRestart
[11:01:20.103]             length <- base::length
[11:01:20.103]             list <- base::list
[11:01:20.103]             seq.int <- base::seq.int
[11:01:20.103]             signalCondition <- base::signalCondition
[11:01:20.103]             sys.calls <- base::sys.calls
[11:01:20.103]             `[[` <- base::`[[`
[11:01:20.103]             `+` <- base::`+`
[11:01:20.103]             `<<-` <- base::`<<-`
[11:01:20.103]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.103]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.103]                   3L)]
[11:01:20.103]             }
[11:01:20.103]             function(cond) {
[11:01:20.103]                 is_error <- inherits(cond, "error")
[11:01:20.103]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.103]                   NULL)
[11:01:20.103]                 if (is_error) {
[11:01:20.103]                   sessionInformation <- function() {
[11:01:20.103]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.103]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.103]                       search = base::search(), system = base::Sys.info())
[11:01:20.103]                   }
[11:01:20.103]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.103]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.103]                     cond$call), session = sessionInformation(), 
[11:01:20.103]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.103]                   signalCondition(cond)
[11:01:20.103]                 }
[11:01:20.103]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.103]                 "immediateCondition"))) {
[11:01:20.103]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.103]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.103]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.103]                   if (TRUE && !signal) {
[11:01:20.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.103]                     {
[11:01:20.103]                       inherits <- base::inherits
[11:01:20.103]                       invokeRestart <- base::invokeRestart
[11:01:20.103]                       is.null <- base::is.null
[11:01:20.103]                       muffled <- FALSE
[11:01:20.103]                       if (inherits(cond, "message")) {
[11:01:20.103]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.103]                         if (muffled) 
[11:01:20.103]                           invokeRestart("muffleMessage")
[11:01:20.103]                       }
[11:01:20.103]                       else if (inherits(cond, "warning")) {
[11:01:20.103]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.103]                         if (muffled) 
[11:01:20.103]                           invokeRestart("muffleWarning")
[11:01:20.103]                       }
[11:01:20.103]                       else if (inherits(cond, "condition")) {
[11:01:20.103]                         if (!is.null(pattern)) {
[11:01:20.103]                           computeRestarts <- base::computeRestarts
[11:01:20.103]                           grepl <- base::grepl
[11:01:20.103]                           restarts <- computeRestarts(cond)
[11:01:20.103]                           for (restart in restarts) {
[11:01:20.103]                             name <- restart$name
[11:01:20.103]                             if (is.null(name)) 
[11:01:20.103]                               next
[11:01:20.103]                             if (!grepl(pattern, name)) 
[11:01:20.103]                               next
[11:01:20.103]                             invokeRestart(restart)
[11:01:20.103]                             muffled <- TRUE
[11:01:20.103]                             break
[11:01:20.103]                           }
[11:01:20.103]                         }
[11:01:20.103]                       }
[11:01:20.103]                       invisible(muffled)
[11:01:20.103]                     }
[11:01:20.103]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.103]                   }
[11:01:20.103]                 }
[11:01:20.103]                 else {
[11:01:20.103]                   if (TRUE) {
[11:01:20.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.103]                     {
[11:01:20.103]                       inherits <- base::inherits
[11:01:20.103]                       invokeRestart <- base::invokeRestart
[11:01:20.103]                       is.null <- base::is.null
[11:01:20.103]                       muffled <- FALSE
[11:01:20.103]                       if (inherits(cond, "message")) {
[11:01:20.103]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.103]                         if (muffled) 
[11:01:20.103]                           invokeRestart("muffleMessage")
[11:01:20.103]                       }
[11:01:20.103]                       else if (inherits(cond, "warning")) {
[11:01:20.103]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.103]                         if (muffled) 
[11:01:20.103]                           invokeRestart("muffleWarning")
[11:01:20.103]                       }
[11:01:20.103]                       else if (inherits(cond, "condition")) {
[11:01:20.103]                         if (!is.null(pattern)) {
[11:01:20.103]                           computeRestarts <- base::computeRestarts
[11:01:20.103]                           grepl <- base::grepl
[11:01:20.103]                           restarts <- computeRestarts(cond)
[11:01:20.103]                           for (restart in restarts) {
[11:01:20.103]                             name <- restart$name
[11:01:20.103]                             if (is.null(name)) 
[11:01:20.103]                               next
[11:01:20.103]                             if (!grepl(pattern, name)) 
[11:01:20.103]                               next
[11:01:20.103]                             invokeRestart(restart)
[11:01:20.103]                             muffled <- TRUE
[11:01:20.103]                             break
[11:01:20.103]                           }
[11:01:20.103]                         }
[11:01:20.103]                       }
[11:01:20.103]                       invisible(muffled)
[11:01:20.103]                     }
[11:01:20.103]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.103]                   }
[11:01:20.103]                 }
[11:01:20.103]             }
[11:01:20.103]         }))
[11:01:20.103]     }, error = function(ex) {
[11:01:20.103]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.103]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.103]                 ...future.rng), started = ...future.startTime, 
[11:01:20.103]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.103]             version = "1.8"), class = "FutureResult")
[11:01:20.103]     }, finally = {
[11:01:20.103]         if (!identical(...future.workdir, getwd())) 
[11:01:20.103]             setwd(...future.workdir)
[11:01:20.103]         {
[11:01:20.103]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.103]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.103]             }
[11:01:20.103]             base::options(...future.oldOptions)
[11:01:20.103]             if (.Platform$OS.type == "windows") {
[11:01:20.103]                 old_names <- names(...future.oldEnvVars)
[11:01:20.103]                 envs <- base::Sys.getenv()
[11:01:20.103]                 names <- names(envs)
[11:01:20.103]                 common <- intersect(names, old_names)
[11:01:20.103]                 added <- setdiff(names, old_names)
[11:01:20.103]                 removed <- setdiff(old_names, names)
[11:01:20.103]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.103]                   envs[common]]
[11:01:20.103]                 NAMES <- toupper(changed)
[11:01:20.103]                 args <- list()
[11:01:20.103]                 for (kk in seq_along(NAMES)) {
[11:01:20.103]                   name <- changed[[kk]]
[11:01:20.103]                   NAME <- NAMES[[kk]]
[11:01:20.103]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.103]                     next
[11:01:20.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.103]                 }
[11:01:20.103]                 NAMES <- toupper(added)
[11:01:20.103]                 for (kk in seq_along(NAMES)) {
[11:01:20.103]                   name <- added[[kk]]
[11:01:20.103]                   NAME <- NAMES[[kk]]
[11:01:20.103]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.103]                     next
[11:01:20.103]                   args[[name]] <- ""
[11:01:20.103]                 }
[11:01:20.103]                 NAMES <- toupper(removed)
[11:01:20.103]                 for (kk in seq_along(NAMES)) {
[11:01:20.103]                   name <- removed[[kk]]
[11:01:20.103]                   NAME <- NAMES[[kk]]
[11:01:20.103]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.103]                     next
[11:01:20.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.103]                 }
[11:01:20.103]                 if (length(args) > 0) 
[11:01:20.103]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.103]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.103]             }
[11:01:20.103]             else {
[11:01:20.103]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.103]             }
[11:01:20.103]             {
[11:01:20.103]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.103]                   0L) {
[11:01:20.103]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.103]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.103]                   base::options(opts)
[11:01:20.103]                 }
[11:01:20.103]                 {
[11:01:20.103]                   {
[11:01:20.103]                     NULL
[11:01:20.103]                     RNGkind("Mersenne-Twister")
[11:01:20.103]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:20.103]                       inherits = FALSE)
[11:01:20.103]                   }
[11:01:20.103]                   options(future.plan = NULL)
[11:01:20.103]                   if (is.na(NA_character_)) 
[11:01:20.103]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.103]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.103]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.103]                     .init = FALSE)
[11:01:20.103]                 }
[11:01:20.103]             }
[11:01:20.103]         }
[11:01:20.103]     })
[11:01:20.103]     if (TRUE) {
[11:01:20.103]         base::sink(type = "output", split = FALSE)
[11:01:20.103]         if (TRUE) {
[11:01:20.103]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.103]         }
[11:01:20.103]         else {
[11:01:20.103]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.103]         }
[11:01:20.103]         base::close(...future.stdout)
[11:01:20.103]         ...future.stdout <- NULL
[11:01:20.103]     }
[11:01:20.103]     ...future.result$conditions <- ...future.conditions
[11:01:20.103]     ...future.result$finished <- base::Sys.time()
[11:01:20.103]     ...future.result
[11:01:20.103] }
[11:01:20.105] plan(): Setting new future strategy stack:
[11:01:20.105] List of future strategies:
[11:01:20.105] 1. sequential:
[11:01:20.105]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.105]    - tweaked: FALSE
[11:01:20.105]    - call: NULL
[11:01:20.106] plan(): nbrOfWorkers() = 1
[11:01:20.137] plan(): Setting new future strategy stack:
[11:01:20.138] List of future strategies:
[11:01:20.138] 1. sequential:
[11:01:20.138]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.138]    - tweaked: FALSE
[11:01:20.138]    - call: plan(strategy)
[11:01:20.138] plan(): nbrOfWorkers() = 1
[11:01:20.138] SequentialFuture started (and completed)
[11:01:20.138] signalConditions() ...
[11:01:20.138]  - include = ‘immediateCondition’
[11:01:20.138]  - exclude = 
[11:01:20.138]  - resignal = FALSE
[11:01:20.139]  - Number of conditions: 88
[11:01:20.139] signalConditions() ... done
[11:01:20.139] - Launch lazy future ... done
[11:01:20.139] run() for ‘SequentialFuture’ ... done
[11:01:20.139] signalConditions() ...
[11:01:20.139]  - include = ‘immediateCondition’
[11:01:20.139]  - exclude = 
[11:01:20.139]  - resignal = FALSE
[11:01:20.139]  - Number of conditions: 88
[11:01:20.139] signalConditions() ... done
[11:01:20.140] Future state: ‘finished’
[11:01:20.140] signalConditions() ...
[11:01:20.140]  - include = ‘condition’
[11:01:20.140]  - exclude = ‘immediateCondition’
[11:01:20.140]  - resignal = TRUE
[11:01:20.140]  - Number of conditions: 88
[11:01:20.140]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.106] getGlobalsAndPackages() ...
[11:01:20.140]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.106] Searching for globals...
[11:01:20.140]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.120] 
[11:01:20.140]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.120] Searching for globals ... DONE
[11:01:20.140]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.120] - globals: [0] <none>
[11:01:20.141]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.120] getGlobalsAndPackages() ... DONE
[11:01:20.141]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.121] run() for ‘Future’ ...
[11:01:20.141]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.121] - state: ‘created’
[11:01:20.141]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.121] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:20.141]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.121] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:20.141]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.121] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:20.141]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.121]   - Field: ‘label’
[11:01:20.141]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.121]   - Field: ‘local’
[11:01:20.141]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.122]   - Field: ‘owner’
[11:01:20.142]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.122]   - Field: ‘envir’
[11:01:20.142]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.122]   - Field: ‘packages’
[11:01:20.142]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.122]   - Field: ‘gc’
[11:01:20.142]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.122]   - Field: ‘conditions’
[11:01:20.142]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.122]   - Field: ‘expr’
[11:01:20.142]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.122]   - Field: ‘uuid’
[11:01:20.142]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.122]   - Field: ‘seed’
[11:01:20.142]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.122]   - Field: ‘version’
[11:01:20.142]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.122]   - Field: ‘result’
[11:01:20.143]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.123]   - Field: ‘asynchronous’
[11:01:20.143]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.123]   - Field: ‘calls’
[11:01:20.143]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.123]   - Field: ‘globals’
[11:01:20.143]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.123]   - Field: ‘stdout’
[11:01:20.143]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.123]   - Field: ‘earlySignal’
[11:01:20.143]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.123]   - Field: ‘lazy’
[11:01:20.143]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.123]   - Field: ‘state’
[11:01:20.143]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.123] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:20.143]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.123] - Launch lazy future ...
[11:01:20.144]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.124] Packages needed by the future expression (n = 0): <none>
[11:01:20.144]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.124] Packages needed by future strategies (n = 0): <none>
[11:01:20.144]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.124] {
[11:01:20.124]     {
[11:01:20.124]         {
[11:01:20.124]             ...future.startTime <- base::Sys.time()
[11:01:20.124]             {
[11:01:20.124]                 {
[11:01:20.124]                   {
[11:01:20.124]                     base::local({
[11:01:20.124]                       has_future <- base::requireNamespace("future", 
[11:01:20.124]                         quietly = TRUE)
[11:01:20.124]                       if (has_future) {
[11:01:20.124]                         ns <- base::getNamespace("future")
[11:01:20.124]                         version <- ns[[".package"]][["version"]]
[11:01:20.124]                         if (is.null(version)) 
[11:01:20.124]                           version <- utils::packageVersion("future")
[11:01:20.124]                       }
[11:01:20.124]                       else {
[11:01:20.124]                         version <- NULL
[11:01:20.124]                       }
[11:01:20.124]                       if (!has_future || version < "1.8.0") {
[11:01:20.124]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.124]                           "", base::R.version$version.string), 
[11:01:20.124]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:20.124]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.124]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.124]                             "release", "version")], collapse = " "), 
[11:01:20.124]                           hostname = base::Sys.info()[["nodename"]])
[11:01:20.124]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.124]                           info)
[11:01:20.124]                         info <- base::paste(info, collapse = "; ")
[11:01:20.124]                         if (!has_future) {
[11:01:20.124]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.124]                             info)
[11:01:20.124]                         }
[11:01:20.124]                         else {
[11:01:20.124]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.124]                             info, version)
[11:01:20.124]                         }
[11:01:20.124]                         base::stop(msg)
[11:01:20.124]                       }
[11:01:20.124]                     })
[11:01:20.124]                   }
[11:01:20.124]                   ...future.strategy.old <- future::plan("list")
[11:01:20.124]                   options(future.plan = NULL)
[11:01:20.124]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.124]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.124]                 }
[11:01:20.124]                 ...future.workdir <- getwd()
[11:01:20.124]             }
[11:01:20.124]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.124]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.124]         }
[11:01:20.124]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.124]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.124]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.124]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.124]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.124]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.124]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.124]             base::names(...future.oldOptions))
[11:01:20.124]     }
[11:01:20.124]     if (FALSE) {
[11:01:20.124]     }
[11:01:20.124]     else {
[11:01:20.124]         if (TRUE) {
[11:01:20.124]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.124]                 open = "w")
[11:01:20.124]         }
[11:01:20.124]         else {
[11:01:20.124]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.124]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.124]         }
[11:01:20.124]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.124]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.124]             base::sink(type = "output", split = FALSE)
[11:01:20.124]             base::close(...future.stdout)
[11:01:20.124]         }, add = TRUE)
[11:01:20.124]     }
[11:01:20.124]     ...future.frame <- base::sys.nframe()
[11:01:20.124]     ...future.conditions <- base::list()
[11:01:20.124]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.124]     if (FALSE) {
[11:01:20.124]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.124]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.124]     }
[11:01:20.124]     ...future.result <- base::tryCatch({
[11:01:20.124]         base::withCallingHandlers({
[11:01:20.124]             ...future.value <- base::withVisible(base::local(2))
[11:01:20.124]             future::FutureResult(value = ...future.value$value, 
[11:01:20.124]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.124]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.124]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.124]                     ...future.globalenv.names))
[11:01:20.124]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.124]         }, condition = base::local({
[11:01:20.124]             c <- base::c
[11:01:20.124]             inherits <- base::inherits
[11:01:20.124]             invokeRestart <- base::invokeRestart
[11:01:20.124]             length <- base::length
[11:01:20.124]             list <- base::list
[11:01:20.124]             seq.int <- base::seq.int
[11:01:20.124]             signalCondition <- base::signalCondition
[11:01:20.124]             sys.calls <- base::sys.calls
[11:01:20.124]             `[[` <- base::`[[`
[11:01:20.124]             `+` <- base::`+`
[11:01:20.124]             `<<-` <- base::`<<-`
[11:01:20.124]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.124]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.124]                   3L)]
[11:01:20.124]             }
[11:01:20.124]             function(cond) {
[11:01:20.124]                 is_error <- inherits(cond, "error")
[11:01:20.124]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.124]                   NULL)
[11:01:20.124]                 if (is_error) {
[11:01:20.124]                   sessionInformation <- function() {
[11:01:20.124]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.124]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.124]                       search = base::search(), system = base::Sys.info())
[11:01:20.124]                   }
[11:01:20.124]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.124]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.124]                     cond$call), session = sessionInformation(), 
[11:01:20.124]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.124]                   signalCondition(cond)
[11:01:20.124]                 }
[11:01:20.124]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.124]                 "immediateCondition"))) {
[11:01:20.124]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.124]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.124]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.124]                   if (TRUE && !signal) {
[11:01:20.124]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.124]                     {
[11:01:20.124]                       inherits <- base::inherits
[11:01:20.124]                       invokeRestart <- base::invokeRestart
[11:01:20.124]                       is.null <- base::is.null
[11:01:20.124]                       muffled <- FALSE
[11:01:20.124]                       if (inherits(cond, "message")) {
[11:01:20.124]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.124]                         if (muffled) 
[11:01:20.124]                           invokeRestart("muffleMessage")
[11:01:20.124]                       }
[11:01:20.124]                       else if (inherits(cond, "warning")) {
[11:01:20.124]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.124]                         if (muffled) 
[11:01:20.124]                           invokeRestart("muffleWarning")
[11:01:20.124]                       }
[11:01:20.124]                       else if (inherits(cond, "condition")) {
[11:01:20.124]                         if (!is.null(pattern)) {
[11:01:20.124]                           computeRestarts <- base::computeRestarts
[11:01:20.124]                           grepl <- base::grepl
[11:01:20.124]                           restarts <- computeRestarts(cond)
[11:01:20.124]                           for (restart in restarts) {
[11:01:20.124]                             name <- restart$name
[11:01:20.124]                             if (is.null(name)) 
[11:01:20.124]                               next
[11:01:20.124]                             if (!grepl(pattern, name)) 
[11:01:20.124]                               next
[11:01:20.124]                             invokeRestart(restart)
[11:01:20.124]                             muffled <- TRUE
[11:01:20.124]                             break
[11:01:20.124]                           }
[11:01:20.124]                         }
[11:01:20.124]                       }
[11:01:20.124]                       invisible(muffled)
[11:01:20.124]                     }
[11:01:20.124]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.124]                   }
[11:01:20.124]                 }
[11:01:20.124]                 else {
[11:01:20.124]                   if (TRUE) {
[11:01:20.124]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.124]                     {
[11:01:20.124]                       inherits <- base::inherits
[11:01:20.124]                       invokeRestart <- base::invokeRestart
[11:01:20.124]                       is.null <- base::is.null
[11:01:20.124]                       muffled <- FALSE
[11:01:20.124]                       if (inherits(cond, "message")) {
[11:01:20.124]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.124]                         if (muffled) 
[11:01:20.124]                           invokeRestart("muffleMessage")
[11:01:20.124]                       }
[11:01:20.124]                       else if (inherits(cond, "warning")) {
[11:01:20.124]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.124]                         if (muffled) 
[11:01:20.124]                           invokeRestart("muffleWarning")
[11:01:20.124]                       }
[11:01:20.124]                       else if (inherits(cond, "condition")) {
[11:01:20.124]                         if (!is.null(pattern)) {
[11:01:20.124]                           computeRestarts <- base::computeRestarts
[11:01:20.124]                           grepl <- base::grepl
[11:01:20.124]                           restarts <- computeRestarts(cond)
[11:01:20.124]                           for (restart in restarts) {
[11:01:20.124]                             name <- restart$name
[11:01:20.124]                             if (is.null(name)) 
[11:01:20.124]                               next
[11:01:20.124]                             if (!grepl(pattern, name)) 
[11:01:20.124]                               next
[11:01:20.124]                             invokeRestart(restart)
[11:01:20.124]                             muffled <- TRUE
[11:01:20.124]                             break
[11:01:20.124]                           }
[11:01:20.124]                         }
[11:01:20.124]                       }
[11:01:20.124]                       invisible(muffled)
[11:01:20.124]                     }
[11:01:20.124]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.124]                   }
[11:01:20.124]                 }
[11:01:20.124]             }
[11:01:20.124]         }))
[11:01:20.124]     }, error = function(ex) {
[11:01:20.124]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.124]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.124]                 ...future.rng), started = ...future.startTime, 
[11:01:20.124]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.124]             version = "1.8"), class = "FutureResult")
[11:01:20.124]     }, finally = {
[11:01:20.124]         if (!identical(...future.workdir, getwd())) 
[11:01:20.124]             setwd(...future.workdir)
[11:01:20.124]         {
[11:01:20.124]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.124]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.124]             }
[11:01:20.124]             base::options(...future.oldOptions)
[11:01:20.124]             if (.Platform$OS.type == "windows") {
[11:01:20.124]                 old_names <- names(...future.oldEnvVars)
[11:01:20.124]                 envs <- base::Sys.getenv()
[11:01:20.124]                 names <- names(envs)
[11:01:20.124]                 common <- intersect(names, old_names)
[11:01:20.124]                 added <- setdiff(names, old_names)
[11:01:20.124]                 removed <- setdiff(old_names, names)
[11:01:20.124]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.124]                   envs[common]]
[11:01:20.124]                 NAMES <- toupper(changed)
[11:01:20.124]                 args <- list()
[11:01:20.124]                 for (kk in seq_along(NAMES)) {
[11:01:20.124]                   name <- changed[[kk]]
[11:01:20.124]                   NAME <- NAMES[[kk]]
[11:01:20.124]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.124]                     next
[11:01:20.124]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.124]                 }
[11:01:20.124]                 NAMES <- toupper(added)
[11:01:20.124]                 for (kk in seq_along(NAMES)) {
[11:01:20.124]                   name <- added[[kk]]
[11:01:20.124]                   NAME <- NAMES[[kk]]
[11:01:20.124]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.124]                     next
[11:01:20.124]                   args[[name]] <- ""
[11:01:20.124]                 }
[11:01:20.124]                 NAMES <- toupper(removed)
[11:01:20.124]                 for (kk in seq_along(NAMES)) {
[11:01:20.124]                   name <- removed[[kk]]
[11:01:20.124]                   NAME <- NAMES[[kk]]
[11:01:20.124]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.124]                     next
[11:01:20.124]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.124]                 }
[11:01:20.124]                 if (length(args) > 0) 
[11:01:20.124]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.124]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.124]             }
[11:01:20.124]             else {
[11:01:20.124]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.124]             }
[11:01:20.124]             {
[11:01:20.124]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.124]                   0L) {
[11:01:20.124]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.124]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.124]                   base::options(opts)
[11:01:20.124]                 }
[11:01:20.124]                 {
[11:01:20.124]                   {
[11:01:20.124]                     NULL
[11:01:20.124]                     RNGkind("Mersenne-Twister")
[11:01:20.124]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:20.124]                       inherits = FALSE)
[11:01:20.124]                   }
[11:01:20.124]                   options(future.plan = NULL)
[11:01:20.124]                   if (is.na(NA_character_)) 
[11:01:20.124]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.124]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.124]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.124]                     .init = FALSE)
[11:01:20.124]                 }
[11:01:20.124]             }
[11:01:20.124]         }
[11:01:20.124]     })
[11:01:20.124]     if (TRUE) {
[11:01:20.124]         base::sink(type = "output", split = FALSE)
[11:01:20.124]         if (TRUE) {
[11:01:20.124]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.124]         }
[11:01:20.124]         else {
[11:01:20.124]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.124]         }
[11:01:20.124]         base::close(...future.stdout)
[11:01:20.124]         ...future.stdout <- NULL
[11:01:20.124]     }
[11:01:20.124]     ...future.result$conditions <- ...future.conditions
[11:01:20.124]     ...future.result$finished <- base::Sys.time()
[11:01:20.124]     ...future.result
[11:01:20.124] }
[11:01:20.144]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.126] plan(): Setting new future strategy stack:
[11:01:20.144]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.126] List of future strategies:
[11:01:20.126] 1. sequential:
[11:01:20.126]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.126]    - tweaked: FALSE
[11:01:20.126]    - call: NULL
[11:01:20.144]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.126] plan(): nbrOfWorkers() = 1
[11:01:20.144]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.127] plan(): Setting new future strategy stack:
[11:01:20.145]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.127] List of future strategies:
[11:01:20.127] 1. sequential:
[11:01:20.127]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.127]    - tweaked: FALSE
[11:01:20.127]    - call: NULL
[11:01:20.145]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.128] plan(): nbrOfWorkers() = 1
[11:01:20.145]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.128] SequentialFuture started (and completed)
[11:01:20.145]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.129] - Launch lazy future ... done
[11:01:20.145]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.129] run() for ‘SequentialFuture’ ... done
[11:01:20.145]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.129] getGlobalsAndPackages() ...
[11:01:20.145]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.129] Searching for globals...
[11:01:20.145]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.129] 
[11:01:20.145]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.130] Searching for globals ... DONE
[11:01:20.146]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.130] - globals: [0] <none>
[11:01:20.146]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.130] getGlobalsAndPackages() ... DONE
[11:01:20.146]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.130] run() for ‘Future’ ...
[11:01:20.146]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.130] - state: ‘created’
[11:01:20.146]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.130] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:20.146]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.130] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:20.146]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.131] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:20.146]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.131]   - Field: ‘label’
[11:01:20.146]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.131]   - Field: ‘local’
[11:01:20.147]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.131]   - Field: ‘owner’
[11:01:20.147]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.131]   - Field: ‘envir’
[11:01:20.147]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.131]   - Field: ‘packages’
[11:01:20.147]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.131]   - Field: ‘gc’
[11:01:20.147]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.131]   - Field: ‘conditions’
[11:01:20.147]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.131]   - Field: ‘expr’
[11:01:20.147]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.131]   - Field: ‘uuid’
[11:01:20.147]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.132]   - Field: ‘seed’
[11:01:20.147]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.132]   - Field: ‘version’
[11:01:20.148]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.132]   - Field: ‘result’
[11:01:20.148]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.132]   - Field: ‘asynchronous’
[11:01:20.148]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.132]   - Field: ‘calls’
[11:01:20.148]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.132]   - Field: ‘globals’
[11:01:20.148]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.132]   - Field: ‘stdout’
[11:01:20.148]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.132]   - Field: ‘earlySignal’
[11:01:20.148]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.132]   - Field: ‘lazy’
[11:01:20.148]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.132]   - Field: ‘state’
[11:01:20.148]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.132] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:20.149]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.133] - Launch lazy future ...
[11:01:20.149]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.133] Packages needed by the future expression (n = 0): <none>
[11:01:20.150]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.133] Packages needed by future strategies (n = 0): <none>
[11:01:20.150]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.133] {
[11:01:20.133]     {
[11:01:20.133]         {
[11:01:20.133]             ...future.startTime <- base::Sys.time()
[11:01:20.133]             {
[11:01:20.133]                 {
[11:01:20.133]                   {
[11:01:20.133]                     base::local({
[11:01:20.133]                       has_future <- base::requireNamespace("future", 
[11:01:20.133]                         quietly = TRUE)
[11:01:20.133]                       if (has_future) {
[11:01:20.133]                         ns <- base::getNamespace("future")
[11:01:20.133]                         version <- ns[[".package"]][["version"]]
[11:01:20.133]                         if (is.null(version)) 
[11:01:20.133]                           version <- utils::packageVersion("future")
[11:01:20.133]                       }
[11:01:20.133]                       else {
[11:01:20.133]                         version <- NULL
[11:01:20.133]                       }
[11:01:20.133]                       if (!has_future || version < "1.8.0") {
[11:01:20.133]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.133]                           "", base::R.version$version.string), 
[11:01:20.133]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:20.133]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.133]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.133]                             "release", "version")], collapse = " "), 
[11:01:20.133]                           hostname = base::Sys.info()[["nodename"]])
[11:01:20.133]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.133]                           info)
[11:01:20.133]                         info <- base::paste(info, collapse = "; ")
[11:01:20.133]                         if (!has_future) {
[11:01:20.133]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.133]                             info)
[11:01:20.133]                         }
[11:01:20.133]                         else {
[11:01:20.133]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.133]                             info, version)
[11:01:20.133]                         }
[11:01:20.133]                         base::stop(msg)
[11:01:20.133]                       }
[11:01:20.133]                     })
[11:01:20.133]                   }
[11:01:20.133]                   ...future.strategy.old <- future::plan("list")
[11:01:20.133]                   options(future.plan = NULL)
[11:01:20.133]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.133]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.133]                 }
[11:01:20.133]                 ...future.workdir <- getwd()
[11:01:20.133]             }
[11:01:20.133]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.133]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.133]         }
[11:01:20.133]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.133]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.133]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.133]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.133]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.133]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.133]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.133]             base::names(...future.oldOptions))
[11:01:20.133]     }
[11:01:20.133]     if (FALSE) {
[11:01:20.133]     }
[11:01:20.133]     else {
[11:01:20.133]         if (TRUE) {
[11:01:20.133]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.133]                 open = "w")
[11:01:20.133]         }
[11:01:20.133]         else {
[11:01:20.133]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.133]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.133]         }
[11:01:20.133]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.133]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.133]             base::sink(type = "output", split = FALSE)
[11:01:20.133]             base::close(...future.stdout)
[11:01:20.133]         }, add = TRUE)
[11:01:20.133]     }
[11:01:20.133]     ...future.frame <- base::sys.nframe()
[11:01:20.133]     ...future.conditions <- base::list()
[11:01:20.133]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.133]     if (FALSE) {
[11:01:20.133]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.133]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.133]     }
[11:01:20.133]     ...future.result <- base::tryCatch({
[11:01:20.133]         base::withCallingHandlers({
[11:01:20.133]             ...future.value <- base::withVisible(base::local(4))
[11:01:20.133]             future::FutureResult(value = ...future.value$value, 
[11:01:20.133]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.133]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.133]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.133]                     ...future.globalenv.names))
[11:01:20.133]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.133]         }, condition = base::local({
[11:01:20.133]             c <- base::c
[11:01:20.133]             inherits <- base::inherits
[11:01:20.133]             invokeRestart <- base::invokeRestart
[11:01:20.133]             length <- base::length
[11:01:20.133]             list <- base::list
[11:01:20.133]             seq.int <- base::seq.int
[11:01:20.133]             signalCondition <- base::signalCondition
[11:01:20.133]             sys.calls <- base::sys.calls
[11:01:20.133]             `[[` <- base::`[[`
[11:01:20.133]             `+` <- base::`+`
[11:01:20.133]             `<<-` <- base::`<<-`
[11:01:20.133]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.133]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.133]                   3L)]
[11:01:20.133]             }
[11:01:20.133]             function(cond) {
[11:01:20.133]                 is_error <- inherits(cond, "error")
[11:01:20.133]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.133]                   NULL)
[11:01:20.133]                 if (is_error) {
[11:01:20.133]                   sessionInformation <- function() {
[11:01:20.133]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.133]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.133]                       search = base::search(), system = base::Sys.info())
[11:01:20.133]                   }
[11:01:20.133]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.133]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.133]                     cond$call), session = sessionInformation(), 
[11:01:20.133]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.133]                   signalCondition(cond)
[11:01:20.133]                 }
[11:01:20.133]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.133]                 "immediateCondition"))) {
[11:01:20.133]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.133]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.133]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.133]                   if (TRUE && !signal) {
[11:01:20.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.133]                     {
[11:01:20.133]                       inherits <- base::inherits
[11:01:20.133]                       invokeRestart <- base::invokeRestart
[11:01:20.133]                       is.null <- base::is.null
[11:01:20.133]                       muffled <- FALSE
[11:01:20.133]                       if (inherits(cond, "message")) {
[11:01:20.133]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.133]                         if (muffled) 
[11:01:20.133]                           invokeRestart("muffleMessage")
[11:01:20.133]                       }
[11:01:20.133]                       else if (inherits(cond, "warning")) {
[11:01:20.133]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.133]                         if (muffled) 
[11:01:20.133]                           invokeRestart("muffleWarning")
[11:01:20.133]                       }
[11:01:20.133]                       else if (inherits(cond, "condition")) {
[11:01:20.133]                         if (!is.null(pattern)) {
[11:01:20.133]                           computeRestarts <- base::computeRestarts
[11:01:20.133]                           grepl <- base::grepl
[11:01:20.133]                           restarts <- computeRestarts(cond)
[11:01:20.133]                           for (restart in restarts) {
[11:01:20.133]                             name <- restart$name
[11:01:20.133]                             if (is.null(name)) 
[11:01:20.133]                               next
[11:01:20.133]                             if (!grepl(pattern, name)) 
[11:01:20.133]                               next
[11:01:20.133]                             invokeRestart(restart)
[11:01:20.133]                             muffled <- TRUE
[11:01:20.133]                             break
[11:01:20.133]                           }
[11:01:20.133]                         }
[11:01:20.133]                       }
[11:01:20.133]                       invisible(muffled)
[11:01:20.133]                     }
[11:01:20.133]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.133]                   }
[11:01:20.133]                 }
[11:01:20.133]                 else {
[11:01:20.133]                   if (TRUE) {
[11:01:20.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.133]                     {
[11:01:20.133]                       inherits <- base::inherits
[11:01:20.133]                       invokeRestart <- base::invokeRestart
[11:01:20.133]                       is.null <- base::is.null
[11:01:20.133]                       muffled <- FALSE
[11:01:20.133]                       if (inherits(cond, "message")) {
[11:01:20.133]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.133]                         if (muffled) 
[11:01:20.133]                           invokeRestart("muffleMessage")
[11:01:20.133]                       }
[11:01:20.133]                       else if (inherits(cond, "warning")) {
[11:01:20.133]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.133]                         if (muffled) 
[11:01:20.133]                           invokeRestart("muffleWarning")
[11:01:20.133]                       }
[11:01:20.133]                       else if (inherits(cond, "condition")) {
[11:01:20.133]                         if (!is.null(pattern)) {
[11:01:20.133]                           computeRestarts <- base::computeRestarts
[11:01:20.133]                           grepl <- base::grepl
[11:01:20.133]                           restarts <- computeRestarts(cond)
[11:01:20.133]                           for (restart in restarts) {
[11:01:20.133]                             name <- restart$name
[11:01:20.133]                             if (is.null(name)) 
[11:01:20.133]                               next
[11:01:20.133]                             if (!grepl(pattern, name)) 
[11:01:20.133]                               next
[11:01:20.133]                             invokeRestart(restart)
[11:01:20.133]                             muffled <- TRUE
[11:01:20.133]                             break
[11:01:20.133]                           }
[11:01:20.133]                         }
[11:01:20.133]                       }
[11:01:20.133]                       invisible(muffled)
[11:01:20.133]                     }
[11:01:20.133]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.133]                   }
[11:01:20.133]                 }
[11:01:20.133]             }
[11:01:20.133]         }))
[11:01:20.133]     }, error = function(ex) {
[11:01:20.133]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.133]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.133]                 ...future.rng), started = ...future.startTime, 
[11:01:20.133]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.133]             version = "1.8"), class = "FutureResult")
[11:01:20.133]     }, finally = {
[11:01:20.133]         if (!identical(...future.workdir, getwd())) 
[11:01:20.133]             setwd(...future.workdir)
[11:01:20.133]         {
[11:01:20.133]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.133]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.133]             }
[11:01:20.133]             base::options(...future.oldOptions)
[11:01:20.133]             if (.Platform$OS.type == "windows") {
[11:01:20.133]                 old_names <- names(...future.oldEnvVars)
[11:01:20.133]                 envs <- base::Sys.getenv()
[11:01:20.133]                 names <- names(envs)
[11:01:20.133]                 common <- intersect(names, old_names)
[11:01:20.133]                 added <- setdiff(names, old_names)
[11:01:20.133]                 removed <- setdiff(old_names, names)
[11:01:20.133]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.133]                   envs[common]]
[11:01:20.133]                 NAMES <- toupper(changed)
[11:01:20.133]                 args <- list()
[11:01:20.133]                 for (kk in seq_along(NAMES)) {
[11:01:20.133]                   name <- changed[[kk]]
[11:01:20.133]                   NAME <- NAMES[[kk]]
[11:01:20.133]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.133]                     next
[11:01:20.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.133]                 }
[11:01:20.133]                 NAMES <- toupper(added)
[11:01:20.133]                 for (kk in seq_along(NAMES)) {
[11:01:20.133]                   name <- added[[kk]]
[11:01:20.133]                   NAME <- NAMES[[kk]]
[11:01:20.133]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.133]                     next
[11:01:20.133]                   args[[name]] <- ""
[11:01:20.133]                 }
[11:01:20.133]                 NAMES <- toupper(removed)
[11:01:20.133]                 for (kk in seq_along(NAMES)) {
[11:01:20.133]                   name <- removed[[kk]]
[11:01:20.133]                   NAME <- NAMES[[kk]]
[11:01:20.133]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.133]                     next
[11:01:20.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.133]                 }
[11:01:20.133]                 if (length(args) > 0) 
[11:01:20.133]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.133]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.133]             }
[11:01:20.133]             else {
[11:01:20.133]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.133]             }
[11:01:20.133]             {
[11:01:20.133]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.133]                   0L) {
[11:01:20.133]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.133]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.133]                   base::options(opts)
[11:01:20.133]                 }
[11:01:20.133]                 {
[11:01:20.133]                   {
[11:01:20.133]                     NULL
[11:01:20.133]                     RNGkind("Mersenne-Twister")
[11:01:20.133]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:20.133]                       inherits = FALSE)
[11:01:20.133]                   }
[11:01:20.133]                   options(future.plan = NULL)
[11:01:20.133]                   if (is.na(NA_character_)) 
[11:01:20.133]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.133]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.133]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.133]                     .init = FALSE)
[11:01:20.133]                 }
[11:01:20.133]             }
[11:01:20.133]         }
[11:01:20.133]     })
[11:01:20.133]     if (TRUE) {
[11:01:20.133]         base::sink(type = "output", split = FALSE)
[11:01:20.133]         if (TRUE) {
[11:01:20.133]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.133]         }
[11:01:20.133]         else {
[11:01:20.133]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.133]         }
[11:01:20.133]         base::close(...future.stdout)
[11:01:20.133]         ...future.stdout <- NULL
[11:01:20.133]     }
[11:01:20.133]     ...future.result$conditions <- ...future.conditions
[11:01:20.133]     ...future.result$finished <- base::Sys.time()
[11:01:20.133]     ...future.result
[11:01:20.133] }
[11:01:20.150]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.135] plan(): Setting new future strategy stack:
[11:01:20.150]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.135] List of future strategies:
[11:01:20.135] 1. sequential:
[11:01:20.135]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.135]    - tweaked: FALSE
[11:01:20.135]    - call: NULL
[11:01:20.150]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.135] plan(): nbrOfWorkers() = 1
[11:01:20.150]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.136] plan(): Setting new future strategy stack:
[11:01:20.150]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.136] List of future strategies:
[11:01:20.136] 1. sequential:
[11:01:20.136]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.136]    - tweaked: FALSE
[11:01:20.136]    - call: NULL
[11:01:20.151]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.137] plan(): nbrOfWorkers() = 1
[11:01:20.151]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.137] SequentialFuture started (and completed)
[11:01:20.151]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.137] - Launch lazy future ... done
[11:01:20.151]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.137] run() for ‘SequentialFuture’ ... done
[11:01:20.151] signalConditions() ... done
a = 10
[11:01:20.151] getGlobalsAndPackages() ...
[11:01:20.151] Searching for globals...
[11:01:20.152] - globals found: [3] ‘{’, ‘+’, ‘a’
[11:01:20.152] Searching for globals ... DONE
[11:01:20.152] Resolving globals: FALSE
[11:01:20.153] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:20.153] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:20.153] - globals: [1] ‘a’
[11:01:20.153] 
[11:01:20.153] getGlobalsAndPackages() ... DONE
[11:01:20.153] run() for ‘Future’ ...
[11:01:20.154] - state: ‘created’
[11:01:20.154] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:20.154] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:20.154] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:20.154]   - Field: ‘label’
[11:01:20.154]   - Field: ‘local’
[11:01:20.154]   - Field: ‘owner’
[11:01:20.154]   - Field: ‘envir’
[11:01:20.154]   - Field: ‘packages’
[11:01:20.154]   - Field: ‘gc’
[11:01:20.155]   - Field: ‘conditions’
[11:01:20.155]   - Field: ‘expr’
[11:01:20.155]   - Field: ‘uuid’
[11:01:20.155]   - Field: ‘seed’
[11:01:20.155]   - Field: ‘version’
[11:01:20.155]   - Field: ‘result’
[11:01:20.155]   - Field: ‘asynchronous’
[11:01:20.155]   - Field: ‘calls’
[11:01:20.155]   - Field: ‘globals’
[11:01:20.155]   - Field: ‘stdout’
[11:01:20.155]   - Field: ‘earlySignal’
[11:01:20.155]   - Field: ‘lazy’
[11:01:20.156]   - Field: ‘state’
[11:01:20.156] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:20.156] - Launch lazy future ...
[11:01:20.156] Packages needed by the future expression (n = 0): <none>
[11:01:20.156] Packages needed by future strategies (n = 0): <none>
[11:01:20.156] {
[11:01:20.156]     {
[11:01:20.156]         {
[11:01:20.156]             ...future.startTime <- base::Sys.time()
[11:01:20.156]             {
[11:01:20.156]                 {
[11:01:20.156]                   {
[11:01:20.156]                     base::local({
[11:01:20.156]                       has_future <- base::requireNamespace("future", 
[11:01:20.156]                         quietly = TRUE)
[11:01:20.156]                       if (has_future) {
[11:01:20.156]                         ns <- base::getNamespace("future")
[11:01:20.156]                         version <- ns[[".package"]][["version"]]
[11:01:20.156]                         if (is.null(version)) 
[11:01:20.156]                           version <- utils::packageVersion("future")
[11:01:20.156]                       }
[11:01:20.156]                       else {
[11:01:20.156]                         version <- NULL
[11:01:20.156]                       }
[11:01:20.156]                       if (!has_future || version < "1.8.0") {
[11:01:20.156]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.156]                           "", base::R.version$version.string), 
[11:01:20.156]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:20.156]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.156]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.156]                             "release", "version")], collapse = " "), 
[11:01:20.156]                           hostname = base::Sys.info()[["nodename"]])
[11:01:20.156]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.156]                           info)
[11:01:20.156]                         info <- base::paste(info, collapse = "; ")
[11:01:20.156]                         if (!has_future) {
[11:01:20.156]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.156]                             info)
[11:01:20.156]                         }
[11:01:20.156]                         else {
[11:01:20.156]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.156]                             info, version)
[11:01:20.156]                         }
[11:01:20.156]                         base::stop(msg)
[11:01:20.156]                       }
[11:01:20.156]                     })
[11:01:20.156]                   }
[11:01:20.156]                   ...future.strategy.old <- future::plan("list")
[11:01:20.156]                   options(future.plan = NULL)
[11:01:20.156]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.156]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.156]                 }
[11:01:20.156]                 ...future.workdir <- getwd()
[11:01:20.156]             }
[11:01:20.156]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.156]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.156]         }
[11:01:20.156]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.156]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.156]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.156]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.156]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.156]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.156]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.156]             base::names(...future.oldOptions))
[11:01:20.156]     }
[11:01:20.156]     if (FALSE) {
[11:01:20.156]     }
[11:01:20.156]     else {
[11:01:20.156]         if (TRUE) {
[11:01:20.156]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.156]                 open = "w")
[11:01:20.156]         }
[11:01:20.156]         else {
[11:01:20.156]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.156]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.156]         }
[11:01:20.156]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.156]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.156]             base::sink(type = "output", split = FALSE)
[11:01:20.156]             base::close(...future.stdout)
[11:01:20.156]         }, add = TRUE)
[11:01:20.156]     }
[11:01:20.156]     ...future.frame <- base::sys.nframe()
[11:01:20.156]     ...future.conditions <- base::list()
[11:01:20.156]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.156]     if (FALSE) {
[11:01:20.156]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.156]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.156]     }
[11:01:20.156]     ...future.result <- base::tryCatch({
[11:01:20.156]         base::withCallingHandlers({
[11:01:20.156]             ...future.value <- base::withVisible(base::local({
[11:01:20.156]                 a + 1
[11:01:20.156]             }))
[11:01:20.156]             future::FutureResult(value = ...future.value$value, 
[11:01:20.156]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.156]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.156]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.156]                     ...future.globalenv.names))
[11:01:20.156]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.156]         }, condition = base::local({
[11:01:20.156]             c <- base::c
[11:01:20.156]             inherits <- base::inherits
[11:01:20.156]             invokeRestart <- base::invokeRestart
[11:01:20.156]             length <- base::length
[11:01:20.156]             list <- base::list
[11:01:20.156]             seq.int <- base::seq.int
[11:01:20.156]             signalCondition <- base::signalCondition
[11:01:20.156]             sys.calls <- base::sys.calls
[11:01:20.156]             `[[` <- base::`[[`
[11:01:20.156]             `+` <- base::`+`
[11:01:20.156]             `<<-` <- base::`<<-`
[11:01:20.156]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.156]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.156]                   3L)]
[11:01:20.156]             }
[11:01:20.156]             function(cond) {
[11:01:20.156]                 is_error <- inherits(cond, "error")
[11:01:20.156]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.156]                   NULL)
[11:01:20.156]                 if (is_error) {
[11:01:20.156]                   sessionInformation <- function() {
[11:01:20.156]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.156]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.156]                       search = base::search(), system = base::Sys.info())
[11:01:20.156]                   }
[11:01:20.156]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.156]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.156]                     cond$call), session = sessionInformation(), 
[11:01:20.156]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.156]                   signalCondition(cond)
[11:01:20.156]                 }
[11:01:20.156]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.156]                 "immediateCondition"))) {
[11:01:20.156]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.156]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.156]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.156]                   if (TRUE && !signal) {
[11:01:20.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.156]                     {
[11:01:20.156]                       inherits <- base::inherits
[11:01:20.156]                       invokeRestart <- base::invokeRestart
[11:01:20.156]                       is.null <- base::is.null
[11:01:20.156]                       muffled <- FALSE
[11:01:20.156]                       if (inherits(cond, "message")) {
[11:01:20.156]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.156]                         if (muffled) 
[11:01:20.156]                           invokeRestart("muffleMessage")
[11:01:20.156]                       }
[11:01:20.156]                       else if (inherits(cond, "warning")) {
[11:01:20.156]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.156]                         if (muffled) 
[11:01:20.156]                           invokeRestart("muffleWarning")
[11:01:20.156]                       }
[11:01:20.156]                       else if (inherits(cond, "condition")) {
[11:01:20.156]                         if (!is.null(pattern)) {
[11:01:20.156]                           computeRestarts <- base::computeRestarts
[11:01:20.156]                           grepl <- base::grepl
[11:01:20.156]                           restarts <- computeRestarts(cond)
[11:01:20.156]                           for (restart in restarts) {
[11:01:20.156]                             name <- restart$name
[11:01:20.156]                             if (is.null(name)) 
[11:01:20.156]                               next
[11:01:20.156]                             if (!grepl(pattern, name)) 
[11:01:20.156]                               next
[11:01:20.156]                             invokeRestart(restart)
[11:01:20.156]                             muffled <- TRUE
[11:01:20.156]                             break
[11:01:20.156]                           }
[11:01:20.156]                         }
[11:01:20.156]                       }
[11:01:20.156]                       invisible(muffled)
[11:01:20.156]                     }
[11:01:20.156]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.156]                   }
[11:01:20.156]                 }
[11:01:20.156]                 else {
[11:01:20.156]                   if (TRUE) {
[11:01:20.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.156]                     {
[11:01:20.156]                       inherits <- base::inherits
[11:01:20.156]                       invokeRestart <- base::invokeRestart
[11:01:20.156]                       is.null <- base::is.null
[11:01:20.156]                       muffled <- FALSE
[11:01:20.156]                       if (inherits(cond, "message")) {
[11:01:20.156]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.156]                         if (muffled) 
[11:01:20.156]                           invokeRestart("muffleMessage")
[11:01:20.156]                       }
[11:01:20.156]                       else if (inherits(cond, "warning")) {
[11:01:20.156]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.156]                         if (muffled) 
[11:01:20.156]                           invokeRestart("muffleWarning")
[11:01:20.156]                       }
[11:01:20.156]                       else if (inherits(cond, "condition")) {
[11:01:20.156]                         if (!is.null(pattern)) {
[11:01:20.156]                           computeRestarts <- base::computeRestarts
[11:01:20.156]                           grepl <- base::grepl
[11:01:20.156]                           restarts <- computeRestarts(cond)
[11:01:20.156]                           for (restart in restarts) {
[11:01:20.156]                             name <- restart$name
[11:01:20.156]                             if (is.null(name)) 
[11:01:20.156]                               next
[11:01:20.156]                             if (!grepl(pattern, name)) 
[11:01:20.156]                               next
[11:01:20.156]                             invokeRestart(restart)
[11:01:20.156]                             muffled <- TRUE
[11:01:20.156]                             break
[11:01:20.156]                           }
[11:01:20.156]                         }
[11:01:20.156]                       }
[11:01:20.156]                       invisible(muffled)
[11:01:20.156]                     }
[11:01:20.156]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.156]                   }
[11:01:20.156]                 }
[11:01:20.156]             }
[11:01:20.156]         }))
[11:01:20.156]     }, error = function(ex) {
[11:01:20.156]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.156]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.156]                 ...future.rng), started = ...future.startTime, 
[11:01:20.156]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.156]             version = "1.8"), class = "FutureResult")
[11:01:20.156]     }, finally = {
[11:01:20.156]         if (!identical(...future.workdir, getwd())) 
[11:01:20.156]             setwd(...future.workdir)
[11:01:20.156]         {
[11:01:20.156]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.156]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.156]             }
[11:01:20.156]             base::options(...future.oldOptions)
[11:01:20.156]             if (.Platform$OS.type == "windows") {
[11:01:20.156]                 old_names <- names(...future.oldEnvVars)
[11:01:20.156]                 envs <- base::Sys.getenv()
[11:01:20.156]                 names <- names(envs)
[11:01:20.156]                 common <- intersect(names, old_names)
[11:01:20.156]                 added <- setdiff(names, old_names)
[11:01:20.156]                 removed <- setdiff(old_names, names)
[11:01:20.156]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.156]                   envs[common]]
[11:01:20.156]                 NAMES <- toupper(changed)
[11:01:20.156]                 args <- list()
[11:01:20.156]                 for (kk in seq_along(NAMES)) {
[11:01:20.156]                   name <- changed[[kk]]
[11:01:20.156]                   NAME <- NAMES[[kk]]
[11:01:20.156]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.156]                     next
[11:01:20.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.156]                 }
[11:01:20.156]                 NAMES <- toupper(added)
[11:01:20.156]                 for (kk in seq_along(NAMES)) {
[11:01:20.156]                   name <- added[[kk]]
[11:01:20.156]                   NAME <- NAMES[[kk]]
[11:01:20.156]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.156]                     next
[11:01:20.156]                   args[[name]] <- ""
[11:01:20.156]                 }
[11:01:20.156]                 NAMES <- toupper(removed)
[11:01:20.156]                 for (kk in seq_along(NAMES)) {
[11:01:20.156]                   name <- removed[[kk]]
[11:01:20.156]                   NAME <- NAMES[[kk]]
[11:01:20.156]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.156]                     next
[11:01:20.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.156]                 }
[11:01:20.156]                 if (length(args) > 0) 
[11:01:20.156]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.156]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.156]             }
[11:01:20.156]             else {
[11:01:20.156]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.156]             }
[11:01:20.156]             {
[11:01:20.156]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.156]                   0L) {
[11:01:20.156]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.156]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.156]                   base::options(opts)
[11:01:20.156]                 }
[11:01:20.156]                 {
[11:01:20.156]                   {
[11:01:20.156]                     NULL
[11:01:20.156]                     RNGkind("Mersenne-Twister")
[11:01:20.156]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:20.156]                       inherits = FALSE)
[11:01:20.156]                   }
[11:01:20.156]                   options(future.plan = NULL)
[11:01:20.156]                   if (is.na(NA_character_)) 
[11:01:20.156]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.156]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.156]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.156]                     .init = FALSE)
[11:01:20.156]                 }
[11:01:20.156]             }
[11:01:20.156]         }
[11:01:20.156]     })
[11:01:20.156]     if (TRUE) {
[11:01:20.156]         base::sink(type = "output", split = FALSE)
[11:01:20.156]         if (TRUE) {
[11:01:20.156]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.156]         }
[11:01:20.156]         else {
[11:01:20.156]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.156]         }
[11:01:20.156]         base::close(...future.stdout)
[11:01:20.156]         ...future.stdout <- NULL
[11:01:20.156]     }
[11:01:20.156]     ...future.result$conditions <- ...future.conditions
[11:01:20.156]     ...future.result$finished <- base::Sys.time()
[11:01:20.156]     ...future.result
[11:01:20.156] }
[11:01:20.158] assign_globals() ...
[11:01:20.158] List of 1
[11:01:20.158]  $ a: num 10
[11:01:20.158]  - attr(*, "where")=List of 1
[11:01:20.158]   ..$ a:<environment: R_EmptyEnv> 
[11:01:20.158]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:20.158]  - attr(*, "resolved")= logi FALSE
[11:01:20.158]  - attr(*, "total_size")= num 39
[11:01:20.158]  - attr(*, "already-done")= logi TRUE
[11:01:20.160] - copied ‘a’ to environment
[11:01:20.160] assign_globals() ... done
[11:01:20.161] plan(): Setting new future strategy stack:
[11:01:20.161] List of future strategies:
[11:01:20.161] 1. sequential:
[11:01:20.161]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.161]    - tweaked: FALSE
[11:01:20.161]    - call: NULL
[11:01:20.161] plan(): nbrOfWorkers() = 1
[11:01:20.162] plan(): Setting new future strategy stack:
[11:01:20.162] List of future strategies:
[11:01:20.162] 1. sequential:
[11:01:20.162]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.162]    - tweaked: FALSE
[11:01:20.162]    - call: plan(strategy)
[11:01:20.162] plan(): nbrOfWorkers() = 1
[11:01:20.162] SequentialFuture started (and completed)
[11:01:20.162] - Launch lazy future ... done
[11:01:20.163] run() for ‘SequentialFuture’ ... done
b = 11
*** %<-% with ‘sequential’ futures ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** %<-% with ‘multicore’ futures ...
[11:01:20.167] plan(): Setting new future strategy stack:
[11:01:20.167] List of future strategies:
[11:01:20.167] 1. multicore:
[11:01:20.167]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:20.167]    - tweaked: FALSE
[11:01:20.167]    - call: plan(strategy)
[11:01:20.169] plan(): nbrOfWorkers() = 2
** Future evaluation without globals
[11:01:20.169] getGlobalsAndPackages() ...
[11:01:20.170] Searching for globals...
[11:01:20.170] - globals found: [2] ‘{’, ‘<-’
[11:01:20.170] Searching for globals ... DONE
[11:01:20.170] Resolving globals: FALSE
[11:01:20.171] 
[11:01:20.171] 
[11:01:20.171] getGlobalsAndPackages() ... DONE
[11:01:20.171] run() for ‘Future’ ...
[11:01:20.171] - state: ‘created’
[11:01:20.172] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:20.174] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:20.174] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:20.174]   - Field: ‘label’
[11:01:20.174]   - Field: ‘local’
[11:01:20.174]   - Field: ‘owner’
[11:01:20.174]   - Field: ‘envir’
[11:01:20.174]   - Field: ‘workers’
[11:01:20.174]   - Field: ‘packages’
[11:01:20.174]   - Field: ‘gc’
[11:01:20.175]   - Field: ‘job’
[11:01:20.175]   - Field: ‘conditions’
[11:01:20.175]   - Field: ‘expr’
[11:01:20.175]   - Field: ‘uuid’
[11:01:20.175]   - Field: ‘seed’
[11:01:20.175]   - Field: ‘version’
[11:01:20.175]   - Field: ‘result’
[11:01:20.175]   - Field: ‘asynchronous’
[11:01:20.175]   - Field: ‘calls’
[11:01:20.175]   - Field: ‘globals’
[11:01:20.175]   - Field: ‘stdout’
[11:01:20.175]   - Field: ‘earlySignal’
[11:01:20.176]   - Field: ‘lazy’
[11:01:20.176]   - Field: ‘state’
[11:01:20.176] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:20.176] - Launch lazy future ...
[11:01:20.177] Packages needed by the future expression (n = 0): <none>
[11:01:20.177] Packages needed by future strategies (n = 0): <none>
[11:01:20.177] {
[11:01:20.177]     {
[11:01:20.177]         {
[11:01:20.177]             ...future.startTime <- base::Sys.time()
[11:01:20.177]             {
[11:01:20.177]                 {
[11:01:20.177]                   {
[11:01:20.177]                     {
[11:01:20.177]                       base::local({
[11:01:20.177]                         has_future <- base::requireNamespace("future", 
[11:01:20.177]                           quietly = TRUE)
[11:01:20.177]                         if (has_future) {
[11:01:20.177]                           ns <- base::getNamespace("future")
[11:01:20.177]                           version <- ns[[".package"]][["version"]]
[11:01:20.177]                           if (is.null(version)) 
[11:01:20.177]                             version <- utils::packageVersion("future")
[11:01:20.177]                         }
[11:01:20.177]                         else {
[11:01:20.177]                           version <- NULL
[11:01:20.177]                         }
[11:01:20.177]                         if (!has_future || version < "1.8.0") {
[11:01:20.177]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.177]                             "", base::R.version$version.string), 
[11:01:20.177]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:20.177]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.177]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.177]                               "release", "version")], collapse = " "), 
[11:01:20.177]                             hostname = base::Sys.info()[["nodename"]])
[11:01:20.177]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.177]                             info)
[11:01:20.177]                           info <- base::paste(info, collapse = "; ")
[11:01:20.177]                           if (!has_future) {
[11:01:20.177]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.177]                               info)
[11:01:20.177]                           }
[11:01:20.177]                           else {
[11:01:20.177]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.177]                               info, version)
[11:01:20.177]                           }
[11:01:20.177]                           base::stop(msg)
[11:01:20.177]                         }
[11:01:20.177]                       })
[11:01:20.177]                     }
[11:01:20.177]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:20.177]                     base::options(mc.cores = 1L)
[11:01:20.177]                   }
[11:01:20.177]                   ...future.strategy.old <- future::plan("list")
[11:01:20.177]                   options(future.plan = NULL)
[11:01:20.177]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.177]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.177]                 }
[11:01:20.177]                 ...future.workdir <- getwd()
[11:01:20.177]             }
[11:01:20.177]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.177]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.177]         }
[11:01:20.177]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.177]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.177]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.177]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.177]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.177]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.177]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.177]             base::names(...future.oldOptions))
[11:01:20.177]     }
[11:01:20.177]     if (FALSE) {
[11:01:20.177]     }
[11:01:20.177]     else {
[11:01:20.177]         if (TRUE) {
[11:01:20.177]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.177]                 open = "w")
[11:01:20.177]         }
[11:01:20.177]         else {
[11:01:20.177]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.177]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.177]         }
[11:01:20.177]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.177]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.177]             base::sink(type = "output", split = FALSE)
[11:01:20.177]             base::close(...future.stdout)
[11:01:20.177]         }, add = TRUE)
[11:01:20.177]     }
[11:01:20.177]     ...future.frame <- base::sys.nframe()
[11:01:20.177]     ...future.conditions <- base::list()
[11:01:20.177]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.177]     if (FALSE) {
[11:01:20.177]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.177]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.177]     }
[11:01:20.177]     ...future.result <- base::tryCatch({
[11:01:20.177]         base::withCallingHandlers({
[11:01:20.177]             ...future.value <- base::withVisible(base::local({
[11:01:20.177]                 withCallingHandlers({
[11:01:20.177]                   {
[11:01:20.177]                     x <- 1
[11:01:20.177]                   }
[11:01:20.177]                 }, immediateCondition = function(cond) {
[11:01:20.177]                   save_rds <- function (object, pathname, ...) 
[11:01:20.177]                   {
[11:01:20.177]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:20.177]                     if (file_test("-f", pathname_tmp)) {
[11:01:20.177]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.177]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:20.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.177]                         fi_tmp[["mtime"]])
[11:01:20.177]                     }
[11:01:20.177]                     tryCatch({
[11:01:20.177]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:20.177]                     }, error = function(ex) {
[11:01:20.177]                       msg <- conditionMessage(ex)
[11:01:20.177]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.177]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:20.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.177]                         fi_tmp[["mtime"]], msg)
[11:01:20.177]                       ex$message <- msg
[11:01:20.177]                       stop(ex)
[11:01:20.177]                     })
[11:01:20.177]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:20.177]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:20.177]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:20.177]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.177]                       fi <- file.info(pathname)
[11:01:20.177]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:20.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.177]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:20.177]                         fi[["size"]], fi[["mtime"]])
[11:01:20.177]                       stop(msg)
[11:01:20.177]                     }
[11:01:20.177]                     invisible(pathname)
[11:01:20.177]                   }
[11:01:20.177]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:20.177]                     rootPath = tempdir()) 
[11:01:20.177]                   {
[11:01:20.177]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:20.177]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:20.177]                       tmpdir = path, fileext = ".rds")
[11:01:20.177]                     save_rds(obj, file)
[11:01:20.177]                   }
[11:01:20.177]                   saveImmediateCondition(cond, path = "/tmp/RtmpxWUrEc/.future/immediateConditions")
[11:01:20.177]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.177]                   {
[11:01:20.177]                     inherits <- base::inherits
[11:01:20.177]                     invokeRestart <- base::invokeRestart
[11:01:20.177]                     is.null <- base::is.null
[11:01:20.177]                     muffled <- FALSE
[11:01:20.177]                     if (inherits(cond, "message")) {
[11:01:20.177]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:20.177]                       if (muffled) 
[11:01:20.177]                         invokeRestart("muffleMessage")
[11:01:20.177]                     }
[11:01:20.177]                     else if (inherits(cond, "warning")) {
[11:01:20.177]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:20.177]                       if (muffled) 
[11:01:20.177]                         invokeRestart("muffleWarning")
[11:01:20.177]                     }
[11:01:20.177]                     else if (inherits(cond, "condition")) {
[11:01:20.177]                       if (!is.null(pattern)) {
[11:01:20.177]                         computeRestarts <- base::computeRestarts
[11:01:20.177]                         grepl <- base::grepl
[11:01:20.177]                         restarts <- computeRestarts(cond)
[11:01:20.177]                         for (restart in restarts) {
[11:01:20.177]                           name <- restart$name
[11:01:20.177]                           if (is.null(name)) 
[11:01:20.177]                             next
[11:01:20.177]                           if (!grepl(pattern, name)) 
[11:01:20.177]                             next
[11:01:20.177]                           invokeRestart(restart)
[11:01:20.177]                           muffled <- TRUE
[11:01:20.177]                           break
[11:01:20.177]                         }
[11:01:20.177]                       }
[11:01:20.177]                     }
[11:01:20.177]                     invisible(muffled)
[11:01:20.177]                   }
[11:01:20.177]                   muffleCondition(cond)
[11:01:20.177]                 })
[11:01:20.177]             }))
[11:01:20.177]             future::FutureResult(value = ...future.value$value, 
[11:01:20.177]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.177]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.177]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.177]                     ...future.globalenv.names))
[11:01:20.177]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.177]         }, condition = base::local({
[11:01:20.177]             c <- base::c
[11:01:20.177]             inherits <- base::inherits
[11:01:20.177]             invokeRestart <- base::invokeRestart
[11:01:20.177]             length <- base::length
[11:01:20.177]             list <- base::list
[11:01:20.177]             seq.int <- base::seq.int
[11:01:20.177]             signalCondition <- base::signalCondition
[11:01:20.177]             sys.calls <- base::sys.calls
[11:01:20.177]             `[[` <- base::`[[`
[11:01:20.177]             `+` <- base::`+`
[11:01:20.177]             `<<-` <- base::`<<-`
[11:01:20.177]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.177]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.177]                   3L)]
[11:01:20.177]             }
[11:01:20.177]             function(cond) {
[11:01:20.177]                 is_error <- inherits(cond, "error")
[11:01:20.177]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.177]                   NULL)
[11:01:20.177]                 if (is_error) {
[11:01:20.177]                   sessionInformation <- function() {
[11:01:20.177]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.177]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.177]                       search = base::search(), system = base::Sys.info())
[11:01:20.177]                   }
[11:01:20.177]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.177]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.177]                     cond$call), session = sessionInformation(), 
[11:01:20.177]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.177]                   signalCondition(cond)
[11:01:20.177]                 }
[11:01:20.177]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.177]                 "immediateCondition"))) {
[11:01:20.177]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.177]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.177]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.177]                   if (TRUE && !signal) {
[11:01:20.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.177]                     {
[11:01:20.177]                       inherits <- base::inherits
[11:01:20.177]                       invokeRestart <- base::invokeRestart
[11:01:20.177]                       is.null <- base::is.null
[11:01:20.177]                       muffled <- FALSE
[11:01:20.177]                       if (inherits(cond, "message")) {
[11:01:20.177]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.177]                         if (muffled) 
[11:01:20.177]                           invokeRestart("muffleMessage")
[11:01:20.177]                       }
[11:01:20.177]                       else if (inherits(cond, "warning")) {
[11:01:20.177]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.177]                         if (muffled) 
[11:01:20.177]                           invokeRestart("muffleWarning")
[11:01:20.177]                       }
[11:01:20.177]                       else if (inherits(cond, "condition")) {
[11:01:20.177]                         if (!is.null(pattern)) {
[11:01:20.177]                           computeRestarts <- base::computeRestarts
[11:01:20.177]                           grepl <- base::grepl
[11:01:20.177]                           restarts <- computeRestarts(cond)
[11:01:20.177]                           for (restart in restarts) {
[11:01:20.177]                             name <- restart$name
[11:01:20.177]                             if (is.null(name)) 
[11:01:20.177]                               next
[11:01:20.177]                             if (!grepl(pattern, name)) 
[11:01:20.177]                               next
[11:01:20.177]                             invokeRestart(restart)
[11:01:20.177]                             muffled <- TRUE
[11:01:20.177]                             break
[11:01:20.177]                           }
[11:01:20.177]                         }
[11:01:20.177]                       }
[11:01:20.177]                       invisible(muffled)
[11:01:20.177]                     }
[11:01:20.177]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.177]                   }
[11:01:20.177]                 }
[11:01:20.177]                 else {
[11:01:20.177]                   if (TRUE) {
[11:01:20.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.177]                     {
[11:01:20.177]                       inherits <- base::inherits
[11:01:20.177]                       invokeRestart <- base::invokeRestart
[11:01:20.177]                       is.null <- base::is.null
[11:01:20.177]                       muffled <- FALSE
[11:01:20.177]                       if (inherits(cond, "message")) {
[11:01:20.177]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.177]                         if (muffled) 
[11:01:20.177]                           invokeRestart("muffleMessage")
[11:01:20.177]                       }
[11:01:20.177]                       else if (inherits(cond, "warning")) {
[11:01:20.177]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.177]                         if (muffled) 
[11:01:20.177]                           invokeRestart("muffleWarning")
[11:01:20.177]                       }
[11:01:20.177]                       else if (inherits(cond, "condition")) {
[11:01:20.177]                         if (!is.null(pattern)) {
[11:01:20.177]                           computeRestarts <- base::computeRestarts
[11:01:20.177]                           grepl <- base::grepl
[11:01:20.177]                           restarts <- computeRestarts(cond)
[11:01:20.177]                           for (restart in restarts) {
[11:01:20.177]                             name <- restart$name
[11:01:20.177]                             if (is.null(name)) 
[11:01:20.177]                               next
[11:01:20.177]                             if (!grepl(pattern, name)) 
[11:01:20.177]                               next
[11:01:20.177]                             invokeRestart(restart)
[11:01:20.177]                             muffled <- TRUE
[11:01:20.177]                             break
[11:01:20.177]                           }
[11:01:20.177]                         }
[11:01:20.177]                       }
[11:01:20.177]                       invisible(muffled)
[11:01:20.177]                     }
[11:01:20.177]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.177]                   }
[11:01:20.177]                 }
[11:01:20.177]             }
[11:01:20.177]         }))
[11:01:20.177]     }, error = function(ex) {
[11:01:20.177]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.177]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.177]                 ...future.rng), started = ...future.startTime, 
[11:01:20.177]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.177]             version = "1.8"), class = "FutureResult")
[11:01:20.177]     }, finally = {
[11:01:20.177]         if (!identical(...future.workdir, getwd())) 
[11:01:20.177]             setwd(...future.workdir)
[11:01:20.177]         {
[11:01:20.177]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.177]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.177]             }
[11:01:20.177]             base::options(...future.oldOptions)
[11:01:20.177]             if (.Platform$OS.type == "windows") {
[11:01:20.177]                 old_names <- names(...future.oldEnvVars)
[11:01:20.177]                 envs <- base::Sys.getenv()
[11:01:20.177]                 names <- names(envs)
[11:01:20.177]                 common <- intersect(names, old_names)
[11:01:20.177]                 added <- setdiff(names, old_names)
[11:01:20.177]                 removed <- setdiff(old_names, names)
[11:01:20.177]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.177]                   envs[common]]
[11:01:20.177]                 NAMES <- toupper(changed)
[11:01:20.177]                 args <- list()
[11:01:20.177]                 for (kk in seq_along(NAMES)) {
[11:01:20.177]                   name <- changed[[kk]]
[11:01:20.177]                   NAME <- NAMES[[kk]]
[11:01:20.177]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.177]                     next
[11:01:20.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.177]                 }
[11:01:20.177]                 NAMES <- toupper(added)
[11:01:20.177]                 for (kk in seq_along(NAMES)) {
[11:01:20.177]                   name <- added[[kk]]
[11:01:20.177]                   NAME <- NAMES[[kk]]
[11:01:20.177]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.177]                     next
[11:01:20.177]                   args[[name]] <- ""
[11:01:20.177]                 }
[11:01:20.177]                 NAMES <- toupper(removed)
[11:01:20.177]                 for (kk in seq_along(NAMES)) {
[11:01:20.177]                   name <- removed[[kk]]
[11:01:20.177]                   NAME <- NAMES[[kk]]
[11:01:20.177]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.177]                     next
[11:01:20.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.177]                 }
[11:01:20.177]                 if (length(args) > 0) 
[11:01:20.177]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.177]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.177]             }
[11:01:20.177]             else {
[11:01:20.177]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.177]             }
[11:01:20.177]             {
[11:01:20.177]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.177]                   0L) {
[11:01:20.177]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.177]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.177]                   base::options(opts)
[11:01:20.177]                 }
[11:01:20.177]                 {
[11:01:20.177]                   {
[11:01:20.177]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:20.177]                     NULL
[11:01:20.177]                   }
[11:01:20.177]                   options(future.plan = NULL)
[11:01:20.177]                   if (is.na(NA_character_)) 
[11:01:20.177]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.177]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.177]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.177]                     .init = FALSE)
[11:01:20.177]                 }
[11:01:20.177]             }
[11:01:20.177]         }
[11:01:20.177]     })
[11:01:20.177]     if (TRUE) {
[11:01:20.177]         base::sink(type = "output", split = FALSE)
[11:01:20.177]         if (TRUE) {
[11:01:20.177]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.177]         }
[11:01:20.177]         else {
[11:01:20.177]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.177]         }
[11:01:20.177]         base::close(...future.stdout)
[11:01:20.177]         ...future.stdout <- NULL
[11:01:20.177]     }
[11:01:20.177]     ...future.result$conditions <- ...future.conditions
[11:01:20.177]     ...future.result$finished <- base::Sys.time()
[11:01:20.177]     ...future.result
[11:01:20.177] }
[11:01:20.179] requestCore(): workers = 2
[11:01:20.182] MulticoreFuture started
[11:01:20.182] - Launch lazy future ... done
[11:01:20.183] plan(): Setting new future strategy stack:
[11:01:20.183] run() for ‘MulticoreFuture’ ... done
[11:01:20.184] result() for MulticoreFuture ...
[11:01:20.183] List of future strategies:
[11:01:20.183] 1. sequential:
[11:01:20.183]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.183]    - tweaked: FALSE
[11:01:20.183]    - call: NULL
[11:01:20.184] plan(): nbrOfWorkers() = 1
[11:01:20.186] plan(): Setting new future strategy stack:
[11:01:20.186] List of future strategies:
[11:01:20.186] 1. multicore:
[11:01:20.186]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:20.186]    - tweaked: FALSE
[11:01:20.186]    - call: plan(strategy)
[11:01:20.189] plan(): nbrOfWorkers() = 2
[11:01:20.193] result() for MulticoreFuture ...
[11:01:20.193] result() for MulticoreFuture ... done
[11:01:20.193] result() for MulticoreFuture ... done
[11:01:20.194] result() for MulticoreFuture ...
[11:01:20.194] result() for MulticoreFuture ... done
** Future evaluation with globals
[11:01:20.194] getGlobalsAndPackages() ...
[11:01:20.194] Searching for globals...
[11:01:20.196] - globals found: [3] ‘{’, ‘<-’, ‘a’
[11:01:20.196] Searching for globals ... DONE
[11:01:20.196] Resolving globals: FALSE
[11:01:20.196] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:20.197] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:20.197] - globals: [1] ‘a’
[11:01:20.197] 
[11:01:20.197] getGlobalsAndPackages() ... DONE
[11:01:20.197] run() for ‘Future’ ...
[11:01:20.197] - state: ‘created’
[11:01:20.198] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:20.200] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:20.200] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:20.200]   - Field: ‘label’
[11:01:20.200]   - Field: ‘local’
[11:01:20.200]   - Field: ‘owner’
[11:01:20.200]   - Field: ‘envir’
[11:01:20.200]   - Field: ‘workers’
[11:01:20.201]   - Field: ‘packages’
[11:01:20.201]   - Field: ‘gc’
[11:01:20.201]   - Field: ‘job’
[11:01:20.201]   - Field: ‘conditions’
[11:01:20.201]   - Field: ‘expr’
[11:01:20.201]   - Field: ‘uuid’
[11:01:20.201]   - Field: ‘seed’
[11:01:20.201]   - Field: ‘version’
[11:01:20.201]   - Field: ‘result’
[11:01:20.201]   - Field: ‘asynchronous’
[11:01:20.202]   - Field: ‘calls’
[11:01:20.202]   - Field: ‘globals’
[11:01:20.202]   - Field: ‘stdout’
[11:01:20.202]   - Field: ‘earlySignal’
[11:01:20.202]   - Field: ‘lazy’
[11:01:20.202]   - Field: ‘state’
[11:01:20.202] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:20.202] - Launch lazy future ...
[11:01:20.203] Packages needed by the future expression (n = 0): <none>
[11:01:20.203] Packages needed by future strategies (n = 0): <none>
[11:01:20.203] {
[11:01:20.203]     {
[11:01:20.203]         {
[11:01:20.203]             ...future.startTime <- base::Sys.time()
[11:01:20.203]             {
[11:01:20.203]                 {
[11:01:20.203]                   {
[11:01:20.203]                     {
[11:01:20.203]                       base::local({
[11:01:20.203]                         has_future <- base::requireNamespace("future", 
[11:01:20.203]                           quietly = TRUE)
[11:01:20.203]                         if (has_future) {
[11:01:20.203]                           ns <- base::getNamespace("future")
[11:01:20.203]                           version <- ns[[".package"]][["version"]]
[11:01:20.203]                           if (is.null(version)) 
[11:01:20.203]                             version <- utils::packageVersion("future")
[11:01:20.203]                         }
[11:01:20.203]                         else {
[11:01:20.203]                           version <- NULL
[11:01:20.203]                         }
[11:01:20.203]                         if (!has_future || version < "1.8.0") {
[11:01:20.203]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.203]                             "", base::R.version$version.string), 
[11:01:20.203]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:20.203]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.203]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.203]                               "release", "version")], collapse = " "), 
[11:01:20.203]                             hostname = base::Sys.info()[["nodename"]])
[11:01:20.203]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.203]                             info)
[11:01:20.203]                           info <- base::paste(info, collapse = "; ")
[11:01:20.203]                           if (!has_future) {
[11:01:20.203]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.203]                               info)
[11:01:20.203]                           }
[11:01:20.203]                           else {
[11:01:20.203]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.203]                               info, version)
[11:01:20.203]                           }
[11:01:20.203]                           base::stop(msg)
[11:01:20.203]                         }
[11:01:20.203]                       })
[11:01:20.203]                     }
[11:01:20.203]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:20.203]                     base::options(mc.cores = 1L)
[11:01:20.203]                   }
[11:01:20.203]                   ...future.strategy.old <- future::plan("list")
[11:01:20.203]                   options(future.plan = NULL)
[11:01:20.203]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.203]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.203]                 }
[11:01:20.203]                 ...future.workdir <- getwd()
[11:01:20.203]             }
[11:01:20.203]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.203]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.203]         }
[11:01:20.203]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.203]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.203]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.203]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.203]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.203]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.203]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.203]             base::names(...future.oldOptions))
[11:01:20.203]     }
[11:01:20.203]     if (FALSE) {
[11:01:20.203]     }
[11:01:20.203]     else {
[11:01:20.203]         if (TRUE) {
[11:01:20.203]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.203]                 open = "w")
[11:01:20.203]         }
[11:01:20.203]         else {
[11:01:20.203]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.203]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.203]         }
[11:01:20.203]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.203]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.203]             base::sink(type = "output", split = FALSE)
[11:01:20.203]             base::close(...future.stdout)
[11:01:20.203]         }, add = TRUE)
[11:01:20.203]     }
[11:01:20.203]     ...future.frame <- base::sys.nframe()
[11:01:20.203]     ...future.conditions <- base::list()
[11:01:20.203]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.203]     if (FALSE) {
[11:01:20.203]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.203]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.203]     }
[11:01:20.203]     ...future.result <- base::tryCatch({
[11:01:20.203]         base::withCallingHandlers({
[11:01:20.203]             ...future.value <- base::withVisible(base::local({
[11:01:20.203]                 withCallingHandlers({
[11:01:20.203]                   {
[11:01:20.203]                     x <- a
[11:01:20.203]                   }
[11:01:20.203]                 }, immediateCondition = function(cond) {
[11:01:20.203]                   save_rds <- function (object, pathname, ...) 
[11:01:20.203]                   {
[11:01:20.203]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:20.203]                     if (file_test("-f", pathname_tmp)) {
[11:01:20.203]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.203]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:20.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.203]                         fi_tmp[["mtime"]])
[11:01:20.203]                     }
[11:01:20.203]                     tryCatch({
[11:01:20.203]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:20.203]                     }, error = function(ex) {
[11:01:20.203]                       msg <- conditionMessage(ex)
[11:01:20.203]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.203]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:20.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.203]                         fi_tmp[["mtime"]], msg)
[11:01:20.203]                       ex$message <- msg
[11:01:20.203]                       stop(ex)
[11:01:20.203]                     })
[11:01:20.203]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:20.203]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:20.203]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:20.203]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.203]                       fi <- file.info(pathname)
[11:01:20.203]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:20.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.203]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:20.203]                         fi[["size"]], fi[["mtime"]])
[11:01:20.203]                       stop(msg)
[11:01:20.203]                     }
[11:01:20.203]                     invisible(pathname)
[11:01:20.203]                   }
[11:01:20.203]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:20.203]                     rootPath = tempdir()) 
[11:01:20.203]                   {
[11:01:20.203]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:20.203]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:20.203]                       tmpdir = path, fileext = ".rds")
[11:01:20.203]                     save_rds(obj, file)
[11:01:20.203]                   }
[11:01:20.203]                   saveImmediateCondition(cond, path = "/tmp/RtmpxWUrEc/.future/immediateConditions")
[11:01:20.203]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.203]                   {
[11:01:20.203]                     inherits <- base::inherits
[11:01:20.203]                     invokeRestart <- base::invokeRestart
[11:01:20.203]                     is.null <- base::is.null
[11:01:20.203]                     muffled <- FALSE
[11:01:20.203]                     if (inherits(cond, "message")) {
[11:01:20.203]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:20.203]                       if (muffled) 
[11:01:20.203]                         invokeRestart("muffleMessage")
[11:01:20.203]                     }
[11:01:20.203]                     else if (inherits(cond, "warning")) {
[11:01:20.203]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:20.203]                       if (muffled) 
[11:01:20.203]                         invokeRestart("muffleWarning")
[11:01:20.203]                     }
[11:01:20.203]                     else if (inherits(cond, "condition")) {
[11:01:20.203]                       if (!is.null(pattern)) {
[11:01:20.203]                         computeRestarts <- base::computeRestarts
[11:01:20.203]                         grepl <- base::grepl
[11:01:20.203]                         restarts <- computeRestarts(cond)
[11:01:20.203]                         for (restart in restarts) {
[11:01:20.203]                           name <- restart$name
[11:01:20.203]                           if (is.null(name)) 
[11:01:20.203]                             next
[11:01:20.203]                           if (!grepl(pattern, name)) 
[11:01:20.203]                             next
[11:01:20.203]                           invokeRestart(restart)
[11:01:20.203]                           muffled <- TRUE
[11:01:20.203]                           break
[11:01:20.203]                         }
[11:01:20.203]                       }
[11:01:20.203]                     }
[11:01:20.203]                     invisible(muffled)
[11:01:20.203]                   }
[11:01:20.203]                   muffleCondition(cond)
[11:01:20.203]                 })
[11:01:20.203]             }))
[11:01:20.203]             future::FutureResult(value = ...future.value$value, 
[11:01:20.203]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.203]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.203]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.203]                     ...future.globalenv.names))
[11:01:20.203]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.203]         }, condition = base::local({
[11:01:20.203]             c <- base::c
[11:01:20.203]             inherits <- base::inherits
[11:01:20.203]             invokeRestart <- base::invokeRestart
[11:01:20.203]             length <- base::length
[11:01:20.203]             list <- base::list
[11:01:20.203]             seq.int <- base::seq.int
[11:01:20.203]             signalCondition <- base::signalCondition
[11:01:20.203]             sys.calls <- base::sys.calls
[11:01:20.203]             `[[` <- base::`[[`
[11:01:20.203]             `+` <- base::`+`
[11:01:20.203]             `<<-` <- base::`<<-`
[11:01:20.203]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.203]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.203]                   3L)]
[11:01:20.203]             }
[11:01:20.203]             function(cond) {
[11:01:20.203]                 is_error <- inherits(cond, "error")
[11:01:20.203]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.203]                   NULL)
[11:01:20.203]                 if (is_error) {
[11:01:20.203]                   sessionInformation <- function() {
[11:01:20.203]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.203]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.203]                       search = base::search(), system = base::Sys.info())
[11:01:20.203]                   }
[11:01:20.203]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.203]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.203]                     cond$call), session = sessionInformation(), 
[11:01:20.203]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.203]                   signalCondition(cond)
[11:01:20.203]                 }
[11:01:20.203]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.203]                 "immediateCondition"))) {
[11:01:20.203]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.203]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.203]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.203]                   if (TRUE && !signal) {
[11:01:20.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.203]                     {
[11:01:20.203]                       inherits <- base::inherits
[11:01:20.203]                       invokeRestart <- base::invokeRestart
[11:01:20.203]                       is.null <- base::is.null
[11:01:20.203]                       muffled <- FALSE
[11:01:20.203]                       if (inherits(cond, "message")) {
[11:01:20.203]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.203]                         if (muffled) 
[11:01:20.203]                           invokeRestart("muffleMessage")
[11:01:20.203]                       }
[11:01:20.203]                       else if (inherits(cond, "warning")) {
[11:01:20.203]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.203]                         if (muffled) 
[11:01:20.203]                           invokeRestart("muffleWarning")
[11:01:20.203]                       }
[11:01:20.203]                       else if (inherits(cond, "condition")) {
[11:01:20.203]                         if (!is.null(pattern)) {
[11:01:20.203]                           computeRestarts <- base::computeRestarts
[11:01:20.203]                           grepl <- base::grepl
[11:01:20.203]                           restarts <- computeRestarts(cond)
[11:01:20.203]                           for (restart in restarts) {
[11:01:20.203]                             name <- restart$name
[11:01:20.203]                             if (is.null(name)) 
[11:01:20.203]                               next
[11:01:20.203]                             if (!grepl(pattern, name)) 
[11:01:20.203]                               next
[11:01:20.203]                             invokeRestart(restart)
[11:01:20.203]                             muffled <- TRUE
[11:01:20.203]                             break
[11:01:20.203]                           }
[11:01:20.203]                         }
[11:01:20.203]                       }
[11:01:20.203]                       invisible(muffled)
[11:01:20.203]                     }
[11:01:20.203]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.203]                   }
[11:01:20.203]                 }
[11:01:20.203]                 else {
[11:01:20.203]                   if (TRUE) {
[11:01:20.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.203]                     {
[11:01:20.203]                       inherits <- base::inherits
[11:01:20.203]                       invokeRestart <- base::invokeRestart
[11:01:20.203]                       is.null <- base::is.null
[11:01:20.203]                       muffled <- FALSE
[11:01:20.203]                       if (inherits(cond, "message")) {
[11:01:20.203]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.203]                         if (muffled) 
[11:01:20.203]                           invokeRestart("muffleMessage")
[11:01:20.203]                       }
[11:01:20.203]                       else if (inherits(cond, "warning")) {
[11:01:20.203]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.203]                         if (muffled) 
[11:01:20.203]                           invokeRestart("muffleWarning")
[11:01:20.203]                       }
[11:01:20.203]                       else if (inherits(cond, "condition")) {
[11:01:20.203]                         if (!is.null(pattern)) {
[11:01:20.203]                           computeRestarts <- base::computeRestarts
[11:01:20.203]                           grepl <- base::grepl
[11:01:20.203]                           restarts <- computeRestarts(cond)
[11:01:20.203]                           for (restart in restarts) {
[11:01:20.203]                             name <- restart$name
[11:01:20.203]                             if (is.null(name)) 
[11:01:20.203]                               next
[11:01:20.203]                             if (!grepl(pattern, name)) 
[11:01:20.203]                               next
[11:01:20.203]                             invokeRestart(restart)
[11:01:20.203]                             muffled <- TRUE
[11:01:20.203]                             break
[11:01:20.203]                           }
[11:01:20.203]                         }
[11:01:20.203]                       }
[11:01:20.203]                       invisible(muffled)
[11:01:20.203]                     }
[11:01:20.203]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.203]                   }
[11:01:20.203]                 }
[11:01:20.203]             }
[11:01:20.203]         }))
[11:01:20.203]     }, error = function(ex) {
[11:01:20.203]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.203]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.203]                 ...future.rng), started = ...future.startTime, 
[11:01:20.203]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.203]             version = "1.8"), class = "FutureResult")
[11:01:20.203]     }, finally = {
[11:01:20.203]         if (!identical(...future.workdir, getwd())) 
[11:01:20.203]             setwd(...future.workdir)
[11:01:20.203]         {
[11:01:20.203]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.203]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.203]             }
[11:01:20.203]             base::options(...future.oldOptions)
[11:01:20.203]             if (.Platform$OS.type == "windows") {
[11:01:20.203]                 old_names <- names(...future.oldEnvVars)
[11:01:20.203]                 envs <- base::Sys.getenv()
[11:01:20.203]                 names <- names(envs)
[11:01:20.203]                 common <- intersect(names, old_names)
[11:01:20.203]                 added <- setdiff(names, old_names)
[11:01:20.203]                 removed <- setdiff(old_names, names)
[11:01:20.203]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.203]                   envs[common]]
[11:01:20.203]                 NAMES <- toupper(changed)
[11:01:20.203]                 args <- list()
[11:01:20.203]                 for (kk in seq_along(NAMES)) {
[11:01:20.203]                   name <- changed[[kk]]
[11:01:20.203]                   NAME <- NAMES[[kk]]
[11:01:20.203]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.203]                     next
[11:01:20.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.203]                 }
[11:01:20.203]                 NAMES <- toupper(added)
[11:01:20.203]                 for (kk in seq_along(NAMES)) {
[11:01:20.203]                   name <- added[[kk]]
[11:01:20.203]                   NAME <- NAMES[[kk]]
[11:01:20.203]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.203]                     next
[11:01:20.203]                   args[[name]] <- ""
[11:01:20.203]                 }
[11:01:20.203]                 NAMES <- toupper(removed)
[11:01:20.203]                 for (kk in seq_along(NAMES)) {
[11:01:20.203]                   name <- removed[[kk]]
[11:01:20.203]                   NAME <- NAMES[[kk]]
[11:01:20.203]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.203]                     next
[11:01:20.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.203]                 }
[11:01:20.203]                 if (length(args) > 0) 
[11:01:20.203]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.203]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.203]             }
[11:01:20.203]             else {
[11:01:20.203]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.203]             }
[11:01:20.203]             {
[11:01:20.203]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.203]                   0L) {
[11:01:20.203]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.203]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.203]                   base::options(opts)
[11:01:20.203]                 }
[11:01:20.203]                 {
[11:01:20.203]                   {
[11:01:20.203]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:20.203]                     NULL
[11:01:20.203]                   }
[11:01:20.203]                   options(future.plan = NULL)
[11:01:20.203]                   if (is.na(NA_character_)) 
[11:01:20.203]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.203]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.203]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.203]                     .init = FALSE)
[11:01:20.203]                 }
[11:01:20.203]             }
[11:01:20.203]         }
[11:01:20.203]     })
[11:01:20.203]     if (TRUE) {
[11:01:20.203]         base::sink(type = "output", split = FALSE)
[11:01:20.203]         if (TRUE) {
[11:01:20.203]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.203]         }
[11:01:20.203]         else {
[11:01:20.203]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.203]         }
[11:01:20.203]         base::close(...future.stdout)
[11:01:20.203]         ...future.stdout <- NULL
[11:01:20.203]     }
[11:01:20.203]     ...future.result$conditions <- ...future.conditions
[11:01:20.203]     ...future.result$finished <- base::Sys.time()
[11:01:20.203]     ...future.result
[11:01:20.203] }
[11:01:20.206] assign_globals() ...
[11:01:20.206] List of 1
[11:01:20.206]  $ a: num 2
[11:01:20.206]  - attr(*, "where")=List of 1
[11:01:20.206]   ..$ a:<environment: R_EmptyEnv> 
[11:01:20.206]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:20.206]  - attr(*, "resolved")= logi FALSE
[11:01:20.206]  - attr(*, "total_size")= num 39
[11:01:20.206]  - attr(*, "already-done")= logi TRUE
[11:01:20.209] - copied ‘a’ to environment
[11:01:20.209] assign_globals() ... done
[11:01:20.209] requestCore(): workers = 2
[11:01:20.211] MulticoreFuture started
[11:01:20.211] - Launch lazy future ... done
[11:01:20.211] run() for ‘MulticoreFuture’ ... done
[11:01:20.211] result() for MulticoreFuture ...
[11:01:20.212] plan(): Setting new future strategy stack:
[11:01:20.212] List of future strategies:
[11:01:20.212] 1. sequential:
[11:01:20.212]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.212]    - tweaked: FALSE
[11:01:20.212]    - call: NULL
[11:01:20.213] plan(): nbrOfWorkers() = 1
[11:01:20.215] plan(): Setting new future strategy stack:
[11:01:20.215] List of future strategies:
[11:01:20.215] 1. multicore:
[11:01:20.215]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:20.215]    - tweaked: FALSE
[11:01:20.215]    - call: plan(strategy)
[11:01:20.218] plan(): nbrOfWorkers() = 2
[11:01:20.218] result() for MulticoreFuture ...
[11:01:20.219] result() for MulticoreFuture ... done
[11:01:20.219] result() for MulticoreFuture ... done
[11:01:20.219] result() for MulticoreFuture ...
[11:01:20.219] result() for MulticoreFuture ... done
** Future evaluation with errors
[11:01:20.220] getGlobalsAndPackages() ...
[11:01:20.220] Searching for globals...
[11:01:20.225] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[11:01:20.225] Searching for globals ... DONE
[11:01:20.225] Resolving globals: FALSE
[11:01:20.225] 
[11:01:20.226] 
[11:01:20.226] getGlobalsAndPackages() ... DONE
[11:01:20.226] run() for ‘Future’ ...
[11:01:20.226] - state: ‘created’
[11:01:20.226] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:20.228] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:20.229] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:20.229]   - Field: ‘label’
[11:01:20.229]   - Field: ‘local’
[11:01:20.229]   - Field: ‘owner’
[11:01:20.229]   - Field: ‘envir’
[11:01:20.229]   - Field: ‘workers’
[11:01:20.229]   - Field: ‘packages’
[11:01:20.229]   - Field: ‘gc’
[11:01:20.230]   - Field: ‘job’
[11:01:20.230]   - Field: ‘conditions’
[11:01:20.230]   - Field: ‘expr’
[11:01:20.230]   - Field: ‘uuid’
[11:01:20.230]   - Field: ‘seed’
[11:01:20.230]   - Field: ‘version’
[11:01:20.230]   - Field: ‘result’
[11:01:20.230]   - Field: ‘asynchronous’
[11:01:20.230]   - Field: ‘calls’
[11:01:20.231]   - Field: ‘globals’
[11:01:20.231]   - Field: ‘stdout’
[11:01:20.231]   - Field: ‘earlySignal’
[11:01:20.231]   - Field: ‘lazy’
[11:01:20.231]   - Field: ‘state’
[11:01:20.231] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:20.231] - Launch lazy future ...
[11:01:20.231] Packages needed by the future expression (n = 0): <none>
[11:01:20.232] Packages needed by future strategies (n = 0): <none>
[11:01:20.232] {
[11:01:20.232]     {
[11:01:20.232]         {
[11:01:20.232]             ...future.startTime <- base::Sys.time()
[11:01:20.232]             {
[11:01:20.232]                 {
[11:01:20.232]                   {
[11:01:20.232]                     {
[11:01:20.232]                       base::local({
[11:01:20.232]                         has_future <- base::requireNamespace("future", 
[11:01:20.232]                           quietly = TRUE)
[11:01:20.232]                         if (has_future) {
[11:01:20.232]                           ns <- base::getNamespace("future")
[11:01:20.232]                           version <- ns[[".package"]][["version"]]
[11:01:20.232]                           if (is.null(version)) 
[11:01:20.232]                             version <- utils::packageVersion("future")
[11:01:20.232]                         }
[11:01:20.232]                         else {
[11:01:20.232]                           version <- NULL
[11:01:20.232]                         }
[11:01:20.232]                         if (!has_future || version < "1.8.0") {
[11:01:20.232]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.232]                             "", base::R.version$version.string), 
[11:01:20.232]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:20.232]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.232]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.232]                               "release", "version")], collapse = " "), 
[11:01:20.232]                             hostname = base::Sys.info()[["nodename"]])
[11:01:20.232]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.232]                             info)
[11:01:20.232]                           info <- base::paste(info, collapse = "; ")
[11:01:20.232]                           if (!has_future) {
[11:01:20.232]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.232]                               info)
[11:01:20.232]                           }
[11:01:20.232]                           else {
[11:01:20.232]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.232]                               info, version)
[11:01:20.232]                           }
[11:01:20.232]                           base::stop(msg)
[11:01:20.232]                         }
[11:01:20.232]                       })
[11:01:20.232]                     }
[11:01:20.232]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:20.232]                     base::options(mc.cores = 1L)
[11:01:20.232]                   }
[11:01:20.232]                   ...future.strategy.old <- future::plan("list")
[11:01:20.232]                   options(future.plan = NULL)
[11:01:20.232]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.232]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.232]                 }
[11:01:20.232]                 ...future.workdir <- getwd()
[11:01:20.232]             }
[11:01:20.232]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.232]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.232]         }
[11:01:20.232]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.232]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.232]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.232]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.232]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.232]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.232]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.232]             base::names(...future.oldOptions))
[11:01:20.232]     }
[11:01:20.232]     if (FALSE) {
[11:01:20.232]     }
[11:01:20.232]     else {
[11:01:20.232]         if (TRUE) {
[11:01:20.232]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.232]                 open = "w")
[11:01:20.232]         }
[11:01:20.232]         else {
[11:01:20.232]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.232]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.232]         }
[11:01:20.232]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.232]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.232]             base::sink(type = "output", split = FALSE)
[11:01:20.232]             base::close(...future.stdout)
[11:01:20.232]         }, add = TRUE)
[11:01:20.232]     }
[11:01:20.232]     ...future.frame <- base::sys.nframe()
[11:01:20.232]     ...future.conditions <- base::list()
[11:01:20.232]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.232]     if (FALSE) {
[11:01:20.232]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.232]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.232]     }
[11:01:20.232]     ...future.result <- base::tryCatch({
[11:01:20.232]         base::withCallingHandlers({
[11:01:20.232]             ...future.value <- base::withVisible(base::local({
[11:01:20.232]                 withCallingHandlers({
[11:01:20.232]                   {
[11:01:20.232]                     x <- 3
[11:01:20.232]                     stop("Woops!")
[11:01:20.232]                     x
[11:01:20.232]                   }
[11:01:20.232]                 }, immediateCondition = function(cond) {
[11:01:20.232]                   save_rds <- function (object, pathname, ...) 
[11:01:20.232]                   {
[11:01:20.232]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:20.232]                     if (file_test("-f", pathname_tmp)) {
[11:01:20.232]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.232]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:20.232]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.232]                         fi_tmp[["mtime"]])
[11:01:20.232]                     }
[11:01:20.232]                     tryCatch({
[11:01:20.232]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:20.232]                     }, error = function(ex) {
[11:01:20.232]                       msg <- conditionMessage(ex)
[11:01:20.232]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.232]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:20.232]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.232]                         fi_tmp[["mtime"]], msg)
[11:01:20.232]                       ex$message <- msg
[11:01:20.232]                       stop(ex)
[11:01:20.232]                     })
[11:01:20.232]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:20.232]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:20.232]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:20.232]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.232]                       fi <- file.info(pathname)
[11:01:20.232]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:20.232]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.232]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:20.232]                         fi[["size"]], fi[["mtime"]])
[11:01:20.232]                       stop(msg)
[11:01:20.232]                     }
[11:01:20.232]                     invisible(pathname)
[11:01:20.232]                   }
[11:01:20.232]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:20.232]                     rootPath = tempdir()) 
[11:01:20.232]                   {
[11:01:20.232]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:20.232]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:20.232]                       tmpdir = path, fileext = ".rds")
[11:01:20.232]                     save_rds(obj, file)
[11:01:20.232]                   }
[11:01:20.232]                   saveImmediateCondition(cond, path = "/tmp/RtmpxWUrEc/.future/immediateConditions")
[11:01:20.232]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.232]                   {
[11:01:20.232]                     inherits <- base::inherits
[11:01:20.232]                     invokeRestart <- base::invokeRestart
[11:01:20.232]                     is.null <- base::is.null
[11:01:20.232]                     muffled <- FALSE
[11:01:20.232]                     if (inherits(cond, "message")) {
[11:01:20.232]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:20.232]                       if (muffled) 
[11:01:20.232]                         invokeRestart("muffleMessage")
[11:01:20.232]                     }
[11:01:20.232]                     else if (inherits(cond, "warning")) {
[11:01:20.232]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:20.232]                       if (muffled) 
[11:01:20.232]                         invokeRestart("muffleWarning")
[11:01:20.232]                     }
[11:01:20.232]                     else if (inherits(cond, "condition")) {
[11:01:20.232]                       if (!is.null(pattern)) {
[11:01:20.232]                         computeRestarts <- base::computeRestarts
[11:01:20.232]                         grepl <- base::grepl
[11:01:20.232]                         restarts <- computeRestarts(cond)
[11:01:20.232]                         for (restart in restarts) {
[11:01:20.232]                           name <- restart$name
[11:01:20.232]                           if (is.null(name)) 
[11:01:20.232]                             next
[11:01:20.232]                           if (!grepl(pattern, name)) 
[11:01:20.232]                             next
[11:01:20.232]                           invokeRestart(restart)
[11:01:20.232]                           muffled <- TRUE
[11:01:20.232]                           break
[11:01:20.232]                         }
[11:01:20.232]                       }
[11:01:20.232]                     }
[11:01:20.232]                     invisible(muffled)
[11:01:20.232]                   }
[11:01:20.232]                   muffleCondition(cond)
[11:01:20.232]                 })
[11:01:20.232]             }))
[11:01:20.232]             future::FutureResult(value = ...future.value$value, 
[11:01:20.232]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.232]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.232]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.232]                     ...future.globalenv.names))
[11:01:20.232]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.232]         }, condition = base::local({
[11:01:20.232]             c <- base::c
[11:01:20.232]             inherits <- base::inherits
[11:01:20.232]             invokeRestart <- base::invokeRestart
[11:01:20.232]             length <- base::length
[11:01:20.232]             list <- base::list
[11:01:20.232]             seq.int <- base::seq.int
[11:01:20.232]             signalCondition <- base::signalCondition
[11:01:20.232]             sys.calls <- base::sys.calls
[11:01:20.232]             `[[` <- base::`[[`
[11:01:20.232]             `+` <- base::`+`
[11:01:20.232]             `<<-` <- base::`<<-`
[11:01:20.232]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.232]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.232]                   3L)]
[11:01:20.232]             }
[11:01:20.232]             function(cond) {
[11:01:20.232]                 is_error <- inherits(cond, "error")
[11:01:20.232]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.232]                   NULL)
[11:01:20.232]                 if (is_error) {
[11:01:20.232]                   sessionInformation <- function() {
[11:01:20.232]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.232]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.232]                       search = base::search(), system = base::Sys.info())
[11:01:20.232]                   }
[11:01:20.232]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.232]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.232]                     cond$call), session = sessionInformation(), 
[11:01:20.232]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.232]                   signalCondition(cond)
[11:01:20.232]                 }
[11:01:20.232]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.232]                 "immediateCondition"))) {
[11:01:20.232]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.232]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.232]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.232]                   if (TRUE && !signal) {
[11:01:20.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.232]                     {
[11:01:20.232]                       inherits <- base::inherits
[11:01:20.232]                       invokeRestart <- base::invokeRestart
[11:01:20.232]                       is.null <- base::is.null
[11:01:20.232]                       muffled <- FALSE
[11:01:20.232]                       if (inherits(cond, "message")) {
[11:01:20.232]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.232]                         if (muffled) 
[11:01:20.232]                           invokeRestart("muffleMessage")
[11:01:20.232]                       }
[11:01:20.232]                       else if (inherits(cond, "warning")) {
[11:01:20.232]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.232]                         if (muffled) 
[11:01:20.232]                           invokeRestart("muffleWarning")
[11:01:20.232]                       }
[11:01:20.232]                       else if (inherits(cond, "condition")) {
[11:01:20.232]                         if (!is.null(pattern)) {
[11:01:20.232]                           computeRestarts <- base::computeRestarts
[11:01:20.232]                           grepl <- base::grepl
[11:01:20.232]                           restarts <- computeRestarts(cond)
[11:01:20.232]                           for (restart in restarts) {
[11:01:20.232]                             name <- restart$name
[11:01:20.232]                             if (is.null(name)) 
[11:01:20.232]                               next
[11:01:20.232]                             if (!grepl(pattern, name)) 
[11:01:20.232]                               next
[11:01:20.232]                             invokeRestart(restart)
[11:01:20.232]                             muffled <- TRUE
[11:01:20.232]                             break
[11:01:20.232]                           }
[11:01:20.232]                         }
[11:01:20.232]                       }
[11:01:20.232]                       invisible(muffled)
[11:01:20.232]                     }
[11:01:20.232]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.232]                   }
[11:01:20.232]                 }
[11:01:20.232]                 else {
[11:01:20.232]                   if (TRUE) {
[11:01:20.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.232]                     {
[11:01:20.232]                       inherits <- base::inherits
[11:01:20.232]                       invokeRestart <- base::invokeRestart
[11:01:20.232]                       is.null <- base::is.null
[11:01:20.232]                       muffled <- FALSE
[11:01:20.232]                       if (inherits(cond, "message")) {
[11:01:20.232]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.232]                         if (muffled) 
[11:01:20.232]                           invokeRestart("muffleMessage")
[11:01:20.232]                       }
[11:01:20.232]                       else if (inherits(cond, "warning")) {
[11:01:20.232]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.232]                         if (muffled) 
[11:01:20.232]                           invokeRestart("muffleWarning")
[11:01:20.232]                       }
[11:01:20.232]                       else if (inherits(cond, "condition")) {
[11:01:20.232]                         if (!is.null(pattern)) {
[11:01:20.232]                           computeRestarts <- base::computeRestarts
[11:01:20.232]                           grepl <- base::grepl
[11:01:20.232]                           restarts <- computeRestarts(cond)
[11:01:20.232]                           for (restart in restarts) {
[11:01:20.232]                             name <- restart$name
[11:01:20.232]                             if (is.null(name)) 
[11:01:20.232]                               next
[11:01:20.232]                             if (!grepl(pattern, name)) 
[11:01:20.232]                               next
[11:01:20.232]                             invokeRestart(restart)
[11:01:20.232]                             muffled <- TRUE
[11:01:20.232]                             break
[11:01:20.232]                           }
[11:01:20.232]                         }
[11:01:20.232]                       }
[11:01:20.232]                       invisible(muffled)
[11:01:20.232]                     }
[11:01:20.232]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.232]                   }
[11:01:20.232]                 }
[11:01:20.232]             }
[11:01:20.232]         }))
[11:01:20.232]     }, error = function(ex) {
[11:01:20.232]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.232]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.232]                 ...future.rng), started = ...future.startTime, 
[11:01:20.232]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.232]             version = "1.8"), class = "FutureResult")
[11:01:20.232]     }, finally = {
[11:01:20.232]         if (!identical(...future.workdir, getwd())) 
[11:01:20.232]             setwd(...future.workdir)
[11:01:20.232]         {
[11:01:20.232]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.232]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.232]             }
[11:01:20.232]             base::options(...future.oldOptions)
[11:01:20.232]             if (.Platform$OS.type == "windows") {
[11:01:20.232]                 old_names <- names(...future.oldEnvVars)
[11:01:20.232]                 envs <- base::Sys.getenv()
[11:01:20.232]                 names <- names(envs)
[11:01:20.232]                 common <- intersect(names, old_names)
[11:01:20.232]                 added <- setdiff(names, old_names)
[11:01:20.232]                 removed <- setdiff(old_names, names)
[11:01:20.232]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.232]                   envs[common]]
[11:01:20.232]                 NAMES <- toupper(changed)
[11:01:20.232]                 args <- list()
[11:01:20.232]                 for (kk in seq_along(NAMES)) {
[11:01:20.232]                   name <- changed[[kk]]
[11:01:20.232]                   NAME <- NAMES[[kk]]
[11:01:20.232]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.232]                     next
[11:01:20.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.232]                 }
[11:01:20.232]                 NAMES <- toupper(added)
[11:01:20.232]                 for (kk in seq_along(NAMES)) {
[11:01:20.232]                   name <- added[[kk]]
[11:01:20.232]                   NAME <- NAMES[[kk]]
[11:01:20.232]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.232]                     next
[11:01:20.232]                   args[[name]] <- ""
[11:01:20.232]                 }
[11:01:20.232]                 NAMES <- toupper(removed)
[11:01:20.232]                 for (kk in seq_along(NAMES)) {
[11:01:20.232]                   name <- removed[[kk]]
[11:01:20.232]                   NAME <- NAMES[[kk]]
[11:01:20.232]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.232]                     next
[11:01:20.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.232]                 }
[11:01:20.232]                 if (length(args) > 0) 
[11:01:20.232]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.232]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.232]             }
[11:01:20.232]             else {
[11:01:20.232]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.232]             }
[11:01:20.232]             {
[11:01:20.232]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.232]                   0L) {
[11:01:20.232]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.232]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.232]                   base::options(opts)
[11:01:20.232]                 }
[11:01:20.232]                 {
[11:01:20.232]                   {
[11:01:20.232]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:20.232]                     NULL
[11:01:20.232]                   }
[11:01:20.232]                   options(future.plan = NULL)
[11:01:20.232]                   if (is.na(NA_character_)) 
[11:01:20.232]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.232]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.232]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.232]                     .init = FALSE)
[11:01:20.232]                 }
[11:01:20.232]             }
[11:01:20.232]         }
[11:01:20.232]     })
[11:01:20.232]     if (TRUE) {
[11:01:20.232]         base::sink(type = "output", split = FALSE)
[11:01:20.232]         if (TRUE) {
[11:01:20.232]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.232]         }
[11:01:20.232]         else {
[11:01:20.232]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.232]         }
[11:01:20.232]         base::close(...future.stdout)
[11:01:20.232]         ...future.stdout <- NULL
[11:01:20.232]     }
[11:01:20.232]     ...future.result$conditions <- ...future.conditions
[11:01:20.232]     ...future.result$finished <- base::Sys.time()
[11:01:20.232]     ...future.result
[11:01:20.232] }
[11:01:20.235] requestCore(): workers = 2
[11:01:20.236] MulticoreFuture started
[11:01:20.237] - Launch lazy future ... done
[11:01:20.237] run() for ‘MulticoreFuture’ ... done
[11:01:20.237] plan(): Setting new future strategy stack:
[11:01:20.237] result() for MulticoreFuture ...
[11:01:20.237] List of future strategies:
[11:01:20.237] 1. sequential:
[11:01:20.237]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.237]    - tweaked: FALSE
[11:01:20.237]    - call: NULL
[11:01:20.238] plan(): nbrOfWorkers() = 1
[11:01:20.240] plan(): Setting new future strategy stack:
[11:01:20.240] List of future strategies:
[11:01:20.240] 1. multicore:
[11:01:20.240]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:20.240]    - tweaked: FALSE
[11:01:20.240]    - call: plan(strategy)
[11:01:20.244] plan(): nbrOfWorkers() = 2
[11:01:20.248] result() for MulticoreFuture ...
[11:01:20.248] result() for MulticoreFuture ... done
[11:01:20.249] signalConditions() ...
[11:01:20.249]  - include = ‘immediateCondition’
[11:01:20.249]  - exclude = 
[11:01:20.249]  - resignal = FALSE
[11:01:20.249]  - Number of conditions: 1
[11:01:20.249] signalConditions() ... done
[11:01:20.249] result() for MulticoreFuture ... done
[11:01:20.249] result() for MulticoreFuture ...
[11:01:20.250] result() for MulticoreFuture ... done
[11:01:20.250] signalConditions() ...
[11:01:20.250]  - include = ‘immediateCondition’
[11:01:20.250]  - exclude = 
[11:01:20.250]  - resignal = FALSE
[11:01:20.250]  - Number of conditions: 1
[11:01:20.250] signalConditions() ... done
[11:01:20.250] Future state: ‘finished’
[11:01:20.251] result() for MulticoreFuture ...
[11:01:20.251] result() for MulticoreFuture ... done
[11:01:20.251] signalConditions() ...
[11:01:20.251]  - include = ‘condition’
[11:01:20.251]  - exclude = ‘immediateCondition’
[11:01:20.251]  - resignal = TRUE
[11:01:20.251]  - Number of conditions: 1
[11:01:20.251]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:20.251] signalConditions() ... done
[11:01:20.252] getGlobalsAndPackages() ...
[11:01:20.252] Searching for globals...
[11:01:20.254] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[11:01:20.254] Searching for globals ... DONE
[11:01:20.254] Resolving globals: FALSE
[11:01:20.255] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:20.255] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:20.256] - globals: [1] ‘ii’
[11:01:20.256] 
[11:01:20.256] getGlobalsAndPackages() ... DONE
[11:01:20.256] run() for ‘Future’ ...
[11:01:20.256] - state: ‘created’
[11:01:20.256] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:20.258] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:20.259] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:20.259]   - Field: ‘label’
[11:01:20.259]   - Field: ‘local’
[11:01:20.259]   - Field: ‘owner’
[11:01:20.259]   - Field: ‘envir’
[11:01:20.259]   - Field: ‘workers’
[11:01:20.259]   - Field: ‘packages’
[11:01:20.259]   - Field: ‘gc’
[11:01:20.259]   - Field: ‘job’
[11:01:20.260]   - Field: ‘conditions’
[11:01:20.260]   - Field: ‘expr’
[11:01:20.260]   - Field: ‘uuid’
[11:01:20.260]   - Field: ‘seed’
[11:01:20.260]   - Field: ‘version’
[11:01:20.260]   - Field: ‘result’
[11:01:20.260]   - Field: ‘asynchronous’
[11:01:20.260]   - Field: ‘calls’
[11:01:20.260]   - Field: ‘globals’
[11:01:20.261]   - Field: ‘stdout’
[11:01:20.261]   - Field: ‘earlySignal’
[11:01:20.261]   - Field: ‘lazy’
[11:01:20.261]   - Field: ‘state’
[11:01:20.261] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:20.261] - Launch lazy future ...
[11:01:20.261] Packages needed by the future expression (n = 0): <none>
[11:01:20.261] Packages needed by future strategies (n = 0): <none>
[11:01:20.262] {
[11:01:20.262]     {
[11:01:20.262]         {
[11:01:20.262]             ...future.startTime <- base::Sys.time()
[11:01:20.262]             {
[11:01:20.262]                 {
[11:01:20.262]                   {
[11:01:20.262]                     {
[11:01:20.262]                       base::local({
[11:01:20.262]                         has_future <- base::requireNamespace("future", 
[11:01:20.262]                           quietly = TRUE)
[11:01:20.262]                         if (has_future) {
[11:01:20.262]                           ns <- base::getNamespace("future")
[11:01:20.262]                           version <- ns[[".package"]][["version"]]
[11:01:20.262]                           if (is.null(version)) 
[11:01:20.262]                             version <- utils::packageVersion("future")
[11:01:20.262]                         }
[11:01:20.262]                         else {
[11:01:20.262]                           version <- NULL
[11:01:20.262]                         }
[11:01:20.262]                         if (!has_future || version < "1.8.0") {
[11:01:20.262]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.262]                             "", base::R.version$version.string), 
[11:01:20.262]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:20.262]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.262]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.262]                               "release", "version")], collapse = " "), 
[11:01:20.262]                             hostname = base::Sys.info()[["nodename"]])
[11:01:20.262]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.262]                             info)
[11:01:20.262]                           info <- base::paste(info, collapse = "; ")
[11:01:20.262]                           if (!has_future) {
[11:01:20.262]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.262]                               info)
[11:01:20.262]                           }
[11:01:20.262]                           else {
[11:01:20.262]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.262]                               info, version)
[11:01:20.262]                           }
[11:01:20.262]                           base::stop(msg)
[11:01:20.262]                         }
[11:01:20.262]                       })
[11:01:20.262]                     }
[11:01:20.262]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:20.262]                     base::options(mc.cores = 1L)
[11:01:20.262]                   }
[11:01:20.262]                   ...future.strategy.old <- future::plan("list")
[11:01:20.262]                   options(future.plan = NULL)
[11:01:20.262]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.262]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.262]                 }
[11:01:20.262]                 ...future.workdir <- getwd()
[11:01:20.262]             }
[11:01:20.262]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.262]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.262]         }
[11:01:20.262]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.262]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.262]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.262]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.262]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.262]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.262]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.262]             base::names(...future.oldOptions))
[11:01:20.262]     }
[11:01:20.262]     if (FALSE) {
[11:01:20.262]     }
[11:01:20.262]     else {
[11:01:20.262]         if (TRUE) {
[11:01:20.262]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.262]                 open = "w")
[11:01:20.262]         }
[11:01:20.262]         else {
[11:01:20.262]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.262]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.262]         }
[11:01:20.262]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.262]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.262]             base::sink(type = "output", split = FALSE)
[11:01:20.262]             base::close(...future.stdout)
[11:01:20.262]         }, add = TRUE)
[11:01:20.262]     }
[11:01:20.262]     ...future.frame <- base::sys.nframe()
[11:01:20.262]     ...future.conditions <- base::list()
[11:01:20.262]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.262]     if (FALSE) {
[11:01:20.262]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.262]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.262]     }
[11:01:20.262]     ...future.result <- base::tryCatch({
[11:01:20.262]         base::withCallingHandlers({
[11:01:20.262]             ...future.value <- base::withVisible(base::local({
[11:01:20.262]                 withCallingHandlers({
[11:01:20.262]                   {
[11:01:20.262]                     if (ii%%2 == 0) 
[11:01:20.262]                       stop("Woops!")
[11:01:20.262]                     ii
[11:01:20.262]                   }
[11:01:20.262]                 }, immediateCondition = function(cond) {
[11:01:20.262]                   save_rds <- function (object, pathname, ...) 
[11:01:20.262]                   {
[11:01:20.262]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:20.262]                     if (file_test("-f", pathname_tmp)) {
[11:01:20.262]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.262]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:20.262]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.262]                         fi_tmp[["mtime"]])
[11:01:20.262]                     }
[11:01:20.262]                     tryCatch({
[11:01:20.262]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:20.262]                     }, error = function(ex) {
[11:01:20.262]                       msg <- conditionMessage(ex)
[11:01:20.262]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.262]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:20.262]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.262]                         fi_tmp[["mtime"]], msg)
[11:01:20.262]                       ex$message <- msg
[11:01:20.262]                       stop(ex)
[11:01:20.262]                     })
[11:01:20.262]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:20.262]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:20.262]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:20.262]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.262]                       fi <- file.info(pathname)
[11:01:20.262]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:20.262]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.262]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:20.262]                         fi[["size"]], fi[["mtime"]])
[11:01:20.262]                       stop(msg)
[11:01:20.262]                     }
[11:01:20.262]                     invisible(pathname)
[11:01:20.262]                   }
[11:01:20.262]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:20.262]                     rootPath = tempdir()) 
[11:01:20.262]                   {
[11:01:20.262]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:20.262]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:20.262]                       tmpdir = path, fileext = ".rds")
[11:01:20.262]                     save_rds(obj, file)
[11:01:20.262]                   }
[11:01:20.262]                   saveImmediateCondition(cond, path = "/tmp/RtmpxWUrEc/.future/immediateConditions")
[11:01:20.262]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.262]                   {
[11:01:20.262]                     inherits <- base::inherits
[11:01:20.262]                     invokeRestart <- base::invokeRestart
[11:01:20.262]                     is.null <- base::is.null
[11:01:20.262]                     muffled <- FALSE
[11:01:20.262]                     if (inherits(cond, "message")) {
[11:01:20.262]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:20.262]                       if (muffled) 
[11:01:20.262]                         invokeRestart("muffleMessage")
[11:01:20.262]                     }
[11:01:20.262]                     else if (inherits(cond, "warning")) {
[11:01:20.262]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:20.262]                       if (muffled) 
[11:01:20.262]                         invokeRestart("muffleWarning")
[11:01:20.262]                     }
[11:01:20.262]                     else if (inherits(cond, "condition")) {
[11:01:20.262]                       if (!is.null(pattern)) {
[11:01:20.262]                         computeRestarts <- base::computeRestarts
[11:01:20.262]                         grepl <- base::grepl
[11:01:20.262]                         restarts <- computeRestarts(cond)
[11:01:20.262]                         for (restart in restarts) {
[11:01:20.262]                           name <- restart$name
[11:01:20.262]                           if (is.null(name)) 
[11:01:20.262]                             next
[11:01:20.262]                           if (!grepl(pattern, name)) 
[11:01:20.262]                             next
[11:01:20.262]                           invokeRestart(restart)
[11:01:20.262]                           muffled <- TRUE
[11:01:20.262]                           break
[11:01:20.262]                         }
[11:01:20.262]                       }
[11:01:20.262]                     }
[11:01:20.262]                     invisible(muffled)
[11:01:20.262]                   }
[11:01:20.262]                   muffleCondition(cond)
[11:01:20.262]                 })
[11:01:20.262]             }))
[11:01:20.262]             future::FutureResult(value = ...future.value$value, 
[11:01:20.262]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.262]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.262]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.262]                     ...future.globalenv.names))
[11:01:20.262]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.262]         }, condition = base::local({
[11:01:20.262]             c <- base::c
[11:01:20.262]             inherits <- base::inherits
[11:01:20.262]             invokeRestart <- base::invokeRestart
[11:01:20.262]             length <- base::length
[11:01:20.262]             list <- base::list
[11:01:20.262]             seq.int <- base::seq.int
[11:01:20.262]             signalCondition <- base::signalCondition
[11:01:20.262]             sys.calls <- base::sys.calls
[11:01:20.262]             `[[` <- base::`[[`
[11:01:20.262]             `+` <- base::`+`
[11:01:20.262]             `<<-` <- base::`<<-`
[11:01:20.262]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.262]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.262]                   3L)]
[11:01:20.262]             }
[11:01:20.262]             function(cond) {
[11:01:20.262]                 is_error <- inherits(cond, "error")
[11:01:20.262]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.262]                   NULL)
[11:01:20.262]                 if (is_error) {
[11:01:20.262]                   sessionInformation <- function() {
[11:01:20.262]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.262]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.262]                       search = base::search(), system = base::Sys.info())
[11:01:20.262]                   }
[11:01:20.262]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.262]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.262]                     cond$call), session = sessionInformation(), 
[11:01:20.262]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.262]                   signalCondition(cond)
[11:01:20.262]                 }
[11:01:20.262]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.262]                 "immediateCondition"))) {
[11:01:20.262]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.262]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.262]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.262]                   if (TRUE && !signal) {
[11:01:20.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.262]                     {
[11:01:20.262]                       inherits <- base::inherits
[11:01:20.262]                       invokeRestart <- base::invokeRestart
[11:01:20.262]                       is.null <- base::is.null
[11:01:20.262]                       muffled <- FALSE
[11:01:20.262]                       if (inherits(cond, "message")) {
[11:01:20.262]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.262]                         if (muffled) 
[11:01:20.262]                           invokeRestart("muffleMessage")
[11:01:20.262]                       }
[11:01:20.262]                       else if (inherits(cond, "warning")) {
[11:01:20.262]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.262]                         if (muffled) 
[11:01:20.262]                           invokeRestart("muffleWarning")
[11:01:20.262]                       }
[11:01:20.262]                       else if (inherits(cond, "condition")) {
[11:01:20.262]                         if (!is.null(pattern)) {
[11:01:20.262]                           computeRestarts <- base::computeRestarts
[11:01:20.262]                           grepl <- base::grepl
[11:01:20.262]                           restarts <- computeRestarts(cond)
[11:01:20.262]                           for (restart in restarts) {
[11:01:20.262]                             name <- restart$name
[11:01:20.262]                             if (is.null(name)) 
[11:01:20.262]                               next
[11:01:20.262]                             if (!grepl(pattern, name)) 
[11:01:20.262]                               next
[11:01:20.262]                             invokeRestart(restart)
[11:01:20.262]                             muffled <- TRUE
[11:01:20.262]                             break
[11:01:20.262]                           }
[11:01:20.262]                         }
[11:01:20.262]                       }
[11:01:20.262]                       invisible(muffled)
[11:01:20.262]                     }
[11:01:20.262]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.262]                   }
[11:01:20.262]                 }
[11:01:20.262]                 else {
[11:01:20.262]                   if (TRUE) {
[11:01:20.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.262]                     {
[11:01:20.262]                       inherits <- base::inherits
[11:01:20.262]                       invokeRestart <- base::invokeRestart
[11:01:20.262]                       is.null <- base::is.null
[11:01:20.262]                       muffled <- FALSE
[11:01:20.262]                       if (inherits(cond, "message")) {
[11:01:20.262]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.262]                         if (muffled) 
[11:01:20.262]                           invokeRestart("muffleMessage")
[11:01:20.262]                       }
[11:01:20.262]                       else if (inherits(cond, "warning")) {
[11:01:20.262]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.262]                         if (muffled) 
[11:01:20.262]                           invokeRestart("muffleWarning")
[11:01:20.262]                       }
[11:01:20.262]                       else if (inherits(cond, "condition")) {
[11:01:20.262]                         if (!is.null(pattern)) {
[11:01:20.262]                           computeRestarts <- base::computeRestarts
[11:01:20.262]                           grepl <- base::grepl
[11:01:20.262]                           restarts <- computeRestarts(cond)
[11:01:20.262]                           for (restart in restarts) {
[11:01:20.262]                             name <- restart$name
[11:01:20.262]                             if (is.null(name)) 
[11:01:20.262]                               next
[11:01:20.262]                             if (!grepl(pattern, name)) 
[11:01:20.262]                               next
[11:01:20.262]                             invokeRestart(restart)
[11:01:20.262]                             muffled <- TRUE
[11:01:20.262]                             break
[11:01:20.262]                           }
[11:01:20.262]                         }
[11:01:20.262]                       }
[11:01:20.262]                       invisible(muffled)
[11:01:20.262]                     }
[11:01:20.262]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.262]                   }
[11:01:20.262]                 }
[11:01:20.262]             }
[11:01:20.262]         }))
[11:01:20.262]     }, error = function(ex) {
[11:01:20.262]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.262]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.262]                 ...future.rng), started = ...future.startTime, 
[11:01:20.262]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.262]             version = "1.8"), class = "FutureResult")
[11:01:20.262]     }, finally = {
[11:01:20.262]         if (!identical(...future.workdir, getwd())) 
[11:01:20.262]             setwd(...future.workdir)
[11:01:20.262]         {
[11:01:20.262]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.262]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.262]             }
[11:01:20.262]             base::options(...future.oldOptions)
[11:01:20.262]             if (.Platform$OS.type == "windows") {
[11:01:20.262]                 old_names <- names(...future.oldEnvVars)
[11:01:20.262]                 envs <- base::Sys.getenv()
[11:01:20.262]                 names <- names(envs)
[11:01:20.262]                 common <- intersect(names, old_names)
[11:01:20.262]                 added <- setdiff(names, old_names)
[11:01:20.262]                 removed <- setdiff(old_names, names)
[11:01:20.262]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.262]                   envs[common]]
[11:01:20.262]                 NAMES <- toupper(changed)
[11:01:20.262]                 args <- list()
[11:01:20.262]                 for (kk in seq_along(NAMES)) {
[11:01:20.262]                   name <- changed[[kk]]
[11:01:20.262]                   NAME <- NAMES[[kk]]
[11:01:20.262]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.262]                     next
[11:01:20.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.262]                 }
[11:01:20.262]                 NAMES <- toupper(added)
[11:01:20.262]                 for (kk in seq_along(NAMES)) {
[11:01:20.262]                   name <- added[[kk]]
[11:01:20.262]                   NAME <- NAMES[[kk]]
[11:01:20.262]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.262]                     next
[11:01:20.262]                   args[[name]] <- ""
[11:01:20.262]                 }
[11:01:20.262]                 NAMES <- toupper(removed)
[11:01:20.262]                 for (kk in seq_along(NAMES)) {
[11:01:20.262]                   name <- removed[[kk]]
[11:01:20.262]                   NAME <- NAMES[[kk]]
[11:01:20.262]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.262]                     next
[11:01:20.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.262]                 }
[11:01:20.262]                 if (length(args) > 0) 
[11:01:20.262]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.262]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.262]             }
[11:01:20.262]             else {
[11:01:20.262]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.262]             }
[11:01:20.262]             {
[11:01:20.262]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.262]                   0L) {
[11:01:20.262]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.262]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.262]                   base::options(opts)
[11:01:20.262]                 }
[11:01:20.262]                 {
[11:01:20.262]                   {
[11:01:20.262]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:20.262]                     NULL
[11:01:20.262]                   }
[11:01:20.262]                   options(future.plan = NULL)
[11:01:20.262]                   if (is.na(NA_character_)) 
[11:01:20.262]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.262]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.262]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.262]                     .init = FALSE)
[11:01:20.262]                 }
[11:01:20.262]             }
[11:01:20.262]         }
[11:01:20.262]     })
[11:01:20.262]     if (TRUE) {
[11:01:20.262]         base::sink(type = "output", split = FALSE)
[11:01:20.262]         if (TRUE) {
[11:01:20.262]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.262]         }
[11:01:20.262]         else {
[11:01:20.262]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.262]         }
[11:01:20.262]         base::close(...future.stdout)
[11:01:20.262]         ...future.stdout <- NULL
[11:01:20.262]     }
[11:01:20.262]     ...future.result$conditions <- ...future.conditions
[11:01:20.262]     ...future.result$finished <- base::Sys.time()
[11:01:20.262]     ...future.result
[11:01:20.262] }
[11:01:20.265] assign_globals() ...
[11:01:20.265] List of 1
[11:01:20.265]  $ ii: int 1
[11:01:20.265]  - attr(*, "where")=List of 1
[11:01:20.265]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:20.265]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:20.265]  - attr(*, "resolved")= logi FALSE
[11:01:20.265]  - attr(*, "total_size")= num 35
[11:01:20.265]  - attr(*, "already-done")= logi TRUE
[11:01:20.270] - copied ‘ii’ to environment
[11:01:20.270] assign_globals() ... done
[11:01:20.270] requestCore(): workers = 2
[11:01:20.271] MulticoreFuture started
[11:01:20.272] - Launch lazy future ... done
[11:01:20.272] run() for ‘MulticoreFuture’ ... done
[11:01:20.273] plan(): Setting new future strategy stack:
[11:01:20.273] getGlobalsAndPackages() ...
[11:01:20.273] List of future strategies:
[11:01:20.273] 1. sequential:
[11:01:20.273]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.273]    - tweaked: FALSE
[11:01:20.273]    - call: NULL
[11:01:20.274] Searching for globals...
[11:01:20.274] plan(): nbrOfWorkers() = 1
[11:01:20.276] plan(): Setting new future strategy stack:
[11:01:20.276] List of future strategies:
[11:01:20.276] 1. multicore:
[11:01:20.276]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:20.276]    - tweaked: FALSE
[11:01:20.276]    - call: plan(strategy)
[11:01:20.277] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[11:01:20.278] Searching for globals ... DONE
[11:01:20.278] Resolving globals: FALSE
[11:01:20.279] plan(): nbrOfWorkers() = 2
[11:01:20.279] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:20.279] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:20.280] - globals: [1] ‘ii’
[11:01:20.280] 
[11:01:20.280] getGlobalsAndPackages() ... DONE
[11:01:20.280] run() for ‘Future’ ...
[11:01:20.281] - state: ‘created’
[11:01:20.281] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:20.283] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:20.284] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:20.284]   - Field: ‘label’
[11:01:20.284]   - Field: ‘local’
[11:01:20.284]   - Field: ‘owner’
[11:01:20.284]   - Field: ‘envir’
[11:01:20.284]   - Field: ‘workers’
[11:01:20.285]   - Field: ‘packages’
[11:01:20.285]   - Field: ‘gc’
[11:01:20.285]   - Field: ‘job’
[11:01:20.285]   - Field: ‘conditions’
[11:01:20.285]   - Field: ‘expr’
[11:01:20.285]   - Field: ‘uuid’
[11:01:20.285]   - Field: ‘seed’
[11:01:20.286]   - Field: ‘version’
[11:01:20.286]   - Field: ‘result’
[11:01:20.286]   - Field: ‘asynchronous’
[11:01:20.286]   - Field: ‘calls’
[11:01:20.286]   - Field: ‘globals’
[11:01:20.286]   - Field: ‘stdout’
[11:01:20.286]   - Field: ‘earlySignal’
[11:01:20.287]   - Field: ‘lazy’
[11:01:20.287]   - Field: ‘state’
[11:01:20.287] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:20.287] - Launch lazy future ...
[11:01:20.287] Packages needed by the future expression (n = 0): <none>
[11:01:20.288] Packages needed by future strategies (n = 0): <none>
[11:01:20.288] {
[11:01:20.288]     {
[11:01:20.288]         {
[11:01:20.288]             ...future.startTime <- base::Sys.time()
[11:01:20.288]             {
[11:01:20.288]                 {
[11:01:20.288]                   {
[11:01:20.288]                     {
[11:01:20.288]                       base::local({
[11:01:20.288]                         has_future <- base::requireNamespace("future", 
[11:01:20.288]                           quietly = TRUE)
[11:01:20.288]                         if (has_future) {
[11:01:20.288]                           ns <- base::getNamespace("future")
[11:01:20.288]                           version <- ns[[".package"]][["version"]]
[11:01:20.288]                           if (is.null(version)) 
[11:01:20.288]                             version <- utils::packageVersion("future")
[11:01:20.288]                         }
[11:01:20.288]                         else {
[11:01:20.288]                           version <- NULL
[11:01:20.288]                         }
[11:01:20.288]                         if (!has_future || version < "1.8.0") {
[11:01:20.288]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.288]                             "", base::R.version$version.string), 
[11:01:20.288]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:20.288]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.288]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.288]                               "release", "version")], collapse = " "), 
[11:01:20.288]                             hostname = base::Sys.info()[["nodename"]])
[11:01:20.288]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.288]                             info)
[11:01:20.288]                           info <- base::paste(info, collapse = "; ")
[11:01:20.288]                           if (!has_future) {
[11:01:20.288]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.288]                               info)
[11:01:20.288]                           }
[11:01:20.288]                           else {
[11:01:20.288]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.288]                               info, version)
[11:01:20.288]                           }
[11:01:20.288]                           base::stop(msg)
[11:01:20.288]                         }
[11:01:20.288]                       })
[11:01:20.288]                     }
[11:01:20.288]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:20.288]                     base::options(mc.cores = 1L)
[11:01:20.288]                   }
[11:01:20.288]                   ...future.strategy.old <- future::plan("list")
[11:01:20.288]                   options(future.plan = NULL)
[11:01:20.288]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.288]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.288]                 }
[11:01:20.288]                 ...future.workdir <- getwd()
[11:01:20.288]             }
[11:01:20.288]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.288]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.288]         }
[11:01:20.288]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.288]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.288]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.288]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.288]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.288]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.288]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.288]             base::names(...future.oldOptions))
[11:01:20.288]     }
[11:01:20.288]     if (FALSE) {
[11:01:20.288]     }
[11:01:20.288]     else {
[11:01:20.288]         if (TRUE) {
[11:01:20.288]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.288]                 open = "w")
[11:01:20.288]         }
[11:01:20.288]         else {
[11:01:20.288]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.288]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.288]         }
[11:01:20.288]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.288]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.288]             base::sink(type = "output", split = FALSE)
[11:01:20.288]             base::close(...future.stdout)
[11:01:20.288]         }, add = TRUE)
[11:01:20.288]     }
[11:01:20.288]     ...future.frame <- base::sys.nframe()
[11:01:20.288]     ...future.conditions <- base::list()
[11:01:20.288]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.288]     if (FALSE) {
[11:01:20.288]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.288]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.288]     }
[11:01:20.288]     ...future.result <- base::tryCatch({
[11:01:20.288]         base::withCallingHandlers({
[11:01:20.288]             ...future.value <- base::withVisible(base::local({
[11:01:20.288]                 withCallingHandlers({
[11:01:20.288]                   {
[11:01:20.288]                     if (ii%%2 == 0) 
[11:01:20.288]                       stop("Woops!")
[11:01:20.288]                     ii
[11:01:20.288]                   }
[11:01:20.288]                 }, immediateCondition = function(cond) {
[11:01:20.288]                   save_rds <- function (object, pathname, ...) 
[11:01:20.288]                   {
[11:01:20.288]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:20.288]                     if (file_test("-f", pathname_tmp)) {
[11:01:20.288]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.288]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:20.288]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.288]                         fi_tmp[["mtime"]])
[11:01:20.288]                     }
[11:01:20.288]                     tryCatch({
[11:01:20.288]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:20.288]                     }, error = function(ex) {
[11:01:20.288]                       msg <- conditionMessage(ex)
[11:01:20.288]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.288]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:20.288]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.288]                         fi_tmp[["mtime"]], msg)
[11:01:20.288]                       ex$message <- msg
[11:01:20.288]                       stop(ex)
[11:01:20.288]                     })
[11:01:20.288]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:20.288]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:20.288]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:20.288]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.288]                       fi <- file.info(pathname)
[11:01:20.288]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:20.288]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.288]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:20.288]                         fi[["size"]], fi[["mtime"]])
[11:01:20.288]                       stop(msg)
[11:01:20.288]                     }
[11:01:20.288]                     invisible(pathname)
[11:01:20.288]                   }
[11:01:20.288]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:20.288]                     rootPath = tempdir()) 
[11:01:20.288]                   {
[11:01:20.288]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:20.288]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:20.288]                       tmpdir = path, fileext = ".rds")
[11:01:20.288]                     save_rds(obj, file)
[11:01:20.288]                   }
[11:01:20.288]                   saveImmediateCondition(cond, path = "/tmp/RtmpxWUrEc/.future/immediateConditions")
[11:01:20.288]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.288]                   {
[11:01:20.288]                     inherits <- base::inherits
[11:01:20.288]                     invokeRestart <- base::invokeRestart
[11:01:20.288]                     is.null <- base::is.null
[11:01:20.288]                     muffled <- FALSE
[11:01:20.288]                     if (inherits(cond, "message")) {
[11:01:20.288]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:20.288]                       if (muffled) 
[11:01:20.288]                         invokeRestart("muffleMessage")
[11:01:20.288]                     }
[11:01:20.288]                     else if (inherits(cond, "warning")) {
[11:01:20.288]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:20.288]                       if (muffled) 
[11:01:20.288]                         invokeRestart("muffleWarning")
[11:01:20.288]                     }
[11:01:20.288]                     else if (inherits(cond, "condition")) {
[11:01:20.288]                       if (!is.null(pattern)) {
[11:01:20.288]                         computeRestarts <- base::computeRestarts
[11:01:20.288]                         grepl <- base::grepl
[11:01:20.288]                         restarts <- computeRestarts(cond)
[11:01:20.288]                         for (restart in restarts) {
[11:01:20.288]                           name <- restart$name
[11:01:20.288]                           if (is.null(name)) 
[11:01:20.288]                             next
[11:01:20.288]                           if (!grepl(pattern, name)) 
[11:01:20.288]                             next
[11:01:20.288]                           invokeRestart(restart)
[11:01:20.288]                           muffled <- TRUE
[11:01:20.288]                           break
[11:01:20.288]                         }
[11:01:20.288]                       }
[11:01:20.288]                     }
[11:01:20.288]                     invisible(muffled)
[11:01:20.288]                   }
[11:01:20.288]                   muffleCondition(cond)
[11:01:20.288]                 })
[11:01:20.288]             }))
[11:01:20.288]             future::FutureResult(value = ...future.value$value, 
[11:01:20.288]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.288]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.288]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.288]                     ...future.globalenv.names))
[11:01:20.288]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.288]         }, condition = base::local({
[11:01:20.288]             c <- base::c
[11:01:20.288]             inherits <- base::inherits
[11:01:20.288]             invokeRestart <- base::invokeRestart
[11:01:20.288]             length <- base::length
[11:01:20.288]             list <- base::list
[11:01:20.288]             seq.int <- base::seq.int
[11:01:20.288]             signalCondition <- base::signalCondition
[11:01:20.288]             sys.calls <- base::sys.calls
[11:01:20.288]             `[[` <- base::`[[`
[11:01:20.288]             `+` <- base::`+`
[11:01:20.288]             `<<-` <- base::`<<-`
[11:01:20.288]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.288]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.288]                   3L)]
[11:01:20.288]             }
[11:01:20.288]             function(cond) {
[11:01:20.288]                 is_error <- inherits(cond, "error")
[11:01:20.288]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.288]                   NULL)
[11:01:20.288]                 if (is_error) {
[11:01:20.288]                   sessionInformation <- function() {
[11:01:20.288]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.288]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.288]                       search = base::search(), system = base::Sys.info())
[11:01:20.288]                   }
[11:01:20.288]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.288]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.288]                     cond$call), session = sessionInformation(), 
[11:01:20.288]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.288]                   signalCondition(cond)
[11:01:20.288]                 }
[11:01:20.288]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.288]                 "immediateCondition"))) {
[11:01:20.288]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.288]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.288]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.288]                   if (TRUE && !signal) {
[11:01:20.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.288]                     {
[11:01:20.288]                       inherits <- base::inherits
[11:01:20.288]                       invokeRestart <- base::invokeRestart
[11:01:20.288]                       is.null <- base::is.null
[11:01:20.288]                       muffled <- FALSE
[11:01:20.288]                       if (inherits(cond, "message")) {
[11:01:20.288]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.288]                         if (muffled) 
[11:01:20.288]                           invokeRestart("muffleMessage")
[11:01:20.288]                       }
[11:01:20.288]                       else if (inherits(cond, "warning")) {
[11:01:20.288]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.288]                         if (muffled) 
[11:01:20.288]                           invokeRestart("muffleWarning")
[11:01:20.288]                       }
[11:01:20.288]                       else if (inherits(cond, "condition")) {
[11:01:20.288]                         if (!is.null(pattern)) {
[11:01:20.288]                           computeRestarts <- base::computeRestarts
[11:01:20.288]                           grepl <- base::grepl
[11:01:20.288]                           restarts <- computeRestarts(cond)
[11:01:20.288]                           for (restart in restarts) {
[11:01:20.288]                             name <- restart$name
[11:01:20.288]                             if (is.null(name)) 
[11:01:20.288]                               next
[11:01:20.288]                             if (!grepl(pattern, name)) 
[11:01:20.288]                               next
[11:01:20.288]                             invokeRestart(restart)
[11:01:20.288]                             muffled <- TRUE
[11:01:20.288]                             break
[11:01:20.288]                           }
[11:01:20.288]                         }
[11:01:20.288]                       }
[11:01:20.288]                       invisible(muffled)
[11:01:20.288]                     }
[11:01:20.288]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.288]                   }
[11:01:20.288]                 }
[11:01:20.288]                 else {
[11:01:20.288]                   if (TRUE) {
[11:01:20.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.288]                     {
[11:01:20.288]                       inherits <- base::inherits
[11:01:20.288]                       invokeRestart <- base::invokeRestart
[11:01:20.288]                       is.null <- base::is.null
[11:01:20.288]                       muffled <- FALSE
[11:01:20.288]                       if (inherits(cond, "message")) {
[11:01:20.288]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.288]                         if (muffled) 
[11:01:20.288]                           invokeRestart("muffleMessage")
[11:01:20.288]                       }
[11:01:20.288]                       else if (inherits(cond, "warning")) {
[11:01:20.288]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.288]                         if (muffled) 
[11:01:20.288]                           invokeRestart("muffleWarning")
[11:01:20.288]                       }
[11:01:20.288]                       else if (inherits(cond, "condition")) {
[11:01:20.288]                         if (!is.null(pattern)) {
[11:01:20.288]                           computeRestarts <- base::computeRestarts
[11:01:20.288]                           grepl <- base::grepl
[11:01:20.288]                           restarts <- computeRestarts(cond)
[11:01:20.288]                           for (restart in restarts) {
[11:01:20.288]                             name <- restart$name
[11:01:20.288]                             if (is.null(name)) 
[11:01:20.288]                               next
[11:01:20.288]                             if (!grepl(pattern, name)) 
[11:01:20.288]                               next
[11:01:20.288]                             invokeRestart(restart)
[11:01:20.288]                             muffled <- TRUE
[11:01:20.288]                             break
[11:01:20.288]                           }
[11:01:20.288]                         }
[11:01:20.288]                       }
[11:01:20.288]                       invisible(muffled)
[11:01:20.288]                     }
[11:01:20.288]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.288]                   }
[11:01:20.288]                 }
[11:01:20.288]             }
[11:01:20.288]         }))
[11:01:20.288]     }, error = function(ex) {
[11:01:20.288]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.288]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.288]                 ...future.rng), started = ...future.startTime, 
[11:01:20.288]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.288]             version = "1.8"), class = "FutureResult")
[11:01:20.288]     }, finally = {
[11:01:20.288]         if (!identical(...future.workdir, getwd())) 
[11:01:20.288]             setwd(...future.workdir)
[11:01:20.288]         {
[11:01:20.288]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.288]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.288]             }
[11:01:20.288]             base::options(...future.oldOptions)
[11:01:20.288]             if (.Platform$OS.type == "windows") {
[11:01:20.288]                 old_names <- names(...future.oldEnvVars)
[11:01:20.288]                 envs <- base::Sys.getenv()
[11:01:20.288]                 names <- names(envs)
[11:01:20.288]                 common <- intersect(names, old_names)
[11:01:20.288]                 added <- setdiff(names, old_names)
[11:01:20.288]                 removed <- setdiff(old_names, names)
[11:01:20.288]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.288]                   envs[common]]
[11:01:20.288]                 NAMES <- toupper(changed)
[11:01:20.288]                 args <- list()
[11:01:20.288]                 for (kk in seq_along(NAMES)) {
[11:01:20.288]                   name <- changed[[kk]]
[11:01:20.288]                   NAME <- NAMES[[kk]]
[11:01:20.288]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.288]                     next
[11:01:20.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.288]                 }
[11:01:20.288]                 NAMES <- toupper(added)
[11:01:20.288]                 for (kk in seq_along(NAMES)) {
[11:01:20.288]                   name <- added[[kk]]
[11:01:20.288]                   NAME <- NAMES[[kk]]
[11:01:20.288]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.288]                     next
[11:01:20.288]                   args[[name]] <- ""
[11:01:20.288]                 }
[11:01:20.288]                 NAMES <- toupper(removed)
[11:01:20.288]                 for (kk in seq_along(NAMES)) {
[11:01:20.288]                   name <- removed[[kk]]
[11:01:20.288]                   NAME <- NAMES[[kk]]
[11:01:20.288]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.288]                     next
[11:01:20.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.288]                 }
[11:01:20.288]                 if (length(args) > 0) 
[11:01:20.288]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.288]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.288]             }
[11:01:20.288]             else {
[11:01:20.288]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.288]             }
[11:01:20.288]             {
[11:01:20.288]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.288]                   0L) {
[11:01:20.288]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.288]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.288]                   base::options(opts)
[11:01:20.288]                 }
[11:01:20.288]                 {
[11:01:20.288]                   {
[11:01:20.288]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:20.288]                     NULL
[11:01:20.288]                   }
[11:01:20.288]                   options(future.plan = NULL)
[11:01:20.288]                   if (is.na(NA_character_)) 
[11:01:20.288]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.288]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.288]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.288]                     .init = FALSE)
[11:01:20.288]                 }
[11:01:20.288]             }
[11:01:20.288]         }
[11:01:20.288]     })
[11:01:20.288]     if (TRUE) {
[11:01:20.288]         base::sink(type = "output", split = FALSE)
[11:01:20.288]         if (TRUE) {
[11:01:20.288]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.288]         }
[11:01:20.288]         else {
[11:01:20.288]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.288]         }
[11:01:20.288]         base::close(...future.stdout)
[11:01:20.288]         ...future.stdout <- NULL
[11:01:20.288]     }
[11:01:20.288]     ...future.result$conditions <- ...future.conditions
[11:01:20.288]     ...future.result$finished <- base::Sys.time()
[11:01:20.288]     ...future.result
[11:01:20.288] }
[11:01:20.291] assign_globals() ...
[11:01:20.291] List of 1
[11:01:20.291]  $ ii: int 2
[11:01:20.291]  - attr(*, "where")=List of 1
[11:01:20.291]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:20.291]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:20.291]  - attr(*, "resolved")= logi FALSE
[11:01:20.291]  - attr(*, "total_size")= num 35
[11:01:20.291]  - attr(*, "already-done")= logi TRUE
[11:01:20.295] - copied ‘ii’ to environment
[11:01:20.295] assign_globals() ... done
[11:01:20.295] requestCore(): workers = 2
[11:01:20.297] MulticoreFuture started
[11:01:20.298] - Launch lazy future ... done
[11:01:20.298] run() for ‘MulticoreFuture’ ... done
[11:01:20.299] plan(): Setting new future strategy stack:
[11:01:20.299] getGlobalsAndPackages() ...
[11:01:20.299] Searching for globals...
[11:01:20.299] List of future strategies:
[11:01:20.299] 1. sequential:
[11:01:20.299]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.299]    - tweaked: FALSE
[11:01:20.299]    - call: NULL
[11:01:20.300] plan(): nbrOfWorkers() = 1
[11:01:20.302] plan(): Setting new future strategy stack:
[11:01:20.302] List of future strategies:
[11:01:20.302] 1. multicore:
[11:01:20.302]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:20.302]    - tweaked: FALSE
[11:01:20.302]    - call: plan(strategy)
[11:01:20.302] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[11:01:20.303] Searching for globals ... DONE
[11:01:20.303] Resolving globals: FALSE
[11:01:20.304] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:20.305] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:20.305] - globals: [1] ‘ii’
[11:01:20.305] 
[11:01:20.305] getGlobalsAndPackages() ... DONE
[11:01:20.306] plan(): nbrOfWorkers() = 2
[11:01:20.306] run() for ‘Future’ ...
[11:01:20.306] - state: ‘created’
[11:01:20.306] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:20.310] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:20.310] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:20.310]   - Field: ‘label’
[11:01:20.310]   - Field: ‘local’
[11:01:20.310]   - Field: ‘owner’
[11:01:20.310]   - Field: ‘envir’
[11:01:20.311]   - Field: ‘workers’
[11:01:20.311]   - Field: ‘packages’
[11:01:20.311]   - Field: ‘gc’
[11:01:20.311]   - Field: ‘job’
[11:01:20.311]   - Field: ‘conditions’
[11:01:20.311]   - Field: ‘expr’
[11:01:20.311]   - Field: ‘uuid’
[11:01:20.311]   - Field: ‘seed’
[11:01:20.312]   - Field: ‘version’
[11:01:20.312]   - Field: ‘result’
[11:01:20.312]   - Field: ‘asynchronous’
[11:01:20.312]   - Field: ‘calls’
[11:01:20.312]   - Field: ‘globals’
[11:01:20.312]   - Field: ‘stdout’
[11:01:20.312]   - Field: ‘earlySignal’
[11:01:20.313]   - Field: ‘lazy’
[11:01:20.313]   - Field: ‘state’
[11:01:20.313] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:20.313] - Launch lazy future ...
[11:01:20.313] Packages needed by the future expression (n = 0): <none>
[11:01:20.314] Packages needed by future strategies (n = 0): <none>
[11:01:20.317] {
[11:01:20.317]     {
[11:01:20.317]         {
[11:01:20.317]             ...future.startTime <- base::Sys.time()
[11:01:20.317]             {
[11:01:20.317]                 {
[11:01:20.317]                   {
[11:01:20.317]                     {
[11:01:20.317]                       base::local({
[11:01:20.317]                         has_future <- base::requireNamespace("future", 
[11:01:20.317]                           quietly = TRUE)
[11:01:20.317]                         if (has_future) {
[11:01:20.317]                           ns <- base::getNamespace("future")
[11:01:20.317]                           version <- ns[[".package"]][["version"]]
[11:01:20.317]                           if (is.null(version)) 
[11:01:20.317]                             version <- utils::packageVersion("future")
[11:01:20.317]                         }
[11:01:20.317]                         else {
[11:01:20.317]                           version <- NULL
[11:01:20.317]                         }
[11:01:20.317]                         if (!has_future || version < "1.8.0") {
[11:01:20.317]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.317]                             "", base::R.version$version.string), 
[11:01:20.317]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:20.317]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.317]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.317]                               "release", "version")], collapse = " "), 
[11:01:20.317]                             hostname = base::Sys.info()[["nodename"]])
[11:01:20.317]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.317]                             info)
[11:01:20.317]                           info <- base::paste(info, collapse = "; ")
[11:01:20.317]                           if (!has_future) {
[11:01:20.317]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.317]                               info)
[11:01:20.317]                           }
[11:01:20.317]                           else {
[11:01:20.317]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.317]                               info, version)
[11:01:20.317]                           }
[11:01:20.317]                           base::stop(msg)
[11:01:20.317]                         }
[11:01:20.317]                       })
[11:01:20.317]                     }
[11:01:20.317]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:20.317]                     base::options(mc.cores = 1L)
[11:01:20.317]                   }
[11:01:20.317]                   ...future.strategy.old <- future::plan("list")
[11:01:20.317]                   options(future.plan = NULL)
[11:01:20.317]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.317]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.317]                 }
[11:01:20.317]                 ...future.workdir <- getwd()
[11:01:20.317]             }
[11:01:20.317]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.317]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.317]         }
[11:01:20.317]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.317]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.317]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.317]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.317]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.317]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.317]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.317]             base::names(...future.oldOptions))
[11:01:20.317]     }
[11:01:20.317]     if (FALSE) {
[11:01:20.317]     }
[11:01:20.317]     else {
[11:01:20.317]         if (TRUE) {
[11:01:20.317]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.317]                 open = "w")
[11:01:20.317]         }
[11:01:20.317]         else {
[11:01:20.317]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.317]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.317]         }
[11:01:20.317]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.317]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.317]             base::sink(type = "output", split = FALSE)
[11:01:20.317]             base::close(...future.stdout)
[11:01:20.317]         }, add = TRUE)
[11:01:20.317]     }
[11:01:20.317]     ...future.frame <- base::sys.nframe()
[11:01:20.317]     ...future.conditions <- base::list()
[11:01:20.317]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.317]     if (FALSE) {
[11:01:20.317]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.317]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.317]     }
[11:01:20.317]     ...future.result <- base::tryCatch({
[11:01:20.317]         base::withCallingHandlers({
[11:01:20.317]             ...future.value <- base::withVisible(base::local({
[11:01:20.317]                 withCallingHandlers({
[11:01:20.317]                   {
[11:01:20.317]                     if (ii%%2 == 0) 
[11:01:20.317]                       stop("Woops!")
[11:01:20.317]                     ii
[11:01:20.317]                   }
[11:01:20.317]                 }, immediateCondition = function(cond) {
[11:01:20.317]                   save_rds <- function (object, pathname, ...) 
[11:01:20.317]                   {
[11:01:20.317]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:20.317]                     if (file_test("-f", pathname_tmp)) {
[11:01:20.317]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.317]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:20.317]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.317]                         fi_tmp[["mtime"]])
[11:01:20.317]                     }
[11:01:20.317]                     tryCatch({
[11:01:20.317]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:20.317]                     }, error = function(ex) {
[11:01:20.317]                       msg <- conditionMessage(ex)
[11:01:20.317]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.317]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:20.317]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.317]                         fi_tmp[["mtime"]], msg)
[11:01:20.317]                       ex$message <- msg
[11:01:20.317]                       stop(ex)
[11:01:20.317]                     })
[11:01:20.317]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:20.317]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:20.317]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:20.317]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.317]                       fi <- file.info(pathname)
[11:01:20.317]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:20.317]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.317]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:20.317]                         fi[["size"]], fi[["mtime"]])
[11:01:20.317]                       stop(msg)
[11:01:20.317]                     }
[11:01:20.317]                     invisible(pathname)
[11:01:20.317]                   }
[11:01:20.317]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:20.317]                     rootPath = tempdir()) 
[11:01:20.317]                   {
[11:01:20.317]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:20.317]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:20.317]                       tmpdir = path, fileext = ".rds")
[11:01:20.317]                     save_rds(obj, file)
[11:01:20.317]                   }
[11:01:20.317]                   saveImmediateCondition(cond, path = "/tmp/RtmpxWUrEc/.future/immediateConditions")
[11:01:20.317]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.317]                   {
[11:01:20.317]                     inherits <- base::inherits
[11:01:20.317]                     invokeRestart <- base::invokeRestart
[11:01:20.317]                     is.null <- base::is.null
[11:01:20.317]                     muffled <- FALSE
[11:01:20.317]                     if (inherits(cond, "message")) {
[11:01:20.317]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:20.317]                       if (muffled) 
[11:01:20.317]                         invokeRestart("muffleMessage")
[11:01:20.317]                     }
[11:01:20.317]                     else if (inherits(cond, "warning")) {
[11:01:20.317]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:20.317]                       if (muffled) 
[11:01:20.317]                         invokeRestart("muffleWarning")
[11:01:20.317]                     }
[11:01:20.317]                     else if (inherits(cond, "condition")) {
[11:01:20.317]                       if (!is.null(pattern)) {
[11:01:20.317]                         computeRestarts <- base::computeRestarts
[11:01:20.317]                         grepl <- base::grepl
[11:01:20.317]                         restarts <- computeRestarts(cond)
[11:01:20.317]                         for (restart in restarts) {
[11:01:20.317]                           name <- restart$name
[11:01:20.317]                           if (is.null(name)) 
[11:01:20.317]                             next
[11:01:20.317]                           if (!grepl(pattern, name)) 
[11:01:20.317]                             next
[11:01:20.317]                           invokeRestart(restart)
[11:01:20.317]                           muffled <- TRUE
[11:01:20.317]                           break
[11:01:20.317]                         }
[11:01:20.317]                       }
[11:01:20.317]                     }
[11:01:20.317]                     invisible(muffled)
[11:01:20.317]                   }
[11:01:20.317]                   muffleCondition(cond)
[11:01:20.317]                 })
[11:01:20.317]             }))
[11:01:20.317]             future::FutureResult(value = ...future.value$value, 
[11:01:20.317]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.317]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.317]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.317]                     ...future.globalenv.names))
[11:01:20.317]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.317]         }, condition = base::local({
[11:01:20.317]             c <- base::c
[11:01:20.317]             inherits <- base::inherits
[11:01:20.317]             invokeRestart <- base::invokeRestart
[11:01:20.317]             length <- base::length
[11:01:20.317]             list <- base::list
[11:01:20.317]             seq.int <- base::seq.int
[11:01:20.317]             signalCondition <- base::signalCondition
[11:01:20.317]             sys.calls <- base::sys.calls
[11:01:20.317]             `[[` <- base::`[[`
[11:01:20.317]             `+` <- base::`+`
[11:01:20.317]             `<<-` <- base::`<<-`
[11:01:20.317]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.317]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.317]                   3L)]
[11:01:20.317]             }
[11:01:20.317]             function(cond) {
[11:01:20.317]                 is_error <- inherits(cond, "error")
[11:01:20.317]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.317]                   NULL)
[11:01:20.317]                 if (is_error) {
[11:01:20.317]                   sessionInformation <- function() {
[11:01:20.317]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.317]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.317]                       search = base::search(), system = base::Sys.info())
[11:01:20.317]                   }
[11:01:20.317]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.317]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.317]                     cond$call), session = sessionInformation(), 
[11:01:20.317]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.317]                   signalCondition(cond)
[11:01:20.317]                 }
[11:01:20.317]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.317]                 "immediateCondition"))) {
[11:01:20.317]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.317]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.317]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.317]                   if (TRUE && !signal) {
[11:01:20.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.317]                     {
[11:01:20.317]                       inherits <- base::inherits
[11:01:20.317]                       invokeRestart <- base::invokeRestart
[11:01:20.317]                       is.null <- base::is.null
[11:01:20.317]                       muffled <- FALSE
[11:01:20.317]                       if (inherits(cond, "message")) {
[11:01:20.317]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.317]                         if (muffled) 
[11:01:20.317]                           invokeRestart("muffleMessage")
[11:01:20.317]                       }
[11:01:20.317]                       else if (inherits(cond, "warning")) {
[11:01:20.317]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.317]                         if (muffled) 
[11:01:20.317]                           invokeRestart("muffleWarning")
[11:01:20.317]                       }
[11:01:20.317]                       else if (inherits(cond, "condition")) {
[11:01:20.317]                         if (!is.null(pattern)) {
[11:01:20.317]                           computeRestarts <- base::computeRestarts
[11:01:20.317]                           grepl <- base::grepl
[11:01:20.317]                           restarts <- computeRestarts(cond)
[11:01:20.317]                           for (restart in restarts) {
[11:01:20.317]                             name <- restart$name
[11:01:20.317]                             if (is.null(name)) 
[11:01:20.317]                               next
[11:01:20.317]                             if (!grepl(pattern, name)) 
[11:01:20.317]                               next
[11:01:20.317]                             invokeRestart(restart)
[11:01:20.317]                             muffled <- TRUE
[11:01:20.317]                             break
[11:01:20.317]                           }
[11:01:20.317]                         }
[11:01:20.317]                       }
[11:01:20.317]                       invisible(muffled)
[11:01:20.317]                     }
[11:01:20.317]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.317]                   }
[11:01:20.317]                 }
[11:01:20.317]                 else {
[11:01:20.317]                   if (TRUE) {
[11:01:20.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.317]                     {
[11:01:20.317]                       inherits <- base::inherits
[11:01:20.317]                       invokeRestart <- base::invokeRestart
[11:01:20.317]                       is.null <- base::is.null
[11:01:20.317]                       muffled <- FALSE
[11:01:20.317]                       if (inherits(cond, "message")) {
[11:01:20.317]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.317]                         if (muffled) 
[11:01:20.317]                           invokeRestart("muffleMessage")
[11:01:20.317]                       }
[11:01:20.317]                       else if (inherits(cond, "warning")) {
[11:01:20.317]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.317]                         if (muffled) 
[11:01:20.317]                           invokeRestart("muffleWarning")
[11:01:20.317]                       }
[11:01:20.317]                       else if (inherits(cond, "condition")) {
[11:01:20.317]                         if (!is.null(pattern)) {
[11:01:20.317]                           computeRestarts <- base::computeRestarts
[11:01:20.317]                           grepl <- base::grepl
[11:01:20.317]                           restarts <- computeRestarts(cond)
[11:01:20.317]                           for (restart in restarts) {
[11:01:20.317]                             name <- restart$name
[11:01:20.317]                             if (is.null(name)) 
[11:01:20.317]                               next
[11:01:20.317]                             if (!grepl(pattern, name)) 
[11:01:20.317]                               next
[11:01:20.317]                             invokeRestart(restart)
[11:01:20.317]                             muffled <- TRUE
[11:01:20.317]                             break
[11:01:20.317]                           }
[11:01:20.317]                         }
[11:01:20.317]                       }
[11:01:20.317]                       invisible(muffled)
[11:01:20.317]                     }
[11:01:20.317]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.317]                   }
[11:01:20.317]                 }
[11:01:20.317]             }
[11:01:20.317]         }))
[11:01:20.317]     }, error = function(ex) {
[11:01:20.317]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.317]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.317]                 ...future.rng), started = ...future.startTime, 
[11:01:20.317]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.317]             version = "1.8"), class = "FutureResult")
[11:01:20.317]     }, finally = {
[11:01:20.317]         if (!identical(...future.workdir, getwd())) 
[11:01:20.317]             setwd(...future.workdir)
[11:01:20.317]         {
[11:01:20.317]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.317]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.317]             }
[11:01:20.317]             base::options(...future.oldOptions)
[11:01:20.317]             if (.Platform$OS.type == "windows") {
[11:01:20.317]                 old_names <- names(...future.oldEnvVars)
[11:01:20.317]                 envs <- base::Sys.getenv()
[11:01:20.317]                 names <- names(envs)
[11:01:20.317]                 common <- intersect(names, old_names)
[11:01:20.317]                 added <- setdiff(names, old_names)
[11:01:20.317]                 removed <- setdiff(old_names, names)
[11:01:20.317]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.317]                   envs[common]]
[11:01:20.317]                 NAMES <- toupper(changed)
[11:01:20.317]                 args <- list()
[11:01:20.317]                 for (kk in seq_along(NAMES)) {
[11:01:20.317]                   name <- changed[[kk]]
[11:01:20.317]                   NAME <- NAMES[[kk]]
[11:01:20.317]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.317]                     next
[11:01:20.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.317]                 }
[11:01:20.317]                 NAMES <- toupper(added)
[11:01:20.317]                 for (kk in seq_along(NAMES)) {
[11:01:20.317]                   name <- added[[kk]]
[11:01:20.317]                   NAME <- NAMES[[kk]]
[11:01:20.317]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.317]                     next
[11:01:20.317]                   args[[name]] <- ""
[11:01:20.317]                 }
[11:01:20.317]                 NAMES <- toupper(removed)
[11:01:20.317]                 for (kk in seq_along(NAMES)) {
[11:01:20.317]                   name <- removed[[kk]]
[11:01:20.317]                   NAME <- NAMES[[kk]]
[11:01:20.317]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.317]                     next
[11:01:20.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.317]                 }
[11:01:20.317]                 if (length(args) > 0) 
[11:01:20.317]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.317]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.317]             }
[11:01:20.317]             else {
[11:01:20.317]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.317]             }
[11:01:20.317]             {
[11:01:20.317]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.317]                   0L) {
[11:01:20.317]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.317]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.317]                   base::options(opts)
[11:01:20.317]                 }
[11:01:20.317]                 {
[11:01:20.317]                   {
[11:01:20.317]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:20.317]                     NULL
[11:01:20.317]                   }
[11:01:20.317]                   options(future.plan = NULL)
[11:01:20.317]                   if (is.na(NA_character_)) 
[11:01:20.317]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.317]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.317]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.317]                     .init = FALSE)
[11:01:20.317]                 }
[11:01:20.317]             }
[11:01:20.317]         }
[11:01:20.317]     })
[11:01:20.317]     if (TRUE) {
[11:01:20.317]         base::sink(type = "output", split = FALSE)
[11:01:20.317]         if (TRUE) {
[11:01:20.317]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.317]         }
[11:01:20.317]         else {
[11:01:20.317]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.317]         }
[11:01:20.317]         base::close(...future.stdout)
[11:01:20.317]         ...future.stdout <- NULL
[11:01:20.317]     }
[11:01:20.317]     ...future.result$conditions <- ...future.conditions
[11:01:20.317]     ...future.result$finished <- base::Sys.time()
[11:01:20.317]     ...future.result
[11:01:20.317] }
[11:01:20.320] assign_globals() ...
[11:01:20.320] List of 1
[11:01:20.320]  $ ii: int 3
[11:01:20.320]  - attr(*, "where")=List of 1
[11:01:20.320]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:20.320]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:20.320]  - attr(*, "resolved")= logi FALSE
[11:01:20.320]  - attr(*, "total_size")= num 35
[11:01:20.320]  - attr(*, "already-done")= logi TRUE
[11:01:20.324] - copied ‘ii’ to environment
[11:01:20.325] assign_globals() ... done
[11:01:20.325] requestCore(): workers = 2
[11:01:20.325] Poll #1 (0): usedCores() = 2, workers = 2
[11:01:20.337] result() for MulticoreFuture ...
[11:01:20.337] result() for MulticoreFuture ...
[11:01:20.337] result() for MulticoreFuture ... done
[11:01:20.338] result() for MulticoreFuture ... done
[11:01:20.338] result() for MulticoreFuture ...
[11:01:20.338] result() for MulticoreFuture ... done
[11:01:20.341] MulticoreFuture started
[11:01:20.341] - Launch lazy future ... done
[11:01:20.341] run() for ‘MulticoreFuture’ ... done
[11:01:20.342] plan(): Setting new future strategy stack:
[11:01:20.342] result() for MulticoreFuture ...
[11:01:20.342] result() for MulticoreFuture ... done
[11:01:20.343] result() for MulticoreFuture ...
[11:01:20.343] result() for MulticoreFuture ... done
[11:01:20.342] List of future strategies:
[11:01:20.342] 1. sequential:
[11:01:20.342]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.342]    - tweaked: FALSE
[11:01:20.342]    - call: NULL
[11:01:20.343] result() for MulticoreFuture ...
[11:01:20.343] plan(): nbrOfWorkers() = 1
[11:01:20.346] plan(): Setting new future strategy stack:
[11:01:20.346] List of future strategies:
[11:01:20.346] 1. multicore:
[11:01:20.346]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:20.346]    - tweaked: FALSE
[11:01:20.346]    - call: plan(strategy)
[11:01:20.348] result() for MulticoreFuture ...
[11:01:20.349] result() for MulticoreFuture ... done
[11:01:20.349] signalConditions() ...
[11:01:20.349]  - include = ‘immediateCondition’
[11:01:20.349]  - exclude = 
[11:01:20.350]  - resignal = FALSE
[11:01:20.350]  - Number of conditions: 1
[11:01:20.350] signalConditions() ... done
[11:01:20.350] result() for MulticoreFuture ... done
[11:01:20.350] result() for MulticoreFuture ...
[11:01:20.350] plan(): nbrOfWorkers() = 2
[11:01:20.351] result() for MulticoreFuture ... done
[11:01:20.351] signalConditions() ...
[11:01:20.351]  - include = ‘immediateCondition’
[11:01:20.351]  - exclude = 
[11:01:20.351]  - resignal = FALSE
[11:01:20.351]  - Number of conditions: 1
[11:01:20.352] signalConditions() ... done
[11:01:20.352] Future state: ‘finished’
[11:01:20.352] result() for MulticoreFuture ...
[11:01:20.352] result() for MulticoreFuture ... done
[11:01:20.352] signalConditions() ...
[11:01:20.352]  - include = ‘condition’
[11:01:20.353]  - exclude = ‘immediateCondition’
[11:01:20.353]  - resignal = TRUE
[11:01:20.353]  - Number of conditions: 1
[11:01:20.353]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:20.353] signalConditions() ... done
[11:01:20.354] result() for MulticoreFuture ...
[11:01:20.354] result() for MulticoreFuture ...
[11:01:20.355] result() for MulticoreFuture ... done
[11:01:20.355] result() for MulticoreFuture ... done
[11:01:20.355] result() for MulticoreFuture ...
[11:01:20.355] result() for MulticoreFuture ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[11:01:20.356] result() for MulticoreFuture ...
[11:01:20.356] result() for MulticoreFuture ... done
[11:01:20.356] result() for MulticoreFuture ...
[11:01:20.356] result() for MulticoreFuture ... done
[11:01:20.356] signalConditions() ...
[11:01:20.356]  - include = ‘immediateCondition’
[11:01:20.357]  - exclude = 
[11:01:20.357]  - resignal = FALSE
[11:01:20.357]  - Number of conditions: 1
[11:01:20.357] signalConditions() ... done
[11:01:20.357] Future state: ‘finished’
[11:01:20.357] result() for MulticoreFuture ...
[11:01:20.358] result() for MulticoreFuture ... done
[11:01:20.358] signalConditions() ...
[11:01:20.358]  - include = ‘condition’
[11:01:20.358]  - exclude = ‘immediateCondition’
[11:01:20.358]  - resignal = TRUE
[11:01:20.358]  - Number of conditions: 1
[11:01:20.358]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:20.358] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[11:01:20.359] result() for MulticoreFuture ...
[11:01:20.359] result() for MulticoreFuture ... done
[11:01:20.359] result() for MulticoreFuture ...
[11:01:20.359] result() for MulticoreFuture ... done
[11:01:20.359] signalConditions() ...
[11:01:20.359]  - include = ‘immediateCondition’
[11:01:20.359]  - exclude = 
[11:01:20.359]  - resignal = FALSE
[11:01:20.359]  - Number of conditions: 1
[11:01:20.360] signalConditions() ... done
[11:01:20.360] Future state: ‘finished’
[11:01:20.360] result() for MulticoreFuture ...
[11:01:20.360] result() for MulticoreFuture ... done
[11:01:20.360] signalConditions() ...
[11:01:20.360]  - include = ‘condition’
[11:01:20.360]  - exclude = ‘immediateCondition’
[11:01:20.360]  - resignal = TRUE
[11:01:20.360]  - Number of conditions: 1
[11:01:20.361]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:20.361] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[11:01:20.361] getGlobalsAndPackages() ...
[11:01:20.361] Searching for globals...
[11:01:20.364] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[11:01:20.364] Searching for globals ... DONE
[11:01:20.364] Resolving globals: FALSE
[11:01:20.364] 
[11:01:20.364] 
[11:01:20.365] getGlobalsAndPackages() ... DONE
[11:01:20.365] run() for ‘Future’ ...
[11:01:20.365] - state: ‘created’
[11:01:20.365] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:20.367] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:20.369] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:20.370]   - Field: ‘label’
[11:01:20.370]   - Field: ‘local’
[11:01:20.370]   - Field: ‘owner’
[11:01:20.370]   - Field: ‘envir’
[11:01:20.370]   - Field: ‘workers’
[11:01:20.370]   - Field: ‘packages’
[11:01:20.370]   - Field: ‘gc’
[11:01:20.370]   - Field: ‘job’
[11:01:20.371]   - Field: ‘conditions’
[11:01:20.371]   - Field: ‘expr’
[11:01:20.371]   - Field: ‘uuid’
[11:01:20.371]   - Field: ‘seed’
[11:01:20.371]   - Field: ‘version’
[11:01:20.371]   - Field: ‘result’
[11:01:20.371]   - Field: ‘asynchronous’
[11:01:20.371]   - Field: ‘calls’
[11:01:20.372]   - Field: ‘globals’
[11:01:20.372]   - Field: ‘stdout’
[11:01:20.372]   - Field: ‘earlySignal’
[11:01:20.372]   - Field: ‘lazy’
[11:01:20.372]   - Field: ‘state’
[11:01:20.372] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:20.372] - Launch lazy future ...
[11:01:20.373] Packages needed by the future expression (n = 0): <none>
[11:01:20.373] Packages needed by future strategies (n = 0): <none>
[11:01:20.373] {
[11:01:20.373]     {
[11:01:20.373]         {
[11:01:20.373]             ...future.startTime <- base::Sys.time()
[11:01:20.373]             {
[11:01:20.373]                 {
[11:01:20.373]                   {
[11:01:20.373]                     {
[11:01:20.373]                       base::local({
[11:01:20.373]                         has_future <- base::requireNamespace("future", 
[11:01:20.373]                           quietly = TRUE)
[11:01:20.373]                         if (has_future) {
[11:01:20.373]                           ns <- base::getNamespace("future")
[11:01:20.373]                           version <- ns[[".package"]][["version"]]
[11:01:20.373]                           if (is.null(version)) 
[11:01:20.373]                             version <- utils::packageVersion("future")
[11:01:20.373]                         }
[11:01:20.373]                         else {
[11:01:20.373]                           version <- NULL
[11:01:20.373]                         }
[11:01:20.373]                         if (!has_future || version < "1.8.0") {
[11:01:20.373]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.373]                             "", base::R.version$version.string), 
[11:01:20.373]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:20.373]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.373]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.373]                               "release", "version")], collapse = " "), 
[11:01:20.373]                             hostname = base::Sys.info()[["nodename"]])
[11:01:20.373]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.373]                             info)
[11:01:20.373]                           info <- base::paste(info, collapse = "; ")
[11:01:20.373]                           if (!has_future) {
[11:01:20.373]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.373]                               info)
[11:01:20.373]                           }
[11:01:20.373]                           else {
[11:01:20.373]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.373]                               info, version)
[11:01:20.373]                           }
[11:01:20.373]                           base::stop(msg)
[11:01:20.373]                         }
[11:01:20.373]                       })
[11:01:20.373]                     }
[11:01:20.373]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:20.373]                     base::options(mc.cores = 1L)
[11:01:20.373]                   }
[11:01:20.373]                   ...future.strategy.old <- future::plan("list")
[11:01:20.373]                   options(future.plan = NULL)
[11:01:20.373]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.373]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.373]                 }
[11:01:20.373]                 ...future.workdir <- getwd()
[11:01:20.373]             }
[11:01:20.373]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.373]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.373]         }
[11:01:20.373]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.373]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.373]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.373]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.373]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.373]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.373]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.373]             base::names(...future.oldOptions))
[11:01:20.373]     }
[11:01:20.373]     if (FALSE) {
[11:01:20.373]     }
[11:01:20.373]     else {
[11:01:20.373]         if (TRUE) {
[11:01:20.373]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.373]                 open = "w")
[11:01:20.373]         }
[11:01:20.373]         else {
[11:01:20.373]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.373]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.373]         }
[11:01:20.373]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.373]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.373]             base::sink(type = "output", split = FALSE)
[11:01:20.373]             base::close(...future.stdout)
[11:01:20.373]         }, add = TRUE)
[11:01:20.373]     }
[11:01:20.373]     ...future.frame <- base::sys.nframe()
[11:01:20.373]     ...future.conditions <- base::list()
[11:01:20.373]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.373]     if (FALSE) {
[11:01:20.373]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.373]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.373]     }
[11:01:20.373]     ...future.result <- base::tryCatch({
[11:01:20.373]         base::withCallingHandlers({
[11:01:20.373]             ...future.value <- base::withVisible(base::local({
[11:01:20.373]                 withCallingHandlers({
[11:01:20.373]                   {
[11:01:20.373]                     cat("Processing: ")
[11:01:20.373]                     for (ii in 1:10) {
[11:01:20.373]                       cat(".")
[11:01:20.373]                     }
[11:01:20.373]                     cat(" [100%]\n")
[11:01:20.373]                     4
[11:01:20.373]                   }
[11:01:20.373]                 }, immediateCondition = function(cond) {
[11:01:20.373]                   save_rds <- function (object, pathname, ...) 
[11:01:20.373]                   {
[11:01:20.373]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:20.373]                     if (file_test("-f", pathname_tmp)) {
[11:01:20.373]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.373]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:20.373]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.373]                         fi_tmp[["mtime"]])
[11:01:20.373]                     }
[11:01:20.373]                     tryCatch({
[11:01:20.373]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:20.373]                     }, error = function(ex) {
[11:01:20.373]                       msg <- conditionMessage(ex)
[11:01:20.373]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.373]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:20.373]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.373]                         fi_tmp[["mtime"]], msg)
[11:01:20.373]                       ex$message <- msg
[11:01:20.373]                       stop(ex)
[11:01:20.373]                     })
[11:01:20.373]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:20.373]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:20.373]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:20.373]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.373]                       fi <- file.info(pathname)
[11:01:20.373]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:20.373]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.373]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:20.373]                         fi[["size"]], fi[["mtime"]])
[11:01:20.373]                       stop(msg)
[11:01:20.373]                     }
[11:01:20.373]                     invisible(pathname)
[11:01:20.373]                   }
[11:01:20.373]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:20.373]                     rootPath = tempdir()) 
[11:01:20.373]                   {
[11:01:20.373]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:20.373]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:20.373]                       tmpdir = path, fileext = ".rds")
[11:01:20.373]                     save_rds(obj, file)
[11:01:20.373]                   }
[11:01:20.373]                   saveImmediateCondition(cond, path = "/tmp/RtmpxWUrEc/.future/immediateConditions")
[11:01:20.373]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.373]                   {
[11:01:20.373]                     inherits <- base::inherits
[11:01:20.373]                     invokeRestart <- base::invokeRestart
[11:01:20.373]                     is.null <- base::is.null
[11:01:20.373]                     muffled <- FALSE
[11:01:20.373]                     if (inherits(cond, "message")) {
[11:01:20.373]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:20.373]                       if (muffled) 
[11:01:20.373]                         invokeRestart("muffleMessage")
[11:01:20.373]                     }
[11:01:20.373]                     else if (inherits(cond, "warning")) {
[11:01:20.373]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:20.373]                       if (muffled) 
[11:01:20.373]                         invokeRestart("muffleWarning")
[11:01:20.373]                     }
[11:01:20.373]                     else if (inherits(cond, "condition")) {
[11:01:20.373]                       if (!is.null(pattern)) {
[11:01:20.373]                         computeRestarts <- base::computeRestarts
[11:01:20.373]                         grepl <- base::grepl
[11:01:20.373]                         restarts <- computeRestarts(cond)
[11:01:20.373]                         for (restart in restarts) {
[11:01:20.373]                           name <- restart$name
[11:01:20.373]                           if (is.null(name)) 
[11:01:20.373]                             next
[11:01:20.373]                           if (!grepl(pattern, name)) 
[11:01:20.373]                             next
[11:01:20.373]                           invokeRestart(restart)
[11:01:20.373]                           muffled <- TRUE
[11:01:20.373]                           break
[11:01:20.373]                         }
[11:01:20.373]                       }
[11:01:20.373]                     }
[11:01:20.373]                     invisible(muffled)
[11:01:20.373]                   }
[11:01:20.373]                   muffleCondition(cond)
[11:01:20.373]                 })
[11:01:20.373]             }))
[11:01:20.373]             future::FutureResult(value = ...future.value$value, 
[11:01:20.373]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.373]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.373]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.373]                     ...future.globalenv.names))
[11:01:20.373]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.373]         }, condition = base::local({
[11:01:20.373]             c <- base::c
[11:01:20.373]             inherits <- base::inherits
[11:01:20.373]             invokeRestart <- base::invokeRestart
[11:01:20.373]             length <- base::length
[11:01:20.373]             list <- base::list
[11:01:20.373]             seq.int <- base::seq.int
[11:01:20.373]             signalCondition <- base::signalCondition
[11:01:20.373]             sys.calls <- base::sys.calls
[11:01:20.373]             `[[` <- base::`[[`
[11:01:20.373]             `+` <- base::`+`
[11:01:20.373]             `<<-` <- base::`<<-`
[11:01:20.373]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.373]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.373]                   3L)]
[11:01:20.373]             }
[11:01:20.373]             function(cond) {
[11:01:20.373]                 is_error <- inherits(cond, "error")
[11:01:20.373]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.373]                   NULL)
[11:01:20.373]                 if (is_error) {
[11:01:20.373]                   sessionInformation <- function() {
[11:01:20.373]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.373]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.373]                       search = base::search(), system = base::Sys.info())
[11:01:20.373]                   }
[11:01:20.373]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.373]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.373]                     cond$call), session = sessionInformation(), 
[11:01:20.373]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.373]                   signalCondition(cond)
[11:01:20.373]                 }
[11:01:20.373]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.373]                 "immediateCondition"))) {
[11:01:20.373]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.373]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.373]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.373]                   if (TRUE && !signal) {
[11:01:20.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.373]                     {
[11:01:20.373]                       inherits <- base::inherits
[11:01:20.373]                       invokeRestart <- base::invokeRestart
[11:01:20.373]                       is.null <- base::is.null
[11:01:20.373]                       muffled <- FALSE
[11:01:20.373]                       if (inherits(cond, "message")) {
[11:01:20.373]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.373]                         if (muffled) 
[11:01:20.373]                           invokeRestart("muffleMessage")
[11:01:20.373]                       }
[11:01:20.373]                       else if (inherits(cond, "warning")) {
[11:01:20.373]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.373]                         if (muffled) 
[11:01:20.373]                           invokeRestart("muffleWarning")
[11:01:20.373]                       }
[11:01:20.373]                       else if (inherits(cond, "condition")) {
[11:01:20.373]                         if (!is.null(pattern)) {
[11:01:20.373]                           computeRestarts <- base::computeRestarts
[11:01:20.373]                           grepl <- base::grepl
[11:01:20.373]                           restarts <- computeRestarts(cond)
[11:01:20.373]                           for (restart in restarts) {
[11:01:20.373]                             name <- restart$name
[11:01:20.373]                             if (is.null(name)) 
[11:01:20.373]                               next
[11:01:20.373]                             if (!grepl(pattern, name)) 
[11:01:20.373]                               next
[11:01:20.373]                             invokeRestart(restart)
[11:01:20.373]                             muffled <- TRUE
[11:01:20.373]                             break
[11:01:20.373]                           }
[11:01:20.373]                         }
[11:01:20.373]                       }
[11:01:20.373]                       invisible(muffled)
[11:01:20.373]                     }
[11:01:20.373]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.373]                   }
[11:01:20.373]                 }
[11:01:20.373]                 else {
[11:01:20.373]                   if (TRUE) {
[11:01:20.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.373]                     {
[11:01:20.373]                       inherits <- base::inherits
[11:01:20.373]                       invokeRestart <- base::invokeRestart
[11:01:20.373]                       is.null <- base::is.null
[11:01:20.373]                       muffled <- FALSE
[11:01:20.373]                       if (inherits(cond, "message")) {
[11:01:20.373]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.373]                         if (muffled) 
[11:01:20.373]                           invokeRestart("muffleMessage")
[11:01:20.373]                       }
[11:01:20.373]                       else if (inherits(cond, "warning")) {
[11:01:20.373]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.373]                         if (muffled) 
[11:01:20.373]                           invokeRestart("muffleWarning")
[11:01:20.373]                       }
[11:01:20.373]                       else if (inherits(cond, "condition")) {
[11:01:20.373]                         if (!is.null(pattern)) {
[11:01:20.373]                           computeRestarts <- base::computeRestarts
[11:01:20.373]                           grepl <- base::grepl
[11:01:20.373]                           restarts <- computeRestarts(cond)
[11:01:20.373]                           for (restart in restarts) {
[11:01:20.373]                             name <- restart$name
[11:01:20.373]                             if (is.null(name)) 
[11:01:20.373]                               next
[11:01:20.373]                             if (!grepl(pattern, name)) 
[11:01:20.373]                               next
[11:01:20.373]                             invokeRestart(restart)
[11:01:20.373]                             muffled <- TRUE
[11:01:20.373]                             break
[11:01:20.373]                           }
[11:01:20.373]                         }
[11:01:20.373]                       }
[11:01:20.373]                       invisible(muffled)
[11:01:20.373]                     }
[11:01:20.373]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.373]                   }
[11:01:20.373]                 }
[11:01:20.373]             }
[11:01:20.373]         }))
[11:01:20.373]     }, error = function(ex) {
[11:01:20.373]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.373]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.373]                 ...future.rng), started = ...future.startTime, 
[11:01:20.373]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.373]             version = "1.8"), class = "FutureResult")
[11:01:20.373]     }, finally = {
[11:01:20.373]         if (!identical(...future.workdir, getwd())) 
[11:01:20.373]             setwd(...future.workdir)
[11:01:20.373]         {
[11:01:20.373]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.373]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.373]             }
[11:01:20.373]             base::options(...future.oldOptions)
[11:01:20.373]             if (.Platform$OS.type == "windows") {
[11:01:20.373]                 old_names <- names(...future.oldEnvVars)
[11:01:20.373]                 envs <- base::Sys.getenv()
[11:01:20.373]                 names <- names(envs)
[11:01:20.373]                 common <- intersect(names, old_names)
[11:01:20.373]                 added <- setdiff(names, old_names)
[11:01:20.373]                 removed <- setdiff(old_names, names)
[11:01:20.373]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.373]                   envs[common]]
[11:01:20.373]                 NAMES <- toupper(changed)
[11:01:20.373]                 args <- list()
[11:01:20.373]                 for (kk in seq_along(NAMES)) {
[11:01:20.373]                   name <- changed[[kk]]
[11:01:20.373]                   NAME <- NAMES[[kk]]
[11:01:20.373]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.373]                     next
[11:01:20.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.373]                 }
[11:01:20.373]                 NAMES <- toupper(added)
[11:01:20.373]                 for (kk in seq_along(NAMES)) {
[11:01:20.373]                   name <- added[[kk]]
[11:01:20.373]                   NAME <- NAMES[[kk]]
[11:01:20.373]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.373]                     next
[11:01:20.373]                   args[[name]] <- ""
[11:01:20.373]                 }
[11:01:20.373]                 NAMES <- toupper(removed)
[11:01:20.373]                 for (kk in seq_along(NAMES)) {
[11:01:20.373]                   name <- removed[[kk]]
[11:01:20.373]                   NAME <- NAMES[[kk]]
[11:01:20.373]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.373]                     next
[11:01:20.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.373]                 }
[11:01:20.373]                 if (length(args) > 0) 
[11:01:20.373]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.373]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.373]             }
[11:01:20.373]             else {
[11:01:20.373]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.373]             }
[11:01:20.373]             {
[11:01:20.373]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.373]                   0L) {
[11:01:20.373]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.373]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.373]                   base::options(opts)
[11:01:20.373]                 }
[11:01:20.373]                 {
[11:01:20.373]                   {
[11:01:20.373]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:20.373]                     NULL
[11:01:20.373]                   }
[11:01:20.373]                   options(future.plan = NULL)
[11:01:20.373]                   if (is.na(NA_character_)) 
[11:01:20.373]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.373]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.373]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.373]                     .init = FALSE)
[11:01:20.373]                 }
[11:01:20.373]             }
[11:01:20.373]         }
[11:01:20.373]     })
[11:01:20.373]     if (TRUE) {
[11:01:20.373]         base::sink(type = "output", split = FALSE)
[11:01:20.373]         if (TRUE) {
[11:01:20.373]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.373]         }
[11:01:20.373]         else {
[11:01:20.373]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.373]         }
[11:01:20.373]         base::close(...future.stdout)
[11:01:20.373]         ...future.stdout <- NULL
[11:01:20.373]     }
[11:01:20.373]     ...future.result$conditions <- ...future.conditions
[11:01:20.373]     ...future.result$finished <- base::Sys.time()
[11:01:20.373]     ...future.result
[11:01:20.373] }
[11:01:20.376] requestCore(): workers = 2
[11:01:20.377] MulticoreFuture started
[11:01:20.378] - Launch lazy future ... done
[11:01:20.378] run() for ‘MulticoreFuture’ ... done
[11:01:20.378] plan(): Setting new future strategy stack:
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[11:01:20.379] result() for MulticoreFuture ...
[11:01:20.379] result() for MulticoreFuture ... done
[11:01:20.378] List of future strategies:
[11:01:20.378] 1. sequential:
[11:01:20.378]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.378]    - tweaked: FALSE
[11:01:20.378]    - call: NULL
[11:01:20.379] result() for MulticoreFuture ...
[11:01:20.379] plan(): nbrOfWorkers() = 1
[11:01:20.379] result() for MulticoreFuture ... done
[11:01:20.380] signalConditions() ...
[11:01:20.380]  - include = ‘immediateCondition’
[11:01:20.380]  - exclude = 
[11:01:20.380]  - resignal = FALSE
[11:01:20.380]  - Number of conditions: 1
[11:01:20.380] signalConditions() ... done
[11:01:20.381] Future state: ‘finished’
[11:01:20.381] result() for MulticoreFuture ...
[11:01:20.381] result() for MulticoreFuture ... done
[11:01:20.381] signalConditions() ...
[11:01:20.381] plan(): Setting new future strategy stack:
[11:01:20.381]  - include = ‘condition’
[11:01:20.381]  - exclude = ‘immediateCondition’
[11:01:20.382]  - resignal = TRUE
[11:01:20.381] List of future strategies:
[11:01:20.381] 1. multicore:
[11:01:20.381]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:20.381]    - tweaked: FALSE
[11:01:20.381]    - call: plan(strategy)
[11:01:20.382]  - Number of conditions: 1
[11:01:20.382]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:20.382] signalConditions() ... done
v3: <simpleError> (as expect)
[11:01:20.382] result() for MulticoreFuture ...
[11:01:20.384] plan(): nbrOfWorkers() = 2
[11:01:20.385] result() for MulticoreFuture ...
[11:01:20.385] result() for MulticoreFuture ... done
[11:01:20.385] result() for MulticoreFuture ... done
[11:01:20.385] result() for MulticoreFuture ...
[11:01:20.385] result() for MulticoreFuture ... done
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[11:01:20.386] getGlobalsAndPackages() ...
[11:01:20.386] Searching for globals...
[11:01:20.386] 
[11:01:20.387] Searching for globals ... DONE
[11:01:20.387] - globals: [0] <none>
[11:01:20.387] getGlobalsAndPackages() ... DONE
[11:01:20.387] run() for ‘Future’ ...
[11:01:20.387] - state: ‘created’
[11:01:20.387] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:20.389] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:20.390] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:20.390]   - Field: ‘label’
[11:01:20.390]   - Field: ‘local’
[11:01:20.390]   - Field: ‘owner’
[11:01:20.390]   - Field: ‘envir’
[11:01:20.390]   - Field: ‘workers’
[11:01:20.390]   - Field: ‘packages’
[11:01:20.390]   - Field: ‘gc’
[11:01:20.390]   - Field: ‘job’
[11:01:20.391]   - Field: ‘conditions’
[11:01:20.391]   - Field: ‘expr’
[11:01:20.391]   - Field: ‘uuid’
[11:01:20.391]   - Field: ‘seed’
[11:01:20.391]   - Field: ‘version’
[11:01:20.391]   - Field: ‘result’
[11:01:20.391]   - Field: ‘asynchronous’
[11:01:20.391]   - Field: ‘calls’
[11:01:20.391]   - Field: ‘globals’
[11:01:20.392]   - Field: ‘stdout’
[11:01:20.392]   - Field: ‘earlySignal’
[11:01:20.392]   - Field: ‘lazy’
[11:01:20.392]   - Field: ‘state’
[11:01:20.392] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:20.392] - Launch lazy future ...
[11:01:20.392] Packages needed by the future expression (n = 0): <none>
[11:01:20.392] Packages needed by future strategies (n = 0): <none>
[11:01:20.393] {
[11:01:20.393]     {
[11:01:20.393]         {
[11:01:20.393]             ...future.startTime <- base::Sys.time()
[11:01:20.393]             {
[11:01:20.393]                 {
[11:01:20.393]                   {
[11:01:20.393]                     {
[11:01:20.393]                       base::local({
[11:01:20.393]                         has_future <- base::requireNamespace("future", 
[11:01:20.393]                           quietly = TRUE)
[11:01:20.393]                         if (has_future) {
[11:01:20.393]                           ns <- base::getNamespace("future")
[11:01:20.393]                           version <- ns[[".package"]][["version"]]
[11:01:20.393]                           if (is.null(version)) 
[11:01:20.393]                             version <- utils::packageVersion("future")
[11:01:20.393]                         }
[11:01:20.393]                         else {
[11:01:20.393]                           version <- NULL
[11:01:20.393]                         }
[11:01:20.393]                         if (!has_future || version < "1.8.0") {
[11:01:20.393]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.393]                             "", base::R.version$version.string), 
[11:01:20.393]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:20.393]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.393]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.393]                               "release", "version")], collapse = " "), 
[11:01:20.393]                             hostname = base::Sys.info()[["nodename"]])
[11:01:20.393]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.393]                             info)
[11:01:20.393]                           info <- base::paste(info, collapse = "; ")
[11:01:20.393]                           if (!has_future) {
[11:01:20.393]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.393]                               info)
[11:01:20.393]                           }
[11:01:20.393]                           else {
[11:01:20.393]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.393]                               info, version)
[11:01:20.393]                           }
[11:01:20.393]                           base::stop(msg)
[11:01:20.393]                         }
[11:01:20.393]                       })
[11:01:20.393]                     }
[11:01:20.393]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:20.393]                     base::options(mc.cores = 1L)
[11:01:20.393]                   }
[11:01:20.393]                   ...future.strategy.old <- future::plan("list")
[11:01:20.393]                   options(future.plan = NULL)
[11:01:20.393]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.393]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.393]                 }
[11:01:20.393]                 ...future.workdir <- getwd()
[11:01:20.393]             }
[11:01:20.393]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.393]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.393]         }
[11:01:20.393]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.393]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.393]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.393]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.393]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.393]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.393]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.393]             base::names(...future.oldOptions))
[11:01:20.393]     }
[11:01:20.393]     if (FALSE) {
[11:01:20.393]     }
[11:01:20.393]     else {
[11:01:20.393]         if (TRUE) {
[11:01:20.393]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.393]                 open = "w")
[11:01:20.393]         }
[11:01:20.393]         else {
[11:01:20.393]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.393]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.393]         }
[11:01:20.393]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.393]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.393]             base::sink(type = "output", split = FALSE)
[11:01:20.393]             base::close(...future.stdout)
[11:01:20.393]         }, add = TRUE)
[11:01:20.393]     }
[11:01:20.393]     ...future.frame <- base::sys.nframe()
[11:01:20.393]     ...future.conditions <- base::list()
[11:01:20.393]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.393]     if (FALSE) {
[11:01:20.393]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.393]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.393]     }
[11:01:20.393]     ...future.result <- base::tryCatch({
[11:01:20.393]         base::withCallingHandlers({
[11:01:20.393]             ...future.value <- base::withVisible(base::local({
[11:01:20.393]                 withCallingHandlers({
[11:01:20.393]                   1
[11:01:20.393]                 }, immediateCondition = function(cond) {
[11:01:20.393]                   save_rds <- function (object, pathname, ...) 
[11:01:20.393]                   {
[11:01:20.393]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:20.393]                     if (file_test("-f", pathname_tmp)) {
[11:01:20.393]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.393]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:20.393]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.393]                         fi_tmp[["mtime"]])
[11:01:20.393]                     }
[11:01:20.393]                     tryCatch({
[11:01:20.393]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:20.393]                     }, error = function(ex) {
[11:01:20.393]                       msg <- conditionMessage(ex)
[11:01:20.393]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.393]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:20.393]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.393]                         fi_tmp[["mtime"]], msg)
[11:01:20.393]                       ex$message <- msg
[11:01:20.393]                       stop(ex)
[11:01:20.393]                     })
[11:01:20.393]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:20.393]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:20.393]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:20.393]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.393]                       fi <- file.info(pathname)
[11:01:20.393]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:20.393]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.393]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:20.393]                         fi[["size"]], fi[["mtime"]])
[11:01:20.393]                       stop(msg)
[11:01:20.393]                     }
[11:01:20.393]                     invisible(pathname)
[11:01:20.393]                   }
[11:01:20.393]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:20.393]                     rootPath = tempdir()) 
[11:01:20.393]                   {
[11:01:20.393]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:20.393]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:20.393]                       tmpdir = path, fileext = ".rds")
[11:01:20.393]                     save_rds(obj, file)
[11:01:20.393]                   }
[11:01:20.393]                   saveImmediateCondition(cond, path = "/tmp/RtmpxWUrEc/.future/immediateConditions")
[11:01:20.393]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.393]                   {
[11:01:20.393]                     inherits <- base::inherits
[11:01:20.393]                     invokeRestart <- base::invokeRestart
[11:01:20.393]                     is.null <- base::is.null
[11:01:20.393]                     muffled <- FALSE
[11:01:20.393]                     if (inherits(cond, "message")) {
[11:01:20.393]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:20.393]                       if (muffled) 
[11:01:20.393]                         invokeRestart("muffleMessage")
[11:01:20.393]                     }
[11:01:20.393]                     else if (inherits(cond, "warning")) {
[11:01:20.393]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:20.393]                       if (muffled) 
[11:01:20.393]                         invokeRestart("muffleWarning")
[11:01:20.393]                     }
[11:01:20.393]                     else if (inherits(cond, "condition")) {
[11:01:20.393]                       if (!is.null(pattern)) {
[11:01:20.393]                         computeRestarts <- base::computeRestarts
[11:01:20.393]                         grepl <- base::grepl
[11:01:20.393]                         restarts <- computeRestarts(cond)
[11:01:20.393]                         for (restart in restarts) {
[11:01:20.393]                           name <- restart$name
[11:01:20.393]                           if (is.null(name)) 
[11:01:20.393]                             next
[11:01:20.393]                           if (!grepl(pattern, name)) 
[11:01:20.393]                             next
[11:01:20.393]                           invokeRestart(restart)
[11:01:20.393]                           muffled <- TRUE
[11:01:20.393]                           break
[11:01:20.393]                         }
[11:01:20.393]                       }
[11:01:20.393]                     }
[11:01:20.393]                     invisible(muffled)
[11:01:20.393]                   }
[11:01:20.393]                   muffleCondition(cond)
[11:01:20.393]                 })
[11:01:20.393]             }))
[11:01:20.393]             future::FutureResult(value = ...future.value$value, 
[11:01:20.393]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.393]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.393]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.393]                     ...future.globalenv.names))
[11:01:20.393]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.393]         }, condition = base::local({
[11:01:20.393]             c <- base::c
[11:01:20.393]             inherits <- base::inherits
[11:01:20.393]             invokeRestart <- base::invokeRestart
[11:01:20.393]             length <- base::length
[11:01:20.393]             list <- base::list
[11:01:20.393]             seq.int <- base::seq.int
[11:01:20.393]             signalCondition <- base::signalCondition
[11:01:20.393]             sys.calls <- base::sys.calls
[11:01:20.393]             `[[` <- base::`[[`
[11:01:20.393]             `+` <- base::`+`
[11:01:20.393]             `<<-` <- base::`<<-`
[11:01:20.393]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.393]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.393]                   3L)]
[11:01:20.393]             }
[11:01:20.393]             function(cond) {
[11:01:20.393]                 is_error <- inherits(cond, "error")
[11:01:20.393]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.393]                   NULL)
[11:01:20.393]                 if (is_error) {
[11:01:20.393]                   sessionInformation <- function() {
[11:01:20.393]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.393]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.393]                       search = base::search(), system = base::Sys.info())
[11:01:20.393]                   }
[11:01:20.393]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.393]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.393]                     cond$call), session = sessionInformation(), 
[11:01:20.393]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.393]                   signalCondition(cond)
[11:01:20.393]                 }
[11:01:20.393]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.393]                 "immediateCondition"))) {
[11:01:20.393]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.393]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.393]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.393]                   if (TRUE && !signal) {
[11:01:20.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.393]                     {
[11:01:20.393]                       inherits <- base::inherits
[11:01:20.393]                       invokeRestart <- base::invokeRestart
[11:01:20.393]                       is.null <- base::is.null
[11:01:20.393]                       muffled <- FALSE
[11:01:20.393]                       if (inherits(cond, "message")) {
[11:01:20.393]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.393]                         if (muffled) 
[11:01:20.393]                           invokeRestart("muffleMessage")
[11:01:20.393]                       }
[11:01:20.393]                       else if (inherits(cond, "warning")) {
[11:01:20.393]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.393]                         if (muffled) 
[11:01:20.393]                           invokeRestart("muffleWarning")
[11:01:20.393]                       }
[11:01:20.393]                       else if (inherits(cond, "condition")) {
[11:01:20.393]                         if (!is.null(pattern)) {
[11:01:20.393]                           computeRestarts <- base::computeRestarts
[11:01:20.393]                           grepl <- base::grepl
[11:01:20.393]                           restarts <- computeRestarts(cond)
[11:01:20.393]                           for (restart in restarts) {
[11:01:20.393]                             name <- restart$name
[11:01:20.393]                             if (is.null(name)) 
[11:01:20.393]                               next
[11:01:20.393]                             if (!grepl(pattern, name)) 
[11:01:20.393]                               next
[11:01:20.393]                             invokeRestart(restart)
[11:01:20.393]                             muffled <- TRUE
[11:01:20.393]                             break
[11:01:20.393]                           }
[11:01:20.393]                         }
[11:01:20.393]                       }
[11:01:20.393]                       invisible(muffled)
[11:01:20.393]                     }
[11:01:20.393]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.393]                   }
[11:01:20.393]                 }
[11:01:20.393]                 else {
[11:01:20.393]                   if (TRUE) {
[11:01:20.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.393]                     {
[11:01:20.393]                       inherits <- base::inherits
[11:01:20.393]                       invokeRestart <- base::invokeRestart
[11:01:20.393]                       is.null <- base::is.null
[11:01:20.393]                       muffled <- FALSE
[11:01:20.393]                       if (inherits(cond, "message")) {
[11:01:20.393]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.393]                         if (muffled) 
[11:01:20.393]                           invokeRestart("muffleMessage")
[11:01:20.393]                       }
[11:01:20.393]                       else if (inherits(cond, "warning")) {
[11:01:20.393]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.393]                         if (muffled) 
[11:01:20.393]                           invokeRestart("muffleWarning")
[11:01:20.393]                       }
[11:01:20.393]                       else if (inherits(cond, "condition")) {
[11:01:20.393]                         if (!is.null(pattern)) {
[11:01:20.393]                           computeRestarts <- base::computeRestarts
[11:01:20.393]                           grepl <- base::grepl
[11:01:20.393]                           restarts <- computeRestarts(cond)
[11:01:20.393]                           for (restart in restarts) {
[11:01:20.393]                             name <- restart$name
[11:01:20.393]                             if (is.null(name)) 
[11:01:20.393]                               next
[11:01:20.393]                             if (!grepl(pattern, name)) 
[11:01:20.393]                               next
[11:01:20.393]                             invokeRestart(restart)
[11:01:20.393]                             muffled <- TRUE
[11:01:20.393]                             break
[11:01:20.393]                           }
[11:01:20.393]                         }
[11:01:20.393]                       }
[11:01:20.393]                       invisible(muffled)
[11:01:20.393]                     }
[11:01:20.393]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.393]                   }
[11:01:20.393]                 }
[11:01:20.393]             }
[11:01:20.393]         }))
[11:01:20.393]     }, error = function(ex) {
[11:01:20.393]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.393]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.393]                 ...future.rng), started = ...future.startTime, 
[11:01:20.393]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.393]             version = "1.8"), class = "FutureResult")
[11:01:20.393]     }, finally = {
[11:01:20.393]         if (!identical(...future.workdir, getwd())) 
[11:01:20.393]             setwd(...future.workdir)
[11:01:20.393]         {
[11:01:20.393]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.393]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.393]             }
[11:01:20.393]             base::options(...future.oldOptions)
[11:01:20.393]             if (.Platform$OS.type == "windows") {
[11:01:20.393]                 old_names <- names(...future.oldEnvVars)
[11:01:20.393]                 envs <- base::Sys.getenv()
[11:01:20.393]                 names <- names(envs)
[11:01:20.393]                 common <- intersect(names, old_names)
[11:01:20.393]                 added <- setdiff(names, old_names)
[11:01:20.393]                 removed <- setdiff(old_names, names)
[11:01:20.393]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.393]                   envs[common]]
[11:01:20.393]                 NAMES <- toupper(changed)
[11:01:20.393]                 args <- list()
[11:01:20.393]                 for (kk in seq_along(NAMES)) {
[11:01:20.393]                   name <- changed[[kk]]
[11:01:20.393]                   NAME <- NAMES[[kk]]
[11:01:20.393]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.393]                     next
[11:01:20.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.393]                 }
[11:01:20.393]                 NAMES <- toupper(added)
[11:01:20.393]                 for (kk in seq_along(NAMES)) {
[11:01:20.393]                   name <- added[[kk]]
[11:01:20.393]                   NAME <- NAMES[[kk]]
[11:01:20.393]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.393]                     next
[11:01:20.393]                   args[[name]] <- ""
[11:01:20.393]                 }
[11:01:20.393]                 NAMES <- toupper(removed)
[11:01:20.393]                 for (kk in seq_along(NAMES)) {
[11:01:20.393]                   name <- removed[[kk]]
[11:01:20.393]                   NAME <- NAMES[[kk]]
[11:01:20.393]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.393]                     next
[11:01:20.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.393]                 }
[11:01:20.393]                 if (length(args) > 0) 
[11:01:20.393]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.393]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.393]             }
[11:01:20.393]             else {
[11:01:20.393]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.393]             }
[11:01:20.393]             {
[11:01:20.393]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.393]                   0L) {
[11:01:20.393]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.393]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.393]                   base::options(opts)
[11:01:20.393]                 }
[11:01:20.393]                 {
[11:01:20.393]                   {
[11:01:20.393]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:20.393]                     NULL
[11:01:20.393]                   }
[11:01:20.393]                   options(future.plan = NULL)
[11:01:20.393]                   if (is.na(NA_character_)) 
[11:01:20.393]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.393]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.393]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.393]                     .init = FALSE)
[11:01:20.393]                 }
[11:01:20.393]             }
[11:01:20.393]         }
[11:01:20.393]     })
[11:01:20.393]     if (TRUE) {
[11:01:20.393]         base::sink(type = "output", split = FALSE)
[11:01:20.393]         if (TRUE) {
[11:01:20.393]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.393]         }
[11:01:20.393]         else {
[11:01:20.393]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.393]         }
[11:01:20.393]         base::close(...future.stdout)
[11:01:20.393]         ...future.stdout <- NULL
[11:01:20.393]     }
[11:01:20.393]     ...future.result$conditions <- ...future.conditions
[11:01:20.393]     ...future.result$finished <- base::Sys.time()
[11:01:20.393]     ...future.result
[11:01:20.393] }
[11:01:20.396] requestCore(): workers = 2
[11:01:20.397] MulticoreFuture started
[11:01:20.397] - Launch lazy future ... done
[11:01:20.398] run() for ‘MulticoreFuture’ ... done
[11:01:20.398] plan(): Setting new future strategy stack:
[11:01:20.398] result() for MulticoreFuture ...
[11:01:20.398] List of future strategies:
[11:01:20.398] 1. sequential:
[11:01:20.398]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.398]    - tweaked: FALSE
[11:01:20.398]    - call: NULL
[11:01:20.399] plan(): nbrOfWorkers() = 1
[11:01:20.401] plan(): Setting new future strategy stack:
[11:01:20.401] List of future strategies:
[11:01:20.401] 1. multicore:
[11:01:20.401]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:20.401]    - tweaked: FALSE
[11:01:20.401]    - call: plan(strategy)
[11:01:20.404] plan(): nbrOfWorkers() = 2
[11:01:20.405] result() for MulticoreFuture ...
[11:01:20.405] result() for MulticoreFuture ... done
[11:01:20.405] result() for MulticoreFuture ... done
[11:01:20.405] result() for MulticoreFuture ...
[11:01:20.405] result() for MulticoreFuture ... done
c = 1
[11:01:20.406] getGlobalsAndPackages() ...
[11:01:20.406] Searching for globals...
[11:01:20.406] 
[11:01:20.406] Searching for globals ... DONE
[11:01:20.406] - globals: [0] <none>
[11:01:20.407] getGlobalsAndPackages() ... DONE
[11:01:20.407] run() for ‘Future’ ...
[11:01:20.407] - state: ‘created’
[11:01:20.407] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:20.409] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:20.409] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:20.410]   - Field: ‘label’
[11:01:20.410]   - Field: ‘local’
[11:01:20.410]   - Field: ‘owner’
[11:01:20.410]   - Field: ‘envir’
[11:01:20.410]   - Field: ‘workers’
[11:01:20.410]   - Field: ‘packages’
[11:01:20.410]   - Field: ‘gc’
[11:01:20.410]   - Field: ‘job’
[11:01:20.410]   - Field: ‘conditions’
[11:01:20.411]   - Field: ‘expr’
[11:01:20.411]   - Field: ‘uuid’
[11:01:20.411]   - Field: ‘seed’
[11:01:20.411]   - Field: ‘version’
[11:01:20.411]   - Field: ‘result’
[11:01:20.411]   - Field: ‘asynchronous’
[11:01:20.411]   - Field: ‘calls’
[11:01:20.411]   - Field: ‘globals’
[11:01:20.411]   - Field: ‘stdout’
[11:01:20.412]   - Field: ‘earlySignal’
[11:01:20.412]   - Field: ‘lazy’
[11:01:20.412]   - Field: ‘state’
[11:01:20.414] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:20.414] - Launch lazy future ...
[11:01:20.414] Packages needed by the future expression (n = 0): <none>
[11:01:20.415] Packages needed by future strategies (n = 0): <none>
[11:01:20.415] {
[11:01:20.415]     {
[11:01:20.415]         {
[11:01:20.415]             ...future.startTime <- base::Sys.time()
[11:01:20.415]             {
[11:01:20.415]                 {
[11:01:20.415]                   {
[11:01:20.415]                     {
[11:01:20.415]                       base::local({
[11:01:20.415]                         has_future <- base::requireNamespace("future", 
[11:01:20.415]                           quietly = TRUE)
[11:01:20.415]                         if (has_future) {
[11:01:20.415]                           ns <- base::getNamespace("future")
[11:01:20.415]                           version <- ns[[".package"]][["version"]]
[11:01:20.415]                           if (is.null(version)) 
[11:01:20.415]                             version <- utils::packageVersion("future")
[11:01:20.415]                         }
[11:01:20.415]                         else {
[11:01:20.415]                           version <- NULL
[11:01:20.415]                         }
[11:01:20.415]                         if (!has_future || version < "1.8.0") {
[11:01:20.415]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.415]                             "", base::R.version$version.string), 
[11:01:20.415]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:20.415]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.415]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.415]                               "release", "version")], collapse = " "), 
[11:01:20.415]                             hostname = base::Sys.info()[["nodename"]])
[11:01:20.415]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.415]                             info)
[11:01:20.415]                           info <- base::paste(info, collapse = "; ")
[11:01:20.415]                           if (!has_future) {
[11:01:20.415]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.415]                               info)
[11:01:20.415]                           }
[11:01:20.415]                           else {
[11:01:20.415]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.415]                               info, version)
[11:01:20.415]                           }
[11:01:20.415]                           base::stop(msg)
[11:01:20.415]                         }
[11:01:20.415]                       })
[11:01:20.415]                     }
[11:01:20.415]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:20.415]                     base::options(mc.cores = 1L)
[11:01:20.415]                   }
[11:01:20.415]                   ...future.strategy.old <- future::plan("list")
[11:01:20.415]                   options(future.plan = NULL)
[11:01:20.415]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.415]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.415]                 }
[11:01:20.415]                 ...future.workdir <- getwd()
[11:01:20.415]             }
[11:01:20.415]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.415]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.415]         }
[11:01:20.415]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.415]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.415]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.415]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.415]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.415]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.415]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.415]             base::names(...future.oldOptions))
[11:01:20.415]     }
[11:01:20.415]     if (FALSE) {
[11:01:20.415]     }
[11:01:20.415]     else {
[11:01:20.415]         if (TRUE) {
[11:01:20.415]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.415]                 open = "w")
[11:01:20.415]         }
[11:01:20.415]         else {
[11:01:20.415]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.415]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.415]         }
[11:01:20.415]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.415]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.415]             base::sink(type = "output", split = FALSE)
[11:01:20.415]             base::close(...future.stdout)
[11:01:20.415]         }, add = TRUE)
[11:01:20.415]     }
[11:01:20.415]     ...future.frame <- base::sys.nframe()
[11:01:20.415]     ...future.conditions <- base::list()
[11:01:20.415]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.415]     if (FALSE) {
[11:01:20.415]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.415]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.415]     }
[11:01:20.415]     ...future.result <- base::tryCatch({
[11:01:20.415]         base::withCallingHandlers({
[11:01:20.415]             ...future.value <- base::withVisible(base::local({
[11:01:20.415]                 withCallingHandlers({
[11:01:20.415]                   1
[11:01:20.415]                 }, immediateCondition = function(cond) {
[11:01:20.415]                   save_rds <- function (object, pathname, ...) 
[11:01:20.415]                   {
[11:01:20.415]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:20.415]                     if (file_test("-f", pathname_tmp)) {
[11:01:20.415]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.415]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:20.415]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.415]                         fi_tmp[["mtime"]])
[11:01:20.415]                     }
[11:01:20.415]                     tryCatch({
[11:01:20.415]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:20.415]                     }, error = function(ex) {
[11:01:20.415]                       msg <- conditionMessage(ex)
[11:01:20.415]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.415]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:20.415]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.415]                         fi_tmp[["mtime"]], msg)
[11:01:20.415]                       ex$message <- msg
[11:01:20.415]                       stop(ex)
[11:01:20.415]                     })
[11:01:20.415]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:20.415]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:20.415]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:20.415]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.415]                       fi <- file.info(pathname)
[11:01:20.415]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:20.415]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.415]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:20.415]                         fi[["size"]], fi[["mtime"]])
[11:01:20.415]                       stop(msg)
[11:01:20.415]                     }
[11:01:20.415]                     invisible(pathname)
[11:01:20.415]                   }
[11:01:20.415]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:20.415]                     rootPath = tempdir()) 
[11:01:20.415]                   {
[11:01:20.415]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:20.415]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:20.415]                       tmpdir = path, fileext = ".rds")
[11:01:20.415]                     save_rds(obj, file)
[11:01:20.415]                   }
[11:01:20.415]                   saveImmediateCondition(cond, path = "/tmp/RtmpxWUrEc/.future/immediateConditions")
[11:01:20.415]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.415]                   {
[11:01:20.415]                     inherits <- base::inherits
[11:01:20.415]                     invokeRestart <- base::invokeRestart
[11:01:20.415]                     is.null <- base::is.null
[11:01:20.415]                     muffled <- FALSE
[11:01:20.415]                     if (inherits(cond, "message")) {
[11:01:20.415]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:20.415]                       if (muffled) 
[11:01:20.415]                         invokeRestart("muffleMessage")
[11:01:20.415]                     }
[11:01:20.415]                     else if (inherits(cond, "warning")) {
[11:01:20.415]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:20.415]                       if (muffled) 
[11:01:20.415]                         invokeRestart("muffleWarning")
[11:01:20.415]                     }
[11:01:20.415]                     else if (inherits(cond, "condition")) {
[11:01:20.415]                       if (!is.null(pattern)) {
[11:01:20.415]                         computeRestarts <- base::computeRestarts
[11:01:20.415]                         grepl <- base::grepl
[11:01:20.415]                         restarts <- computeRestarts(cond)
[11:01:20.415]                         for (restart in restarts) {
[11:01:20.415]                           name <- restart$name
[11:01:20.415]                           if (is.null(name)) 
[11:01:20.415]                             next
[11:01:20.415]                           if (!grepl(pattern, name)) 
[11:01:20.415]                             next
[11:01:20.415]                           invokeRestart(restart)
[11:01:20.415]                           muffled <- TRUE
[11:01:20.415]                           break
[11:01:20.415]                         }
[11:01:20.415]                       }
[11:01:20.415]                     }
[11:01:20.415]                     invisible(muffled)
[11:01:20.415]                   }
[11:01:20.415]                   muffleCondition(cond)
[11:01:20.415]                 })
[11:01:20.415]             }))
[11:01:20.415]             future::FutureResult(value = ...future.value$value, 
[11:01:20.415]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.415]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.415]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.415]                     ...future.globalenv.names))
[11:01:20.415]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.415]         }, condition = base::local({
[11:01:20.415]             c <- base::c
[11:01:20.415]             inherits <- base::inherits
[11:01:20.415]             invokeRestart <- base::invokeRestart
[11:01:20.415]             length <- base::length
[11:01:20.415]             list <- base::list
[11:01:20.415]             seq.int <- base::seq.int
[11:01:20.415]             signalCondition <- base::signalCondition
[11:01:20.415]             sys.calls <- base::sys.calls
[11:01:20.415]             `[[` <- base::`[[`
[11:01:20.415]             `+` <- base::`+`
[11:01:20.415]             `<<-` <- base::`<<-`
[11:01:20.415]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.415]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.415]                   3L)]
[11:01:20.415]             }
[11:01:20.415]             function(cond) {
[11:01:20.415]                 is_error <- inherits(cond, "error")
[11:01:20.415]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.415]                   NULL)
[11:01:20.415]                 if (is_error) {
[11:01:20.415]                   sessionInformation <- function() {
[11:01:20.415]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.415]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.415]                       search = base::search(), system = base::Sys.info())
[11:01:20.415]                   }
[11:01:20.415]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.415]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.415]                     cond$call), session = sessionInformation(), 
[11:01:20.415]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.415]                   signalCondition(cond)
[11:01:20.415]                 }
[11:01:20.415]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.415]                 "immediateCondition"))) {
[11:01:20.415]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.415]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.415]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.415]                   if (TRUE && !signal) {
[11:01:20.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.415]                     {
[11:01:20.415]                       inherits <- base::inherits
[11:01:20.415]                       invokeRestart <- base::invokeRestart
[11:01:20.415]                       is.null <- base::is.null
[11:01:20.415]                       muffled <- FALSE
[11:01:20.415]                       if (inherits(cond, "message")) {
[11:01:20.415]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.415]                         if (muffled) 
[11:01:20.415]                           invokeRestart("muffleMessage")
[11:01:20.415]                       }
[11:01:20.415]                       else if (inherits(cond, "warning")) {
[11:01:20.415]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.415]                         if (muffled) 
[11:01:20.415]                           invokeRestart("muffleWarning")
[11:01:20.415]                       }
[11:01:20.415]                       else if (inherits(cond, "condition")) {
[11:01:20.415]                         if (!is.null(pattern)) {
[11:01:20.415]                           computeRestarts <- base::computeRestarts
[11:01:20.415]                           grepl <- base::grepl
[11:01:20.415]                           restarts <- computeRestarts(cond)
[11:01:20.415]                           for (restart in restarts) {
[11:01:20.415]                             name <- restart$name
[11:01:20.415]                             if (is.null(name)) 
[11:01:20.415]                               next
[11:01:20.415]                             if (!grepl(pattern, name)) 
[11:01:20.415]                               next
[11:01:20.415]                             invokeRestart(restart)
[11:01:20.415]                             muffled <- TRUE
[11:01:20.415]                             break
[11:01:20.415]                           }
[11:01:20.415]                         }
[11:01:20.415]                       }
[11:01:20.415]                       invisible(muffled)
[11:01:20.415]                     }
[11:01:20.415]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.415]                   }
[11:01:20.415]                 }
[11:01:20.415]                 else {
[11:01:20.415]                   if (TRUE) {
[11:01:20.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.415]                     {
[11:01:20.415]                       inherits <- base::inherits
[11:01:20.415]                       invokeRestart <- base::invokeRestart
[11:01:20.415]                       is.null <- base::is.null
[11:01:20.415]                       muffled <- FALSE
[11:01:20.415]                       if (inherits(cond, "message")) {
[11:01:20.415]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.415]                         if (muffled) 
[11:01:20.415]                           invokeRestart("muffleMessage")
[11:01:20.415]                       }
[11:01:20.415]                       else if (inherits(cond, "warning")) {
[11:01:20.415]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.415]                         if (muffled) 
[11:01:20.415]                           invokeRestart("muffleWarning")
[11:01:20.415]                       }
[11:01:20.415]                       else if (inherits(cond, "condition")) {
[11:01:20.415]                         if (!is.null(pattern)) {
[11:01:20.415]                           computeRestarts <- base::computeRestarts
[11:01:20.415]                           grepl <- base::grepl
[11:01:20.415]                           restarts <- computeRestarts(cond)
[11:01:20.415]                           for (restart in restarts) {
[11:01:20.415]                             name <- restart$name
[11:01:20.415]                             if (is.null(name)) 
[11:01:20.415]                               next
[11:01:20.415]                             if (!grepl(pattern, name)) 
[11:01:20.415]                               next
[11:01:20.415]                             invokeRestart(restart)
[11:01:20.415]                             muffled <- TRUE
[11:01:20.415]                             break
[11:01:20.415]                           }
[11:01:20.415]                         }
[11:01:20.415]                       }
[11:01:20.415]                       invisible(muffled)
[11:01:20.415]                     }
[11:01:20.415]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.415]                   }
[11:01:20.415]                 }
[11:01:20.415]             }
[11:01:20.415]         }))
[11:01:20.415]     }, error = function(ex) {
[11:01:20.415]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.415]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.415]                 ...future.rng), started = ...future.startTime, 
[11:01:20.415]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.415]             version = "1.8"), class = "FutureResult")
[11:01:20.415]     }, finally = {
[11:01:20.415]         if (!identical(...future.workdir, getwd())) 
[11:01:20.415]             setwd(...future.workdir)
[11:01:20.415]         {
[11:01:20.415]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.415]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.415]             }
[11:01:20.415]             base::options(...future.oldOptions)
[11:01:20.415]             if (.Platform$OS.type == "windows") {
[11:01:20.415]                 old_names <- names(...future.oldEnvVars)
[11:01:20.415]                 envs <- base::Sys.getenv()
[11:01:20.415]                 names <- names(envs)
[11:01:20.415]                 common <- intersect(names, old_names)
[11:01:20.415]                 added <- setdiff(names, old_names)
[11:01:20.415]                 removed <- setdiff(old_names, names)
[11:01:20.415]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.415]                   envs[common]]
[11:01:20.415]                 NAMES <- toupper(changed)
[11:01:20.415]                 args <- list()
[11:01:20.415]                 for (kk in seq_along(NAMES)) {
[11:01:20.415]                   name <- changed[[kk]]
[11:01:20.415]                   NAME <- NAMES[[kk]]
[11:01:20.415]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.415]                     next
[11:01:20.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.415]                 }
[11:01:20.415]                 NAMES <- toupper(added)
[11:01:20.415]                 for (kk in seq_along(NAMES)) {
[11:01:20.415]                   name <- added[[kk]]
[11:01:20.415]                   NAME <- NAMES[[kk]]
[11:01:20.415]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.415]                     next
[11:01:20.415]                   args[[name]] <- ""
[11:01:20.415]                 }
[11:01:20.415]                 NAMES <- toupper(removed)
[11:01:20.415]                 for (kk in seq_along(NAMES)) {
[11:01:20.415]                   name <- removed[[kk]]
[11:01:20.415]                   NAME <- NAMES[[kk]]
[11:01:20.415]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.415]                     next
[11:01:20.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.415]                 }
[11:01:20.415]                 if (length(args) > 0) 
[11:01:20.415]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.415]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.415]             }
[11:01:20.415]             else {
[11:01:20.415]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.415]             }
[11:01:20.415]             {
[11:01:20.415]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.415]                   0L) {
[11:01:20.415]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.415]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.415]                   base::options(opts)
[11:01:20.415]                 }
[11:01:20.415]                 {
[11:01:20.415]                   {
[11:01:20.415]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:20.415]                     NULL
[11:01:20.415]                   }
[11:01:20.415]                   options(future.plan = NULL)
[11:01:20.415]                   if (is.na(NA_character_)) 
[11:01:20.415]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.415]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.415]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.415]                     .init = FALSE)
[11:01:20.415]                 }
[11:01:20.415]             }
[11:01:20.415]         }
[11:01:20.415]     })
[11:01:20.415]     if (TRUE) {
[11:01:20.415]         base::sink(type = "output", split = FALSE)
[11:01:20.415]         if (TRUE) {
[11:01:20.415]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.415]         }
[11:01:20.415]         else {
[11:01:20.415]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.415]         }
[11:01:20.415]         base::close(...future.stdout)
[11:01:20.415]         ...future.stdout <- NULL
[11:01:20.415]     }
[11:01:20.415]     ...future.result$conditions <- ...future.conditions
[11:01:20.415]     ...future.result$finished <- base::Sys.time()
[11:01:20.415]     ...future.result
[11:01:20.415] }
[11:01:20.418] requestCore(): workers = 2
[11:01:20.419] MulticoreFuture started
[11:01:20.420] - Launch lazy future ... done
[11:01:20.420] run() for ‘MulticoreFuture’ ... done
[11:01:20.420] plan(): Setting new future strategy stack:
[11:01:20.421] result() for MulticoreFuture ...
[11:01:20.421] List of future strategies:
[11:01:20.421] 1. sequential:
[11:01:20.421]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.421]    - tweaked: FALSE
[11:01:20.421]    - call: NULL
[11:01:20.422] plan(): nbrOfWorkers() = 1
[11:01:20.424] plan(): Setting new future strategy stack:
[11:01:20.424] List of future strategies:
[11:01:20.424] 1. multicore:
[11:01:20.424]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:20.424]    - tweaked: FALSE
[11:01:20.424]    - call: plan(strategy)
[11:01:20.427] plan(): nbrOfWorkers() = 2
[11:01:20.428] result() for MulticoreFuture ...
[11:01:20.428] result() for MulticoreFuture ... done
[11:01:20.428] result() for MulticoreFuture ... done
[11:01:20.428] result() for MulticoreFuture ...
[11:01:20.428] result() for MulticoreFuture ... done
d = 1
** Nested future assignments
[11:01:20.429] getGlobalsAndPackages() ...
[11:01:20.429] Searching for globals...
[11:01:20.434] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[11:01:20.434] Searching for globals ... DONE
[11:01:20.434] Resolving globals: FALSE
[11:01:20.435] 
[11:01:20.435] - packages: [1] ‘future’
[11:01:20.435] getGlobalsAndPackages() ... DONE
[11:01:20.435] run() for ‘Future’ ...
[11:01:20.435] - state: ‘created’
[11:01:20.436] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:20.438] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:20.438] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:20.438]   - Field: ‘label’
[11:01:20.438]   - Field: ‘local’
[11:01:20.438]   - Field: ‘owner’
[11:01:20.438]   - Field: ‘envir’
[11:01:20.438]   - Field: ‘workers’
[11:01:20.438]   - Field: ‘packages’
[11:01:20.438]   - Field: ‘gc’
[11:01:20.439]   - Field: ‘job’
[11:01:20.439]   - Field: ‘conditions’
[11:01:20.439]   - Field: ‘expr’
[11:01:20.439]   - Field: ‘uuid’
[11:01:20.439]   - Field: ‘seed’
[11:01:20.439]   - Field: ‘version’
[11:01:20.439]   - Field: ‘result’
[11:01:20.439]   - Field: ‘asynchronous’
[11:01:20.439]   - Field: ‘calls’
[11:01:20.440]   - Field: ‘globals’
[11:01:20.440]   - Field: ‘stdout’
[11:01:20.440]   - Field: ‘earlySignal’
[11:01:20.440]   - Field: ‘lazy’
[11:01:20.440]   - Field: ‘state’
[11:01:20.440] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:20.440] - Launch lazy future ...
[11:01:20.441] Packages needed by the future expression (n = 1): ‘future’
[11:01:20.441] Packages needed by future strategies (n = 0): <none>
[11:01:20.441] {
[11:01:20.441]     {
[11:01:20.441]         {
[11:01:20.441]             ...future.startTime <- base::Sys.time()
[11:01:20.441]             {
[11:01:20.441]                 {
[11:01:20.441]                   {
[11:01:20.441]                     {
[11:01:20.441]                       {
[11:01:20.441]                         base::local({
[11:01:20.441]                           has_future <- base::requireNamespace("future", 
[11:01:20.441]                             quietly = TRUE)
[11:01:20.441]                           if (has_future) {
[11:01:20.441]                             ns <- base::getNamespace("future")
[11:01:20.441]                             version <- ns[[".package"]][["version"]]
[11:01:20.441]                             if (is.null(version)) 
[11:01:20.441]                               version <- utils::packageVersion("future")
[11:01:20.441]                           }
[11:01:20.441]                           else {
[11:01:20.441]                             version <- NULL
[11:01:20.441]                           }
[11:01:20.441]                           if (!has_future || version < "1.8.0") {
[11:01:20.441]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.441]                               "", base::R.version$version.string), 
[11:01:20.441]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:20.441]                                 base::R.version$platform, 8 * 
[11:01:20.441]                                   base::.Machine$sizeof.pointer), 
[11:01:20.441]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.441]                                 "release", "version")], collapse = " "), 
[11:01:20.441]                               hostname = base::Sys.info()[["nodename"]])
[11:01:20.441]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.441]                               info)
[11:01:20.441]                             info <- base::paste(info, collapse = "; ")
[11:01:20.441]                             if (!has_future) {
[11:01:20.441]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.441]                                 info)
[11:01:20.441]                             }
[11:01:20.441]                             else {
[11:01:20.441]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.441]                                 info, version)
[11:01:20.441]                             }
[11:01:20.441]                             base::stop(msg)
[11:01:20.441]                           }
[11:01:20.441]                         })
[11:01:20.441]                       }
[11:01:20.441]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:20.441]                       base::options(mc.cores = 1L)
[11:01:20.441]                     }
[11:01:20.441]                     base::local({
[11:01:20.441]                       for (pkg in "future") {
[11:01:20.441]                         base::loadNamespace(pkg)
[11:01:20.441]                         base::library(pkg, character.only = TRUE)
[11:01:20.441]                       }
[11:01:20.441]                     })
[11:01:20.441]                   }
[11:01:20.441]                   ...future.strategy.old <- future::plan("list")
[11:01:20.441]                   options(future.plan = NULL)
[11:01:20.441]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.441]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.441]                 }
[11:01:20.441]                 ...future.workdir <- getwd()
[11:01:20.441]             }
[11:01:20.441]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.441]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.441]         }
[11:01:20.441]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.441]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.441]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.441]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.441]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.441]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.441]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.441]             base::names(...future.oldOptions))
[11:01:20.441]     }
[11:01:20.441]     if (FALSE) {
[11:01:20.441]     }
[11:01:20.441]     else {
[11:01:20.441]         if (TRUE) {
[11:01:20.441]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.441]                 open = "w")
[11:01:20.441]         }
[11:01:20.441]         else {
[11:01:20.441]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.441]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.441]         }
[11:01:20.441]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.441]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.441]             base::sink(type = "output", split = FALSE)
[11:01:20.441]             base::close(...future.stdout)
[11:01:20.441]         }, add = TRUE)
[11:01:20.441]     }
[11:01:20.441]     ...future.frame <- base::sys.nframe()
[11:01:20.441]     ...future.conditions <- base::list()
[11:01:20.441]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.441]     if (FALSE) {
[11:01:20.441]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.441]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.441]     }
[11:01:20.441]     ...future.result <- base::tryCatch({
[11:01:20.441]         base::withCallingHandlers({
[11:01:20.441]             ...future.value <- base::withVisible(base::local({
[11:01:20.441]                 withCallingHandlers({
[11:01:20.441]                   {
[11:01:20.441]                     b <- 1
[11:01:20.441]                     c %<-% 2
[11:01:20.441]                     d <- 3
[11:01:20.441]                     4 %->% e
[11:01:20.441]                     b + c + d + e
[11:01:20.441]                   }
[11:01:20.441]                 }, immediateCondition = function(cond) {
[11:01:20.441]                   save_rds <- function (object, pathname, ...) 
[11:01:20.441]                   {
[11:01:20.441]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:20.441]                     if (file_test("-f", pathname_tmp)) {
[11:01:20.441]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.441]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:20.441]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.441]                         fi_tmp[["mtime"]])
[11:01:20.441]                     }
[11:01:20.441]                     tryCatch({
[11:01:20.441]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:20.441]                     }, error = function(ex) {
[11:01:20.441]                       msg <- conditionMessage(ex)
[11:01:20.441]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.441]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:20.441]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.441]                         fi_tmp[["mtime"]], msg)
[11:01:20.441]                       ex$message <- msg
[11:01:20.441]                       stop(ex)
[11:01:20.441]                     })
[11:01:20.441]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:20.441]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:20.441]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:20.441]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.441]                       fi <- file.info(pathname)
[11:01:20.441]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:20.441]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.441]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:20.441]                         fi[["size"]], fi[["mtime"]])
[11:01:20.441]                       stop(msg)
[11:01:20.441]                     }
[11:01:20.441]                     invisible(pathname)
[11:01:20.441]                   }
[11:01:20.441]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:20.441]                     rootPath = tempdir()) 
[11:01:20.441]                   {
[11:01:20.441]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:20.441]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:20.441]                       tmpdir = path, fileext = ".rds")
[11:01:20.441]                     save_rds(obj, file)
[11:01:20.441]                   }
[11:01:20.441]                   saveImmediateCondition(cond, path = "/tmp/RtmpxWUrEc/.future/immediateConditions")
[11:01:20.441]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.441]                   {
[11:01:20.441]                     inherits <- base::inherits
[11:01:20.441]                     invokeRestart <- base::invokeRestart
[11:01:20.441]                     is.null <- base::is.null
[11:01:20.441]                     muffled <- FALSE
[11:01:20.441]                     if (inherits(cond, "message")) {
[11:01:20.441]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:20.441]                       if (muffled) 
[11:01:20.441]                         invokeRestart("muffleMessage")
[11:01:20.441]                     }
[11:01:20.441]                     else if (inherits(cond, "warning")) {
[11:01:20.441]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:20.441]                       if (muffled) 
[11:01:20.441]                         invokeRestart("muffleWarning")
[11:01:20.441]                     }
[11:01:20.441]                     else if (inherits(cond, "condition")) {
[11:01:20.441]                       if (!is.null(pattern)) {
[11:01:20.441]                         computeRestarts <- base::computeRestarts
[11:01:20.441]                         grepl <- base::grepl
[11:01:20.441]                         restarts <- computeRestarts(cond)
[11:01:20.441]                         for (restart in restarts) {
[11:01:20.441]                           name <- restart$name
[11:01:20.441]                           if (is.null(name)) 
[11:01:20.441]                             next
[11:01:20.441]                           if (!grepl(pattern, name)) 
[11:01:20.441]                             next
[11:01:20.441]                           invokeRestart(restart)
[11:01:20.441]                           muffled <- TRUE
[11:01:20.441]                           break
[11:01:20.441]                         }
[11:01:20.441]                       }
[11:01:20.441]                     }
[11:01:20.441]                     invisible(muffled)
[11:01:20.441]                   }
[11:01:20.441]                   muffleCondition(cond)
[11:01:20.441]                 })
[11:01:20.441]             }))
[11:01:20.441]             future::FutureResult(value = ...future.value$value, 
[11:01:20.441]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.441]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.441]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.441]                     ...future.globalenv.names))
[11:01:20.441]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.441]         }, condition = base::local({
[11:01:20.441]             c <- base::c
[11:01:20.441]             inherits <- base::inherits
[11:01:20.441]             invokeRestart <- base::invokeRestart
[11:01:20.441]             length <- base::length
[11:01:20.441]             list <- base::list
[11:01:20.441]             seq.int <- base::seq.int
[11:01:20.441]             signalCondition <- base::signalCondition
[11:01:20.441]             sys.calls <- base::sys.calls
[11:01:20.441]             `[[` <- base::`[[`
[11:01:20.441]             `+` <- base::`+`
[11:01:20.441]             `<<-` <- base::`<<-`
[11:01:20.441]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.441]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.441]                   3L)]
[11:01:20.441]             }
[11:01:20.441]             function(cond) {
[11:01:20.441]                 is_error <- inherits(cond, "error")
[11:01:20.441]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.441]                   NULL)
[11:01:20.441]                 if (is_error) {
[11:01:20.441]                   sessionInformation <- function() {
[11:01:20.441]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.441]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.441]                       search = base::search(), system = base::Sys.info())
[11:01:20.441]                   }
[11:01:20.441]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.441]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.441]                     cond$call), session = sessionInformation(), 
[11:01:20.441]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.441]                   signalCondition(cond)
[11:01:20.441]                 }
[11:01:20.441]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.441]                 "immediateCondition"))) {
[11:01:20.441]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.441]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.441]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.441]                   if (TRUE && !signal) {
[11:01:20.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.441]                     {
[11:01:20.441]                       inherits <- base::inherits
[11:01:20.441]                       invokeRestart <- base::invokeRestart
[11:01:20.441]                       is.null <- base::is.null
[11:01:20.441]                       muffled <- FALSE
[11:01:20.441]                       if (inherits(cond, "message")) {
[11:01:20.441]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.441]                         if (muffled) 
[11:01:20.441]                           invokeRestart("muffleMessage")
[11:01:20.441]                       }
[11:01:20.441]                       else if (inherits(cond, "warning")) {
[11:01:20.441]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.441]                         if (muffled) 
[11:01:20.441]                           invokeRestart("muffleWarning")
[11:01:20.441]                       }
[11:01:20.441]                       else if (inherits(cond, "condition")) {
[11:01:20.441]                         if (!is.null(pattern)) {
[11:01:20.441]                           computeRestarts <- base::computeRestarts
[11:01:20.441]                           grepl <- base::grepl
[11:01:20.441]                           restarts <- computeRestarts(cond)
[11:01:20.441]                           for (restart in restarts) {
[11:01:20.441]                             name <- restart$name
[11:01:20.441]                             if (is.null(name)) 
[11:01:20.441]                               next
[11:01:20.441]                             if (!grepl(pattern, name)) 
[11:01:20.441]                               next
[11:01:20.441]                             invokeRestart(restart)
[11:01:20.441]                             muffled <- TRUE
[11:01:20.441]                             break
[11:01:20.441]                           }
[11:01:20.441]                         }
[11:01:20.441]                       }
[11:01:20.441]                       invisible(muffled)
[11:01:20.441]                     }
[11:01:20.441]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.441]                   }
[11:01:20.441]                 }
[11:01:20.441]                 else {
[11:01:20.441]                   if (TRUE) {
[11:01:20.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.441]                     {
[11:01:20.441]                       inherits <- base::inherits
[11:01:20.441]                       invokeRestart <- base::invokeRestart
[11:01:20.441]                       is.null <- base::is.null
[11:01:20.441]                       muffled <- FALSE
[11:01:20.441]                       if (inherits(cond, "message")) {
[11:01:20.441]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.441]                         if (muffled) 
[11:01:20.441]                           invokeRestart("muffleMessage")
[11:01:20.441]                       }
[11:01:20.441]                       else if (inherits(cond, "warning")) {
[11:01:20.441]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.441]                         if (muffled) 
[11:01:20.441]                           invokeRestart("muffleWarning")
[11:01:20.441]                       }
[11:01:20.441]                       else if (inherits(cond, "condition")) {
[11:01:20.441]                         if (!is.null(pattern)) {
[11:01:20.441]                           computeRestarts <- base::computeRestarts
[11:01:20.441]                           grepl <- base::grepl
[11:01:20.441]                           restarts <- computeRestarts(cond)
[11:01:20.441]                           for (restart in restarts) {
[11:01:20.441]                             name <- restart$name
[11:01:20.441]                             if (is.null(name)) 
[11:01:20.441]                               next
[11:01:20.441]                             if (!grepl(pattern, name)) 
[11:01:20.441]                               next
[11:01:20.441]                             invokeRestart(restart)
[11:01:20.441]                             muffled <- TRUE
[11:01:20.441]                             break
[11:01:20.441]                           }
[11:01:20.441]                         }
[11:01:20.441]                       }
[11:01:20.441]                       invisible(muffled)
[11:01:20.441]                     }
[11:01:20.441]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.441]                   }
[11:01:20.441]                 }
[11:01:20.441]             }
[11:01:20.441]         }))
[11:01:20.441]     }, error = function(ex) {
[11:01:20.441]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.441]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.441]                 ...future.rng), started = ...future.startTime, 
[11:01:20.441]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.441]             version = "1.8"), class = "FutureResult")
[11:01:20.441]     }, finally = {
[11:01:20.441]         if (!identical(...future.workdir, getwd())) 
[11:01:20.441]             setwd(...future.workdir)
[11:01:20.441]         {
[11:01:20.441]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.441]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.441]             }
[11:01:20.441]             base::options(...future.oldOptions)
[11:01:20.441]             if (.Platform$OS.type == "windows") {
[11:01:20.441]                 old_names <- names(...future.oldEnvVars)
[11:01:20.441]                 envs <- base::Sys.getenv()
[11:01:20.441]                 names <- names(envs)
[11:01:20.441]                 common <- intersect(names, old_names)
[11:01:20.441]                 added <- setdiff(names, old_names)
[11:01:20.441]                 removed <- setdiff(old_names, names)
[11:01:20.441]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.441]                   envs[common]]
[11:01:20.441]                 NAMES <- toupper(changed)
[11:01:20.441]                 args <- list()
[11:01:20.441]                 for (kk in seq_along(NAMES)) {
[11:01:20.441]                   name <- changed[[kk]]
[11:01:20.441]                   NAME <- NAMES[[kk]]
[11:01:20.441]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.441]                     next
[11:01:20.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.441]                 }
[11:01:20.441]                 NAMES <- toupper(added)
[11:01:20.441]                 for (kk in seq_along(NAMES)) {
[11:01:20.441]                   name <- added[[kk]]
[11:01:20.441]                   NAME <- NAMES[[kk]]
[11:01:20.441]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.441]                     next
[11:01:20.441]                   args[[name]] <- ""
[11:01:20.441]                 }
[11:01:20.441]                 NAMES <- toupper(removed)
[11:01:20.441]                 for (kk in seq_along(NAMES)) {
[11:01:20.441]                   name <- removed[[kk]]
[11:01:20.441]                   NAME <- NAMES[[kk]]
[11:01:20.441]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.441]                     next
[11:01:20.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.441]                 }
[11:01:20.441]                 if (length(args) > 0) 
[11:01:20.441]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.441]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.441]             }
[11:01:20.441]             else {
[11:01:20.441]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.441]             }
[11:01:20.441]             {
[11:01:20.441]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.441]                   0L) {
[11:01:20.441]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.441]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.441]                   base::options(opts)
[11:01:20.441]                 }
[11:01:20.441]                 {
[11:01:20.441]                   {
[11:01:20.441]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:20.441]                     NULL
[11:01:20.441]                   }
[11:01:20.441]                   options(future.plan = NULL)
[11:01:20.441]                   if (is.na(NA_character_)) 
[11:01:20.441]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.441]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.441]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.441]                     .init = FALSE)
[11:01:20.441]                 }
[11:01:20.441]             }
[11:01:20.441]         }
[11:01:20.441]     })
[11:01:20.441]     if (TRUE) {
[11:01:20.441]         base::sink(type = "output", split = FALSE)
[11:01:20.441]         if (TRUE) {
[11:01:20.441]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.441]         }
[11:01:20.441]         else {
[11:01:20.441]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.441]         }
[11:01:20.441]         base::close(...future.stdout)
[11:01:20.441]         ...future.stdout <- NULL
[11:01:20.441]     }
[11:01:20.441]     ...future.result$conditions <- ...future.conditions
[11:01:20.441]     ...future.result$finished <- base::Sys.time()
[11:01:20.441]     ...future.result
[11:01:20.441] }
[11:01:20.444] requestCore(): workers = 2
[11:01:20.446] MulticoreFuture started
[11:01:20.446] - Launch lazy future ... done
[11:01:20.446] run() for ‘MulticoreFuture’ ... done
[11:01:20.446] result() for MulticoreFuture ...
[11:01:20.447] plan(): Setting new future strategy stack:
[11:01:20.447] List of future strategies:
[11:01:20.447] 1. sequential:
[11:01:20.447]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.447]    - tweaked: FALSE
[11:01:20.447]    - call: NULL
[11:01:20.448] plan(): nbrOfWorkers() = 1
[11:01:20.481] plan(): Setting new future strategy stack:
[11:01:20.481] List of future strategies:
[11:01:20.481] 1. multicore:
[11:01:20.481]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:20.481]    - tweaked: FALSE
[11:01:20.481]    - call: plan(strategy)
[11:01:20.484] plan(): nbrOfWorkers() = 2
[11:01:20.485] result() for MulticoreFuture ...
[11:01:20.485] result() for MulticoreFuture ... done
[11:01:20.485] signalConditions() ...
[11:01:20.486]  - include = ‘immediateCondition’
[11:01:20.486]  - exclude = 
[11:01:20.486]  - resignal = FALSE
[11:01:20.486]  - Number of conditions: 88
[11:01:20.486] signalConditions() ... done
[11:01:20.486] result() for MulticoreFuture ... done
[11:01:20.486] result() for MulticoreFuture ...
[11:01:20.486] result() for MulticoreFuture ... done
[11:01:20.487] signalConditions() ...
[11:01:20.487]  - include = ‘immediateCondition’
[11:01:20.487]  - exclude = 
[11:01:20.487]  - resignal = FALSE
[11:01:20.487]  - Number of conditions: 88
[11:01:20.487] signalConditions() ... done
[11:01:20.487] Future state: ‘finished’
[11:01:20.487] result() for MulticoreFuture ...
[11:01:20.488] result() for MulticoreFuture ... done
[11:01:20.488] signalConditions() ...
[11:01:20.488]  - include = ‘condition’
[11:01:20.488]  - exclude = ‘immediateCondition’
[11:01:20.488]  - resignal = TRUE
[11:01:20.488]  - Number of conditions: 88
[11:01:20.488]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.449] getGlobalsAndPackages() ...
[11:01:20.488]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.449] Searching for globals...
[11:01:20.488]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.450] 
[11:01:20.489]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.450] Searching for globals ... DONE
[11:01:20.489]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.450] - globals: [0] <none>
[11:01:20.489]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.451] getGlobalsAndPackages() ... DONE
[11:01:20.489]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.451] run() for ‘Future’ ...
[11:01:20.489]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.452] - state: ‘created’
[11:01:20.489]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.452] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:20.492]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.452] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:20.492]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.452] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:20.492]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.453]   - Field: ‘label’
[11:01:20.492]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.453]   - Field: ‘local’
[11:01:20.493]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.453]   - Field: ‘owner’
[11:01:20.493]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.453]   - Field: ‘envir’
[11:01:20.493]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.453]   - Field: ‘packages’
[11:01:20.493]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.454]   - Field: ‘gc’
[11:01:20.494]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.454]   - Field: ‘conditions’
[11:01:20.494]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.454]   - Field: ‘expr’
[11:01:20.494]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.454]   - Field: ‘uuid’
[11:01:20.494]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.454]   - Field: ‘seed’
[11:01:20.494]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.454]   - Field: ‘version’
[11:01:20.494]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.455]   - Field: ‘result’
[11:01:20.495]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.455]   - Field: ‘asynchronous’
[11:01:20.495]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.459]   - Field: ‘calls’
[11:01:20.495]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.459]   - Field: ‘globals’
[11:01:20.495]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.459]   - Field: ‘stdout’
[11:01:20.495]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.459]   - Field: ‘earlySignal’
[11:01:20.495]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.459]   - Field: ‘lazy’
[11:01:20.496]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.460]   - Field: ‘state’
[11:01:20.496]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.460] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:20.496]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.460] - Launch lazy future ...
[11:01:20.496]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.461] Packages needed by the future expression (n = 0): <none>
[11:01:20.496]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.461] Packages needed by future strategies (n = 0): <none>
[11:01:20.496]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.462] {
[11:01:20.462]     {
[11:01:20.462]         {
[11:01:20.462]             ...future.startTime <- base::Sys.time()
[11:01:20.462]             {
[11:01:20.462]                 {
[11:01:20.462]                   {
[11:01:20.462]                     base::local({
[11:01:20.462]                       has_future <- base::requireNamespace("future", 
[11:01:20.462]                         quietly = TRUE)
[11:01:20.462]                       if (has_future) {
[11:01:20.462]                         ns <- base::getNamespace("future")
[11:01:20.462]                         version <- ns[[".package"]][["version"]]
[11:01:20.462]                         if (is.null(version)) 
[11:01:20.462]                           version <- utils::packageVersion("future")
[11:01:20.462]                       }
[11:01:20.462]                       else {
[11:01:20.462]                         version <- NULL
[11:01:20.462]                       }
[11:01:20.462]                       if (!has_future || version < "1.8.0") {
[11:01:20.462]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.462]                           "", base::R.version$version.string), 
[11:01:20.462]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:20.462]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.462]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.462]                             "release", "version")], collapse = " "), 
[11:01:20.462]                           hostname = base::Sys.info()[["nodename"]])
[11:01:20.462]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.462]                           info)
[11:01:20.462]                         info <- base::paste(info, collapse = "; ")
[11:01:20.462]                         if (!has_future) {
[11:01:20.462]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.462]                             info)
[11:01:20.462]                         }
[11:01:20.462]                         else {
[11:01:20.462]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.462]                             info, version)
[11:01:20.462]                         }
[11:01:20.462]                         base::stop(msg)
[11:01:20.462]                       }
[11:01:20.462]                     })
[11:01:20.462]                   }
[11:01:20.462]                   ...future.strategy.old <- future::plan("list")
[11:01:20.462]                   options(future.plan = NULL)
[11:01:20.462]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.462]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.462]                 }
[11:01:20.462]                 ...future.workdir <- getwd()
[11:01:20.462]             }
[11:01:20.462]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.462]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.462]         }
[11:01:20.462]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.462]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.462]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.462]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.462]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.462]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.462]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.462]             base::names(...future.oldOptions))
[11:01:20.462]     }
[11:01:20.462]     if (FALSE) {
[11:01:20.462]     }
[11:01:20.462]     else {
[11:01:20.462]         if (TRUE) {
[11:01:20.462]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.462]                 open = "w")
[11:01:20.462]         }
[11:01:20.462]         else {
[11:01:20.462]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.462]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.462]         }
[11:01:20.462]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.462]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.462]             base::sink(type = "output", split = FALSE)
[11:01:20.462]             base::close(...future.stdout)
[11:01:20.462]         }, add = TRUE)
[11:01:20.462]     }
[11:01:20.462]     ...future.frame <- base::sys.nframe()
[11:01:20.462]     ...future.conditions <- base::list()
[11:01:20.462]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.462]     if (FALSE) {
[11:01:20.462]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.462]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.462]     }
[11:01:20.462]     ...future.result <- base::tryCatch({
[11:01:20.462]         base::withCallingHandlers({
[11:01:20.462]             ...future.value <- base::withVisible(base::local(2))
[11:01:20.462]             future::FutureResult(value = ...future.value$value, 
[11:01:20.462]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.462]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.462]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.462]                     ...future.globalenv.names))
[11:01:20.462]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.462]         }, condition = base::local({
[11:01:20.462]             c <- base::c
[11:01:20.462]             inherits <- base::inherits
[11:01:20.462]             invokeRestart <- base::invokeRestart
[11:01:20.462]             length <- base::length
[11:01:20.462]             list <- base::list
[11:01:20.462]             seq.int <- base::seq.int
[11:01:20.462]             signalCondition <- base::signalCondition
[11:01:20.462]             sys.calls <- base::sys.calls
[11:01:20.462]             `[[` <- base::`[[`
[11:01:20.462]             `+` <- base::`+`
[11:01:20.462]             `<<-` <- base::`<<-`
[11:01:20.462]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.462]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.462]                   3L)]
[11:01:20.462]             }
[11:01:20.462]             function(cond) {
[11:01:20.462]                 is_error <- inherits(cond, "error")
[11:01:20.462]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.462]                   NULL)
[11:01:20.462]                 if (is_error) {
[11:01:20.462]                   sessionInformation <- function() {
[11:01:20.462]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.462]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.462]                       search = base::search(), system = base::Sys.info())
[11:01:20.462]                   }
[11:01:20.462]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.462]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.462]                     cond$call), session = sessionInformation(), 
[11:01:20.462]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.462]                   signalCondition(cond)
[11:01:20.462]                 }
[11:01:20.462]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.462]                 "immediateCondition"))) {
[11:01:20.462]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.462]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.462]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.462]                   if (TRUE && !signal) {
[11:01:20.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.462]                     {
[11:01:20.462]                       inherits <- base::inherits
[11:01:20.462]                       invokeRestart <- base::invokeRestart
[11:01:20.462]                       is.null <- base::is.null
[11:01:20.462]                       muffled <- FALSE
[11:01:20.462]                       if (inherits(cond, "message")) {
[11:01:20.462]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.462]                         if (muffled) 
[11:01:20.462]                           invokeRestart("muffleMessage")
[11:01:20.462]                       }
[11:01:20.462]                       else if (inherits(cond, "warning")) {
[11:01:20.462]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.462]                         if (muffled) 
[11:01:20.462]                           invokeRestart("muffleWarning")
[11:01:20.462]                       }
[11:01:20.462]                       else if (inherits(cond, "condition")) {
[11:01:20.462]                         if (!is.null(pattern)) {
[11:01:20.462]                           computeRestarts <- base::computeRestarts
[11:01:20.462]                           grepl <- base::grepl
[11:01:20.462]                           restarts <- computeRestarts(cond)
[11:01:20.462]                           for (restart in restarts) {
[11:01:20.462]                             name <- restart$name
[11:01:20.462]                             if (is.null(name)) 
[11:01:20.462]                               next
[11:01:20.462]                             if (!grepl(pattern, name)) 
[11:01:20.462]                               next
[11:01:20.462]                             invokeRestart(restart)
[11:01:20.462]                             muffled <- TRUE
[11:01:20.462]                             break
[11:01:20.462]                           }
[11:01:20.462]                         }
[11:01:20.462]                       }
[11:01:20.462]                       invisible(muffled)
[11:01:20.462]                     }
[11:01:20.462]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.462]                   }
[11:01:20.462]                 }
[11:01:20.462]                 else {
[11:01:20.462]                   if (TRUE) {
[11:01:20.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.462]                     {
[11:01:20.462]                       inherits <- base::inherits
[11:01:20.462]                       invokeRestart <- base::invokeRestart
[11:01:20.462]                       is.null <- base::is.null
[11:01:20.462]                       muffled <- FALSE
[11:01:20.462]                       if (inherits(cond, "message")) {
[11:01:20.462]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.462]                         if (muffled) 
[11:01:20.462]                           invokeRestart("muffleMessage")
[11:01:20.462]                       }
[11:01:20.462]                       else if (inherits(cond, "warning")) {
[11:01:20.462]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.462]                         if (muffled) 
[11:01:20.462]                           invokeRestart("muffleWarning")
[11:01:20.462]                       }
[11:01:20.462]                       else if (inherits(cond, "condition")) {
[11:01:20.462]                         if (!is.null(pattern)) {
[11:01:20.462]                           computeRestarts <- base::computeRestarts
[11:01:20.462]                           grepl <- base::grepl
[11:01:20.462]                           restarts <- computeRestarts(cond)
[11:01:20.462]                           for (restart in restarts) {
[11:01:20.462]                             name <- restart$name
[11:01:20.462]                             if (is.null(name)) 
[11:01:20.462]                               next
[11:01:20.462]                             if (!grepl(pattern, name)) 
[11:01:20.462]                               next
[11:01:20.462]                             invokeRestart(restart)
[11:01:20.462]                             muffled <- TRUE
[11:01:20.462]                             break
[11:01:20.462]                           }
[11:01:20.462]                         }
[11:01:20.462]                       }
[11:01:20.462]                       invisible(muffled)
[11:01:20.462]                     }
[11:01:20.462]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.462]                   }
[11:01:20.462]                 }
[11:01:20.462]             }
[11:01:20.462]         }))
[11:01:20.462]     }, error = function(ex) {
[11:01:20.462]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.462]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.462]                 ...future.rng), started = ...future.startTime, 
[11:01:20.462]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.462]             version = "1.8"), class = "FutureResult")
[11:01:20.462]     }, finally = {
[11:01:20.462]         if (!identical(...future.workdir, getwd())) 
[11:01:20.462]             setwd(...future.workdir)
[11:01:20.462]         {
[11:01:20.462]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.462]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.462]             }
[11:01:20.462]             base::options(...future.oldOptions)
[11:01:20.462]             if (.Platform$OS.type == "windows") {
[11:01:20.462]                 old_names <- names(...future.oldEnvVars)
[11:01:20.462]                 envs <- base::Sys.getenv()
[11:01:20.462]                 names <- names(envs)
[11:01:20.462]                 common <- intersect(names, old_names)
[11:01:20.462]                 added <- setdiff(names, old_names)
[11:01:20.462]                 removed <- setdiff(old_names, names)
[11:01:20.462]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.462]                   envs[common]]
[11:01:20.462]                 NAMES <- toupper(changed)
[11:01:20.462]                 args <- list()
[11:01:20.462]                 for (kk in seq_along(NAMES)) {
[11:01:20.462]                   name <- changed[[kk]]
[11:01:20.462]                   NAME <- NAMES[[kk]]
[11:01:20.462]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.462]                     next
[11:01:20.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.462]                 }
[11:01:20.462]                 NAMES <- toupper(added)
[11:01:20.462]                 for (kk in seq_along(NAMES)) {
[11:01:20.462]                   name <- added[[kk]]
[11:01:20.462]                   NAME <- NAMES[[kk]]
[11:01:20.462]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.462]                     next
[11:01:20.462]                   args[[name]] <- ""
[11:01:20.462]                 }
[11:01:20.462]                 NAMES <- toupper(removed)
[11:01:20.462]                 for (kk in seq_along(NAMES)) {
[11:01:20.462]                   name <- removed[[kk]]
[11:01:20.462]                   NAME <- NAMES[[kk]]
[11:01:20.462]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.462]                     next
[11:01:20.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.462]                 }
[11:01:20.462]                 if (length(args) > 0) 
[11:01:20.462]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.462]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.462]             }
[11:01:20.462]             else {
[11:01:20.462]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.462]             }
[11:01:20.462]             {
[11:01:20.462]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.462]                   0L) {
[11:01:20.462]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.462]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.462]                   base::options(opts)
[11:01:20.462]                 }
[11:01:20.462]                 {
[11:01:20.462]                   {
[11:01:20.462]                     NULL
[11:01:20.462]                     RNGkind("Mersenne-Twister")
[11:01:20.462]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:20.462]                       inherits = FALSE)
[11:01:20.462]                   }
[11:01:20.462]                   options(future.plan = NULL)
[11:01:20.462]                   if (is.na(NA_character_)) 
[11:01:20.462]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.462]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.462]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.462]                     .init = FALSE)
[11:01:20.462]                 }
[11:01:20.462]             }
[11:01:20.462]         }
[11:01:20.462]     })
[11:01:20.462]     if (TRUE) {
[11:01:20.462]         base::sink(type = "output", split = FALSE)
[11:01:20.462]         if (TRUE) {
[11:01:20.462]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.462]         }
[11:01:20.462]         else {
[11:01:20.462]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.462]         }
[11:01:20.462]         base::close(...future.stdout)
[11:01:20.462]         ...future.stdout <- NULL
[11:01:20.462]     }
[11:01:20.462]     ...future.result$conditions <- ...future.conditions
[11:01:20.462]     ...future.result$finished <- base::Sys.time()
[11:01:20.462]     ...future.result
[11:01:20.462] }
[11:01:20.497]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.464] plan(): Setting new future strategy stack:
[11:01:20.497]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.464] List of future strategies:
[11:01:20.464] 1. sequential:
[11:01:20.464]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.464]    - tweaked: FALSE
[11:01:20.464]    - call: NULL
[11:01:20.497]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.465] plan(): nbrOfWorkers() = 1
[11:01:20.497]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.466] plan(): Setting new future strategy stack:
[11:01:20.497]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.466] List of future strategies:
[11:01:20.466] 1. sequential:
[11:01:20.466]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.466]    - tweaked: FALSE
[11:01:20.466]    - call: NULL
[11:01:20.498]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.467] plan(): nbrOfWorkers() = 1
[11:01:20.498]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.467] SequentialFuture started (and completed)
[11:01:20.498]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.467] - Launch lazy future ... done
[11:01:20.498]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.468] run() for ‘SequentialFuture’ ... done
[11:01:20.498]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.468] getGlobalsAndPackages() ...
[11:01:20.498]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.468] Searching for globals...
[11:01:20.499]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.469] 
[11:01:20.499]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.469] Searching for globals ... DONE
[11:01:20.499]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.469] - globals: [0] <none>
[11:01:20.499]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.469] getGlobalsAndPackages() ... DONE
[11:01:20.499]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.470] run() for ‘Future’ ...
[11:01:20.499]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.470] - state: ‘created’
[11:01:20.500]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.470] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:20.500]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.470] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:20.500]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.470] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:20.500]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.471]   - Field: ‘label’
[11:01:20.500]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.471]   - Field: ‘local’
[11:01:20.500]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.471]   - Field: ‘owner’
[11:01:20.500]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.471]   - Field: ‘envir’
[11:01:20.501]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.471]   - Field: ‘packages’
[11:01:20.501]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.472]   - Field: ‘gc’
[11:01:20.501]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.472]   - Field: ‘conditions’
[11:01:20.501]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.472]   - Field: ‘expr’
[11:01:20.501]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.472]   - Field: ‘uuid’
[11:01:20.501]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.472]   - Field: ‘seed’
[11:01:20.501]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.472]   - Field: ‘version’
[11:01:20.502]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.472]   - Field: ‘result’
[11:01:20.502]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.473]   - Field: ‘asynchronous’
[11:01:20.502]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.473]   - Field: ‘calls’
[11:01:20.502]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.473]   - Field: ‘globals’
[11:01:20.502]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.473]   - Field: ‘stdout’
[11:01:20.502]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.473]   - Field: ‘earlySignal’
[11:01:20.503]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.473]   - Field: ‘lazy’
[11:01:20.503]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.473]   - Field: ‘state’
[11:01:20.503]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.474] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:20.503]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.474] - Launch lazy future ...
[11:01:20.503]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.474] Packages needed by the future expression (n = 0): <none>
[11:01:20.503]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.474] Packages needed by future strategies (n = 0): <none>
[11:01:20.503]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.475] {
[11:01:20.475]     {
[11:01:20.475]         {
[11:01:20.475]             ...future.startTime <- base::Sys.time()
[11:01:20.475]             {
[11:01:20.475]                 {
[11:01:20.475]                   {
[11:01:20.475]                     base::local({
[11:01:20.475]                       has_future <- base::requireNamespace("future", 
[11:01:20.475]                         quietly = TRUE)
[11:01:20.475]                       if (has_future) {
[11:01:20.475]                         ns <- base::getNamespace("future")
[11:01:20.475]                         version <- ns[[".package"]][["version"]]
[11:01:20.475]                         if (is.null(version)) 
[11:01:20.475]                           version <- utils::packageVersion("future")
[11:01:20.475]                       }
[11:01:20.475]                       else {
[11:01:20.475]                         version <- NULL
[11:01:20.475]                       }
[11:01:20.475]                       if (!has_future || version < "1.8.0") {
[11:01:20.475]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.475]                           "", base::R.version$version.string), 
[11:01:20.475]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:20.475]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.475]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.475]                             "release", "version")], collapse = " "), 
[11:01:20.475]                           hostname = base::Sys.info()[["nodename"]])
[11:01:20.475]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.475]                           info)
[11:01:20.475]                         info <- base::paste(info, collapse = "; ")
[11:01:20.475]                         if (!has_future) {
[11:01:20.475]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.475]                             info)
[11:01:20.475]                         }
[11:01:20.475]                         else {
[11:01:20.475]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.475]                             info, version)
[11:01:20.475]                         }
[11:01:20.475]                         base::stop(msg)
[11:01:20.475]                       }
[11:01:20.475]                     })
[11:01:20.475]                   }
[11:01:20.475]                   ...future.strategy.old <- future::plan("list")
[11:01:20.475]                   options(future.plan = NULL)
[11:01:20.475]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.475]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.475]                 }
[11:01:20.475]                 ...future.workdir <- getwd()
[11:01:20.475]             }
[11:01:20.475]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.475]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.475]         }
[11:01:20.475]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.475]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.475]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.475]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.475]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.475]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.475]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.475]             base::names(...future.oldOptions))
[11:01:20.475]     }
[11:01:20.475]     if (FALSE) {
[11:01:20.475]     }
[11:01:20.475]     else {
[11:01:20.475]         if (TRUE) {
[11:01:20.475]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.475]                 open = "w")
[11:01:20.475]         }
[11:01:20.475]         else {
[11:01:20.475]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.475]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.475]         }
[11:01:20.475]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.475]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.475]             base::sink(type = "output", split = FALSE)
[11:01:20.475]             base::close(...future.stdout)
[11:01:20.475]         }, add = TRUE)
[11:01:20.475]     }
[11:01:20.475]     ...future.frame <- base::sys.nframe()
[11:01:20.475]     ...future.conditions <- base::list()
[11:01:20.475]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.475]     if (FALSE) {
[11:01:20.475]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.475]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.475]     }
[11:01:20.475]     ...future.result <- base::tryCatch({
[11:01:20.475]         base::withCallingHandlers({
[11:01:20.475]             ...future.value <- base::withVisible(base::local(4))
[11:01:20.475]             future::FutureResult(value = ...future.value$value, 
[11:01:20.475]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.475]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.475]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.475]                     ...future.globalenv.names))
[11:01:20.475]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.475]         }, condition = base::local({
[11:01:20.475]             c <- base::c
[11:01:20.475]             inherits <- base::inherits
[11:01:20.475]             invokeRestart <- base::invokeRestart
[11:01:20.475]             length <- base::length
[11:01:20.475]             list <- base::list
[11:01:20.475]             seq.int <- base::seq.int
[11:01:20.475]             signalCondition <- base::signalCondition
[11:01:20.475]             sys.calls <- base::sys.calls
[11:01:20.475]             `[[` <- base::`[[`
[11:01:20.475]             `+` <- base::`+`
[11:01:20.475]             `<<-` <- base::`<<-`
[11:01:20.475]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.475]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.475]                   3L)]
[11:01:20.475]             }
[11:01:20.475]             function(cond) {
[11:01:20.475]                 is_error <- inherits(cond, "error")
[11:01:20.475]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.475]                   NULL)
[11:01:20.475]                 if (is_error) {
[11:01:20.475]                   sessionInformation <- function() {
[11:01:20.475]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.475]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.475]                       search = base::search(), system = base::Sys.info())
[11:01:20.475]                   }
[11:01:20.475]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.475]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.475]                     cond$call), session = sessionInformation(), 
[11:01:20.475]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.475]                   signalCondition(cond)
[11:01:20.475]                 }
[11:01:20.475]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.475]                 "immediateCondition"))) {
[11:01:20.475]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.475]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.475]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.475]                   if (TRUE && !signal) {
[11:01:20.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.475]                     {
[11:01:20.475]                       inherits <- base::inherits
[11:01:20.475]                       invokeRestart <- base::invokeRestart
[11:01:20.475]                       is.null <- base::is.null
[11:01:20.475]                       muffled <- FALSE
[11:01:20.475]                       if (inherits(cond, "message")) {
[11:01:20.475]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.475]                         if (muffled) 
[11:01:20.475]                           invokeRestart("muffleMessage")
[11:01:20.475]                       }
[11:01:20.475]                       else if (inherits(cond, "warning")) {
[11:01:20.475]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.475]                         if (muffled) 
[11:01:20.475]                           invokeRestart("muffleWarning")
[11:01:20.475]                       }
[11:01:20.475]                       else if (inherits(cond, "condition")) {
[11:01:20.475]                         if (!is.null(pattern)) {
[11:01:20.475]                           computeRestarts <- base::computeRestarts
[11:01:20.475]                           grepl <- base::grepl
[11:01:20.475]                           restarts <- computeRestarts(cond)
[11:01:20.475]                           for (restart in restarts) {
[11:01:20.475]                             name <- restart$name
[11:01:20.475]                             if (is.null(name)) 
[11:01:20.475]                               next
[11:01:20.475]                             if (!grepl(pattern, name)) 
[11:01:20.475]                               next
[11:01:20.475]                             invokeRestart(restart)
[11:01:20.475]                             muffled <- TRUE
[11:01:20.475]                             break
[11:01:20.475]                           }
[11:01:20.475]                         }
[11:01:20.475]                       }
[11:01:20.475]                       invisible(muffled)
[11:01:20.475]                     }
[11:01:20.475]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.475]                   }
[11:01:20.475]                 }
[11:01:20.475]                 else {
[11:01:20.475]                   if (TRUE) {
[11:01:20.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.475]                     {
[11:01:20.475]                       inherits <- base::inherits
[11:01:20.475]                       invokeRestart <- base::invokeRestart
[11:01:20.475]                       is.null <- base::is.null
[11:01:20.475]                       muffled <- FALSE
[11:01:20.475]                       if (inherits(cond, "message")) {
[11:01:20.475]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.475]                         if (muffled) 
[11:01:20.475]                           invokeRestart("muffleMessage")
[11:01:20.475]                       }
[11:01:20.475]                       else if (inherits(cond, "warning")) {
[11:01:20.475]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.475]                         if (muffled) 
[11:01:20.475]                           invokeRestart("muffleWarning")
[11:01:20.475]                       }
[11:01:20.475]                       else if (inherits(cond, "condition")) {
[11:01:20.475]                         if (!is.null(pattern)) {
[11:01:20.475]                           computeRestarts <- base::computeRestarts
[11:01:20.475]                           grepl <- base::grepl
[11:01:20.475]                           restarts <- computeRestarts(cond)
[11:01:20.475]                           for (restart in restarts) {
[11:01:20.475]                             name <- restart$name
[11:01:20.475]                             if (is.null(name)) 
[11:01:20.475]                               next
[11:01:20.475]                             if (!grepl(pattern, name)) 
[11:01:20.475]                               next
[11:01:20.475]                             invokeRestart(restart)
[11:01:20.475]                             muffled <- TRUE
[11:01:20.475]                             break
[11:01:20.475]                           }
[11:01:20.475]                         }
[11:01:20.475]                       }
[11:01:20.475]                       invisible(muffled)
[11:01:20.475]                     }
[11:01:20.475]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.475]                   }
[11:01:20.475]                 }
[11:01:20.475]             }
[11:01:20.475]         }))
[11:01:20.475]     }, error = function(ex) {
[11:01:20.475]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.475]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.475]                 ...future.rng), started = ...future.startTime, 
[11:01:20.475]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.475]             version = "1.8"), class = "FutureResult")
[11:01:20.475]     }, finally = {
[11:01:20.475]         if (!identical(...future.workdir, getwd())) 
[11:01:20.475]             setwd(...future.workdir)
[11:01:20.475]         {
[11:01:20.475]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.475]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.475]             }
[11:01:20.475]             base::options(...future.oldOptions)
[11:01:20.475]             if (.Platform$OS.type == "windows") {
[11:01:20.475]                 old_names <- names(...future.oldEnvVars)
[11:01:20.475]                 envs <- base::Sys.getenv()
[11:01:20.475]                 names <- names(envs)
[11:01:20.475]                 common <- intersect(names, old_names)
[11:01:20.475]                 added <- setdiff(names, old_names)
[11:01:20.475]                 removed <- setdiff(old_names, names)
[11:01:20.475]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.475]                   envs[common]]
[11:01:20.475]                 NAMES <- toupper(changed)
[11:01:20.475]                 args <- list()
[11:01:20.475]                 for (kk in seq_along(NAMES)) {
[11:01:20.475]                   name <- changed[[kk]]
[11:01:20.475]                   NAME <- NAMES[[kk]]
[11:01:20.475]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.475]                     next
[11:01:20.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.475]                 }
[11:01:20.475]                 NAMES <- toupper(added)
[11:01:20.475]                 for (kk in seq_along(NAMES)) {
[11:01:20.475]                   name <- added[[kk]]
[11:01:20.475]                   NAME <- NAMES[[kk]]
[11:01:20.475]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.475]                     next
[11:01:20.475]                   args[[name]] <- ""
[11:01:20.475]                 }
[11:01:20.475]                 NAMES <- toupper(removed)
[11:01:20.475]                 for (kk in seq_along(NAMES)) {
[11:01:20.475]                   name <- removed[[kk]]
[11:01:20.475]                   NAME <- NAMES[[kk]]
[11:01:20.475]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.475]                     next
[11:01:20.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.475]                 }
[11:01:20.475]                 if (length(args) > 0) 
[11:01:20.475]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.475]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.475]             }
[11:01:20.475]             else {
[11:01:20.475]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.475]             }
[11:01:20.475]             {
[11:01:20.475]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.475]                   0L) {
[11:01:20.475]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.475]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.475]                   base::options(opts)
[11:01:20.475]                 }
[11:01:20.475]                 {
[11:01:20.475]                   {
[11:01:20.475]                     NULL
[11:01:20.475]                     RNGkind("Mersenne-Twister")
[11:01:20.475]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:20.475]                       inherits = FALSE)
[11:01:20.475]                   }
[11:01:20.475]                   options(future.plan = NULL)
[11:01:20.475]                   if (is.na(NA_character_)) 
[11:01:20.475]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.475]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.475]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.475]                     .init = FALSE)
[11:01:20.475]                 }
[11:01:20.475]             }
[11:01:20.475]         }
[11:01:20.475]     })
[11:01:20.475]     if (TRUE) {
[11:01:20.475]         base::sink(type = "output", split = FALSE)
[11:01:20.475]         if (TRUE) {
[11:01:20.475]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.475]         }
[11:01:20.475]         else {
[11:01:20.475]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.475]         }
[11:01:20.475]         base::close(...future.stdout)
[11:01:20.475]         ...future.stdout <- NULL
[11:01:20.475]     }
[11:01:20.475]     ...future.result$conditions <- ...future.conditions
[11:01:20.475]     ...future.result$finished <- base::Sys.time()
[11:01:20.475]     ...future.result
[11:01:20.475] }
[11:01:20.504]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.477] plan(): Setting new future strategy stack:
[11:01:20.504]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.477] List of future strategies:
[11:01:20.477] 1. sequential:
[11:01:20.477]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.477]    - tweaked: FALSE
[11:01:20.477]    - call: NULL
[11:01:20.504]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.478] plan(): nbrOfWorkers() = 1
[11:01:20.504]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.479] plan(): Setting new future strategy stack:
[11:01:20.504]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.479] List of future strategies:
[11:01:20.479] 1. sequential:
[11:01:20.479]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.479]    - tweaked: FALSE
[11:01:20.479]    - call: NULL
[11:01:20.504]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.480] plan(): nbrOfWorkers() = 1
[11:01:20.505]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.480] SequentialFuture started (and completed)
[11:01:20.505]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.480] - Launch lazy future ... done
[11:01:20.505]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:20.480] run() for ‘SequentialFuture’ ... done
[11:01:20.505] signalConditions() ... done
a = 10
[11:01:20.505] getGlobalsAndPackages() ...
[11:01:20.506] Searching for globals...
[11:01:20.507] - globals found: [3] ‘{’, ‘+’, ‘a’
[11:01:20.507] Searching for globals ... DONE
[11:01:20.507] Resolving globals: FALSE
[11:01:20.507] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:20.508] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:20.508] - globals: [1] ‘a’
[11:01:20.508] 
[11:01:20.508] getGlobalsAndPackages() ... DONE
[11:01:20.508] run() for ‘Future’ ...
[11:01:20.509] - state: ‘created’
[11:01:20.509] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:20.510] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:20.511] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:20.511]   - Field: ‘label’
[11:01:20.511]   - Field: ‘local’
[11:01:20.511]   - Field: ‘owner’
[11:01:20.511]   - Field: ‘envir’
[11:01:20.511]   - Field: ‘workers’
[11:01:20.511]   - Field: ‘packages’
[11:01:20.511]   - Field: ‘gc’
[11:01:20.511]   - Field: ‘job’
[11:01:20.511]   - Field: ‘conditions’
[11:01:20.511]   - Field: ‘expr’
[11:01:20.512]   - Field: ‘uuid’
[11:01:20.512]   - Field: ‘seed’
[11:01:20.512]   - Field: ‘version’
[11:01:20.512]   - Field: ‘result’
[11:01:20.512]   - Field: ‘asynchronous’
[11:01:20.512]   - Field: ‘calls’
[11:01:20.512]   - Field: ‘globals’
[11:01:20.512]   - Field: ‘stdout’
[11:01:20.512]   - Field: ‘earlySignal’
[11:01:20.512]   - Field: ‘lazy’
[11:01:20.512]   - Field: ‘state’
[11:01:20.512] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:20.513] - Launch lazy future ...
[11:01:20.513] Packages needed by the future expression (n = 0): <none>
[11:01:20.513] Packages needed by future strategies (n = 0): <none>
[11:01:20.514] {
[11:01:20.514]     {
[11:01:20.514]         {
[11:01:20.514]             ...future.startTime <- base::Sys.time()
[11:01:20.514]             {
[11:01:20.514]                 {
[11:01:20.514]                   {
[11:01:20.514]                     {
[11:01:20.514]                       base::local({
[11:01:20.514]                         has_future <- base::requireNamespace("future", 
[11:01:20.514]                           quietly = TRUE)
[11:01:20.514]                         if (has_future) {
[11:01:20.514]                           ns <- base::getNamespace("future")
[11:01:20.514]                           version <- ns[[".package"]][["version"]]
[11:01:20.514]                           if (is.null(version)) 
[11:01:20.514]                             version <- utils::packageVersion("future")
[11:01:20.514]                         }
[11:01:20.514]                         else {
[11:01:20.514]                           version <- NULL
[11:01:20.514]                         }
[11:01:20.514]                         if (!has_future || version < "1.8.0") {
[11:01:20.514]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:20.514]                             "", base::R.version$version.string), 
[11:01:20.514]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:20.514]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:20.514]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:20.514]                               "release", "version")], collapse = " "), 
[11:01:20.514]                             hostname = base::Sys.info()[["nodename"]])
[11:01:20.514]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:20.514]                             info)
[11:01:20.514]                           info <- base::paste(info, collapse = "; ")
[11:01:20.514]                           if (!has_future) {
[11:01:20.514]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:20.514]                               info)
[11:01:20.514]                           }
[11:01:20.514]                           else {
[11:01:20.514]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:20.514]                               info, version)
[11:01:20.514]                           }
[11:01:20.514]                           base::stop(msg)
[11:01:20.514]                         }
[11:01:20.514]                       })
[11:01:20.514]                     }
[11:01:20.514]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:20.514]                     base::options(mc.cores = 1L)
[11:01:20.514]                   }
[11:01:20.514]                   ...future.strategy.old <- future::plan("list")
[11:01:20.514]                   options(future.plan = NULL)
[11:01:20.514]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.514]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:20.514]                 }
[11:01:20.514]                 ...future.workdir <- getwd()
[11:01:20.514]             }
[11:01:20.514]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:20.514]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:20.514]         }
[11:01:20.514]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:20.514]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:20.514]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:20.514]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:20.514]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:20.514]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:20.514]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:20.514]             base::names(...future.oldOptions))
[11:01:20.514]     }
[11:01:20.514]     if (FALSE) {
[11:01:20.514]     }
[11:01:20.514]     else {
[11:01:20.514]         if (TRUE) {
[11:01:20.514]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:20.514]                 open = "w")
[11:01:20.514]         }
[11:01:20.514]         else {
[11:01:20.514]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:20.514]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:20.514]         }
[11:01:20.514]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:20.514]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:20.514]             base::sink(type = "output", split = FALSE)
[11:01:20.514]             base::close(...future.stdout)
[11:01:20.514]         }, add = TRUE)
[11:01:20.514]     }
[11:01:20.514]     ...future.frame <- base::sys.nframe()
[11:01:20.514]     ...future.conditions <- base::list()
[11:01:20.514]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:20.514]     if (FALSE) {
[11:01:20.514]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:20.514]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:20.514]     }
[11:01:20.514]     ...future.result <- base::tryCatch({
[11:01:20.514]         base::withCallingHandlers({
[11:01:20.514]             ...future.value <- base::withVisible(base::local({
[11:01:20.514]                 withCallingHandlers({
[11:01:20.514]                   {
[11:01:20.514]                     a + 1
[11:01:20.514]                   }
[11:01:20.514]                 }, immediateCondition = function(cond) {
[11:01:20.514]                   save_rds <- function (object, pathname, ...) 
[11:01:20.514]                   {
[11:01:20.514]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:20.514]                     if (file_test("-f", pathname_tmp)) {
[11:01:20.514]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.514]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:20.514]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.514]                         fi_tmp[["mtime"]])
[11:01:20.514]                     }
[11:01:20.514]                     tryCatch({
[11:01:20.514]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:20.514]                     }, error = function(ex) {
[11:01:20.514]                       msg <- conditionMessage(ex)
[11:01:20.514]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.514]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:20.514]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.514]                         fi_tmp[["mtime"]], msg)
[11:01:20.514]                       ex$message <- msg
[11:01:20.514]                       stop(ex)
[11:01:20.514]                     })
[11:01:20.514]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:20.514]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:20.514]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:20.514]                       fi_tmp <- file.info(pathname_tmp)
[11:01:20.514]                       fi <- file.info(pathname)
[11:01:20.514]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:20.514]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:20.514]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:20.514]                         fi[["size"]], fi[["mtime"]])
[11:01:20.514]                       stop(msg)
[11:01:20.514]                     }
[11:01:20.514]                     invisible(pathname)
[11:01:20.514]                   }
[11:01:20.514]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:20.514]                     rootPath = tempdir()) 
[11:01:20.514]                   {
[11:01:20.514]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:20.514]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:20.514]                       tmpdir = path, fileext = ".rds")
[11:01:20.514]                     save_rds(obj, file)
[11:01:20.514]                   }
[11:01:20.514]                   saveImmediateCondition(cond, path = "/tmp/RtmpxWUrEc/.future/immediateConditions")
[11:01:20.514]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.514]                   {
[11:01:20.514]                     inherits <- base::inherits
[11:01:20.514]                     invokeRestart <- base::invokeRestart
[11:01:20.514]                     is.null <- base::is.null
[11:01:20.514]                     muffled <- FALSE
[11:01:20.514]                     if (inherits(cond, "message")) {
[11:01:20.514]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:20.514]                       if (muffled) 
[11:01:20.514]                         invokeRestart("muffleMessage")
[11:01:20.514]                     }
[11:01:20.514]                     else if (inherits(cond, "warning")) {
[11:01:20.514]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:20.514]                       if (muffled) 
[11:01:20.514]                         invokeRestart("muffleWarning")
[11:01:20.514]                     }
[11:01:20.514]                     else if (inherits(cond, "condition")) {
[11:01:20.514]                       if (!is.null(pattern)) {
[11:01:20.514]                         computeRestarts <- base::computeRestarts
[11:01:20.514]                         grepl <- base::grepl
[11:01:20.514]                         restarts <- computeRestarts(cond)
[11:01:20.514]                         for (restart in restarts) {
[11:01:20.514]                           name <- restart$name
[11:01:20.514]                           if (is.null(name)) 
[11:01:20.514]                             next
[11:01:20.514]                           if (!grepl(pattern, name)) 
[11:01:20.514]                             next
[11:01:20.514]                           invokeRestart(restart)
[11:01:20.514]                           muffled <- TRUE
[11:01:20.514]                           break
[11:01:20.514]                         }
[11:01:20.514]                       }
[11:01:20.514]                     }
[11:01:20.514]                     invisible(muffled)
[11:01:20.514]                   }
[11:01:20.514]                   muffleCondition(cond)
[11:01:20.514]                 })
[11:01:20.514]             }))
[11:01:20.514]             future::FutureResult(value = ...future.value$value, 
[11:01:20.514]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.514]                   ...future.rng), globalenv = if (FALSE) 
[11:01:20.514]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:20.514]                     ...future.globalenv.names))
[11:01:20.514]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:20.514]         }, condition = base::local({
[11:01:20.514]             c <- base::c
[11:01:20.514]             inherits <- base::inherits
[11:01:20.514]             invokeRestart <- base::invokeRestart
[11:01:20.514]             length <- base::length
[11:01:20.514]             list <- base::list
[11:01:20.514]             seq.int <- base::seq.int
[11:01:20.514]             signalCondition <- base::signalCondition
[11:01:20.514]             sys.calls <- base::sys.calls
[11:01:20.514]             `[[` <- base::`[[`
[11:01:20.514]             `+` <- base::`+`
[11:01:20.514]             `<<-` <- base::`<<-`
[11:01:20.514]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:20.514]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:20.514]                   3L)]
[11:01:20.514]             }
[11:01:20.514]             function(cond) {
[11:01:20.514]                 is_error <- inherits(cond, "error")
[11:01:20.514]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:20.514]                   NULL)
[11:01:20.514]                 if (is_error) {
[11:01:20.514]                   sessionInformation <- function() {
[11:01:20.514]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:20.514]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:20.514]                       search = base::search(), system = base::Sys.info())
[11:01:20.514]                   }
[11:01:20.514]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.514]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:20.514]                     cond$call), session = sessionInformation(), 
[11:01:20.514]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:20.514]                   signalCondition(cond)
[11:01:20.514]                 }
[11:01:20.514]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:20.514]                 "immediateCondition"))) {
[11:01:20.514]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:20.514]                   ...future.conditions[[length(...future.conditions) + 
[11:01:20.514]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:20.514]                   if (TRUE && !signal) {
[11:01:20.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.514]                     {
[11:01:20.514]                       inherits <- base::inherits
[11:01:20.514]                       invokeRestart <- base::invokeRestart
[11:01:20.514]                       is.null <- base::is.null
[11:01:20.514]                       muffled <- FALSE
[11:01:20.514]                       if (inherits(cond, "message")) {
[11:01:20.514]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.514]                         if (muffled) 
[11:01:20.514]                           invokeRestart("muffleMessage")
[11:01:20.514]                       }
[11:01:20.514]                       else if (inherits(cond, "warning")) {
[11:01:20.514]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.514]                         if (muffled) 
[11:01:20.514]                           invokeRestart("muffleWarning")
[11:01:20.514]                       }
[11:01:20.514]                       else if (inherits(cond, "condition")) {
[11:01:20.514]                         if (!is.null(pattern)) {
[11:01:20.514]                           computeRestarts <- base::computeRestarts
[11:01:20.514]                           grepl <- base::grepl
[11:01:20.514]                           restarts <- computeRestarts(cond)
[11:01:20.514]                           for (restart in restarts) {
[11:01:20.514]                             name <- restart$name
[11:01:20.514]                             if (is.null(name)) 
[11:01:20.514]                               next
[11:01:20.514]                             if (!grepl(pattern, name)) 
[11:01:20.514]                               next
[11:01:20.514]                             invokeRestart(restart)
[11:01:20.514]                             muffled <- TRUE
[11:01:20.514]                             break
[11:01:20.514]                           }
[11:01:20.514]                         }
[11:01:20.514]                       }
[11:01:20.514]                       invisible(muffled)
[11:01:20.514]                     }
[11:01:20.514]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.514]                   }
[11:01:20.514]                 }
[11:01:20.514]                 else {
[11:01:20.514]                   if (TRUE) {
[11:01:20.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:20.514]                     {
[11:01:20.514]                       inherits <- base::inherits
[11:01:20.514]                       invokeRestart <- base::invokeRestart
[11:01:20.514]                       is.null <- base::is.null
[11:01:20.514]                       muffled <- FALSE
[11:01:20.514]                       if (inherits(cond, "message")) {
[11:01:20.514]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:20.514]                         if (muffled) 
[11:01:20.514]                           invokeRestart("muffleMessage")
[11:01:20.514]                       }
[11:01:20.514]                       else if (inherits(cond, "warning")) {
[11:01:20.514]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:20.514]                         if (muffled) 
[11:01:20.514]                           invokeRestart("muffleWarning")
[11:01:20.514]                       }
[11:01:20.514]                       else if (inherits(cond, "condition")) {
[11:01:20.514]                         if (!is.null(pattern)) {
[11:01:20.514]                           computeRestarts <- base::computeRestarts
[11:01:20.514]                           grepl <- base::grepl
[11:01:20.514]                           restarts <- computeRestarts(cond)
[11:01:20.514]                           for (restart in restarts) {
[11:01:20.514]                             name <- restart$name
[11:01:20.514]                             if (is.null(name)) 
[11:01:20.514]                               next
[11:01:20.514]                             if (!grepl(pattern, name)) 
[11:01:20.514]                               next
[11:01:20.514]                             invokeRestart(restart)
[11:01:20.514]                             muffled <- TRUE
[11:01:20.514]                             break
[11:01:20.514]                           }
[11:01:20.514]                         }
[11:01:20.514]                       }
[11:01:20.514]                       invisible(muffled)
[11:01:20.514]                     }
[11:01:20.514]                     muffleCondition(cond, pattern = "^muffle")
[11:01:20.514]                   }
[11:01:20.514]                 }
[11:01:20.514]             }
[11:01:20.514]         }))
[11:01:20.514]     }, error = function(ex) {
[11:01:20.514]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:20.514]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:20.514]                 ...future.rng), started = ...future.startTime, 
[11:01:20.514]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:20.514]             version = "1.8"), class = "FutureResult")
[11:01:20.514]     }, finally = {
[11:01:20.514]         if (!identical(...future.workdir, getwd())) 
[11:01:20.514]             setwd(...future.workdir)
[11:01:20.514]         {
[11:01:20.514]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:20.514]                 ...future.oldOptions$nwarnings <- NULL
[11:01:20.514]             }
[11:01:20.514]             base::options(...future.oldOptions)
[11:01:20.514]             if (.Platform$OS.type == "windows") {
[11:01:20.514]                 old_names <- names(...future.oldEnvVars)
[11:01:20.514]                 envs <- base::Sys.getenv()
[11:01:20.514]                 names <- names(envs)
[11:01:20.514]                 common <- intersect(names, old_names)
[11:01:20.514]                 added <- setdiff(names, old_names)
[11:01:20.514]                 removed <- setdiff(old_names, names)
[11:01:20.514]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:20.514]                   envs[common]]
[11:01:20.514]                 NAMES <- toupper(changed)
[11:01:20.514]                 args <- list()
[11:01:20.514]                 for (kk in seq_along(NAMES)) {
[11:01:20.514]                   name <- changed[[kk]]
[11:01:20.514]                   NAME <- NAMES[[kk]]
[11:01:20.514]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.514]                     next
[11:01:20.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.514]                 }
[11:01:20.514]                 NAMES <- toupper(added)
[11:01:20.514]                 for (kk in seq_along(NAMES)) {
[11:01:20.514]                   name <- added[[kk]]
[11:01:20.514]                   NAME <- NAMES[[kk]]
[11:01:20.514]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.514]                     next
[11:01:20.514]                   args[[name]] <- ""
[11:01:20.514]                 }
[11:01:20.514]                 NAMES <- toupper(removed)
[11:01:20.514]                 for (kk in seq_along(NAMES)) {
[11:01:20.514]                   name <- removed[[kk]]
[11:01:20.514]                   NAME <- NAMES[[kk]]
[11:01:20.514]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:20.514]                     next
[11:01:20.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:20.514]                 }
[11:01:20.514]                 if (length(args) > 0) 
[11:01:20.514]                   base::do.call(base::Sys.setenv, args = args)
[11:01:20.514]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:20.514]             }
[11:01:20.514]             else {
[11:01:20.514]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:20.514]             }
[11:01:20.514]             {
[11:01:20.514]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:20.514]                   0L) {
[11:01:20.514]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:20.514]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:20.514]                   base::options(opts)
[11:01:20.514]                 }
[11:01:20.514]                 {
[11:01:20.514]                   {
[11:01:20.514]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:20.514]                     NULL
[11:01:20.514]                   }
[11:01:20.514]                   options(future.plan = NULL)
[11:01:20.514]                   if (is.na(NA_character_)) 
[11:01:20.514]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:20.514]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:20.514]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:20.514]                     .init = FALSE)
[11:01:20.514]                 }
[11:01:20.514]             }
[11:01:20.514]         }
[11:01:20.514]     })
[11:01:20.514]     if (TRUE) {
[11:01:20.514]         base::sink(type = "output", split = FALSE)
[11:01:20.514]         if (TRUE) {
[11:01:20.514]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:20.514]         }
[11:01:20.514]         else {
[11:01:20.514]             ...future.result["stdout"] <- base::list(NULL)
[11:01:20.514]         }
[11:01:20.514]         base::close(...future.stdout)
[11:01:20.514]         ...future.stdout <- NULL
[11:01:20.514]     }
[11:01:20.514]     ...future.result$conditions <- ...future.conditions
[11:01:20.514]     ...future.result$finished <- base::Sys.time()
[11:01:20.514]     ...future.result
[11:01:20.514] }
[11:01:20.517] assign_globals() ...
[11:01:20.517] List of 1
[11:01:20.517]  $ a: num 10
[11:01:20.517]  - attr(*, "where")=List of 1
[11:01:20.517]   ..$ a:<environment: R_EmptyEnv> 
[11:01:20.517]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:20.517]  - attr(*, "resolved")= logi FALSE
[11:01:20.517]  - attr(*, "total_size")= num 39
[11:01:20.517]  - attr(*, "already-done")= logi TRUE
[11:01:20.519] - copied ‘a’ to environment
[11:01:20.520] assign_globals() ... done
[11:01:20.520] requestCore(): workers = 2
[11:01:20.521] MulticoreFuture started
[11:01:20.522] - Launch lazy future ... done
[11:01:20.522] run() for ‘MulticoreFuture’ ... done
[11:01:20.522] result() for MulticoreFuture ...
[11:01:20.522] plan(): Setting new future strategy stack:
[11:01:20.523] List of future strategies:
[11:01:20.523] 1. sequential:
[11:01:20.523]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:20.523]    - tweaked: FALSE
[11:01:20.523]    - call: NULL
[11:01:20.524] plan(): nbrOfWorkers() = 1
[11:01:20.526] plan(): Setting new future strategy stack:
[11:01:20.526] List of future strategies:
[11:01:20.526] 1. multicore:
[11:01:20.526]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:20.526]    - tweaked: FALSE
[11:01:20.526]    - call: plan(strategy)
[11:01:20.529] plan(): nbrOfWorkers() = 2
[11:01:20.530] result() for MulticoreFuture ...
[11:01:20.530] result() for MulticoreFuture ... done
[11:01:20.530] result() for MulticoreFuture ... done
[11:01:20.530] result() for MulticoreFuture ...
[11:01:20.530] result() for MulticoreFuture ... done
b = 11
*** %<-% with ‘multicore’ futures ... DONE
*** %<-% with ‘multisession’ futures ...
[11:01:20.531] plan(): Setting new future strategy stack:
[11:01:20.531] List of future strategies:
[11:01:20.531] 1. multisession:
[11:01:20.531]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:20.531]    - tweaked: FALSE
[11:01:20.531]    - call: plan(strategy)
[11:01:20.532] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[11:01:20.532] multisession:
[11:01:20.532] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:20.532] - tweaked: FALSE
[11:01:20.532] - call: plan(strategy)
[11:01:20.536] getGlobalsAndPackages() ...
[11:01:20.536] Not searching for globals
[11:01:20.537] - globals: [0] <none>
[11:01:20.537] getGlobalsAndPackages() ... DONE
[11:01:21.013] Packages needed by the future expression (n = 0): <none>
[11:01:21.013] Packages needed by future strategies (n = 0): <none>
[11:01:21.014] {
[11:01:21.014]     {
[11:01:21.014]         {
[11:01:21.014]             ...future.startTime <- base::Sys.time()
[11:01:21.014]             {
[11:01:21.014]                 {
[11:01:21.014]                   {
[11:01:21.014]                     {
[11:01:21.014]                       base::local({
[11:01:21.014]                         has_future <- base::requireNamespace("future", 
[11:01:21.014]                           quietly = TRUE)
[11:01:21.014]                         if (has_future) {
[11:01:21.014]                           ns <- base::getNamespace("future")
[11:01:21.014]                           version <- ns[[".package"]][["version"]]
[11:01:21.014]                           if (is.null(version)) 
[11:01:21.014]                             version <- utils::packageVersion("future")
[11:01:21.014]                         }
[11:01:21.014]                         else {
[11:01:21.014]                           version <- NULL
[11:01:21.014]                         }
[11:01:21.014]                         if (!has_future || version < "1.8.0") {
[11:01:21.014]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:21.014]                             "", base::R.version$version.string), 
[11:01:21.014]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:21.014]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:21.014]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:21.014]                               "release", "version")], collapse = " "), 
[11:01:21.014]                             hostname = base::Sys.info()[["nodename"]])
[11:01:21.014]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:21.014]                             info)
[11:01:21.014]                           info <- base::paste(info, collapse = "; ")
[11:01:21.014]                           if (!has_future) {
[11:01:21.014]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:21.014]                               info)
[11:01:21.014]                           }
[11:01:21.014]                           else {
[11:01:21.014]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:21.014]                               info, version)
[11:01:21.014]                           }
[11:01:21.014]                           base::stop(msg)
[11:01:21.014]                         }
[11:01:21.014]                       })
[11:01:21.014]                     }
[11:01:21.014]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:21.014]                     base::options(mc.cores = 1L)
[11:01:21.014]                   }
[11:01:21.014]                   ...future.strategy.old <- future::plan("list")
[11:01:21.014]                   options(future.plan = NULL)
[11:01:21.014]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.014]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:21.014]                 }
[11:01:21.014]                 ...future.workdir <- getwd()
[11:01:21.014]             }
[11:01:21.014]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:21.014]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:21.014]         }
[11:01:21.014]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:21.014]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:21.014]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:21.014]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:21.014]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:21.014]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:21.014]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:21.014]             base::names(...future.oldOptions))
[11:01:21.014]     }
[11:01:21.014]     if (FALSE) {
[11:01:21.014]     }
[11:01:21.014]     else {
[11:01:21.014]         if (TRUE) {
[11:01:21.014]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:21.014]                 open = "w")
[11:01:21.014]         }
[11:01:21.014]         else {
[11:01:21.014]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:21.014]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:21.014]         }
[11:01:21.014]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:21.014]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:21.014]             base::sink(type = "output", split = FALSE)
[11:01:21.014]             base::close(...future.stdout)
[11:01:21.014]         }, add = TRUE)
[11:01:21.014]     }
[11:01:21.014]     ...future.frame <- base::sys.nframe()
[11:01:21.014]     ...future.conditions <- base::list()
[11:01:21.014]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:21.014]     if (FALSE) {
[11:01:21.014]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:21.014]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:21.014]     }
[11:01:21.014]     ...future.result <- base::tryCatch({
[11:01:21.014]         base::withCallingHandlers({
[11:01:21.014]             ...future.value <- base::withVisible(base::local({
[11:01:21.014]                 ...future.makeSendCondition <- base::local({
[11:01:21.014]                   sendCondition <- NULL
[11:01:21.014]                   function(frame = 1L) {
[11:01:21.014]                     if (is.function(sendCondition)) 
[11:01:21.014]                       return(sendCondition)
[11:01:21.014]                     ns <- getNamespace("parallel")
[11:01:21.014]                     if (exists("sendData", mode = "function", 
[11:01:21.014]                       envir = ns)) {
[11:01:21.014]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:21.014]                         envir = ns)
[11:01:21.014]                       envir <- sys.frame(frame)
[11:01:21.014]                       master <- NULL
[11:01:21.014]                       while (!identical(envir, .GlobalEnv) && 
[11:01:21.014]                         !identical(envir, emptyenv())) {
[11:01:21.014]                         if (exists("master", mode = "list", envir = envir, 
[11:01:21.014]                           inherits = FALSE)) {
[11:01:21.014]                           master <- get("master", mode = "list", 
[11:01:21.014]                             envir = envir, inherits = FALSE)
[11:01:21.014]                           if (inherits(master, c("SOCKnode", 
[11:01:21.014]                             "SOCK0node"))) {
[11:01:21.014]                             sendCondition <<- function(cond) {
[11:01:21.014]                               data <- list(type = "VALUE", value = cond, 
[11:01:21.014]                                 success = TRUE)
[11:01:21.014]                               parallel_sendData(master, data)
[11:01:21.014]                             }
[11:01:21.014]                             return(sendCondition)
[11:01:21.014]                           }
[11:01:21.014]                         }
[11:01:21.014]                         frame <- frame + 1L
[11:01:21.014]                         envir <- sys.frame(frame)
[11:01:21.014]                       }
[11:01:21.014]                     }
[11:01:21.014]                     sendCondition <<- function(cond) NULL
[11:01:21.014]                   }
[11:01:21.014]                 })
[11:01:21.014]                 withCallingHandlers({
[11:01:21.014]                   NA
[11:01:21.014]                 }, immediateCondition = function(cond) {
[11:01:21.014]                   sendCondition <- ...future.makeSendCondition()
[11:01:21.014]                   sendCondition(cond)
[11:01:21.014]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.014]                   {
[11:01:21.014]                     inherits <- base::inherits
[11:01:21.014]                     invokeRestart <- base::invokeRestart
[11:01:21.014]                     is.null <- base::is.null
[11:01:21.014]                     muffled <- FALSE
[11:01:21.014]                     if (inherits(cond, "message")) {
[11:01:21.014]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:21.014]                       if (muffled) 
[11:01:21.014]                         invokeRestart("muffleMessage")
[11:01:21.014]                     }
[11:01:21.014]                     else if (inherits(cond, "warning")) {
[11:01:21.014]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:21.014]                       if (muffled) 
[11:01:21.014]                         invokeRestart("muffleWarning")
[11:01:21.014]                     }
[11:01:21.014]                     else if (inherits(cond, "condition")) {
[11:01:21.014]                       if (!is.null(pattern)) {
[11:01:21.014]                         computeRestarts <- base::computeRestarts
[11:01:21.014]                         grepl <- base::grepl
[11:01:21.014]                         restarts <- computeRestarts(cond)
[11:01:21.014]                         for (restart in restarts) {
[11:01:21.014]                           name <- restart$name
[11:01:21.014]                           if (is.null(name)) 
[11:01:21.014]                             next
[11:01:21.014]                           if (!grepl(pattern, name)) 
[11:01:21.014]                             next
[11:01:21.014]                           invokeRestart(restart)
[11:01:21.014]                           muffled <- TRUE
[11:01:21.014]                           break
[11:01:21.014]                         }
[11:01:21.014]                       }
[11:01:21.014]                     }
[11:01:21.014]                     invisible(muffled)
[11:01:21.014]                   }
[11:01:21.014]                   muffleCondition(cond)
[11:01:21.014]                 })
[11:01:21.014]             }))
[11:01:21.014]             future::FutureResult(value = ...future.value$value, 
[11:01:21.014]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.014]                   ...future.rng), globalenv = if (FALSE) 
[11:01:21.014]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:21.014]                     ...future.globalenv.names))
[11:01:21.014]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:21.014]         }, condition = base::local({
[11:01:21.014]             c <- base::c
[11:01:21.014]             inherits <- base::inherits
[11:01:21.014]             invokeRestart <- base::invokeRestart
[11:01:21.014]             length <- base::length
[11:01:21.014]             list <- base::list
[11:01:21.014]             seq.int <- base::seq.int
[11:01:21.014]             signalCondition <- base::signalCondition
[11:01:21.014]             sys.calls <- base::sys.calls
[11:01:21.014]             `[[` <- base::`[[`
[11:01:21.014]             `+` <- base::`+`
[11:01:21.014]             `<<-` <- base::`<<-`
[11:01:21.014]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:21.014]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:21.014]                   3L)]
[11:01:21.014]             }
[11:01:21.014]             function(cond) {
[11:01:21.014]                 is_error <- inherits(cond, "error")
[11:01:21.014]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:21.014]                   NULL)
[11:01:21.014]                 if (is_error) {
[11:01:21.014]                   sessionInformation <- function() {
[11:01:21.014]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:21.014]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:21.014]                       search = base::search(), system = base::Sys.info())
[11:01:21.014]                   }
[11:01:21.014]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.014]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:21.014]                     cond$call), session = sessionInformation(), 
[11:01:21.014]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:21.014]                   signalCondition(cond)
[11:01:21.014]                 }
[11:01:21.014]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:21.014]                 "immediateCondition"))) {
[11:01:21.014]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:21.014]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.014]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:21.014]                   if (TRUE && !signal) {
[11:01:21.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.014]                     {
[11:01:21.014]                       inherits <- base::inherits
[11:01:21.014]                       invokeRestart <- base::invokeRestart
[11:01:21.014]                       is.null <- base::is.null
[11:01:21.014]                       muffled <- FALSE
[11:01:21.014]                       if (inherits(cond, "message")) {
[11:01:21.014]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.014]                         if (muffled) 
[11:01:21.014]                           invokeRestart("muffleMessage")
[11:01:21.014]                       }
[11:01:21.014]                       else if (inherits(cond, "warning")) {
[11:01:21.014]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.014]                         if (muffled) 
[11:01:21.014]                           invokeRestart("muffleWarning")
[11:01:21.014]                       }
[11:01:21.014]                       else if (inherits(cond, "condition")) {
[11:01:21.014]                         if (!is.null(pattern)) {
[11:01:21.014]                           computeRestarts <- base::computeRestarts
[11:01:21.014]                           grepl <- base::grepl
[11:01:21.014]                           restarts <- computeRestarts(cond)
[11:01:21.014]                           for (restart in restarts) {
[11:01:21.014]                             name <- restart$name
[11:01:21.014]                             if (is.null(name)) 
[11:01:21.014]                               next
[11:01:21.014]                             if (!grepl(pattern, name)) 
[11:01:21.014]                               next
[11:01:21.014]                             invokeRestart(restart)
[11:01:21.014]                             muffled <- TRUE
[11:01:21.014]                             break
[11:01:21.014]                           }
[11:01:21.014]                         }
[11:01:21.014]                       }
[11:01:21.014]                       invisible(muffled)
[11:01:21.014]                     }
[11:01:21.014]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.014]                   }
[11:01:21.014]                 }
[11:01:21.014]                 else {
[11:01:21.014]                   if (TRUE) {
[11:01:21.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.014]                     {
[11:01:21.014]                       inherits <- base::inherits
[11:01:21.014]                       invokeRestart <- base::invokeRestart
[11:01:21.014]                       is.null <- base::is.null
[11:01:21.014]                       muffled <- FALSE
[11:01:21.014]                       if (inherits(cond, "message")) {
[11:01:21.014]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.014]                         if (muffled) 
[11:01:21.014]                           invokeRestart("muffleMessage")
[11:01:21.014]                       }
[11:01:21.014]                       else if (inherits(cond, "warning")) {
[11:01:21.014]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.014]                         if (muffled) 
[11:01:21.014]                           invokeRestart("muffleWarning")
[11:01:21.014]                       }
[11:01:21.014]                       else if (inherits(cond, "condition")) {
[11:01:21.014]                         if (!is.null(pattern)) {
[11:01:21.014]                           computeRestarts <- base::computeRestarts
[11:01:21.014]                           grepl <- base::grepl
[11:01:21.014]                           restarts <- computeRestarts(cond)
[11:01:21.014]                           for (restart in restarts) {
[11:01:21.014]                             name <- restart$name
[11:01:21.014]                             if (is.null(name)) 
[11:01:21.014]                               next
[11:01:21.014]                             if (!grepl(pattern, name)) 
[11:01:21.014]                               next
[11:01:21.014]                             invokeRestart(restart)
[11:01:21.014]                             muffled <- TRUE
[11:01:21.014]                             break
[11:01:21.014]                           }
[11:01:21.014]                         }
[11:01:21.014]                       }
[11:01:21.014]                       invisible(muffled)
[11:01:21.014]                     }
[11:01:21.014]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.014]                   }
[11:01:21.014]                 }
[11:01:21.014]             }
[11:01:21.014]         }))
[11:01:21.014]     }, error = function(ex) {
[11:01:21.014]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:21.014]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.014]                 ...future.rng), started = ...future.startTime, 
[11:01:21.014]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:21.014]             version = "1.8"), class = "FutureResult")
[11:01:21.014]     }, finally = {
[11:01:21.014]         if (!identical(...future.workdir, getwd())) 
[11:01:21.014]             setwd(...future.workdir)
[11:01:21.014]         {
[11:01:21.014]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:21.014]                 ...future.oldOptions$nwarnings <- NULL
[11:01:21.014]             }
[11:01:21.014]             base::options(...future.oldOptions)
[11:01:21.014]             if (.Platform$OS.type == "windows") {
[11:01:21.014]                 old_names <- names(...future.oldEnvVars)
[11:01:21.014]                 envs <- base::Sys.getenv()
[11:01:21.014]                 names <- names(envs)
[11:01:21.014]                 common <- intersect(names, old_names)
[11:01:21.014]                 added <- setdiff(names, old_names)
[11:01:21.014]                 removed <- setdiff(old_names, names)
[11:01:21.014]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:21.014]                   envs[common]]
[11:01:21.014]                 NAMES <- toupper(changed)
[11:01:21.014]                 args <- list()
[11:01:21.014]                 for (kk in seq_along(NAMES)) {
[11:01:21.014]                   name <- changed[[kk]]
[11:01:21.014]                   NAME <- NAMES[[kk]]
[11:01:21.014]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.014]                     next
[11:01:21.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.014]                 }
[11:01:21.014]                 NAMES <- toupper(added)
[11:01:21.014]                 for (kk in seq_along(NAMES)) {
[11:01:21.014]                   name <- added[[kk]]
[11:01:21.014]                   NAME <- NAMES[[kk]]
[11:01:21.014]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.014]                     next
[11:01:21.014]                   args[[name]] <- ""
[11:01:21.014]                 }
[11:01:21.014]                 NAMES <- toupper(removed)
[11:01:21.014]                 for (kk in seq_along(NAMES)) {
[11:01:21.014]                   name <- removed[[kk]]
[11:01:21.014]                   NAME <- NAMES[[kk]]
[11:01:21.014]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.014]                     next
[11:01:21.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.014]                 }
[11:01:21.014]                 if (length(args) > 0) 
[11:01:21.014]                   base::do.call(base::Sys.setenv, args = args)
[11:01:21.014]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:21.014]             }
[11:01:21.014]             else {
[11:01:21.014]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:21.014]             }
[11:01:21.014]             {
[11:01:21.014]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:21.014]                   0L) {
[11:01:21.014]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:21.014]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:21.014]                   base::options(opts)
[11:01:21.014]                 }
[11:01:21.014]                 {
[11:01:21.014]                   {
[11:01:21.014]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:21.014]                     NULL
[11:01:21.014]                   }
[11:01:21.014]                   options(future.plan = NULL)
[11:01:21.014]                   if (is.na(NA_character_)) 
[11:01:21.014]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.014]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:21.014]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:21.014]                     .init = FALSE)
[11:01:21.014]                 }
[11:01:21.014]             }
[11:01:21.014]         }
[11:01:21.014]     })
[11:01:21.014]     if (TRUE) {
[11:01:21.014]         base::sink(type = "output", split = FALSE)
[11:01:21.014]         if (TRUE) {
[11:01:21.014]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:21.014]         }
[11:01:21.014]         else {
[11:01:21.014]             ...future.result["stdout"] <- base::list(NULL)
[11:01:21.014]         }
[11:01:21.014]         base::close(...future.stdout)
[11:01:21.014]         ...future.stdout <- NULL
[11:01:21.014]     }
[11:01:21.014]     ...future.result$conditions <- ...future.conditions
[11:01:21.014]     ...future.result$finished <- base::Sys.time()
[11:01:21.014]     ...future.result
[11:01:21.014] }
[11:01:21.065] MultisessionFuture started
[11:01:21.065] result() for ClusterFuture ...
[11:01:21.065] receiveMessageFromWorker() for ClusterFuture ...
[11:01:21.066] - Validating connection of MultisessionFuture
[11:01:21.096] - received message: FutureResult
[11:01:21.096] - Received FutureResult
[11:01:21.096] - Erased future from FutureRegistry
[11:01:21.096] result() for ClusterFuture ...
[11:01:21.096] - result already collected: FutureResult
[11:01:21.096] result() for ClusterFuture ... done
[11:01:21.096] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:21.096] result() for ClusterFuture ... done
[11:01:21.096] result() for ClusterFuture ...
[11:01:21.097] - result already collected: FutureResult
[11:01:21.097] result() for ClusterFuture ... done
[11:01:21.097] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[11:01:21.098] plan(): nbrOfWorkers() = 2
** Future evaluation without globals
[11:01:21.099] getGlobalsAndPackages() ...
[11:01:21.099] Searching for globals...
[11:01:21.100] - globals found: [2] ‘{’, ‘<-’
[11:01:21.100] Searching for globals ... DONE
[11:01:21.100] Resolving globals: FALSE
[11:01:21.100] 
[11:01:21.100] 
[11:01:21.100] getGlobalsAndPackages() ... DONE
[11:01:21.101] run() for ‘Future’ ...
[11:01:21.101] - state: ‘created’
[11:01:21.101] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:21.115] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:21.115] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:21.115]   - Field: ‘node’
[11:01:21.115]   - Field: ‘label’
[11:01:21.115]   - Field: ‘local’
[11:01:21.115]   - Field: ‘owner’
[11:01:21.115]   - Field: ‘envir’
[11:01:21.115]   - Field: ‘workers’
[11:01:21.115]   - Field: ‘packages’
[11:01:21.116]   - Field: ‘gc’
[11:01:21.116]   - Field: ‘conditions’
[11:01:21.116]   - Field: ‘persistent’
[11:01:21.116]   - Field: ‘expr’
[11:01:21.116]   - Field: ‘uuid’
[11:01:21.116]   - Field: ‘seed’
[11:01:21.116]   - Field: ‘version’
[11:01:21.116]   - Field: ‘result’
[11:01:21.116]   - Field: ‘asynchronous’
[11:01:21.116]   - Field: ‘calls’
[11:01:21.116]   - Field: ‘globals’
[11:01:21.117]   - Field: ‘stdout’
[11:01:21.117]   - Field: ‘earlySignal’
[11:01:21.117]   - Field: ‘lazy’
[11:01:21.117]   - Field: ‘state’
[11:01:21.117] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:21.117] - Launch lazy future ...
[11:01:21.117] Packages needed by the future expression (n = 0): <none>
[11:01:21.117] Packages needed by future strategies (n = 0): <none>
[11:01:21.118] {
[11:01:21.118]     {
[11:01:21.118]         {
[11:01:21.118]             ...future.startTime <- base::Sys.time()
[11:01:21.118]             {
[11:01:21.118]                 {
[11:01:21.118]                   {
[11:01:21.118]                     {
[11:01:21.118]                       base::local({
[11:01:21.118]                         has_future <- base::requireNamespace("future", 
[11:01:21.118]                           quietly = TRUE)
[11:01:21.118]                         if (has_future) {
[11:01:21.118]                           ns <- base::getNamespace("future")
[11:01:21.118]                           version <- ns[[".package"]][["version"]]
[11:01:21.118]                           if (is.null(version)) 
[11:01:21.118]                             version <- utils::packageVersion("future")
[11:01:21.118]                         }
[11:01:21.118]                         else {
[11:01:21.118]                           version <- NULL
[11:01:21.118]                         }
[11:01:21.118]                         if (!has_future || version < "1.8.0") {
[11:01:21.118]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:21.118]                             "", base::R.version$version.string), 
[11:01:21.118]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:21.118]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:21.118]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:21.118]                               "release", "version")], collapse = " "), 
[11:01:21.118]                             hostname = base::Sys.info()[["nodename"]])
[11:01:21.118]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:21.118]                             info)
[11:01:21.118]                           info <- base::paste(info, collapse = "; ")
[11:01:21.118]                           if (!has_future) {
[11:01:21.118]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:21.118]                               info)
[11:01:21.118]                           }
[11:01:21.118]                           else {
[11:01:21.118]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:21.118]                               info, version)
[11:01:21.118]                           }
[11:01:21.118]                           base::stop(msg)
[11:01:21.118]                         }
[11:01:21.118]                       })
[11:01:21.118]                     }
[11:01:21.118]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:21.118]                     base::options(mc.cores = 1L)
[11:01:21.118]                   }
[11:01:21.118]                   ...future.strategy.old <- future::plan("list")
[11:01:21.118]                   options(future.plan = NULL)
[11:01:21.118]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.118]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:21.118]                 }
[11:01:21.118]                 ...future.workdir <- getwd()
[11:01:21.118]             }
[11:01:21.118]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:21.118]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:21.118]         }
[11:01:21.118]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:21.118]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:21.118]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:21.118]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:21.118]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:21.118]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:21.118]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:21.118]             base::names(...future.oldOptions))
[11:01:21.118]     }
[11:01:21.118]     if (FALSE) {
[11:01:21.118]     }
[11:01:21.118]     else {
[11:01:21.118]         if (TRUE) {
[11:01:21.118]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:21.118]                 open = "w")
[11:01:21.118]         }
[11:01:21.118]         else {
[11:01:21.118]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:21.118]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:21.118]         }
[11:01:21.118]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:21.118]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:21.118]             base::sink(type = "output", split = FALSE)
[11:01:21.118]             base::close(...future.stdout)
[11:01:21.118]         }, add = TRUE)
[11:01:21.118]     }
[11:01:21.118]     ...future.frame <- base::sys.nframe()
[11:01:21.118]     ...future.conditions <- base::list()
[11:01:21.118]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:21.118]     if (FALSE) {
[11:01:21.118]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:21.118]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:21.118]     }
[11:01:21.118]     ...future.result <- base::tryCatch({
[11:01:21.118]         base::withCallingHandlers({
[11:01:21.118]             ...future.value <- base::withVisible(base::local({
[11:01:21.118]                 ...future.makeSendCondition <- base::local({
[11:01:21.118]                   sendCondition <- NULL
[11:01:21.118]                   function(frame = 1L) {
[11:01:21.118]                     if (is.function(sendCondition)) 
[11:01:21.118]                       return(sendCondition)
[11:01:21.118]                     ns <- getNamespace("parallel")
[11:01:21.118]                     if (exists("sendData", mode = "function", 
[11:01:21.118]                       envir = ns)) {
[11:01:21.118]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:21.118]                         envir = ns)
[11:01:21.118]                       envir <- sys.frame(frame)
[11:01:21.118]                       master <- NULL
[11:01:21.118]                       while (!identical(envir, .GlobalEnv) && 
[11:01:21.118]                         !identical(envir, emptyenv())) {
[11:01:21.118]                         if (exists("master", mode = "list", envir = envir, 
[11:01:21.118]                           inherits = FALSE)) {
[11:01:21.118]                           master <- get("master", mode = "list", 
[11:01:21.118]                             envir = envir, inherits = FALSE)
[11:01:21.118]                           if (inherits(master, c("SOCKnode", 
[11:01:21.118]                             "SOCK0node"))) {
[11:01:21.118]                             sendCondition <<- function(cond) {
[11:01:21.118]                               data <- list(type = "VALUE", value = cond, 
[11:01:21.118]                                 success = TRUE)
[11:01:21.118]                               parallel_sendData(master, data)
[11:01:21.118]                             }
[11:01:21.118]                             return(sendCondition)
[11:01:21.118]                           }
[11:01:21.118]                         }
[11:01:21.118]                         frame <- frame + 1L
[11:01:21.118]                         envir <- sys.frame(frame)
[11:01:21.118]                       }
[11:01:21.118]                     }
[11:01:21.118]                     sendCondition <<- function(cond) NULL
[11:01:21.118]                   }
[11:01:21.118]                 })
[11:01:21.118]                 withCallingHandlers({
[11:01:21.118]                   {
[11:01:21.118]                     x <- 1
[11:01:21.118]                   }
[11:01:21.118]                 }, immediateCondition = function(cond) {
[11:01:21.118]                   sendCondition <- ...future.makeSendCondition()
[11:01:21.118]                   sendCondition(cond)
[11:01:21.118]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.118]                   {
[11:01:21.118]                     inherits <- base::inherits
[11:01:21.118]                     invokeRestart <- base::invokeRestart
[11:01:21.118]                     is.null <- base::is.null
[11:01:21.118]                     muffled <- FALSE
[11:01:21.118]                     if (inherits(cond, "message")) {
[11:01:21.118]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:21.118]                       if (muffled) 
[11:01:21.118]                         invokeRestart("muffleMessage")
[11:01:21.118]                     }
[11:01:21.118]                     else if (inherits(cond, "warning")) {
[11:01:21.118]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:21.118]                       if (muffled) 
[11:01:21.118]                         invokeRestart("muffleWarning")
[11:01:21.118]                     }
[11:01:21.118]                     else if (inherits(cond, "condition")) {
[11:01:21.118]                       if (!is.null(pattern)) {
[11:01:21.118]                         computeRestarts <- base::computeRestarts
[11:01:21.118]                         grepl <- base::grepl
[11:01:21.118]                         restarts <- computeRestarts(cond)
[11:01:21.118]                         for (restart in restarts) {
[11:01:21.118]                           name <- restart$name
[11:01:21.118]                           if (is.null(name)) 
[11:01:21.118]                             next
[11:01:21.118]                           if (!grepl(pattern, name)) 
[11:01:21.118]                             next
[11:01:21.118]                           invokeRestart(restart)
[11:01:21.118]                           muffled <- TRUE
[11:01:21.118]                           break
[11:01:21.118]                         }
[11:01:21.118]                       }
[11:01:21.118]                     }
[11:01:21.118]                     invisible(muffled)
[11:01:21.118]                   }
[11:01:21.118]                   muffleCondition(cond)
[11:01:21.118]                 })
[11:01:21.118]             }))
[11:01:21.118]             future::FutureResult(value = ...future.value$value, 
[11:01:21.118]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.118]                   ...future.rng), globalenv = if (FALSE) 
[11:01:21.118]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:21.118]                     ...future.globalenv.names))
[11:01:21.118]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:21.118]         }, condition = base::local({
[11:01:21.118]             c <- base::c
[11:01:21.118]             inherits <- base::inherits
[11:01:21.118]             invokeRestart <- base::invokeRestart
[11:01:21.118]             length <- base::length
[11:01:21.118]             list <- base::list
[11:01:21.118]             seq.int <- base::seq.int
[11:01:21.118]             signalCondition <- base::signalCondition
[11:01:21.118]             sys.calls <- base::sys.calls
[11:01:21.118]             `[[` <- base::`[[`
[11:01:21.118]             `+` <- base::`+`
[11:01:21.118]             `<<-` <- base::`<<-`
[11:01:21.118]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:21.118]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:21.118]                   3L)]
[11:01:21.118]             }
[11:01:21.118]             function(cond) {
[11:01:21.118]                 is_error <- inherits(cond, "error")
[11:01:21.118]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:21.118]                   NULL)
[11:01:21.118]                 if (is_error) {
[11:01:21.118]                   sessionInformation <- function() {
[11:01:21.118]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:21.118]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:21.118]                       search = base::search(), system = base::Sys.info())
[11:01:21.118]                   }
[11:01:21.118]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.118]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:21.118]                     cond$call), session = sessionInformation(), 
[11:01:21.118]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:21.118]                   signalCondition(cond)
[11:01:21.118]                 }
[11:01:21.118]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:21.118]                 "immediateCondition"))) {
[11:01:21.118]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:21.118]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.118]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:21.118]                   if (TRUE && !signal) {
[11:01:21.118]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.118]                     {
[11:01:21.118]                       inherits <- base::inherits
[11:01:21.118]                       invokeRestart <- base::invokeRestart
[11:01:21.118]                       is.null <- base::is.null
[11:01:21.118]                       muffled <- FALSE
[11:01:21.118]                       if (inherits(cond, "message")) {
[11:01:21.118]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.118]                         if (muffled) 
[11:01:21.118]                           invokeRestart("muffleMessage")
[11:01:21.118]                       }
[11:01:21.118]                       else if (inherits(cond, "warning")) {
[11:01:21.118]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.118]                         if (muffled) 
[11:01:21.118]                           invokeRestart("muffleWarning")
[11:01:21.118]                       }
[11:01:21.118]                       else if (inherits(cond, "condition")) {
[11:01:21.118]                         if (!is.null(pattern)) {
[11:01:21.118]                           computeRestarts <- base::computeRestarts
[11:01:21.118]                           grepl <- base::grepl
[11:01:21.118]                           restarts <- computeRestarts(cond)
[11:01:21.118]                           for (restart in restarts) {
[11:01:21.118]                             name <- restart$name
[11:01:21.118]                             if (is.null(name)) 
[11:01:21.118]                               next
[11:01:21.118]                             if (!grepl(pattern, name)) 
[11:01:21.118]                               next
[11:01:21.118]                             invokeRestart(restart)
[11:01:21.118]                             muffled <- TRUE
[11:01:21.118]                             break
[11:01:21.118]                           }
[11:01:21.118]                         }
[11:01:21.118]                       }
[11:01:21.118]                       invisible(muffled)
[11:01:21.118]                     }
[11:01:21.118]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.118]                   }
[11:01:21.118]                 }
[11:01:21.118]                 else {
[11:01:21.118]                   if (TRUE) {
[11:01:21.118]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.118]                     {
[11:01:21.118]                       inherits <- base::inherits
[11:01:21.118]                       invokeRestart <- base::invokeRestart
[11:01:21.118]                       is.null <- base::is.null
[11:01:21.118]                       muffled <- FALSE
[11:01:21.118]                       if (inherits(cond, "message")) {
[11:01:21.118]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.118]                         if (muffled) 
[11:01:21.118]                           invokeRestart("muffleMessage")
[11:01:21.118]                       }
[11:01:21.118]                       else if (inherits(cond, "warning")) {
[11:01:21.118]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.118]                         if (muffled) 
[11:01:21.118]                           invokeRestart("muffleWarning")
[11:01:21.118]                       }
[11:01:21.118]                       else if (inherits(cond, "condition")) {
[11:01:21.118]                         if (!is.null(pattern)) {
[11:01:21.118]                           computeRestarts <- base::computeRestarts
[11:01:21.118]                           grepl <- base::grepl
[11:01:21.118]                           restarts <- computeRestarts(cond)
[11:01:21.118]                           for (restart in restarts) {
[11:01:21.118]                             name <- restart$name
[11:01:21.118]                             if (is.null(name)) 
[11:01:21.118]                               next
[11:01:21.118]                             if (!grepl(pattern, name)) 
[11:01:21.118]                               next
[11:01:21.118]                             invokeRestart(restart)
[11:01:21.118]                             muffled <- TRUE
[11:01:21.118]                             break
[11:01:21.118]                           }
[11:01:21.118]                         }
[11:01:21.118]                       }
[11:01:21.118]                       invisible(muffled)
[11:01:21.118]                     }
[11:01:21.118]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.118]                   }
[11:01:21.118]                 }
[11:01:21.118]             }
[11:01:21.118]         }))
[11:01:21.118]     }, error = function(ex) {
[11:01:21.118]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:21.118]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.118]                 ...future.rng), started = ...future.startTime, 
[11:01:21.118]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:21.118]             version = "1.8"), class = "FutureResult")
[11:01:21.118]     }, finally = {
[11:01:21.118]         if (!identical(...future.workdir, getwd())) 
[11:01:21.118]             setwd(...future.workdir)
[11:01:21.118]         {
[11:01:21.118]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:21.118]                 ...future.oldOptions$nwarnings <- NULL
[11:01:21.118]             }
[11:01:21.118]             base::options(...future.oldOptions)
[11:01:21.118]             if (.Platform$OS.type == "windows") {
[11:01:21.118]                 old_names <- names(...future.oldEnvVars)
[11:01:21.118]                 envs <- base::Sys.getenv()
[11:01:21.118]                 names <- names(envs)
[11:01:21.118]                 common <- intersect(names, old_names)
[11:01:21.118]                 added <- setdiff(names, old_names)
[11:01:21.118]                 removed <- setdiff(old_names, names)
[11:01:21.118]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:21.118]                   envs[common]]
[11:01:21.118]                 NAMES <- toupper(changed)
[11:01:21.118]                 args <- list()
[11:01:21.118]                 for (kk in seq_along(NAMES)) {
[11:01:21.118]                   name <- changed[[kk]]
[11:01:21.118]                   NAME <- NAMES[[kk]]
[11:01:21.118]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.118]                     next
[11:01:21.118]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.118]                 }
[11:01:21.118]                 NAMES <- toupper(added)
[11:01:21.118]                 for (kk in seq_along(NAMES)) {
[11:01:21.118]                   name <- added[[kk]]
[11:01:21.118]                   NAME <- NAMES[[kk]]
[11:01:21.118]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.118]                     next
[11:01:21.118]                   args[[name]] <- ""
[11:01:21.118]                 }
[11:01:21.118]                 NAMES <- toupper(removed)
[11:01:21.118]                 for (kk in seq_along(NAMES)) {
[11:01:21.118]                   name <- removed[[kk]]
[11:01:21.118]                   NAME <- NAMES[[kk]]
[11:01:21.118]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.118]                     next
[11:01:21.118]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.118]                 }
[11:01:21.118]                 if (length(args) > 0) 
[11:01:21.118]                   base::do.call(base::Sys.setenv, args = args)
[11:01:21.118]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:21.118]             }
[11:01:21.118]             else {
[11:01:21.118]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:21.118]             }
[11:01:21.118]             {
[11:01:21.118]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:21.118]                   0L) {
[11:01:21.118]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:21.118]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:21.118]                   base::options(opts)
[11:01:21.118]                 }
[11:01:21.118]                 {
[11:01:21.118]                   {
[11:01:21.118]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:21.118]                     NULL
[11:01:21.118]                   }
[11:01:21.118]                   options(future.plan = NULL)
[11:01:21.118]                   if (is.na(NA_character_)) 
[11:01:21.118]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.118]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:21.118]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:21.118]                     .init = FALSE)
[11:01:21.118]                 }
[11:01:21.118]             }
[11:01:21.118]         }
[11:01:21.118]     })
[11:01:21.118]     if (TRUE) {
[11:01:21.118]         base::sink(type = "output", split = FALSE)
[11:01:21.118]         if (TRUE) {
[11:01:21.118]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:21.118]         }
[11:01:21.118]         else {
[11:01:21.118]             ...future.result["stdout"] <- base::list(NULL)
[11:01:21.118]         }
[11:01:21.118]         base::close(...future.stdout)
[11:01:21.118]         ...future.stdout <- NULL
[11:01:21.118]     }
[11:01:21.118]     ...future.result$conditions <- ...future.conditions
[11:01:21.118]     ...future.result$finished <- base::Sys.time()
[11:01:21.118]     ...future.result
[11:01:21.118] }
[11:01:21.121] MultisessionFuture started
[11:01:21.121] - Launch lazy future ... done
[11:01:21.121] run() for ‘MultisessionFuture’ ... done
[11:01:21.121] result() for ClusterFuture ...
[11:01:21.121] receiveMessageFromWorker() for ClusterFuture ...
[11:01:21.121] - Validating connection of MultisessionFuture
[11:01:21.163] - received message: FutureResult
[11:01:21.163] - Received FutureResult
[11:01:21.163] - Erased future from FutureRegistry
[11:01:21.163] result() for ClusterFuture ...
[11:01:21.163] - result already collected: FutureResult
[11:01:21.163] result() for ClusterFuture ... done
[11:01:21.163] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:21.163] result() for ClusterFuture ... done
[11:01:21.164] result() for ClusterFuture ...
[11:01:21.164] - result already collected: FutureResult
[11:01:21.164] result() for ClusterFuture ... done
** Future evaluation with globals
[11:01:21.164] getGlobalsAndPackages() ...
[11:01:21.164] Searching for globals...
[11:01:21.165] - globals found: [3] ‘{’, ‘<-’, ‘a’
[11:01:21.165] Searching for globals ... DONE
[11:01:21.165] Resolving globals: FALSE
[11:01:21.166] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:21.166] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:21.166] - globals: [1] ‘a’
[11:01:21.166] 
[11:01:21.166] getGlobalsAndPackages() ... DONE
[11:01:21.167] run() for ‘Future’ ...
[11:01:21.167] - state: ‘created’
[11:01:21.167] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:21.182] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:21.182] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:21.182]   - Field: ‘node’
[11:01:21.182]   - Field: ‘label’
[11:01:21.182]   - Field: ‘local’
[11:01:21.182]   - Field: ‘owner’
[11:01:21.183]   - Field: ‘envir’
[11:01:21.183]   - Field: ‘workers’
[11:01:21.183]   - Field: ‘packages’
[11:01:21.183]   - Field: ‘gc’
[11:01:21.183]   - Field: ‘conditions’
[11:01:21.183]   - Field: ‘persistent’
[11:01:21.183]   - Field: ‘expr’
[11:01:21.183]   - Field: ‘uuid’
[11:01:21.183]   - Field: ‘seed’
[11:01:21.183]   - Field: ‘version’
[11:01:21.184]   - Field: ‘result’
[11:01:21.184]   - Field: ‘asynchronous’
[11:01:21.184]   - Field: ‘calls’
[11:01:21.184]   - Field: ‘globals’
[11:01:21.184]   - Field: ‘stdout’
[11:01:21.184]   - Field: ‘earlySignal’
[11:01:21.184]   - Field: ‘lazy’
[11:01:21.184]   - Field: ‘state’
[11:01:21.184] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:21.185] - Launch lazy future ...
[11:01:21.185] Packages needed by the future expression (n = 0): <none>
[11:01:21.185] Packages needed by future strategies (n = 0): <none>
[11:01:21.185] {
[11:01:21.185]     {
[11:01:21.185]         {
[11:01:21.185]             ...future.startTime <- base::Sys.time()
[11:01:21.185]             {
[11:01:21.185]                 {
[11:01:21.185]                   {
[11:01:21.185]                     {
[11:01:21.185]                       base::local({
[11:01:21.185]                         has_future <- base::requireNamespace("future", 
[11:01:21.185]                           quietly = TRUE)
[11:01:21.185]                         if (has_future) {
[11:01:21.185]                           ns <- base::getNamespace("future")
[11:01:21.185]                           version <- ns[[".package"]][["version"]]
[11:01:21.185]                           if (is.null(version)) 
[11:01:21.185]                             version <- utils::packageVersion("future")
[11:01:21.185]                         }
[11:01:21.185]                         else {
[11:01:21.185]                           version <- NULL
[11:01:21.185]                         }
[11:01:21.185]                         if (!has_future || version < "1.8.0") {
[11:01:21.185]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:21.185]                             "", base::R.version$version.string), 
[11:01:21.185]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:21.185]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:21.185]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:21.185]                               "release", "version")], collapse = " "), 
[11:01:21.185]                             hostname = base::Sys.info()[["nodename"]])
[11:01:21.185]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:21.185]                             info)
[11:01:21.185]                           info <- base::paste(info, collapse = "; ")
[11:01:21.185]                           if (!has_future) {
[11:01:21.185]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:21.185]                               info)
[11:01:21.185]                           }
[11:01:21.185]                           else {
[11:01:21.185]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:21.185]                               info, version)
[11:01:21.185]                           }
[11:01:21.185]                           base::stop(msg)
[11:01:21.185]                         }
[11:01:21.185]                       })
[11:01:21.185]                     }
[11:01:21.185]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:21.185]                     base::options(mc.cores = 1L)
[11:01:21.185]                   }
[11:01:21.185]                   ...future.strategy.old <- future::plan("list")
[11:01:21.185]                   options(future.plan = NULL)
[11:01:21.185]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.185]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:21.185]                 }
[11:01:21.185]                 ...future.workdir <- getwd()
[11:01:21.185]             }
[11:01:21.185]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:21.185]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:21.185]         }
[11:01:21.185]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:21.185]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:21.185]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:21.185]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:21.185]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:21.185]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:21.185]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:21.185]             base::names(...future.oldOptions))
[11:01:21.185]     }
[11:01:21.185]     if (FALSE) {
[11:01:21.185]     }
[11:01:21.185]     else {
[11:01:21.185]         if (TRUE) {
[11:01:21.185]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:21.185]                 open = "w")
[11:01:21.185]         }
[11:01:21.185]         else {
[11:01:21.185]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:21.185]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:21.185]         }
[11:01:21.185]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:21.185]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:21.185]             base::sink(type = "output", split = FALSE)
[11:01:21.185]             base::close(...future.stdout)
[11:01:21.185]         }, add = TRUE)
[11:01:21.185]     }
[11:01:21.185]     ...future.frame <- base::sys.nframe()
[11:01:21.185]     ...future.conditions <- base::list()
[11:01:21.185]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:21.185]     if (FALSE) {
[11:01:21.185]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:21.185]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:21.185]     }
[11:01:21.185]     ...future.result <- base::tryCatch({
[11:01:21.185]         base::withCallingHandlers({
[11:01:21.185]             ...future.value <- base::withVisible(base::local({
[11:01:21.185]                 ...future.makeSendCondition <- base::local({
[11:01:21.185]                   sendCondition <- NULL
[11:01:21.185]                   function(frame = 1L) {
[11:01:21.185]                     if (is.function(sendCondition)) 
[11:01:21.185]                       return(sendCondition)
[11:01:21.185]                     ns <- getNamespace("parallel")
[11:01:21.185]                     if (exists("sendData", mode = "function", 
[11:01:21.185]                       envir = ns)) {
[11:01:21.185]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:21.185]                         envir = ns)
[11:01:21.185]                       envir <- sys.frame(frame)
[11:01:21.185]                       master <- NULL
[11:01:21.185]                       while (!identical(envir, .GlobalEnv) && 
[11:01:21.185]                         !identical(envir, emptyenv())) {
[11:01:21.185]                         if (exists("master", mode = "list", envir = envir, 
[11:01:21.185]                           inherits = FALSE)) {
[11:01:21.185]                           master <- get("master", mode = "list", 
[11:01:21.185]                             envir = envir, inherits = FALSE)
[11:01:21.185]                           if (inherits(master, c("SOCKnode", 
[11:01:21.185]                             "SOCK0node"))) {
[11:01:21.185]                             sendCondition <<- function(cond) {
[11:01:21.185]                               data <- list(type = "VALUE", value = cond, 
[11:01:21.185]                                 success = TRUE)
[11:01:21.185]                               parallel_sendData(master, data)
[11:01:21.185]                             }
[11:01:21.185]                             return(sendCondition)
[11:01:21.185]                           }
[11:01:21.185]                         }
[11:01:21.185]                         frame <- frame + 1L
[11:01:21.185]                         envir <- sys.frame(frame)
[11:01:21.185]                       }
[11:01:21.185]                     }
[11:01:21.185]                     sendCondition <<- function(cond) NULL
[11:01:21.185]                   }
[11:01:21.185]                 })
[11:01:21.185]                 withCallingHandlers({
[11:01:21.185]                   {
[11:01:21.185]                     x <- a
[11:01:21.185]                   }
[11:01:21.185]                 }, immediateCondition = function(cond) {
[11:01:21.185]                   sendCondition <- ...future.makeSendCondition()
[11:01:21.185]                   sendCondition(cond)
[11:01:21.185]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.185]                   {
[11:01:21.185]                     inherits <- base::inherits
[11:01:21.185]                     invokeRestart <- base::invokeRestart
[11:01:21.185]                     is.null <- base::is.null
[11:01:21.185]                     muffled <- FALSE
[11:01:21.185]                     if (inherits(cond, "message")) {
[11:01:21.185]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:21.185]                       if (muffled) 
[11:01:21.185]                         invokeRestart("muffleMessage")
[11:01:21.185]                     }
[11:01:21.185]                     else if (inherits(cond, "warning")) {
[11:01:21.185]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:21.185]                       if (muffled) 
[11:01:21.185]                         invokeRestart("muffleWarning")
[11:01:21.185]                     }
[11:01:21.185]                     else if (inherits(cond, "condition")) {
[11:01:21.185]                       if (!is.null(pattern)) {
[11:01:21.185]                         computeRestarts <- base::computeRestarts
[11:01:21.185]                         grepl <- base::grepl
[11:01:21.185]                         restarts <- computeRestarts(cond)
[11:01:21.185]                         for (restart in restarts) {
[11:01:21.185]                           name <- restart$name
[11:01:21.185]                           if (is.null(name)) 
[11:01:21.185]                             next
[11:01:21.185]                           if (!grepl(pattern, name)) 
[11:01:21.185]                             next
[11:01:21.185]                           invokeRestart(restart)
[11:01:21.185]                           muffled <- TRUE
[11:01:21.185]                           break
[11:01:21.185]                         }
[11:01:21.185]                       }
[11:01:21.185]                     }
[11:01:21.185]                     invisible(muffled)
[11:01:21.185]                   }
[11:01:21.185]                   muffleCondition(cond)
[11:01:21.185]                 })
[11:01:21.185]             }))
[11:01:21.185]             future::FutureResult(value = ...future.value$value, 
[11:01:21.185]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.185]                   ...future.rng), globalenv = if (FALSE) 
[11:01:21.185]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:21.185]                     ...future.globalenv.names))
[11:01:21.185]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:21.185]         }, condition = base::local({
[11:01:21.185]             c <- base::c
[11:01:21.185]             inherits <- base::inherits
[11:01:21.185]             invokeRestart <- base::invokeRestart
[11:01:21.185]             length <- base::length
[11:01:21.185]             list <- base::list
[11:01:21.185]             seq.int <- base::seq.int
[11:01:21.185]             signalCondition <- base::signalCondition
[11:01:21.185]             sys.calls <- base::sys.calls
[11:01:21.185]             `[[` <- base::`[[`
[11:01:21.185]             `+` <- base::`+`
[11:01:21.185]             `<<-` <- base::`<<-`
[11:01:21.185]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:21.185]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:21.185]                   3L)]
[11:01:21.185]             }
[11:01:21.185]             function(cond) {
[11:01:21.185]                 is_error <- inherits(cond, "error")
[11:01:21.185]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:21.185]                   NULL)
[11:01:21.185]                 if (is_error) {
[11:01:21.185]                   sessionInformation <- function() {
[11:01:21.185]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:21.185]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:21.185]                       search = base::search(), system = base::Sys.info())
[11:01:21.185]                   }
[11:01:21.185]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.185]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:21.185]                     cond$call), session = sessionInformation(), 
[11:01:21.185]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:21.185]                   signalCondition(cond)
[11:01:21.185]                 }
[11:01:21.185]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:21.185]                 "immediateCondition"))) {
[11:01:21.185]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:21.185]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.185]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:21.185]                   if (TRUE && !signal) {
[11:01:21.185]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.185]                     {
[11:01:21.185]                       inherits <- base::inherits
[11:01:21.185]                       invokeRestart <- base::invokeRestart
[11:01:21.185]                       is.null <- base::is.null
[11:01:21.185]                       muffled <- FALSE
[11:01:21.185]                       if (inherits(cond, "message")) {
[11:01:21.185]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.185]                         if (muffled) 
[11:01:21.185]                           invokeRestart("muffleMessage")
[11:01:21.185]                       }
[11:01:21.185]                       else if (inherits(cond, "warning")) {
[11:01:21.185]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.185]                         if (muffled) 
[11:01:21.185]                           invokeRestart("muffleWarning")
[11:01:21.185]                       }
[11:01:21.185]                       else if (inherits(cond, "condition")) {
[11:01:21.185]                         if (!is.null(pattern)) {
[11:01:21.185]                           computeRestarts <- base::computeRestarts
[11:01:21.185]                           grepl <- base::grepl
[11:01:21.185]                           restarts <- computeRestarts(cond)
[11:01:21.185]                           for (restart in restarts) {
[11:01:21.185]                             name <- restart$name
[11:01:21.185]                             if (is.null(name)) 
[11:01:21.185]                               next
[11:01:21.185]                             if (!grepl(pattern, name)) 
[11:01:21.185]                               next
[11:01:21.185]                             invokeRestart(restart)
[11:01:21.185]                             muffled <- TRUE
[11:01:21.185]                             break
[11:01:21.185]                           }
[11:01:21.185]                         }
[11:01:21.185]                       }
[11:01:21.185]                       invisible(muffled)
[11:01:21.185]                     }
[11:01:21.185]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.185]                   }
[11:01:21.185]                 }
[11:01:21.185]                 else {
[11:01:21.185]                   if (TRUE) {
[11:01:21.185]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.185]                     {
[11:01:21.185]                       inherits <- base::inherits
[11:01:21.185]                       invokeRestart <- base::invokeRestart
[11:01:21.185]                       is.null <- base::is.null
[11:01:21.185]                       muffled <- FALSE
[11:01:21.185]                       if (inherits(cond, "message")) {
[11:01:21.185]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.185]                         if (muffled) 
[11:01:21.185]                           invokeRestart("muffleMessage")
[11:01:21.185]                       }
[11:01:21.185]                       else if (inherits(cond, "warning")) {
[11:01:21.185]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.185]                         if (muffled) 
[11:01:21.185]                           invokeRestart("muffleWarning")
[11:01:21.185]                       }
[11:01:21.185]                       else if (inherits(cond, "condition")) {
[11:01:21.185]                         if (!is.null(pattern)) {
[11:01:21.185]                           computeRestarts <- base::computeRestarts
[11:01:21.185]                           grepl <- base::grepl
[11:01:21.185]                           restarts <- computeRestarts(cond)
[11:01:21.185]                           for (restart in restarts) {
[11:01:21.185]                             name <- restart$name
[11:01:21.185]                             if (is.null(name)) 
[11:01:21.185]                               next
[11:01:21.185]                             if (!grepl(pattern, name)) 
[11:01:21.185]                               next
[11:01:21.185]                             invokeRestart(restart)
[11:01:21.185]                             muffled <- TRUE
[11:01:21.185]                             break
[11:01:21.185]                           }
[11:01:21.185]                         }
[11:01:21.185]                       }
[11:01:21.185]                       invisible(muffled)
[11:01:21.185]                     }
[11:01:21.185]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.185]                   }
[11:01:21.185]                 }
[11:01:21.185]             }
[11:01:21.185]         }))
[11:01:21.185]     }, error = function(ex) {
[11:01:21.185]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:21.185]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.185]                 ...future.rng), started = ...future.startTime, 
[11:01:21.185]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:21.185]             version = "1.8"), class = "FutureResult")
[11:01:21.185]     }, finally = {
[11:01:21.185]         if (!identical(...future.workdir, getwd())) 
[11:01:21.185]             setwd(...future.workdir)
[11:01:21.185]         {
[11:01:21.185]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:21.185]                 ...future.oldOptions$nwarnings <- NULL
[11:01:21.185]             }
[11:01:21.185]             base::options(...future.oldOptions)
[11:01:21.185]             if (.Platform$OS.type == "windows") {
[11:01:21.185]                 old_names <- names(...future.oldEnvVars)
[11:01:21.185]                 envs <- base::Sys.getenv()
[11:01:21.185]                 names <- names(envs)
[11:01:21.185]                 common <- intersect(names, old_names)
[11:01:21.185]                 added <- setdiff(names, old_names)
[11:01:21.185]                 removed <- setdiff(old_names, names)
[11:01:21.185]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:21.185]                   envs[common]]
[11:01:21.185]                 NAMES <- toupper(changed)
[11:01:21.185]                 args <- list()
[11:01:21.185]                 for (kk in seq_along(NAMES)) {
[11:01:21.185]                   name <- changed[[kk]]
[11:01:21.185]                   NAME <- NAMES[[kk]]
[11:01:21.185]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.185]                     next
[11:01:21.185]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.185]                 }
[11:01:21.185]                 NAMES <- toupper(added)
[11:01:21.185]                 for (kk in seq_along(NAMES)) {
[11:01:21.185]                   name <- added[[kk]]
[11:01:21.185]                   NAME <- NAMES[[kk]]
[11:01:21.185]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.185]                     next
[11:01:21.185]                   args[[name]] <- ""
[11:01:21.185]                 }
[11:01:21.185]                 NAMES <- toupper(removed)
[11:01:21.185]                 for (kk in seq_along(NAMES)) {
[11:01:21.185]                   name <- removed[[kk]]
[11:01:21.185]                   NAME <- NAMES[[kk]]
[11:01:21.185]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.185]                     next
[11:01:21.185]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.185]                 }
[11:01:21.185]                 if (length(args) > 0) 
[11:01:21.185]                   base::do.call(base::Sys.setenv, args = args)
[11:01:21.185]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:21.185]             }
[11:01:21.185]             else {
[11:01:21.185]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:21.185]             }
[11:01:21.185]             {
[11:01:21.185]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:21.185]                   0L) {
[11:01:21.185]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:21.185]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:21.185]                   base::options(opts)
[11:01:21.185]                 }
[11:01:21.185]                 {
[11:01:21.185]                   {
[11:01:21.185]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:21.185]                     NULL
[11:01:21.185]                   }
[11:01:21.185]                   options(future.plan = NULL)
[11:01:21.185]                   if (is.na(NA_character_)) 
[11:01:21.185]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.185]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:21.185]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:21.185]                     .init = FALSE)
[11:01:21.185]                 }
[11:01:21.185]             }
[11:01:21.185]         }
[11:01:21.185]     })
[11:01:21.185]     if (TRUE) {
[11:01:21.185]         base::sink(type = "output", split = FALSE)
[11:01:21.185]         if (TRUE) {
[11:01:21.185]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:21.185]         }
[11:01:21.185]         else {
[11:01:21.185]             ...future.result["stdout"] <- base::list(NULL)
[11:01:21.185]         }
[11:01:21.185]         base::close(...future.stdout)
[11:01:21.185]         ...future.stdout <- NULL
[11:01:21.185]     }
[11:01:21.185]     ...future.result$conditions <- ...future.conditions
[11:01:21.185]     ...future.result$finished <- base::Sys.time()
[11:01:21.185]     ...future.result
[11:01:21.185] }
[11:01:21.188] Exporting 1 global objects (346 bytes) to cluster node #1 ...
[11:01:21.188] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[11:01:21.192] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[11:01:21.192] Exporting 1 global objects (346 bytes) to cluster node #1 ... DONE
[11:01:21.193] MultisessionFuture started
[11:01:21.193] - Launch lazy future ... done
[11:01:21.193] run() for ‘MultisessionFuture’ ... done
[11:01:21.193] result() for ClusterFuture ...
[11:01:21.193] receiveMessageFromWorker() for ClusterFuture ...
[11:01:21.193] - Validating connection of MultisessionFuture
[11:01:21.234] - received message: FutureResult
[11:01:21.234] - Received FutureResult
[11:01:21.234] - Erased future from FutureRegistry
[11:01:21.234] result() for ClusterFuture ...
[11:01:21.234] - result already collected: FutureResult
[11:01:21.235] result() for ClusterFuture ... done
[11:01:21.235] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:21.235] result() for ClusterFuture ... done
[11:01:21.235] result() for ClusterFuture ...
[11:01:21.235] - result already collected: FutureResult
[11:01:21.235] result() for ClusterFuture ... done
** Future evaluation with errors
[11:01:21.236] getGlobalsAndPackages() ...
[11:01:21.236] Searching for globals...
[11:01:21.237] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[11:01:21.237] Searching for globals ... DONE
[11:01:21.238] Resolving globals: FALSE
[11:01:21.238] 
[11:01:21.238] 
[11:01:21.238] getGlobalsAndPackages() ... DONE
[11:01:21.238] run() for ‘Future’ ...
[11:01:21.239] - state: ‘created’
[11:01:21.239] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:21.253] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:21.253] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:21.253]   - Field: ‘node’
[11:01:21.253]   - Field: ‘label’
[11:01:21.253]   - Field: ‘local’
[11:01:21.254]   - Field: ‘owner’
[11:01:21.254]   - Field: ‘envir’
[11:01:21.254]   - Field: ‘workers’
[11:01:21.254]   - Field: ‘packages’
[11:01:21.254]   - Field: ‘gc’
[11:01:21.254]   - Field: ‘conditions’
[11:01:21.254]   - Field: ‘persistent’
[11:01:21.254]   - Field: ‘expr’
[11:01:21.254]   - Field: ‘uuid’
[11:01:21.254]   - Field: ‘seed’
[11:01:21.254]   - Field: ‘version’
[11:01:21.255]   - Field: ‘result’
[11:01:21.255]   - Field: ‘asynchronous’
[11:01:21.255]   - Field: ‘calls’
[11:01:21.255]   - Field: ‘globals’
[11:01:21.255]   - Field: ‘stdout’
[11:01:21.255]   - Field: ‘earlySignal’
[11:01:21.255]   - Field: ‘lazy’
[11:01:21.255]   - Field: ‘state’
[11:01:21.255] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:21.256] - Launch lazy future ...
[11:01:21.256] Packages needed by the future expression (n = 0): <none>
[11:01:21.256] Packages needed by future strategies (n = 0): <none>
[11:01:21.256] {
[11:01:21.256]     {
[11:01:21.256]         {
[11:01:21.256]             ...future.startTime <- base::Sys.time()
[11:01:21.256]             {
[11:01:21.256]                 {
[11:01:21.256]                   {
[11:01:21.256]                     {
[11:01:21.256]                       base::local({
[11:01:21.256]                         has_future <- base::requireNamespace("future", 
[11:01:21.256]                           quietly = TRUE)
[11:01:21.256]                         if (has_future) {
[11:01:21.256]                           ns <- base::getNamespace("future")
[11:01:21.256]                           version <- ns[[".package"]][["version"]]
[11:01:21.256]                           if (is.null(version)) 
[11:01:21.256]                             version <- utils::packageVersion("future")
[11:01:21.256]                         }
[11:01:21.256]                         else {
[11:01:21.256]                           version <- NULL
[11:01:21.256]                         }
[11:01:21.256]                         if (!has_future || version < "1.8.0") {
[11:01:21.256]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:21.256]                             "", base::R.version$version.string), 
[11:01:21.256]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:21.256]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:21.256]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:21.256]                               "release", "version")], collapse = " "), 
[11:01:21.256]                             hostname = base::Sys.info()[["nodename"]])
[11:01:21.256]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:21.256]                             info)
[11:01:21.256]                           info <- base::paste(info, collapse = "; ")
[11:01:21.256]                           if (!has_future) {
[11:01:21.256]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:21.256]                               info)
[11:01:21.256]                           }
[11:01:21.256]                           else {
[11:01:21.256]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:21.256]                               info, version)
[11:01:21.256]                           }
[11:01:21.256]                           base::stop(msg)
[11:01:21.256]                         }
[11:01:21.256]                       })
[11:01:21.256]                     }
[11:01:21.256]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:21.256]                     base::options(mc.cores = 1L)
[11:01:21.256]                   }
[11:01:21.256]                   ...future.strategy.old <- future::plan("list")
[11:01:21.256]                   options(future.plan = NULL)
[11:01:21.256]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.256]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:21.256]                 }
[11:01:21.256]                 ...future.workdir <- getwd()
[11:01:21.256]             }
[11:01:21.256]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:21.256]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:21.256]         }
[11:01:21.256]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:21.256]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:21.256]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:21.256]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:21.256]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:21.256]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:21.256]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:21.256]             base::names(...future.oldOptions))
[11:01:21.256]     }
[11:01:21.256]     if (FALSE) {
[11:01:21.256]     }
[11:01:21.256]     else {
[11:01:21.256]         if (TRUE) {
[11:01:21.256]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:21.256]                 open = "w")
[11:01:21.256]         }
[11:01:21.256]         else {
[11:01:21.256]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:21.256]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:21.256]         }
[11:01:21.256]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:21.256]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:21.256]             base::sink(type = "output", split = FALSE)
[11:01:21.256]             base::close(...future.stdout)
[11:01:21.256]         }, add = TRUE)
[11:01:21.256]     }
[11:01:21.256]     ...future.frame <- base::sys.nframe()
[11:01:21.256]     ...future.conditions <- base::list()
[11:01:21.256]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:21.256]     if (FALSE) {
[11:01:21.256]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:21.256]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:21.256]     }
[11:01:21.256]     ...future.result <- base::tryCatch({
[11:01:21.256]         base::withCallingHandlers({
[11:01:21.256]             ...future.value <- base::withVisible(base::local({
[11:01:21.256]                 ...future.makeSendCondition <- base::local({
[11:01:21.256]                   sendCondition <- NULL
[11:01:21.256]                   function(frame = 1L) {
[11:01:21.256]                     if (is.function(sendCondition)) 
[11:01:21.256]                       return(sendCondition)
[11:01:21.256]                     ns <- getNamespace("parallel")
[11:01:21.256]                     if (exists("sendData", mode = "function", 
[11:01:21.256]                       envir = ns)) {
[11:01:21.256]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:21.256]                         envir = ns)
[11:01:21.256]                       envir <- sys.frame(frame)
[11:01:21.256]                       master <- NULL
[11:01:21.256]                       while (!identical(envir, .GlobalEnv) && 
[11:01:21.256]                         !identical(envir, emptyenv())) {
[11:01:21.256]                         if (exists("master", mode = "list", envir = envir, 
[11:01:21.256]                           inherits = FALSE)) {
[11:01:21.256]                           master <- get("master", mode = "list", 
[11:01:21.256]                             envir = envir, inherits = FALSE)
[11:01:21.256]                           if (inherits(master, c("SOCKnode", 
[11:01:21.256]                             "SOCK0node"))) {
[11:01:21.256]                             sendCondition <<- function(cond) {
[11:01:21.256]                               data <- list(type = "VALUE", value = cond, 
[11:01:21.256]                                 success = TRUE)
[11:01:21.256]                               parallel_sendData(master, data)
[11:01:21.256]                             }
[11:01:21.256]                             return(sendCondition)
[11:01:21.256]                           }
[11:01:21.256]                         }
[11:01:21.256]                         frame <- frame + 1L
[11:01:21.256]                         envir <- sys.frame(frame)
[11:01:21.256]                       }
[11:01:21.256]                     }
[11:01:21.256]                     sendCondition <<- function(cond) NULL
[11:01:21.256]                   }
[11:01:21.256]                 })
[11:01:21.256]                 withCallingHandlers({
[11:01:21.256]                   {
[11:01:21.256]                     x <- 3
[11:01:21.256]                     stop("Woops!")
[11:01:21.256]                     x
[11:01:21.256]                   }
[11:01:21.256]                 }, immediateCondition = function(cond) {
[11:01:21.256]                   sendCondition <- ...future.makeSendCondition()
[11:01:21.256]                   sendCondition(cond)
[11:01:21.256]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.256]                   {
[11:01:21.256]                     inherits <- base::inherits
[11:01:21.256]                     invokeRestart <- base::invokeRestart
[11:01:21.256]                     is.null <- base::is.null
[11:01:21.256]                     muffled <- FALSE
[11:01:21.256]                     if (inherits(cond, "message")) {
[11:01:21.256]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:21.256]                       if (muffled) 
[11:01:21.256]                         invokeRestart("muffleMessage")
[11:01:21.256]                     }
[11:01:21.256]                     else if (inherits(cond, "warning")) {
[11:01:21.256]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:21.256]                       if (muffled) 
[11:01:21.256]                         invokeRestart("muffleWarning")
[11:01:21.256]                     }
[11:01:21.256]                     else if (inherits(cond, "condition")) {
[11:01:21.256]                       if (!is.null(pattern)) {
[11:01:21.256]                         computeRestarts <- base::computeRestarts
[11:01:21.256]                         grepl <- base::grepl
[11:01:21.256]                         restarts <- computeRestarts(cond)
[11:01:21.256]                         for (restart in restarts) {
[11:01:21.256]                           name <- restart$name
[11:01:21.256]                           if (is.null(name)) 
[11:01:21.256]                             next
[11:01:21.256]                           if (!grepl(pattern, name)) 
[11:01:21.256]                             next
[11:01:21.256]                           invokeRestart(restart)
[11:01:21.256]                           muffled <- TRUE
[11:01:21.256]                           break
[11:01:21.256]                         }
[11:01:21.256]                       }
[11:01:21.256]                     }
[11:01:21.256]                     invisible(muffled)
[11:01:21.256]                   }
[11:01:21.256]                   muffleCondition(cond)
[11:01:21.256]                 })
[11:01:21.256]             }))
[11:01:21.256]             future::FutureResult(value = ...future.value$value, 
[11:01:21.256]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.256]                   ...future.rng), globalenv = if (FALSE) 
[11:01:21.256]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:21.256]                     ...future.globalenv.names))
[11:01:21.256]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:21.256]         }, condition = base::local({
[11:01:21.256]             c <- base::c
[11:01:21.256]             inherits <- base::inherits
[11:01:21.256]             invokeRestart <- base::invokeRestart
[11:01:21.256]             length <- base::length
[11:01:21.256]             list <- base::list
[11:01:21.256]             seq.int <- base::seq.int
[11:01:21.256]             signalCondition <- base::signalCondition
[11:01:21.256]             sys.calls <- base::sys.calls
[11:01:21.256]             `[[` <- base::`[[`
[11:01:21.256]             `+` <- base::`+`
[11:01:21.256]             `<<-` <- base::`<<-`
[11:01:21.256]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:21.256]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:21.256]                   3L)]
[11:01:21.256]             }
[11:01:21.256]             function(cond) {
[11:01:21.256]                 is_error <- inherits(cond, "error")
[11:01:21.256]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:21.256]                   NULL)
[11:01:21.256]                 if (is_error) {
[11:01:21.256]                   sessionInformation <- function() {
[11:01:21.256]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:21.256]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:21.256]                       search = base::search(), system = base::Sys.info())
[11:01:21.256]                   }
[11:01:21.256]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.256]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:21.256]                     cond$call), session = sessionInformation(), 
[11:01:21.256]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:21.256]                   signalCondition(cond)
[11:01:21.256]                 }
[11:01:21.256]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:21.256]                 "immediateCondition"))) {
[11:01:21.256]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:21.256]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.256]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:21.256]                   if (TRUE && !signal) {
[11:01:21.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.256]                     {
[11:01:21.256]                       inherits <- base::inherits
[11:01:21.256]                       invokeRestart <- base::invokeRestart
[11:01:21.256]                       is.null <- base::is.null
[11:01:21.256]                       muffled <- FALSE
[11:01:21.256]                       if (inherits(cond, "message")) {
[11:01:21.256]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.256]                         if (muffled) 
[11:01:21.256]                           invokeRestart("muffleMessage")
[11:01:21.256]                       }
[11:01:21.256]                       else if (inherits(cond, "warning")) {
[11:01:21.256]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.256]                         if (muffled) 
[11:01:21.256]                           invokeRestart("muffleWarning")
[11:01:21.256]                       }
[11:01:21.256]                       else if (inherits(cond, "condition")) {
[11:01:21.256]                         if (!is.null(pattern)) {
[11:01:21.256]                           computeRestarts <- base::computeRestarts
[11:01:21.256]                           grepl <- base::grepl
[11:01:21.256]                           restarts <- computeRestarts(cond)
[11:01:21.256]                           for (restart in restarts) {
[11:01:21.256]                             name <- restart$name
[11:01:21.256]                             if (is.null(name)) 
[11:01:21.256]                               next
[11:01:21.256]                             if (!grepl(pattern, name)) 
[11:01:21.256]                               next
[11:01:21.256]                             invokeRestart(restart)
[11:01:21.256]                             muffled <- TRUE
[11:01:21.256]                             break
[11:01:21.256]                           }
[11:01:21.256]                         }
[11:01:21.256]                       }
[11:01:21.256]                       invisible(muffled)
[11:01:21.256]                     }
[11:01:21.256]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.256]                   }
[11:01:21.256]                 }
[11:01:21.256]                 else {
[11:01:21.256]                   if (TRUE) {
[11:01:21.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.256]                     {
[11:01:21.256]                       inherits <- base::inherits
[11:01:21.256]                       invokeRestart <- base::invokeRestart
[11:01:21.256]                       is.null <- base::is.null
[11:01:21.256]                       muffled <- FALSE
[11:01:21.256]                       if (inherits(cond, "message")) {
[11:01:21.256]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.256]                         if (muffled) 
[11:01:21.256]                           invokeRestart("muffleMessage")
[11:01:21.256]                       }
[11:01:21.256]                       else if (inherits(cond, "warning")) {
[11:01:21.256]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.256]                         if (muffled) 
[11:01:21.256]                           invokeRestart("muffleWarning")
[11:01:21.256]                       }
[11:01:21.256]                       else if (inherits(cond, "condition")) {
[11:01:21.256]                         if (!is.null(pattern)) {
[11:01:21.256]                           computeRestarts <- base::computeRestarts
[11:01:21.256]                           grepl <- base::grepl
[11:01:21.256]                           restarts <- computeRestarts(cond)
[11:01:21.256]                           for (restart in restarts) {
[11:01:21.256]                             name <- restart$name
[11:01:21.256]                             if (is.null(name)) 
[11:01:21.256]                               next
[11:01:21.256]                             if (!grepl(pattern, name)) 
[11:01:21.256]                               next
[11:01:21.256]                             invokeRestart(restart)
[11:01:21.256]                             muffled <- TRUE
[11:01:21.256]                             break
[11:01:21.256]                           }
[11:01:21.256]                         }
[11:01:21.256]                       }
[11:01:21.256]                       invisible(muffled)
[11:01:21.256]                     }
[11:01:21.256]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.256]                   }
[11:01:21.256]                 }
[11:01:21.256]             }
[11:01:21.256]         }))
[11:01:21.256]     }, error = function(ex) {
[11:01:21.256]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:21.256]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.256]                 ...future.rng), started = ...future.startTime, 
[11:01:21.256]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:21.256]             version = "1.8"), class = "FutureResult")
[11:01:21.256]     }, finally = {
[11:01:21.256]         if (!identical(...future.workdir, getwd())) 
[11:01:21.256]             setwd(...future.workdir)
[11:01:21.256]         {
[11:01:21.256]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:21.256]                 ...future.oldOptions$nwarnings <- NULL
[11:01:21.256]             }
[11:01:21.256]             base::options(...future.oldOptions)
[11:01:21.256]             if (.Platform$OS.type == "windows") {
[11:01:21.256]                 old_names <- names(...future.oldEnvVars)
[11:01:21.256]                 envs <- base::Sys.getenv()
[11:01:21.256]                 names <- names(envs)
[11:01:21.256]                 common <- intersect(names, old_names)
[11:01:21.256]                 added <- setdiff(names, old_names)
[11:01:21.256]                 removed <- setdiff(old_names, names)
[11:01:21.256]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:21.256]                   envs[common]]
[11:01:21.256]                 NAMES <- toupper(changed)
[11:01:21.256]                 args <- list()
[11:01:21.256]                 for (kk in seq_along(NAMES)) {
[11:01:21.256]                   name <- changed[[kk]]
[11:01:21.256]                   NAME <- NAMES[[kk]]
[11:01:21.256]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.256]                     next
[11:01:21.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.256]                 }
[11:01:21.256]                 NAMES <- toupper(added)
[11:01:21.256]                 for (kk in seq_along(NAMES)) {
[11:01:21.256]                   name <- added[[kk]]
[11:01:21.256]                   NAME <- NAMES[[kk]]
[11:01:21.256]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.256]                     next
[11:01:21.256]                   args[[name]] <- ""
[11:01:21.256]                 }
[11:01:21.256]                 NAMES <- toupper(removed)
[11:01:21.256]                 for (kk in seq_along(NAMES)) {
[11:01:21.256]                   name <- removed[[kk]]
[11:01:21.256]                   NAME <- NAMES[[kk]]
[11:01:21.256]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.256]                     next
[11:01:21.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.256]                 }
[11:01:21.256]                 if (length(args) > 0) 
[11:01:21.256]                   base::do.call(base::Sys.setenv, args = args)
[11:01:21.256]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:21.256]             }
[11:01:21.256]             else {
[11:01:21.256]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:21.256]             }
[11:01:21.256]             {
[11:01:21.256]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:21.256]                   0L) {
[11:01:21.256]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:21.256]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:21.256]                   base::options(opts)
[11:01:21.256]                 }
[11:01:21.256]                 {
[11:01:21.256]                   {
[11:01:21.256]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:21.256]                     NULL
[11:01:21.256]                   }
[11:01:21.256]                   options(future.plan = NULL)
[11:01:21.256]                   if (is.na(NA_character_)) 
[11:01:21.256]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.256]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:21.256]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:21.256]                     .init = FALSE)
[11:01:21.256]                 }
[11:01:21.256]             }
[11:01:21.256]         }
[11:01:21.256]     })
[11:01:21.256]     if (TRUE) {
[11:01:21.256]         base::sink(type = "output", split = FALSE)
[11:01:21.256]         if (TRUE) {
[11:01:21.256]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:21.256]         }
[11:01:21.256]         else {
[11:01:21.256]             ...future.result["stdout"] <- base::list(NULL)
[11:01:21.256]         }
[11:01:21.256]         base::close(...future.stdout)
[11:01:21.256]         ...future.stdout <- NULL
[11:01:21.256]     }
[11:01:21.256]     ...future.result$conditions <- ...future.conditions
[11:01:21.256]     ...future.result$finished <- base::Sys.time()
[11:01:21.256]     ...future.result
[11:01:21.256] }
[11:01:21.260] MultisessionFuture started
[11:01:21.260] - Launch lazy future ... done
[11:01:21.260] run() for ‘MultisessionFuture’ ... done
[11:01:21.260] result() for ClusterFuture ...
[11:01:21.260] receiveMessageFromWorker() for ClusterFuture ...
[11:01:21.260] - Validating connection of MultisessionFuture
[11:01:21.302] - received message: FutureResult
[11:01:21.303] - Received FutureResult
[11:01:21.303] - Erased future from FutureRegistry
[11:01:21.303] result() for ClusterFuture ...
[11:01:21.303] - result already collected: FutureResult
[11:01:21.303] result() for ClusterFuture ... done
[11:01:21.303] signalConditions() ...
[11:01:21.303]  - include = ‘immediateCondition’
[11:01:21.303]  - exclude = 
[11:01:21.304]  - resignal = FALSE
[11:01:21.304]  - Number of conditions: 1
[11:01:21.304] signalConditions() ... done
[11:01:21.304] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:21.304] result() for ClusterFuture ... done
[11:01:21.304] result() for ClusterFuture ...
[11:01:21.304] - result already collected: FutureResult
[11:01:21.304] result() for ClusterFuture ... done
[11:01:21.304] signalConditions() ...
[11:01:21.305]  - include = ‘immediateCondition’
[11:01:21.305]  - exclude = 
[11:01:21.305]  - resignal = FALSE
[11:01:21.305]  - Number of conditions: 1
[11:01:21.305] signalConditions() ... done
[11:01:21.305] Future state: ‘finished’
[11:01:21.305] result() for ClusterFuture ...
[11:01:21.305] - result already collected: FutureResult
[11:01:21.305] result() for ClusterFuture ... done
[11:01:21.306] signalConditions() ...
[11:01:21.306]  - include = ‘condition’
[11:01:21.306]  - exclude = ‘immediateCondition’
[11:01:21.306]  - resignal = TRUE
[11:01:21.306]  - Number of conditions: 1
[11:01:21.306]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:21.306] signalConditions() ... done
[11:01:21.307] getGlobalsAndPackages() ...
[11:01:21.307] Searching for globals...
[11:01:21.309] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[11:01:21.309] Searching for globals ... DONE
[11:01:21.309] Resolving globals: FALSE
[11:01:21.309] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:21.310] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:21.310] - globals: [1] ‘ii’
[11:01:21.310] 
[11:01:21.310] getGlobalsAndPackages() ... DONE
[11:01:21.310] run() for ‘Future’ ...
[11:01:21.311] - state: ‘created’
[11:01:21.311] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:21.327] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:21.327] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:21.328]   - Field: ‘node’
[11:01:21.328]   - Field: ‘label’
[11:01:21.328]   - Field: ‘local’
[11:01:21.328]   - Field: ‘owner’
[11:01:21.328]   - Field: ‘envir’
[11:01:21.328]   - Field: ‘workers’
[11:01:21.329]   - Field: ‘packages’
[11:01:21.329]   - Field: ‘gc’
[11:01:21.329]   - Field: ‘conditions’
[11:01:21.329]   - Field: ‘persistent’
[11:01:21.329]   - Field: ‘expr’
[11:01:21.330]   - Field: ‘uuid’
[11:01:21.330]   - Field: ‘seed’
[11:01:21.330]   - Field: ‘version’
[11:01:21.330]   - Field: ‘result’
[11:01:21.330]   - Field: ‘asynchronous’
[11:01:21.331]   - Field: ‘calls’
[11:01:21.331]   - Field: ‘globals’
[11:01:21.331]   - Field: ‘stdout’
[11:01:21.331]   - Field: ‘earlySignal’
[11:01:21.331]   - Field: ‘lazy’
[11:01:21.332]   - Field: ‘state’
[11:01:21.332] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:21.332] - Launch lazy future ...
[11:01:21.333] Packages needed by the future expression (n = 0): <none>
[11:01:21.333] Packages needed by future strategies (n = 0): <none>
[11:01:21.334] {
[11:01:21.334]     {
[11:01:21.334]         {
[11:01:21.334]             ...future.startTime <- base::Sys.time()
[11:01:21.334]             {
[11:01:21.334]                 {
[11:01:21.334]                   {
[11:01:21.334]                     {
[11:01:21.334]                       base::local({
[11:01:21.334]                         has_future <- base::requireNamespace("future", 
[11:01:21.334]                           quietly = TRUE)
[11:01:21.334]                         if (has_future) {
[11:01:21.334]                           ns <- base::getNamespace("future")
[11:01:21.334]                           version <- ns[[".package"]][["version"]]
[11:01:21.334]                           if (is.null(version)) 
[11:01:21.334]                             version <- utils::packageVersion("future")
[11:01:21.334]                         }
[11:01:21.334]                         else {
[11:01:21.334]                           version <- NULL
[11:01:21.334]                         }
[11:01:21.334]                         if (!has_future || version < "1.8.0") {
[11:01:21.334]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:21.334]                             "", base::R.version$version.string), 
[11:01:21.334]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:21.334]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:21.334]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:21.334]                               "release", "version")], collapse = " "), 
[11:01:21.334]                             hostname = base::Sys.info()[["nodename"]])
[11:01:21.334]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:21.334]                             info)
[11:01:21.334]                           info <- base::paste(info, collapse = "; ")
[11:01:21.334]                           if (!has_future) {
[11:01:21.334]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:21.334]                               info)
[11:01:21.334]                           }
[11:01:21.334]                           else {
[11:01:21.334]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:21.334]                               info, version)
[11:01:21.334]                           }
[11:01:21.334]                           base::stop(msg)
[11:01:21.334]                         }
[11:01:21.334]                       })
[11:01:21.334]                     }
[11:01:21.334]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:21.334]                     base::options(mc.cores = 1L)
[11:01:21.334]                   }
[11:01:21.334]                   ...future.strategy.old <- future::plan("list")
[11:01:21.334]                   options(future.plan = NULL)
[11:01:21.334]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.334]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:21.334]                 }
[11:01:21.334]                 ...future.workdir <- getwd()
[11:01:21.334]             }
[11:01:21.334]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:21.334]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:21.334]         }
[11:01:21.334]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:21.334]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:21.334]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:21.334]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:21.334]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:21.334]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:21.334]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:21.334]             base::names(...future.oldOptions))
[11:01:21.334]     }
[11:01:21.334]     if (FALSE) {
[11:01:21.334]     }
[11:01:21.334]     else {
[11:01:21.334]         if (TRUE) {
[11:01:21.334]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:21.334]                 open = "w")
[11:01:21.334]         }
[11:01:21.334]         else {
[11:01:21.334]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:21.334]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:21.334]         }
[11:01:21.334]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:21.334]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:21.334]             base::sink(type = "output", split = FALSE)
[11:01:21.334]             base::close(...future.stdout)
[11:01:21.334]         }, add = TRUE)
[11:01:21.334]     }
[11:01:21.334]     ...future.frame <- base::sys.nframe()
[11:01:21.334]     ...future.conditions <- base::list()
[11:01:21.334]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:21.334]     if (FALSE) {
[11:01:21.334]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:21.334]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:21.334]     }
[11:01:21.334]     ...future.result <- base::tryCatch({
[11:01:21.334]         base::withCallingHandlers({
[11:01:21.334]             ...future.value <- base::withVisible(base::local({
[11:01:21.334]                 ...future.makeSendCondition <- base::local({
[11:01:21.334]                   sendCondition <- NULL
[11:01:21.334]                   function(frame = 1L) {
[11:01:21.334]                     if (is.function(sendCondition)) 
[11:01:21.334]                       return(sendCondition)
[11:01:21.334]                     ns <- getNamespace("parallel")
[11:01:21.334]                     if (exists("sendData", mode = "function", 
[11:01:21.334]                       envir = ns)) {
[11:01:21.334]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:21.334]                         envir = ns)
[11:01:21.334]                       envir <- sys.frame(frame)
[11:01:21.334]                       master <- NULL
[11:01:21.334]                       while (!identical(envir, .GlobalEnv) && 
[11:01:21.334]                         !identical(envir, emptyenv())) {
[11:01:21.334]                         if (exists("master", mode = "list", envir = envir, 
[11:01:21.334]                           inherits = FALSE)) {
[11:01:21.334]                           master <- get("master", mode = "list", 
[11:01:21.334]                             envir = envir, inherits = FALSE)
[11:01:21.334]                           if (inherits(master, c("SOCKnode", 
[11:01:21.334]                             "SOCK0node"))) {
[11:01:21.334]                             sendCondition <<- function(cond) {
[11:01:21.334]                               data <- list(type = "VALUE", value = cond, 
[11:01:21.334]                                 success = TRUE)
[11:01:21.334]                               parallel_sendData(master, data)
[11:01:21.334]                             }
[11:01:21.334]                             return(sendCondition)
[11:01:21.334]                           }
[11:01:21.334]                         }
[11:01:21.334]                         frame <- frame + 1L
[11:01:21.334]                         envir <- sys.frame(frame)
[11:01:21.334]                       }
[11:01:21.334]                     }
[11:01:21.334]                     sendCondition <<- function(cond) NULL
[11:01:21.334]                   }
[11:01:21.334]                 })
[11:01:21.334]                 withCallingHandlers({
[11:01:21.334]                   {
[11:01:21.334]                     if (ii%%2 == 0) 
[11:01:21.334]                       stop("Woops!")
[11:01:21.334]                     ii
[11:01:21.334]                   }
[11:01:21.334]                 }, immediateCondition = function(cond) {
[11:01:21.334]                   sendCondition <- ...future.makeSendCondition()
[11:01:21.334]                   sendCondition(cond)
[11:01:21.334]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.334]                   {
[11:01:21.334]                     inherits <- base::inherits
[11:01:21.334]                     invokeRestart <- base::invokeRestart
[11:01:21.334]                     is.null <- base::is.null
[11:01:21.334]                     muffled <- FALSE
[11:01:21.334]                     if (inherits(cond, "message")) {
[11:01:21.334]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:21.334]                       if (muffled) 
[11:01:21.334]                         invokeRestart("muffleMessage")
[11:01:21.334]                     }
[11:01:21.334]                     else if (inherits(cond, "warning")) {
[11:01:21.334]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:21.334]                       if (muffled) 
[11:01:21.334]                         invokeRestart("muffleWarning")
[11:01:21.334]                     }
[11:01:21.334]                     else if (inherits(cond, "condition")) {
[11:01:21.334]                       if (!is.null(pattern)) {
[11:01:21.334]                         computeRestarts <- base::computeRestarts
[11:01:21.334]                         grepl <- base::grepl
[11:01:21.334]                         restarts <- computeRestarts(cond)
[11:01:21.334]                         for (restart in restarts) {
[11:01:21.334]                           name <- restart$name
[11:01:21.334]                           if (is.null(name)) 
[11:01:21.334]                             next
[11:01:21.334]                           if (!grepl(pattern, name)) 
[11:01:21.334]                             next
[11:01:21.334]                           invokeRestart(restart)
[11:01:21.334]                           muffled <- TRUE
[11:01:21.334]                           break
[11:01:21.334]                         }
[11:01:21.334]                       }
[11:01:21.334]                     }
[11:01:21.334]                     invisible(muffled)
[11:01:21.334]                   }
[11:01:21.334]                   muffleCondition(cond)
[11:01:21.334]                 })
[11:01:21.334]             }))
[11:01:21.334]             future::FutureResult(value = ...future.value$value, 
[11:01:21.334]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.334]                   ...future.rng), globalenv = if (FALSE) 
[11:01:21.334]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:21.334]                     ...future.globalenv.names))
[11:01:21.334]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:21.334]         }, condition = base::local({
[11:01:21.334]             c <- base::c
[11:01:21.334]             inherits <- base::inherits
[11:01:21.334]             invokeRestart <- base::invokeRestart
[11:01:21.334]             length <- base::length
[11:01:21.334]             list <- base::list
[11:01:21.334]             seq.int <- base::seq.int
[11:01:21.334]             signalCondition <- base::signalCondition
[11:01:21.334]             sys.calls <- base::sys.calls
[11:01:21.334]             `[[` <- base::`[[`
[11:01:21.334]             `+` <- base::`+`
[11:01:21.334]             `<<-` <- base::`<<-`
[11:01:21.334]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:21.334]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:21.334]                   3L)]
[11:01:21.334]             }
[11:01:21.334]             function(cond) {
[11:01:21.334]                 is_error <- inherits(cond, "error")
[11:01:21.334]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:21.334]                   NULL)
[11:01:21.334]                 if (is_error) {
[11:01:21.334]                   sessionInformation <- function() {
[11:01:21.334]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:21.334]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:21.334]                       search = base::search(), system = base::Sys.info())
[11:01:21.334]                   }
[11:01:21.334]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.334]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:21.334]                     cond$call), session = sessionInformation(), 
[11:01:21.334]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:21.334]                   signalCondition(cond)
[11:01:21.334]                 }
[11:01:21.334]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:21.334]                 "immediateCondition"))) {
[11:01:21.334]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:21.334]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.334]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:21.334]                   if (TRUE && !signal) {
[11:01:21.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.334]                     {
[11:01:21.334]                       inherits <- base::inherits
[11:01:21.334]                       invokeRestart <- base::invokeRestart
[11:01:21.334]                       is.null <- base::is.null
[11:01:21.334]                       muffled <- FALSE
[11:01:21.334]                       if (inherits(cond, "message")) {
[11:01:21.334]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.334]                         if (muffled) 
[11:01:21.334]                           invokeRestart("muffleMessage")
[11:01:21.334]                       }
[11:01:21.334]                       else if (inherits(cond, "warning")) {
[11:01:21.334]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.334]                         if (muffled) 
[11:01:21.334]                           invokeRestart("muffleWarning")
[11:01:21.334]                       }
[11:01:21.334]                       else if (inherits(cond, "condition")) {
[11:01:21.334]                         if (!is.null(pattern)) {
[11:01:21.334]                           computeRestarts <- base::computeRestarts
[11:01:21.334]                           grepl <- base::grepl
[11:01:21.334]                           restarts <- computeRestarts(cond)
[11:01:21.334]                           for (restart in restarts) {
[11:01:21.334]                             name <- restart$name
[11:01:21.334]                             if (is.null(name)) 
[11:01:21.334]                               next
[11:01:21.334]                             if (!grepl(pattern, name)) 
[11:01:21.334]                               next
[11:01:21.334]                             invokeRestart(restart)
[11:01:21.334]                             muffled <- TRUE
[11:01:21.334]                             break
[11:01:21.334]                           }
[11:01:21.334]                         }
[11:01:21.334]                       }
[11:01:21.334]                       invisible(muffled)
[11:01:21.334]                     }
[11:01:21.334]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.334]                   }
[11:01:21.334]                 }
[11:01:21.334]                 else {
[11:01:21.334]                   if (TRUE) {
[11:01:21.334]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.334]                     {
[11:01:21.334]                       inherits <- base::inherits
[11:01:21.334]                       invokeRestart <- base::invokeRestart
[11:01:21.334]                       is.null <- base::is.null
[11:01:21.334]                       muffled <- FALSE
[11:01:21.334]                       if (inherits(cond, "message")) {
[11:01:21.334]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.334]                         if (muffled) 
[11:01:21.334]                           invokeRestart("muffleMessage")
[11:01:21.334]                       }
[11:01:21.334]                       else if (inherits(cond, "warning")) {
[11:01:21.334]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.334]                         if (muffled) 
[11:01:21.334]                           invokeRestart("muffleWarning")
[11:01:21.334]                       }
[11:01:21.334]                       else if (inherits(cond, "condition")) {
[11:01:21.334]                         if (!is.null(pattern)) {
[11:01:21.334]                           computeRestarts <- base::computeRestarts
[11:01:21.334]                           grepl <- base::grepl
[11:01:21.334]                           restarts <- computeRestarts(cond)
[11:01:21.334]                           for (restart in restarts) {
[11:01:21.334]                             name <- restart$name
[11:01:21.334]                             if (is.null(name)) 
[11:01:21.334]                               next
[11:01:21.334]                             if (!grepl(pattern, name)) 
[11:01:21.334]                               next
[11:01:21.334]                             invokeRestart(restart)
[11:01:21.334]                             muffled <- TRUE
[11:01:21.334]                             break
[11:01:21.334]                           }
[11:01:21.334]                         }
[11:01:21.334]                       }
[11:01:21.334]                       invisible(muffled)
[11:01:21.334]                     }
[11:01:21.334]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.334]                   }
[11:01:21.334]                 }
[11:01:21.334]             }
[11:01:21.334]         }))
[11:01:21.334]     }, error = function(ex) {
[11:01:21.334]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:21.334]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.334]                 ...future.rng), started = ...future.startTime, 
[11:01:21.334]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:21.334]             version = "1.8"), class = "FutureResult")
[11:01:21.334]     }, finally = {
[11:01:21.334]         if (!identical(...future.workdir, getwd())) 
[11:01:21.334]             setwd(...future.workdir)
[11:01:21.334]         {
[11:01:21.334]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:21.334]                 ...future.oldOptions$nwarnings <- NULL
[11:01:21.334]             }
[11:01:21.334]             base::options(...future.oldOptions)
[11:01:21.334]             if (.Platform$OS.type == "windows") {
[11:01:21.334]                 old_names <- names(...future.oldEnvVars)
[11:01:21.334]                 envs <- base::Sys.getenv()
[11:01:21.334]                 names <- names(envs)
[11:01:21.334]                 common <- intersect(names, old_names)
[11:01:21.334]                 added <- setdiff(names, old_names)
[11:01:21.334]                 removed <- setdiff(old_names, names)
[11:01:21.334]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:21.334]                   envs[common]]
[11:01:21.334]                 NAMES <- toupper(changed)
[11:01:21.334]                 args <- list()
[11:01:21.334]                 for (kk in seq_along(NAMES)) {
[11:01:21.334]                   name <- changed[[kk]]
[11:01:21.334]                   NAME <- NAMES[[kk]]
[11:01:21.334]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.334]                     next
[11:01:21.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.334]                 }
[11:01:21.334]                 NAMES <- toupper(added)
[11:01:21.334]                 for (kk in seq_along(NAMES)) {
[11:01:21.334]                   name <- added[[kk]]
[11:01:21.334]                   NAME <- NAMES[[kk]]
[11:01:21.334]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.334]                     next
[11:01:21.334]                   args[[name]] <- ""
[11:01:21.334]                 }
[11:01:21.334]                 NAMES <- toupper(removed)
[11:01:21.334]                 for (kk in seq_along(NAMES)) {
[11:01:21.334]                   name <- removed[[kk]]
[11:01:21.334]                   NAME <- NAMES[[kk]]
[11:01:21.334]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.334]                     next
[11:01:21.334]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.334]                 }
[11:01:21.334]                 if (length(args) > 0) 
[11:01:21.334]                   base::do.call(base::Sys.setenv, args = args)
[11:01:21.334]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:21.334]             }
[11:01:21.334]             else {
[11:01:21.334]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:21.334]             }
[11:01:21.334]             {
[11:01:21.334]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:21.334]                   0L) {
[11:01:21.334]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:21.334]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:21.334]                   base::options(opts)
[11:01:21.334]                 }
[11:01:21.334]                 {
[11:01:21.334]                   {
[11:01:21.334]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:21.334]                     NULL
[11:01:21.334]                   }
[11:01:21.334]                   options(future.plan = NULL)
[11:01:21.334]                   if (is.na(NA_character_)) 
[11:01:21.334]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.334]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:21.334]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:21.334]                     .init = FALSE)
[11:01:21.334]                 }
[11:01:21.334]             }
[11:01:21.334]         }
[11:01:21.334]     })
[11:01:21.334]     if (TRUE) {
[11:01:21.334]         base::sink(type = "output", split = FALSE)
[11:01:21.334]         if (TRUE) {
[11:01:21.334]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:21.334]         }
[11:01:21.334]         else {
[11:01:21.334]             ...future.result["stdout"] <- base::list(NULL)
[11:01:21.334]         }
[11:01:21.334]         base::close(...future.stdout)
[11:01:21.334]         ...future.stdout <- NULL
[11:01:21.334]     }
[11:01:21.334]     ...future.result$conditions <- ...future.conditions
[11:01:21.334]     ...future.result$finished <- base::Sys.time()
[11:01:21.334]     ...future.result
[11:01:21.334] }
[11:01:21.337] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[11:01:21.337] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[11:01:21.338] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[11:01:21.338] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[11:01:21.338] MultisessionFuture started
[11:01:21.338] - Launch lazy future ... done
[11:01:21.339] run() for ‘MultisessionFuture’ ... done
[11:01:21.339] getGlobalsAndPackages() ...
[11:01:21.339] Searching for globals...
[11:01:21.341] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[11:01:21.341] Searching for globals ... DONE
[11:01:21.341] Resolving globals: FALSE
[11:01:21.342] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:21.342] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:21.342] - globals: [1] ‘ii’
[11:01:21.343] 
[11:01:21.343] getGlobalsAndPackages() ... DONE
[11:01:21.343] run() for ‘Future’ ...
[11:01:21.343] - state: ‘created’
[11:01:21.343] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:21.358] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:21.358] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:21.358]   - Field: ‘node’
[11:01:21.358]   - Field: ‘label’
[11:01:21.358]   - Field: ‘local’
[11:01:21.358]   - Field: ‘owner’
[11:01:21.358]   - Field: ‘envir’
[11:01:21.358]   - Field: ‘workers’
[11:01:21.359]   - Field: ‘packages’
[11:01:21.359]   - Field: ‘gc’
[11:01:21.359]   - Field: ‘conditions’
[11:01:21.359]   - Field: ‘persistent’
[11:01:21.359]   - Field: ‘expr’
[11:01:21.359]   - Field: ‘uuid’
[11:01:21.359]   - Field: ‘seed’
[11:01:21.360]   - Field: ‘version’
[11:01:21.360]   - Field: ‘result’
[11:01:21.360]   - Field: ‘asynchronous’
[11:01:21.360]   - Field: ‘calls’
[11:01:21.360]   - Field: ‘globals’
[11:01:21.360]   - Field: ‘stdout’
[11:01:21.360]   - Field: ‘earlySignal’
[11:01:21.361]   - Field: ‘lazy’
[11:01:21.361]   - Field: ‘state’
[11:01:21.361] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:21.361] - Launch lazy future ...
[11:01:21.361] Packages needed by the future expression (n = 0): <none>
[11:01:21.362] Packages needed by future strategies (n = 0): <none>
[11:01:21.362] {
[11:01:21.362]     {
[11:01:21.362]         {
[11:01:21.362]             ...future.startTime <- base::Sys.time()
[11:01:21.362]             {
[11:01:21.362]                 {
[11:01:21.362]                   {
[11:01:21.362]                     {
[11:01:21.362]                       base::local({
[11:01:21.362]                         has_future <- base::requireNamespace("future", 
[11:01:21.362]                           quietly = TRUE)
[11:01:21.362]                         if (has_future) {
[11:01:21.362]                           ns <- base::getNamespace("future")
[11:01:21.362]                           version <- ns[[".package"]][["version"]]
[11:01:21.362]                           if (is.null(version)) 
[11:01:21.362]                             version <- utils::packageVersion("future")
[11:01:21.362]                         }
[11:01:21.362]                         else {
[11:01:21.362]                           version <- NULL
[11:01:21.362]                         }
[11:01:21.362]                         if (!has_future || version < "1.8.0") {
[11:01:21.362]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:21.362]                             "", base::R.version$version.string), 
[11:01:21.362]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:21.362]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:21.362]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:21.362]                               "release", "version")], collapse = " "), 
[11:01:21.362]                             hostname = base::Sys.info()[["nodename"]])
[11:01:21.362]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:21.362]                             info)
[11:01:21.362]                           info <- base::paste(info, collapse = "; ")
[11:01:21.362]                           if (!has_future) {
[11:01:21.362]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:21.362]                               info)
[11:01:21.362]                           }
[11:01:21.362]                           else {
[11:01:21.362]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:21.362]                               info, version)
[11:01:21.362]                           }
[11:01:21.362]                           base::stop(msg)
[11:01:21.362]                         }
[11:01:21.362]                       })
[11:01:21.362]                     }
[11:01:21.362]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:21.362]                     base::options(mc.cores = 1L)
[11:01:21.362]                   }
[11:01:21.362]                   ...future.strategy.old <- future::plan("list")
[11:01:21.362]                   options(future.plan = NULL)
[11:01:21.362]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.362]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:21.362]                 }
[11:01:21.362]                 ...future.workdir <- getwd()
[11:01:21.362]             }
[11:01:21.362]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:21.362]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:21.362]         }
[11:01:21.362]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:21.362]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:21.362]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:21.362]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:21.362]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:21.362]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:21.362]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:21.362]             base::names(...future.oldOptions))
[11:01:21.362]     }
[11:01:21.362]     if (FALSE) {
[11:01:21.362]     }
[11:01:21.362]     else {
[11:01:21.362]         if (TRUE) {
[11:01:21.362]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:21.362]                 open = "w")
[11:01:21.362]         }
[11:01:21.362]         else {
[11:01:21.362]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:21.362]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:21.362]         }
[11:01:21.362]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:21.362]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:21.362]             base::sink(type = "output", split = FALSE)
[11:01:21.362]             base::close(...future.stdout)
[11:01:21.362]         }, add = TRUE)
[11:01:21.362]     }
[11:01:21.362]     ...future.frame <- base::sys.nframe()
[11:01:21.362]     ...future.conditions <- base::list()
[11:01:21.362]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:21.362]     if (FALSE) {
[11:01:21.362]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:21.362]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:21.362]     }
[11:01:21.362]     ...future.result <- base::tryCatch({
[11:01:21.362]         base::withCallingHandlers({
[11:01:21.362]             ...future.value <- base::withVisible(base::local({
[11:01:21.362]                 ...future.makeSendCondition <- base::local({
[11:01:21.362]                   sendCondition <- NULL
[11:01:21.362]                   function(frame = 1L) {
[11:01:21.362]                     if (is.function(sendCondition)) 
[11:01:21.362]                       return(sendCondition)
[11:01:21.362]                     ns <- getNamespace("parallel")
[11:01:21.362]                     if (exists("sendData", mode = "function", 
[11:01:21.362]                       envir = ns)) {
[11:01:21.362]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:21.362]                         envir = ns)
[11:01:21.362]                       envir <- sys.frame(frame)
[11:01:21.362]                       master <- NULL
[11:01:21.362]                       while (!identical(envir, .GlobalEnv) && 
[11:01:21.362]                         !identical(envir, emptyenv())) {
[11:01:21.362]                         if (exists("master", mode = "list", envir = envir, 
[11:01:21.362]                           inherits = FALSE)) {
[11:01:21.362]                           master <- get("master", mode = "list", 
[11:01:21.362]                             envir = envir, inherits = FALSE)
[11:01:21.362]                           if (inherits(master, c("SOCKnode", 
[11:01:21.362]                             "SOCK0node"))) {
[11:01:21.362]                             sendCondition <<- function(cond) {
[11:01:21.362]                               data <- list(type = "VALUE", value = cond, 
[11:01:21.362]                                 success = TRUE)
[11:01:21.362]                               parallel_sendData(master, data)
[11:01:21.362]                             }
[11:01:21.362]                             return(sendCondition)
[11:01:21.362]                           }
[11:01:21.362]                         }
[11:01:21.362]                         frame <- frame + 1L
[11:01:21.362]                         envir <- sys.frame(frame)
[11:01:21.362]                       }
[11:01:21.362]                     }
[11:01:21.362]                     sendCondition <<- function(cond) NULL
[11:01:21.362]                   }
[11:01:21.362]                 })
[11:01:21.362]                 withCallingHandlers({
[11:01:21.362]                   {
[11:01:21.362]                     if (ii%%2 == 0) 
[11:01:21.362]                       stop("Woops!")
[11:01:21.362]                     ii
[11:01:21.362]                   }
[11:01:21.362]                 }, immediateCondition = function(cond) {
[11:01:21.362]                   sendCondition <- ...future.makeSendCondition()
[11:01:21.362]                   sendCondition(cond)
[11:01:21.362]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.362]                   {
[11:01:21.362]                     inherits <- base::inherits
[11:01:21.362]                     invokeRestart <- base::invokeRestart
[11:01:21.362]                     is.null <- base::is.null
[11:01:21.362]                     muffled <- FALSE
[11:01:21.362]                     if (inherits(cond, "message")) {
[11:01:21.362]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:21.362]                       if (muffled) 
[11:01:21.362]                         invokeRestart("muffleMessage")
[11:01:21.362]                     }
[11:01:21.362]                     else if (inherits(cond, "warning")) {
[11:01:21.362]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:21.362]                       if (muffled) 
[11:01:21.362]                         invokeRestart("muffleWarning")
[11:01:21.362]                     }
[11:01:21.362]                     else if (inherits(cond, "condition")) {
[11:01:21.362]                       if (!is.null(pattern)) {
[11:01:21.362]                         computeRestarts <- base::computeRestarts
[11:01:21.362]                         grepl <- base::grepl
[11:01:21.362]                         restarts <- computeRestarts(cond)
[11:01:21.362]                         for (restart in restarts) {
[11:01:21.362]                           name <- restart$name
[11:01:21.362]                           if (is.null(name)) 
[11:01:21.362]                             next
[11:01:21.362]                           if (!grepl(pattern, name)) 
[11:01:21.362]                             next
[11:01:21.362]                           invokeRestart(restart)
[11:01:21.362]                           muffled <- TRUE
[11:01:21.362]                           break
[11:01:21.362]                         }
[11:01:21.362]                       }
[11:01:21.362]                     }
[11:01:21.362]                     invisible(muffled)
[11:01:21.362]                   }
[11:01:21.362]                   muffleCondition(cond)
[11:01:21.362]                 })
[11:01:21.362]             }))
[11:01:21.362]             future::FutureResult(value = ...future.value$value, 
[11:01:21.362]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.362]                   ...future.rng), globalenv = if (FALSE) 
[11:01:21.362]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:21.362]                     ...future.globalenv.names))
[11:01:21.362]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:21.362]         }, condition = base::local({
[11:01:21.362]             c <- base::c
[11:01:21.362]             inherits <- base::inherits
[11:01:21.362]             invokeRestart <- base::invokeRestart
[11:01:21.362]             length <- base::length
[11:01:21.362]             list <- base::list
[11:01:21.362]             seq.int <- base::seq.int
[11:01:21.362]             signalCondition <- base::signalCondition
[11:01:21.362]             sys.calls <- base::sys.calls
[11:01:21.362]             `[[` <- base::`[[`
[11:01:21.362]             `+` <- base::`+`
[11:01:21.362]             `<<-` <- base::`<<-`
[11:01:21.362]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:21.362]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:21.362]                   3L)]
[11:01:21.362]             }
[11:01:21.362]             function(cond) {
[11:01:21.362]                 is_error <- inherits(cond, "error")
[11:01:21.362]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:21.362]                   NULL)
[11:01:21.362]                 if (is_error) {
[11:01:21.362]                   sessionInformation <- function() {
[11:01:21.362]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:21.362]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:21.362]                       search = base::search(), system = base::Sys.info())
[11:01:21.362]                   }
[11:01:21.362]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.362]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:21.362]                     cond$call), session = sessionInformation(), 
[11:01:21.362]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:21.362]                   signalCondition(cond)
[11:01:21.362]                 }
[11:01:21.362]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:21.362]                 "immediateCondition"))) {
[11:01:21.362]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:21.362]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.362]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:21.362]                   if (TRUE && !signal) {
[11:01:21.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.362]                     {
[11:01:21.362]                       inherits <- base::inherits
[11:01:21.362]                       invokeRestart <- base::invokeRestart
[11:01:21.362]                       is.null <- base::is.null
[11:01:21.362]                       muffled <- FALSE
[11:01:21.362]                       if (inherits(cond, "message")) {
[11:01:21.362]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.362]                         if (muffled) 
[11:01:21.362]                           invokeRestart("muffleMessage")
[11:01:21.362]                       }
[11:01:21.362]                       else if (inherits(cond, "warning")) {
[11:01:21.362]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.362]                         if (muffled) 
[11:01:21.362]                           invokeRestart("muffleWarning")
[11:01:21.362]                       }
[11:01:21.362]                       else if (inherits(cond, "condition")) {
[11:01:21.362]                         if (!is.null(pattern)) {
[11:01:21.362]                           computeRestarts <- base::computeRestarts
[11:01:21.362]                           grepl <- base::grepl
[11:01:21.362]                           restarts <- computeRestarts(cond)
[11:01:21.362]                           for (restart in restarts) {
[11:01:21.362]                             name <- restart$name
[11:01:21.362]                             if (is.null(name)) 
[11:01:21.362]                               next
[11:01:21.362]                             if (!grepl(pattern, name)) 
[11:01:21.362]                               next
[11:01:21.362]                             invokeRestart(restart)
[11:01:21.362]                             muffled <- TRUE
[11:01:21.362]                             break
[11:01:21.362]                           }
[11:01:21.362]                         }
[11:01:21.362]                       }
[11:01:21.362]                       invisible(muffled)
[11:01:21.362]                     }
[11:01:21.362]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.362]                   }
[11:01:21.362]                 }
[11:01:21.362]                 else {
[11:01:21.362]                   if (TRUE) {
[11:01:21.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.362]                     {
[11:01:21.362]                       inherits <- base::inherits
[11:01:21.362]                       invokeRestart <- base::invokeRestart
[11:01:21.362]                       is.null <- base::is.null
[11:01:21.362]                       muffled <- FALSE
[11:01:21.362]                       if (inherits(cond, "message")) {
[11:01:21.362]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.362]                         if (muffled) 
[11:01:21.362]                           invokeRestart("muffleMessage")
[11:01:21.362]                       }
[11:01:21.362]                       else if (inherits(cond, "warning")) {
[11:01:21.362]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.362]                         if (muffled) 
[11:01:21.362]                           invokeRestart("muffleWarning")
[11:01:21.362]                       }
[11:01:21.362]                       else if (inherits(cond, "condition")) {
[11:01:21.362]                         if (!is.null(pattern)) {
[11:01:21.362]                           computeRestarts <- base::computeRestarts
[11:01:21.362]                           grepl <- base::grepl
[11:01:21.362]                           restarts <- computeRestarts(cond)
[11:01:21.362]                           for (restart in restarts) {
[11:01:21.362]                             name <- restart$name
[11:01:21.362]                             if (is.null(name)) 
[11:01:21.362]                               next
[11:01:21.362]                             if (!grepl(pattern, name)) 
[11:01:21.362]                               next
[11:01:21.362]                             invokeRestart(restart)
[11:01:21.362]                             muffled <- TRUE
[11:01:21.362]                             break
[11:01:21.362]                           }
[11:01:21.362]                         }
[11:01:21.362]                       }
[11:01:21.362]                       invisible(muffled)
[11:01:21.362]                     }
[11:01:21.362]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.362]                   }
[11:01:21.362]                 }
[11:01:21.362]             }
[11:01:21.362]         }))
[11:01:21.362]     }, error = function(ex) {
[11:01:21.362]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:21.362]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.362]                 ...future.rng), started = ...future.startTime, 
[11:01:21.362]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:21.362]             version = "1.8"), class = "FutureResult")
[11:01:21.362]     }, finally = {
[11:01:21.362]         if (!identical(...future.workdir, getwd())) 
[11:01:21.362]             setwd(...future.workdir)
[11:01:21.362]         {
[11:01:21.362]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:21.362]                 ...future.oldOptions$nwarnings <- NULL
[11:01:21.362]             }
[11:01:21.362]             base::options(...future.oldOptions)
[11:01:21.362]             if (.Platform$OS.type == "windows") {
[11:01:21.362]                 old_names <- names(...future.oldEnvVars)
[11:01:21.362]                 envs <- base::Sys.getenv()
[11:01:21.362]                 names <- names(envs)
[11:01:21.362]                 common <- intersect(names, old_names)
[11:01:21.362]                 added <- setdiff(names, old_names)
[11:01:21.362]                 removed <- setdiff(old_names, names)
[11:01:21.362]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:21.362]                   envs[common]]
[11:01:21.362]                 NAMES <- toupper(changed)
[11:01:21.362]                 args <- list()
[11:01:21.362]                 for (kk in seq_along(NAMES)) {
[11:01:21.362]                   name <- changed[[kk]]
[11:01:21.362]                   NAME <- NAMES[[kk]]
[11:01:21.362]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.362]                     next
[11:01:21.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.362]                 }
[11:01:21.362]                 NAMES <- toupper(added)
[11:01:21.362]                 for (kk in seq_along(NAMES)) {
[11:01:21.362]                   name <- added[[kk]]
[11:01:21.362]                   NAME <- NAMES[[kk]]
[11:01:21.362]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.362]                     next
[11:01:21.362]                   args[[name]] <- ""
[11:01:21.362]                 }
[11:01:21.362]                 NAMES <- toupper(removed)
[11:01:21.362]                 for (kk in seq_along(NAMES)) {
[11:01:21.362]                   name <- removed[[kk]]
[11:01:21.362]                   NAME <- NAMES[[kk]]
[11:01:21.362]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.362]                     next
[11:01:21.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.362]                 }
[11:01:21.362]                 if (length(args) > 0) 
[11:01:21.362]                   base::do.call(base::Sys.setenv, args = args)
[11:01:21.362]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:21.362]             }
[11:01:21.362]             else {
[11:01:21.362]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:21.362]             }
[11:01:21.362]             {
[11:01:21.362]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:21.362]                   0L) {
[11:01:21.362]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:21.362]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:21.362]                   base::options(opts)
[11:01:21.362]                 }
[11:01:21.362]                 {
[11:01:21.362]                   {
[11:01:21.362]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:21.362]                     NULL
[11:01:21.362]                   }
[11:01:21.362]                   options(future.plan = NULL)
[11:01:21.362]                   if (is.na(NA_character_)) 
[11:01:21.362]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.362]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:21.362]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:21.362]                     .init = FALSE)
[11:01:21.362]                 }
[11:01:21.362]             }
[11:01:21.362]         }
[11:01:21.362]     })
[11:01:21.362]     if (TRUE) {
[11:01:21.362]         base::sink(type = "output", split = FALSE)
[11:01:21.362]         if (TRUE) {
[11:01:21.362]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:21.362]         }
[11:01:21.362]         else {
[11:01:21.362]             ...future.result["stdout"] <- base::list(NULL)
[11:01:21.362]         }
[11:01:21.362]         base::close(...future.stdout)
[11:01:21.362]         ...future.stdout <- NULL
[11:01:21.362]     }
[11:01:21.362]     ...future.result$conditions <- ...future.conditions
[11:01:21.362]     ...future.result$finished <- base::Sys.time()
[11:01:21.362]     ...future.result
[11:01:21.362] }
[11:01:21.425] Exporting 1 global objects (344 bytes) to cluster node #2 ...
[11:01:21.425] Exporting ‘ii’ (35 bytes) to cluster node #2 ...
[11:01:21.425] Exporting ‘ii’ (35 bytes) to cluster node #2 ... DONE
[11:01:21.426] Exporting 1 global objects (344 bytes) to cluster node #2 ... DONE
[11:01:21.426] MultisessionFuture started
[11:01:21.426] - Launch lazy future ... done
[11:01:21.426] run() for ‘MultisessionFuture’ ... done
[11:01:21.427] getGlobalsAndPackages() ...
[11:01:21.427] Searching for globals...
[11:01:21.429] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[11:01:21.429] Searching for globals ... DONE
[11:01:21.429] Resolving globals: FALSE
[11:01:21.430] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:21.430] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:21.431] - globals: [1] ‘ii’
[11:01:21.431] 
[11:01:21.431] getGlobalsAndPackages() ... DONE
[11:01:21.431] run() for ‘Future’ ...
[11:01:21.431] - state: ‘created’
[11:01:21.431] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:21.446] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:21.446] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:21.446]   - Field: ‘node’
[11:01:21.446]   - Field: ‘label’
[11:01:21.446]   - Field: ‘local’
[11:01:21.447]   - Field: ‘owner’
[11:01:21.447]   - Field: ‘envir’
[11:01:21.447]   - Field: ‘workers’
[11:01:21.447]   - Field: ‘packages’
[11:01:21.447]   - Field: ‘gc’
[11:01:21.447]   - Field: ‘conditions’
[11:01:21.447]   - Field: ‘persistent’
[11:01:21.447]   - Field: ‘expr’
[11:01:21.447]   - Field: ‘uuid’
[11:01:21.450]   - Field: ‘seed’
[11:01:21.450]   - Field: ‘version’
[11:01:21.450]   - Field: ‘result’
[11:01:21.450]   - Field: ‘asynchronous’
[11:01:21.450]   - Field: ‘calls’
[11:01:21.450]   - Field: ‘globals’
[11:01:21.450]   - Field: ‘stdout’
[11:01:21.450]   - Field: ‘earlySignal’
[11:01:21.450]   - Field: ‘lazy’
[11:01:21.451]   - Field: ‘state’
[11:01:21.451] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:21.451] - Launch lazy future ...
[11:01:21.451] Packages needed by the future expression (n = 0): <none>
[11:01:21.451] Packages needed by future strategies (n = 0): <none>
[11:01:21.451] {
[11:01:21.451]     {
[11:01:21.451]         {
[11:01:21.451]             ...future.startTime <- base::Sys.time()
[11:01:21.451]             {
[11:01:21.451]                 {
[11:01:21.451]                   {
[11:01:21.451]                     {
[11:01:21.451]                       base::local({
[11:01:21.451]                         has_future <- base::requireNamespace("future", 
[11:01:21.451]                           quietly = TRUE)
[11:01:21.451]                         if (has_future) {
[11:01:21.451]                           ns <- base::getNamespace("future")
[11:01:21.451]                           version <- ns[[".package"]][["version"]]
[11:01:21.451]                           if (is.null(version)) 
[11:01:21.451]                             version <- utils::packageVersion("future")
[11:01:21.451]                         }
[11:01:21.451]                         else {
[11:01:21.451]                           version <- NULL
[11:01:21.451]                         }
[11:01:21.451]                         if (!has_future || version < "1.8.0") {
[11:01:21.451]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:21.451]                             "", base::R.version$version.string), 
[11:01:21.451]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:21.451]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:21.451]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:21.451]                               "release", "version")], collapse = " "), 
[11:01:21.451]                             hostname = base::Sys.info()[["nodename"]])
[11:01:21.451]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:21.451]                             info)
[11:01:21.451]                           info <- base::paste(info, collapse = "; ")
[11:01:21.451]                           if (!has_future) {
[11:01:21.451]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:21.451]                               info)
[11:01:21.451]                           }
[11:01:21.451]                           else {
[11:01:21.451]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:21.451]                               info, version)
[11:01:21.451]                           }
[11:01:21.451]                           base::stop(msg)
[11:01:21.451]                         }
[11:01:21.451]                       })
[11:01:21.451]                     }
[11:01:21.451]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:21.451]                     base::options(mc.cores = 1L)
[11:01:21.451]                   }
[11:01:21.451]                   ...future.strategy.old <- future::plan("list")
[11:01:21.451]                   options(future.plan = NULL)
[11:01:21.451]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.451]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:21.451]                 }
[11:01:21.451]                 ...future.workdir <- getwd()
[11:01:21.451]             }
[11:01:21.451]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:21.451]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:21.451]         }
[11:01:21.451]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:21.451]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:21.451]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:21.451]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:21.451]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:21.451]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:21.451]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:21.451]             base::names(...future.oldOptions))
[11:01:21.451]     }
[11:01:21.451]     if (FALSE) {
[11:01:21.451]     }
[11:01:21.451]     else {
[11:01:21.451]         if (TRUE) {
[11:01:21.451]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:21.451]                 open = "w")
[11:01:21.451]         }
[11:01:21.451]         else {
[11:01:21.451]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:21.451]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:21.451]         }
[11:01:21.451]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:21.451]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:21.451]             base::sink(type = "output", split = FALSE)
[11:01:21.451]             base::close(...future.stdout)
[11:01:21.451]         }, add = TRUE)
[11:01:21.451]     }
[11:01:21.451]     ...future.frame <- base::sys.nframe()
[11:01:21.451]     ...future.conditions <- base::list()
[11:01:21.451]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:21.451]     if (FALSE) {
[11:01:21.451]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:21.451]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:21.451]     }
[11:01:21.451]     ...future.result <- base::tryCatch({
[11:01:21.451]         base::withCallingHandlers({
[11:01:21.451]             ...future.value <- base::withVisible(base::local({
[11:01:21.451]                 ...future.makeSendCondition <- base::local({
[11:01:21.451]                   sendCondition <- NULL
[11:01:21.451]                   function(frame = 1L) {
[11:01:21.451]                     if (is.function(sendCondition)) 
[11:01:21.451]                       return(sendCondition)
[11:01:21.451]                     ns <- getNamespace("parallel")
[11:01:21.451]                     if (exists("sendData", mode = "function", 
[11:01:21.451]                       envir = ns)) {
[11:01:21.451]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:21.451]                         envir = ns)
[11:01:21.451]                       envir <- sys.frame(frame)
[11:01:21.451]                       master <- NULL
[11:01:21.451]                       while (!identical(envir, .GlobalEnv) && 
[11:01:21.451]                         !identical(envir, emptyenv())) {
[11:01:21.451]                         if (exists("master", mode = "list", envir = envir, 
[11:01:21.451]                           inherits = FALSE)) {
[11:01:21.451]                           master <- get("master", mode = "list", 
[11:01:21.451]                             envir = envir, inherits = FALSE)
[11:01:21.451]                           if (inherits(master, c("SOCKnode", 
[11:01:21.451]                             "SOCK0node"))) {
[11:01:21.451]                             sendCondition <<- function(cond) {
[11:01:21.451]                               data <- list(type = "VALUE", value = cond, 
[11:01:21.451]                                 success = TRUE)
[11:01:21.451]                               parallel_sendData(master, data)
[11:01:21.451]                             }
[11:01:21.451]                             return(sendCondition)
[11:01:21.451]                           }
[11:01:21.451]                         }
[11:01:21.451]                         frame <- frame + 1L
[11:01:21.451]                         envir <- sys.frame(frame)
[11:01:21.451]                       }
[11:01:21.451]                     }
[11:01:21.451]                     sendCondition <<- function(cond) NULL
[11:01:21.451]                   }
[11:01:21.451]                 })
[11:01:21.451]                 withCallingHandlers({
[11:01:21.451]                   {
[11:01:21.451]                     if (ii%%2 == 0) 
[11:01:21.451]                       stop("Woops!")
[11:01:21.451]                     ii
[11:01:21.451]                   }
[11:01:21.451]                 }, immediateCondition = function(cond) {
[11:01:21.451]                   sendCondition <- ...future.makeSendCondition()
[11:01:21.451]                   sendCondition(cond)
[11:01:21.451]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.451]                   {
[11:01:21.451]                     inherits <- base::inherits
[11:01:21.451]                     invokeRestart <- base::invokeRestart
[11:01:21.451]                     is.null <- base::is.null
[11:01:21.451]                     muffled <- FALSE
[11:01:21.451]                     if (inherits(cond, "message")) {
[11:01:21.451]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:21.451]                       if (muffled) 
[11:01:21.451]                         invokeRestart("muffleMessage")
[11:01:21.451]                     }
[11:01:21.451]                     else if (inherits(cond, "warning")) {
[11:01:21.451]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:21.451]                       if (muffled) 
[11:01:21.451]                         invokeRestart("muffleWarning")
[11:01:21.451]                     }
[11:01:21.451]                     else if (inherits(cond, "condition")) {
[11:01:21.451]                       if (!is.null(pattern)) {
[11:01:21.451]                         computeRestarts <- base::computeRestarts
[11:01:21.451]                         grepl <- base::grepl
[11:01:21.451]                         restarts <- computeRestarts(cond)
[11:01:21.451]                         for (restart in restarts) {
[11:01:21.451]                           name <- restart$name
[11:01:21.451]                           if (is.null(name)) 
[11:01:21.451]                             next
[11:01:21.451]                           if (!grepl(pattern, name)) 
[11:01:21.451]                             next
[11:01:21.451]                           invokeRestart(restart)
[11:01:21.451]                           muffled <- TRUE
[11:01:21.451]                           break
[11:01:21.451]                         }
[11:01:21.451]                       }
[11:01:21.451]                     }
[11:01:21.451]                     invisible(muffled)
[11:01:21.451]                   }
[11:01:21.451]                   muffleCondition(cond)
[11:01:21.451]                 })
[11:01:21.451]             }))
[11:01:21.451]             future::FutureResult(value = ...future.value$value, 
[11:01:21.451]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.451]                   ...future.rng), globalenv = if (FALSE) 
[11:01:21.451]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:21.451]                     ...future.globalenv.names))
[11:01:21.451]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:21.451]         }, condition = base::local({
[11:01:21.451]             c <- base::c
[11:01:21.451]             inherits <- base::inherits
[11:01:21.451]             invokeRestart <- base::invokeRestart
[11:01:21.451]             length <- base::length
[11:01:21.451]             list <- base::list
[11:01:21.451]             seq.int <- base::seq.int
[11:01:21.451]             signalCondition <- base::signalCondition
[11:01:21.451]             sys.calls <- base::sys.calls
[11:01:21.451]             `[[` <- base::`[[`
[11:01:21.451]             `+` <- base::`+`
[11:01:21.451]             `<<-` <- base::`<<-`
[11:01:21.451]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:21.451]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:21.451]                   3L)]
[11:01:21.451]             }
[11:01:21.451]             function(cond) {
[11:01:21.451]                 is_error <- inherits(cond, "error")
[11:01:21.451]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:21.451]                   NULL)
[11:01:21.451]                 if (is_error) {
[11:01:21.451]                   sessionInformation <- function() {
[11:01:21.451]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:21.451]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:21.451]                       search = base::search(), system = base::Sys.info())
[11:01:21.451]                   }
[11:01:21.451]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.451]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:21.451]                     cond$call), session = sessionInformation(), 
[11:01:21.451]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:21.451]                   signalCondition(cond)
[11:01:21.451]                 }
[11:01:21.451]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:21.451]                 "immediateCondition"))) {
[11:01:21.451]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:21.451]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.451]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:21.451]                   if (TRUE && !signal) {
[11:01:21.451]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.451]                     {
[11:01:21.451]                       inherits <- base::inherits
[11:01:21.451]                       invokeRestart <- base::invokeRestart
[11:01:21.451]                       is.null <- base::is.null
[11:01:21.451]                       muffled <- FALSE
[11:01:21.451]                       if (inherits(cond, "message")) {
[11:01:21.451]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.451]                         if (muffled) 
[11:01:21.451]                           invokeRestart("muffleMessage")
[11:01:21.451]                       }
[11:01:21.451]                       else if (inherits(cond, "warning")) {
[11:01:21.451]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.451]                         if (muffled) 
[11:01:21.451]                           invokeRestart("muffleWarning")
[11:01:21.451]                       }
[11:01:21.451]                       else if (inherits(cond, "condition")) {
[11:01:21.451]                         if (!is.null(pattern)) {
[11:01:21.451]                           computeRestarts <- base::computeRestarts
[11:01:21.451]                           grepl <- base::grepl
[11:01:21.451]                           restarts <- computeRestarts(cond)
[11:01:21.451]                           for (restart in restarts) {
[11:01:21.451]                             name <- restart$name
[11:01:21.451]                             if (is.null(name)) 
[11:01:21.451]                               next
[11:01:21.451]                             if (!grepl(pattern, name)) 
[11:01:21.451]                               next
[11:01:21.451]                             invokeRestart(restart)
[11:01:21.451]                             muffled <- TRUE
[11:01:21.451]                             break
[11:01:21.451]                           }
[11:01:21.451]                         }
[11:01:21.451]                       }
[11:01:21.451]                       invisible(muffled)
[11:01:21.451]                     }
[11:01:21.451]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.451]                   }
[11:01:21.451]                 }
[11:01:21.451]                 else {
[11:01:21.451]                   if (TRUE) {
[11:01:21.451]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.451]                     {
[11:01:21.451]                       inherits <- base::inherits
[11:01:21.451]                       invokeRestart <- base::invokeRestart
[11:01:21.451]                       is.null <- base::is.null
[11:01:21.451]                       muffled <- FALSE
[11:01:21.451]                       if (inherits(cond, "message")) {
[11:01:21.451]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.451]                         if (muffled) 
[11:01:21.451]                           invokeRestart("muffleMessage")
[11:01:21.451]                       }
[11:01:21.451]                       else if (inherits(cond, "warning")) {
[11:01:21.451]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.451]                         if (muffled) 
[11:01:21.451]                           invokeRestart("muffleWarning")
[11:01:21.451]                       }
[11:01:21.451]                       else if (inherits(cond, "condition")) {
[11:01:21.451]                         if (!is.null(pattern)) {
[11:01:21.451]                           computeRestarts <- base::computeRestarts
[11:01:21.451]                           grepl <- base::grepl
[11:01:21.451]                           restarts <- computeRestarts(cond)
[11:01:21.451]                           for (restart in restarts) {
[11:01:21.451]                             name <- restart$name
[11:01:21.451]                             if (is.null(name)) 
[11:01:21.451]                               next
[11:01:21.451]                             if (!grepl(pattern, name)) 
[11:01:21.451]                               next
[11:01:21.451]                             invokeRestart(restart)
[11:01:21.451]                             muffled <- TRUE
[11:01:21.451]                             break
[11:01:21.451]                           }
[11:01:21.451]                         }
[11:01:21.451]                       }
[11:01:21.451]                       invisible(muffled)
[11:01:21.451]                     }
[11:01:21.451]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.451]                   }
[11:01:21.451]                 }
[11:01:21.451]             }
[11:01:21.451]         }))
[11:01:21.451]     }, error = function(ex) {
[11:01:21.451]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:21.451]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.451]                 ...future.rng), started = ...future.startTime, 
[11:01:21.451]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:21.451]             version = "1.8"), class = "FutureResult")
[11:01:21.451]     }, finally = {
[11:01:21.451]         if (!identical(...future.workdir, getwd())) 
[11:01:21.451]             setwd(...future.workdir)
[11:01:21.451]         {
[11:01:21.451]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:21.451]                 ...future.oldOptions$nwarnings <- NULL
[11:01:21.451]             }
[11:01:21.451]             base::options(...future.oldOptions)
[11:01:21.451]             if (.Platform$OS.type == "windows") {
[11:01:21.451]                 old_names <- names(...future.oldEnvVars)
[11:01:21.451]                 envs <- base::Sys.getenv()
[11:01:21.451]                 names <- names(envs)
[11:01:21.451]                 common <- intersect(names, old_names)
[11:01:21.451]                 added <- setdiff(names, old_names)
[11:01:21.451]                 removed <- setdiff(old_names, names)
[11:01:21.451]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:21.451]                   envs[common]]
[11:01:21.451]                 NAMES <- toupper(changed)
[11:01:21.451]                 args <- list()
[11:01:21.451]                 for (kk in seq_along(NAMES)) {
[11:01:21.451]                   name <- changed[[kk]]
[11:01:21.451]                   NAME <- NAMES[[kk]]
[11:01:21.451]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.451]                     next
[11:01:21.451]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.451]                 }
[11:01:21.451]                 NAMES <- toupper(added)
[11:01:21.451]                 for (kk in seq_along(NAMES)) {
[11:01:21.451]                   name <- added[[kk]]
[11:01:21.451]                   NAME <- NAMES[[kk]]
[11:01:21.451]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.451]                     next
[11:01:21.451]                   args[[name]] <- ""
[11:01:21.451]                 }
[11:01:21.451]                 NAMES <- toupper(removed)
[11:01:21.451]                 for (kk in seq_along(NAMES)) {
[11:01:21.451]                   name <- removed[[kk]]
[11:01:21.451]                   NAME <- NAMES[[kk]]
[11:01:21.451]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.451]                     next
[11:01:21.451]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.451]                 }
[11:01:21.451]                 if (length(args) > 0) 
[11:01:21.451]                   base::do.call(base::Sys.setenv, args = args)
[11:01:21.451]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:21.451]             }
[11:01:21.451]             else {
[11:01:21.451]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:21.451]             }
[11:01:21.451]             {
[11:01:21.451]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:21.451]                   0L) {
[11:01:21.451]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:21.451]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:21.451]                   base::options(opts)
[11:01:21.451]                 }
[11:01:21.451]                 {
[11:01:21.451]                   {
[11:01:21.451]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:21.451]                     NULL
[11:01:21.451]                   }
[11:01:21.451]                   options(future.plan = NULL)
[11:01:21.451]                   if (is.na(NA_character_)) 
[11:01:21.451]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.451]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:21.451]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:21.451]                     .init = FALSE)
[11:01:21.451]                 }
[11:01:21.451]             }
[11:01:21.451]         }
[11:01:21.451]     })
[11:01:21.451]     if (TRUE) {
[11:01:21.451]         base::sink(type = "output", split = FALSE)
[11:01:21.451]         if (TRUE) {
[11:01:21.451]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:21.451]         }
[11:01:21.451]         else {
[11:01:21.451]             ...future.result["stdout"] <- base::list(NULL)
[11:01:21.451]         }
[11:01:21.451]         base::close(...future.stdout)
[11:01:21.451]         ...future.stdout <- NULL
[11:01:21.451]     }
[11:01:21.451]     ...future.result$conditions <- ...future.conditions
[11:01:21.451]     ...future.result$finished <- base::Sys.time()
[11:01:21.451]     ...future.result
[11:01:21.451] }
[11:01:21.454] Poll #1 (0): usedNodes() = 2, workers = 2
[11:01:21.473] receiveMessageFromWorker() for ClusterFuture ...
[11:01:21.473] - Validating connection of MultisessionFuture
[11:01:21.473] - received message: FutureResult
[11:01:21.473] - Received FutureResult
[11:01:21.473] - Erased future from FutureRegistry
[11:01:21.473] result() for ClusterFuture ...
[11:01:21.473] - result already collected: FutureResult
[11:01:21.473] result() for ClusterFuture ... done
[11:01:21.473] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:21.474] result() for ClusterFuture ...
[11:01:21.474] - result already collected: FutureResult
[11:01:21.474] result() for ClusterFuture ... done
[11:01:21.474] result() for ClusterFuture ...
[11:01:21.474] - result already collected: FutureResult
[11:01:21.474] result() for ClusterFuture ... done
[11:01:21.475] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[11:01:21.475] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[11:01:21.475] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[11:01:21.475] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[11:01:21.476] MultisessionFuture started
[11:01:21.476] - Launch lazy future ... done
[11:01:21.476] run() for ‘MultisessionFuture’ ... done
[11:01:21.476] result() for ClusterFuture ...
[11:01:21.476] - result already collected: FutureResult
[11:01:21.476] result() for ClusterFuture ... done
[11:01:21.476] result() for ClusterFuture ...
[11:01:21.477] - result already collected: FutureResult
[11:01:21.477] result() for ClusterFuture ... done
[11:01:21.477] result() for ClusterFuture ...
[11:01:21.477] receiveMessageFromWorker() for ClusterFuture ...
[11:01:21.477] - Validating connection of MultisessionFuture
[11:01:21.498] - received message: FutureResult
[11:01:21.498] - Received FutureResult
[11:01:21.499] - Erased future from FutureRegistry
[11:01:21.499] result() for ClusterFuture ...
[11:01:21.499] - result already collected: FutureResult
[11:01:21.499] result() for ClusterFuture ... done
[11:01:21.499] signalConditions() ...
[11:01:21.499]  - include = ‘immediateCondition’
[11:01:21.499]  - exclude = 
[11:01:21.499]  - resignal = FALSE
[11:01:21.499]  - Number of conditions: 1
[11:01:21.499] signalConditions() ... done
[11:01:21.499] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:21.499] result() for ClusterFuture ... done
[11:01:21.500] result() for ClusterFuture ...
[11:01:21.500] - result already collected: FutureResult
[11:01:21.500] result() for ClusterFuture ... done
[11:01:21.500] signalConditions() ...
[11:01:21.500]  - include = ‘immediateCondition’
[11:01:21.500]  - exclude = 
[11:01:21.500]  - resignal = FALSE
[11:01:21.500]  - Number of conditions: 1
[11:01:21.500] signalConditions() ... done
[11:01:21.500] Future state: ‘finished’
[11:01:21.500] result() for ClusterFuture ...
[11:01:21.501] - result already collected: FutureResult
[11:01:21.501] result() for ClusterFuture ... done
[11:01:21.501] signalConditions() ...
[11:01:21.501]  - include = ‘condition’
[11:01:21.501]  - exclude = ‘immediateCondition’
[11:01:21.501]  - resignal = TRUE
[11:01:21.501]  - Number of conditions: 1
[11:01:21.501]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:21.501] signalConditions() ... done
[11:01:21.502] result() for ClusterFuture ...
[11:01:21.502] receiveMessageFromWorker() for ClusterFuture ...
[11:01:21.502] - Validating connection of MultisessionFuture
[11:01:21.518] - received message: FutureResult
[11:01:21.518] - Received FutureResult
[11:01:21.518] - Erased future from FutureRegistry
[11:01:21.518] result() for ClusterFuture ...
[11:01:21.518] - result already collected: FutureResult
[11:01:21.519] result() for ClusterFuture ... done
[11:01:21.519] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:21.519] result() for ClusterFuture ... done
[11:01:21.519] result() for ClusterFuture ...
[11:01:21.519] - result already collected: FutureResult
[11:01:21.519] result() for ClusterFuture ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[11:01:21.519] result() for ClusterFuture ...
[11:01:21.519] - result already collected: FutureResult
[11:01:21.520] result() for ClusterFuture ... done
[11:01:21.520] result() for ClusterFuture ...
[11:01:21.520] - result already collected: FutureResult
[11:01:21.520] result() for ClusterFuture ... done
[11:01:21.520] signalConditions() ...
[11:01:21.520]  - include = ‘immediateCondition’
[11:01:21.520]  - exclude = 
[11:01:21.520]  - resignal = FALSE
[11:01:21.520]  - Number of conditions: 1
[11:01:21.520] signalConditions() ... done
[11:01:21.520] Future state: ‘finished’
[11:01:21.520] result() for ClusterFuture ...
[11:01:21.521] - result already collected: FutureResult
[11:01:21.521] result() for ClusterFuture ... done
[11:01:21.521] signalConditions() ...
[11:01:21.521]  - include = ‘condition’
[11:01:21.521]  - exclude = ‘immediateCondition’
[11:01:21.521]  - resignal = TRUE
[11:01:21.521]  - Number of conditions: 1
[11:01:21.521]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:21.521] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[11:01:21.522] result() for ClusterFuture ...
[11:01:21.522] - result already collected: FutureResult
[11:01:21.522] result() for ClusterFuture ... done
[11:01:21.522] result() for ClusterFuture ...
[11:01:21.522] - result already collected: FutureResult
[11:01:21.522] result() for ClusterFuture ... done
[11:01:21.522] signalConditions() ...
[11:01:21.522]  - include = ‘immediateCondition’
[11:01:21.522]  - exclude = 
[11:01:21.522]  - resignal = FALSE
[11:01:21.522]  - Number of conditions: 1
[11:01:21.522] signalConditions() ... done
[11:01:21.523] Future state: ‘finished’
[11:01:21.523] result() for ClusterFuture ...
[11:01:21.523] - result already collected: FutureResult
[11:01:21.523] result() for ClusterFuture ... done
[11:01:21.523] signalConditions() ...
[11:01:21.523]  - include = ‘condition’
[11:01:21.523]  - exclude = ‘immediateCondition’
[11:01:21.523]  - resignal = TRUE
[11:01:21.523]  - Number of conditions: 1
[11:01:21.523]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:21.523] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[11:01:21.524] getGlobalsAndPackages() ...
[11:01:21.524] Searching for globals...
[11:01:21.526] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[11:01:21.526] Searching for globals ... DONE
[11:01:21.526] Resolving globals: FALSE
[11:01:21.526] 
[11:01:21.526] 
[11:01:21.526] getGlobalsAndPackages() ... DONE
[11:01:21.527] run() for ‘Future’ ...
[11:01:21.527] - state: ‘created’
[11:01:21.527] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:21.541] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:21.541] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:21.541]   - Field: ‘node’
[11:01:21.541]   - Field: ‘label’
[11:01:21.541]   - Field: ‘local’
[11:01:21.541]   - Field: ‘owner’
[11:01:21.541]   - Field: ‘envir’
[11:01:21.541]   - Field: ‘workers’
[11:01:21.541]   - Field: ‘packages’
[11:01:21.541]   - Field: ‘gc’
[11:01:21.541]   - Field: ‘conditions’
[11:01:21.542]   - Field: ‘persistent’
[11:01:21.542]   - Field: ‘expr’
[11:01:21.542]   - Field: ‘uuid’
[11:01:21.542]   - Field: ‘seed’
[11:01:21.542]   - Field: ‘version’
[11:01:21.542]   - Field: ‘result’
[11:01:21.542]   - Field: ‘asynchronous’
[11:01:21.542]   - Field: ‘calls’
[11:01:21.542]   - Field: ‘globals’
[11:01:21.542]   - Field: ‘stdout’
[11:01:21.542]   - Field: ‘earlySignal’
[11:01:21.542]   - Field: ‘lazy’
[11:01:21.543]   - Field: ‘state’
[11:01:21.543] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:21.543] - Launch lazy future ...
[11:01:21.543] Packages needed by the future expression (n = 0): <none>
[11:01:21.543] Packages needed by future strategies (n = 0): <none>
[11:01:21.544] {
[11:01:21.544]     {
[11:01:21.544]         {
[11:01:21.544]             ...future.startTime <- base::Sys.time()
[11:01:21.544]             {
[11:01:21.544]                 {
[11:01:21.544]                   {
[11:01:21.544]                     {
[11:01:21.544]                       base::local({
[11:01:21.544]                         has_future <- base::requireNamespace("future", 
[11:01:21.544]                           quietly = TRUE)
[11:01:21.544]                         if (has_future) {
[11:01:21.544]                           ns <- base::getNamespace("future")
[11:01:21.544]                           version <- ns[[".package"]][["version"]]
[11:01:21.544]                           if (is.null(version)) 
[11:01:21.544]                             version <- utils::packageVersion("future")
[11:01:21.544]                         }
[11:01:21.544]                         else {
[11:01:21.544]                           version <- NULL
[11:01:21.544]                         }
[11:01:21.544]                         if (!has_future || version < "1.8.0") {
[11:01:21.544]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:21.544]                             "", base::R.version$version.string), 
[11:01:21.544]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:21.544]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:21.544]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:21.544]                               "release", "version")], collapse = " "), 
[11:01:21.544]                             hostname = base::Sys.info()[["nodename"]])
[11:01:21.544]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:21.544]                             info)
[11:01:21.544]                           info <- base::paste(info, collapse = "; ")
[11:01:21.544]                           if (!has_future) {
[11:01:21.544]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:21.544]                               info)
[11:01:21.544]                           }
[11:01:21.544]                           else {
[11:01:21.544]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:21.544]                               info, version)
[11:01:21.544]                           }
[11:01:21.544]                           base::stop(msg)
[11:01:21.544]                         }
[11:01:21.544]                       })
[11:01:21.544]                     }
[11:01:21.544]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:21.544]                     base::options(mc.cores = 1L)
[11:01:21.544]                   }
[11:01:21.544]                   ...future.strategy.old <- future::plan("list")
[11:01:21.544]                   options(future.plan = NULL)
[11:01:21.544]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.544]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:21.544]                 }
[11:01:21.544]                 ...future.workdir <- getwd()
[11:01:21.544]             }
[11:01:21.544]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:21.544]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:21.544]         }
[11:01:21.544]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:21.544]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:21.544]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:21.544]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:21.544]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:21.544]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:21.544]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:21.544]             base::names(...future.oldOptions))
[11:01:21.544]     }
[11:01:21.544]     if (FALSE) {
[11:01:21.544]     }
[11:01:21.544]     else {
[11:01:21.544]         if (TRUE) {
[11:01:21.544]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:21.544]                 open = "w")
[11:01:21.544]         }
[11:01:21.544]         else {
[11:01:21.544]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:21.544]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:21.544]         }
[11:01:21.544]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:21.544]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:21.544]             base::sink(type = "output", split = FALSE)
[11:01:21.544]             base::close(...future.stdout)
[11:01:21.544]         }, add = TRUE)
[11:01:21.544]     }
[11:01:21.544]     ...future.frame <- base::sys.nframe()
[11:01:21.544]     ...future.conditions <- base::list()
[11:01:21.544]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:21.544]     if (FALSE) {
[11:01:21.544]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:21.544]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:21.544]     }
[11:01:21.544]     ...future.result <- base::tryCatch({
[11:01:21.544]         base::withCallingHandlers({
[11:01:21.544]             ...future.value <- base::withVisible(base::local({
[11:01:21.544]                 ...future.makeSendCondition <- base::local({
[11:01:21.544]                   sendCondition <- NULL
[11:01:21.544]                   function(frame = 1L) {
[11:01:21.544]                     if (is.function(sendCondition)) 
[11:01:21.544]                       return(sendCondition)
[11:01:21.544]                     ns <- getNamespace("parallel")
[11:01:21.544]                     if (exists("sendData", mode = "function", 
[11:01:21.544]                       envir = ns)) {
[11:01:21.544]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:21.544]                         envir = ns)
[11:01:21.544]                       envir <- sys.frame(frame)
[11:01:21.544]                       master <- NULL
[11:01:21.544]                       while (!identical(envir, .GlobalEnv) && 
[11:01:21.544]                         !identical(envir, emptyenv())) {
[11:01:21.544]                         if (exists("master", mode = "list", envir = envir, 
[11:01:21.544]                           inherits = FALSE)) {
[11:01:21.544]                           master <- get("master", mode = "list", 
[11:01:21.544]                             envir = envir, inherits = FALSE)
[11:01:21.544]                           if (inherits(master, c("SOCKnode", 
[11:01:21.544]                             "SOCK0node"))) {
[11:01:21.544]                             sendCondition <<- function(cond) {
[11:01:21.544]                               data <- list(type = "VALUE", value = cond, 
[11:01:21.544]                                 success = TRUE)
[11:01:21.544]                               parallel_sendData(master, data)
[11:01:21.544]                             }
[11:01:21.544]                             return(sendCondition)
[11:01:21.544]                           }
[11:01:21.544]                         }
[11:01:21.544]                         frame <- frame + 1L
[11:01:21.544]                         envir <- sys.frame(frame)
[11:01:21.544]                       }
[11:01:21.544]                     }
[11:01:21.544]                     sendCondition <<- function(cond) NULL
[11:01:21.544]                   }
[11:01:21.544]                 })
[11:01:21.544]                 withCallingHandlers({
[11:01:21.544]                   {
[11:01:21.544]                     cat("Processing: ")
[11:01:21.544]                     for (ii in 1:10) {
[11:01:21.544]                       cat(".")
[11:01:21.544]                     }
[11:01:21.544]                     cat(" [100%]\n")
[11:01:21.544]                     4
[11:01:21.544]                   }
[11:01:21.544]                 }, immediateCondition = function(cond) {
[11:01:21.544]                   sendCondition <- ...future.makeSendCondition()
[11:01:21.544]                   sendCondition(cond)
[11:01:21.544]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.544]                   {
[11:01:21.544]                     inherits <- base::inherits
[11:01:21.544]                     invokeRestart <- base::invokeRestart
[11:01:21.544]                     is.null <- base::is.null
[11:01:21.544]                     muffled <- FALSE
[11:01:21.544]                     if (inherits(cond, "message")) {
[11:01:21.544]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:21.544]                       if (muffled) 
[11:01:21.544]                         invokeRestart("muffleMessage")
[11:01:21.544]                     }
[11:01:21.544]                     else if (inherits(cond, "warning")) {
[11:01:21.544]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:21.544]                       if (muffled) 
[11:01:21.544]                         invokeRestart("muffleWarning")
[11:01:21.544]                     }
[11:01:21.544]                     else if (inherits(cond, "condition")) {
[11:01:21.544]                       if (!is.null(pattern)) {
[11:01:21.544]                         computeRestarts <- base::computeRestarts
[11:01:21.544]                         grepl <- base::grepl
[11:01:21.544]                         restarts <- computeRestarts(cond)
[11:01:21.544]                         for (restart in restarts) {
[11:01:21.544]                           name <- restart$name
[11:01:21.544]                           if (is.null(name)) 
[11:01:21.544]                             next
[11:01:21.544]                           if (!grepl(pattern, name)) 
[11:01:21.544]                             next
[11:01:21.544]                           invokeRestart(restart)
[11:01:21.544]                           muffled <- TRUE
[11:01:21.544]                           break
[11:01:21.544]                         }
[11:01:21.544]                       }
[11:01:21.544]                     }
[11:01:21.544]                     invisible(muffled)
[11:01:21.544]                   }
[11:01:21.544]                   muffleCondition(cond)
[11:01:21.544]                 })
[11:01:21.544]             }))
[11:01:21.544]             future::FutureResult(value = ...future.value$value, 
[11:01:21.544]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.544]                   ...future.rng), globalenv = if (FALSE) 
[11:01:21.544]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:21.544]                     ...future.globalenv.names))
[11:01:21.544]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:21.544]         }, condition = base::local({
[11:01:21.544]             c <- base::c
[11:01:21.544]             inherits <- base::inherits
[11:01:21.544]             invokeRestart <- base::invokeRestart
[11:01:21.544]             length <- base::length
[11:01:21.544]             list <- base::list
[11:01:21.544]             seq.int <- base::seq.int
[11:01:21.544]             signalCondition <- base::signalCondition
[11:01:21.544]             sys.calls <- base::sys.calls
[11:01:21.544]             `[[` <- base::`[[`
[11:01:21.544]             `+` <- base::`+`
[11:01:21.544]             `<<-` <- base::`<<-`
[11:01:21.544]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:21.544]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:21.544]                   3L)]
[11:01:21.544]             }
[11:01:21.544]             function(cond) {
[11:01:21.544]                 is_error <- inherits(cond, "error")
[11:01:21.544]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:21.544]                   NULL)
[11:01:21.544]                 if (is_error) {
[11:01:21.544]                   sessionInformation <- function() {
[11:01:21.544]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:21.544]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:21.544]                       search = base::search(), system = base::Sys.info())
[11:01:21.544]                   }
[11:01:21.544]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.544]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:21.544]                     cond$call), session = sessionInformation(), 
[11:01:21.544]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:21.544]                   signalCondition(cond)
[11:01:21.544]                 }
[11:01:21.544]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:21.544]                 "immediateCondition"))) {
[11:01:21.544]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:21.544]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.544]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:21.544]                   if (TRUE && !signal) {
[11:01:21.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.544]                     {
[11:01:21.544]                       inherits <- base::inherits
[11:01:21.544]                       invokeRestart <- base::invokeRestart
[11:01:21.544]                       is.null <- base::is.null
[11:01:21.544]                       muffled <- FALSE
[11:01:21.544]                       if (inherits(cond, "message")) {
[11:01:21.544]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.544]                         if (muffled) 
[11:01:21.544]                           invokeRestart("muffleMessage")
[11:01:21.544]                       }
[11:01:21.544]                       else if (inherits(cond, "warning")) {
[11:01:21.544]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.544]                         if (muffled) 
[11:01:21.544]                           invokeRestart("muffleWarning")
[11:01:21.544]                       }
[11:01:21.544]                       else if (inherits(cond, "condition")) {
[11:01:21.544]                         if (!is.null(pattern)) {
[11:01:21.544]                           computeRestarts <- base::computeRestarts
[11:01:21.544]                           grepl <- base::grepl
[11:01:21.544]                           restarts <- computeRestarts(cond)
[11:01:21.544]                           for (restart in restarts) {
[11:01:21.544]                             name <- restart$name
[11:01:21.544]                             if (is.null(name)) 
[11:01:21.544]                               next
[11:01:21.544]                             if (!grepl(pattern, name)) 
[11:01:21.544]                               next
[11:01:21.544]                             invokeRestart(restart)
[11:01:21.544]                             muffled <- TRUE
[11:01:21.544]                             break
[11:01:21.544]                           }
[11:01:21.544]                         }
[11:01:21.544]                       }
[11:01:21.544]                       invisible(muffled)
[11:01:21.544]                     }
[11:01:21.544]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.544]                   }
[11:01:21.544]                 }
[11:01:21.544]                 else {
[11:01:21.544]                   if (TRUE) {
[11:01:21.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.544]                     {
[11:01:21.544]                       inherits <- base::inherits
[11:01:21.544]                       invokeRestart <- base::invokeRestart
[11:01:21.544]                       is.null <- base::is.null
[11:01:21.544]                       muffled <- FALSE
[11:01:21.544]                       if (inherits(cond, "message")) {
[11:01:21.544]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.544]                         if (muffled) 
[11:01:21.544]                           invokeRestart("muffleMessage")
[11:01:21.544]                       }
[11:01:21.544]                       else if (inherits(cond, "warning")) {
[11:01:21.544]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.544]                         if (muffled) 
[11:01:21.544]                           invokeRestart("muffleWarning")
[11:01:21.544]                       }
[11:01:21.544]                       else if (inherits(cond, "condition")) {
[11:01:21.544]                         if (!is.null(pattern)) {
[11:01:21.544]                           computeRestarts <- base::computeRestarts
[11:01:21.544]                           grepl <- base::grepl
[11:01:21.544]                           restarts <- computeRestarts(cond)
[11:01:21.544]                           for (restart in restarts) {
[11:01:21.544]                             name <- restart$name
[11:01:21.544]                             if (is.null(name)) 
[11:01:21.544]                               next
[11:01:21.544]                             if (!grepl(pattern, name)) 
[11:01:21.544]                               next
[11:01:21.544]                             invokeRestart(restart)
[11:01:21.544]                             muffled <- TRUE
[11:01:21.544]                             break
[11:01:21.544]                           }
[11:01:21.544]                         }
[11:01:21.544]                       }
[11:01:21.544]                       invisible(muffled)
[11:01:21.544]                     }
[11:01:21.544]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.544]                   }
[11:01:21.544]                 }
[11:01:21.544]             }
[11:01:21.544]         }))
[11:01:21.544]     }, error = function(ex) {
[11:01:21.544]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:21.544]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.544]                 ...future.rng), started = ...future.startTime, 
[11:01:21.544]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:21.544]             version = "1.8"), class = "FutureResult")
[11:01:21.544]     }, finally = {
[11:01:21.544]         if (!identical(...future.workdir, getwd())) 
[11:01:21.544]             setwd(...future.workdir)
[11:01:21.544]         {
[11:01:21.544]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:21.544]                 ...future.oldOptions$nwarnings <- NULL
[11:01:21.544]             }
[11:01:21.544]             base::options(...future.oldOptions)
[11:01:21.544]             if (.Platform$OS.type == "windows") {
[11:01:21.544]                 old_names <- names(...future.oldEnvVars)
[11:01:21.544]                 envs <- base::Sys.getenv()
[11:01:21.544]                 names <- names(envs)
[11:01:21.544]                 common <- intersect(names, old_names)
[11:01:21.544]                 added <- setdiff(names, old_names)
[11:01:21.544]                 removed <- setdiff(old_names, names)
[11:01:21.544]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:21.544]                   envs[common]]
[11:01:21.544]                 NAMES <- toupper(changed)
[11:01:21.544]                 args <- list()
[11:01:21.544]                 for (kk in seq_along(NAMES)) {
[11:01:21.544]                   name <- changed[[kk]]
[11:01:21.544]                   NAME <- NAMES[[kk]]
[11:01:21.544]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.544]                     next
[11:01:21.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.544]                 }
[11:01:21.544]                 NAMES <- toupper(added)
[11:01:21.544]                 for (kk in seq_along(NAMES)) {
[11:01:21.544]                   name <- added[[kk]]
[11:01:21.544]                   NAME <- NAMES[[kk]]
[11:01:21.544]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.544]                     next
[11:01:21.544]                   args[[name]] <- ""
[11:01:21.544]                 }
[11:01:21.544]                 NAMES <- toupper(removed)
[11:01:21.544]                 for (kk in seq_along(NAMES)) {
[11:01:21.544]                   name <- removed[[kk]]
[11:01:21.544]                   NAME <- NAMES[[kk]]
[11:01:21.544]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.544]                     next
[11:01:21.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.544]                 }
[11:01:21.544]                 if (length(args) > 0) 
[11:01:21.544]                   base::do.call(base::Sys.setenv, args = args)
[11:01:21.544]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:21.544]             }
[11:01:21.544]             else {
[11:01:21.544]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:21.544]             }
[11:01:21.544]             {
[11:01:21.544]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:21.544]                   0L) {
[11:01:21.544]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:21.544]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:21.544]                   base::options(opts)
[11:01:21.544]                 }
[11:01:21.544]                 {
[11:01:21.544]                   {
[11:01:21.544]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:21.544]                     NULL
[11:01:21.544]                   }
[11:01:21.544]                   options(future.plan = NULL)
[11:01:21.544]                   if (is.na(NA_character_)) 
[11:01:21.544]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.544]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:21.544]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:21.544]                     .init = FALSE)
[11:01:21.544]                 }
[11:01:21.544]             }
[11:01:21.544]         }
[11:01:21.544]     })
[11:01:21.544]     if (TRUE) {
[11:01:21.544]         base::sink(type = "output", split = FALSE)
[11:01:21.544]         if (TRUE) {
[11:01:21.544]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:21.544]         }
[11:01:21.544]         else {
[11:01:21.544]             ...future.result["stdout"] <- base::list(NULL)
[11:01:21.544]         }
[11:01:21.544]         base::close(...future.stdout)
[11:01:21.544]         ...future.stdout <- NULL
[11:01:21.544]     }
[11:01:21.544]     ...future.result$conditions <- ...future.conditions
[11:01:21.544]     ...future.result$finished <- base::Sys.time()
[11:01:21.544]     ...future.result
[11:01:21.544] }
[11:01:21.546] MultisessionFuture started
[11:01:21.547] - Launch lazy future ... done
[11:01:21.547] run() for ‘MultisessionFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[11:01:21.547] result() for ClusterFuture ...
[11:01:21.547] - result already collected: FutureResult
[11:01:21.547] result() for ClusterFuture ... done
[11:01:21.547] result() for ClusterFuture ...
[11:01:21.547] - result already collected: FutureResult
[11:01:21.547] result() for ClusterFuture ... done
[11:01:21.548] signalConditions() ...
[11:01:21.548]  - include = ‘immediateCondition’
[11:01:21.548]  - exclude = 
[11:01:21.548]  - resignal = FALSE
[11:01:21.548]  - Number of conditions: 1
[11:01:21.548] signalConditions() ... done
[11:01:21.548] Future state: ‘finished’
[11:01:21.548] result() for ClusterFuture ...
[11:01:21.548] - result already collected: FutureResult
[11:01:21.548] result() for ClusterFuture ... done
[11:01:21.548] signalConditions() ...
[11:01:21.548]  - include = ‘condition’
[11:01:21.549]  - exclude = ‘immediateCondition’
[11:01:21.549]  - resignal = TRUE
[11:01:21.549]  - Number of conditions: 1
[11:01:21.549]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:21.549] signalConditions() ... done
v3: <simpleError> (as expect)
[11:01:21.549] result() for ClusterFuture ...
[11:01:21.549] receiveMessageFromWorker() for ClusterFuture ...
[11:01:21.549] - Validating connection of MultisessionFuture
[11:01:21.588] - received message: FutureResult
[11:01:21.588] - Received FutureResult
[11:01:21.588] - Erased future from FutureRegistry
[11:01:21.588] result() for ClusterFuture ...
[11:01:21.588] - result already collected: FutureResult
[11:01:21.589] result() for ClusterFuture ... done
[11:01:21.589] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:21.589] result() for ClusterFuture ... done
[11:01:21.589] result() for ClusterFuture ...
[11:01:21.589] - result already collected: FutureResult
[11:01:21.589] result() for ClusterFuture ... done
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[11:01:21.589] getGlobalsAndPackages() ...
[11:01:21.589] Searching for globals...
[11:01:21.590] 
[11:01:21.590] Searching for globals ... DONE
[11:01:21.590] - globals: [0] <none>
[11:01:21.590] getGlobalsAndPackages() ... DONE
[11:01:21.590] run() for ‘Future’ ...
[11:01:21.590] - state: ‘created’
[11:01:21.590] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:21.604] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:21.604] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:21.604]   - Field: ‘node’
[11:01:21.604]   - Field: ‘label’
[11:01:21.604]   - Field: ‘local’
[11:01:21.604]   - Field: ‘owner’
[11:01:21.604]   - Field: ‘envir’
[11:01:21.605]   - Field: ‘workers’
[11:01:21.605]   - Field: ‘packages’
[11:01:21.605]   - Field: ‘gc’
[11:01:21.605]   - Field: ‘conditions’
[11:01:21.605]   - Field: ‘persistent’
[11:01:21.605]   - Field: ‘expr’
[11:01:21.605]   - Field: ‘uuid’
[11:01:21.605]   - Field: ‘seed’
[11:01:21.605]   - Field: ‘version’
[11:01:21.605]   - Field: ‘result’
[11:01:21.605]   - Field: ‘asynchronous’
[11:01:21.605]   - Field: ‘calls’
[11:01:21.606]   - Field: ‘globals’
[11:01:21.606]   - Field: ‘stdout’
[11:01:21.606]   - Field: ‘earlySignal’
[11:01:21.606]   - Field: ‘lazy’
[11:01:21.606]   - Field: ‘state’
[11:01:21.606] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:21.606] - Launch lazy future ...
[11:01:21.606] Packages needed by the future expression (n = 0): <none>
[11:01:21.606] Packages needed by future strategies (n = 0): <none>
[11:01:21.607] {
[11:01:21.607]     {
[11:01:21.607]         {
[11:01:21.607]             ...future.startTime <- base::Sys.time()
[11:01:21.607]             {
[11:01:21.607]                 {
[11:01:21.607]                   {
[11:01:21.607]                     {
[11:01:21.607]                       base::local({
[11:01:21.607]                         has_future <- base::requireNamespace("future", 
[11:01:21.607]                           quietly = TRUE)
[11:01:21.607]                         if (has_future) {
[11:01:21.607]                           ns <- base::getNamespace("future")
[11:01:21.607]                           version <- ns[[".package"]][["version"]]
[11:01:21.607]                           if (is.null(version)) 
[11:01:21.607]                             version <- utils::packageVersion("future")
[11:01:21.607]                         }
[11:01:21.607]                         else {
[11:01:21.607]                           version <- NULL
[11:01:21.607]                         }
[11:01:21.607]                         if (!has_future || version < "1.8.0") {
[11:01:21.607]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:21.607]                             "", base::R.version$version.string), 
[11:01:21.607]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:21.607]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:21.607]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:21.607]                               "release", "version")], collapse = " "), 
[11:01:21.607]                             hostname = base::Sys.info()[["nodename"]])
[11:01:21.607]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:21.607]                             info)
[11:01:21.607]                           info <- base::paste(info, collapse = "; ")
[11:01:21.607]                           if (!has_future) {
[11:01:21.607]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:21.607]                               info)
[11:01:21.607]                           }
[11:01:21.607]                           else {
[11:01:21.607]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:21.607]                               info, version)
[11:01:21.607]                           }
[11:01:21.607]                           base::stop(msg)
[11:01:21.607]                         }
[11:01:21.607]                       })
[11:01:21.607]                     }
[11:01:21.607]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:21.607]                     base::options(mc.cores = 1L)
[11:01:21.607]                   }
[11:01:21.607]                   ...future.strategy.old <- future::plan("list")
[11:01:21.607]                   options(future.plan = NULL)
[11:01:21.607]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.607]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:21.607]                 }
[11:01:21.607]                 ...future.workdir <- getwd()
[11:01:21.607]             }
[11:01:21.607]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:21.607]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:21.607]         }
[11:01:21.607]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:21.607]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:21.607]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:21.607]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:21.607]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:21.607]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:21.607]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:21.607]             base::names(...future.oldOptions))
[11:01:21.607]     }
[11:01:21.607]     if (FALSE) {
[11:01:21.607]     }
[11:01:21.607]     else {
[11:01:21.607]         if (TRUE) {
[11:01:21.607]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:21.607]                 open = "w")
[11:01:21.607]         }
[11:01:21.607]         else {
[11:01:21.607]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:21.607]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:21.607]         }
[11:01:21.607]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:21.607]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:21.607]             base::sink(type = "output", split = FALSE)
[11:01:21.607]             base::close(...future.stdout)
[11:01:21.607]         }, add = TRUE)
[11:01:21.607]     }
[11:01:21.607]     ...future.frame <- base::sys.nframe()
[11:01:21.607]     ...future.conditions <- base::list()
[11:01:21.607]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:21.607]     if (FALSE) {
[11:01:21.607]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:21.607]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:21.607]     }
[11:01:21.607]     ...future.result <- base::tryCatch({
[11:01:21.607]         base::withCallingHandlers({
[11:01:21.607]             ...future.value <- base::withVisible(base::local({
[11:01:21.607]                 ...future.makeSendCondition <- base::local({
[11:01:21.607]                   sendCondition <- NULL
[11:01:21.607]                   function(frame = 1L) {
[11:01:21.607]                     if (is.function(sendCondition)) 
[11:01:21.607]                       return(sendCondition)
[11:01:21.607]                     ns <- getNamespace("parallel")
[11:01:21.607]                     if (exists("sendData", mode = "function", 
[11:01:21.607]                       envir = ns)) {
[11:01:21.607]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:21.607]                         envir = ns)
[11:01:21.607]                       envir <- sys.frame(frame)
[11:01:21.607]                       master <- NULL
[11:01:21.607]                       while (!identical(envir, .GlobalEnv) && 
[11:01:21.607]                         !identical(envir, emptyenv())) {
[11:01:21.607]                         if (exists("master", mode = "list", envir = envir, 
[11:01:21.607]                           inherits = FALSE)) {
[11:01:21.607]                           master <- get("master", mode = "list", 
[11:01:21.607]                             envir = envir, inherits = FALSE)
[11:01:21.607]                           if (inherits(master, c("SOCKnode", 
[11:01:21.607]                             "SOCK0node"))) {
[11:01:21.607]                             sendCondition <<- function(cond) {
[11:01:21.607]                               data <- list(type = "VALUE", value = cond, 
[11:01:21.607]                                 success = TRUE)
[11:01:21.607]                               parallel_sendData(master, data)
[11:01:21.607]                             }
[11:01:21.607]                             return(sendCondition)
[11:01:21.607]                           }
[11:01:21.607]                         }
[11:01:21.607]                         frame <- frame + 1L
[11:01:21.607]                         envir <- sys.frame(frame)
[11:01:21.607]                       }
[11:01:21.607]                     }
[11:01:21.607]                     sendCondition <<- function(cond) NULL
[11:01:21.607]                   }
[11:01:21.607]                 })
[11:01:21.607]                 withCallingHandlers({
[11:01:21.607]                   1
[11:01:21.607]                 }, immediateCondition = function(cond) {
[11:01:21.607]                   sendCondition <- ...future.makeSendCondition()
[11:01:21.607]                   sendCondition(cond)
[11:01:21.607]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.607]                   {
[11:01:21.607]                     inherits <- base::inherits
[11:01:21.607]                     invokeRestart <- base::invokeRestart
[11:01:21.607]                     is.null <- base::is.null
[11:01:21.607]                     muffled <- FALSE
[11:01:21.607]                     if (inherits(cond, "message")) {
[11:01:21.607]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:21.607]                       if (muffled) 
[11:01:21.607]                         invokeRestart("muffleMessage")
[11:01:21.607]                     }
[11:01:21.607]                     else if (inherits(cond, "warning")) {
[11:01:21.607]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:21.607]                       if (muffled) 
[11:01:21.607]                         invokeRestart("muffleWarning")
[11:01:21.607]                     }
[11:01:21.607]                     else if (inherits(cond, "condition")) {
[11:01:21.607]                       if (!is.null(pattern)) {
[11:01:21.607]                         computeRestarts <- base::computeRestarts
[11:01:21.607]                         grepl <- base::grepl
[11:01:21.607]                         restarts <- computeRestarts(cond)
[11:01:21.607]                         for (restart in restarts) {
[11:01:21.607]                           name <- restart$name
[11:01:21.607]                           if (is.null(name)) 
[11:01:21.607]                             next
[11:01:21.607]                           if (!grepl(pattern, name)) 
[11:01:21.607]                             next
[11:01:21.607]                           invokeRestart(restart)
[11:01:21.607]                           muffled <- TRUE
[11:01:21.607]                           break
[11:01:21.607]                         }
[11:01:21.607]                       }
[11:01:21.607]                     }
[11:01:21.607]                     invisible(muffled)
[11:01:21.607]                   }
[11:01:21.607]                   muffleCondition(cond)
[11:01:21.607]                 })
[11:01:21.607]             }))
[11:01:21.607]             future::FutureResult(value = ...future.value$value, 
[11:01:21.607]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.607]                   ...future.rng), globalenv = if (FALSE) 
[11:01:21.607]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:21.607]                     ...future.globalenv.names))
[11:01:21.607]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:21.607]         }, condition = base::local({
[11:01:21.607]             c <- base::c
[11:01:21.607]             inherits <- base::inherits
[11:01:21.607]             invokeRestart <- base::invokeRestart
[11:01:21.607]             length <- base::length
[11:01:21.607]             list <- base::list
[11:01:21.607]             seq.int <- base::seq.int
[11:01:21.607]             signalCondition <- base::signalCondition
[11:01:21.607]             sys.calls <- base::sys.calls
[11:01:21.607]             `[[` <- base::`[[`
[11:01:21.607]             `+` <- base::`+`
[11:01:21.607]             `<<-` <- base::`<<-`
[11:01:21.607]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:21.607]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:21.607]                   3L)]
[11:01:21.607]             }
[11:01:21.607]             function(cond) {
[11:01:21.607]                 is_error <- inherits(cond, "error")
[11:01:21.607]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:21.607]                   NULL)
[11:01:21.607]                 if (is_error) {
[11:01:21.607]                   sessionInformation <- function() {
[11:01:21.607]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:21.607]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:21.607]                       search = base::search(), system = base::Sys.info())
[11:01:21.607]                   }
[11:01:21.607]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.607]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:21.607]                     cond$call), session = sessionInformation(), 
[11:01:21.607]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:21.607]                   signalCondition(cond)
[11:01:21.607]                 }
[11:01:21.607]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:21.607]                 "immediateCondition"))) {
[11:01:21.607]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:21.607]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.607]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:21.607]                   if (TRUE && !signal) {
[11:01:21.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.607]                     {
[11:01:21.607]                       inherits <- base::inherits
[11:01:21.607]                       invokeRestart <- base::invokeRestart
[11:01:21.607]                       is.null <- base::is.null
[11:01:21.607]                       muffled <- FALSE
[11:01:21.607]                       if (inherits(cond, "message")) {
[11:01:21.607]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.607]                         if (muffled) 
[11:01:21.607]                           invokeRestart("muffleMessage")
[11:01:21.607]                       }
[11:01:21.607]                       else if (inherits(cond, "warning")) {
[11:01:21.607]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.607]                         if (muffled) 
[11:01:21.607]                           invokeRestart("muffleWarning")
[11:01:21.607]                       }
[11:01:21.607]                       else if (inherits(cond, "condition")) {
[11:01:21.607]                         if (!is.null(pattern)) {
[11:01:21.607]                           computeRestarts <- base::computeRestarts
[11:01:21.607]                           grepl <- base::grepl
[11:01:21.607]                           restarts <- computeRestarts(cond)
[11:01:21.607]                           for (restart in restarts) {
[11:01:21.607]                             name <- restart$name
[11:01:21.607]                             if (is.null(name)) 
[11:01:21.607]                               next
[11:01:21.607]                             if (!grepl(pattern, name)) 
[11:01:21.607]                               next
[11:01:21.607]                             invokeRestart(restart)
[11:01:21.607]                             muffled <- TRUE
[11:01:21.607]                             break
[11:01:21.607]                           }
[11:01:21.607]                         }
[11:01:21.607]                       }
[11:01:21.607]                       invisible(muffled)
[11:01:21.607]                     }
[11:01:21.607]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.607]                   }
[11:01:21.607]                 }
[11:01:21.607]                 else {
[11:01:21.607]                   if (TRUE) {
[11:01:21.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.607]                     {
[11:01:21.607]                       inherits <- base::inherits
[11:01:21.607]                       invokeRestart <- base::invokeRestart
[11:01:21.607]                       is.null <- base::is.null
[11:01:21.607]                       muffled <- FALSE
[11:01:21.607]                       if (inherits(cond, "message")) {
[11:01:21.607]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.607]                         if (muffled) 
[11:01:21.607]                           invokeRestart("muffleMessage")
[11:01:21.607]                       }
[11:01:21.607]                       else if (inherits(cond, "warning")) {
[11:01:21.607]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.607]                         if (muffled) 
[11:01:21.607]                           invokeRestart("muffleWarning")
[11:01:21.607]                       }
[11:01:21.607]                       else if (inherits(cond, "condition")) {
[11:01:21.607]                         if (!is.null(pattern)) {
[11:01:21.607]                           computeRestarts <- base::computeRestarts
[11:01:21.607]                           grepl <- base::grepl
[11:01:21.607]                           restarts <- computeRestarts(cond)
[11:01:21.607]                           for (restart in restarts) {
[11:01:21.607]                             name <- restart$name
[11:01:21.607]                             if (is.null(name)) 
[11:01:21.607]                               next
[11:01:21.607]                             if (!grepl(pattern, name)) 
[11:01:21.607]                               next
[11:01:21.607]                             invokeRestart(restart)
[11:01:21.607]                             muffled <- TRUE
[11:01:21.607]                             break
[11:01:21.607]                           }
[11:01:21.607]                         }
[11:01:21.607]                       }
[11:01:21.607]                       invisible(muffled)
[11:01:21.607]                     }
[11:01:21.607]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.607]                   }
[11:01:21.607]                 }
[11:01:21.607]             }
[11:01:21.607]         }))
[11:01:21.607]     }, error = function(ex) {
[11:01:21.607]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:21.607]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.607]                 ...future.rng), started = ...future.startTime, 
[11:01:21.607]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:21.607]             version = "1.8"), class = "FutureResult")
[11:01:21.607]     }, finally = {
[11:01:21.607]         if (!identical(...future.workdir, getwd())) 
[11:01:21.607]             setwd(...future.workdir)
[11:01:21.607]         {
[11:01:21.607]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:21.607]                 ...future.oldOptions$nwarnings <- NULL
[11:01:21.607]             }
[11:01:21.607]             base::options(...future.oldOptions)
[11:01:21.607]             if (.Platform$OS.type == "windows") {
[11:01:21.607]                 old_names <- names(...future.oldEnvVars)
[11:01:21.607]                 envs <- base::Sys.getenv()
[11:01:21.607]                 names <- names(envs)
[11:01:21.607]                 common <- intersect(names, old_names)
[11:01:21.607]                 added <- setdiff(names, old_names)
[11:01:21.607]                 removed <- setdiff(old_names, names)
[11:01:21.607]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:21.607]                   envs[common]]
[11:01:21.607]                 NAMES <- toupper(changed)
[11:01:21.607]                 args <- list()
[11:01:21.607]                 for (kk in seq_along(NAMES)) {
[11:01:21.607]                   name <- changed[[kk]]
[11:01:21.607]                   NAME <- NAMES[[kk]]
[11:01:21.607]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.607]                     next
[11:01:21.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.607]                 }
[11:01:21.607]                 NAMES <- toupper(added)
[11:01:21.607]                 for (kk in seq_along(NAMES)) {
[11:01:21.607]                   name <- added[[kk]]
[11:01:21.607]                   NAME <- NAMES[[kk]]
[11:01:21.607]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.607]                     next
[11:01:21.607]                   args[[name]] <- ""
[11:01:21.607]                 }
[11:01:21.607]                 NAMES <- toupper(removed)
[11:01:21.607]                 for (kk in seq_along(NAMES)) {
[11:01:21.607]                   name <- removed[[kk]]
[11:01:21.607]                   NAME <- NAMES[[kk]]
[11:01:21.607]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.607]                     next
[11:01:21.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.607]                 }
[11:01:21.607]                 if (length(args) > 0) 
[11:01:21.607]                   base::do.call(base::Sys.setenv, args = args)
[11:01:21.607]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:21.607]             }
[11:01:21.607]             else {
[11:01:21.607]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:21.607]             }
[11:01:21.607]             {
[11:01:21.607]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:21.607]                   0L) {
[11:01:21.607]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:21.607]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:21.607]                   base::options(opts)
[11:01:21.607]                 }
[11:01:21.607]                 {
[11:01:21.607]                   {
[11:01:21.607]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:21.607]                     NULL
[11:01:21.607]                   }
[11:01:21.607]                   options(future.plan = NULL)
[11:01:21.607]                   if (is.na(NA_character_)) 
[11:01:21.607]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.607]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:21.607]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:21.607]                     .init = FALSE)
[11:01:21.607]                 }
[11:01:21.607]             }
[11:01:21.607]         }
[11:01:21.607]     })
[11:01:21.607]     if (TRUE) {
[11:01:21.607]         base::sink(type = "output", split = FALSE)
[11:01:21.607]         if (TRUE) {
[11:01:21.607]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:21.607]         }
[11:01:21.607]         else {
[11:01:21.607]             ...future.result["stdout"] <- base::list(NULL)
[11:01:21.607]         }
[11:01:21.607]         base::close(...future.stdout)
[11:01:21.607]         ...future.stdout <- NULL
[11:01:21.607]     }
[11:01:21.607]     ...future.result$conditions <- ...future.conditions
[11:01:21.607]     ...future.result$finished <- base::Sys.time()
[11:01:21.607]     ...future.result
[11:01:21.607] }
[11:01:21.610] MultisessionFuture started
[11:01:21.610] - Launch lazy future ... done
[11:01:21.610] run() for ‘MultisessionFuture’ ... done
[11:01:21.610] result() for ClusterFuture ...
[11:01:21.610] receiveMessageFromWorker() for ClusterFuture ...
[11:01:21.610] - Validating connection of MultisessionFuture
[11:01:21.652] - received message: FutureResult
[11:01:21.652] - Received FutureResult
[11:01:21.652] - Erased future from FutureRegistry
[11:01:21.652] result() for ClusterFuture ...
[11:01:21.652] - result already collected: FutureResult
[11:01:21.652] result() for ClusterFuture ... done
[11:01:21.652] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:21.653] result() for ClusterFuture ... done
[11:01:21.653] result() for ClusterFuture ...
[11:01:21.653] - result already collected: FutureResult
[11:01:21.653] result() for ClusterFuture ... done
c = 1
[11:01:21.653] getGlobalsAndPackages() ...
[11:01:21.653] Searching for globals...
[11:01:21.653] 
[11:01:21.654] Searching for globals ... DONE
[11:01:21.654] - globals: [0] <none>
[11:01:21.654] getGlobalsAndPackages() ... DONE
[11:01:21.654] run() for ‘Future’ ...
[11:01:21.654] - state: ‘created’
[11:01:21.654] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:21.668] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:21.668] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:21.668]   - Field: ‘node’
[11:01:21.668]   - Field: ‘label’
[11:01:21.668]   - Field: ‘local’
[11:01:21.668]   - Field: ‘owner’
[11:01:21.668]   - Field: ‘envir’
[11:01:21.668]   - Field: ‘workers’
[11:01:21.668]   - Field: ‘packages’
[11:01:21.668]   - Field: ‘gc’
[11:01:21.669]   - Field: ‘conditions’
[11:01:21.669]   - Field: ‘persistent’
[11:01:21.669]   - Field: ‘expr’
[11:01:21.669]   - Field: ‘uuid’
[11:01:21.669]   - Field: ‘seed’
[11:01:21.669]   - Field: ‘version’
[11:01:21.669]   - Field: ‘result’
[11:01:21.669]   - Field: ‘asynchronous’
[11:01:21.669]   - Field: ‘calls’
[11:01:21.669]   - Field: ‘globals’
[11:01:21.669]   - Field: ‘stdout’
[11:01:21.669]   - Field: ‘earlySignal’
[11:01:21.670]   - Field: ‘lazy’
[11:01:21.670]   - Field: ‘state’
[11:01:21.670] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:21.670] - Launch lazy future ...
[11:01:21.670] Packages needed by the future expression (n = 0): <none>
[11:01:21.670] Packages needed by future strategies (n = 0): <none>
[11:01:21.671] {
[11:01:21.671]     {
[11:01:21.671]         {
[11:01:21.671]             ...future.startTime <- base::Sys.time()
[11:01:21.671]             {
[11:01:21.671]                 {
[11:01:21.671]                   {
[11:01:21.671]                     {
[11:01:21.671]                       base::local({
[11:01:21.671]                         has_future <- base::requireNamespace("future", 
[11:01:21.671]                           quietly = TRUE)
[11:01:21.671]                         if (has_future) {
[11:01:21.671]                           ns <- base::getNamespace("future")
[11:01:21.671]                           version <- ns[[".package"]][["version"]]
[11:01:21.671]                           if (is.null(version)) 
[11:01:21.671]                             version <- utils::packageVersion("future")
[11:01:21.671]                         }
[11:01:21.671]                         else {
[11:01:21.671]                           version <- NULL
[11:01:21.671]                         }
[11:01:21.671]                         if (!has_future || version < "1.8.0") {
[11:01:21.671]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:21.671]                             "", base::R.version$version.string), 
[11:01:21.671]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:21.671]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:21.671]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:21.671]                               "release", "version")], collapse = " "), 
[11:01:21.671]                             hostname = base::Sys.info()[["nodename"]])
[11:01:21.671]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:21.671]                             info)
[11:01:21.671]                           info <- base::paste(info, collapse = "; ")
[11:01:21.671]                           if (!has_future) {
[11:01:21.671]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:21.671]                               info)
[11:01:21.671]                           }
[11:01:21.671]                           else {
[11:01:21.671]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:21.671]                               info, version)
[11:01:21.671]                           }
[11:01:21.671]                           base::stop(msg)
[11:01:21.671]                         }
[11:01:21.671]                       })
[11:01:21.671]                     }
[11:01:21.671]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:21.671]                     base::options(mc.cores = 1L)
[11:01:21.671]                   }
[11:01:21.671]                   ...future.strategy.old <- future::plan("list")
[11:01:21.671]                   options(future.plan = NULL)
[11:01:21.671]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.671]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:21.671]                 }
[11:01:21.671]                 ...future.workdir <- getwd()
[11:01:21.671]             }
[11:01:21.671]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:21.671]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:21.671]         }
[11:01:21.671]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:21.671]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:21.671]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:21.671]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:21.671]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:21.671]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:21.671]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:21.671]             base::names(...future.oldOptions))
[11:01:21.671]     }
[11:01:21.671]     if (FALSE) {
[11:01:21.671]     }
[11:01:21.671]     else {
[11:01:21.671]         if (TRUE) {
[11:01:21.671]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:21.671]                 open = "w")
[11:01:21.671]         }
[11:01:21.671]         else {
[11:01:21.671]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:21.671]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:21.671]         }
[11:01:21.671]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:21.671]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:21.671]             base::sink(type = "output", split = FALSE)
[11:01:21.671]             base::close(...future.stdout)
[11:01:21.671]         }, add = TRUE)
[11:01:21.671]     }
[11:01:21.671]     ...future.frame <- base::sys.nframe()
[11:01:21.671]     ...future.conditions <- base::list()
[11:01:21.671]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:21.671]     if (FALSE) {
[11:01:21.671]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:21.671]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:21.671]     }
[11:01:21.671]     ...future.result <- base::tryCatch({
[11:01:21.671]         base::withCallingHandlers({
[11:01:21.671]             ...future.value <- base::withVisible(base::local({
[11:01:21.671]                 ...future.makeSendCondition <- base::local({
[11:01:21.671]                   sendCondition <- NULL
[11:01:21.671]                   function(frame = 1L) {
[11:01:21.671]                     if (is.function(sendCondition)) 
[11:01:21.671]                       return(sendCondition)
[11:01:21.671]                     ns <- getNamespace("parallel")
[11:01:21.671]                     if (exists("sendData", mode = "function", 
[11:01:21.671]                       envir = ns)) {
[11:01:21.671]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:21.671]                         envir = ns)
[11:01:21.671]                       envir <- sys.frame(frame)
[11:01:21.671]                       master <- NULL
[11:01:21.671]                       while (!identical(envir, .GlobalEnv) && 
[11:01:21.671]                         !identical(envir, emptyenv())) {
[11:01:21.671]                         if (exists("master", mode = "list", envir = envir, 
[11:01:21.671]                           inherits = FALSE)) {
[11:01:21.671]                           master <- get("master", mode = "list", 
[11:01:21.671]                             envir = envir, inherits = FALSE)
[11:01:21.671]                           if (inherits(master, c("SOCKnode", 
[11:01:21.671]                             "SOCK0node"))) {
[11:01:21.671]                             sendCondition <<- function(cond) {
[11:01:21.671]                               data <- list(type = "VALUE", value = cond, 
[11:01:21.671]                                 success = TRUE)
[11:01:21.671]                               parallel_sendData(master, data)
[11:01:21.671]                             }
[11:01:21.671]                             return(sendCondition)
[11:01:21.671]                           }
[11:01:21.671]                         }
[11:01:21.671]                         frame <- frame + 1L
[11:01:21.671]                         envir <- sys.frame(frame)
[11:01:21.671]                       }
[11:01:21.671]                     }
[11:01:21.671]                     sendCondition <<- function(cond) NULL
[11:01:21.671]                   }
[11:01:21.671]                 })
[11:01:21.671]                 withCallingHandlers({
[11:01:21.671]                   1
[11:01:21.671]                 }, immediateCondition = function(cond) {
[11:01:21.671]                   sendCondition <- ...future.makeSendCondition()
[11:01:21.671]                   sendCondition(cond)
[11:01:21.671]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.671]                   {
[11:01:21.671]                     inherits <- base::inherits
[11:01:21.671]                     invokeRestart <- base::invokeRestart
[11:01:21.671]                     is.null <- base::is.null
[11:01:21.671]                     muffled <- FALSE
[11:01:21.671]                     if (inherits(cond, "message")) {
[11:01:21.671]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:21.671]                       if (muffled) 
[11:01:21.671]                         invokeRestart("muffleMessage")
[11:01:21.671]                     }
[11:01:21.671]                     else if (inherits(cond, "warning")) {
[11:01:21.671]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:21.671]                       if (muffled) 
[11:01:21.671]                         invokeRestart("muffleWarning")
[11:01:21.671]                     }
[11:01:21.671]                     else if (inherits(cond, "condition")) {
[11:01:21.671]                       if (!is.null(pattern)) {
[11:01:21.671]                         computeRestarts <- base::computeRestarts
[11:01:21.671]                         grepl <- base::grepl
[11:01:21.671]                         restarts <- computeRestarts(cond)
[11:01:21.671]                         for (restart in restarts) {
[11:01:21.671]                           name <- restart$name
[11:01:21.671]                           if (is.null(name)) 
[11:01:21.671]                             next
[11:01:21.671]                           if (!grepl(pattern, name)) 
[11:01:21.671]                             next
[11:01:21.671]                           invokeRestart(restart)
[11:01:21.671]                           muffled <- TRUE
[11:01:21.671]                           break
[11:01:21.671]                         }
[11:01:21.671]                       }
[11:01:21.671]                     }
[11:01:21.671]                     invisible(muffled)
[11:01:21.671]                   }
[11:01:21.671]                   muffleCondition(cond)
[11:01:21.671]                 })
[11:01:21.671]             }))
[11:01:21.671]             future::FutureResult(value = ...future.value$value, 
[11:01:21.671]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.671]                   ...future.rng), globalenv = if (FALSE) 
[11:01:21.671]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:21.671]                     ...future.globalenv.names))
[11:01:21.671]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:21.671]         }, condition = base::local({
[11:01:21.671]             c <- base::c
[11:01:21.671]             inherits <- base::inherits
[11:01:21.671]             invokeRestart <- base::invokeRestart
[11:01:21.671]             length <- base::length
[11:01:21.671]             list <- base::list
[11:01:21.671]             seq.int <- base::seq.int
[11:01:21.671]             signalCondition <- base::signalCondition
[11:01:21.671]             sys.calls <- base::sys.calls
[11:01:21.671]             `[[` <- base::`[[`
[11:01:21.671]             `+` <- base::`+`
[11:01:21.671]             `<<-` <- base::`<<-`
[11:01:21.671]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:21.671]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:21.671]                   3L)]
[11:01:21.671]             }
[11:01:21.671]             function(cond) {
[11:01:21.671]                 is_error <- inherits(cond, "error")
[11:01:21.671]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:21.671]                   NULL)
[11:01:21.671]                 if (is_error) {
[11:01:21.671]                   sessionInformation <- function() {
[11:01:21.671]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:21.671]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:21.671]                       search = base::search(), system = base::Sys.info())
[11:01:21.671]                   }
[11:01:21.671]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.671]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:21.671]                     cond$call), session = sessionInformation(), 
[11:01:21.671]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:21.671]                   signalCondition(cond)
[11:01:21.671]                 }
[11:01:21.671]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:21.671]                 "immediateCondition"))) {
[11:01:21.671]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:21.671]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.671]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:21.671]                   if (TRUE && !signal) {
[11:01:21.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.671]                     {
[11:01:21.671]                       inherits <- base::inherits
[11:01:21.671]                       invokeRestart <- base::invokeRestart
[11:01:21.671]                       is.null <- base::is.null
[11:01:21.671]                       muffled <- FALSE
[11:01:21.671]                       if (inherits(cond, "message")) {
[11:01:21.671]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.671]                         if (muffled) 
[11:01:21.671]                           invokeRestart("muffleMessage")
[11:01:21.671]                       }
[11:01:21.671]                       else if (inherits(cond, "warning")) {
[11:01:21.671]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.671]                         if (muffled) 
[11:01:21.671]                           invokeRestart("muffleWarning")
[11:01:21.671]                       }
[11:01:21.671]                       else if (inherits(cond, "condition")) {
[11:01:21.671]                         if (!is.null(pattern)) {
[11:01:21.671]                           computeRestarts <- base::computeRestarts
[11:01:21.671]                           grepl <- base::grepl
[11:01:21.671]                           restarts <- computeRestarts(cond)
[11:01:21.671]                           for (restart in restarts) {
[11:01:21.671]                             name <- restart$name
[11:01:21.671]                             if (is.null(name)) 
[11:01:21.671]                               next
[11:01:21.671]                             if (!grepl(pattern, name)) 
[11:01:21.671]                               next
[11:01:21.671]                             invokeRestart(restart)
[11:01:21.671]                             muffled <- TRUE
[11:01:21.671]                             break
[11:01:21.671]                           }
[11:01:21.671]                         }
[11:01:21.671]                       }
[11:01:21.671]                       invisible(muffled)
[11:01:21.671]                     }
[11:01:21.671]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.671]                   }
[11:01:21.671]                 }
[11:01:21.671]                 else {
[11:01:21.671]                   if (TRUE) {
[11:01:21.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.671]                     {
[11:01:21.671]                       inherits <- base::inherits
[11:01:21.671]                       invokeRestart <- base::invokeRestart
[11:01:21.671]                       is.null <- base::is.null
[11:01:21.671]                       muffled <- FALSE
[11:01:21.671]                       if (inherits(cond, "message")) {
[11:01:21.671]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.671]                         if (muffled) 
[11:01:21.671]                           invokeRestart("muffleMessage")
[11:01:21.671]                       }
[11:01:21.671]                       else if (inherits(cond, "warning")) {
[11:01:21.671]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.671]                         if (muffled) 
[11:01:21.671]                           invokeRestart("muffleWarning")
[11:01:21.671]                       }
[11:01:21.671]                       else if (inherits(cond, "condition")) {
[11:01:21.671]                         if (!is.null(pattern)) {
[11:01:21.671]                           computeRestarts <- base::computeRestarts
[11:01:21.671]                           grepl <- base::grepl
[11:01:21.671]                           restarts <- computeRestarts(cond)
[11:01:21.671]                           for (restart in restarts) {
[11:01:21.671]                             name <- restart$name
[11:01:21.671]                             if (is.null(name)) 
[11:01:21.671]                               next
[11:01:21.671]                             if (!grepl(pattern, name)) 
[11:01:21.671]                               next
[11:01:21.671]                             invokeRestart(restart)
[11:01:21.671]                             muffled <- TRUE
[11:01:21.671]                             break
[11:01:21.671]                           }
[11:01:21.671]                         }
[11:01:21.671]                       }
[11:01:21.671]                       invisible(muffled)
[11:01:21.671]                     }
[11:01:21.671]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.671]                   }
[11:01:21.671]                 }
[11:01:21.671]             }
[11:01:21.671]         }))
[11:01:21.671]     }, error = function(ex) {
[11:01:21.671]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:21.671]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.671]                 ...future.rng), started = ...future.startTime, 
[11:01:21.671]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:21.671]             version = "1.8"), class = "FutureResult")
[11:01:21.671]     }, finally = {
[11:01:21.671]         if (!identical(...future.workdir, getwd())) 
[11:01:21.671]             setwd(...future.workdir)
[11:01:21.671]         {
[11:01:21.671]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:21.671]                 ...future.oldOptions$nwarnings <- NULL
[11:01:21.671]             }
[11:01:21.671]             base::options(...future.oldOptions)
[11:01:21.671]             if (.Platform$OS.type == "windows") {
[11:01:21.671]                 old_names <- names(...future.oldEnvVars)
[11:01:21.671]                 envs <- base::Sys.getenv()
[11:01:21.671]                 names <- names(envs)
[11:01:21.671]                 common <- intersect(names, old_names)
[11:01:21.671]                 added <- setdiff(names, old_names)
[11:01:21.671]                 removed <- setdiff(old_names, names)
[11:01:21.671]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:21.671]                   envs[common]]
[11:01:21.671]                 NAMES <- toupper(changed)
[11:01:21.671]                 args <- list()
[11:01:21.671]                 for (kk in seq_along(NAMES)) {
[11:01:21.671]                   name <- changed[[kk]]
[11:01:21.671]                   NAME <- NAMES[[kk]]
[11:01:21.671]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.671]                     next
[11:01:21.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.671]                 }
[11:01:21.671]                 NAMES <- toupper(added)
[11:01:21.671]                 for (kk in seq_along(NAMES)) {
[11:01:21.671]                   name <- added[[kk]]
[11:01:21.671]                   NAME <- NAMES[[kk]]
[11:01:21.671]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.671]                     next
[11:01:21.671]                   args[[name]] <- ""
[11:01:21.671]                 }
[11:01:21.671]                 NAMES <- toupper(removed)
[11:01:21.671]                 for (kk in seq_along(NAMES)) {
[11:01:21.671]                   name <- removed[[kk]]
[11:01:21.671]                   NAME <- NAMES[[kk]]
[11:01:21.671]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.671]                     next
[11:01:21.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.671]                 }
[11:01:21.671]                 if (length(args) > 0) 
[11:01:21.671]                   base::do.call(base::Sys.setenv, args = args)
[11:01:21.671]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:21.671]             }
[11:01:21.671]             else {
[11:01:21.671]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:21.671]             }
[11:01:21.671]             {
[11:01:21.671]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:21.671]                   0L) {
[11:01:21.671]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:21.671]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:21.671]                   base::options(opts)
[11:01:21.671]                 }
[11:01:21.671]                 {
[11:01:21.671]                   {
[11:01:21.671]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:21.671]                     NULL
[11:01:21.671]                   }
[11:01:21.671]                   options(future.plan = NULL)
[11:01:21.671]                   if (is.na(NA_character_)) 
[11:01:21.671]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.671]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:21.671]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:21.671]                     .init = FALSE)
[11:01:21.671]                 }
[11:01:21.671]             }
[11:01:21.671]         }
[11:01:21.671]     })
[11:01:21.671]     if (TRUE) {
[11:01:21.671]         base::sink(type = "output", split = FALSE)
[11:01:21.671]         if (TRUE) {
[11:01:21.671]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:21.671]         }
[11:01:21.671]         else {
[11:01:21.671]             ...future.result["stdout"] <- base::list(NULL)
[11:01:21.671]         }
[11:01:21.671]         base::close(...future.stdout)
[11:01:21.671]         ...future.stdout <- NULL
[11:01:21.671]     }
[11:01:21.671]     ...future.result$conditions <- ...future.conditions
[11:01:21.671]     ...future.result$finished <- base::Sys.time()
[11:01:21.671]     ...future.result
[11:01:21.671] }
[11:01:21.673] MultisessionFuture started
[11:01:21.673] - Launch lazy future ... done
[11:01:21.674] run() for ‘MultisessionFuture’ ... done
[11:01:21.674] result() for ClusterFuture ...
[11:01:21.674] receiveMessageFromWorker() for ClusterFuture ...
[11:01:21.674] - Validating connection of MultisessionFuture
[11:01:21.715] - received message: FutureResult
[11:01:21.715] - Received FutureResult
[11:01:21.715] - Erased future from FutureRegistry
[11:01:21.715] result() for ClusterFuture ...
[11:01:21.715] - result already collected: FutureResult
[11:01:21.715] result() for ClusterFuture ... done
[11:01:21.716] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:21.716] result() for ClusterFuture ... done
[11:01:21.716] result() for ClusterFuture ...
[11:01:21.716] - result already collected: FutureResult
[11:01:21.716] result() for ClusterFuture ... done
d = 1
** Nested future assignments
[11:01:21.716] getGlobalsAndPackages() ...
[11:01:21.716] Searching for globals...
[11:01:21.720] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[11:01:21.720] Searching for globals ... DONE
[11:01:21.720] Resolving globals: FALSE
[11:01:21.720] 
[11:01:21.720] - packages: [1] ‘future’
[11:01:21.721] getGlobalsAndPackages() ... DONE
[11:01:21.721] run() for ‘Future’ ...
[11:01:21.721] - state: ‘created’
[11:01:21.721] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:21.735] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:21.735] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:21.735]   - Field: ‘node’
[11:01:21.735]   - Field: ‘label’
[11:01:21.735]   - Field: ‘local’
[11:01:21.735]   - Field: ‘owner’
[11:01:21.735]   - Field: ‘envir’
[11:01:21.735]   - Field: ‘workers’
[11:01:21.735]   - Field: ‘packages’
[11:01:21.735]   - Field: ‘gc’
[11:01:21.735]   - Field: ‘conditions’
[11:01:21.736]   - Field: ‘persistent’
[11:01:21.736]   - Field: ‘expr’
[11:01:21.736]   - Field: ‘uuid’
[11:01:21.736]   - Field: ‘seed’
[11:01:21.736]   - Field: ‘version’
[11:01:21.736]   - Field: ‘result’
[11:01:21.736]   - Field: ‘asynchronous’
[11:01:21.736]   - Field: ‘calls’
[11:01:21.736]   - Field: ‘globals’
[11:01:21.736]   - Field: ‘stdout’
[11:01:21.736]   - Field: ‘earlySignal’
[11:01:21.736]   - Field: ‘lazy’
[11:01:21.737]   - Field: ‘state’
[11:01:21.737] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:21.737] - Launch lazy future ...
[11:01:21.737] Packages needed by the future expression (n = 1): ‘future’
[11:01:21.737] Packages needed by future strategies (n = 0): <none>
[11:01:21.738] {
[11:01:21.738]     {
[11:01:21.738]         {
[11:01:21.738]             ...future.startTime <- base::Sys.time()
[11:01:21.738]             {
[11:01:21.738]                 {
[11:01:21.738]                   {
[11:01:21.738]                     {
[11:01:21.738]                       {
[11:01:21.738]                         base::local({
[11:01:21.738]                           has_future <- base::requireNamespace("future", 
[11:01:21.738]                             quietly = TRUE)
[11:01:21.738]                           if (has_future) {
[11:01:21.738]                             ns <- base::getNamespace("future")
[11:01:21.738]                             version <- ns[[".package"]][["version"]]
[11:01:21.738]                             if (is.null(version)) 
[11:01:21.738]                               version <- utils::packageVersion("future")
[11:01:21.738]                           }
[11:01:21.738]                           else {
[11:01:21.738]                             version <- NULL
[11:01:21.738]                           }
[11:01:21.738]                           if (!has_future || version < "1.8.0") {
[11:01:21.738]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:21.738]                               "", base::R.version$version.string), 
[11:01:21.738]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:21.738]                                 base::R.version$platform, 8 * 
[11:01:21.738]                                   base::.Machine$sizeof.pointer), 
[11:01:21.738]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:21.738]                                 "release", "version")], collapse = " "), 
[11:01:21.738]                               hostname = base::Sys.info()[["nodename"]])
[11:01:21.738]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:21.738]                               info)
[11:01:21.738]                             info <- base::paste(info, collapse = "; ")
[11:01:21.738]                             if (!has_future) {
[11:01:21.738]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:21.738]                                 info)
[11:01:21.738]                             }
[11:01:21.738]                             else {
[11:01:21.738]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:21.738]                                 info, version)
[11:01:21.738]                             }
[11:01:21.738]                             base::stop(msg)
[11:01:21.738]                           }
[11:01:21.738]                         })
[11:01:21.738]                       }
[11:01:21.738]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:21.738]                       base::options(mc.cores = 1L)
[11:01:21.738]                     }
[11:01:21.738]                     base::local({
[11:01:21.738]                       for (pkg in "future") {
[11:01:21.738]                         base::loadNamespace(pkg)
[11:01:21.738]                         base::library(pkg, character.only = TRUE)
[11:01:21.738]                       }
[11:01:21.738]                     })
[11:01:21.738]                   }
[11:01:21.738]                   ...future.strategy.old <- future::plan("list")
[11:01:21.738]                   options(future.plan = NULL)
[11:01:21.738]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.738]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:21.738]                 }
[11:01:21.738]                 ...future.workdir <- getwd()
[11:01:21.738]             }
[11:01:21.738]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:21.738]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:21.738]         }
[11:01:21.738]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:21.738]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:21.738]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:21.738]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:21.738]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:21.738]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:21.738]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:21.738]             base::names(...future.oldOptions))
[11:01:21.738]     }
[11:01:21.738]     if (FALSE) {
[11:01:21.738]     }
[11:01:21.738]     else {
[11:01:21.738]         if (TRUE) {
[11:01:21.738]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:21.738]                 open = "w")
[11:01:21.738]         }
[11:01:21.738]         else {
[11:01:21.738]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:21.738]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:21.738]         }
[11:01:21.738]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:21.738]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:21.738]             base::sink(type = "output", split = FALSE)
[11:01:21.738]             base::close(...future.stdout)
[11:01:21.738]         }, add = TRUE)
[11:01:21.738]     }
[11:01:21.738]     ...future.frame <- base::sys.nframe()
[11:01:21.738]     ...future.conditions <- base::list()
[11:01:21.738]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:21.738]     if (FALSE) {
[11:01:21.738]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:21.738]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:21.738]     }
[11:01:21.738]     ...future.result <- base::tryCatch({
[11:01:21.738]         base::withCallingHandlers({
[11:01:21.738]             ...future.value <- base::withVisible(base::local({
[11:01:21.738]                 ...future.makeSendCondition <- base::local({
[11:01:21.738]                   sendCondition <- NULL
[11:01:21.738]                   function(frame = 1L) {
[11:01:21.738]                     if (is.function(sendCondition)) 
[11:01:21.738]                       return(sendCondition)
[11:01:21.738]                     ns <- getNamespace("parallel")
[11:01:21.738]                     if (exists("sendData", mode = "function", 
[11:01:21.738]                       envir = ns)) {
[11:01:21.738]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:21.738]                         envir = ns)
[11:01:21.738]                       envir <- sys.frame(frame)
[11:01:21.738]                       master <- NULL
[11:01:21.738]                       while (!identical(envir, .GlobalEnv) && 
[11:01:21.738]                         !identical(envir, emptyenv())) {
[11:01:21.738]                         if (exists("master", mode = "list", envir = envir, 
[11:01:21.738]                           inherits = FALSE)) {
[11:01:21.738]                           master <- get("master", mode = "list", 
[11:01:21.738]                             envir = envir, inherits = FALSE)
[11:01:21.738]                           if (inherits(master, c("SOCKnode", 
[11:01:21.738]                             "SOCK0node"))) {
[11:01:21.738]                             sendCondition <<- function(cond) {
[11:01:21.738]                               data <- list(type = "VALUE", value = cond, 
[11:01:21.738]                                 success = TRUE)
[11:01:21.738]                               parallel_sendData(master, data)
[11:01:21.738]                             }
[11:01:21.738]                             return(sendCondition)
[11:01:21.738]                           }
[11:01:21.738]                         }
[11:01:21.738]                         frame <- frame + 1L
[11:01:21.738]                         envir <- sys.frame(frame)
[11:01:21.738]                       }
[11:01:21.738]                     }
[11:01:21.738]                     sendCondition <<- function(cond) NULL
[11:01:21.738]                   }
[11:01:21.738]                 })
[11:01:21.738]                 withCallingHandlers({
[11:01:21.738]                   {
[11:01:21.738]                     b <- 1
[11:01:21.738]                     c %<-% 2
[11:01:21.738]                     d <- 3
[11:01:21.738]                     4 %->% e
[11:01:21.738]                     b + c + d + e
[11:01:21.738]                   }
[11:01:21.738]                 }, immediateCondition = function(cond) {
[11:01:21.738]                   sendCondition <- ...future.makeSendCondition()
[11:01:21.738]                   sendCondition(cond)
[11:01:21.738]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.738]                   {
[11:01:21.738]                     inherits <- base::inherits
[11:01:21.738]                     invokeRestart <- base::invokeRestart
[11:01:21.738]                     is.null <- base::is.null
[11:01:21.738]                     muffled <- FALSE
[11:01:21.738]                     if (inherits(cond, "message")) {
[11:01:21.738]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:21.738]                       if (muffled) 
[11:01:21.738]                         invokeRestart("muffleMessage")
[11:01:21.738]                     }
[11:01:21.738]                     else if (inherits(cond, "warning")) {
[11:01:21.738]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:21.738]                       if (muffled) 
[11:01:21.738]                         invokeRestart("muffleWarning")
[11:01:21.738]                     }
[11:01:21.738]                     else if (inherits(cond, "condition")) {
[11:01:21.738]                       if (!is.null(pattern)) {
[11:01:21.738]                         computeRestarts <- base::computeRestarts
[11:01:21.738]                         grepl <- base::grepl
[11:01:21.738]                         restarts <- computeRestarts(cond)
[11:01:21.738]                         for (restart in restarts) {
[11:01:21.738]                           name <- restart$name
[11:01:21.738]                           if (is.null(name)) 
[11:01:21.738]                             next
[11:01:21.738]                           if (!grepl(pattern, name)) 
[11:01:21.738]                             next
[11:01:21.738]                           invokeRestart(restart)
[11:01:21.738]                           muffled <- TRUE
[11:01:21.738]                           break
[11:01:21.738]                         }
[11:01:21.738]                       }
[11:01:21.738]                     }
[11:01:21.738]                     invisible(muffled)
[11:01:21.738]                   }
[11:01:21.738]                   muffleCondition(cond)
[11:01:21.738]                 })
[11:01:21.738]             }))
[11:01:21.738]             future::FutureResult(value = ...future.value$value, 
[11:01:21.738]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.738]                   ...future.rng), globalenv = if (FALSE) 
[11:01:21.738]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:21.738]                     ...future.globalenv.names))
[11:01:21.738]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:21.738]         }, condition = base::local({
[11:01:21.738]             c <- base::c
[11:01:21.738]             inherits <- base::inherits
[11:01:21.738]             invokeRestart <- base::invokeRestart
[11:01:21.738]             length <- base::length
[11:01:21.738]             list <- base::list
[11:01:21.738]             seq.int <- base::seq.int
[11:01:21.738]             signalCondition <- base::signalCondition
[11:01:21.738]             sys.calls <- base::sys.calls
[11:01:21.738]             `[[` <- base::`[[`
[11:01:21.738]             `+` <- base::`+`
[11:01:21.738]             `<<-` <- base::`<<-`
[11:01:21.738]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:21.738]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:21.738]                   3L)]
[11:01:21.738]             }
[11:01:21.738]             function(cond) {
[11:01:21.738]                 is_error <- inherits(cond, "error")
[11:01:21.738]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:21.738]                   NULL)
[11:01:21.738]                 if (is_error) {
[11:01:21.738]                   sessionInformation <- function() {
[11:01:21.738]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:21.738]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:21.738]                       search = base::search(), system = base::Sys.info())
[11:01:21.738]                   }
[11:01:21.738]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.738]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:21.738]                     cond$call), session = sessionInformation(), 
[11:01:21.738]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:21.738]                   signalCondition(cond)
[11:01:21.738]                 }
[11:01:21.738]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:21.738]                 "immediateCondition"))) {
[11:01:21.738]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:21.738]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.738]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:21.738]                   if (TRUE && !signal) {
[11:01:21.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.738]                     {
[11:01:21.738]                       inherits <- base::inherits
[11:01:21.738]                       invokeRestart <- base::invokeRestart
[11:01:21.738]                       is.null <- base::is.null
[11:01:21.738]                       muffled <- FALSE
[11:01:21.738]                       if (inherits(cond, "message")) {
[11:01:21.738]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.738]                         if (muffled) 
[11:01:21.738]                           invokeRestart("muffleMessage")
[11:01:21.738]                       }
[11:01:21.738]                       else if (inherits(cond, "warning")) {
[11:01:21.738]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.738]                         if (muffled) 
[11:01:21.738]                           invokeRestart("muffleWarning")
[11:01:21.738]                       }
[11:01:21.738]                       else if (inherits(cond, "condition")) {
[11:01:21.738]                         if (!is.null(pattern)) {
[11:01:21.738]                           computeRestarts <- base::computeRestarts
[11:01:21.738]                           grepl <- base::grepl
[11:01:21.738]                           restarts <- computeRestarts(cond)
[11:01:21.738]                           for (restart in restarts) {
[11:01:21.738]                             name <- restart$name
[11:01:21.738]                             if (is.null(name)) 
[11:01:21.738]                               next
[11:01:21.738]                             if (!grepl(pattern, name)) 
[11:01:21.738]                               next
[11:01:21.738]                             invokeRestart(restart)
[11:01:21.738]                             muffled <- TRUE
[11:01:21.738]                             break
[11:01:21.738]                           }
[11:01:21.738]                         }
[11:01:21.738]                       }
[11:01:21.738]                       invisible(muffled)
[11:01:21.738]                     }
[11:01:21.738]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.738]                   }
[11:01:21.738]                 }
[11:01:21.738]                 else {
[11:01:21.738]                   if (TRUE) {
[11:01:21.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.738]                     {
[11:01:21.738]                       inherits <- base::inherits
[11:01:21.738]                       invokeRestart <- base::invokeRestart
[11:01:21.738]                       is.null <- base::is.null
[11:01:21.738]                       muffled <- FALSE
[11:01:21.738]                       if (inherits(cond, "message")) {
[11:01:21.738]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.738]                         if (muffled) 
[11:01:21.738]                           invokeRestart("muffleMessage")
[11:01:21.738]                       }
[11:01:21.738]                       else if (inherits(cond, "warning")) {
[11:01:21.738]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.738]                         if (muffled) 
[11:01:21.738]                           invokeRestart("muffleWarning")
[11:01:21.738]                       }
[11:01:21.738]                       else if (inherits(cond, "condition")) {
[11:01:21.738]                         if (!is.null(pattern)) {
[11:01:21.738]                           computeRestarts <- base::computeRestarts
[11:01:21.738]                           grepl <- base::grepl
[11:01:21.738]                           restarts <- computeRestarts(cond)
[11:01:21.738]                           for (restart in restarts) {
[11:01:21.738]                             name <- restart$name
[11:01:21.738]                             if (is.null(name)) 
[11:01:21.738]                               next
[11:01:21.738]                             if (!grepl(pattern, name)) 
[11:01:21.738]                               next
[11:01:21.738]                             invokeRestart(restart)
[11:01:21.738]                             muffled <- TRUE
[11:01:21.738]                             break
[11:01:21.738]                           }
[11:01:21.738]                         }
[11:01:21.738]                       }
[11:01:21.738]                       invisible(muffled)
[11:01:21.738]                     }
[11:01:21.738]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.738]                   }
[11:01:21.738]                 }
[11:01:21.738]             }
[11:01:21.738]         }))
[11:01:21.738]     }, error = function(ex) {
[11:01:21.738]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:21.738]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.738]                 ...future.rng), started = ...future.startTime, 
[11:01:21.738]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:21.738]             version = "1.8"), class = "FutureResult")
[11:01:21.738]     }, finally = {
[11:01:21.738]         if (!identical(...future.workdir, getwd())) 
[11:01:21.738]             setwd(...future.workdir)
[11:01:21.738]         {
[11:01:21.738]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:21.738]                 ...future.oldOptions$nwarnings <- NULL
[11:01:21.738]             }
[11:01:21.738]             base::options(...future.oldOptions)
[11:01:21.738]             if (.Platform$OS.type == "windows") {
[11:01:21.738]                 old_names <- names(...future.oldEnvVars)
[11:01:21.738]                 envs <- base::Sys.getenv()
[11:01:21.738]                 names <- names(envs)
[11:01:21.738]                 common <- intersect(names, old_names)
[11:01:21.738]                 added <- setdiff(names, old_names)
[11:01:21.738]                 removed <- setdiff(old_names, names)
[11:01:21.738]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:21.738]                   envs[common]]
[11:01:21.738]                 NAMES <- toupper(changed)
[11:01:21.738]                 args <- list()
[11:01:21.738]                 for (kk in seq_along(NAMES)) {
[11:01:21.738]                   name <- changed[[kk]]
[11:01:21.738]                   NAME <- NAMES[[kk]]
[11:01:21.738]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.738]                     next
[11:01:21.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.738]                 }
[11:01:21.738]                 NAMES <- toupper(added)
[11:01:21.738]                 for (kk in seq_along(NAMES)) {
[11:01:21.738]                   name <- added[[kk]]
[11:01:21.738]                   NAME <- NAMES[[kk]]
[11:01:21.738]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.738]                     next
[11:01:21.738]                   args[[name]] <- ""
[11:01:21.738]                 }
[11:01:21.738]                 NAMES <- toupper(removed)
[11:01:21.738]                 for (kk in seq_along(NAMES)) {
[11:01:21.738]                   name <- removed[[kk]]
[11:01:21.738]                   NAME <- NAMES[[kk]]
[11:01:21.738]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.738]                     next
[11:01:21.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.738]                 }
[11:01:21.738]                 if (length(args) > 0) 
[11:01:21.738]                   base::do.call(base::Sys.setenv, args = args)
[11:01:21.738]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:21.738]             }
[11:01:21.738]             else {
[11:01:21.738]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:21.738]             }
[11:01:21.738]             {
[11:01:21.738]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:21.738]                   0L) {
[11:01:21.738]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:21.738]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:21.738]                   base::options(opts)
[11:01:21.738]                 }
[11:01:21.738]                 {
[11:01:21.738]                   {
[11:01:21.738]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:21.738]                     NULL
[11:01:21.738]                   }
[11:01:21.738]                   options(future.plan = NULL)
[11:01:21.738]                   if (is.na(NA_character_)) 
[11:01:21.738]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.738]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:21.738]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:21.738]                     .init = FALSE)
[11:01:21.738]                 }
[11:01:21.738]             }
[11:01:21.738]         }
[11:01:21.738]     })
[11:01:21.738]     if (TRUE) {
[11:01:21.738]         base::sink(type = "output", split = FALSE)
[11:01:21.738]         if (TRUE) {
[11:01:21.738]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:21.738]         }
[11:01:21.738]         else {
[11:01:21.738]             ...future.result["stdout"] <- base::list(NULL)
[11:01:21.738]         }
[11:01:21.738]         base::close(...future.stdout)
[11:01:21.738]         ...future.stdout <- NULL
[11:01:21.738]     }
[11:01:21.738]     ...future.result$conditions <- ...future.conditions
[11:01:21.738]     ...future.result$finished <- base::Sys.time()
[11:01:21.738]     ...future.result
[11:01:21.738] }
[11:01:21.740] MultisessionFuture started
[11:01:21.741] - Launch lazy future ... done
[11:01:21.741] run() for ‘MultisessionFuture’ ... done
[11:01:21.741] result() for ClusterFuture ...
[11:01:21.741] receiveMessageFromWorker() for ClusterFuture ...
[11:01:21.741] - Validating connection of MultisessionFuture
[11:01:21.794] - received message: FutureResult
[11:01:21.794] - Received FutureResult
[11:01:21.794] - Erased future from FutureRegistry
[11:01:21.794] result() for ClusterFuture ...
[11:01:21.794] - result already collected: FutureResult
[11:01:21.794] result() for ClusterFuture ... done
[11:01:21.794] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:21.794] result() for ClusterFuture ... done
[11:01:21.795] result() for ClusterFuture ...
[11:01:21.795] - result already collected: FutureResult
[11:01:21.795] result() for ClusterFuture ... done
a = 10
[11:01:21.795] getGlobalsAndPackages() ...
[11:01:21.795] Searching for globals...
[11:01:21.801] - globals found: [3] ‘{’, ‘+’, ‘a’
[11:01:21.801] Searching for globals ... DONE
[11:01:21.801] Resolving globals: FALSE
[11:01:21.801] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:21.802] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:21.802] - globals: [1] ‘a’
[11:01:21.802] 
[11:01:21.802] getGlobalsAndPackages() ... DONE
[11:01:21.802] run() for ‘Future’ ...
[11:01:21.802] - state: ‘created’
[11:01:21.802] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:21.816] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:21.816] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:21.816]   - Field: ‘node’
[11:01:21.816]   - Field: ‘label’
[11:01:21.816]   - Field: ‘local’
[11:01:21.817]   - Field: ‘owner’
[11:01:21.817]   - Field: ‘envir’
[11:01:21.817]   - Field: ‘workers’
[11:01:21.817]   - Field: ‘packages’
[11:01:21.817]   - Field: ‘gc’
[11:01:21.817]   - Field: ‘conditions’
[11:01:21.817]   - Field: ‘persistent’
[11:01:21.817]   - Field: ‘expr’
[11:01:21.817]   - Field: ‘uuid’
[11:01:21.817]   - Field: ‘seed’
[11:01:21.817]   - Field: ‘version’
[11:01:21.817]   - Field: ‘result’
[11:01:21.818]   - Field: ‘asynchronous’
[11:01:21.818]   - Field: ‘calls’
[11:01:21.818]   - Field: ‘globals’
[11:01:21.818]   - Field: ‘stdout’
[11:01:21.818]   - Field: ‘earlySignal’
[11:01:21.818]   - Field: ‘lazy’
[11:01:21.818]   - Field: ‘state’
[11:01:21.818] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:21.818] - Launch lazy future ...
[11:01:21.818] Packages needed by the future expression (n = 0): <none>
[11:01:21.819] Packages needed by future strategies (n = 0): <none>
[11:01:21.819] {
[11:01:21.819]     {
[11:01:21.819]         {
[11:01:21.819]             ...future.startTime <- base::Sys.time()
[11:01:21.819]             {
[11:01:21.819]                 {
[11:01:21.819]                   {
[11:01:21.819]                     {
[11:01:21.819]                       base::local({
[11:01:21.819]                         has_future <- base::requireNamespace("future", 
[11:01:21.819]                           quietly = TRUE)
[11:01:21.819]                         if (has_future) {
[11:01:21.819]                           ns <- base::getNamespace("future")
[11:01:21.819]                           version <- ns[[".package"]][["version"]]
[11:01:21.819]                           if (is.null(version)) 
[11:01:21.819]                             version <- utils::packageVersion("future")
[11:01:21.819]                         }
[11:01:21.819]                         else {
[11:01:21.819]                           version <- NULL
[11:01:21.819]                         }
[11:01:21.819]                         if (!has_future || version < "1.8.0") {
[11:01:21.819]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:21.819]                             "", base::R.version$version.string), 
[11:01:21.819]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:21.819]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:21.819]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:21.819]                               "release", "version")], collapse = " "), 
[11:01:21.819]                             hostname = base::Sys.info()[["nodename"]])
[11:01:21.819]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:21.819]                             info)
[11:01:21.819]                           info <- base::paste(info, collapse = "; ")
[11:01:21.819]                           if (!has_future) {
[11:01:21.819]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:21.819]                               info)
[11:01:21.819]                           }
[11:01:21.819]                           else {
[11:01:21.819]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:21.819]                               info, version)
[11:01:21.819]                           }
[11:01:21.819]                           base::stop(msg)
[11:01:21.819]                         }
[11:01:21.819]                       })
[11:01:21.819]                     }
[11:01:21.819]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:21.819]                     base::options(mc.cores = 1L)
[11:01:21.819]                   }
[11:01:21.819]                   ...future.strategy.old <- future::plan("list")
[11:01:21.819]                   options(future.plan = NULL)
[11:01:21.819]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.819]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:21.819]                 }
[11:01:21.819]                 ...future.workdir <- getwd()
[11:01:21.819]             }
[11:01:21.819]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:21.819]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:21.819]         }
[11:01:21.819]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:21.819]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:21.819]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:21.819]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:21.819]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:21.819]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:21.819]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:21.819]             base::names(...future.oldOptions))
[11:01:21.819]     }
[11:01:21.819]     if (FALSE) {
[11:01:21.819]     }
[11:01:21.819]     else {
[11:01:21.819]         if (TRUE) {
[11:01:21.819]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:21.819]                 open = "w")
[11:01:21.819]         }
[11:01:21.819]         else {
[11:01:21.819]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:21.819]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:21.819]         }
[11:01:21.819]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:21.819]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:21.819]             base::sink(type = "output", split = FALSE)
[11:01:21.819]             base::close(...future.stdout)
[11:01:21.819]         }, add = TRUE)
[11:01:21.819]     }
[11:01:21.819]     ...future.frame <- base::sys.nframe()
[11:01:21.819]     ...future.conditions <- base::list()
[11:01:21.819]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:21.819]     if (FALSE) {
[11:01:21.819]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:21.819]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:21.819]     }
[11:01:21.819]     ...future.result <- base::tryCatch({
[11:01:21.819]         base::withCallingHandlers({
[11:01:21.819]             ...future.value <- base::withVisible(base::local({
[11:01:21.819]                 ...future.makeSendCondition <- base::local({
[11:01:21.819]                   sendCondition <- NULL
[11:01:21.819]                   function(frame = 1L) {
[11:01:21.819]                     if (is.function(sendCondition)) 
[11:01:21.819]                       return(sendCondition)
[11:01:21.819]                     ns <- getNamespace("parallel")
[11:01:21.819]                     if (exists("sendData", mode = "function", 
[11:01:21.819]                       envir = ns)) {
[11:01:21.819]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:21.819]                         envir = ns)
[11:01:21.819]                       envir <- sys.frame(frame)
[11:01:21.819]                       master <- NULL
[11:01:21.819]                       while (!identical(envir, .GlobalEnv) && 
[11:01:21.819]                         !identical(envir, emptyenv())) {
[11:01:21.819]                         if (exists("master", mode = "list", envir = envir, 
[11:01:21.819]                           inherits = FALSE)) {
[11:01:21.819]                           master <- get("master", mode = "list", 
[11:01:21.819]                             envir = envir, inherits = FALSE)
[11:01:21.819]                           if (inherits(master, c("SOCKnode", 
[11:01:21.819]                             "SOCK0node"))) {
[11:01:21.819]                             sendCondition <<- function(cond) {
[11:01:21.819]                               data <- list(type = "VALUE", value = cond, 
[11:01:21.819]                                 success = TRUE)
[11:01:21.819]                               parallel_sendData(master, data)
[11:01:21.819]                             }
[11:01:21.819]                             return(sendCondition)
[11:01:21.819]                           }
[11:01:21.819]                         }
[11:01:21.819]                         frame <- frame + 1L
[11:01:21.819]                         envir <- sys.frame(frame)
[11:01:21.819]                       }
[11:01:21.819]                     }
[11:01:21.819]                     sendCondition <<- function(cond) NULL
[11:01:21.819]                   }
[11:01:21.819]                 })
[11:01:21.819]                 withCallingHandlers({
[11:01:21.819]                   {
[11:01:21.819]                     a + 1
[11:01:21.819]                   }
[11:01:21.819]                 }, immediateCondition = function(cond) {
[11:01:21.819]                   sendCondition <- ...future.makeSendCondition()
[11:01:21.819]                   sendCondition(cond)
[11:01:21.819]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.819]                   {
[11:01:21.819]                     inherits <- base::inherits
[11:01:21.819]                     invokeRestart <- base::invokeRestart
[11:01:21.819]                     is.null <- base::is.null
[11:01:21.819]                     muffled <- FALSE
[11:01:21.819]                     if (inherits(cond, "message")) {
[11:01:21.819]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:21.819]                       if (muffled) 
[11:01:21.819]                         invokeRestart("muffleMessage")
[11:01:21.819]                     }
[11:01:21.819]                     else if (inherits(cond, "warning")) {
[11:01:21.819]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:21.819]                       if (muffled) 
[11:01:21.819]                         invokeRestart("muffleWarning")
[11:01:21.819]                     }
[11:01:21.819]                     else if (inherits(cond, "condition")) {
[11:01:21.819]                       if (!is.null(pattern)) {
[11:01:21.819]                         computeRestarts <- base::computeRestarts
[11:01:21.819]                         grepl <- base::grepl
[11:01:21.819]                         restarts <- computeRestarts(cond)
[11:01:21.819]                         for (restart in restarts) {
[11:01:21.819]                           name <- restart$name
[11:01:21.819]                           if (is.null(name)) 
[11:01:21.819]                             next
[11:01:21.819]                           if (!grepl(pattern, name)) 
[11:01:21.819]                             next
[11:01:21.819]                           invokeRestart(restart)
[11:01:21.819]                           muffled <- TRUE
[11:01:21.819]                           break
[11:01:21.819]                         }
[11:01:21.819]                       }
[11:01:21.819]                     }
[11:01:21.819]                     invisible(muffled)
[11:01:21.819]                   }
[11:01:21.819]                   muffleCondition(cond)
[11:01:21.819]                 })
[11:01:21.819]             }))
[11:01:21.819]             future::FutureResult(value = ...future.value$value, 
[11:01:21.819]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.819]                   ...future.rng), globalenv = if (FALSE) 
[11:01:21.819]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:21.819]                     ...future.globalenv.names))
[11:01:21.819]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:21.819]         }, condition = base::local({
[11:01:21.819]             c <- base::c
[11:01:21.819]             inherits <- base::inherits
[11:01:21.819]             invokeRestart <- base::invokeRestart
[11:01:21.819]             length <- base::length
[11:01:21.819]             list <- base::list
[11:01:21.819]             seq.int <- base::seq.int
[11:01:21.819]             signalCondition <- base::signalCondition
[11:01:21.819]             sys.calls <- base::sys.calls
[11:01:21.819]             `[[` <- base::`[[`
[11:01:21.819]             `+` <- base::`+`
[11:01:21.819]             `<<-` <- base::`<<-`
[11:01:21.819]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:21.819]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:21.819]                   3L)]
[11:01:21.819]             }
[11:01:21.819]             function(cond) {
[11:01:21.819]                 is_error <- inherits(cond, "error")
[11:01:21.819]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:21.819]                   NULL)
[11:01:21.819]                 if (is_error) {
[11:01:21.819]                   sessionInformation <- function() {
[11:01:21.819]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:21.819]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:21.819]                       search = base::search(), system = base::Sys.info())
[11:01:21.819]                   }
[11:01:21.819]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.819]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:21.819]                     cond$call), session = sessionInformation(), 
[11:01:21.819]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:21.819]                   signalCondition(cond)
[11:01:21.819]                 }
[11:01:21.819]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:21.819]                 "immediateCondition"))) {
[11:01:21.819]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:21.819]                   ...future.conditions[[length(...future.conditions) + 
[11:01:21.819]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:21.819]                   if (TRUE && !signal) {
[11:01:21.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.819]                     {
[11:01:21.819]                       inherits <- base::inherits
[11:01:21.819]                       invokeRestart <- base::invokeRestart
[11:01:21.819]                       is.null <- base::is.null
[11:01:21.819]                       muffled <- FALSE
[11:01:21.819]                       if (inherits(cond, "message")) {
[11:01:21.819]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.819]                         if (muffled) 
[11:01:21.819]                           invokeRestart("muffleMessage")
[11:01:21.819]                       }
[11:01:21.819]                       else if (inherits(cond, "warning")) {
[11:01:21.819]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.819]                         if (muffled) 
[11:01:21.819]                           invokeRestart("muffleWarning")
[11:01:21.819]                       }
[11:01:21.819]                       else if (inherits(cond, "condition")) {
[11:01:21.819]                         if (!is.null(pattern)) {
[11:01:21.819]                           computeRestarts <- base::computeRestarts
[11:01:21.819]                           grepl <- base::grepl
[11:01:21.819]                           restarts <- computeRestarts(cond)
[11:01:21.819]                           for (restart in restarts) {
[11:01:21.819]                             name <- restart$name
[11:01:21.819]                             if (is.null(name)) 
[11:01:21.819]                               next
[11:01:21.819]                             if (!grepl(pattern, name)) 
[11:01:21.819]                               next
[11:01:21.819]                             invokeRestart(restart)
[11:01:21.819]                             muffled <- TRUE
[11:01:21.819]                             break
[11:01:21.819]                           }
[11:01:21.819]                         }
[11:01:21.819]                       }
[11:01:21.819]                       invisible(muffled)
[11:01:21.819]                     }
[11:01:21.819]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.819]                   }
[11:01:21.819]                 }
[11:01:21.819]                 else {
[11:01:21.819]                   if (TRUE) {
[11:01:21.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:21.819]                     {
[11:01:21.819]                       inherits <- base::inherits
[11:01:21.819]                       invokeRestart <- base::invokeRestart
[11:01:21.819]                       is.null <- base::is.null
[11:01:21.819]                       muffled <- FALSE
[11:01:21.819]                       if (inherits(cond, "message")) {
[11:01:21.819]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:21.819]                         if (muffled) 
[11:01:21.819]                           invokeRestart("muffleMessage")
[11:01:21.819]                       }
[11:01:21.819]                       else if (inherits(cond, "warning")) {
[11:01:21.819]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:21.819]                         if (muffled) 
[11:01:21.819]                           invokeRestart("muffleWarning")
[11:01:21.819]                       }
[11:01:21.819]                       else if (inherits(cond, "condition")) {
[11:01:21.819]                         if (!is.null(pattern)) {
[11:01:21.819]                           computeRestarts <- base::computeRestarts
[11:01:21.819]                           grepl <- base::grepl
[11:01:21.819]                           restarts <- computeRestarts(cond)
[11:01:21.819]                           for (restart in restarts) {
[11:01:21.819]                             name <- restart$name
[11:01:21.819]                             if (is.null(name)) 
[11:01:21.819]                               next
[11:01:21.819]                             if (!grepl(pattern, name)) 
[11:01:21.819]                               next
[11:01:21.819]                             invokeRestart(restart)
[11:01:21.819]                             muffled <- TRUE
[11:01:21.819]                             break
[11:01:21.819]                           }
[11:01:21.819]                         }
[11:01:21.819]                       }
[11:01:21.819]                       invisible(muffled)
[11:01:21.819]                     }
[11:01:21.819]                     muffleCondition(cond, pattern = "^muffle")
[11:01:21.819]                   }
[11:01:21.819]                 }
[11:01:21.819]             }
[11:01:21.819]         }))
[11:01:21.819]     }, error = function(ex) {
[11:01:21.819]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:21.819]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:21.819]                 ...future.rng), started = ...future.startTime, 
[11:01:21.819]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:21.819]             version = "1.8"), class = "FutureResult")
[11:01:21.819]     }, finally = {
[11:01:21.819]         if (!identical(...future.workdir, getwd())) 
[11:01:21.819]             setwd(...future.workdir)
[11:01:21.819]         {
[11:01:21.819]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:21.819]                 ...future.oldOptions$nwarnings <- NULL
[11:01:21.819]             }
[11:01:21.819]             base::options(...future.oldOptions)
[11:01:21.819]             if (.Platform$OS.type == "windows") {
[11:01:21.819]                 old_names <- names(...future.oldEnvVars)
[11:01:21.819]                 envs <- base::Sys.getenv()
[11:01:21.819]                 names <- names(envs)
[11:01:21.819]                 common <- intersect(names, old_names)
[11:01:21.819]                 added <- setdiff(names, old_names)
[11:01:21.819]                 removed <- setdiff(old_names, names)
[11:01:21.819]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:21.819]                   envs[common]]
[11:01:21.819]                 NAMES <- toupper(changed)
[11:01:21.819]                 args <- list()
[11:01:21.819]                 for (kk in seq_along(NAMES)) {
[11:01:21.819]                   name <- changed[[kk]]
[11:01:21.819]                   NAME <- NAMES[[kk]]
[11:01:21.819]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.819]                     next
[11:01:21.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.819]                 }
[11:01:21.819]                 NAMES <- toupper(added)
[11:01:21.819]                 for (kk in seq_along(NAMES)) {
[11:01:21.819]                   name <- added[[kk]]
[11:01:21.819]                   NAME <- NAMES[[kk]]
[11:01:21.819]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.819]                     next
[11:01:21.819]                   args[[name]] <- ""
[11:01:21.819]                 }
[11:01:21.819]                 NAMES <- toupper(removed)
[11:01:21.819]                 for (kk in seq_along(NAMES)) {
[11:01:21.819]                   name <- removed[[kk]]
[11:01:21.819]                   NAME <- NAMES[[kk]]
[11:01:21.819]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:21.819]                     next
[11:01:21.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:21.819]                 }
[11:01:21.819]                 if (length(args) > 0) 
[11:01:21.819]                   base::do.call(base::Sys.setenv, args = args)
[11:01:21.819]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:21.819]             }
[11:01:21.819]             else {
[11:01:21.819]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:21.819]             }
[11:01:21.819]             {
[11:01:21.819]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:21.819]                   0L) {
[11:01:21.819]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:21.819]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:21.819]                   base::options(opts)
[11:01:21.819]                 }
[11:01:21.819]                 {
[11:01:21.819]                   {
[11:01:21.819]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:21.819]                     NULL
[11:01:21.819]                   }
[11:01:21.819]                   options(future.plan = NULL)
[11:01:21.819]                   if (is.na(NA_character_)) 
[11:01:21.819]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:21.819]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:21.819]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:21.819]                     .init = FALSE)
[11:01:21.819]                 }
[11:01:21.819]             }
[11:01:21.819]         }
[11:01:21.819]     })
[11:01:21.819]     if (TRUE) {
[11:01:21.819]         base::sink(type = "output", split = FALSE)
[11:01:21.819]         if (TRUE) {
[11:01:21.819]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:21.819]         }
[11:01:21.819]         else {
[11:01:21.819]             ...future.result["stdout"] <- base::list(NULL)
[11:01:21.819]         }
[11:01:21.819]         base::close(...future.stdout)
[11:01:21.819]         ...future.stdout <- NULL
[11:01:21.819]     }
[11:01:21.819]     ...future.result$conditions <- ...future.conditions
[11:01:21.819]     ...future.result$finished <- base::Sys.time()
[11:01:21.819]     ...future.result
[11:01:21.819] }
[11:01:21.821] Exporting 1 global objects (346 bytes) to cluster node #1 ...
[11:01:21.822] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[11:01:21.822] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[11:01:21.822] Exporting 1 global objects (346 bytes) to cluster node #1 ... DONE
[11:01:21.823] MultisessionFuture started
[11:01:21.823] - Launch lazy future ... done
[11:01:21.823] run() for ‘MultisessionFuture’ ... done
[11:01:21.823] result() for ClusterFuture ...
[11:01:21.823] receiveMessageFromWorker() for ClusterFuture ...
[11:01:21.823] - Validating connection of MultisessionFuture
[11:01:21.865] - received message: FutureResult
[11:01:21.865] - Received FutureResult
[11:01:21.865] - Erased future from FutureRegistry
[11:01:21.865] result() for ClusterFuture ...
[11:01:21.865] - result already collected: FutureResult
[11:01:21.865] result() for ClusterFuture ... done
[11:01:21.865] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:21.866] result() for ClusterFuture ... done
[11:01:21.866] result() for ClusterFuture ...
[11:01:21.866] - result already collected: FutureResult
[11:01:21.866] result() for ClusterFuture ... done
b = 11
*** %<-% with ‘multisession’ futures ... DONE
Testing with 2 cores ... DONE
> 
> message("*** %<-% ... DONE")
*** %<-% ... DONE
> 
> source("incl/end.R")
[11:01:21.867] plan(): Setting new future strategy stack:
[11:01:21.867] List of future strategies:
[11:01:21.867] 1. FutureStrategy:
[11:01:21.867]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:21.867]    - tweaked: FALSE
[11:01:21.867]    - call: future::plan(oplan)
[11:01:21.867] plan(): nbrOfWorkers() = 1
> 
