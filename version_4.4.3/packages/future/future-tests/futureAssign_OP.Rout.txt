
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[08:27:41.034] plan(): Setting new future strategy stack:
[08:27:41.034] List of future strategies:
[08:27:41.034] 1. sequential:
[08:27:41.034]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.034]    - tweaked: FALSE
[08:27:41.034]    - call: future::plan("sequential")
[08:27:41.048] plan(): nbrOfWorkers() = 1
> 
> message("*** %<-% ...")
*** %<-% ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("*** %%<-%% with %s futures ...", sQuote(strategy)))
+     plan(strategy)
+ 
+     rm(list = intersect(c("x", "y"), ls()))
+ 
+     message("** Future evaluation without globals")
+     v1 %<-% { x <- 1 }
+     stopifnot(!exists("x", inherits = FALSE), identical(v1, 1))
+ 
+     message("** Future evaluation with globals")
+     a <- 2
+     v2 %<-% { x <- a }
+     stopifnot(!exists("x", inherits = FALSE), identical(v2, a))
+ 
+     message("** Future evaluation with errors")
+     v3 %<-% {
+       x <- 3
+       stop("Woops!")
+       x
+     }
+     stopifnot(!exists("x", inherits = FALSE))
+     res <- tryCatch(identical(v3, 3), error = identity)
+     stopifnot(inherits(res, "error"))
+ 
+ 
+     y <- listenv::listenv()
+     for (ii in 1:3) {
+       y[[ii]] %<-% {
+         if (ii %% 2 == 0) stop("Woops!")
+         ii
+       }
+     }
+     res <- tryCatch(as.list(y), error = identity)
+     stopifnot(inherits(res, "error"))
+     z <- y[c(1, 3)]
+     z <- unlist(z)
+     stopifnot(all(z == c(1, 3)))
+     res <- tryCatch(y[[2]], error = identity)
+     stopifnot(inherits(res, "error"))
+     res <- tryCatch(y[1:2], error = identity)
+     stopifnot(inherits(res, "error"))
+ 
+ 
+     message("** Future evaluation with a poor-man's \"progress bar\"")
+     v4 %<-% {
+       cat("Processing: ")
+       for (ii in 1:10) { cat(".") }
+       cat(" [100%]\n")
+       4
+     }
+ 
+ 
+     message("** Collecting results")
+     printf("v1 = %s\n", v1)
+     stopifnot(v1 == 1)
+ 
+     printf("v2 = %s\n", v2)
+     stopifnot(v2 == a)
+ 
+     stopifnot(tryCatch({
+       printf("v3 = %s\n", v3)
+     }, error = function(ex) {
+       printf("v3: <%s> (as expect)\n", class(ex)[1])
+       TRUE
+     }))
+ 
+     printf("v4 = %s\n", v4)
+     #stopifnot(v4 == 4)
+ 
+ 
+     message("** Left-to-right and right-to-left future assignments")
+     c %<-% 1
+     printf("c = %s\n", c)
+     1 %->% d
+     printf("d = %s\n", d)
+     stopifnot(d == c)
+ 
+ 
+ 
+     message("** Nested future assignments")
+     a %<-% {
+       b <- 1
+       c %<-% 2
+       3 -> d
+       4 %->% e
+       b + c + d + e
+     }
+     printf("a = %s\n", a)
+     stopifnot(a == 10)
+ 
+     { a + 1 } %->% b
+     printf("b = %s\n", b)
+     stopifnot(b == a + 1)
+ 
+     message(sprintf("*** %%<-%% with %s futures ... DONE", sQuote(strategy)))
+   } # for (strategy in ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** %<-% with ‘sequential’ futures ...
[08:27:41.109] plan(): Setting new future strategy stack:
[08:27:41.109] List of future strategies:
[08:27:41.109] 1. sequential:
[08:27:41.109]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.109]    - tweaked: FALSE
[08:27:41.109]    - call: plan(strategy)
[08:27:41.122] plan(): nbrOfWorkers() = 1
** Future evaluation without globals
[08:27:41.124] getGlobalsAndPackages() ...
[08:27:41.124] Searching for globals...
[08:27:41.128] - globals found: [2] ‘{’, ‘<-’
[08:27:41.128] Searching for globals ... DONE
[08:27:41.128] Resolving globals: FALSE
[08:27:41.129] 
[08:27:41.129] 
[08:27:41.129] getGlobalsAndPackages() ... DONE
[08:27:41.130] run() for ‘Future’ ...
[08:27:41.130] - state: ‘created’
[08:27:41.130] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:41.130] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:41.130] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:41.130]   - Field: ‘label’
[08:27:41.130]   - Field: ‘local’
[08:27:41.131]   - Field: ‘owner’
[08:27:41.131]   - Field: ‘envir’
[08:27:41.131]   - Field: ‘packages’
[08:27:41.131]   - Field: ‘gc’
[08:27:41.131]   - Field: ‘conditions’
[08:27:41.131]   - Field: ‘expr’
[08:27:41.131]   - Field: ‘uuid’
[08:27:41.131]   - Field: ‘seed’
[08:27:41.131]   - Field: ‘version’
[08:27:41.131]   - Field: ‘result’
[08:27:41.131]   - Field: ‘asynchronous’
[08:27:41.131]   - Field: ‘calls’
[08:27:41.132]   - Field: ‘globals’
[08:27:41.132]   - Field: ‘stdout’
[08:27:41.132]   - Field: ‘earlySignal’
[08:27:41.132]   - Field: ‘lazy’
[08:27:41.132]   - Field: ‘state’
[08:27:41.132] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:41.132] - Launch lazy future ...
[08:27:41.133] Packages needed by the future expression (n = 0): <none>
[08:27:41.133] Packages needed by future strategies (n = 0): <none>
[08:27:41.133] {
[08:27:41.133]     {
[08:27:41.133]         {
[08:27:41.133]             ...future.startTime <- base::Sys.time()
[08:27:41.133]             {
[08:27:41.133]                 {
[08:27:41.133]                   {
[08:27:41.133]                     base::local({
[08:27:41.133]                       has_future <- base::requireNamespace("future", 
[08:27:41.133]                         quietly = TRUE)
[08:27:41.133]                       if (has_future) {
[08:27:41.133]                         ns <- base::getNamespace("future")
[08:27:41.133]                         version <- ns[[".package"]][["version"]]
[08:27:41.133]                         if (is.null(version)) 
[08:27:41.133]                           version <- utils::packageVersion("future")
[08:27:41.133]                       }
[08:27:41.133]                       else {
[08:27:41.133]                         version <- NULL
[08:27:41.133]                       }
[08:27:41.133]                       if (!has_future || version < "1.8.0") {
[08:27:41.133]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.133]                           "", base::R.version$version.string), 
[08:27:41.133]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:41.133]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.133]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.133]                             "release", "version")], collapse = " "), 
[08:27:41.133]                           hostname = base::Sys.info()[["nodename"]])
[08:27:41.133]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.133]                           info)
[08:27:41.133]                         info <- base::paste(info, collapse = "; ")
[08:27:41.133]                         if (!has_future) {
[08:27:41.133]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.133]                             info)
[08:27:41.133]                         }
[08:27:41.133]                         else {
[08:27:41.133]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.133]                             info, version)
[08:27:41.133]                         }
[08:27:41.133]                         base::stop(msg)
[08:27:41.133]                       }
[08:27:41.133]                     })
[08:27:41.133]                   }
[08:27:41.133]                   ...future.strategy.old <- future::plan("list")
[08:27:41.133]                   options(future.plan = NULL)
[08:27:41.133]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.133]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.133]                 }
[08:27:41.133]                 ...future.workdir <- getwd()
[08:27:41.133]             }
[08:27:41.133]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.133]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.133]         }
[08:27:41.133]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.133]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.133]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.133]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.133]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.133]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.133]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.133]             base::names(...future.oldOptions))
[08:27:41.133]     }
[08:27:41.133]     if (FALSE) {
[08:27:41.133]     }
[08:27:41.133]     else {
[08:27:41.133]         if (TRUE) {
[08:27:41.133]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.133]                 open = "w")
[08:27:41.133]         }
[08:27:41.133]         else {
[08:27:41.133]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.133]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.133]         }
[08:27:41.133]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.133]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.133]             base::sink(type = "output", split = FALSE)
[08:27:41.133]             base::close(...future.stdout)
[08:27:41.133]         }, add = TRUE)
[08:27:41.133]     }
[08:27:41.133]     ...future.frame <- base::sys.nframe()
[08:27:41.133]     ...future.conditions <- base::list()
[08:27:41.133]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.133]     if (FALSE) {
[08:27:41.133]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.133]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.133]     }
[08:27:41.133]     ...future.result <- base::tryCatch({
[08:27:41.133]         base::withCallingHandlers({
[08:27:41.133]             ...future.value <- base::withVisible(base::local({
[08:27:41.133]                 x <- 1
[08:27:41.133]             }))
[08:27:41.133]             future::FutureResult(value = ...future.value$value, 
[08:27:41.133]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.133]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.133]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.133]                     ...future.globalenv.names))
[08:27:41.133]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.133]         }, condition = base::local({
[08:27:41.133]             c <- base::c
[08:27:41.133]             inherits <- base::inherits
[08:27:41.133]             invokeRestart <- base::invokeRestart
[08:27:41.133]             length <- base::length
[08:27:41.133]             list <- base::list
[08:27:41.133]             seq.int <- base::seq.int
[08:27:41.133]             signalCondition <- base::signalCondition
[08:27:41.133]             sys.calls <- base::sys.calls
[08:27:41.133]             `[[` <- base::`[[`
[08:27:41.133]             `+` <- base::`+`
[08:27:41.133]             `<<-` <- base::`<<-`
[08:27:41.133]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.133]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.133]                   3L)]
[08:27:41.133]             }
[08:27:41.133]             function(cond) {
[08:27:41.133]                 is_error <- inherits(cond, "error")
[08:27:41.133]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.133]                   NULL)
[08:27:41.133]                 if (is_error) {
[08:27:41.133]                   sessionInformation <- function() {
[08:27:41.133]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.133]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.133]                       search = base::search(), system = base::Sys.info())
[08:27:41.133]                   }
[08:27:41.133]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.133]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.133]                     cond$call), session = sessionInformation(), 
[08:27:41.133]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.133]                   signalCondition(cond)
[08:27:41.133]                 }
[08:27:41.133]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.133]                 "immediateCondition"))) {
[08:27:41.133]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.133]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.133]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.133]                   if (TRUE && !signal) {
[08:27:41.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.133]                     {
[08:27:41.133]                       inherits <- base::inherits
[08:27:41.133]                       invokeRestart <- base::invokeRestart
[08:27:41.133]                       is.null <- base::is.null
[08:27:41.133]                       muffled <- FALSE
[08:27:41.133]                       if (inherits(cond, "message")) {
[08:27:41.133]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.133]                         if (muffled) 
[08:27:41.133]                           invokeRestart("muffleMessage")
[08:27:41.133]                       }
[08:27:41.133]                       else if (inherits(cond, "warning")) {
[08:27:41.133]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.133]                         if (muffled) 
[08:27:41.133]                           invokeRestart("muffleWarning")
[08:27:41.133]                       }
[08:27:41.133]                       else if (inherits(cond, "condition")) {
[08:27:41.133]                         if (!is.null(pattern)) {
[08:27:41.133]                           computeRestarts <- base::computeRestarts
[08:27:41.133]                           grepl <- base::grepl
[08:27:41.133]                           restarts <- computeRestarts(cond)
[08:27:41.133]                           for (restart in restarts) {
[08:27:41.133]                             name <- restart$name
[08:27:41.133]                             if (is.null(name)) 
[08:27:41.133]                               next
[08:27:41.133]                             if (!grepl(pattern, name)) 
[08:27:41.133]                               next
[08:27:41.133]                             invokeRestart(restart)
[08:27:41.133]                             muffled <- TRUE
[08:27:41.133]                             break
[08:27:41.133]                           }
[08:27:41.133]                         }
[08:27:41.133]                       }
[08:27:41.133]                       invisible(muffled)
[08:27:41.133]                     }
[08:27:41.133]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.133]                   }
[08:27:41.133]                 }
[08:27:41.133]                 else {
[08:27:41.133]                   if (TRUE) {
[08:27:41.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.133]                     {
[08:27:41.133]                       inherits <- base::inherits
[08:27:41.133]                       invokeRestart <- base::invokeRestart
[08:27:41.133]                       is.null <- base::is.null
[08:27:41.133]                       muffled <- FALSE
[08:27:41.133]                       if (inherits(cond, "message")) {
[08:27:41.133]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.133]                         if (muffled) 
[08:27:41.133]                           invokeRestart("muffleMessage")
[08:27:41.133]                       }
[08:27:41.133]                       else if (inherits(cond, "warning")) {
[08:27:41.133]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.133]                         if (muffled) 
[08:27:41.133]                           invokeRestart("muffleWarning")
[08:27:41.133]                       }
[08:27:41.133]                       else if (inherits(cond, "condition")) {
[08:27:41.133]                         if (!is.null(pattern)) {
[08:27:41.133]                           computeRestarts <- base::computeRestarts
[08:27:41.133]                           grepl <- base::grepl
[08:27:41.133]                           restarts <- computeRestarts(cond)
[08:27:41.133]                           for (restart in restarts) {
[08:27:41.133]                             name <- restart$name
[08:27:41.133]                             if (is.null(name)) 
[08:27:41.133]                               next
[08:27:41.133]                             if (!grepl(pattern, name)) 
[08:27:41.133]                               next
[08:27:41.133]                             invokeRestart(restart)
[08:27:41.133]                             muffled <- TRUE
[08:27:41.133]                             break
[08:27:41.133]                           }
[08:27:41.133]                         }
[08:27:41.133]                       }
[08:27:41.133]                       invisible(muffled)
[08:27:41.133]                     }
[08:27:41.133]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.133]                   }
[08:27:41.133]                 }
[08:27:41.133]             }
[08:27:41.133]         }))
[08:27:41.133]     }, error = function(ex) {
[08:27:41.133]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.133]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.133]                 ...future.rng), started = ...future.startTime, 
[08:27:41.133]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.133]             version = "1.8"), class = "FutureResult")
[08:27:41.133]     }, finally = {
[08:27:41.133]         if (!identical(...future.workdir, getwd())) 
[08:27:41.133]             setwd(...future.workdir)
[08:27:41.133]         {
[08:27:41.133]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.133]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.133]             }
[08:27:41.133]             base::options(...future.oldOptions)
[08:27:41.133]             if (.Platform$OS.type == "windows") {
[08:27:41.133]                 old_names <- names(...future.oldEnvVars)
[08:27:41.133]                 envs <- base::Sys.getenv()
[08:27:41.133]                 names <- names(envs)
[08:27:41.133]                 common <- intersect(names, old_names)
[08:27:41.133]                 added <- setdiff(names, old_names)
[08:27:41.133]                 removed <- setdiff(old_names, names)
[08:27:41.133]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.133]                   envs[common]]
[08:27:41.133]                 NAMES <- toupper(changed)
[08:27:41.133]                 args <- list()
[08:27:41.133]                 for (kk in seq_along(NAMES)) {
[08:27:41.133]                   name <- changed[[kk]]
[08:27:41.133]                   NAME <- NAMES[[kk]]
[08:27:41.133]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.133]                     next
[08:27:41.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.133]                 }
[08:27:41.133]                 NAMES <- toupper(added)
[08:27:41.133]                 for (kk in seq_along(NAMES)) {
[08:27:41.133]                   name <- added[[kk]]
[08:27:41.133]                   NAME <- NAMES[[kk]]
[08:27:41.133]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.133]                     next
[08:27:41.133]                   args[[name]] <- ""
[08:27:41.133]                 }
[08:27:41.133]                 NAMES <- toupper(removed)
[08:27:41.133]                 for (kk in seq_along(NAMES)) {
[08:27:41.133]                   name <- removed[[kk]]
[08:27:41.133]                   NAME <- NAMES[[kk]]
[08:27:41.133]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.133]                     next
[08:27:41.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.133]                 }
[08:27:41.133]                 if (length(args) > 0) 
[08:27:41.133]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.133]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.133]             }
[08:27:41.133]             else {
[08:27:41.133]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.133]             }
[08:27:41.133]             {
[08:27:41.133]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.133]                   0L) {
[08:27:41.133]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.133]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.133]                   base::options(opts)
[08:27:41.133]                 }
[08:27:41.133]                 {
[08:27:41.133]                   {
[08:27:41.133]                     NULL
[08:27:41.133]                     RNGkind("Mersenne-Twister")
[08:27:41.133]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:41.133]                       inherits = FALSE)
[08:27:41.133]                   }
[08:27:41.133]                   options(future.plan = NULL)
[08:27:41.133]                   if (is.na(NA_character_)) 
[08:27:41.133]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.133]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.133]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.133]                     .init = FALSE)
[08:27:41.133]                 }
[08:27:41.133]             }
[08:27:41.133]         }
[08:27:41.133]     })
[08:27:41.133]     if (TRUE) {
[08:27:41.133]         base::sink(type = "output", split = FALSE)
[08:27:41.133]         if (TRUE) {
[08:27:41.133]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.133]         }
[08:27:41.133]         else {
[08:27:41.133]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.133]         }
[08:27:41.133]         base::close(...future.stdout)
[08:27:41.133]         ...future.stdout <- NULL
[08:27:41.133]     }
[08:27:41.133]     ...future.result$conditions <- ...future.conditions
[08:27:41.133]     ...future.result$finished <- base::Sys.time()
[08:27:41.133]     ...future.result
[08:27:41.133] }
[08:27:41.135] plan(): Setting new future strategy stack:
[08:27:41.136] List of future strategies:
[08:27:41.136] 1. sequential:
[08:27:41.136]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.136]    - tweaked: FALSE
[08:27:41.136]    - call: NULL
[08:27:41.136] plan(): nbrOfWorkers() = 1
[08:27:41.137] plan(): Setting new future strategy stack:
[08:27:41.137] List of future strategies:
[08:27:41.137] 1. sequential:
[08:27:41.137]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.137]    - tweaked: FALSE
[08:27:41.137]    - call: plan(strategy)
[08:27:41.138] plan(): nbrOfWorkers() = 1
[08:27:41.138] SequentialFuture started (and completed)
[08:27:41.138] - Launch lazy future ... done
[08:27:41.138] run() for ‘SequentialFuture’ ... done
** Future evaluation with globals
[08:27:41.139] getGlobalsAndPackages() ...
[08:27:41.139] Searching for globals...
[08:27:41.140] - globals found: [3] ‘{’, ‘<-’, ‘a’
[08:27:41.140] Searching for globals ... DONE
[08:27:41.140] Resolving globals: FALSE
[08:27:41.141] The total size of the 1 globals is 39 bytes (39 bytes)
[08:27:41.141] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[08:27:41.141] - globals: [1] ‘a’
[08:27:41.141] 
[08:27:41.141] getGlobalsAndPackages() ... DONE
[08:27:41.142] run() for ‘Future’ ...
[08:27:41.142] - state: ‘created’
[08:27:41.142] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:41.142] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:41.142] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:41.142]   - Field: ‘label’
[08:27:41.142]   - Field: ‘local’
[08:27:41.143]   - Field: ‘owner’
[08:27:41.143]   - Field: ‘envir’
[08:27:41.143]   - Field: ‘packages’
[08:27:41.143]   - Field: ‘gc’
[08:27:41.143]   - Field: ‘conditions’
[08:27:41.143]   - Field: ‘expr’
[08:27:41.143]   - Field: ‘uuid’
[08:27:41.143]   - Field: ‘seed’
[08:27:41.143]   - Field: ‘version’
[08:27:41.143]   - Field: ‘result’
[08:27:41.143]   - Field: ‘asynchronous’
[08:27:41.143]   - Field: ‘calls’
[08:27:41.144]   - Field: ‘globals’
[08:27:41.144]   - Field: ‘stdout’
[08:27:41.144]   - Field: ‘earlySignal’
[08:27:41.144]   - Field: ‘lazy’
[08:27:41.144]   - Field: ‘state’
[08:27:41.144] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:41.144] - Launch lazy future ...
[08:27:41.144] Packages needed by the future expression (n = 0): <none>
[08:27:41.144] Packages needed by future strategies (n = 0): <none>
[08:27:41.145] {
[08:27:41.145]     {
[08:27:41.145]         {
[08:27:41.145]             ...future.startTime <- base::Sys.time()
[08:27:41.145]             {
[08:27:41.145]                 {
[08:27:41.145]                   {
[08:27:41.145]                     base::local({
[08:27:41.145]                       has_future <- base::requireNamespace("future", 
[08:27:41.145]                         quietly = TRUE)
[08:27:41.145]                       if (has_future) {
[08:27:41.145]                         ns <- base::getNamespace("future")
[08:27:41.145]                         version <- ns[[".package"]][["version"]]
[08:27:41.145]                         if (is.null(version)) 
[08:27:41.145]                           version <- utils::packageVersion("future")
[08:27:41.145]                       }
[08:27:41.145]                       else {
[08:27:41.145]                         version <- NULL
[08:27:41.145]                       }
[08:27:41.145]                       if (!has_future || version < "1.8.0") {
[08:27:41.145]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.145]                           "", base::R.version$version.string), 
[08:27:41.145]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:41.145]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.145]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.145]                             "release", "version")], collapse = " "), 
[08:27:41.145]                           hostname = base::Sys.info()[["nodename"]])
[08:27:41.145]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.145]                           info)
[08:27:41.145]                         info <- base::paste(info, collapse = "; ")
[08:27:41.145]                         if (!has_future) {
[08:27:41.145]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.145]                             info)
[08:27:41.145]                         }
[08:27:41.145]                         else {
[08:27:41.145]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.145]                             info, version)
[08:27:41.145]                         }
[08:27:41.145]                         base::stop(msg)
[08:27:41.145]                       }
[08:27:41.145]                     })
[08:27:41.145]                   }
[08:27:41.145]                   ...future.strategy.old <- future::plan("list")
[08:27:41.145]                   options(future.plan = NULL)
[08:27:41.145]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.145]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.145]                 }
[08:27:41.145]                 ...future.workdir <- getwd()
[08:27:41.145]             }
[08:27:41.145]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.145]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.145]         }
[08:27:41.145]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.145]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.145]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.145]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.145]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.145]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.145]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.145]             base::names(...future.oldOptions))
[08:27:41.145]     }
[08:27:41.145]     if (FALSE) {
[08:27:41.145]     }
[08:27:41.145]     else {
[08:27:41.145]         if (TRUE) {
[08:27:41.145]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.145]                 open = "w")
[08:27:41.145]         }
[08:27:41.145]         else {
[08:27:41.145]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.145]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.145]         }
[08:27:41.145]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.145]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.145]             base::sink(type = "output", split = FALSE)
[08:27:41.145]             base::close(...future.stdout)
[08:27:41.145]         }, add = TRUE)
[08:27:41.145]     }
[08:27:41.145]     ...future.frame <- base::sys.nframe()
[08:27:41.145]     ...future.conditions <- base::list()
[08:27:41.145]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.145]     if (FALSE) {
[08:27:41.145]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.145]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.145]     }
[08:27:41.145]     ...future.result <- base::tryCatch({
[08:27:41.145]         base::withCallingHandlers({
[08:27:41.145]             ...future.value <- base::withVisible(base::local({
[08:27:41.145]                 x <- a
[08:27:41.145]             }))
[08:27:41.145]             future::FutureResult(value = ...future.value$value, 
[08:27:41.145]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.145]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.145]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.145]                     ...future.globalenv.names))
[08:27:41.145]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.145]         }, condition = base::local({
[08:27:41.145]             c <- base::c
[08:27:41.145]             inherits <- base::inherits
[08:27:41.145]             invokeRestart <- base::invokeRestart
[08:27:41.145]             length <- base::length
[08:27:41.145]             list <- base::list
[08:27:41.145]             seq.int <- base::seq.int
[08:27:41.145]             signalCondition <- base::signalCondition
[08:27:41.145]             sys.calls <- base::sys.calls
[08:27:41.145]             `[[` <- base::`[[`
[08:27:41.145]             `+` <- base::`+`
[08:27:41.145]             `<<-` <- base::`<<-`
[08:27:41.145]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.145]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.145]                   3L)]
[08:27:41.145]             }
[08:27:41.145]             function(cond) {
[08:27:41.145]                 is_error <- inherits(cond, "error")
[08:27:41.145]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.145]                   NULL)
[08:27:41.145]                 if (is_error) {
[08:27:41.145]                   sessionInformation <- function() {
[08:27:41.145]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.145]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.145]                       search = base::search(), system = base::Sys.info())
[08:27:41.145]                   }
[08:27:41.145]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.145]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.145]                     cond$call), session = sessionInformation(), 
[08:27:41.145]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.145]                   signalCondition(cond)
[08:27:41.145]                 }
[08:27:41.145]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.145]                 "immediateCondition"))) {
[08:27:41.145]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.145]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.145]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.145]                   if (TRUE && !signal) {
[08:27:41.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.145]                     {
[08:27:41.145]                       inherits <- base::inherits
[08:27:41.145]                       invokeRestart <- base::invokeRestart
[08:27:41.145]                       is.null <- base::is.null
[08:27:41.145]                       muffled <- FALSE
[08:27:41.145]                       if (inherits(cond, "message")) {
[08:27:41.145]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.145]                         if (muffled) 
[08:27:41.145]                           invokeRestart("muffleMessage")
[08:27:41.145]                       }
[08:27:41.145]                       else if (inherits(cond, "warning")) {
[08:27:41.145]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.145]                         if (muffled) 
[08:27:41.145]                           invokeRestart("muffleWarning")
[08:27:41.145]                       }
[08:27:41.145]                       else if (inherits(cond, "condition")) {
[08:27:41.145]                         if (!is.null(pattern)) {
[08:27:41.145]                           computeRestarts <- base::computeRestarts
[08:27:41.145]                           grepl <- base::grepl
[08:27:41.145]                           restarts <- computeRestarts(cond)
[08:27:41.145]                           for (restart in restarts) {
[08:27:41.145]                             name <- restart$name
[08:27:41.145]                             if (is.null(name)) 
[08:27:41.145]                               next
[08:27:41.145]                             if (!grepl(pattern, name)) 
[08:27:41.145]                               next
[08:27:41.145]                             invokeRestart(restart)
[08:27:41.145]                             muffled <- TRUE
[08:27:41.145]                             break
[08:27:41.145]                           }
[08:27:41.145]                         }
[08:27:41.145]                       }
[08:27:41.145]                       invisible(muffled)
[08:27:41.145]                     }
[08:27:41.145]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.145]                   }
[08:27:41.145]                 }
[08:27:41.145]                 else {
[08:27:41.145]                   if (TRUE) {
[08:27:41.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.145]                     {
[08:27:41.145]                       inherits <- base::inherits
[08:27:41.145]                       invokeRestart <- base::invokeRestart
[08:27:41.145]                       is.null <- base::is.null
[08:27:41.145]                       muffled <- FALSE
[08:27:41.145]                       if (inherits(cond, "message")) {
[08:27:41.145]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.145]                         if (muffled) 
[08:27:41.145]                           invokeRestart("muffleMessage")
[08:27:41.145]                       }
[08:27:41.145]                       else if (inherits(cond, "warning")) {
[08:27:41.145]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.145]                         if (muffled) 
[08:27:41.145]                           invokeRestart("muffleWarning")
[08:27:41.145]                       }
[08:27:41.145]                       else if (inherits(cond, "condition")) {
[08:27:41.145]                         if (!is.null(pattern)) {
[08:27:41.145]                           computeRestarts <- base::computeRestarts
[08:27:41.145]                           grepl <- base::grepl
[08:27:41.145]                           restarts <- computeRestarts(cond)
[08:27:41.145]                           for (restart in restarts) {
[08:27:41.145]                             name <- restart$name
[08:27:41.145]                             if (is.null(name)) 
[08:27:41.145]                               next
[08:27:41.145]                             if (!grepl(pattern, name)) 
[08:27:41.145]                               next
[08:27:41.145]                             invokeRestart(restart)
[08:27:41.145]                             muffled <- TRUE
[08:27:41.145]                             break
[08:27:41.145]                           }
[08:27:41.145]                         }
[08:27:41.145]                       }
[08:27:41.145]                       invisible(muffled)
[08:27:41.145]                     }
[08:27:41.145]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.145]                   }
[08:27:41.145]                 }
[08:27:41.145]             }
[08:27:41.145]         }))
[08:27:41.145]     }, error = function(ex) {
[08:27:41.145]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.145]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.145]                 ...future.rng), started = ...future.startTime, 
[08:27:41.145]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.145]             version = "1.8"), class = "FutureResult")
[08:27:41.145]     }, finally = {
[08:27:41.145]         if (!identical(...future.workdir, getwd())) 
[08:27:41.145]             setwd(...future.workdir)
[08:27:41.145]         {
[08:27:41.145]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.145]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.145]             }
[08:27:41.145]             base::options(...future.oldOptions)
[08:27:41.145]             if (.Platform$OS.type == "windows") {
[08:27:41.145]                 old_names <- names(...future.oldEnvVars)
[08:27:41.145]                 envs <- base::Sys.getenv()
[08:27:41.145]                 names <- names(envs)
[08:27:41.145]                 common <- intersect(names, old_names)
[08:27:41.145]                 added <- setdiff(names, old_names)
[08:27:41.145]                 removed <- setdiff(old_names, names)
[08:27:41.145]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.145]                   envs[common]]
[08:27:41.145]                 NAMES <- toupper(changed)
[08:27:41.145]                 args <- list()
[08:27:41.145]                 for (kk in seq_along(NAMES)) {
[08:27:41.145]                   name <- changed[[kk]]
[08:27:41.145]                   NAME <- NAMES[[kk]]
[08:27:41.145]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.145]                     next
[08:27:41.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.145]                 }
[08:27:41.145]                 NAMES <- toupper(added)
[08:27:41.145]                 for (kk in seq_along(NAMES)) {
[08:27:41.145]                   name <- added[[kk]]
[08:27:41.145]                   NAME <- NAMES[[kk]]
[08:27:41.145]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.145]                     next
[08:27:41.145]                   args[[name]] <- ""
[08:27:41.145]                 }
[08:27:41.145]                 NAMES <- toupper(removed)
[08:27:41.145]                 for (kk in seq_along(NAMES)) {
[08:27:41.145]                   name <- removed[[kk]]
[08:27:41.145]                   NAME <- NAMES[[kk]]
[08:27:41.145]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.145]                     next
[08:27:41.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.145]                 }
[08:27:41.145]                 if (length(args) > 0) 
[08:27:41.145]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.145]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.145]             }
[08:27:41.145]             else {
[08:27:41.145]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.145]             }
[08:27:41.145]             {
[08:27:41.145]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.145]                   0L) {
[08:27:41.145]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.145]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.145]                   base::options(opts)
[08:27:41.145]                 }
[08:27:41.145]                 {
[08:27:41.145]                   {
[08:27:41.145]                     NULL
[08:27:41.145]                     RNGkind("Mersenne-Twister")
[08:27:41.145]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:41.145]                       inherits = FALSE)
[08:27:41.145]                   }
[08:27:41.145]                   options(future.plan = NULL)
[08:27:41.145]                   if (is.na(NA_character_)) 
[08:27:41.145]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.145]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.145]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.145]                     .init = FALSE)
[08:27:41.145]                 }
[08:27:41.145]             }
[08:27:41.145]         }
[08:27:41.145]     })
[08:27:41.145]     if (TRUE) {
[08:27:41.145]         base::sink(type = "output", split = FALSE)
[08:27:41.145]         if (TRUE) {
[08:27:41.145]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.145]         }
[08:27:41.145]         else {
[08:27:41.145]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.145]         }
[08:27:41.145]         base::close(...future.stdout)
[08:27:41.145]         ...future.stdout <- NULL
[08:27:41.145]     }
[08:27:41.145]     ...future.result$conditions <- ...future.conditions
[08:27:41.145]     ...future.result$finished <- base::Sys.time()
[08:27:41.145]     ...future.result
[08:27:41.145] }
[08:27:41.146] assign_globals() ...
[08:27:41.147] List of 1
[08:27:41.147]  $ a: num 2
[08:27:41.147]  - attr(*, "where")=List of 1
[08:27:41.147]   ..$ a:<environment: R_EmptyEnv> 
[08:27:41.147]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:41.147]  - attr(*, "resolved")= logi FALSE
[08:27:41.147]  - attr(*, "total_size")= num 39
[08:27:41.147]  - attr(*, "already-done")= logi TRUE
[08:27:41.153] - copied ‘a’ to environment
[08:27:41.154] assign_globals() ... done
[08:27:41.154] plan(): Setting new future strategy stack:
[08:27:41.154] List of future strategies:
[08:27:41.154] 1. sequential:
[08:27:41.154]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.154]    - tweaked: FALSE
[08:27:41.154]    - call: NULL
[08:27:41.154] plan(): nbrOfWorkers() = 1
[08:27:41.155] plan(): Setting new future strategy stack:
[08:27:41.155] List of future strategies:
[08:27:41.155] 1. sequential:
[08:27:41.155]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.155]    - tweaked: FALSE
[08:27:41.155]    - call: plan(strategy)
[08:27:41.156] plan(): nbrOfWorkers() = 1
[08:27:41.156] SequentialFuture started (and completed)
[08:27:41.156] - Launch lazy future ... done
[08:27:41.156] run() for ‘SequentialFuture’ ... done
** Future evaluation with errors
[08:27:41.156] getGlobalsAndPackages() ...
[08:27:41.156] Searching for globals...
[08:27:41.160] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[08:27:41.160] Searching for globals ... DONE
[08:27:41.160] Resolving globals: FALSE
[08:27:41.160] 
[08:27:41.160] 
[08:27:41.161] getGlobalsAndPackages() ... DONE
[08:27:41.161] run() for ‘Future’ ...
[08:27:41.161] - state: ‘created’
[08:27:41.161] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:41.161] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:41.161] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:41.161]   - Field: ‘label’
[08:27:41.162]   - Field: ‘local’
[08:27:41.162]   - Field: ‘owner’
[08:27:41.162]   - Field: ‘envir’
[08:27:41.162]   - Field: ‘packages’
[08:27:41.162]   - Field: ‘gc’
[08:27:41.162]   - Field: ‘conditions’
[08:27:41.162]   - Field: ‘expr’
[08:27:41.162]   - Field: ‘uuid’
[08:27:41.162]   - Field: ‘seed’
[08:27:41.162]   - Field: ‘version’
[08:27:41.162]   - Field: ‘result’
[08:27:41.162]   - Field: ‘asynchronous’
[08:27:41.163]   - Field: ‘calls’
[08:27:41.163]   - Field: ‘globals’
[08:27:41.163]   - Field: ‘stdout’
[08:27:41.163]   - Field: ‘earlySignal’
[08:27:41.163]   - Field: ‘lazy’
[08:27:41.163]   - Field: ‘state’
[08:27:41.163] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:41.163] - Launch lazy future ...
[08:27:41.163] Packages needed by the future expression (n = 0): <none>
[08:27:41.163] Packages needed by future strategies (n = 0): <none>
[08:27:41.164] {
[08:27:41.164]     {
[08:27:41.164]         {
[08:27:41.164]             ...future.startTime <- base::Sys.time()
[08:27:41.164]             {
[08:27:41.164]                 {
[08:27:41.164]                   {
[08:27:41.164]                     base::local({
[08:27:41.164]                       has_future <- base::requireNamespace("future", 
[08:27:41.164]                         quietly = TRUE)
[08:27:41.164]                       if (has_future) {
[08:27:41.164]                         ns <- base::getNamespace("future")
[08:27:41.164]                         version <- ns[[".package"]][["version"]]
[08:27:41.164]                         if (is.null(version)) 
[08:27:41.164]                           version <- utils::packageVersion("future")
[08:27:41.164]                       }
[08:27:41.164]                       else {
[08:27:41.164]                         version <- NULL
[08:27:41.164]                       }
[08:27:41.164]                       if (!has_future || version < "1.8.0") {
[08:27:41.164]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.164]                           "", base::R.version$version.string), 
[08:27:41.164]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:41.164]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.164]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.164]                             "release", "version")], collapse = " "), 
[08:27:41.164]                           hostname = base::Sys.info()[["nodename"]])
[08:27:41.164]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.164]                           info)
[08:27:41.164]                         info <- base::paste(info, collapse = "; ")
[08:27:41.164]                         if (!has_future) {
[08:27:41.164]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.164]                             info)
[08:27:41.164]                         }
[08:27:41.164]                         else {
[08:27:41.164]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.164]                             info, version)
[08:27:41.164]                         }
[08:27:41.164]                         base::stop(msg)
[08:27:41.164]                       }
[08:27:41.164]                     })
[08:27:41.164]                   }
[08:27:41.164]                   ...future.strategy.old <- future::plan("list")
[08:27:41.164]                   options(future.plan = NULL)
[08:27:41.164]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.164]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.164]                 }
[08:27:41.164]                 ...future.workdir <- getwd()
[08:27:41.164]             }
[08:27:41.164]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.164]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.164]         }
[08:27:41.164]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.164]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.164]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.164]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.164]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.164]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.164]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.164]             base::names(...future.oldOptions))
[08:27:41.164]     }
[08:27:41.164]     if (FALSE) {
[08:27:41.164]     }
[08:27:41.164]     else {
[08:27:41.164]         if (TRUE) {
[08:27:41.164]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.164]                 open = "w")
[08:27:41.164]         }
[08:27:41.164]         else {
[08:27:41.164]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.164]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.164]         }
[08:27:41.164]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.164]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.164]             base::sink(type = "output", split = FALSE)
[08:27:41.164]             base::close(...future.stdout)
[08:27:41.164]         }, add = TRUE)
[08:27:41.164]     }
[08:27:41.164]     ...future.frame <- base::sys.nframe()
[08:27:41.164]     ...future.conditions <- base::list()
[08:27:41.164]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.164]     if (FALSE) {
[08:27:41.164]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.164]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.164]     }
[08:27:41.164]     ...future.result <- base::tryCatch({
[08:27:41.164]         base::withCallingHandlers({
[08:27:41.164]             ...future.value <- base::withVisible(base::local({
[08:27:41.164]                 x <- 3
[08:27:41.164]                 stop("Woops!")
[08:27:41.164]                 x
[08:27:41.164]             }))
[08:27:41.164]             future::FutureResult(value = ...future.value$value, 
[08:27:41.164]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.164]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.164]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.164]                     ...future.globalenv.names))
[08:27:41.164]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.164]         }, condition = base::local({
[08:27:41.164]             c <- base::c
[08:27:41.164]             inherits <- base::inherits
[08:27:41.164]             invokeRestart <- base::invokeRestart
[08:27:41.164]             length <- base::length
[08:27:41.164]             list <- base::list
[08:27:41.164]             seq.int <- base::seq.int
[08:27:41.164]             signalCondition <- base::signalCondition
[08:27:41.164]             sys.calls <- base::sys.calls
[08:27:41.164]             `[[` <- base::`[[`
[08:27:41.164]             `+` <- base::`+`
[08:27:41.164]             `<<-` <- base::`<<-`
[08:27:41.164]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.164]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.164]                   3L)]
[08:27:41.164]             }
[08:27:41.164]             function(cond) {
[08:27:41.164]                 is_error <- inherits(cond, "error")
[08:27:41.164]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.164]                   NULL)
[08:27:41.164]                 if (is_error) {
[08:27:41.164]                   sessionInformation <- function() {
[08:27:41.164]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.164]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.164]                       search = base::search(), system = base::Sys.info())
[08:27:41.164]                   }
[08:27:41.164]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.164]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.164]                     cond$call), session = sessionInformation(), 
[08:27:41.164]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.164]                   signalCondition(cond)
[08:27:41.164]                 }
[08:27:41.164]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.164]                 "immediateCondition"))) {
[08:27:41.164]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.164]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.164]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.164]                   if (TRUE && !signal) {
[08:27:41.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.164]                     {
[08:27:41.164]                       inherits <- base::inherits
[08:27:41.164]                       invokeRestart <- base::invokeRestart
[08:27:41.164]                       is.null <- base::is.null
[08:27:41.164]                       muffled <- FALSE
[08:27:41.164]                       if (inherits(cond, "message")) {
[08:27:41.164]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.164]                         if (muffled) 
[08:27:41.164]                           invokeRestart("muffleMessage")
[08:27:41.164]                       }
[08:27:41.164]                       else if (inherits(cond, "warning")) {
[08:27:41.164]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.164]                         if (muffled) 
[08:27:41.164]                           invokeRestart("muffleWarning")
[08:27:41.164]                       }
[08:27:41.164]                       else if (inherits(cond, "condition")) {
[08:27:41.164]                         if (!is.null(pattern)) {
[08:27:41.164]                           computeRestarts <- base::computeRestarts
[08:27:41.164]                           grepl <- base::grepl
[08:27:41.164]                           restarts <- computeRestarts(cond)
[08:27:41.164]                           for (restart in restarts) {
[08:27:41.164]                             name <- restart$name
[08:27:41.164]                             if (is.null(name)) 
[08:27:41.164]                               next
[08:27:41.164]                             if (!grepl(pattern, name)) 
[08:27:41.164]                               next
[08:27:41.164]                             invokeRestart(restart)
[08:27:41.164]                             muffled <- TRUE
[08:27:41.164]                             break
[08:27:41.164]                           }
[08:27:41.164]                         }
[08:27:41.164]                       }
[08:27:41.164]                       invisible(muffled)
[08:27:41.164]                     }
[08:27:41.164]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.164]                   }
[08:27:41.164]                 }
[08:27:41.164]                 else {
[08:27:41.164]                   if (TRUE) {
[08:27:41.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.164]                     {
[08:27:41.164]                       inherits <- base::inherits
[08:27:41.164]                       invokeRestart <- base::invokeRestart
[08:27:41.164]                       is.null <- base::is.null
[08:27:41.164]                       muffled <- FALSE
[08:27:41.164]                       if (inherits(cond, "message")) {
[08:27:41.164]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.164]                         if (muffled) 
[08:27:41.164]                           invokeRestart("muffleMessage")
[08:27:41.164]                       }
[08:27:41.164]                       else if (inherits(cond, "warning")) {
[08:27:41.164]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.164]                         if (muffled) 
[08:27:41.164]                           invokeRestart("muffleWarning")
[08:27:41.164]                       }
[08:27:41.164]                       else if (inherits(cond, "condition")) {
[08:27:41.164]                         if (!is.null(pattern)) {
[08:27:41.164]                           computeRestarts <- base::computeRestarts
[08:27:41.164]                           grepl <- base::grepl
[08:27:41.164]                           restarts <- computeRestarts(cond)
[08:27:41.164]                           for (restart in restarts) {
[08:27:41.164]                             name <- restart$name
[08:27:41.164]                             if (is.null(name)) 
[08:27:41.164]                               next
[08:27:41.164]                             if (!grepl(pattern, name)) 
[08:27:41.164]                               next
[08:27:41.164]                             invokeRestart(restart)
[08:27:41.164]                             muffled <- TRUE
[08:27:41.164]                             break
[08:27:41.164]                           }
[08:27:41.164]                         }
[08:27:41.164]                       }
[08:27:41.164]                       invisible(muffled)
[08:27:41.164]                     }
[08:27:41.164]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.164]                   }
[08:27:41.164]                 }
[08:27:41.164]             }
[08:27:41.164]         }))
[08:27:41.164]     }, error = function(ex) {
[08:27:41.164]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.164]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.164]                 ...future.rng), started = ...future.startTime, 
[08:27:41.164]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.164]             version = "1.8"), class = "FutureResult")
[08:27:41.164]     }, finally = {
[08:27:41.164]         if (!identical(...future.workdir, getwd())) 
[08:27:41.164]             setwd(...future.workdir)
[08:27:41.164]         {
[08:27:41.164]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.164]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.164]             }
[08:27:41.164]             base::options(...future.oldOptions)
[08:27:41.164]             if (.Platform$OS.type == "windows") {
[08:27:41.164]                 old_names <- names(...future.oldEnvVars)
[08:27:41.164]                 envs <- base::Sys.getenv()
[08:27:41.164]                 names <- names(envs)
[08:27:41.164]                 common <- intersect(names, old_names)
[08:27:41.164]                 added <- setdiff(names, old_names)
[08:27:41.164]                 removed <- setdiff(old_names, names)
[08:27:41.164]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.164]                   envs[common]]
[08:27:41.164]                 NAMES <- toupper(changed)
[08:27:41.164]                 args <- list()
[08:27:41.164]                 for (kk in seq_along(NAMES)) {
[08:27:41.164]                   name <- changed[[kk]]
[08:27:41.164]                   NAME <- NAMES[[kk]]
[08:27:41.164]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.164]                     next
[08:27:41.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.164]                 }
[08:27:41.164]                 NAMES <- toupper(added)
[08:27:41.164]                 for (kk in seq_along(NAMES)) {
[08:27:41.164]                   name <- added[[kk]]
[08:27:41.164]                   NAME <- NAMES[[kk]]
[08:27:41.164]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.164]                     next
[08:27:41.164]                   args[[name]] <- ""
[08:27:41.164]                 }
[08:27:41.164]                 NAMES <- toupper(removed)
[08:27:41.164]                 for (kk in seq_along(NAMES)) {
[08:27:41.164]                   name <- removed[[kk]]
[08:27:41.164]                   NAME <- NAMES[[kk]]
[08:27:41.164]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.164]                     next
[08:27:41.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.164]                 }
[08:27:41.164]                 if (length(args) > 0) 
[08:27:41.164]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.164]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.164]             }
[08:27:41.164]             else {
[08:27:41.164]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.164]             }
[08:27:41.164]             {
[08:27:41.164]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.164]                   0L) {
[08:27:41.164]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.164]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.164]                   base::options(opts)
[08:27:41.164]                 }
[08:27:41.164]                 {
[08:27:41.164]                   {
[08:27:41.164]                     NULL
[08:27:41.164]                     RNGkind("Mersenne-Twister")
[08:27:41.164]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:41.164]                       inherits = FALSE)
[08:27:41.164]                   }
[08:27:41.164]                   options(future.plan = NULL)
[08:27:41.164]                   if (is.na(NA_character_)) 
[08:27:41.164]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.164]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.164]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.164]                     .init = FALSE)
[08:27:41.164]                 }
[08:27:41.164]             }
[08:27:41.164]         }
[08:27:41.164]     })
[08:27:41.164]     if (TRUE) {
[08:27:41.164]         base::sink(type = "output", split = FALSE)
[08:27:41.164]         if (TRUE) {
[08:27:41.164]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.164]         }
[08:27:41.164]         else {
[08:27:41.164]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.164]         }
[08:27:41.164]         base::close(...future.stdout)
[08:27:41.164]         ...future.stdout <- NULL
[08:27:41.164]     }
[08:27:41.164]     ...future.result$conditions <- ...future.conditions
[08:27:41.164]     ...future.result$finished <- base::Sys.time()
[08:27:41.164]     ...future.result
[08:27:41.164] }
[08:27:41.166] plan(): Setting new future strategy stack:
[08:27:41.166] List of future strategies:
[08:27:41.166] 1. sequential:
[08:27:41.166]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.166]    - tweaked: FALSE
[08:27:41.166]    - call: NULL
[08:27:41.166] plan(): nbrOfWorkers() = 1
[08:27:41.167] plan(): Setting new future strategy stack:
[08:27:41.167] List of future strategies:
[08:27:41.167] 1. sequential:
[08:27:41.167]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.167]    - tweaked: FALSE
[08:27:41.167]    - call: plan(strategy)
[08:27:41.168] plan(): nbrOfWorkers() = 1
[08:27:41.168] SequentialFuture started (and completed)
[08:27:41.168] signalConditions() ...
[08:27:41.168]  - include = ‘immediateCondition’
[08:27:41.168]  - exclude = 
[08:27:41.168]  - resignal = FALSE
[08:27:41.168]  - Number of conditions: 1
[08:27:41.168] signalConditions() ... done
[08:27:41.168] - Launch lazy future ... done
[08:27:41.168] run() for ‘SequentialFuture’ ... done
[08:27:41.169] signalConditions() ...
[08:27:41.169]  - include = ‘immediateCondition’
[08:27:41.169]  - exclude = 
[08:27:41.169]  - resignal = FALSE
[08:27:41.169]  - Number of conditions: 1
[08:27:41.169] signalConditions() ... done
[08:27:41.169] Future state: ‘finished’
[08:27:41.169] signalConditions() ...
[08:27:41.169]  - include = ‘condition’
[08:27:41.169]  - exclude = ‘immediateCondition’
[08:27:41.170]  - resignal = TRUE
[08:27:41.170]  - Number of conditions: 1
[08:27:41.170]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:27:41.170] signalConditions() ... done
[08:27:41.170] getGlobalsAndPackages() ...
[08:27:41.171] Searching for globals...
[08:27:41.172] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[08:27:41.172] Searching for globals ... DONE
[08:27:41.172] Resolving globals: FALSE
[08:27:41.173] The total size of the 1 globals is 35 bytes (35 bytes)
[08:27:41.173] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:27:41.173] - globals: [1] ‘ii’
[08:27:41.173] 
[08:27:41.174] getGlobalsAndPackages() ... DONE
[08:27:41.174] run() for ‘Future’ ...
[08:27:41.174] - state: ‘created’
[08:27:41.174] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:41.174] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:41.174] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:41.174]   - Field: ‘label’
[08:27:41.175]   - Field: ‘local’
[08:27:41.175]   - Field: ‘owner’
[08:27:41.175]   - Field: ‘envir’
[08:27:41.175]   - Field: ‘packages’
[08:27:41.175]   - Field: ‘gc’
[08:27:41.175]   - Field: ‘conditions’
[08:27:41.175]   - Field: ‘expr’
[08:27:41.175]   - Field: ‘uuid’
[08:27:41.175]   - Field: ‘seed’
[08:27:41.175]   - Field: ‘version’
[08:27:41.175]   - Field: ‘result’
[08:27:41.175]   - Field: ‘asynchronous’
[08:27:41.176]   - Field: ‘calls’
[08:27:41.176]   - Field: ‘globals’
[08:27:41.176]   - Field: ‘stdout’
[08:27:41.176]   - Field: ‘earlySignal’
[08:27:41.176]   - Field: ‘lazy’
[08:27:41.176]   - Field: ‘state’
[08:27:41.176] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:41.176] - Launch lazy future ...
[08:27:41.176] Packages needed by the future expression (n = 0): <none>
[08:27:41.176] Packages needed by future strategies (n = 0): <none>
[08:27:41.177] {
[08:27:41.177]     {
[08:27:41.177]         {
[08:27:41.177]             ...future.startTime <- base::Sys.time()
[08:27:41.177]             {
[08:27:41.177]                 {
[08:27:41.177]                   {
[08:27:41.177]                     base::local({
[08:27:41.177]                       has_future <- base::requireNamespace("future", 
[08:27:41.177]                         quietly = TRUE)
[08:27:41.177]                       if (has_future) {
[08:27:41.177]                         ns <- base::getNamespace("future")
[08:27:41.177]                         version <- ns[[".package"]][["version"]]
[08:27:41.177]                         if (is.null(version)) 
[08:27:41.177]                           version <- utils::packageVersion("future")
[08:27:41.177]                       }
[08:27:41.177]                       else {
[08:27:41.177]                         version <- NULL
[08:27:41.177]                       }
[08:27:41.177]                       if (!has_future || version < "1.8.0") {
[08:27:41.177]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.177]                           "", base::R.version$version.string), 
[08:27:41.177]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:41.177]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.177]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.177]                             "release", "version")], collapse = " "), 
[08:27:41.177]                           hostname = base::Sys.info()[["nodename"]])
[08:27:41.177]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.177]                           info)
[08:27:41.177]                         info <- base::paste(info, collapse = "; ")
[08:27:41.177]                         if (!has_future) {
[08:27:41.177]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.177]                             info)
[08:27:41.177]                         }
[08:27:41.177]                         else {
[08:27:41.177]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.177]                             info, version)
[08:27:41.177]                         }
[08:27:41.177]                         base::stop(msg)
[08:27:41.177]                       }
[08:27:41.177]                     })
[08:27:41.177]                   }
[08:27:41.177]                   ...future.strategy.old <- future::plan("list")
[08:27:41.177]                   options(future.plan = NULL)
[08:27:41.177]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.177]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.177]                 }
[08:27:41.177]                 ...future.workdir <- getwd()
[08:27:41.177]             }
[08:27:41.177]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.177]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.177]         }
[08:27:41.177]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.177]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.177]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.177]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.177]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.177]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.177]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.177]             base::names(...future.oldOptions))
[08:27:41.177]     }
[08:27:41.177]     if (FALSE) {
[08:27:41.177]     }
[08:27:41.177]     else {
[08:27:41.177]         if (TRUE) {
[08:27:41.177]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.177]                 open = "w")
[08:27:41.177]         }
[08:27:41.177]         else {
[08:27:41.177]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.177]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.177]         }
[08:27:41.177]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.177]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.177]             base::sink(type = "output", split = FALSE)
[08:27:41.177]             base::close(...future.stdout)
[08:27:41.177]         }, add = TRUE)
[08:27:41.177]     }
[08:27:41.177]     ...future.frame <- base::sys.nframe()
[08:27:41.177]     ...future.conditions <- base::list()
[08:27:41.177]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.177]     if (FALSE) {
[08:27:41.177]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.177]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.177]     }
[08:27:41.177]     ...future.result <- base::tryCatch({
[08:27:41.177]         base::withCallingHandlers({
[08:27:41.177]             ...future.value <- base::withVisible(base::local({
[08:27:41.177]                 if (ii%%2 == 0) 
[08:27:41.177]                   stop("Woops!")
[08:27:41.177]                 ii
[08:27:41.177]             }))
[08:27:41.177]             future::FutureResult(value = ...future.value$value, 
[08:27:41.177]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.177]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.177]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.177]                     ...future.globalenv.names))
[08:27:41.177]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.177]         }, condition = base::local({
[08:27:41.177]             c <- base::c
[08:27:41.177]             inherits <- base::inherits
[08:27:41.177]             invokeRestart <- base::invokeRestart
[08:27:41.177]             length <- base::length
[08:27:41.177]             list <- base::list
[08:27:41.177]             seq.int <- base::seq.int
[08:27:41.177]             signalCondition <- base::signalCondition
[08:27:41.177]             sys.calls <- base::sys.calls
[08:27:41.177]             `[[` <- base::`[[`
[08:27:41.177]             `+` <- base::`+`
[08:27:41.177]             `<<-` <- base::`<<-`
[08:27:41.177]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.177]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.177]                   3L)]
[08:27:41.177]             }
[08:27:41.177]             function(cond) {
[08:27:41.177]                 is_error <- inherits(cond, "error")
[08:27:41.177]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.177]                   NULL)
[08:27:41.177]                 if (is_error) {
[08:27:41.177]                   sessionInformation <- function() {
[08:27:41.177]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.177]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.177]                       search = base::search(), system = base::Sys.info())
[08:27:41.177]                   }
[08:27:41.177]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.177]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.177]                     cond$call), session = sessionInformation(), 
[08:27:41.177]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.177]                   signalCondition(cond)
[08:27:41.177]                 }
[08:27:41.177]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.177]                 "immediateCondition"))) {
[08:27:41.177]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.177]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.177]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.177]                   if (TRUE && !signal) {
[08:27:41.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.177]                     {
[08:27:41.177]                       inherits <- base::inherits
[08:27:41.177]                       invokeRestart <- base::invokeRestart
[08:27:41.177]                       is.null <- base::is.null
[08:27:41.177]                       muffled <- FALSE
[08:27:41.177]                       if (inherits(cond, "message")) {
[08:27:41.177]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.177]                         if (muffled) 
[08:27:41.177]                           invokeRestart("muffleMessage")
[08:27:41.177]                       }
[08:27:41.177]                       else if (inherits(cond, "warning")) {
[08:27:41.177]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.177]                         if (muffled) 
[08:27:41.177]                           invokeRestart("muffleWarning")
[08:27:41.177]                       }
[08:27:41.177]                       else if (inherits(cond, "condition")) {
[08:27:41.177]                         if (!is.null(pattern)) {
[08:27:41.177]                           computeRestarts <- base::computeRestarts
[08:27:41.177]                           grepl <- base::grepl
[08:27:41.177]                           restarts <- computeRestarts(cond)
[08:27:41.177]                           for (restart in restarts) {
[08:27:41.177]                             name <- restart$name
[08:27:41.177]                             if (is.null(name)) 
[08:27:41.177]                               next
[08:27:41.177]                             if (!grepl(pattern, name)) 
[08:27:41.177]                               next
[08:27:41.177]                             invokeRestart(restart)
[08:27:41.177]                             muffled <- TRUE
[08:27:41.177]                             break
[08:27:41.177]                           }
[08:27:41.177]                         }
[08:27:41.177]                       }
[08:27:41.177]                       invisible(muffled)
[08:27:41.177]                     }
[08:27:41.177]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.177]                   }
[08:27:41.177]                 }
[08:27:41.177]                 else {
[08:27:41.177]                   if (TRUE) {
[08:27:41.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.177]                     {
[08:27:41.177]                       inherits <- base::inherits
[08:27:41.177]                       invokeRestart <- base::invokeRestart
[08:27:41.177]                       is.null <- base::is.null
[08:27:41.177]                       muffled <- FALSE
[08:27:41.177]                       if (inherits(cond, "message")) {
[08:27:41.177]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.177]                         if (muffled) 
[08:27:41.177]                           invokeRestart("muffleMessage")
[08:27:41.177]                       }
[08:27:41.177]                       else if (inherits(cond, "warning")) {
[08:27:41.177]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.177]                         if (muffled) 
[08:27:41.177]                           invokeRestart("muffleWarning")
[08:27:41.177]                       }
[08:27:41.177]                       else if (inherits(cond, "condition")) {
[08:27:41.177]                         if (!is.null(pattern)) {
[08:27:41.177]                           computeRestarts <- base::computeRestarts
[08:27:41.177]                           grepl <- base::grepl
[08:27:41.177]                           restarts <- computeRestarts(cond)
[08:27:41.177]                           for (restart in restarts) {
[08:27:41.177]                             name <- restart$name
[08:27:41.177]                             if (is.null(name)) 
[08:27:41.177]                               next
[08:27:41.177]                             if (!grepl(pattern, name)) 
[08:27:41.177]                               next
[08:27:41.177]                             invokeRestart(restart)
[08:27:41.177]                             muffled <- TRUE
[08:27:41.177]                             break
[08:27:41.177]                           }
[08:27:41.177]                         }
[08:27:41.177]                       }
[08:27:41.177]                       invisible(muffled)
[08:27:41.177]                     }
[08:27:41.177]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.177]                   }
[08:27:41.177]                 }
[08:27:41.177]             }
[08:27:41.177]         }))
[08:27:41.177]     }, error = function(ex) {
[08:27:41.177]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.177]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.177]                 ...future.rng), started = ...future.startTime, 
[08:27:41.177]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.177]             version = "1.8"), class = "FutureResult")
[08:27:41.177]     }, finally = {
[08:27:41.177]         if (!identical(...future.workdir, getwd())) 
[08:27:41.177]             setwd(...future.workdir)
[08:27:41.177]         {
[08:27:41.177]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.177]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.177]             }
[08:27:41.177]             base::options(...future.oldOptions)
[08:27:41.177]             if (.Platform$OS.type == "windows") {
[08:27:41.177]                 old_names <- names(...future.oldEnvVars)
[08:27:41.177]                 envs <- base::Sys.getenv()
[08:27:41.177]                 names <- names(envs)
[08:27:41.177]                 common <- intersect(names, old_names)
[08:27:41.177]                 added <- setdiff(names, old_names)
[08:27:41.177]                 removed <- setdiff(old_names, names)
[08:27:41.177]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.177]                   envs[common]]
[08:27:41.177]                 NAMES <- toupper(changed)
[08:27:41.177]                 args <- list()
[08:27:41.177]                 for (kk in seq_along(NAMES)) {
[08:27:41.177]                   name <- changed[[kk]]
[08:27:41.177]                   NAME <- NAMES[[kk]]
[08:27:41.177]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.177]                     next
[08:27:41.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.177]                 }
[08:27:41.177]                 NAMES <- toupper(added)
[08:27:41.177]                 for (kk in seq_along(NAMES)) {
[08:27:41.177]                   name <- added[[kk]]
[08:27:41.177]                   NAME <- NAMES[[kk]]
[08:27:41.177]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.177]                     next
[08:27:41.177]                   args[[name]] <- ""
[08:27:41.177]                 }
[08:27:41.177]                 NAMES <- toupper(removed)
[08:27:41.177]                 for (kk in seq_along(NAMES)) {
[08:27:41.177]                   name <- removed[[kk]]
[08:27:41.177]                   NAME <- NAMES[[kk]]
[08:27:41.177]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.177]                     next
[08:27:41.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.177]                 }
[08:27:41.177]                 if (length(args) > 0) 
[08:27:41.177]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.177]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.177]             }
[08:27:41.177]             else {
[08:27:41.177]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.177]             }
[08:27:41.177]             {
[08:27:41.177]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.177]                   0L) {
[08:27:41.177]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.177]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.177]                   base::options(opts)
[08:27:41.177]                 }
[08:27:41.177]                 {
[08:27:41.177]                   {
[08:27:41.177]                     NULL
[08:27:41.177]                     RNGkind("Mersenne-Twister")
[08:27:41.177]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:41.177]                       inherits = FALSE)
[08:27:41.177]                   }
[08:27:41.177]                   options(future.plan = NULL)
[08:27:41.177]                   if (is.na(NA_character_)) 
[08:27:41.177]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.177]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.177]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.177]                     .init = FALSE)
[08:27:41.177]                 }
[08:27:41.177]             }
[08:27:41.177]         }
[08:27:41.177]     })
[08:27:41.177]     if (TRUE) {
[08:27:41.177]         base::sink(type = "output", split = FALSE)
[08:27:41.177]         if (TRUE) {
[08:27:41.177]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.177]         }
[08:27:41.177]         else {
[08:27:41.177]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.177]         }
[08:27:41.177]         base::close(...future.stdout)
[08:27:41.177]         ...future.stdout <- NULL
[08:27:41.177]     }
[08:27:41.177]     ...future.result$conditions <- ...future.conditions
[08:27:41.177]     ...future.result$finished <- base::Sys.time()
[08:27:41.177]     ...future.result
[08:27:41.177] }
[08:27:41.179] assign_globals() ...
[08:27:41.179] List of 1
[08:27:41.179]  $ ii: int 1
[08:27:41.179]  - attr(*, "where")=List of 1
[08:27:41.179]   ..$ ii:<environment: R_EmptyEnv> 
[08:27:41.179]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:41.179]  - attr(*, "resolved")= logi FALSE
[08:27:41.179]  - attr(*, "total_size")= num 35
[08:27:41.179]  - attr(*, "already-done")= logi TRUE
[08:27:41.183] - copied ‘ii’ to environment
[08:27:41.183] assign_globals() ... done
[08:27:41.183] plan(): Setting new future strategy stack:
[08:27:41.183] List of future strategies:
[08:27:41.183] 1. sequential:
[08:27:41.183]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.183]    - tweaked: FALSE
[08:27:41.183]    - call: NULL
[08:27:41.184] plan(): nbrOfWorkers() = 1
[08:27:41.184] plan(): Setting new future strategy stack:
[08:27:41.184] List of future strategies:
[08:27:41.184] 1. sequential:
[08:27:41.184]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.184]    - tweaked: FALSE
[08:27:41.184]    - call: plan(strategy)
[08:27:41.185] plan(): nbrOfWorkers() = 1
[08:27:41.185] SequentialFuture started (and completed)
[08:27:41.185] - Launch lazy future ... done
[08:27:41.185] run() for ‘SequentialFuture’ ... done
[08:27:41.186] getGlobalsAndPackages() ...
[08:27:41.186] Searching for globals...
[08:27:41.187] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[08:27:41.187] Searching for globals ... DONE
[08:27:41.187] Resolving globals: FALSE
[08:27:41.188] The total size of the 1 globals is 35 bytes (35 bytes)
[08:27:41.188] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:27:41.188] - globals: [1] ‘ii’
[08:27:41.188] 
[08:27:41.188] getGlobalsAndPackages() ... DONE
[08:27:41.189] run() for ‘Future’ ...
[08:27:41.189] - state: ‘created’
[08:27:41.189] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:41.189] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:41.189] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:41.189]   - Field: ‘label’
[08:27:41.189]   - Field: ‘local’
[08:27:41.190]   - Field: ‘owner’
[08:27:41.190]   - Field: ‘envir’
[08:27:41.190]   - Field: ‘packages’
[08:27:41.190]   - Field: ‘gc’
[08:27:41.190]   - Field: ‘conditions’
[08:27:41.190]   - Field: ‘expr’
[08:27:41.190]   - Field: ‘uuid’
[08:27:41.190]   - Field: ‘seed’
[08:27:41.190]   - Field: ‘version’
[08:27:41.190]   - Field: ‘result’
[08:27:41.190]   - Field: ‘asynchronous’
[08:27:41.190]   - Field: ‘calls’
[08:27:41.191]   - Field: ‘globals’
[08:27:41.191]   - Field: ‘stdout’
[08:27:41.191]   - Field: ‘earlySignal’
[08:27:41.191]   - Field: ‘lazy’
[08:27:41.191]   - Field: ‘state’
[08:27:41.191] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:41.191] - Launch lazy future ...
[08:27:41.191] Packages needed by the future expression (n = 0): <none>
[08:27:41.191] Packages needed by future strategies (n = 0): <none>
[08:27:41.192] {
[08:27:41.192]     {
[08:27:41.192]         {
[08:27:41.192]             ...future.startTime <- base::Sys.time()
[08:27:41.192]             {
[08:27:41.192]                 {
[08:27:41.192]                   {
[08:27:41.192]                     base::local({
[08:27:41.192]                       has_future <- base::requireNamespace("future", 
[08:27:41.192]                         quietly = TRUE)
[08:27:41.192]                       if (has_future) {
[08:27:41.192]                         ns <- base::getNamespace("future")
[08:27:41.192]                         version <- ns[[".package"]][["version"]]
[08:27:41.192]                         if (is.null(version)) 
[08:27:41.192]                           version <- utils::packageVersion("future")
[08:27:41.192]                       }
[08:27:41.192]                       else {
[08:27:41.192]                         version <- NULL
[08:27:41.192]                       }
[08:27:41.192]                       if (!has_future || version < "1.8.0") {
[08:27:41.192]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.192]                           "", base::R.version$version.string), 
[08:27:41.192]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:41.192]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.192]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.192]                             "release", "version")], collapse = " "), 
[08:27:41.192]                           hostname = base::Sys.info()[["nodename"]])
[08:27:41.192]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.192]                           info)
[08:27:41.192]                         info <- base::paste(info, collapse = "; ")
[08:27:41.192]                         if (!has_future) {
[08:27:41.192]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.192]                             info)
[08:27:41.192]                         }
[08:27:41.192]                         else {
[08:27:41.192]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.192]                             info, version)
[08:27:41.192]                         }
[08:27:41.192]                         base::stop(msg)
[08:27:41.192]                       }
[08:27:41.192]                     })
[08:27:41.192]                   }
[08:27:41.192]                   ...future.strategy.old <- future::plan("list")
[08:27:41.192]                   options(future.plan = NULL)
[08:27:41.192]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.192]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.192]                 }
[08:27:41.192]                 ...future.workdir <- getwd()
[08:27:41.192]             }
[08:27:41.192]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.192]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.192]         }
[08:27:41.192]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.192]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.192]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.192]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.192]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.192]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.192]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.192]             base::names(...future.oldOptions))
[08:27:41.192]     }
[08:27:41.192]     if (FALSE) {
[08:27:41.192]     }
[08:27:41.192]     else {
[08:27:41.192]         if (TRUE) {
[08:27:41.192]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.192]                 open = "w")
[08:27:41.192]         }
[08:27:41.192]         else {
[08:27:41.192]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.192]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.192]         }
[08:27:41.192]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.192]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.192]             base::sink(type = "output", split = FALSE)
[08:27:41.192]             base::close(...future.stdout)
[08:27:41.192]         }, add = TRUE)
[08:27:41.192]     }
[08:27:41.192]     ...future.frame <- base::sys.nframe()
[08:27:41.192]     ...future.conditions <- base::list()
[08:27:41.192]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.192]     if (FALSE) {
[08:27:41.192]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.192]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.192]     }
[08:27:41.192]     ...future.result <- base::tryCatch({
[08:27:41.192]         base::withCallingHandlers({
[08:27:41.192]             ...future.value <- base::withVisible(base::local({
[08:27:41.192]                 if (ii%%2 == 0) 
[08:27:41.192]                   stop("Woops!")
[08:27:41.192]                 ii
[08:27:41.192]             }))
[08:27:41.192]             future::FutureResult(value = ...future.value$value, 
[08:27:41.192]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.192]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.192]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.192]                     ...future.globalenv.names))
[08:27:41.192]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.192]         }, condition = base::local({
[08:27:41.192]             c <- base::c
[08:27:41.192]             inherits <- base::inherits
[08:27:41.192]             invokeRestart <- base::invokeRestart
[08:27:41.192]             length <- base::length
[08:27:41.192]             list <- base::list
[08:27:41.192]             seq.int <- base::seq.int
[08:27:41.192]             signalCondition <- base::signalCondition
[08:27:41.192]             sys.calls <- base::sys.calls
[08:27:41.192]             `[[` <- base::`[[`
[08:27:41.192]             `+` <- base::`+`
[08:27:41.192]             `<<-` <- base::`<<-`
[08:27:41.192]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.192]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.192]                   3L)]
[08:27:41.192]             }
[08:27:41.192]             function(cond) {
[08:27:41.192]                 is_error <- inherits(cond, "error")
[08:27:41.192]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.192]                   NULL)
[08:27:41.192]                 if (is_error) {
[08:27:41.192]                   sessionInformation <- function() {
[08:27:41.192]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.192]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.192]                       search = base::search(), system = base::Sys.info())
[08:27:41.192]                   }
[08:27:41.192]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.192]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.192]                     cond$call), session = sessionInformation(), 
[08:27:41.192]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.192]                   signalCondition(cond)
[08:27:41.192]                 }
[08:27:41.192]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.192]                 "immediateCondition"))) {
[08:27:41.192]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.192]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.192]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.192]                   if (TRUE && !signal) {
[08:27:41.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.192]                     {
[08:27:41.192]                       inherits <- base::inherits
[08:27:41.192]                       invokeRestart <- base::invokeRestart
[08:27:41.192]                       is.null <- base::is.null
[08:27:41.192]                       muffled <- FALSE
[08:27:41.192]                       if (inherits(cond, "message")) {
[08:27:41.192]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.192]                         if (muffled) 
[08:27:41.192]                           invokeRestart("muffleMessage")
[08:27:41.192]                       }
[08:27:41.192]                       else if (inherits(cond, "warning")) {
[08:27:41.192]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.192]                         if (muffled) 
[08:27:41.192]                           invokeRestart("muffleWarning")
[08:27:41.192]                       }
[08:27:41.192]                       else if (inherits(cond, "condition")) {
[08:27:41.192]                         if (!is.null(pattern)) {
[08:27:41.192]                           computeRestarts <- base::computeRestarts
[08:27:41.192]                           grepl <- base::grepl
[08:27:41.192]                           restarts <- computeRestarts(cond)
[08:27:41.192]                           for (restart in restarts) {
[08:27:41.192]                             name <- restart$name
[08:27:41.192]                             if (is.null(name)) 
[08:27:41.192]                               next
[08:27:41.192]                             if (!grepl(pattern, name)) 
[08:27:41.192]                               next
[08:27:41.192]                             invokeRestart(restart)
[08:27:41.192]                             muffled <- TRUE
[08:27:41.192]                             break
[08:27:41.192]                           }
[08:27:41.192]                         }
[08:27:41.192]                       }
[08:27:41.192]                       invisible(muffled)
[08:27:41.192]                     }
[08:27:41.192]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.192]                   }
[08:27:41.192]                 }
[08:27:41.192]                 else {
[08:27:41.192]                   if (TRUE) {
[08:27:41.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.192]                     {
[08:27:41.192]                       inherits <- base::inherits
[08:27:41.192]                       invokeRestart <- base::invokeRestart
[08:27:41.192]                       is.null <- base::is.null
[08:27:41.192]                       muffled <- FALSE
[08:27:41.192]                       if (inherits(cond, "message")) {
[08:27:41.192]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.192]                         if (muffled) 
[08:27:41.192]                           invokeRestart("muffleMessage")
[08:27:41.192]                       }
[08:27:41.192]                       else if (inherits(cond, "warning")) {
[08:27:41.192]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.192]                         if (muffled) 
[08:27:41.192]                           invokeRestart("muffleWarning")
[08:27:41.192]                       }
[08:27:41.192]                       else if (inherits(cond, "condition")) {
[08:27:41.192]                         if (!is.null(pattern)) {
[08:27:41.192]                           computeRestarts <- base::computeRestarts
[08:27:41.192]                           grepl <- base::grepl
[08:27:41.192]                           restarts <- computeRestarts(cond)
[08:27:41.192]                           for (restart in restarts) {
[08:27:41.192]                             name <- restart$name
[08:27:41.192]                             if (is.null(name)) 
[08:27:41.192]                               next
[08:27:41.192]                             if (!grepl(pattern, name)) 
[08:27:41.192]                               next
[08:27:41.192]                             invokeRestart(restart)
[08:27:41.192]                             muffled <- TRUE
[08:27:41.192]                             break
[08:27:41.192]                           }
[08:27:41.192]                         }
[08:27:41.192]                       }
[08:27:41.192]                       invisible(muffled)
[08:27:41.192]                     }
[08:27:41.192]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.192]                   }
[08:27:41.192]                 }
[08:27:41.192]             }
[08:27:41.192]         }))
[08:27:41.192]     }, error = function(ex) {
[08:27:41.192]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.192]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.192]                 ...future.rng), started = ...future.startTime, 
[08:27:41.192]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.192]             version = "1.8"), class = "FutureResult")
[08:27:41.192]     }, finally = {
[08:27:41.192]         if (!identical(...future.workdir, getwd())) 
[08:27:41.192]             setwd(...future.workdir)
[08:27:41.192]         {
[08:27:41.192]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.192]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.192]             }
[08:27:41.192]             base::options(...future.oldOptions)
[08:27:41.192]             if (.Platform$OS.type == "windows") {
[08:27:41.192]                 old_names <- names(...future.oldEnvVars)
[08:27:41.192]                 envs <- base::Sys.getenv()
[08:27:41.192]                 names <- names(envs)
[08:27:41.192]                 common <- intersect(names, old_names)
[08:27:41.192]                 added <- setdiff(names, old_names)
[08:27:41.192]                 removed <- setdiff(old_names, names)
[08:27:41.192]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.192]                   envs[common]]
[08:27:41.192]                 NAMES <- toupper(changed)
[08:27:41.192]                 args <- list()
[08:27:41.192]                 for (kk in seq_along(NAMES)) {
[08:27:41.192]                   name <- changed[[kk]]
[08:27:41.192]                   NAME <- NAMES[[kk]]
[08:27:41.192]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.192]                     next
[08:27:41.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.192]                 }
[08:27:41.192]                 NAMES <- toupper(added)
[08:27:41.192]                 for (kk in seq_along(NAMES)) {
[08:27:41.192]                   name <- added[[kk]]
[08:27:41.192]                   NAME <- NAMES[[kk]]
[08:27:41.192]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.192]                     next
[08:27:41.192]                   args[[name]] <- ""
[08:27:41.192]                 }
[08:27:41.192]                 NAMES <- toupper(removed)
[08:27:41.192]                 for (kk in seq_along(NAMES)) {
[08:27:41.192]                   name <- removed[[kk]]
[08:27:41.192]                   NAME <- NAMES[[kk]]
[08:27:41.192]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.192]                     next
[08:27:41.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.192]                 }
[08:27:41.192]                 if (length(args) > 0) 
[08:27:41.192]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.192]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.192]             }
[08:27:41.192]             else {
[08:27:41.192]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.192]             }
[08:27:41.192]             {
[08:27:41.192]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.192]                   0L) {
[08:27:41.192]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.192]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.192]                   base::options(opts)
[08:27:41.192]                 }
[08:27:41.192]                 {
[08:27:41.192]                   {
[08:27:41.192]                     NULL
[08:27:41.192]                     RNGkind("Mersenne-Twister")
[08:27:41.192]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:41.192]                       inherits = FALSE)
[08:27:41.192]                   }
[08:27:41.192]                   options(future.plan = NULL)
[08:27:41.192]                   if (is.na(NA_character_)) 
[08:27:41.192]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.192]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.192]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.192]                     .init = FALSE)
[08:27:41.192]                 }
[08:27:41.192]             }
[08:27:41.192]         }
[08:27:41.192]     })
[08:27:41.192]     if (TRUE) {
[08:27:41.192]         base::sink(type = "output", split = FALSE)
[08:27:41.192]         if (TRUE) {
[08:27:41.192]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.192]         }
[08:27:41.192]         else {
[08:27:41.192]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.192]         }
[08:27:41.192]         base::close(...future.stdout)
[08:27:41.192]         ...future.stdout <- NULL
[08:27:41.192]     }
[08:27:41.192]     ...future.result$conditions <- ...future.conditions
[08:27:41.192]     ...future.result$finished <- base::Sys.time()
[08:27:41.192]     ...future.result
[08:27:41.192] }
[08:27:41.193] assign_globals() ...
[08:27:41.194] List of 1
[08:27:41.194]  $ ii: int 2
[08:27:41.194]  - attr(*, "where")=List of 1
[08:27:41.194]   ..$ ii:<environment: R_EmptyEnv> 
[08:27:41.194]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:41.194]  - attr(*, "resolved")= logi FALSE
[08:27:41.194]  - attr(*, "total_size")= num 35
[08:27:41.194]  - attr(*, "already-done")= logi TRUE
[08:27:41.196] - copied ‘ii’ to environment
[08:27:41.196] assign_globals() ... done
[08:27:41.196] plan(): Setting new future strategy stack:
[08:27:41.196] List of future strategies:
[08:27:41.196] 1. sequential:
[08:27:41.196]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.196]    - tweaked: FALSE
[08:27:41.196]    - call: NULL
[08:27:41.197] plan(): nbrOfWorkers() = 1
[08:27:41.198] plan(): Setting new future strategy stack:
[08:27:41.198] List of future strategies:
[08:27:41.198] 1. sequential:
[08:27:41.198]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.198]    - tweaked: FALSE
[08:27:41.198]    - call: plan(strategy)
[08:27:41.198] plan(): nbrOfWorkers() = 1
[08:27:41.198] SequentialFuture started (and completed)
[08:27:41.199] signalConditions() ...
[08:27:41.199]  - include = ‘immediateCondition’
[08:27:41.199]  - exclude = 
[08:27:41.199]  - resignal = FALSE
[08:27:41.199]  - Number of conditions: 1
[08:27:41.199] signalConditions() ... done
[08:27:41.199] - Launch lazy future ... done
[08:27:41.199] run() for ‘SequentialFuture’ ... done
[08:27:41.200] getGlobalsAndPackages() ...
[08:27:41.200] Searching for globals...
[08:27:41.201] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[08:27:41.201] Searching for globals ... DONE
[08:27:41.201] Resolving globals: FALSE
[08:27:41.202] The total size of the 1 globals is 35 bytes (35 bytes)
[08:27:41.202] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:27:41.202] - globals: [1] ‘ii’
[08:27:41.202] 
[08:27:41.202] getGlobalsAndPackages() ... DONE
[08:27:41.203] run() for ‘Future’ ...
[08:27:41.203] - state: ‘created’
[08:27:41.203] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:41.203] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:41.203] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:41.203]   - Field: ‘label’
[08:27:41.203]   - Field: ‘local’
[08:27:41.203]   - Field: ‘owner’
[08:27:41.203]   - Field: ‘envir’
[08:27:41.204]   - Field: ‘packages’
[08:27:41.204]   - Field: ‘gc’
[08:27:41.204]   - Field: ‘conditions’
[08:27:41.204]   - Field: ‘expr’
[08:27:41.204]   - Field: ‘uuid’
[08:27:41.204]   - Field: ‘seed’
[08:27:41.204]   - Field: ‘version’
[08:27:41.204]   - Field: ‘result’
[08:27:41.204]   - Field: ‘asynchronous’
[08:27:41.204]   - Field: ‘calls’
[08:27:41.204]   - Field: ‘globals’
[08:27:41.204]   - Field: ‘stdout’
[08:27:41.205]   - Field: ‘earlySignal’
[08:27:41.205]   - Field: ‘lazy’
[08:27:41.205]   - Field: ‘state’
[08:27:41.205] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:41.205] - Launch lazy future ...
[08:27:41.205] Packages needed by the future expression (n = 0): <none>
[08:27:41.205] Packages needed by future strategies (n = 0): <none>
[08:27:41.206] {
[08:27:41.206]     {
[08:27:41.206]         {
[08:27:41.206]             ...future.startTime <- base::Sys.time()
[08:27:41.206]             {
[08:27:41.206]                 {
[08:27:41.206]                   {
[08:27:41.206]                     base::local({
[08:27:41.206]                       has_future <- base::requireNamespace("future", 
[08:27:41.206]                         quietly = TRUE)
[08:27:41.206]                       if (has_future) {
[08:27:41.206]                         ns <- base::getNamespace("future")
[08:27:41.206]                         version <- ns[[".package"]][["version"]]
[08:27:41.206]                         if (is.null(version)) 
[08:27:41.206]                           version <- utils::packageVersion("future")
[08:27:41.206]                       }
[08:27:41.206]                       else {
[08:27:41.206]                         version <- NULL
[08:27:41.206]                       }
[08:27:41.206]                       if (!has_future || version < "1.8.0") {
[08:27:41.206]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.206]                           "", base::R.version$version.string), 
[08:27:41.206]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:41.206]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.206]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.206]                             "release", "version")], collapse = " "), 
[08:27:41.206]                           hostname = base::Sys.info()[["nodename"]])
[08:27:41.206]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.206]                           info)
[08:27:41.206]                         info <- base::paste(info, collapse = "; ")
[08:27:41.206]                         if (!has_future) {
[08:27:41.206]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.206]                             info)
[08:27:41.206]                         }
[08:27:41.206]                         else {
[08:27:41.206]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.206]                             info, version)
[08:27:41.206]                         }
[08:27:41.206]                         base::stop(msg)
[08:27:41.206]                       }
[08:27:41.206]                     })
[08:27:41.206]                   }
[08:27:41.206]                   ...future.strategy.old <- future::plan("list")
[08:27:41.206]                   options(future.plan = NULL)
[08:27:41.206]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.206]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.206]                 }
[08:27:41.206]                 ...future.workdir <- getwd()
[08:27:41.206]             }
[08:27:41.206]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.206]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.206]         }
[08:27:41.206]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.206]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.206]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.206]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.206]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.206]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.206]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.206]             base::names(...future.oldOptions))
[08:27:41.206]     }
[08:27:41.206]     if (FALSE) {
[08:27:41.206]     }
[08:27:41.206]     else {
[08:27:41.206]         if (TRUE) {
[08:27:41.206]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.206]                 open = "w")
[08:27:41.206]         }
[08:27:41.206]         else {
[08:27:41.206]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.206]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.206]         }
[08:27:41.206]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.206]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.206]             base::sink(type = "output", split = FALSE)
[08:27:41.206]             base::close(...future.stdout)
[08:27:41.206]         }, add = TRUE)
[08:27:41.206]     }
[08:27:41.206]     ...future.frame <- base::sys.nframe()
[08:27:41.206]     ...future.conditions <- base::list()
[08:27:41.206]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.206]     if (FALSE) {
[08:27:41.206]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.206]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.206]     }
[08:27:41.206]     ...future.result <- base::tryCatch({
[08:27:41.206]         base::withCallingHandlers({
[08:27:41.206]             ...future.value <- base::withVisible(base::local({
[08:27:41.206]                 if (ii%%2 == 0) 
[08:27:41.206]                   stop("Woops!")
[08:27:41.206]                 ii
[08:27:41.206]             }))
[08:27:41.206]             future::FutureResult(value = ...future.value$value, 
[08:27:41.206]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.206]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.206]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.206]                     ...future.globalenv.names))
[08:27:41.206]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.206]         }, condition = base::local({
[08:27:41.206]             c <- base::c
[08:27:41.206]             inherits <- base::inherits
[08:27:41.206]             invokeRestart <- base::invokeRestart
[08:27:41.206]             length <- base::length
[08:27:41.206]             list <- base::list
[08:27:41.206]             seq.int <- base::seq.int
[08:27:41.206]             signalCondition <- base::signalCondition
[08:27:41.206]             sys.calls <- base::sys.calls
[08:27:41.206]             `[[` <- base::`[[`
[08:27:41.206]             `+` <- base::`+`
[08:27:41.206]             `<<-` <- base::`<<-`
[08:27:41.206]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.206]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.206]                   3L)]
[08:27:41.206]             }
[08:27:41.206]             function(cond) {
[08:27:41.206]                 is_error <- inherits(cond, "error")
[08:27:41.206]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.206]                   NULL)
[08:27:41.206]                 if (is_error) {
[08:27:41.206]                   sessionInformation <- function() {
[08:27:41.206]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.206]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.206]                       search = base::search(), system = base::Sys.info())
[08:27:41.206]                   }
[08:27:41.206]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.206]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.206]                     cond$call), session = sessionInformation(), 
[08:27:41.206]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.206]                   signalCondition(cond)
[08:27:41.206]                 }
[08:27:41.206]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.206]                 "immediateCondition"))) {
[08:27:41.206]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.206]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.206]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.206]                   if (TRUE && !signal) {
[08:27:41.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.206]                     {
[08:27:41.206]                       inherits <- base::inherits
[08:27:41.206]                       invokeRestart <- base::invokeRestart
[08:27:41.206]                       is.null <- base::is.null
[08:27:41.206]                       muffled <- FALSE
[08:27:41.206]                       if (inherits(cond, "message")) {
[08:27:41.206]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.206]                         if (muffled) 
[08:27:41.206]                           invokeRestart("muffleMessage")
[08:27:41.206]                       }
[08:27:41.206]                       else if (inherits(cond, "warning")) {
[08:27:41.206]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.206]                         if (muffled) 
[08:27:41.206]                           invokeRestart("muffleWarning")
[08:27:41.206]                       }
[08:27:41.206]                       else if (inherits(cond, "condition")) {
[08:27:41.206]                         if (!is.null(pattern)) {
[08:27:41.206]                           computeRestarts <- base::computeRestarts
[08:27:41.206]                           grepl <- base::grepl
[08:27:41.206]                           restarts <- computeRestarts(cond)
[08:27:41.206]                           for (restart in restarts) {
[08:27:41.206]                             name <- restart$name
[08:27:41.206]                             if (is.null(name)) 
[08:27:41.206]                               next
[08:27:41.206]                             if (!grepl(pattern, name)) 
[08:27:41.206]                               next
[08:27:41.206]                             invokeRestart(restart)
[08:27:41.206]                             muffled <- TRUE
[08:27:41.206]                             break
[08:27:41.206]                           }
[08:27:41.206]                         }
[08:27:41.206]                       }
[08:27:41.206]                       invisible(muffled)
[08:27:41.206]                     }
[08:27:41.206]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.206]                   }
[08:27:41.206]                 }
[08:27:41.206]                 else {
[08:27:41.206]                   if (TRUE) {
[08:27:41.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.206]                     {
[08:27:41.206]                       inherits <- base::inherits
[08:27:41.206]                       invokeRestart <- base::invokeRestart
[08:27:41.206]                       is.null <- base::is.null
[08:27:41.206]                       muffled <- FALSE
[08:27:41.206]                       if (inherits(cond, "message")) {
[08:27:41.206]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.206]                         if (muffled) 
[08:27:41.206]                           invokeRestart("muffleMessage")
[08:27:41.206]                       }
[08:27:41.206]                       else if (inherits(cond, "warning")) {
[08:27:41.206]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.206]                         if (muffled) 
[08:27:41.206]                           invokeRestart("muffleWarning")
[08:27:41.206]                       }
[08:27:41.206]                       else if (inherits(cond, "condition")) {
[08:27:41.206]                         if (!is.null(pattern)) {
[08:27:41.206]                           computeRestarts <- base::computeRestarts
[08:27:41.206]                           grepl <- base::grepl
[08:27:41.206]                           restarts <- computeRestarts(cond)
[08:27:41.206]                           for (restart in restarts) {
[08:27:41.206]                             name <- restart$name
[08:27:41.206]                             if (is.null(name)) 
[08:27:41.206]                               next
[08:27:41.206]                             if (!grepl(pattern, name)) 
[08:27:41.206]                               next
[08:27:41.206]                             invokeRestart(restart)
[08:27:41.206]                             muffled <- TRUE
[08:27:41.206]                             break
[08:27:41.206]                           }
[08:27:41.206]                         }
[08:27:41.206]                       }
[08:27:41.206]                       invisible(muffled)
[08:27:41.206]                     }
[08:27:41.206]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.206]                   }
[08:27:41.206]                 }
[08:27:41.206]             }
[08:27:41.206]         }))
[08:27:41.206]     }, error = function(ex) {
[08:27:41.206]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.206]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.206]                 ...future.rng), started = ...future.startTime, 
[08:27:41.206]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.206]             version = "1.8"), class = "FutureResult")
[08:27:41.206]     }, finally = {
[08:27:41.206]         if (!identical(...future.workdir, getwd())) 
[08:27:41.206]             setwd(...future.workdir)
[08:27:41.206]         {
[08:27:41.206]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.206]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.206]             }
[08:27:41.206]             base::options(...future.oldOptions)
[08:27:41.206]             if (.Platform$OS.type == "windows") {
[08:27:41.206]                 old_names <- names(...future.oldEnvVars)
[08:27:41.206]                 envs <- base::Sys.getenv()
[08:27:41.206]                 names <- names(envs)
[08:27:41.206]                 common <- intersect(names, old_names)
[08:27:41.206]                 added <- setdiff(names, old_names)
[08:27:41.206]                 removed <- setdiff(old_names, names)
[08:27:41.206]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.206]                   envs[common]]
[08:27:41.206]                 NAMES <- toupper(changed)
[08:27:41.206]                 args <- list()
[08:27:41.206]                 for (kk in seq_along(NAMES)) {
[08:27:41.206]                   name <- changed[[kk]]
[08:27:41.206]                   NAME <- NAMES[[kk]]
[08:27:41.206]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.206]                     next
[08:27:41.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.206]                 }
[08:27:41.206]                 NAMES <- toupper(added)
[08:27:41.206]                 for (kk in seq_along(NAMES)) {
[08:27:41.206]                   name <- added[[kk]]
[08:27:41.206]                   NAME <- NAMES[[kk]]
[08:27:41.206]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.206]                     next
[08:27:41.206]                   args[[name]] <- ""
[08:27:41.206]                 }
[08:27:41.206]                 NAMES <- toupper(removed)
[08:27:41.206]                 for (kk in seq_along(NAMES)) {
[08:27:41.206]                   name <- removed[[kk]]
[08:27:41.206]                   NAME <- NAMES[[kk]]
[08:27:41.206]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.206]                     next
[08:27:41.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.206]                 }
[08:27:41.206]                 if (length(args) > 0) 
[08:27:41.206]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.206]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.206]             }
[08:27:41.206]             else {
[08:27:41.206]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.206]             }
[08:27:41.206]             {
[08:27:41.206]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.206]                   0L) {
[08:27:41.206]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.206]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.206]                   base::options(opts)
[08:27:41.206]                 }
[08:27:41.206]                 {
[08:27:41.206]                   {
[08:27:41.206]                     NULL
[08:27:41.206]                     RNGkind("Mersenne-Twister")
[08:27:41.206]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:41.206]                       inherits = FALSE)
[08:27:41.206]                   }
[08:27:41.206]                   options(future.plan = NULL)
[08:27:41.206]                   if (is.na(NA_character_)) 
[08:27:41.206]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.206]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.206]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.206]                     .init = FALSE)
[08:27:41.206]                 }
[08:27:41.206]             }
[08:27:41.206]         }
[08:27:41.206]     })
[08:27:41.206]     if (TRUE) {
[08:27:41.206]         base::sink(type = "output", split = FALSE)
[08:27:41.206]         if (TRUE) {
[08:27:41.206]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.206]         }
[08:27:41.206]         else {
[08:27:41.206]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.206]         }
[08:27:41.206]         base::close(...future.stdout)
[08:27:41.206]         ...future.stdout <- NULL
[08:27:41.206]     }
[08:27:41.206]     ...future.result$conditions <- ...future.conditions
[08:27:41.206]     ...future.result$finished <- base::Sys.time()
[08:27:41.206]     ...future.result
[08:27:41.206] }
[08:27:41.207] assign_globals() ...
[08:27:41.207] List of 1
[08:27:41.207]  $ ii: int 3
[08:27:41.207]  - attr(*, "where")=List of 1
[08:27:41.207]   ..$ ii:<environment: R_EmptyEnv> 
[08:27:41.207]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:41.207]  - attr(*, "resolved")= logi FALSE
[08:27:41.207]  - attr(*, "total_size")= num 35
[08:27:41.207]  - attr(*, "already-done")= logi TRUE
[08:27:41.211] - copied ‘ii’ to environment
[08:27:41.212] assign_globals() ... done
[08:27:41.212] plan(): Setting new future strategy stack:
[08:27:41.212] List of future strategies:
[08:27:41.212] 1. sequential:
[08:27:41.212]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.212]    - tweaked: FALSE
[08:27:41.212]    - call: NULL
[08:27:41.212] plan(): nbrOfWorkers() = 1
[08:27:41.213] plan(): Setting new future strategy stack:
[08:27:41.213] List of future strategies:
[08:27:41.213] 1. sequential:
[08:27:41.213]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.213]    - tweaked: FALSE
[08:27:41.213]    - call: plan(strategy)
[08:27:41.214] plan(): nbrOfWorkers() = 1
[08:27:41.214] SequentialFuture started (and completed)
[08:27:41.214] - Launch lazy future ... done
[08:27:41.214] run() for ‘SequentialFuture’ ... done
[08:27:41.214] signalConditions() ...
[08:27:41.214]  - include = ‘immediateCondition’
[08:27:41.214]  - exclude = 
[08:27:41.215]  - resignal = FALSE
[08:27:41.215]  - Number of conditions: 1
[08:27:41.215] signalConditions() ... done
[08:27:41.215] Future state: ‘finished’
[08:27:41.215] signalConditions() ...
[08:27:41.215]  - include = ‘condition’
[08:27:41.215]  - exclude = ‘immediateCondition’
[08:27:41.215]  - resignal = TRUE
[08:27:41.215]  - Number of conditions: 1
[08:27:41.215]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:27:41.216] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[08:27:41.217] signalConditions() ...
[08:27:41.217]  - include = ‘immediateCondition’
[08:27:41.217]  - exclude = 
[08:27:41.217]  - resignal = FALSE
[08:27:41.217]  - Number of conditions: 1
[08:27:41.217] signalConditions() ... done
[08:27:41.217] Future state: ‘finished’
[08:27:41.217] signalConditions() ...
[08:27:41.217]  - include = ‘condition’
[08:27:41.217]  - exclude = ‘immediateCondition’
[08:27:41.217]  - resignal = TRUE
[08:27:41.217]  - Number of conditions: 1
[08:27:41.218]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:27:41.218] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[08:27:41.218] signalConditions() ...
[08:27:41.218]  - include = ‘immediateCondition’
[08:27:41.218]  - exclude = 
[08:27:41.218]  - resignal = FALSE
[08:27:41.218]  - Number of conditions: 1
[08:27:41.218] signalConditions() ... done
[08:27:41.219] Future state: ‘finished’
[08:27:41.219] signalConditions() ...
[08:27:41.219]  - include = ‘condition’
[08:27:41.219]  - exclude = ‘immediateCondition’
[08:27:41.219]  - resignal = TRUE
[08:27:41.219]  - Number of conditions: 1
[08:27:41.219]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:27:41.219] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[08:27:41.219] getGlobalsAndPackages() ...
[08:27:41.220] Searching for globals...
[08:27:41.221] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[08:27:41.222] Searching for globals ... DONE
[08:27:41.222] Resolving globals: FALSE
[08:27:41.222] 
[08:27:41.222] 
[08:27:41.222] getGlobalsAndPackages() ... DONE
[08:27:41.222] run() for ‘Future’ ...
[08:27:41.222] - state: ‘created’
[08:27:41.223] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:41.223] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:41.223] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:41.223]   - Field: ‘label’
[08:27:41.223]   - Field: ‘local’
[08:27:41.223]   - Field: ‘owner’
[08:27:41.223]   - Field: ‘envir’
[08:27:41.223]   - Field: ‘packages’
[08:27:41.223]   - Field: ‘gc’
[08:27:41.224]   - Field: ‘conditions’
[08:27:41.224]   - Field: ‘expr’
[08:27:41.224]   - Field: ‘uuid’
[08:27:41.224]   - Field: ‘seed’
[08:27:41.224]   - Field: ‘version’
[08:27:41.224]   - Field: ‘result’
[08:27:41.224]   - Field: ‘asynchronous’
[08:27:41.224]   - Field: ‘calls’
[08:27:41.224]   - Field: ‘globals’
[08:27:41.224]   - Field: ‘stdout’
[08:27:41.224]   - Field: ‘earlySignal’
[08:27:41.224]   - Field: ‘lazy’
[08:27:41.225]   - Field: ‘state’
[08:27:41.225] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:41.225] - Launch lazy future ...
[08:27:41.225] Packages needed by the future expression (n = 0): <none>
[08:27:41.225] Packages needed by future strategies (n = 0): <none>
[08:27:41.225] {
[08:27:41.225]     {
[08:27:41.225]         {
[08:27:41.225]             ...future.startTime <- base::Sys.time()
[08:27:41.225]             {
[08:27:41.225]                 {
[08:27:41.225]                   {
[08:27:41.225]                     base::local({
[08:27:41.225]                       has_future <- base::requireNamespace("future", 
[08:27:41.225]                         quietly = TRUE)
[08:27:41.225]                       if (has_future) {
[08:27:41.225]                         ns <- base::getNamespace("future")
[08:27:41.225]                         version <- ns[[".package"]][["version"]]
[08:27:41.225]                         if (is.null(version)) 
[08:27:41.225]                           version <- utils::packageVersion("future")
[08:27:41.225]                       }
[08:27:41.225]                       else {
[08:27:41.225]                         version <- NULL
[08:27:41.225]                       }
[08:27:41.225]                       if (!has_future || version < "1.8.0") {
[08:27:41.225]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.225]                           "", base::R.version$version.string), 
[08:27:41.225]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:41.225]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.225]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.225]                             "release", "version")], collapse = " "), 
[08:27:41.225]                           hostname = base::Sys.info()[["nodename"]])
[08:27:41.225]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.225]                           info)
[08:27:41.225]                         info <- base::paste(info, collapse = "; ")
[08:27:41.225]                         if (!has_future) {
[08:27:41.225]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.225]                             info)
[08:27:41.225]                         }
[08:27:41.225]                         else {
[08:27:41.225]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.225]                             info, version)
[08:27:41.225]                         }
[08:27:41.225]                         base::stop(msg)
[08:27:41.225]                       }
[08:27:41.225]                     })
[08:27:41.225]                   }
[08:27:41.225]                   ...future.strategy.old <- future::plan("list")
[08:27:41.225]                   options(future.plan = NULL)
[08:27:41.225]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.225]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.225]                 }
[08:27:41.225]                 ...future.workdir <- getwd()
[08:27:41.225]             }
[08:27:41.225]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.225]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.225]         }
[08:27:41.225]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.225]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.225]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.225]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.225]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.225]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.225]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.225]             base::names(...future.oldOptions))
[08:27:41.225]     }
[08:27:41.225]     if (FALSE) {
[08:27:41.225]     }
[08:27:41.225]     else {
[08:27:41.225]         if (TRUE) {
[08:27:41.225]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.225]                 open = "w")
[08:27:41.225]         }
[08:27:41.225]         else {
[08:27:41.225]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.225]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.225]         }
[08:27:41.225]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.225]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.225]             base::sink(type = "output", split = FALSE)
[08:27:41.225]             base::close(...future.stdout)
[08:27:41.225]         }, add = TRUE)
[08:27:41.225]     }
[08:27:41.225]     ...future.frame <- base::sys.nframe()
[08:27:41.225]     ...future.conditions <- base::list()
[08:27:41.225]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.225]     if (FALSE) {
[08:27:41.225]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.225]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.225]     }
[08:27:41.225]     ...future.result <- base::tryCatch({
[08:27:41.225]         base::withCallingHandlers({
[08:27:41.225]             ...future.value <- base::withVisible(base::local({
[08:27:41.225]                 cat("Processing: ")
[08:27:41.225]                 for (ii in 1:10) {
[08:27:41.225]                   cat(".")
[08:27:41.225]                 }
[08:27:41.225]                 cat(" [100%]\n")
[08:27:41.225]                 4
[08:27:41.225]             }))
[08:27:41.225]             future::FutureResult(value = ...future.value$value, 
[08:27:41.225]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.225]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.225]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.225]                     ...future.globalenv.names))
[08:27:41.225]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.225]         }, condition = base::local({
[08:27:41.225]             c <- base::c
[08:27:41.225]             inherits <- base::inherits
[08:27:41.225]             invokeRestart <- base::invokeRestart
[08:27:41.225]             length <- base::length
[08:27:41.225]             list <- base::list
[08:27:41.225]             seq.int <- base::seq.int
[08:27:41.225]             signalCondition <- base::signalCondition
[08:27:41.225]             sys.calls <- base::sys.calls
[08:27:41.225]             `[[` <- base::`[[`
[08:27:41.225]             `+` <- base::`+`
[08:27:41.225]             `<<-` <- base::`<<-`
[08:27:41.225]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.225]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.225]                   3L)]
[08:27:41.225]             }
[08:27:41.225]             function(cond) {
[08:27:41.225]                 is_error <- inherits(cond, "error")
[08:27:41.225]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.225]                   NULL)
[08:27:41.225]                 if (is_error) {
[08:27:41.225]                   sessionInformation <- function() {
[08:27:41.225]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.225]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.225]                       search = base::search(), system = base::Sys.info())
[08:27:41.225]                   }
[08:27:41.225]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.225]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.225]                     cond$call), session = sessionInformation(), 
[08:27:41.225]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.225]                   signalCondition(cond)
[08:27:41.225]                 }
[08:27:41.225]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.225]                 "immediateCondition"))) {
[08:27:41.225]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.225]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.225]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.225]                   if (TRUE && !signal) {
[08:27:41.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.225]                     {
[08:27:41.225]                       inherits <- base::inherits
[08:27:41.225]                       invokeRestart <- base::invokeRestart
[08:27:41.225]                       is.null <- base::is.null
[08:27:41.225]                       muffled <- FALSE
[08:27:41.225]                       if (inherits(cond, "message")) {
[08:27:41.225]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.225]                         if (muffled) 
[08:27:41.225]                           invokeRestart("muffleMessage")
[08:27:41.225]                       }
[08:27:41.225]                       else if (inherits(cond, "warning")) {
[08:27:41.225]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.225]                         if (muffled) 
[08:27:41.225]                           invokeRestart("muffleWarning")
[08:27:41.225]                       }
[08:27:41.225]                       else if (inherits(cond, "condition")) {
[08:27:41.225]                         if (!is.null(pattern)) {
[08:27:41.225]                           computeRestarts <- base::computeRestarts
[08:27:41.225]                           grepl <- base::grepl
[08:27:41.225]                           restarts <- computeRestarts(cond)
[08:27:41.225]                           for (restart in restarts) {
[08:27:41.225]                             name <- restart$name
[08:27:41.225]                             if (is.null(name)) 
[08:27:41.225]                               next
[08:27:41.225]                             if (!grepl(pattern, name)) 
[08:27:41.225]                               next
[08:27:41.225]                             invokeRestart(restart)
[08:27:41.225]                             muffled <- TRUE
[08:27:41.225]                             break
[08:27:41.225]                           }
[08:27:41.225]                         }
[08:27:41.225]                       }
[08:27:41.225]                       invisible(muffled)
[08:27:41.225]                     }
[08:27:41.225]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.225]                   }
[08:27:41.225]                 }
[08:27:41.225]                 else {
[08:27:41.225]                   if (TRUE) {
[08:27:41.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.225]                     {
[08:27:41.225]                       inherits <- base::inherits
[08:27:41.225]                       invokeRestart <- base::invokeRestart
[08:27:41.225]                       is.null <- base::is.null
[08:27:41.225]                       muffled <- FALSE
[08:27:41.225]                       if (inherits(cond, "message")) {
[08:27:41.225]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.225]                         if (muffled) 
[08:27:41.225]                           invokeRestart("muffleMessage")
[08:27:41.225]                       }
[08:27:41.225]                       else if (inherits(cond, "warning")) {
[08:27:41.225]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.225]                         if (muffled) 
[08:27:41.225]                           invokeRestart("muffleWarning")
[08:27:41.225]                       }
[08:27:41.225]                       else if (inherits(cond, "condition")) {
[08:27:41.225]                         if (!is.null(pattern)) {
[08:27:41.225]                           computeRestarts <- base::computeRestarts
[08:27:41.225]                           grepl <- base::grepl
[08:27:41.225]                           restarts <- computeRestarts(cond)
[08:27:41.225]                           for (restart in restarts) {
[08:27:41.225]                             name <- restart$name
[08:27:41.225]                             if (is.null(name)) 
[08:27:41.225]                               next
[08:27:41.225]                             if (!grepl(pattern, name)) 
[08:27:41.225]                               next
[08:27:41.225]                             invokeRestart(restart)
[08:27:41.225]                             muffled <- TRUE
[08:27:41.225]                             break
[08:27:41.225]                           }
[08:27:41.225]                         }
[08:27:41.225]                       }
[08:27:41.225]                       invisible(muffled)
[08:27:41.225]                     }
[08:27:41.225]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.225]                   }
[08:27:41.225]                 }
[08:27:41.225]             }
[08:27:41.225]         }))
[08:27:41.225]     }, error = function(ex) {
[08:27:41.225]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.225]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.225]                 ...future.rng), started = ...future.startTime, 
[08:27:41.225]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.225]             version = "1.8"), class = "FutureResult")
[08:27:41.225]     }, finally = {
[08:27:41.225]         if (!identical(...future.workdir, getwd())) 
[08:27:41.225]             setwd(...future.workdir)
[08:27:41.225]         {
[08:27:41.225]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.225]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.225]             }
[08:27:41.225]             base::options(...future.oldOptions)
[08:27:41.225]             if (.Platform$OS.type == "windows") {
[08:27:41.225]                 old_names <- names(...future.oldEnvVars)
[08:27:41.225]                 envs <- base::Sys.getenv()
[08:27:41.225]                 names <- names(envs)
[08:27:41.225]                 common <- intersect(names, old_names)
[08:27:41.225]                 added <- setdiff(names, old_names)
[08:27:41.225]                 removed <- setdiff(old_names, names)
[08:27:41.225]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.225]                   envs[common]]
[08:27:41.225]                 NAMES <- toupper(changed)
[08:27:41.225]                 args <- list()
[08:27:41.225]                 for (kk in seq_along(NAMES)) {
[08:27:41.225]                   name <- changed[[kk]]
[08:27:41.225]                   NAME <- NAMES[[kk]]
[08:27:41.225]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.225]                     next
[08:27:41.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.225]                 }
[08:27:41.225]                 NAMES <- toupper(added)
[08:27:41.225]                 for (kk in seq_along(NAMES)) {
[08:27:41.225]                   name <- added[[kk]]
[08:27:41.225]                   NAME <- NAMES[[kk]]
[08:27:41.225]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.225]                     next
[08:27:41.225]                   args[[name]] <- ""
[08:27:41.225]                 }
[08:27:41.225]                 NAMES <- toupper(removed)
[08:27:41.225]                 for (kk in seq_along(NAMES)) {
[08:27:41.225]                   name <- removed[[kk]]
[08:27:41.225]                   NAME <- NAMES[[kk]]
[08:27:41.225]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.225]                     next
[08:27:41.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.225]                 }
[08:27:41.225]                 if (length(args) > 0) 
[08:27:41.225]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.225]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.225]             }
[08:27:41.225]             else {
[08:27:41.225]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.225]             }
[08:27:41.225]             {
[08:27:41.225]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.225]                   0L) {
[08:27:41.225]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.225]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.225]                   base::options(opts)
[08:27:41.225]                 }
[08:27:41.225]                 {
[08:27:41.225]                   {
[08:27:41.225]                     NULL
[08:27:41.225]                     RNGkind("Mersenne-Twister")
[08:27:41.225]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:41.225]                       inherits = FALSE)
[08:27:41.225]                   }
[08:27:41.225]                   options(future.plan = NULL)
[08:27:41.225]                   if (is.na(NA_character_)) 
[08:27:41.225]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.225]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.225]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.225]                     .init = FALSE)
[08:27:41.225]                 }
[08:27:41.225]             }
[08:27:41.225]         }
[08:27:41.225]     })
[08:27:41.225]     if (TRUE) {
[08:27:41.225]         base::sink(type = "output", split = FALSE)
[08:27:41.225]         if (TRUE) {
[08:27:41.225]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.225]         }
[08:27:41.225]         else {
[08:27:41.225]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.225]         }
[08:27:41.225]         base::close(...future.stdout)
[08:27:41.225]         ...future.stdout <- NULL
[08:27:41.225]     }
[08:27:41.225]     ...future.result$conditions <- ...future.conditions
[08:27:41.225]     ...future.result$finished <- base::Sys.time()
[08:27:41.225]     ...future.result
[08:27:41.225] }
[08:27:41.227] plan(): Setting new future strategy stack:
[08:27:41.227] List of future strategies:
[08:27:41.227] 1. sequential:
[08:27:41.227]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.227]    - tweaked: FALSE
[08:27:41.227]    - call: NULL
[08:27:41.228] plan(): nbrOfWorkers() = 1
[08:27:41.229] plan(): Setting new future strategy stack:
[08:27:41.229] List of future strategies:
[08:27:41.229] 1. sequential:
[08:27:41.229]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.229]    - tweaked: FALSE
[08:27:41.229]    - call: plan(strategy)
[08:27:41.229] plan(): nbrOfWorkers() = 1
[08:27:41.229] SequentialFuture started (and completed)
[08:27:41.229] - Launch lazy future ... done
[08:27:41.229] run() for ‘SequentialFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[08:27:41.231] signalConditions() ...
[08:27:41.231]  - include = ‘immediateCondition’
[08:27:41.231]  - exclude = 
[08:27:41.231]  - resignal = FALSE
[08:27:41.231]  - Number of conditions: 1
[08:27:41.231] signalConditions() ... done
[08:27:41.231] Future state: ‘finished’
[08:27:41.231] signalConditions() ...
[08:27:41.232]  - include = ‘condition’
[08:27:41.232]  - exclude = ‘immediateCondition’
[08:27:41.232]  - resignal = TRUE
[08:27:41.232]  - Number of conditions: 1
[08:27:41.232]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:27:41.232] signalConditions() ... done
v3: <simpleError> (as expect)
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[08:27:41.232] getGlobalsAndPackages() ...
[08:27:41.232] Searching for globals...
[08:27:41.233] 
[08:27:41.233] Searching for globals ... DONE
[08:27:41.233] - globals: [0] <none>
[08:27:41.233] getGlobalsAndPackages() ... DONE
[08:27:41.233] run() for ‘Future’ ...
[08:27:41.233] - state: ‘created’
[08:27:41.233] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:41.234] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:41.234] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:41.234]   - Field: ‘label’
[08:27:41.234]   - Field: ‘local’
[08:27:41.236]   - Field: ‘owner’
[08:27:41.236]   - Field: ‘envir’
[08:27:41.236]   - Field: ‘packages’
[08:27:41.236]   - Field: ‘gc’
[08:27:41.236]   - Field: ‘conditions’
[08:27:41.236]   - Field: ‘expr’
[08:27:41.236]   - Field: ‘uuid’
[08:27:41.236]   - Field: ‘seed’
[08:27:41.236]   - Field: ‘version’
[08:27:41.237]   - Field: ‘result’
[08:27:41.237]   - Field: ‘asynchronous’
[08:27:41.237]   - Field: ‘calls’
[08:27:41.237]   - Field: ‘globals’
[08:27:41.237]   - Field: ‘stdout’
[08:27:41.237]   - Field: ‘earlySignal’
[08:27:41.237]   - Field: ‘lazy’
[08:27:41.237]   - Field: ‘state’
[08:27:41.237] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:41.237] - Launch lazy future ...
[08:27:41.238] Packages needed by the future expression (n = 0): <none>
[08:27:41.238] Packages needed by future strategies (n = 0): <none>
[08:27:41.238] {
[08:27:41.238]     {
[08:27:41.238]         {
[08:27:41.238]             ...future.startTime <- base::Sys.time()
[08:27:41.238]             {
[08:27:41.238]                 {
[08:27:41.238]                   {
[08:27:41.238]                     base::local({
[08:27:41.238]                       has_future <- base::requireNamespace("future", 
[08:27:41.238]                         quietly = TRUE)
[08:27:41.238]                       if (has_future) {
[08:27:41.238]                         ns <- base::getNamespace("future")
[08:27:41.238]                         version <- ns[[".package"]][["version"]]
[08:27:41.238]                         if (is.null(version)) 
[08:27:41.238]                           version <- utils::packageVersion("future")
[08:27:41.238]                       }
[08:27:41.238]                       else {
[08:27:41.238]                         version <- NULL
[08:27:41.238]                       }
[08:27:41.238]                       if (!has_future || version < "1.8.0") {
[08:27:41.238]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.238]                           "", base::R.version$version.string), 
[08:27:41.238]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:41.238]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.238]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.238]                             "release", "version")], collapse = " "), 
[08:27:41.238]                           hostname = base::Sys.info()[["nodename"]])
[08:27:41.238]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.238]                           info)
[08:27:41.238]                         info <- base::paste(info, collapse = "; ")
[08:27:41.238]                         if (!has_future) {
[08:27:41.238]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.238]                             info)
[08:27:41.238]                         }
[08:27:41.238]                         else {
[08:27:41.238]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.238]                             info, version)
[08:27:41.238]                         }
[08:27:41.238]                         base::stop(msg)
[08:27:41.238]                       }
[08:27:41.238]                     })
[08:27:41.238]                   }
[08:27:41.238]                   ...future.strategy.old <- future::plan("list")
[08:27:41.238]                   options(future.plan = NULL)
[08:27:41.238]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.238]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.238]                 }
[08:27:41.238]                 ...future.workdir <- getwd()
[08:27:41.238]             }
[08:27:41.238]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.238]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.238]         }
[08:27:41.238]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.238]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.238]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.238]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.238]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.238]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.238]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.238]             base::names(...future.oldOptions))
[08:27:41.238]     }
[08:27:41.238]     if (FALSE) {
[08:27:41.238]     }
[08:27:41.238]     else {
[08:27:41.238]         if (TRUE) {
[08:27:41.238]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.238]                 open = "w")
[08:27:41.238]         }
[08:27:41.238]         else {
[08:27:41.238]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.238]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.238]         }
[08:27:41.238]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.238]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.238]             base::sink(type = "output", split = FALSE)
[08:27:41.238]             base::close(...future.stdout)
[08:27:41.238]         }, add = TRUE)
[08:27:41.238]     }
[08:27:41.238]     ...future.frame <- base::sys.nframe()
[08:27:41.238]     ...future.conditions <- base::list()
[08:27:41.238]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.238]     if (FALSE) {
[08:27:41.238]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.238]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.238]     }
[08:27:41.238]     ...future.result <- base::tryCatch({
[08:27:41.238]         base::withCallingHandlers({
[08:27:41.238]             ...future.value <- base::withVisible(base::local(1))
[08:27:41.238]             future::FutureResult(value = ...future.value$value, 
[08:27:41.238]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.238]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.238]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.238]                     ...future.globalenv.names))
[08:27:41.238]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.238]         }, condition = base::local({
[08:27:41.238]             c <- base::c
[08:27:41.238]             inherits <- base::inherits
[08:27:41.238]             invokeRestart <- base::invokeRestart
[08:27:41.238]             length <- base::length
[08:27:41.238]             list <- base::list
[08:27:41.238]             seq.int <- base::seq.int
[08:27:41.238]             signalCondition <- base::signalCondition
[08:27:41.238]             sys.calls <- base::sys.calls
[08:27:41.238]             `[[` <- base::`[[`
[08:27:41.238]             `+` <- base::`+`
[08:27:41.238]             `<<-` <- base::`<<-`
[08:27:41.238]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.238]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.238]                   3L)]
[08:27:41.238]             }
[08:27:41.238]             function(cond) {
[08:27:41.238]                 is_error <- inherits(cond, "error")
[08:27:41.238]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.238]                   NULL)
[08:27:41.238]                 if (is_error) {
[08:27:41.238]                   sessionInformation <- function() {
[08:27:41.238]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.238]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.238]                       search = base::search(), system = base::Sys.info())
[08:27:41.238]                   }
[08:27:41.238]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.238]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.238]                     cond$call), session = sessionInformation(), 
[08:27:41.238]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.238]                   signalCondition(cond)
[08:27:41.238]                 }
[08:27:41.238]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.238]                 "immediateCondition"))) {
[08:27:41.238]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.238]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.238]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.238]                   if (TRUE && !signal) {
[08:27:41.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.238]                     {
[08:27:41.238]                       inherits <- base::inherits
[08:27:41.238]                       invokeRestart <- base::invokeRestart
[08:27:41.238]                       is.null <- base::is.null
[08:27:41.238]                       muffled <- FALSE
[08:27:41.238]                       if (inherits(cond, "message")) {
[08:27:41.238]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.238]                         if (muffled) 
[08:27:41.238]                           invokeRestart("muffleMessage")
[08:27:41.238]                       }
[08:27:41.238]                       else if (inherits(cond, "warning")) {
[08:27:41.238]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.238]                         if (muffled) 
[08:27:41.238]                           invokeRestart("muffleWarning")
[08:27:41.238]                       }
[08:27:41.238]                       else if (inherits(cond, "condition")) {
[08:27:41.238]                         if (!is.null(pattern)) {
[08:27:41.238]                           computeRestarts <- base::computeRestarts
[08:27:41.238]                           grepl <- base::grepl
[08:27:41.238]                           restarts <- computeRestarts(cond)
[08:27:41.238]                           for (restart in restarts) {
[08:27:41.238]                             name <- restart$name
[08:27:41.238]                             if (is.null(name)) 
[08:27:41.238]                               next
[08:27:41.238]                             if (!grepl(pattern, name)) 
[08:27:41.238]                               next
[08:27:41.238]                             invokeRestart(restart)
[08:27:41.238]                             muffled <- TRUE
[08:27:41.238]                             break
[08:27:41.238]                           }
[08:27:41.238]                         }
[08:27:41.238]                       }
[08:27:41.238]                       invisible(muffled)
[08:27:41.238]                     }
[08:27:41.238]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.238]                   }
[08:27:41.238]                 }
[08:27:41.238]                 else {
[08:27:41.238]                   if (TRUE) {
[08:27:41.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.238]                     {
[08:27:41.238]                       inherits <- base::inherits
[08:27:41.238]                       invokeRestart <- base::invokeRestart
[08:27:41.238]                       is.null <- base::is.null
[08:27:41.238]                       muffled <- FALSE
[08:27:41.238]                       if (inherits(cond, "message")) {
[08:27:41.238]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.238]                         if (muffled) 
[08:27:41.238]                           invokeRestart("muffleMessage")
[08:27:41.238]                       }
[08:27:41.238]                       else if (inherits(cond, "warning")) {
[08:27:41.238]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.238]                         if (muffled) 
[08:27:41.238]                           invokeRestart("muffleWarning")
[08:27:41.238]                       }
[08:27:41.238]                       else if (inherits(cond, "condition")) {
[08:27:41.238]                         if (!is.null(pattern)) {
[08:27:41.238]                           computeRestarts <- base::computeRestarts
[08:27:41.238]                           grepl <- base::grepl
[08:27:41.238]                           restarts <- computeRestarts(cond)
[08:27:41.238]                           for (restart in restarts) {
[08:27:41.238]                             name <- restart$name
[08:27:41.238]                             if (is.null(name)) 
[08:27:41.238]                               next
[08:27:41.238]                             if (!grepl(pattern, name)) 
[08:27:41.238]                               next
[08:27:41.238]                             invokeRestart(restart)
[08:27:41.238]                             muffled <- TRUE
[08:27:41.238]                             break
[08:27:41.238]                           }
[08:27:41.238]                         }
[08:27:41.238]                       }
[08:27:41.238]                       invisible(muffled)
[08:27:41.238]                     }
[08:27:41.238]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.238]                   }
[08:27:41.238]                 }
[08:27:41.238]             }
[08:27:41.238]         }))
[08:27:41.238]     }, error = function(ex) {
[08:27:41.238]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.238]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.238]                 ...future.rng), started = ...future.startTime, 
[08:27:41.238]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.238]             version = "1.8"), class = "FutureResult")
[08:27:41.238]     }, finally = {
[08:27:41.238]         if (!identical(...future.workdir, getwd())) 
[08:27:41.238]             setwd(...future.workdir)
[08:27:41.238]         {
[08:27:41.238]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.238]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.238]             }
[08:27:41.238]             base::options(...future.oldOptions)
[08:27:41.238]             if (.Platform$OS.type == "windows") {
[08:27:41.238]                 old_names <- names(...future.oldEnvVars)
[08:27:41.238]                 envs <- base::Sys.getenv()
[08:27:41.238]                 names <- names(envs)
[08:27:41.238]                 common <- intersect(names, old_names)
[08:27:41.238]                 added <- setdiff(names, old_names)
[08:27:41.238]                 removed <- setdiff(old_names, names)
[08:27:41.238]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.238]                   envs[common]]
[08:27:41.238]                 NAMES <- toupper(changed)
[08:27:41.238]                 args <- list()
[08:27:41.238]                 for (kk in seq_along(NAMES)) {
[08:27:41.238]                   name <- changed[[kk]]
[08:27:41.238]                   NAME <- NAMES[[kk]]
[08:27:41.238]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.238]                     next
[08:27:41.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.238]                 }
[08:27:41.238]                 NAMES <- toupper(added)
[08:27:41.238]                 for (kk in seq_along(NAMES)) {
[08:27:41.238]                   name <- added[[kk]]
[08:27:41.238]                   NAME <- NAMES[[kk]]
[08:27:41.238]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.238]                     next
[08:27:41.238]                   args[[name]] <- ""
[08:27:41.238]                 }
[08:27:41.238]                 NAMES <- toupper(removed)
[08:27:41.238]                 for (kk in seq_along(NAMES)) {
[08:27:41.238]                   name <- removed[[kk]]
[08:27:41.238]                   NAME <- NAMES[[kk]]
[08:27:41.238]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.238]                     next
[08:27:41.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.238]                 }
[08:27:41.238]                 if (length(args) > 0) 
[08:27:41.238]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.238]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.238]             }
[08:27:41.238]             else {
[08:27:41.238]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.238]             }
[08:27:41.238]             {
[08:27:41.238]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.238]                   0L) {
[08:27:41.238]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.238]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.238]                   base::options(opts)
[08:27:41.238]                 }
[08:27:41.238]                 {
[08:27:41.238]                   {
[08:27:41.238]                     NULL
[08:27:41.238]                     RNGkind("Mersenne-Twister")
[08:27:41.238]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:41.238]                       inherits = FALSE)
[08:27:41.238]                   }
[08:27:41.238]                   options(future.plan = NULL)
[08:27:41.238]                   if (is.na(NA_character_)) 
[08:27:41.238]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.238]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.238]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.238]                     .init = FALSE)
[08:27:41.238]                 }
[08:27:41.238]             }
[08:27:41.238]         }
[08:27:41.238]     })
[08:27:41.238]     if (TRUE) {
[08:27:41.238]         base::sink(type = "output", split = FALSE)
[08:27:41.238]         if (TRUE) {
[08:27:41.238]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.238]         }
[08:27:41.238]         else {
[08:27:41.238]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.238]         }
[08:27:41.238]         base::close(...future.stdout)
[08:27:41.238]         ...future.stdout <- NULL
[08:27:41.238]     }
[08:27:41.238]     ...future.result$conditions <- ...future.conditions
[08:27:41.238]     ...future.result$finished <- base::Sys.time()
[08:27:41.238]     ...future.result
[08:27:41.238] }
[08:27:41.240] plan(): Setting new future strategy stack:
[08:27:41.240] List of future strategies:
[08:27:41.240] 1. sequential:
[08:27:41.240]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.240]    - tweaked: FALSE
[08:27:41.240]    - call: NULL
[08:27:41.240] plan(): nbrOfWorkers() = 1
[08:27:41.241] plan(): Setting new future strategy stack:
[08:27:41.241] List of future strategies:
[08:27:41.241] 1. sequential:
[08:27:41.241]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.241]    - tweaked: FALSE
[08:27:41.241]    - call: plan(strategy)
[08:27:41.242] plan(): nbrOfWorkers() = 1
[08:27:41.242] SequentialFuture started (and completed)
[08:27:41.242] - Launch lazy future ... done
[08:27:41.242] run() for ‘SequentialFuture’ ... done
c = 1
[08:27:41.242] getGlobalsAndPackages() ...
[08:27:41.242] Searching for globals...
[08:27:41.243] 
[08:27:41.243] Searching for globals ... DONE
[08:27:41.243] - globals: [0] <none>
[08:27:41.243] getGlobalsAndPackages() ... DONE
[08:27:41.243] run() for ‘Future’ ...
[08:27:41.243] - state: ‘created’
[08:27:41.243] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:41.244] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:41.244] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:41.244]   - Field: ‘label’
[08:27:41.244]   - Field: ‘local’
[08:27:41.244]   - Field: ‘owner’
[08:27:41.244]   - Field: ‘envir’
[08:27:41.244]   - Field: ‘packages’
[08:27:41.244]   - Field: ‘gc’
[08:27:41.244]   - Field: ‘conditions’
[08:27:41.245]   - Field: ‘expr’
[08:27:41.245]   - Field: ‘uuid’
[08:27:41.245]   - Field: ‘seed’
[08:27:41.245]   - Field: ‘version’
[08:27:41.245]   - Field: ‘result’
[08:27:41.245]   - Field: ‘asynchronous’
[08:27:41.245]   - Field: ‘calls’
[08:27:41.245]   - Field: ‘globals’
[08:27:41.245]   - Field: ‘stdout’
[08:27:41.245]   - Field: ‘earlySignal’
[08:27:41.245]   - Field: ‘lazy’
[08:27:41.245]   - Field: ‘state’
[08:27:41.246] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:41.246] - Launch lazy future ...
[08:27:41.246] Packages needed by the future expression (n = 0): <none>
[08:27:41.246] Packages needed by future strategies (n = 0): <none>
[08:27:41.246] {
[08:27:41.246]     {
[08:27:41.246]         {
[08:27:41.246]             ...future.startTime <- base::Sys.time()
[08:27:41.246]             {
[08:27:41.246]                 {
[08:27:41.246]                   {
[08:27:41.246]                     base::local({
[08:27:41.246]                       has_future <- base::requireNamespace("future", 
[08:27:41.246]                         quietly = TRUE)
[08:27:41.246]                       if (has_future) {
[08:27:41.246]                         ns <- base::getNamespace("future")
[08:27:41.246]                         version <- ns[[".package"]][["version"]]
[08:27:41.246]                         if (is.null(version)) 
[08:27:41.246]                           version <- utils::packageVersion("future")
[08:27:41.246]                       }
[08:27:41.246]                       else {
[08:27:41.246]                         version <- NULL
[08:27:41.246]                       }
[08:27:41.246]                       if (!has_future || version < "1.8.0") {
[08:27:41.246]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.246]                           "", base::R.version$version.string), 
[08:27:41.246]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:41.246]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.246]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.246]                             "release", "version")], collapse = " "), 
[08:27:41.246]                           hostname = base::Sys.info()[["nodename"]])
[08:27:41.246]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.246]                           info)
[08:27:41.246]                         info <- base::paste(info, collapse = "; ")
[08:27:41.246]                         if (!has_future) {
[08:27:41.246]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.246]                             info)
[08:27:41.246]                         }
[08:27:41.246]                         else {
[08:27:41.246]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.246]                             info, version)
[08:27:41.246]                         }
[08:27:41.246]                         base::stop(msg)
[08:27:41.246]                       }
[08:27:41.246]                     })
[08:27:41.246]                   }
[08:27:41.246]                   ...future.strategy.old <- future::plan("list")
[08:27:41.246]                   options(future.plan = NULL)
[08:27:41.246]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.246]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.246]                 }
[08:27:41.246]                 ...future.workdir <- getwd()
[08:27:41.246]             }
[08:27:41.246]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.246]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.246]         }
[08:27:41.246]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.246]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.246]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.246]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.246]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.246]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.246]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.246]             base::names(...future.oldOptions))
[08:27:41.246]     }
[08:27:41.246]     if (FALSE) {
[08:27:41.246]     }
[08:27:41.246]     else {
[08:27:41.246]         if (TRUE) {
[08:27:41.246]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.246]                 open = "w")
[08:27:41.246]         }
[08:27:41.246]         else {
[08:27:41.246]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.246]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.246]         }
[08:27:41.246]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.246]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.246]             base::sink(type = "output", split = FALSE)
[08:27:41.246]             base::close(...future.stdout)
[08:27:41.246]         }, add = TRUE)
[08:27:41.246]     }
[08:27:41.246]     ...future.frame <- base::sys.nframe()
[08:27:41.246]     ...future.conditions <- base::list()
[08:27:41.246]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.246]     if (FALSE) {
[08:27:41.246]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.246]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.246]     }
[08:27:41.246]     ...future.result <- base::tryCatch({
[08:27:41.246]         base::withCallingHandlers({
[08:27:41.246]             ...future.value <- base::withVisible(base::local(1))
[08:27:41.246]             future::FutureResult(value = ...future.value$value, 
[08:27:41.246]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.246]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.246]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.246]                     ...future.globalenv.names))
[08:27:41.246]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.246]         }, condition = base::local({
[08:27:41.246]             c <- base::c
[08:27:41.246]             inherits <- base::inherits
[08:27:41.246]             invokeRestart <- base::invokeRestart
[08:27:41.246]             length <- base::length
[08:27:41.246]             list <- base::list
[08:27:41.246]             seq.int <- base::seq.int
[08:27:41.246]             signalCondition <- base::signalCondition
[08:27:41.246]             sys.calls <- base::sys.calls
[08:27:41.246]             `[[` <- base::`[[`
[08:27:41.246]             `+` <- base::`+`
[08:27:41.246]             `<<-` <- base::`<<-`
[08:27:41.246]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.246]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.246]                   3L)]
[08:27:41.246]             }
[08:27:41.246]             function(cond) {
[08:27:41.246]                 is_error <- inherits(cond, "error")
[08:27:41.246]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.246]                   NULL)
[08:27:41.246]                 if (is_error) {
[08:27:41.246]                   sessionInformation <- function() {
[08:27:41.246]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.246]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.246]                       search = base::search(), system = base::Sys.info())
[08:27:41.246]                   }
[08:27:41.246]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.246]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.246]                     cond$call), session = sessionInformation(), 
[08:27:41.246]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.246]                   signalCondition(cond)
[08:27:41.246]                 }
[08:27:41.246]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.246]                 "immediateCondition"))) {
[08:27:41.246]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.246]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.246]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.246]                   if (TRUE && !signal) {
[08:27:41.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.246]                     {
[08:27:41.246]                       inherits <- base::inherits
[08:27:41.246]                       invokeRestart <- base::invokeRestart
[08:27:41.246]                       is.null <- base::is.null
[08:27:41.246]                       muffled <- FALSE
[08:27:41.246]                       if (inherits(cond, "message")) {
[08:27:41.246]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.246]                         if (muffled) 
[08:27:41.246]                           invokeRestart("muffleMessage")
[08:27:41.246]                       }
[08:27:41.246]                       else if (inherits(cond, "warning")) {
[08:27:41.246]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.246]                         if (muffled) 
[08:27:41.246]                           invokeRestart("muffleWarning")
[08:27:41.246]                       }
[08:27:41.246]                       else if (inherits(cond, "condition")) {
[08:27:41.246]                         if (!is.null(pattern)) {
[08:27:41.246]                           computeRestarts <- base::computeRestarts
[08:27:41.246]                           grepl <- base::grepl
[08:27:41.246]                           restarts <- computeRestarts(cond)
[08:27:41.246]                           for (restart in restarts) {
[08:27:41.246]                             name <- restart$name
[08:27:41.246]                             if (is.null(name)) 
[08:27:41.246]                               next
[08:27:41.246]                             if (!grepl(pattern, name)) 
[08:27:41.246]                               next
[08:27:41.246]                             invokeRestart(restart)
[08:27:41.246]                             muffled <- TRUE
[08:27:41.246]                             break
[08:27:41.246]                           }
[08:27:41.246]                         }
[08:27:41.246]                       }
[08:27:41.246]                       invisible(muffled)
[08:27:41.246]                     }
[08:27:41.246]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.246]                   }
[08:27:41.246]                 }
[08:27:41.246]                 else {
[08:27:41.246]                   if (TRUE) {
[08:27:41.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.246]                     {
[08:27:41.246]                       inherits <- base::inherits
[08:27:41.246]                       invokeRestart <- base::invokeRestart
[08:27:41.246]                       is.null <- base::is.null
[08:27:41.246]                       muffled <- FALSE
[08:27:41.246]                       if (inherits(cond, "message")) {
[08:27:41.246]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.246]                         if (muffled) 
[08:27:41.246]                           invokeRestart("muffleMessage")
[08:27:41.246]                       }
[08:27:41.246]                       else if (inherits(cond, "warning")) {
[08:27:41.246]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.246]                         if (muffled) 
[08:27:41.246]                           invokeRestart("muffleWarning")
[08:27:41.246]                       }
[08:27:41.246]                       else if (inherits(cond, "condition")) {
[08:27:41.246]                         if (!is.null(pattern)) {
[08:27:41.246]                           computeRestarts <- base::computeRestarts
[08:27:41.246]                           grepl <- base::grepl
[08:27:41.246]                           restarts <- computeRestarts(cond)
[08:27:41.246]                           for (restart in restarts) {
[08:27:41.246]                             name <- restart$name
[08:27:41.246]                             if (is.null(name)) 
[08:27:41.246]                               next
[08:27:41.246]                             if (!grepl(pattern, name)) 
[08:27:41.246]                               next
[08:27:41.246]                             invokeRestart(restart)
[08:27:41.246]                             muffled <- TRUE
[08:27:41.246]                             break
[08:27:41.246]                           }
[08:27:41.246]                         }
[08:27:41.246]                       }
[08:27:41.246]                       invisible(muffled)
[08:27:41.246]                     }
[08:27:41.246]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.246]                   }
[08:27:41.246]                 }
[08:27:41.246]             }
[08:27:41.246]         }))
[08:27:41.246]     }, error = function(ex) {
[08:27:41.246]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.246]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.246]                 ...future.rng), started = ...future.startTime, 
[08:27:41.246]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.246]             version = "1.8"), class = "FutureResult")
[08:27:41.246]     }, finally = {
[08:27:41.246]         if (!identical(...future.workdir, getwd())) 
[08:27:41.246]             setwd(...future.workdir)
[08:27:41.246]         {
[08:27:41.246]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.246]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.246]             }
[08:27:41.246]             base::options(...future.oldOptions)
[08:27:41.246]             if (.Platform$OS.type == "windows") {
[08:27:41.246]                 old_names <- names(...future.oldEnvVars)
[08:27:41.246]                 envs <- base::Sys.getenv()
[08:27:41.246]                 names <- names(envs)
[08:27:41.246]                 common <- intersect(names, old_names)
[08:27:41.246]                 added <- setdiff(names, old_names)
[08:27:41.246]                 removed <- setdiff(old_names, names)
[08:27:41.246]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.246]                   envs[common]]
[08:27:41.246]                 NAMES <- toupper(changed)
[08:27:41.246]                 args <- list()
[08:27:41.246]                 for (kk in seq_along(NAMES)) {
[08:27:41.246]                   name <- changed[[kk]]
[08:27:41.246]                   NAME <- NAMES[[kk]]
[08:27:41.246]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.246]                     next
[08:27:41.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.246]                 }
[08:27:41.246]                 NAMES <- toupper(added)
[08:27:41.246]                 for (kk in seq_along(NAMES)) {
[08:27:41.246]                   name <- added[[kk]]
[08:27:41.246]                   NAME <- NAMES[[kk]]
[08:27:41.246]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.246]                     next
[08:27:41.246]                   args[[name]] <- ""
[08:27:41.246]                 }
[08:27:41.246]                 NAMES <- toupper(removed)
[08:27:41.246]                 for (kk in seq_along(NAMES)) {
[08:27:41.246]                   name <- removed[[kk]]
[08:27:41.246]                   NAME <- NAMES[[kk]]
[08:27:41.246]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.246]                     next
[08:27:41.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.246]                 }
[08:27:41.246]                 if (length(args) > 0) 
[08:27:41.246]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.246]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.246]             }
[08:27:41.246]             else {
[08:27:41.246]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.246]             }
[08:27:41.246]             {
[08:27:41.246]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.246]                   0L) {
[08:27:41.246]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.246]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.246]                   base::options(opts)
[08:27:41.246]                 }
[08:27:41.246]                 {
[08:27:41.246]                   {
[08:27:41.246]                     NULL
[08:27:41.246]                     RNGkind("Mersenne-Twister")
[08:27:41.246]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:41.246]                       inherits = FALSE)
[08:27:41.246]                   }
[08:27:41.246]                   options(future.plan = NULL)
[08:27:41.246]                   if (is.na(NA_character_)) 
[08:27:41.246]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.246]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.246]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.246]                     .init = FALSE)
[08:27:41.246]                 }
[08:27:41.246]             }
[08:27:41.246]         }
[08:27:41.246]     })
[08:27:41.246]     if (TRUE) {
[08:27:41.246]         base::sink(type = "output", split = FALSE)
[08:27:41.246]         if (TRUE) {
[08:27:41.246]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.246]         }
[08:27:41.246]         else {
[08:27:41.246]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.246]         }
[08:27:41.246]         base::close(...future.stdout)
[08:27:41.246]         ...future.stdout <- NULL
[08:27:41.246]     }
[08:27:41.246]     ...future.result$conditions <- ...future.conditions
[08:27:41.246]     ...future.result$finished <- base::Sys.time()
[08:27:41.246]     ...future.result
[08:27:41.246] }
[08:27:41.248] plan(): Setting new future strategy stack:
[08:27:41.248] List of future strategies:
[08:27:41.248] 1. sequential:
[08:27:41.248]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.248]    - tweaked: FALSE
[08:27:41.248]    - call: NULL
[08:27:41.249] plan(): nbrOfWorkers() = 1
[08:27:41.250] plan(): Setting new future strategy stack:
[08:27:41.250] List of future strategies:
[08:27:41.250] 1. sequential:
[08:27:41.250]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.250]    - tweaked: FALSE
[08:27:41.250]    - call: plan(strategy)
[08:27:41.250] plan(): nbrOfWorkers() = 1
[08:27:41.250] SequentialFuture started (and completed)
[08:27:41.250] - Launch lazy future ... done
[08:27:41.251] run() for ‘SequentialFuture’ ... done
d = 1
** Nested future assignments
[08:27:41.251] getGlobalsAndPackages() ...
[08:27:41.251] Searching for globals...
[08:27:41.255] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[08:27:41.255] Searching for globals ... DONE
[08:27:41.255] Resolving globals: FALSE
[08:27:41.256] 
[08:27:41.256] - packages: [1] ‘future’
[08:27:41.256] getGlobalsAndPackages() ... DONE
[08:27:41.256] run() for ‘Future’ ...
[08:27:41.256] - state: ‘created’
[08:27:41.256] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:41.257] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:41.257] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:41.257]   - Field: ‘label’
[08:27:41.257]   - Field: ‘local’
[08:27:41.257]   - Field: ‘owner’
[08:27:41.257]   - Field: ‘envir’
[08:27:41.257]   - Field: ‘packages’
[08:27:41.257]   - Field: ‘gc’
[08:27:41.257]   - Field: ‘conditions’
[08:27:41.257]   - Field: ‘expr’
[08:27:41.257]   - Field: ‘uuid’
[08:27:41.258]   - Field: ‘seed’
[08:27:41.258]   - Field: ‘version’
[08:27:41.258]   - Field: ‘result’
[08:27:41.258]   - Field: ‘asynchronous’
[08:27:41.258]   - Field: ‘calls’
[08:27:41.258]   - Field: ‘globals’
[08:27:41.258]   - Field: ‘stdout’
[08:27:41.258]   - Field: ‘earlySignal’
[08:27:41.258]   - Field: ‘lazy’
[08:27:41.258]   - Field: ‘state’
[08:27:41.258] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:41.259] - Launch lazy future ...
[08:27:41.259] Packages needed by the future expression (n = 1): ‘future’
[08:27:41.259] Packages needed by future strategies (n = 0): <none>
[08:27:41.259] {
[08:27:41.259]     {
[08:27:41.259]         {
[08:27:41.259]             ...future.startTime <- base::Sys.time()
[08:27:41.259]             {
[08:27:41.259]                 {
[08:27:41.259]                   {
[08:27:41.259]                     {
[08:27:41.259]                       base::local({
[08:27:41.259]                         has_future <- base::requireNamespace("future", 
[08:27:41.259]                           quietly = TRUE)
[08:27:41.259]                         if (has_future) {
[08:27:41.259]                           ns <- base::getNamespace("future")
[08:27:41.259]                           version <- ns[[".package"]][["version"]]
[08:27:41.259]                           if (is.null(version)) 
[08:27:41.259]                             version <- utils::packageVersion("future")
[08:27:41.259]                         }
[08:27:41.259]                         else {
[08:27:41.259]                           version <- NULL
[08:27:41.259]                         }
[08:27:41.259]                         if (!has_future || version < "1.8.0") {
[08:27:41.259]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.259]                             "", base::R.version$version.string), 
[08:27:41.259]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:41.259]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.259]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.259]                               "release", "version")], collapse = " "), 
[08:27:41.259]                             hostname = base::Sys.info()[["nodename"]])
[08:27:41.259]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.259]                             info)
[08:27:41.259]                           info <- base::paste(info, collapse = "; ")
[08:27:41.259]                           if (!has_future) {
[08:27:41.259]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.259]                               info)
[08:27:41.259]                           }
[08:27:41.259]                           else {
[08:27:41.259]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.259]                               info, version)
[08:27:41.259]                           }
[08:27:41.259]                           base::stop(msg)
[08:27:41.259]                         }
[08:27:41.259]                       })
[08:27:41.259]                     }
[08:27:41.259]                     base::local({
[08:27:41.259]                       for (pkg in "future") {
[08:27:41.259]                         base::loadNamespace(pkg)
[08:27:41.259]                         base::library(pkg, character.only = TRUE)
[08:27:41.259]                       }
[08:27:41.259]                     })
[08:27:41.259]                   }
[08:27:41.259]                   ...future.strategy.old <- future::plan("list")
[08:27:41.259]                   options(future.plan = NULL)
[08:27:41.259]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.259]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.259]                 }
[08:27:41.259]                 ...future.workdir <- getwd()
[08:27:41.259]             }
[08:27:41.259]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.259]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.259]         }
[08:27:41.259]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.259]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.259]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.259]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.259]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.259]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.259]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.259]             base::names(...future.oldOptions))
[08:27:41.259]     }
[08:27:41.259]     if (FALSE) {
[08:27:41.259]     }
[08:27:41.259]     else {
[08:27:41.259]         if (TRUE) {
[08:27:41.259]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.259]                 open = "w")
[08:27:41.259]         }
[08:27:41.259]         else {
[08:27:41.259]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.259]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.259]         }
[08:27:41.259]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.259]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.259]             base::sink(type = "output", split = FALSE)
[08:27:41.259]             base::close(...future.stdout)
[08:27:41.259]         }, add = TRUE)
[08:27:41.259]     }
[08:27:41.259]     ...future.frame <- base::sys.nframe()
[08:27:41.259]     ...future.conditions <- base::list()
[08:27:41.259]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.259]     if (FALSE) {
[08:27:41.259]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.259]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.259]     }
[08:27:41.259]     ...future.result <- base::tryCatch({
[08:27:41.259]         base::withCallingHandlers({
[08:27:41.259]             ...future.value <- base::withVisible(base::local({
[08:27:41.259]                 b <- 1
[08:27:41.259]                 c %<-% 2
[08:27:41.259]                 d <- 3
[08:27:41.259]                 4 %->% e
[08:27:41.259]                 b + c + d + e
[08:27:41.259]             }))
[08:27:41.259]             future::FutureResult(value = ...future.value$value, 
[08:27:41.259]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.259]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.259]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.259]                     ...future.globalenv.names))
[08:27:41.259]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.259]         }, condition = base::local({
[08:27:41.259]             c <- base::c
[08:27:41.259]             inherits <- base::inherits
[08:27:41.259]             invokeRestart <- base::invokeRestart
[08:27:41.259]             length <- base::length
[08:27:41.259]             list <- base::list
[08:27:41.259]             seq.int <- base::seq.int
[08:27:41.259]             signalCondition <- base::signalCondition
[08:27:41.259]             sys.calls <- base::sys.calls
[08:27:41.259]             `[[` <- base::`[[`
[08:27:41.259]             `+` <- base::`+`
[08:27:41.259]             `<<-` <- base::`<<-`
[08:27:41.259]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.259]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.259]                   3L)]
[08:27:41.259]             }
[08:27:41.259]             function(cond) {
[08:27:41.259]                 is_error <- inherits(cond, "error")
[08:27:41.259]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.259]                   NULL)
[08:27:41.259]                 if (is_error) {
[08:27:41.259]                   sessionInformation <- function() {
[08:27:41.259]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.259]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.259]                       search = base::search(), system = base::Sys.info())
[08:27:41.259]                   }
[08:27:41.259]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.259]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.259]                     cond$call), session = sessionInformation(), 
[08:27:41.259]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.259]                   signalCondition(cond)
[08:27:41.259]                 }
[08:27:41.259]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.259]                 "immediateCondition"))) {
[08:27:41.259]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.259]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.259]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.259]                   if (TRUE && !signal) {
[08:27:41.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.259]                     {
[08:27:41.259]                       inherits <- base::inherits
[08:27:41.259]                       invokeRestart <- base::invokeRestart
[08:27:41.259]                       is.null <- base::is.null
[08:27:41.259]                       muffled <- FALSE
[08:27:41.259]                       if (inherits(cond, "message")) {
[08:27:41.259]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.259]                         if (muffled) 
[08:27:41.259]                           invokeRestart("muffleMessage")
[08:27:41.259]                       }
[08:27:41.259]                       else if (inherits(cond, "warning")) {
[08:27:41.259]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.259]                         if (muffled) 
[08:27:41.259]                           invokeRestart("muffleWarning")
[08:27:41.259]                       }
[08:27:41.259]                       else if (inherits(cond, "condition")) {
[08:27:41.259]                         if (!is.null(pattern)) {
[08:27:41.259]                           computeRestarts <- base::computeRestarts
[08:27:41.259]                           grepl <- base::grepl
[08:27:41.259]                           restarts <- computeRestarts(cond)
[08:27:41.259]                           for (restart in restarts) {
[08:27:41.259]                             name <- restart$name
[08:27:41.259]                             if (is.null(name)) 
[08:27:41.259]                               next
[08:27:41.259]                             if (!grepl(pattern, name)) 
[08:27:41.259]                               next
[08:27:41.259]                             invokeRestart(restart)
[08:27:41.259]                             muffled <- TRUE
[08:27:41.259]                             break
[08:27:41.259]                           }
[08:27:41.259]                         }
[08:27:41.259]                       }
[08:27:41.259]                       invisible(muffled)
[08:27:41.259]                     }
[08:27:41.259]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.259]                   }
[08:27:41.259]                 }
[08:27:41.259]                 else {
[08:27:41.259]                   if (TRUE) {
[08:27:41.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.259]                     {
[08:27:41.259]                       inherits <- base::inherits
[08:27:41.259]                       invokeRestart <- base::invokeRestart
[08:27:41.259]                       is.null <- base::is.null
[08:27:41.259]                       muffled <- FALSE
[08:27:41.259]                       if (inherits(cond, "message")) {
[08:27:41.259]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.259]                         if (muffled) 
[08:27:41.259]                           invokeRestart("muffleMessage")
[08:27:41.259]                       }
[08:27:41.259]                       else if (inherits(cond, "warning")) {
[08:27:41.259]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.259]                         if (muffled) 
[08:27:41.259]                           invokeRestart("muffleWarning")
[08:27:41.259]                       }
[08:27:41.259]                       else if (inherits(cond, "condition")) {
[08:27:41.259]                         if (!is.null(pattern)) {
[08:27:41.259]                           computeRestarts <- base::computeRestarts
[08:27:41.259]                           grepl <- base::grepl
[08:27:41.259]                           restarts <- computeRestarts(cond)
[08:27:41.259]                           for (restart in restarts) {
[08:27:41.259]                             name <- restart$name
[08:27:41.259]                             if (is.null(name)) 
[08:27:41.259]                               next
[08:27:41.259]                             if (!grepl(pattern, name)) 
[08:27:41.259]                               next
[08:27:41.259]                             invokeRestart(restart)
[08:27:41.259]                             muffled <- TRUE
[08:27:41.259]                             break
[08:27:41.259]                           }
[08:27:41.259]                         }
[08:27:41.259]                       }
[08:27:41.259]                       invisible(muffled)
[08:27:41.259]                     }
[08:27:41.259]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.259]                   }
[08:27:41.259]                 }
[08:27:41.259]             }
[08:27:41.259]         }))
[08:27:41.259]     }, error = function(ex) {
[08:27:41.259]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.259]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.259]                 ...future.rng), started = ...future.startTime, 
[08:27:41.259]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.259]             version = "1.8"), class = "FutureResult")
[08:27:41.259]     }, finally = {
[08:27:41.259]         if (!identical(...future.workdir, getwd())) 
[08:27:41.259]             setwd(...future.workdir)
[08:27:41.259]         {
[08:27:41.259]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.259]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.259]             }
[08:27:41.259]             base::options(...future.oldOptions)
[08:27:41.259]             if (.Platform$OS.type == "windows") {
[08:27:41.259]                 old_names <- names(...future.oldEnvVars)
[08:27:41.259]                 envs <- base::Sys.getenv()
[08:27:41.259]                 names <- names(envs)
[08:27:41.259]                 common <- intersect(names, old_names)
[08:27:41.259]                 added <- setdiff(names, old_names)
[08:27:41.259]                 removed <- setdiff(old_names, names)
[08:27:41.259]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.259]                   envs[common]]
[08:27:41.259]                 NAMES <- toupper(changed)
[08:27:41.259]                 args <- list()
[08:27:41.259]                 for (kk in seq_along(NAMES)) {
[08:27:41.259]                   name <- changed[[kk]]
[08:27:41.259]                   NAME <- NAMES[[kk]]
[08:27:41.259]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.259]                     next
[08:27:41.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.259]                 }
[08:27:41.259]                 NAMES <- toupper(added)
[08:27:41.259]                 for (kk in seq_along(NAMES)) {
[08:27:41.259]                   name <- added[[kk]]
[08:27:41.259]                   NAME <- NAMES[[kk]]
[08:27:41.259]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.259]                     next
[08:27:41.259]                   args[[name]] <- ""
[08:27:41.259]                 }
[08:27:41.259]                 NAMES <- toupper(removed)
[08:27:41.259]                 for (kk in seq_along(NAMES)) {
[08:27:41.259]                   name <- removed[[kk]]
[08:27:41.259]                   NAME <- NAMES[[kk]]
[08:27:41.259]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.259]                     next
[08:27:41.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.259]                 }
[08:27:41.259]                 if (length(args) > 0) 
[08:27:41.259]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.259]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.259]             }
[08:27:41.259]             else {
[08:27:41.259]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.259]             }
[08:27:41.259]             {
[08:27:41.259]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.259]                   0L) {
[08:27:41.259]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.259]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.259]                   base::options(opts)
[08:27:41.259]                 }
[08:27:41.259]                 {
[08:27:41.259]                   {
[08:27:41.259]                     NULL
[08:27:41.259]                     RNGkind("Mersenne-Twister")
[08:27:41.259]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:41.259]                       inherits = FALSE)
[08:27:41.259]                   }
[08:27:41.259]                   options(future.plan = NULL)
[08:27:41.259]                   if (is.na(NA_character_)) 
[08:27:41.259]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.259]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.259]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.259]                     .init = FALSE)
[08:27:41.259]                 }
[08:27:41.259]             }
[08:27:41.259]         }
[08:27:41.259]     })
[08:27:41.259]     if (TRUE) {
[08:27:41.259]         base::sink(type = "output", split = FALSE)
[08:27:41.259]         if (TRUE) {
[08:27:41.259]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.259]         }
[08:27:41.259]         else {
[08:27:41.259]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.259]         }
[08:27:41.259]         base::close(...future.stdout)
[08:27:41.259]         ...future.stdout <- NULL
[08:27:41.259]     }
[08:27:41.259]     ...future.result$conditions <- ...future.conditions
[08:27:41.259]     ...future.result$finished <- base::Sys.time()
[08:27:41.259]     ...future.result
[08:27:41.259] }
[08:27:41.261] plan(): Setting new future strategy stack:
[08:27:41.261] List of future strategies:
[08:27:41.261] 1. sequential:
[08:27:41.261]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.261]    - tweaked: FALSE
[08:27:41.261]    - call: NULL
[08:27:41.262] plan(): nbrOfWorkers() = 1
[08:27:41.299] plan(): Setting new future strategy stack:
[08:27:41.299] List of future strategies:
[08:27:41.299] 1. sequential:
[08:27:41.299]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.299]    - tweaked: FALSE
[08:27:41.299]    - call: plan(strategy)
[08:27:41.300] plan(): nbrOfWorkers() = 1
[08:27:41.300] SequentialFuture started (and completed)
[08:27:41.300] signalConditions() ...
[08:27:41.300]  - include = ‘immediateCondition’
[08:27:41.300]  - exclude = 
[08:27:41.300]  - resignal = FALSE
[08:27:41.300]  - Number of conditions: 88
[08:27:41.301] signalConditions() ... done
[08:27:41.301] - Launch lazy future ... done
[08:27:41.301] run() for ‘SequentialFuture’ ... done
[08:27:41.301] signalConditions() ...
[08:27:41.301]  - include = ‘immediateCondition’
[08:27:41.301]  - exclude = 
[08:27:41.301]  - resignal = FALSE
[08:27:41.301]  - Number of conditions: 88
[08:27:41.302] signalConditions() ... done
[08:27:41.302] Future state: ‘finished’
[08:27:41.302] signalConditions() ...
[08:27:41.302]  - include = ‘condition’
[08:27:41.302]  - exclude = ‘immediateCondition’
[08:27:41.302]  - resignal = TRUE
[08:27:41.302]  - Number of conditions: 88
[08:27:41.302]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.263] getGlobalsAndPackages() ...
[08:27:41.302]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.263] Searching for globals...
[08:27:41.302]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.279] 
[08:27:41.303]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.279] Searching for globals ... DONE
[08:27:41.303]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.279] - globals: [0] <none>
[08:27:41.303]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.280] getGlobalsAndPackages() ... DONE
[08:27:41.303]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.280] run() for ‘Future’ ...
[08:27:41.303]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.280] - state: ‘created’
[08:27:41.303]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.280] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:41.303]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.280] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:41.303]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.281] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:41.304]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.281]   - Field: ‘label’
[08:27:41.304]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.281]   - Field: ‘local’
[08:27:41.304]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.281]   - Field: ‘owner’
[08:27:41.304]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.281]   - Field: ‘envir’
[08:27:41.304]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.281]   - Field: ‘packages’
[08:27:41.304]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.281]   - Field: ‘gc’
[08:27:41.304]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.281]   - Field: ‘conditions’
[08:27:41.304]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.281]   - Field: ‘expr’
[08:27:41.304]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.282]   - Field: ‘uuid’
[08:27:41.305]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.282]   - Field: ‘seed’
[08:27:41.305]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.282]   - Field: ‘version’
[08:27:41.305]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.282]   - Field: ‘result’
[08:27:41.305]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.282]   - Field: ‘asynchronous’
[08:27:41.305]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.282]   - Field: ‘calls’
[08:27:41.305]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.282]   - Field: ‘globals’
[08:27:41.305]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.282]   - Field: ‘stdout’
[08:27:41.305]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.282]   - Field: ‘earlySignal’
[08:27:41.306]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.282]   - Field: ‘lazy’
[08:27:41.306]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.283]   - Field: ‘state’
[08:27:41.306]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.283] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:41.306]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.283] - Launch lazy future ...
[08:27:41.306]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.283] Packages needed by the future expression (n = 0): <none>
[08:27:41.306]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.283] Packages needed by future strategies (n = 0): <none>
[08:27:41.306]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.284] {
[08:27:41.284]     {
[08:27:41.284]         {
[08:27:41.284]             ...future.startTime <- base::Sys.time()
[08:27:41.284]             {
[08:27:41.284]                 {
[08:27:41.284]                   {
[08:27:41.284]                     base::local({
[08:27:41.284]                       has_future <- base::requireNamespace("future", 
[08:27:41.284]                         quietly = TRUE)
[08:27:41.284]                       if (has_future) {
[08:27:41.284]                         ns <- base::getNamespace("future")
[08:27:41.284]                         version <- ns[[".package"]][["version"]]
[08:27:41.284]                         if (is.null(version)) 
[08:27:41.284]                           version <- utils::packageVersion("future")
[08:27:41.284]                       }
[08:27:41.284]                       else {
[08:27:41.284]                         version <- NULL
[08:27:41.284]                       }
[08:27:41.284]                       if (!has_future || version < "1.8.0") {
[08:27:41.284]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.284]                           "", base::R.version$version.string), 
[08:27:41.284]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:41.284]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.284]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.284]                             "release", "version")], collapse = " "), 
[08:27:41.284]                           hostname = base::Sys.info()[["nodename"]])
[08:27:41.284]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.284]                           info)
[08:27:41.284]                         info <- base::paste(info, collapse = "; ")
[08:27:41.284]                         if (!has_future) {
[08:27:41.284]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.284]                             info)
[08:27:41.284]                         }
[08:27:41.284]                         else {
[08:27:41.284]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.284]                             info, version)
[08:27:41.284]                         }
[08:27:41.284]                         base::stop(msg)
[08:27:41.284]                       }
[08:27:41.284]                     })
[08:27:41.284]                   }
[08:27:41.284]                   ...future.strategy.old <- future::plan("list")
[08:27:41.284]                   options(future.plan = NULL)
[08:27:41.284]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.284]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.284]                 }
[08:27:41.284]                 ...future.workdir <- getwd()
[08:27:41.284]             }
[08:27:41.284]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.284]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.284]         }
[08:27:41.284]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.284]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.284]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.284]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.284]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.284]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.284]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.284]             base::names(...future.oldOptions))
[08:27:41.284]     }
[08:27:41.284]     if (FALSE) {
[08:27:41.284]     }
[08:27:41.284]     else {
[08:27:41.284]         if (TRUE) {
[08:27:41.284]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.284]                 open = "w")
[08:27:41.284]         }
[08:27:41.284]         else {
[08:27:41.284]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.284]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.284]         }
[08:27:41.284]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.284]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.284]             base::sink(type = "output", split = FALSE)
[08:27:41.284]             base::close(...future.stdout)
[08:27:41.284]         }, add = TRUE)
[08:27:41.284]     }
[08:27:41.284]     ...future.frame <- base::sys.nframe()
[08:27:41.284]     ...future.conditions <- base::list()
[08:27:41.284]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.284]     if (FALSE) {
[08:27:41.284]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.284]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.284]     }
[08:27:41.284]     ...future.result <- base::tryCatch({
[08:27:41.284]         base::withCallingHandlers({
[08:27:41.284]             ...future.value <- base::withVisible(base::local(2))
[08:27:41.284]             future::FutureResult(value = ...future.value$value, 
[08:27:41.284]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.284]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.284]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.284]                     ...future.globalenv.names))
[08:27:41.284]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.284]         }, condition = base::local({
[08:27:41.284]             c <- base::c
[08:27:41.284]             inherits <- base::inherits
[08:27:41.284]             invokeRestart <- base::invokeRestart
[08:27:41.284]             length <- base::length
[08:27:41.284]             list <- base::list
[08:27:41.284]             seq.int <- base::seq.int
[08:27:41.284]             signalCondition <- base::signalCondition
[08:27:41.284]             sys.calls <- base::sys.calls
[08:27:41.284]             `[[` <- base::`[[`
[08:27:41.284]             `+` <- base::`+`
[08:27:41.284]             `<<-` <- base::`<<-`
[08:27:41.284]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.284]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.284]                   3L)]
[08:27:41.284]             }
[08:27:41.284]             function(cond) {
[08:27:41.284]                 is_error <- inherits(cond, "error")
[08:27:41.284]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.284]                   NULL)
[08:27:41.284]                 if (is_error) {
[08:27:41.284]                   sessionInformation <- function() {
[08:27:41.284]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.284]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.284]                       search = base::search(), system = base::Sys.info())
[08:27:41.284]                   }
[08:27:41.284]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.284]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.284]                     cond$call), session = sessionInformation(), 
[08:27:41.284]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.284]                   signalCondition(cond)
[08:27:41.284]                 }
[08:27:41.284]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.284]                 "immediateCondition"))) {
[08:27:41.284]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.284]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.284]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.284]                   if (TRUE && !signal) {
[08:27:41.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.284]                     {
[08:27:41.284]                       inherits <- base::inherits
[08:27:41.284]                       invokeRestart <- base::invokeRestart
[08:27:41.284]                       is.null <- base::is.null
[08:27:41.284]                       muffled <- FALSE
[08:27:41.284]                       if (inherits(cond, "message")) {
[08:27:41.284]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.284]                         if (muffled) 
[08:27:41.284]                           invokeRestart("muffleMessage")
[08:27:41.284]                       }
[08:27:41.284]                       else if (inherits(cond, "warning")) {
[08:27:41.284]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.284]                         if (muffled) 
[08:27:41.284]                           invokeRestart("muffleWarning")
[08:27:41.284]                       }
[08:27:41.284]                       else if (inherits(cond, "condition")) {
[08:27:41.284]                         if (!is.null(pattern)) {
[08:27:41.284]                           computeRestarts <- base::computeRestarts
[08:27:41.284]                           grepl <- base::grepl
[08:27:41.284]                           restarts <- computeRestarts(cond)
[08:27:41.284]                           for (restart in restarts) {
[08:27:41.284]                             name <- restart$name
[08:27:41.284]                             if (is.null(name)) 
[08:27:41.284]                               next
[08:27:41.284]                             if (!grepl(pattern, name)) 
[08:27:41.284]                               next
[08:27:41.284]                             invokeRestart(restart)
[08:27:41.284]                             muffled <- TRUE
[08:27:41.284]                             break
[08:27:41.284]                           }
[08:27:41.284]                         }
[08:27:41.284]                       }
[08:27:41.284]                       invisible(muffled)
[08:27:41.284]                     }
[08:27:41.284]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.284]                   }
[08:27:41.284]                 }
[08:27:41.284]                 else {
[08:27:41.284]                   if (TRUE) {
[08:27:41.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.284]                     {
[08:27:41.284]                       inherits <- base::inherits
[08:27:41.284]                       invokeRestart <- base::invokeRestart
[08:27:41.284]                       is.null <- base::is.null
[08:27:41.284]                       muffled <- FALSE
[08:27:41.284]                       if (inherits(cond, "message")) {
[08:27:41.284]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.284]                         if (muffled) 
[08:27:41.284]                           invokeRestart("muffleMessage")
[08:27:41.284]                       }
[08:27:41.284]                       else if (inherits(cond, "warning")) {
[08:27:41.284]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.284]                         if (muffled) 
[08:27:41.284]                           invokeRestart("muffleWarning")
[08:27:41.284]                       }
[08:27:41.284]                       else if (inherits(cond, "condition")) {
[08:27:41.284]                         if (!is.null(pattern)) {
[08:27:41.284]                           computeRestarts <- base::computeRestarts
[08:27:41.284]                           grepl <- base::grepl
[08:27:41.284]                           restarts <- computeRestarts(cond)
[08:27:41.284]                           for (restart in restarts) {
[08:27:41.284]                             name <- restart$name
[08:27:41.284]                             if (is.null(name)) 
[08:27:41.284]                               next
[08:27:41.284]                             if (!grepl(pattern, name)) 
[08:27:41.284]                               next
[08:27:41.284]                             invokeRestart(restart)
[08:27:41.284]                             muffled <- TRUE
[08:27:41.284]                             break
[08:27:41.284]                           }
[08:27:41.284]                         }
[08:27:41.284]                       }
[08:27:41.284]                       invisible(muffled)
[08:27:41.284]                     }
[08:27:41.284]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.284]                   }
[08:27:41.284]                 }
[08:27:41.284]             }
[08:27:41.284]         }))
[08:27:41.284]     }, error = function(ex) {
[08:27:41.284]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.284]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.284]                 ...future.rng), started = ...future.startTime, 
[08:27:41.284]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.284]             version = "1.8"), class = "FutureResult")
[08:27:41.284]     }, finally = {
[08:27:41.284]         if (!identical(...future.workdir, getwd())) 
[08:27:41.284]             setwd(...future.workdir)
[08:27:41.284]         {
[08:27:41.284]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.284]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.284]             }
[08:27:41.284]             base::options(...future.oldOptions)
[08:27:41.284]             if (.Platform$OS.type == "windows") {
[08:27:41.284]                 old_names <- names(...future.oldEnvVars)
[08:27:41.284]                 envs <- base::Sys.getenv()
[08:27:41.284]                 names <- names(envs)
[08:27:41.284]                 common <- intersect(names, old_names)
[08:27:41.284]                 added <- setdiff(names, old_names)
[08:27:41.284]                 removed <- setdiff(old_names, names)
[08:27:41.284]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.284]                   envs[common]]
[08:27:41.284]                 NAMES <- toupper(changed)
[08:27:41.284]                 args <- list()
[08:27:41.284]                 for (kk in seq_along(NAMES)) {
[08:27:41.284]                   name <- changed[[kk]]
[08:27:41.284]                   NAME <- NAMES[[kk]]
[08:27:41.284]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.284]                     next
[08:27:41.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.284]                 }
[08:27:41.284]                 NAMES <- toupper(added)
[08:27:41.284]                 for (kk in seq_along(NAMES)) {
[08:27:41.284]                   name <- added[[kk]]
[08:27:41.284]                   NAME <- NAMES[[kk]]
[08:27:41.284]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.284]                     next
[08:27:41.284]                   args[[name]] <- ""
[08:27:41.284]                 }
[08:27:41.284]                 NAMES <- toupper(removed)
[08:27:41.284]                 for (kk in seq_along(NAMES)) {
[08:27:41.284]                   name <- removed[[kk]]
[08:27:41.284]                   NAME <- NAMES[[kk]]
[08:27:41.284]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.284]                     next
[08:27:41.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.284]                 }
[08:27:41.284]                 if (length(args) > 0) 
[08:27:41.284]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.284]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.284]             }
[08:27:41.284]             else {
[08:27:41.284]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.284]             }
[08:27:41.284]             {
[08:27:41.284]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.284]                   0L) {
[08:27:41.284]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.284]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.284]                   base::options(opts)
[08:27:41.284]                 }
[08:27:41.284]                 {
[08:27:41.284]                   {
[08:27:41.284]                     NULL
[08:27:41.284]                     RNGkind("Mersenne-Twister")
[08:27:41.284]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:41.284]                       inherits = FALSE)
[08:27:41.284]                   }
[08:27:41.284]                   options(future.plan = NULL)
[08:27:41.284]                   if (is.na(NA_character_)) 
[08:27:41.284]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.284]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.284]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.284]                     .init = FALSE)
[08:27:41.284]                 }
[08:27:41.284]             }
[08:27:41.284]         }
[08:27:41.284]     })
[08:27:41.284]     if (TRUE) {
[08:27:41.284]         base::sink(type = "output", split = FALSE)
[08:27:41.284]         if (TRUE) {
[08:27:41.284]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.284]         }
[08:27:41.284]         else {
[08:27:41.284]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.284]         }
[08:27:41.284]         base::close(...future.stdout)
[08:27:41.284]         ...future.stdout <- NULL
[08:27:41.284]     }
[08:27:41.284]     ...future.result$conditions <- ...future.conditions
[08:27:41.284]     ...future.result$finished <- base::Sys.time()
[08:27:41.284]     ...future.result
[08:27:41.284] }
[08:27:41.307]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.285] plan(): Setting new future strategy stack:
[08:27:41.307]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.285] List of future strategies:
[08:27:41.285] 1. sequential:
[08:27:41.285]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.285]    - tweaked: FALSE
[08:27:41.285]    - call: NULL
[08:27:41.307]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.286] plan(): nbrOfWorkers() = 1
[08:27:41.307]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.287] plan(): Setting new future strategy stack:
[08:27:41.307]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.287] List of future strategies:
[08:27:41.287] 1. sequential:
[08:27:41.287]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.287]    - tweaked: FALSE
[08:27:41.287]    - call: NULL
[08:27:41.307]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.289] plan(): nbrOfWorkers() = 1
[08:27:41.307]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.289] SequentialFuture started (and completed)
[08:27:41.307]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.290] - Launch lazy future ... done
[08:27:41.308]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.290] run() for ‘SequentialFuture’ ... done
[08:27:41.308]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.290] getGlobalsAndPackages() ...
[08:27:41.308]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.290] Searching for globals...
[08:27:41.308]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.291] 
[08:27:41.308]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.291] Searching for globals ... DONE
[08:27:41.308]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.291] - globals: [0] <none>
[08:27:41.308]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.291] getGlobalsAndPackages() ... DONE
[08:27:41.308]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.291] run() for ‘Future’ ...
[08:27:41.308]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.291] - state: ‘created’
[08:27:41.309]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.291] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:41.309]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.292] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:41.309]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.292] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:41.309]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.292]   - Field: ‘label’
[08:27:41.309]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.292]   - Field: ‘local’
[08:27:41.309]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.292]   - Field: ‘owner’
[08:27:41.309]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.292]   - Field: ‘envir’
[08:27:41.309]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.292]   - Field: ‘packages’
[08:27:41.310]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.292]   - Field: ‘gc’
[08:27:41.310]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.293]   - Field: ‘conditions’
[08:27:41.310]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.293]   - Field: ‘expr’
[08:27:41.310]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.293]   - Field: ‘uuid’
[08:27:41.310]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.293]   - Field: ‘seed’
[08:27:41.310]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.293]   - Field: ‘version’
[08:27:41.310]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.293]   - Field: ‘result’
[08:27:41.310]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.293]   - Field: ‘asynchronous’
[08:27:41.311]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.293]   - Field: ‘calls’
[08:27:41.311]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.293]   - Field: ‘globals’
[08:27:41.311]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.293]   - Field: ‘stdout’
[08:27:41.311]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.294]   - Field: ‘earlySignal’
[08:27:41.311]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.294]   - Field: ‘lazy’
[08:27:41.311]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.294]   - Field: ‘state’
[08:27:41.311]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.294] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:41.311]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.294] - Launch lazy future ...
[08:27:41.312]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.294] Packages needed by the future expression (n = 0): <none>
[08:27:41.313]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.294] Packages needed by future strategies (n = 0): <none>
[08:27:41.314]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.295] {
[08:27:41.295]     {
[08:27:41.295]         {
[08:27:41.295]             ...future.startTime <- base::Sys.time()
[08:27:41.295]             {
[08:27:41.295]                 {
[08:27:41.295]                   {
[08:27:41.295]                     base::local({
[08:27:41.295]                       has_future <- base::requireNamespace("future", 
[08:27:41.295]                         quietly = TRUE)
[08:27:41.295]                       if (has_future) {
[08:27:41.295]                         ns <- base::getNamespace("future")
[08:27:41.295]                         version <- ns[[".package"]][["version"]]
[08:27:41.295]                         if (is.null(version)) 
[08:27:41.295]                           version <- utils::packageVersion("future")
[08:27:41.295]                       }
[08:27:41.295]                       else {
[08:27:41.295]                         version <- NULL
[08:27:41.295]                       }
[08:27:41.295]                       if (!has_future || version < "1.8.0") {
[08:27:41.295]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.295]                           "", base::R.version$version.string), 
[08:27:41.295]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:41.295]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.295]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.295]                             "release", "version")], collapse = " "), 
[08:27:41.295]                           hostname = base::Sys.info()[["nodename"]])
[08:27:41.295]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.295]                           info)
[08:27:41.295]                         info <- base::paste(info, collapse = "; ")
[08:27:41.295]                         if (!has_future) {
[08:27:41.295]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.295]                             info)
[08:27:41.295]                         }
[08:27:41.295]                         else {
[08:27:41.295]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.295]                             info, version)
[08:27:41.295]                         }
[08:27:41.295]                         base::stop(msg)
[08:27:41.295]                       }
[08:27:41.295]                     })
[08:27:41.295]                   }
[08:27:41.295]                   ...future.strategy.old <- future::plan("list")
[08:27:41.295]                   options(future.plan = NULL)
[08:27:41.295]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.295]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.295]                 }
[08:27:41.295]                 ...future.workdir <- getwd()
[08:27:41.295]             }
[08:27:41.295]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.295]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.295]         }
[08:27:41.295]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.295]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.295]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.295]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.295]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.295]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.295]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.295]             base::names(...future.oldOptions))
[08:27:41.295]     }
[08:27:41.295]     if (FALSE) {
[08:27:41.295]     }
[08:27:41.295]     else {
[08:27:41.295]         if (TRUE) {
[08:27:41.295]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.295]                 open = "w")
[08:27:41.295]         }
[08:27:41.295]         else {
[08:27:41.295]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.295]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.295]         }
[08:27:41.295]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.295]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.295]             base::sink(type = "output", split = FALSE)
[08:27:41.295]             base::close(...future.stdout)
[08:27:41.295]         }, add = TRUE)
[08:27:41.295]     }
[08:27:41.295]     ...future.frame <- base::sys.nframe()
[08:27:41.295]     ...future.conditions <- base::list()
[08:27:41.295]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.295]     if (FALSE) {
[08:27:41.295]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.295]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.295]     }
[08:27:41.295]     ...future.result <- base::tryCatch({
[08:27:41.295]         base::withCallingHandlers({
[08:27:41.295]             ...future.value <- base::withVisible(base::local(4))
[08:27:41.295]             future::FutureResult(value = ...future.value$value, 
[08:27:41.295]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.295]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.295]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.295]                     ...future.globalenv.names))
[08:27:41.295]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.295]         }, condition = base::local({
[08:27:41.295]             c <- base::c
[08:27:41.295]             inherits <- base::inherits
[08:27:41.295]             invokeRestart <- base::invokeRestart
[08:27:41.295]             length <- base::length
[08:27:41.295]             list <- base::list
[08:27:41.295]             seq.int <- base::seq.int
[08:27:41.295]             signalCondition <- base::signalCondition
[08:27:41.295]             sys.calls <- base::sys.calls
[08:27:41.295]             `[[` <- base::`[[`
[08:27:41.295]             `+` <- base::`+`
[08:27:41.295]             `<<-` <- base::`<<-`
[08:27:41.295]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.295]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.295]                   3L)]
[08:27:41.295]             }
[08:27:41.295]             function(cond) {
[08:27:41.295]                 is_error <- inherits(cond, "error")
[08:27:41.295]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.295]                   NULL)
[08:27:41.295]                 if (is_error) {
[08:27:41.295]                   sessionInformation <- function() {
[08:27:41.295]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.295]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.295]                       search = base::search(), system = base::Sys.info())
[08:27:41.295]                   }
[08:27:41.295]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.295]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.295]                     cond$call), session = sessionInformation(), 
[08:27:41.295]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.295]                   signalCondition(cond)
[08:27:41.295]                 }
[08:27:41.295]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.295]                 "immediateCondition"))) {
[08:27:41.295]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.295]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.295]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.295]                   if (TRUE && !signal) {
[08:27:41.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.295]                     {
[08:27:41.295]                       inherits <- base::inherits
[08:27:41.295]                       invokeRestart <- base::invokeRestart
[08:27:41.295]                       is.null <- base::is.null
[08:27:41.295]                       muffled <- FALSE
[08:27:41.295]                       if (inherits(cond, "message")) {
[08:27:41.295]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.295]                         if (muffled) 
[08:27:41.295]                           invokeRestart("muffleMessage")
[08:27:41.295]                       }
[08:27:41.295]                       else if (inherits(cond, "warning")) {
[08:27:41.295]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.295]                         if (muffled) 
[08:27:41.295]                           invokeRestart("muffleWarning")
[08:27:41.295]                       }
[08:27:41.295]                       else if (inherits(cond, "condition")) {
[08:27:41.295]                         if (!is.null(pattern)) {
[08:27:41.295]                           computeRestarts <- base::computeRestarts
[08:27:41.295]                           grepl <- base::grepl
[08:27:41.295]                           restarts <- computeRestarts(cond)
[08:27:41.295]                           for (restart in restarts) {
[08:27:41.295]                             name <- restart$name
[08:27:41.295]                             if (is.null(name)) 
[08:27:41.295]                               next
[08:27:41.295]                             if (!grepl(pattern, name)) 
[08:27:41.295]                               next
[08:27:41.295]                             invokeRestart(restart)
[08:27:41.295]                             muffled <- TRUE
[08:27:41.295]                             break
[08:27:41.295]                           }
[08:27:41.295]                         }
[08:27:41.295]                       }
[08:27:41.295]                       invisible(muffled)
[08:27:41.295]                     }
[08:27:41.295]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.295]                   }
[08:27:41.295]                 }
[08:27:41.295]                 else {
[08:27:41.295]                   if (TRUE) {
[08:27:41.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.295]                     {
[08:27:41.295]                       inherits <- base::inherits
[08:27:41.295]                       invokeRestart <- base::invokeRestart
[08:27:41.295]                       is.null <- base::is.null
[08:27:41.295]                       muffled <- FALSE
[08:27:41.295]                       if (inherits(cond, "message")) {
[08:27:41.295]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.295]                         if (muffled) 
[08:27:41.295]                           invokeRestart("muffleMessage")
[08:27:41.295]                       }
[08:27:41.295]                       else if (inherits(cond, "warning")) {
[08:27:41.295]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.295]                         if (muffled) 
[08:27:41.295]                           invokeRestart("muffleWarning")
[08:27:41.295]                       }
[08:27:41.295]                       else if (inherits(cond, "condition")) {
[08:27:41.295]                         if (!is.null(pattern)) {
[08:27:41.295]                           computeRestarts <- base::computeRestarts
[08:27:41.295]                           grepl <- base::grepl
[08:27:41.295]                           restarts <- computeRestarts(cond)
[08:27:41.295]                           for (restart in restarts) {
[08:27:41.295]                             name <- restart$name
[08:27:41.295]                             if (is.null(name)) 
[08:27:41.295]                               next
[08:27:41.295]                             if (!grepl(pattern, name)) 
[08:27:41.295]                               next
[08:27:41.295]                             invokeRestart(restart)
[08:27:41.295]                             muffled <- TRUE
[08:27:41.295]                             break
[08:27:41.295]                           }
[08:27:41.295]                         }
[08:27:41.295]                       }
[08:27:41.295]                       invisible(muffled)
[08:27:41.295]                     }
[08:27:41.295]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.295]                   }
[08:27:41.295]                 }
[08:27:41.295]             }
[08:27:41.295]         }))
[08:27:41.295]     }, error = function(ex) {
[08:27:41.295]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.295]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.295]                 ...future.rng), started = ...future.startTime, 
[08:27:41.295]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.295]             version = "1.8"), class = "FutureResult")
[08:27:41.295]     }, finally = {
[08:27:41.295]         if (!identical(...future.workdir, getwd())) 
[08:27:41.295]             setwd(...future.workdir)
[08:27:41.295]         {
[08:27:41.295]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.295]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.295]             }
[08:27:41.295]             base::options(...future.oldOptions)
[08:27:41.295]             if (.Platform$OS.type == "windows") {
[08:27:41.295]                 old_names <- names(...future.oldEnvVars)
[08:27:41.295]                 envs <- base::Sys.getenv()
[08:27:41.295]                 names <- names(envs)
[08:27:41.295]                 common <- intersect(names, old_names)
[08:27:41.295]                 added <- setdiff(names, old_names)
[08:27:41.295]                 removed <- setdiff(old_names, names)
[08:27:41.295]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.295]                   envs[common]]
[08:27:41.295]                 NAMES <- toupper(changed)
[08:27:41.295]                 args <- list()
[08:27:41.295]                 for (kk in seq_along(NAMES)) {
[08:27:41.295]                   name <- changed[[kk]]
[08:27:41.295]                   NAME <- NAMES[[kk]]
[08:27:41.295]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.295]                     next
[08:27:41.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.295]                 }
[08:27:41.295]                 NAMES <- toupper(added)
[08:27:41.295]                 for (kk in seq_along(NAMES)) {
[08:27:41.295]                   name <- added[[kk]]
[08:27:41.295]                   NAME <- NAMES[[kk]]
[08:27:41.295]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.295]                     next
[08:27:41.295]                   args[[name]] <- ""
[08:27:41.295]                 }
[08:27:41.295]                 NAMES <- toupper(removed)
[08:27:41.295]                 for (kk in seq_along(NAMES)) {
[08:27:41.295]                   name <- removed[[kk]]
[08:27:41.295]                   NAME <- NAMES[[kk]]
[08:27:41.295]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.295]                     next
[08:27:41.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.295]                 }
[08:27:41.295]                 if (length(args) > 0) 
[08:27:41.295]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.295]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.295]             }
[08:27:41.295]             else {
[08:27:41.295]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.295]             }
[08:27:41.295]             {
[08:27:41.295]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.295]                   0L) {
[08:27:41.295]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.295]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.295]                   base::options(opts)
[08:27:41.295]                 }
[08:27:41.295]                 {
[08:27:41.295]                   {
[08:27:41.295]                     NULL
[08:27:41.295]                     RNGkind("Mersenne-Twister")
[08:27:41.295]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:41.295]                       inherits = FALSE)
[08:27:41.295]                   }
[08:27:41.295]                   options(future.plan = NULL)
[08:27:41.295]                   if (is.na(NA_character_)) 
[08:27:41.295]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.295]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.295]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.295]                     .init = FALSE)
[08:27:41.295]                 }
[08:27:41.295]             }
[08:27:41.295]         }
[08:27:41.295]     })
[08:27:41.295]     if (TRUE) {
[08:27:41.295]         base::sink(type = "output", split = FALSE)
[08:27:41.295]         if (TRUE) {
[08:27:41.295]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.295]         }
[08:27:41.295]         else {
[08:27:41.295]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.295]         }
[08:27:41.295]         base::close(...future.stdout)
[08:27:41.295]         ...future.stdout <- NULL
[08:27:41.295]     }
[08:27:41.295]     ...future.result$conditions <- ...future.conditions
[08:27:41.295]     ...future.result$finished <- base::Sys.time()
[08:27:41.295]     ...future.result
[08:27:41.295] }
[08:27:41.314]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.296] plan(): Setting new future strategy stack:
[08:27:41.314]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.297] List of future strategies:
[08:27:41.297] 1. sequential:
[08:27:41.297]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.297]    - tweaked: FALSE
[08:27:41.297]    - call: NULL
[08:27:41.314]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.297] plan(): nbrOfWorkers() = 1
[08:27:41.314]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.298] plan(): Setting new future strategy stack:
[08:27:41.314]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.298] List of future strategies:
[08:27:41.298] 1. sequential:
[08:27:41.298]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.298]    - tweaked: FALSE
[08:27:41.298]    - call: NULL
[08:27:41.315]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.298] plan(): nbrOfWorkers() = 1
[08:27:41.315]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.298] SequentialFuture started (and completed)
[08:27:41.315]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.299] - Launch lazy future ... done
[08:27:41.315]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.299] run() for ‘SequentialFuture’ ... done
[08:27:41.315] signalConditions() ... done
a = 10
[08:27:41.315] getGlobalsAndPackages() ...
[08:27:41.315] Searching for globals...
[08:27:41.316] - globals found: [3] ‘{’, ‘+’, ‘a’
[08:27:41.316] Searching for globals ... DONE
[08:27:41.317] Resolving globals: FALSE
[08:27:41.317] The total size of the 1 globals is 39 bytes (39 bytes)
[08:27:41.317] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[08:27:41.317] - globals: [1] ‘a’
[08:27:41.317] 
[08:27:41.318] getGlobalsAndPackages() ... DONE
[08:27:41.318] run() for ‘Future’ ...
[08:27:41.318] - state: ‘created’
[08:27:41.318] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:41.318] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:41.318] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:41.318]   - Field: ‘label’
[08:27:41.319]   - Field: ‘local’
[08:27:41.319]   - Field: ‘owner’
[08:27:41.319]   - Field: ‘envir’
[08:27:41.319]   - Field: ‘packages’
[08:27:41.319]   - Field: ‘gc’
[08:27:41.319]   - Field: ‘conditions’
[08:27:41.319]   - Field: ‘expr’
[08:27:41.319]   - Field: ‘uuid’
[08:27:41.319]   - Field: ‘seed’
[08:27:41.319]   - Field: ‘version’
[08:27:41.319]   - Field: ‘result’
[08:27:41.320]   - Field: ‘asynchronous’
[08:27:41.320]   - Field: ‘calls’
[08:27:41.320]   - Field: ‘globals’
[08:27:41.320]   - Field: ‘stdout’
[08:27:41.320]   - Field: ‘earlySignal’
[08:27:41.320]   - Field: ‘lazy’
[08:27:41.320]   - Field: ‘state’
[08:27:41.320] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:41.320] - Launch lazy future ...
[08:27:41.320] Packages needed by the future expression (n = 0): <none>
[08:27:41.321] Packages needed by future strategies (n = 0): <none>
[08:27:41.321] {
[08:27:41.321]     {
[08:27:41.321]         {
[08:27:41.321]             ...future.startTime <- base::Sys.time()
[08:27:41.321]             {
[08:27:41.321]                 {
[08:27:41.321]                   {
[08:27:41.321]                     base::local({
[08:27:41.321]                       has_future <- base::requireNamespace("future", 
[08:27:41.321]                         quietly = TRUE)
[08:27:41.321]                       if (has_future) {
[08:27:41.321]                         ns <- base::getNamespace("future")
[08:27:41.321]                         version <- ns[[".package"]][["version"]]
[08:27:41.321]                         if (is.null(version)) 
[08:27:41.321]                           version <- utils::packageVersion("future")
[08:27:41.321]                       }
[08:27:41.321]                       else {
[08:27:41.321]                         version <- NULL
[08:27:41.321]                       }
[08:27:41.321]                       if (!has_future || version < "1.8.0") {
[08:27:41.321]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.321]                           "", base::R.version$version.string), 
[08:27:41.321]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:41.321]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.321]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.321]                             "release", "version")], collapse = " "), 
[08:27:41.321]                           hostname = base::Sys.info()[["nodename"]])
[08:27:41.321]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.321]                           info)
[08:27:41.321]                         info <- base::paste(info, collapse = "; ")
[08:27:41.321]                         if (!has_future) {
[08:27:41.321]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.321]                             info)
[08:27:41.321]                         }
[08:27:41.321]                         else {
[08:27:41.321]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.321]                             info, version)
[08:27:41.321]                         }
[08:27:41.321]                         base::stop(msg)
[08:27:41.321]                       }
[08:27:41.321]                     })
[08:27:41.321]                   }
[08:27:41.321]                   ...future.strategy.old <- future::plan("list")
[08:27:41.321]                   options(future.plan = NULL)
[08:27:41.321]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.321]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.321]                 }
[08:27:41.321]                 ...future.workdir <- getwd()
[08:27:41.321]             }
[08:27:41.321]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.321]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.321]         }
[08:27:41.321]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.321]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.321]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.321]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.321]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.321]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.321]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.321]             base::names(...future.oldOptions))
[08:27:41.321]     }
[08:27:41.321]     if (FALSE) {
[08:27:41.321]     }
[08:27:41.321]     else {
[08:27:41.321]         if (TRUE) {
[08:27:41.321]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.321]                 open = "w")
[08:27:41.321]         }
[08:27:41.321]         else {
[08:27:41.321]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.321]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.321]         }
[08:27:41.321]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.321]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.321]             base::sink(type = "output", split = FALSE)
[08:27:41.321]             base::close(...future.stdout)
[08:27:41.321]         }, add = TRUE)
[08:27:41.321]     }
[08:27:41.321]     ...future.frame <- base::sys.nframe()
[08:27:41.321]     ...future.conditions <- base::list()
[08:27:41.321]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.321]     if (FALSE) {
[08:27:41.321]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.321]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.321]     }
[08:27:41.321]     ...future.result <- base::tryCatch({
[08:27:41.321]         base::withCallingHandlers({
[08:27:41.321]             ...future.value <- base::withVisible(base::local({
[08:27:41.321]                 a + 1
[08:27:41.321]             }))
[08:27:41.321]             future::FutureResult(value = ...future.value$value, 
[08:27:41.321]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.321]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.321]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.321]                     ...future.globalenv.names))
[08:27:41.321]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.321]         }, condition = base::local({
[08:27:41.321]             c <- base::c
[08:27:41.321]             inherits <- base::inherits
[08:27:41.321]             invokeRestart <- base::invokeRestart
[08:27:41.321]             length <- base::length
[08:27:41.321]             list <- base::list
[08:27:41.321]             seq.int <- base::seq.int
[08:27:41.321]             signalCondition <- base::signalCondition
[08:27:41.321]             sys.calls <- base::sys.calls
[08:27:41.321]             `[[` <- base::`[[`
[08:27:41.321]             `+` <- base::`+`
[08:27:41.321]             `<<-` <- base::`<<-`
[08:27:41.321]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.321]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.321]                   3L)]
[08:27:41.321]             }
[08:27:41.321]             function(cond) {
[08:27:41.321]                 is_error <- inherits(cond, "error")
[08:27:41.321]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.321]                   NULL)
[08:27:41.321]                 if (is_error) {
[08:27:41.321]                   sessionInformation <- function() {
[08:27:41.321]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.321]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.321]                       search = base::search(), system = base::Sys.info())
[08:27:41.321]                   }
[08:27:41.321]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.321]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.321]                     cond$call), session = sessionInformation(), 
[08:27:41.321]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.321]                   signalCondition(cond)
[08:27:41.321]                 }
[08:27:41.321]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.321]                 "immediateCondition"))) {
[08:27:41.321]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.321]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.321]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.321]                   if (TRUE && !signal) {
[08:27:41.321]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.321]                     {
[08:27:41.321]                       inherits <- base::inherits
[08:27:41.321]                       invokeRestart <- base::invokeRestart
[08:27:41.321]                       is.null <- base::is.null
[08:27:41.321]                       muffled <- FALSE
[08:27:41.321]                       if (inherits(cond, "message")) {
[08:27:41.321]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.321]                         if (muffled) 
[08:27:41.321]                           invokeRestart("muffleMessage")
[08:27:41.321]                       }
[08:27:41.321]                       else if (inherits(cond, "warning")) {
[08:27:41.321]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.321]                         if (muffled) 
[08:27:41.321]                           invokeRestart("muffleWarning")
[08:27:41.321]                       }
[08:27:41.321]                       else if (inherits(cond, "condition")) {
[08:27:41.321]                         if (!is.null(pattern)) {
[08:27:41.321]                           computeRestarts <- base::computeRestarts
[08:27:41.321]                           grepl <- base::grepl
[08:27:41.321]                           restarts <- computeRestarts(cond)
[08:27:41.321]                           for (restart in restarts) {
[08:27:41.321]                             name <- restart$name
[08:27:41.321]                             if (is.null(name)) 
[08:27:41.321]                               next
[08:27:41.321]                             if (!grepl(pattern, name)) 
[08:27:41.321]                               next
[08:27:41.321]                             invokeRestart(restart)
[08:27:41.321]                             muffled <- TRUE
[08:27:41.321]                             break
[08:27:41.321]                           }
[08:27:41.321]                         }
[08:27:41.321]                       }
[08:27:41.321]                       invisible(muffled)
[08:27:41.321]                     }
[08:27:41.321]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.321]                   }
[08:27:41.321]                 }
[08:27:41.321]                 else {
[08:27:41.321]                   if (TRUE) {
[08:27:41.321]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.321]                     {
[08:27:41.321]                       inherits <- base::inherits
[08:27:41.321]                       invokeRestart <- base::invokeRestart
[08:27:41.321]                       is.null <- base::is.null
[08:27:41.321]                       muffled <- FALSE
[08:27:41.321]                       if (inherits(cond, "message")) {
[08:27:41.321]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.321]                         if (muffled) 
[08:27:41.321]                           invokeRestart("muffleMessage")
[08:27:41.321]                       }
[08:27:41.321]                       else if (inherits(cond, "warning")) {
[08:27:41.321]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.321]                         if (muffled) 
[08:27:41.321]                           invokeRestart("muffleWarning")
[08:27:41.321]                       }
[08:27:41.321]                       else if (inherits(cond, "condition")) {
[08:27:41.321]                         if (!is.null(pattern)) {
[08:27:41.321]                           computeRestarts <- base::computeRestarts
[08:27:41.321]                           grepl <- base::grepl
[08:27:41.321]                           restarts <- computeRestarts(cond)
[08:27:41.321]                           for (restart in restarts) {
[08:27:41.321]                             name <- restart$name
[08:27:41.321]                             if (is.null(name)) 
[08:27:41.321]                               next
[08:27:41.321]                             if (!grepl(pattern, name)) 
[08:27:41.321]                               next
[08:27:41.321]                             invokeRestart(restart)
[08:27:41.321]                             muffled <- TRUE
[08:27:41.321]                             break
[08:27:41.321]                           }
[08:27:41.321]                         }
[08:27:41.321]                       }
[08:27:41.321]                       invisible(muffled)
[08:27:41.321]                     }
[08:27:41.321]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.321]                   }
[08:27:41.321]                 }
[08:27:41.321]             }
[08:27:41.321]         }))
[08:27:41.321]     }, error = function(ex) {
[08:27:41.321]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.321]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.321]                 ...future.rng), started = ...future.startTime, 
[08:27:41.321]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.321]             version = "1.8"), class = "FutureResult")
[08:27:41.321]     }, finally = {
[08:27:41.321]         if (!identical(...future.workdir, getwd())) 
[08:27:41.321]             setwd(...future.workdir)
[08:27:41.321]         {
[08:27:41.321]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.321]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.321]             }
[08:27:41.321]             base::options(...future.oldOptions)
[08:27:41.321]             if (.Platform$OS.type == "windows") {
[08:27:41.321]                 old_names <- names(...future.oldEnvVars)
[08:27:41.321]                 envs <- base::Sys.getenv()
[08:27:41.321]                 names <- names(envs)
[08:27:41.321]                 common <- intersect(names, old_names)
[08:27:41.321]                 added <- setdiff(names, old_names)
[08:27:41.321]                 removed <- setdiff(old_names, names)
[08:27:41.321]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.321]                   envs[common]]
[08:27:41.321]                 NAMES <- toupper(changed)
[08:27:41.321]                 args <- list()
[08:27:41.321]                 for (kk in seq_along(NAMES)) {
[08:27:41.321]                   name <- changed[[kk]]
[08:27:41.321]                   NAME <- NAMES[[kk]]
[08:27:41.321]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.321]                     next
[08:27:41.321]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.321]                 }
[08:27:41.321]                 NAMES <- toupper(added)
[08:27:41.321]                 for (kk in seq_along(NAMES)) {
[08:27:41.321]                   name <- added[[kk]]
[08:27:41.321]                   NAME <- NAMES[[kk]]
[08:27:41.321]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.321]                     next
[08:27:41.321]                   args[[name]] <- ""
[08:27:41.321]                 }
[08:27:41.321]                 NAMES <- toupper(removed)
[08:27:41.321]                 for (kk in seq_along(NAMES)) {
[08:27:41.321]                   name <- removed[[kk]]
[08:27:41.321]                   NAME <- NAMES[[kk]]
[08:27:41.321]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.321]                     next
[08:27:41.321]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.321]                 }
[08:27:41.321]                 if (length(args) > 0) 
[08:27:41.321]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.321]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.321]             }
[08:27:41.321]             else {
[08:27:41.321]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.321]             }
[08:27:41.321]             {
[08:27:41.321]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.321]                   0L) {
[08:27:41.321]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.321]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.321]                   base::options(opts)
[08:27:41.321]                 }
[08:27:41.321]                 {
[08:27:41.321]                   {
[08:27:41.321]                     NULL
[08:27:41.321]                     RNGkind("Mersenne-Twister")
[08:27:41.321]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:41.321]                       inherits = FALSE)
[08:27:41.321]                   }
[08:27:41.321]                   options(future.plan = NULL)
[08:27:41.321]                   if (is.na(NA_character_)) 
[08:27:41.321]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.321]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.321]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.321]                     .init = FALSE)
[08:27:41.321]                 }
[08:27:41.321]             }
[08:27:41.321]         }
[08:27:41.321]     })
[08:27:41.321]     if (TRUE) {
[08:27:41.321]         base::sink(type = "output", split = FALSE)
[08:27:41.321]         if (TRUE) {
[08:27:41.321]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.321]         }
[08:27:41.321]         else {
[08:27:41.321]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.321]         }
[08:27:41.321]         base::close(...future.stdout)
[08:27:41.321]         ...future.stdout <- NULL
[08:27:41.321]     }
[08:27:41.321]     ...future.result$conditions <- ...future.conditions
[08:27:41.321]     ...future.result$finished <- base::Sys.time()
[08:27:41.321]     ...future.result
[08:27:41.321] }
[08:27:41.323] assign_globals() ...
[08:27:41.323] List of 1
[08:27:41.323]  $ a: num 10
[08:27:41.323]  - attr(*, "where")=List of 1
[08:27:41.323]   ..$ a:<environment: R_EmptyEnv> 
[08:27:41.323]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:41.323]  - attr(*, "resolved")= logi FALSE
[08:27:41.323]  - attr(*, "total_size")= num 39
[08:27:41.323]  - attr(*, "already-done")= logi TRUE
[08:27:41.325] - copied ‘a’ to environment
[08:27:41.325] assign_globals() ... done
[08:27:41.326] plan(): Setting new future strategy stack:
[08:27:41.326] List of future strategies:
[08:27:41.326] 1. sequential:
[08:27:41.326]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.326]    - tweaked: FALSE
[08:27:41.326]    - call: NULL
[08:27:41.326] plan(): nbrOfWorkers() = 1
[08:27:41.327] plan(): Setting new future strategy stack:
[08:27:41.327] List of future strategies:
[08:27:41.327] 1. sequential:
[08:27:41.327]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.327]    - tweaked: FALSE
[08:27:41.327]    - call: plan(strategy)
[08:27:41.327] plan(): nbrOfWorkers() = 1
[08:27:41.328] SequentialFuture started (and completed)
[08:27:41.328] - Launch lazy future ... done
[08:27:41.328] run() for ‘SequentialFuture’ ... done
b = 11
*** %<-% with ‘sequential’ futures ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** %<-% with ‘multicore’ futures ...
[08:27:41.333] plan(): Setting new future strategy stack:
[08:27:41.333] List of future strategies:
[08:27:41.333] 1. multicore:
[08:27:41.333]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:41.333]    - tweaked: FALSE
[08:27:41.333]    - call: plan(strategy)
[08:27:41.335] plan(): nbrOfWorkers() = 2
** Future evaluation without globals
[08:27:41.336] getGlobalsAndPackages() ...
[08:27:41.336] Searching for globals...
[08:27:41.336] - globals found: [2] ‘{’, ‘<-’
[08:27:41.337] Searching for globals ... DONE
[08:27:41.337] Resolving globals: FALSE
[08:27:41.337] 
[08:27:41.337] 
[08:27:41.337] getGlobalsAndPackages() ... DONE
[08:27:41.337] run() for ‘Future’ ...
[08:27:41.338] - state: ‘created’
[08:27:41.339] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:41.341] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:41.341] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:41.341]   - Field: ‘label’
[08:27:41.341]   - Field: ‘local’
[08:27:41.342]   - Field: ‘owner’
[08:27:41.342]   - Field: ‘envir’
[08:27:41.342]   - Field: ‘workers’
[08:27:41.342]   - Field: ‘packages’
[08:27:41.342]   - Field: ‘gc’
[08:27:41.342]   - Field: ‘job’
[08:27:41.342]   - Field: ‘conditions’
[08:27:41.342]   - Field: ‘expr’
[08:27:41.342]   - Field: ‘uuid’
[08:27:41.342]   - Field: ‘seed’
[08:27:41.342]   - Field: ‘version’
[08:27:41.343]   - Field: ‘result’
[08:27:41.343]   - Field: ‘asynchronous’
[08:27:41.343]   - Field: ‘calls’
[08:27:41.343]   - Field: ‘globals’
[08:27:41.343]   - Field: ‘stdout’
[08:27:41.343]   - Field: ‘earlySignal’
[08:27:41.343]   - Field: ‘lazy’
[08:27:41.343]   - Field: ‘state’
[08:27:41.343] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:41.343] - Launch lazy future ...
[08:27:41.344] Packages needed by the future expression (n = 0): <none>
[08:27:41.344] Packages needed by future strategies (n = 0): <none>
[08:27:41.345] {
[08:27:41.345]     {
[08:27:41.345]         {
[08:27:41.345]             ...future.startTime <- base::Sys.time()
[08:27:41.345]             {
[08:27:41.345]                 {
[08:27:41.345]                   {
[08:27:41.345]                     {
[08:27:41.345]                       base::local({
[08:27:41.345]                         has_future <- base::requireNamespace("future", 
[08:27:41.345]                           quietly = TRUE)
[08:27:41.345]                         if (has_future) {
[08:27:41.345]                           ns <- base::getNamespace("future")
[08:27:41.345]                           version <- ns[[".package"]][["version"]]
[08:27:41.345]                           if (is.null(version)) 
[08:27:41.345]                             version <- utils::packageVersion("future")
[08:27:41.345]                         }
[08:27:41.345]                         else {
[08:27:41.345]                           version <- NULL
[08:27:41.345]                         }
[08:27:41.345]                         if (!has_future || version < "1.8.0") {
[08:27:41.345]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.345]                             "", base::R.version$version.string), 
[08:27:41.345]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:41.345]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.345]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.345]                               "release", "version")], collapse = " "), 
[08:27:41.345]                             hostname = base::Sys.info()[["nodename"]])
[08:27:41.345]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.345]                             info)
[08:27:41.345]                           info <- base::paste(info, collapse = "; ")
[08:27:41.345]                           if (!has_future) {
[08:27:41.345]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.345]                               info)
[08:27:41.345]                           }
[08:27:41.345]                           else {
[08:27:41.345]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.345]                               info, version)
[08:27:41.345]                           }
[08:27:41.345]                           base::stop(msg)
[08:27:41.345]                         }
[08:27:41.345]                       })
[08:27:41.345]                     }
[08:27:41.345]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:41.345]                     base::options(mc.cores = 1L)
[08:27:41.345]                   }
[08:27:41.345]                   ...future.strategy.old <- future::plan("list")
[08:27:41.345]                   options(future.plan = NULL)
[08:27:41.345]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.345]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.345]                 }
[08:27:41.345]                 ...future.workdir <- getwd()
[08:27:41.345]             }
[08:27:41.345]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.345]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.345]         }
[08:27:41.345]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.345]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.345]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.345]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.345]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.345]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.345]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.345]             base::names(...future.oldOptions))
[08:27:41.345]     }
[08:27:41.345]     if (FALSE) {
[08:27:41.345]     }
[08:27:41.345]     else {
[08:27:41.345]         if (TRUE) {
[08:27:41.345]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.345]                 open = "w")
[08:27:41.345]         }
[08:27:41.345]         else {
[08:27:41.345]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.345]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.345]         }
[08:27:41.345]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.345]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.345]             base::sink(type = "output", split = FALSE)
[08:27:41.345]             base::close(...future.stdout)
[08:27:41.345]         }, add = TRUE)
[08:27:41.345]     }
[08:27:41.345]     ...future.frame <- base::sys.nframe()
[08:27:41.345]     ...future.conditions <- base::list()
[08:27:41.345]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.345]     if (FALSE) {
[08:27:41.345]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.345]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.345]     }
[08:27:41.345]     ...future.result <- base::tryCatch({
[08:27:41.345]         base::withCallingHandlers({
[08:27:41.345]             ...future.value <- base::withVisible(base::local({
[08:27:41.345]                 withCallingHandlers({
[08:27:41.345]                   {
[08:27:41.345]                     x <- 1
[08:27:41.345]                   }
[08:27:41.345]                 }, immediateCondition = function(cond) {
[08:27:41.345]                   save_rds <- function (object, pathname, ...) 
[08:27:41.345]                   {
[08:27:41.345]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:41.345]                     if (file_test("-f", pathname_tmp)) {
[08:27:41.345]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.345]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:41.345]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.345]                         fi_tmp[["mtime"]])
[08:27:41.345]                     }
[08:27:41.345]                     tryCatch({
[08:27:41.345]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:41.345]                     }, error = function(ex) {
[08:27:41.345]                       msg <- conditionMessage(ex)
[08:27:41.345]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.345]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:41.345]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.345]                         fi_tmp[["mtime"]], msg)
[08:27:41.345]                       ex$message <- msg
[08:27:41.345]                       stop(ex)
[08:27:41.345]                     })
[08:27:41.345]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:41.345]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:41.345]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:41.345]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.345]                       fi <- file.info(pathname)
[08:27:41.345]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:41.345]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.345]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:41.345]                         fi[["size"]], fi[["mtime"]])
[08:27:41.345]                       stop(msg)
[08:27:41.345]                     }
[08:27:41.345]                     invisible(pathname)
[08:27:41.345]                   }
[08:27:41.345]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:41.345]                     rootPath = tempdir()) 
[08:27:41.345]                   {
[08:27:41.345]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:41.345]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:41.345]                       tmpdir = path, fileext = ".rds")
[08:27:41.345]                     save_rds(obj, file)
[08:27:41.345]                   }
[08:27:41.345]                   saveImmediateCondition(cond, path = "/tmp/RtmpOWg6bo/.future/immediateConditions")
[08:27:41.345]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.345]                   {
[08:27:41.345]                     inherits <- base::inherits
[08:27:41.345]                     invokeRestart <- base::invokeRestart
[08:27:41.345]                     is.null <- base::is.null
[08:27:41.345]                     muffled <- FALSE
[08:27:41.345]                     if (inherits(cond, "message")) {
[08:27:41.345]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:41.345]                       if (muffled) 
[08:27:41.345]                         invokeRestart("muffleMessage")
[08:27:41.345]                     }
[08:27:41.345]                     else if (inherits(cond, "warning")) {
[08:27:41.345]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:41.345]                       if (muffled) 
[08:27:41.345]                         invokeRestart("muffleWarning")
[08:27:41.345]                     }
[08:27:41.345]                     else if (inherits(cond, "condition")) {
[08:27:41.345]                       if (!is.null(pattern)) {
[08:27:41.345]                         computeRestarts <- base::computeRestarts
[08:27:41.345]                         grepl <- base::grepl
[08:27:41.345]                         restarts <- computeRestarts(cond)
[08:27:41.345]                         for (restart in restarts) {
[08:27:41.345]                           name <- restart$name
[08:27:41.345]                           if (is.null(name)) 
[08:27:41.345]                             next
[08:27:41.345]                           if (!grepl(pattern, name)) 
[08:27:41.345]                             next
[08:27:41.345]                           invokeRestart(restart)
[08:27:41.345]                           muffled <- TRUE
[08:27:41.345]                           break
[08:27:41.345]                         }
[08:27:41.345]                       }
[08:27:41.345]                     }
[08:27:41.345]                     invisible(muffled)
[08:27:41.345]                   }
[08:27:41.345]                   muffleCondition(cond)
[08:27:41.345]                 })
[08:27:41.345]             }))
[08:27:41.345]             future::FutureResult(value = ...future.value$value, 
[08:27:41.345]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.345]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.345]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.345]                     ...future.globalenv.names))
[08:27:41.345]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.345]         }, condition = base::local({
[08:27:41.345]             c <- base::c
[08:27:41.345]             inherits <- base::inherits
[08:27:41.345]             invokeRestart <- base::invokeRestart
[08:27:41.345]             length <- base::length
[08:27:41.345]             list <- base::list
[08:27:41.345]             seq.int <- base::seq.int
[08:27:41.345]             signalCondition <- base::signalCondition
[08:27:41.345]             sys.calls <- base::sys.calls
[08:27:41.345]             `[[` <- base::`[[`
[08:27:41.345]             `+` <- base::`+`
[08:27:41.345]             `<<-` <- base::`<<-`
[08:27:41.345]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.345]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.345]                   3L)]
[08:27:41.345]             }
[08:27:41.345]             function(cond) {
[08:27:41.345]                 is_error <- inherits(cond, "error")
[08:27:41.345]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.345]                   NULL)
[08:27:41.345]                 if (is_error) {
[08:27:41.345]                   sessionInformation <- function() {
[08:27:41.345]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.345]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.345]                       search = base::search(), system = base::Sys.info())
[08:27:41.345]                   }
[08:27:41.345]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.345]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.345]                     cond$call), session = sessionInformation(), 
[08:27:41.345]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.345]                   signalCondition(cond)
[08:27:41.345]                 }
[08:27:41.345]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.345]                 "immediateCondition"))) {
[08:27:41.345]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.345]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.345]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.345]                   if (TRUE && !signal) {
[08:27:41.345]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.345]                     {
[08:27:41.345]                       inherits <- base::inherits
[08:27:41.345]                       invokeRestart <- base::invokeRestart
[08:27:41.345]                       is.null <- base::is.null
[08:27:41.345]                       muffled <- FALSE
[08:27:41.345]                       if (inherits(cond, "message")) {
[08:27:41.345]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.345]                         if (muffled) 
[08:27:41.345]                           invokeRestart("muffleMessage")
[08:27:41.345]                       }
[08:27:41.345]                       else if (inherits(cond, "warning")) {
[08:27:41.345]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.345]                         if (muffled) 
[08:27:41.345]                           invokeRestart("muffleWarning")
[08:27:41.345]                       }
[08:27:41.345]                       else if (inherits(cond, "condition")) {
[08:27:41.345]                         if (!is.null(pattern)) {
[08:27:41.345]                           computeRestarts <- base::computeRestarts
[08:27:41.345]                           grepl <- base::grepl
[08:27:41.345]                           restarts <- computeRestarts(cond)
[08:27:41.345]                           for (restart in restarts) {
[08:27:41.345]                             name <- restart$name
[08:27:41.345]                             if (is.null(name)) 
[08:27:41.345]                               next
[08:27:41.345]                             if (!grepl(pattern, name)) 
[08:27:41.345]                               next
[08:27:41.345]                             invokeRestart(restart)
[08:27:41.345]                             muffled <- TRUE
[08:27:41.345]                             break
[08:27:41.345]                           }
[08:27:41.345]                         }
[08:27:41.345]                       }
[08:27:41.345]                       invisible(muffled)
[08:27:41.345]                     }
[08:27:41.345]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.345]                   }
[08:27:41.345]                 }
[08:27:41.345]                 else {
[08:27:41.345]                   if (TRUE) {
[08:27:41.345]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.345]                     {
[08:27:41.345]                       inherits <- base::inherits
[08:27:41.345]                       invokeRestart <- base::invokeRestart
[08:27:41.345]                       is.null <- base::is.null
[08:27:41.345]                       muffled <- FALSE
[08:27:41.345]                       if (inherits(cond, "message")) {
[08:27:41.345]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.345]                         if (muffled) 
[08:27:41.345]                           invokeRestart("muffleMessage")
[08:27:41.345]                       }
[08:27:41.345]                       else if (inherits(cond, "warning")) {
[08:27:41.345]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.345]                         if (muffled) 
[08:27:41.345]                           invokeRestart("muffleWarning")
[08:27:41.345]                       }
[08:27:41.345]                       else if (inherits(cond, "condition")) {
[08:27:41.345]                         if (!is.null(pattern)) {
[08:27:41.345]                           computeRestarts <- base::computeRestarts
[08:27:41.345]                           grepl <- base::grepl
[08:27:41.345]                           restarts <- computeRestarts(cond)
[08:27:41.345]                           for (restart in restarts) {
[08:27:41.345]                             name <- restart$name
[08:27:41.345]                             if (is.null(name)) 
[08:27:41.345]                               next
[08:27:41.345]                             if (!grepl(pattern, name)) 
[08:27:41.345]                               next
[08:27:41.345]                             invokeRestart(restart)
[08:27:41.345]                             muffled <- TRUE
[08:27:41.345]                             break
[08:27:41.345]                           }
[08:27:41.345]                         }
[08:27:41.345]                       }
[08:27:41.345]                       invisible(muffled)
[08:27:41.345]                     }
[08:27:41.345]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.345]                   }
[08:27:41.345]                 }
[08:27:41.345]             }
[08:27:41.345]         }))
[08:27:41.345]     }, error = function(ex) {
[08:27:41.345]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.345]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.345]                 ...future.rng), started = ...future.startTime, 
[08:27:41.345]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.345]             version = "1.8"), class = "FutureResult")
[08:27:41.345]     }, finally = {
[08:27:41.345]         if (!identical(...future.workdir, getwd())) 
[08:27:41.345]             setwd(...future.workdir)
[08:27:41.345]         {
[08:27:41.345]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.345]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.345]             }
[08:27:41.345]             base::options(...future.oldOptions)
[08:27:41.345]             if (.Platform$OS.type == "windows") {
[08:27:41.345]                 old_names <- names(...future.oldEnvVars)
[08:27:41.345]                 envs <- base::Sys.getenv()
[08:27:41.345]                 names <- names(envs)
[08:27:41.345]                 common <- intersect(names, old_names)
[08:27:41.345]                 added <- setdiff(names, old_names)
[08:27:41.345]                 removed <- setdiff(old_names, names)
[08:27:41.345]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.345]                   envs[common]]
[08:27:41.345]                 NAMES <- toupper(changed)
[08:27:41.345]                 args <- list()
[08:27:41.345]                 for (kk in seq_along(NAMES)) {
[08:27:41.345]                   name <- changed[[kk]]
[08:27:41.345]                   NAME <- NAMES[[kk]]
[08:27:41.345]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.345]                     next
[08:27:41.345]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.345]                 }
[08:27:41.345]                 NAMES <- toupper(added)
[08:27:41.345]                 for (kk in seq_along(NAMES)) {
[08:27:41.345]                   name <- added[[kk]]
[08:27:41.345]                   NAME <- NAMES[[kk]]
[08:27:41.345]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.345]                     next
[08:27:41.345]                   args[[name]] <- ""
[08:27:41.345]                 }
[08:27:41.345]                 NAMES <- toupper(removed)
[08:27:41.345]                 for (kk in seq_along(NAMES)) {
[08:27:41.345]                   name <- removed[[kk]]
[08:27:41.345]                   NAME <- NAMES[[kk]]
[08:27:41.345]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.345]                     next
[08:27:41.345]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.345]                 }
[08:27:41.345]                 if (length(args) > 0) 
[08:27:41.345]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.345]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.345]             }
[08:27:41.345]             else {
[08:27:41.345]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.345]             }
[08:27:41.345]             {
[08:27:41.345]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.345]                   0L) {
[08:27:41.345]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.345]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.345]                   base::options(opts)
[08:27:41.345]                 }
[08:27:41.345]                 {
[08:27:41.345]                   {
[08:27:41.345]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:41.345]                     NULL
[08:27:41.345]                   }
[08:27:41.345]                   options(future.plan = NULL)
[08:27:41.345]                   if (is.na(NA_character_)) 
[08:27:41.345]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.345]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.345]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.345]                     .init = FALSE)
[08:27:41.345]                 }
[08:27:41.345]             }
[08:27:41.345]         }
[08:27:41.345]     })
[08:27:41.345]     if (TRUE) {
[08:27:41.345]         base::sink(type = "output", split = FALSE)
[08:27:41.345]         if (TRUE) {
[08:27:41.345]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.345]         }
[08:27:41.345]         else {
[08:27:41.345]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.345]         }
[08:27:41.345]         base::close(...future.stdout)
[08:27:41.345]         ...future.stdout <- NULL
[08:27:41.345]     }
[08:27:41.345]     ...future.result$conditions <- ...future.conditions
[08:27:41.345]     ...future.result$finished <- base::Sys.time()
[08:27:41.345]     ...future.result
[08:27:41.345] }
[08:27:41.347] requestCore(): workers = 2
[08:27:41.350] MulticoreFuture started
[08:27:41.351] - Launch lazy future ... done
[08:27:41.351] plan(): Setting new future strategy stack:
[08:27:41.351] run() for ‘MulticoreFuture’ ... done
[08:27:41.351] List of future strategies:
[08:27:41.351] 1. sequential:
[08:27:41.351]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.351]    - tweaked: FALSE
[08:27:41.351]    - call: NULL
[08:27:41.352] plan(): nbrOfWorkers() = 1
[08:27:41.352] result() for MulticoreFuture ...
[08:27:41.354] plan(): Setting new future strategy stack:
[08:27:41.354] List of future strategies:
[08:27:41.354] 1. multicore:
[08:27:41.354]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:41.354]    - tweaked: FALSE
[08:27:41.354]    - call: plan(strategy)
[08:27:41.357] plan(): nbrOfWorkers() = 2
[08:27:41.362] result() for MulticoreFuture ...
[08:27:41.362] result() for MulticoreFuture ... done
[08:27:41.362] result() for MulticoreFuture ... done
[08:27:41.362] result() for MulticoreFuture ...
[08:27:41.363] result() for MulticoreFuture ... done
** Future evaluation with globals
[08:27:41.363] getGlobalsAndPackages() ...
[08:27:41.363] Searching for globals...
[08:27:41.365] - globals found: [3] ‘{’, ‘<-’, ‘a’
[08:27:41.365] Searching for globals ... DONE
[08:27:41.365] Resolving globals: FALSE
[08:27:41.365] The total size of the 1 globals is 39 bytes (39 bytes)
[08:27:41.366] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[08:27:41.366] - globals: [1] ‘a’
[08:27:41.366] 
[08:27:41.366] getGlobalsAndPackages() ... DONE
[08:27:41.367] run() for ‘Future’ ...
[08:27:41.367] - state: ‘created’
[08:27:41.367] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:41.369] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:41.369] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:41.369]   - Field: ‘label’
[08:27:41.369]   - Field: ‘local’
[08:27:41.369]   - Field: ‘owner’
[08:27:41.370]   - Field: ‘envir’
[08:27:41.370]   - Field: ‘workers’
[08:27:41.370]   - Field: ‘packages’
[08:27:41.370]   - Field: ‘gc’
[08:27:41.370]   - Field: ‘job’
[08:27:41.370]   - Field: ‘conditions’
[08:27:41.370]   - Field: ‘expr’
[08:27:41.370]   - Field: ‘uuid’
[08:27:41.370]   - Field: ‘seed’
[08:27:41.371]   - Field: ‘version’
[08:27:41.371]   - Field: ‘result’
[08:27:41.371]   - Field: ‘asynchronous’
[08:27:41.371]   - Field: ‘calls’
[08:27:41.371]   - Field: ‘globals’
[08:27:41.371]   - Field: ‘stdout’
[08:27:41.371]   - Field: ‘earlySignal’
[08:27:41.371]   - Field: ‘lazy’
[08:27:41.371]   - Field: ‘state’
[08:27:41.372] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:41.372] - Launch lazy future ...
[08:27:41.372] Packages needed by the future expression (n = 0): <none>
[08:27:41.372] Packages needed by future strategies (n = 0): <none>
[08:27:41.373] {
[08:27:41.373]     {
[08:27:41.373]         {
[08:27:41.373]             ...future.startTime <- base::Sys.time()
[08:27:41.373]             {
[08:27:41.373]                 {
[08:27:41.373]                   {
[08:27:41.373]                     {
[08:27:41.373]                       base::local({
[08:27:41.373]                         has_future <- base::requireNamespace("future", 
[08:27:41.373]                           quietly = TRUE)
[08:27:41.373]                         if (has_future) {
[08:27:41.373]                           ns <- base::getNamespace("future")
[08:27:41.373]                           version <- ns[[".package"]][["version"]]
[08:27:41.373]                           if (is.null(version)) 
[08:27:41.373]                             version <- utils::packageVersion("future")
[08:27:41.373]                         }
[08:27:41.373]                         else {
[08:27:41.373]                           version <- NULL
[08:27:41.373]                         }
[08:27:41.373]                         if (!has_future || version < "1.8.0") {
[08:27:41.373]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.373]                             "", base::R.version$version.string), 
[08:27:41.373]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:41.373]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.373]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.373]                               "release", "version")], collapse = " "), 
[08:27:41.373]                             hostname = base::Sys.info()[["nodename"]])
[08:27:41.373]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.373]                             info)
[08:27:41.373]                           info <- base::paste(info, collapse = "; ")
[08:27:41.373]                           if (!has_future) {
[08:27:41.373]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.373]                               info)
[08:27:41.373]                           }
[08:27:41.373]                           else {
[08:27:41.373]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.373]                               info, version)
[08:27:41.373]                           }
[08:27:41.373]                           base::stop(msg)
[08:27:41.373]                         }
[08:27:41.373]                       })
[08:27:41.373]                     }
[08:27:41.373]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:41.373]                     base::options(mc.cores = 1L)
[08:27:41.373]                   }
[08:27:41.373]                   ...future.strategy.old <- future::plan("list")
[08:27:41.373]                   options(future.plan = NULL)
[08:27:41.373]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.373]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.373]                 }
[08:27:41.373]                 ...future.workdir <- getwd()
[08:27:41.373]             }
[08:27:41.373]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.373]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.373]         }
[08:27:41.373]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.373]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.373]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.373]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.373]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.373]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.373]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.373]             base::names(...future.oldOptions))
[08:27:41.373]     }
[08:27:41.373]     if (FALSE) {
[08:27:41.373]     }
[08:27:41.373]     else {
[08:27:41.373]         if (TRUE) {
[08:27:41.373]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.373]                 open = "w")
[08:27:41.373]         }
[08:27:41.373]         else {
[08:27:41.373]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.373]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.373]         }
[08:27:41.373]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.373]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.373]             base::sink(type = "output", split = FALSE)
[08:27:41.373]             base::close(...future.stdout)
[08:27:41.373]         }, add = TRUE)
[08:27:41.373]     }
[08:27:41.373]     ...future.frame <- base::sys.nframe()
[08:27:41.373]     ...future.conditions <- base::list()
[08:27:41.373]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.373]     if (FALSE) {
[08:27:41.373]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.373]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.373]     }
[08:27:41.373]     ...future.result <- base::tryCatch({
[08:27:41.373]         base::withCallingHandlers({
[08:27:41.373]             ...future.value <- base::withVisible(base::local({
[08:27:41.373]                 withCallingHandlers({
[08:27:41.373]                   {
[08:27:41.373]                     x <- a
[08:27:41.373]                   }
[08:27:41.373]                 }, immediateCondition = function(cond) {
[08:27:41.373]                   save_rds <- function (object, pathname, ...) 
[08:27:41.373]                   {
[08:27:41.373]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:41.373]                     if (file_test("-f", pathname_tmp)) {
[08:27:41.373]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.373]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:41.373]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.373]                         fi_tmp[["mtime"]])
[08:27:41.373]                     }
[08:27:41.373]                     tryCatch({
[08:27:41.373]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:41.373]                     }, error = function(ex) {
[08:27:41.373]                       msg <- conditionMessage(ex)
[08:27:41.373]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.373]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:41.373]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.373]                         fi_tmp[["mtime"]], msg)
[08:27:41.373]                       ex$message <- msg
[08:27:41.373]                       stop(ex)
[08:27:41.373]                     })
[08:27:41.373]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:41.373]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:41.373]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:41.373]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.373]                       fi <- file.info(pathname)
[08:27:41.373]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:41.373]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.373]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:41.373]                         fi[["size"]], fi[["mtime"]])
[08:27:41.373]                       stop(msg)
[08:27:41.373]                     }
[08:27:41.373]                     invisible(pathname)
[08:27:41.373]                   }
[08:27:41.373]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:41.373]                     rootPath = tempdir()) 
[08:27:41.373]                   {
[08:27:41.373]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:41.373]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:41.373]                       tmpdir = path, fileext = ".rds")
[08:27:41.373]                     save_rds(obj, file)
[08:27:41.373]                   }
[08:27:41.373]                   saveImmediateCondition(cond, path = "/tmp/RtmpOWg6bo/.future/immediateConditions")
[08:27:41.373]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.373]                   {
[08:27:41.373]                     inherits <- base::inherits
[08:27:41.373]                     invokeRestart <- base::invokeRestart
[08:27:41.373]                     is.null <- base::is.null
[08:27:41.373]                     muffled <- FALSE
[08:27:41.373]                     if (inherits(cond, "message")) {
[08:27:41.373]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:41.373]                       if (muffled) 
[08:27:41.373]                         invokeRestart("muffleMessage")
[08:27:41.373]                     }
[08:27:41.373]                     else if (inherits(cond, "warning")) {
[08:27:41.373]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:41.373]                       if (muffled) 
[08:27:41.373]                         invokeRestart("muffleWarning")
[08:27:41.373]                     }
[08:27:41.373]                     else if (inherits(cond, "condition")) {
[08:27:41.373]                       if (!is.null(pattern)) {
[08:27:41.373]                         computeRestarts <- base::computeRestarts
[08:27:41.373]                         grepl <- base::grepl
[08:27:41.373]                         restarts <- computeRestarts(cond)
[08:27:41.373]                         for (restart in restarts) {
[08:27:41.373]                           name <- restart$name
[08:27:41.373]                           if (is.null(name)) 
[08:27:41.373]                             next
[08:27:41.373]                           if (!grepl(pattern, name)) 
[08:27:41.373]                             next
[08:27:41.373]                           invokeRestart(restart)
[08:27:41.373]                           muffled <- TRUE
[08:27:41.373]                           break
[08:27:41.373]                         }
[08:27:41.373]                       }
[08:27:41.373]                     }
[08:27:41.373]                     invisible(muffled)
[08:27:41.373]                   }
[08:27:41.373]                   muffleCondition(cond)
[08:27:41.373]                 })
[08:27:41.373]             }))
[08:27:41.373]             future::FutureResult(value = ...future.value$value, 
[08:27:41.373]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.373]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.373]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.373]                     ...future.globalenv.names))
[08:27:41.373]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.373]         }, condition = base::local({
[08:27:41.373]             c <- base::c
[08:27:41.373]             inherits <- base::inherits
[08:27:41.373]             invokeRestart <- base::invokeRestart
[08:27:41.373]             length <- base::length
[08:27:41.373]             list <- base::list
[08:27:41.373]             seq.int <- base::seq.int
[08:27:41.373]             signalCondition <- base::signalCondition
[08:27:41.373]             sys.calls <- base::sys.calls
[08:27:41.373]             `[[` <- base::`[[`
[08:27:41.373]             `+` <- base::`+`
[08:27:41.373]             `<<-` <- base::`<<-`
[08:27:41.373]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.373]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.373]                   3L)]
[08:27:41.373]             }
[08:27:41.373]             function(cond) {
[08:27:41.373]                 is_error <- inherits(cond, "error")
[08:27:41.373]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.373]                   NULL)
[08:27:41.373]                 if (is_error) {
[08:27:41.373]                   sessionInformation <- function() {
[08:27:41.373]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.373]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.373]                       search = base::search(), system = base::Sys.info())
[08:27:41.373]                   }
[08:27:41.373]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.373]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.373]                     cond$call), session = sessionInformation(), 
[08:27:41.373]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.373]                   signalCondition(cond)
[08:27:41.373]                 }
[08:27:41.373]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.373]                 "immediateCondition"))) {
[08:27:41.373]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.373]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.373]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.373]                   if (TRUE && !signal) {
[08:27:41.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.373]                     {
[08:27:41.373]                       inherits <- base::inherits
[08:27:41.373]                       invokeRestart <- base::invokeRestart
[08:27:41.373]                       is.null <- base::is.null
[08:27:41.373]                       muffled <- FALSE
[08:27:41.373]                       if (inherits(cond, "message")) {
[08:27:41.373]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.373]                         if (muffled) 
[08:27:41.373]                           invokeRestart("muffleMessage")
[08:27:41.373]                       }
[08:27:41.373]                       else if (inherits(cond, "warning")) {
[08:27:41.373]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.373]                         if (muffled) 
[08:27:41.373]                           invokeRestart("muffleWarning")
[08:27:41.373]                       }
[08:27:41.373]                       else if (inherits(cond, "condition")) {
[08:27:41.373]                         if (!is.null(pattern)) {
[08:27:41.373]                           computeRestarts <- base::computeRestarts
[08:27:41.373]                           grepl <- base::grepl
[08:27:41.373]                           restarts <- computeRestarts(cond)
[08:27:41.373]                           for (restart in restarts) {
[08:27:41.373]                             name <- restart$name
[08:27:41.373]                             if (is.null(name)) 
[08:27:41.373]                               next
[08:27:41.373]                             if (!grepl(pattern, name)) 
[08:27:41.373]                               next
[08:27:41.373]                             invokeRestart(restart)
[08:27:41.373]                             muffled <- TRUE
[08:27:41.373]                             break
[08:27:41.373]                           }
[08:27:41.373]                         }
[08:27:41.373]                       }
[08:27:41.373]                       invisible(muffled)
[08:27:41.373]                     }
[08:27:41.373]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.373]                   }
[08:27:41.373]                 }
[08:27:41.373]                 else {
[08:27:41.373]                   if (TRUE) {
[08:27:41.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.373]                     {
[08:27:41.373]                       inherits <- base::inherits
[08:27:41.373]                       invokeRestart <- base::invokeRestart
[08:27:41.373]                       is.null <- base::is.null
[08:27:41.373]                       muffled <- FALSE
[08:27:41.373]                       if (inherits(cond, "message")) {
[08:27:41.373]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.373]                         if (muffled) 
[08:27:41.373]                           invokeRestart("muffleMessage")
[08:27:41.373]                       }
[08:27:41.373]                       else if (inherits(cond, "warning")) {
[08:27:41.373]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.373]                         if (muffled) 
[08:27:41.373]                           invokeRestart("muffleWarning")
[08:27:41.373]                       }
[08:27:41.373]                       else if (inherits(cond, "condition")) {
[08:27:41.373]                         if (!is.null(pattern)) {
[08:27:41.373]                           computeRestarts <- base::computeRestarts
[08:27:41.373]                           grepl <- base::grepl
[08:27:41.373]                           restarts <- computeRestarts(cond)
[08:27:41.373]                           for (restart in restarts) {
[08:27:41.373]                             name <- restart$name
[08:27:41.373]                             if (is.null(name)) 
[08:27:41.373]                               next
[08:27:41.373]                             if (!grepl(pattern, name)) 
[08:27:41.373]                               next
[08:27:41.373]                             invokeRestart(restart)
[08:27:41.373]                             muffled <- TRUE
[08:27:41.373]                             break
[08:27:41.373]                           }
[08:27:41.373]                         }
[08:27:41.373]                       }
[08:27:41.373]                       invisible(muffled)
[08:27:41.373]                     }
[08:27:41.373]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.373]                   }
[08:27:41.373]                 }
[08:27:41.373]             }
[08:27:41.373]         }))
[08:27:41.373]     }, error = function(ex) {
[08:27:41.373]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.373]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.373]                 ...future.rng), started = ...future.startTime, 
[08:27:41.373]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.373]             version = "1.8"), class = "FutureResult")
[08:27:41.373]     }, finally = {
[08:27:41.373]         if (!identical(...future.workdir, getwd())) 
[08:27:41.373]             setwd(...future.workdir)
[08:27:41.373]         {
[08:27:41.373]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.373]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.373]             }
[08:27:41.373]             base::options(...future.oldOptions)
[08:27:41.373]             if (.Platform$OS.type == "windows") {
[08:27:41.373]                 old_names <- names(...future.oldEnvVars)
[08:27:41.373]                 envs <- base::Sys.getenv()
[08:27:41.373]                 names <- names(envs)
[08:27:41.373]                 common <- intersect(names, old_names)
[08:27:41.373]                 added <- setdiff(names, old_names)
[08:27:41.373]                 removed <- setdiff(old_names, names)
[08:27:41.373]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.373]                   envs[common]]
[08:27:41.373]                 NAMES <- toupper(changed)
[08:27:41.373]                 args <- list()
[08:27:41.373]                 for (kk in seq_along(NAMES)) {
[08:27:41.373]                   name <- changed[[kk]]
[08:27:41.373]                   NAME <- NAMES[[kk]]
[08:27:41.373]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.373]                     next
[08:27:41.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.373]                 }
[08:27:41.373]                 NAMES <- toupper(added)
[08:27:41.373]                 for (kk in seq_along(NAMES)) {
[08:27:41.373]                   name <- added[[kk]]
[08:27:41.373]                   NAME <- NAMES[[kk]]
[08:27:41.373]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.373]                     next
[08:27:41.373]                   args[[name]] <- ""
[08:27:41.373]                 }
[08:27:41.373]                 NAMES <- toupper(removed)
[08:27:41.373]                 for (kk in seq_along(NAMES)) {
[08:27:41.373]                   name <- removed[[kk]]
[08:27:41.373]                   NAME <- NAMES[[kk]]
[08:27:41.373]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.373]                     next
[08:27:41.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.373]                 }
[08:27:41.373]                 if (length(args) > 0) 
[08:27:41.373]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.373]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.373]             }
[08:27:41.373]             else {
[08:27:41.373]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.373]             }
[08:27:41.373]             {
[08:27:41.373]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.373]                   0L) {
[08:27:41.373]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.373]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.373]                   base::options(opts)
[08:27:41.373]                 }
[08:27:41.373]                 {
[08:27:41.373]                   {
[08:27:41.373]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:41.373]                     NULL
[08:27:41.373]                   }
[08:27:41.373]                   options(future.plan = NULL)
[08:27:41.373]                   if (is.na(NA_character_)) 
[08:27:41.373]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.373]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.373]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.373]                     .init = FALSE)
[08:27:41.373]                 }
[08:27:41.373]             }
[08:27:41.373]         }
[08:27:41.373]     })
[08:27:41.373]     if (TRUE) {
[08:27:41.373]         base::sink(type = "output", split = FALSE)
[08:27:41.373]         if (TRUE) {
[08:27:41.373]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.373]         }
[08:27:41.373]         else {
[08:27:41.373]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.373]         }
[08:27:41.373]         base::close(...future.stdout)
[08:27:41.373]         ...future.stdout <- NULL
[08:27:41.373]     }
[08:27:41.373]     ...future.result$conditions <- ...future.conditions
[08:27:41.373]     ...future.result$finished <- base::Sys.time()
[08:27:41.373]     ...future.result
[08:27:41.373] }
[08:27:41.375] assign_globals() ...
[08:27:41.375] List of 1
[08:27:41.375]  $ a: num 2
[08:27:41.375]  - attr(*, "where")=List of 1
[08:27:41.375]   ..$ a:<environment: R_EmptyEnv> 
[08:27:41.375]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:41.375]  - attr(*, "resolved")= logi FALSE
[08:27:41.375]  - attr(*, "total_size")= num 39
[08:27:41.375]  - attr(*, "already-done")= logi TRUE
[08:27:41.378] - copied ‘a’ to environment
[08:27:41.379] assign_globals() ... done
[08:27:41.379] requestCore(): workers = 2
[08:27:41.381] MulticoreFuture started
[08:27:41.381] - Launch lazy future ... done
[08:27:41.382] run() for ‘MulticoreFuture’ ... done
[08:27:41.382] plan(): Setting new future strategy stack:
[08:27:41.382] result() for MulticoreFuture ...
[08:27:41.382] List of future strategies:
[08:27:41.382] 1. sequential:
[08:27:41.382]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.382]    - tweaked: FALSE
[08:27:41.382]    - call: NULL
[08:27:41.383] plan(): nbrOfWorkers() = 1
[08:27:41.385] plan(): Setting new future strategy stack:
[08:27:41.385] List of future strategies:
[08:27:41.385] 1. multicore:
[08:27:41.385]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:41.385]    - tweaked: FALSE
[08:27:41.385]    - call: plan(strategy)
[08:27:41.388] plan(): nbrOfWorkers() = 2
[08:27:41.389] result() for MulticoreFuture ...
[08:27:41.389] result() for MulticoreFuture ... done
[08:27:41.389] result() for MulticoreFuture ... done
[08:27:41.389] result() for MulticoreFuture ...
[08:27:41.389] result() for MulticoreFuture ... done
** Future evaluation with errors
[08:27:41.390] getGlobalsAndPackages() ...
[08:27:41.390] Searching for globals...
[08:27:41.396] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[08:27:41.396] Searching for globals ... DONE
[08:27:41.396] Resolving globals: FALSE
[08:27:41.396] 
[08:27:41.397] 
[08:27:41.397] getGlobalsAndPackages() ... DONE
[08:27:41.397] run() for ‘Future’ ...
[08:27:41.397] - state: ‘created’
[08:27:41.397] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:41.399] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:41.400] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:41.400]   - Field: ‘label’
[08:27:41.400]   - Field: ‘local’
[08:27:41.400]   - Field: ‘owner’
[08:27:41.400]   - Field: ‘envir’
[08:27:41.400]   - Field: ‘workers’
[08:27:41.400]   - Field: ‘packages’
[08:27:41.401]   - Field: ‘gc’
[08:27:41.401]   - Field: ‘job’
[08:27:41.401]   - Field: ‘conditions’
[08:27:41.401]   - Field: ‘expr’
[08:27:41.401]   - Field: ‘uuid’
[08:27:41.401]   - Field: ‘seed’
[08:27:41.401]   - Field: ‘version’
[08:27:41.401]   - Field: ‘result’
[08:27:41.401]   - Field: ‘asynchronous’
[08:27:41.402]   - Field: ‘calls’
[08:27:41.402]   - Field: ‘globals’
[08:27:41.402]   - Field: ‘stdout’
[08:27:41.402]   - Field: ‘earlySignal’
[08:27:41.402]   - Field: ‘lazy’
[08:27:41.402]   - Field: ‘state’
[08:27:41.402] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:41.402] - Launch lazy future ...
[08:27:41.403] Packages needed by the future expression (n = 0): <none>
[08:27:41.403] Packages needed by future strategies (n = 0): <none>
[08:27:41.403] {
[08:27:41.403]     {
[08:27:41.403]         {
[08:27:41.403]             ...future.startTime <- base::Sys.time()
[08:27:41.403]             {
[08:27:41.403]                 {
[08:27:41.403]                   {
[08:27:41.403]                     {
[08:27:41.403]                       base::local({
[08:27:41.403]                         has_future <- base::requireNamespace("future", 
[08:27:41.403]                           quietly = TRUE)
[08:27:41.403]                         if (has_future) {
[08:27:41.403]                           ns <- base::getNamespace("future")
[08:27:41.403]                           version <- ns[[".package"]][["version"]]
[08:27:41.403]                           if (is.null(version)) 
[08:27:41.403]                             version <- utils::packageVersion("future")
[08:27:41.403]                         }
[08:27:41.403]                         else {
[08:27:41.403]                           version <- NULL
[08:27:41.403]                         }
[08:27:41.403]                         if (!has_future || version < "1.8.0") {
[08:27:41.403]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.403]                             "", base::R.version$version.string), 
[08:27:41.403]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:41.403]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.403]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.403]                               "release", "version")], collapse = " "), 
[08:27:41.403]                             hostname = base::Sys.info()[["nodename"]])
[08:27:41.403]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.403]                             info)
[08:27:41.403]                           info <- base::paste(info, collapse = "; ")
[08:27:41.403]                           if (!has_future) {
[08:27:41.403]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.403]                               info)
[08:27:41.403]                           }
[08:27:41.403]                           else {
[08:27:41.403]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.403]                               info, version)
[08:27:41.403]                           }
[08:27:41.403]                           base::stop(msg)
[08:27:41.403]                         }
[08:27:41.403]                       })
[08:27:41.403]                     }
[08:27:41.403]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:41.403]                     base::options(mc.cores = 1L)
[08:27:41.403]                   }
[08:27:41.403]                   ...future.strategy.old <- future::plan("list")
[08:27:41.403]                   options(future.plan = NULL)
[08:27:41.403]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.403]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.403]                 }
[08:27:41.403]                 ...future.workdir <- getwd()
[08:27:41.403]             }
[08:27:41.403]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.403]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.403]         }
[08:27:41.403]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.403]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.403]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.403]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.403]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.403]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.403]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.403]             base::names(...future.oldOptions))
[08:27:41.403]     }
[08:27:41.403]     if (FALSE) {
[08:27:41.403]     }
[08:27:41.403]     else {
[08:27:41.403]         if (TRUE) {
[08:27:41.403]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.403]                 open = "w")
[08:27:41.403]         }
[08:27:41.403]         else {
[08:27:41.403]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.403]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.403]         }
[08:27:41.403]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.403]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.403]             base::sink(type = "output", split = FALSE)
[08:27:41.403]             base::close(...future.stdout)
[08:27:41.403]         }, add = TRUE)
[08:27:41.403]     }
[08:27:41.403]     ...future.frame <- base::sys.nframe()
[08:27:41.403]     ...future.conditions <- base::list()
[08:27:41.403]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.403]     if (FALSE) {
[08:27:41.403]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.403]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.403]     }
[08:27:41.403]     ...future.result <- base::tryCatch({
[08:27:41.403]         base::withCallingHandlers({
[08:27:41.403]             ...future.value <- base::withVisible(base::local({
[08:27:41.403]                 withCallingHandlers({
[08:27:41.403]                   {
[08:27:41.403]                     x <- 3
[08:27:41.403]                     stop("Woops!")
[08:27:41.403]                     x
[08:27:41.403]                   }
[08:27:41.403]                 }, immediateCondition = function(cond) {
[08:27:41.403]                   save_rds <- function (object, pathname, ...) 
[08:27:41.403]                   {
[08:27:41.403]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:41.403]                     if (file_test("-f", pathname_tmp)) {
[08:27:41.403]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.403]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:41.403]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.403]                         fi_tmp[["mtime"]])
[08:27:41.403]                     }
[08:27:41.403]                     tryCatch({
[08:27:41.403]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:41.403]                     }, error = function(ex) {
[08:27:41.403]                       msg <- conditionMessage(ex)
[08:27:41.403]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.403]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:41.403]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.403]                         fi_tmp[["mtime"]], msg)
[08:27:41.403]                       ex$message <- msg
[08:27:41.403]                       stop(ex)
[08:27:41.403]                     })
[08:27:41.403]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:41.403]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:41.403]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:41.403]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.403]                       fi <- file.info(pathname)
[08:27:41.403]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:41.403]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.403]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:41.403]                         fi[["size"]], fi[["mtime"]])
[08:27:41.403]                       stop(msg)
[08:27:41.403]                     }
[08:27:41.403]                     invisible(pathname)
[08:27:41.403]                   }
[08:27:41.403]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:41.403]                     rootPath = tempdir()) 
[08:27:41.403]                   {
[08:27:41.403]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:41.403]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:41.403]                       tmpdir = path, fileext = ".rds")
[08:27:41.403]                     save_rds(obj, file)
[08:27:41.403]                   }
[08:27:41.403]                   saveImmediateCondition(cond, path = "/tmp/RtmpOWg6bo/.future/immediateConditions")
[08:27:41.403]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.403]                   {
[08:27:41.403]                     inherits <- base::inherits
[08:27:41.403]                     invokeRestart <- base::invokeRestart
[08:27:41.403]                     is.null <- base::is.null
[08:27:41.403]                     muffled <- FALSE
[08:27:41.403]                     if (inherits(cond, "message")) {
[08:27:41.403]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:41.403]                       if (muffled) 
[08:27:41.403]                         invokeRestart("muffleMessage")
[08:27:41.403]                     }
[08:27:41.403]                     else if (inherits(cond, "warning")) {
[08:27:41.403]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:41.403]                       if (muffled) 
[08:27:41.403]                         invokeRestart("muffleWarning")
[08:27:41.403]                     }
[08:27:41.403]                     else if (inherits(cond, "condition")) {
[08:27:41.403]                       if (!is.null(pattern)) {
[08:27:41.403]                         computeRestarts <- base::computeRestarts
[08:27:41.403]                         grepl <- base::grepl
[08:27:41.403]                         restarts <- computeRestarts(cond)
[08:27:41.403]                         for (restart in restarts) {
[08:27:41.403]                           name <- restart$name
[08:27:41.403]                           if (is.null(name)) 
[08:27:41.403]                             next
[08:27:41.403]                           if (!grepl(pattern, name)) 
[08:27:41.403]                             next
[08:27:41.403]                           invokeRestart(restart)
[08:27:41.403]                           muffled <- TRUE
[08:27:41.403]                           break
[08:27:41.403]                         }
[08:27:41.403]                       }
[08:27:41.403]                     }
[08:27:41.403]                     invisible(muffled)
[08:27:41.403]                   }
[08:27:41.403]                   muffleCondition(cond)
[08:27:41.403]                 })
[08:27:41.403]             }))
[08:27:41.403]             future::FutureResult(value = ...future.value$value, 
[08:27:41.403]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.403]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.403]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.403]                     ...future.globalenv.names))
[08:27:41.403]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.403]         }, condition = base::local({
[08:27:41.403]             c <- base::c
[08:27:41.403]             inherits <- base::inherits
[08:27:41.403]             invokeRestart <- base::invokeRestart
[08:27:41.403]             length <- base::length
[08:27:41.403]             list <- base::list
[08:27:41.403]             seq.int <- base::seq.int
[08:27:41.403]             signalCondition <- base::signalCondition
[08:27:41.403]             sys.calls <- base::sys.calls
[08:27:41.403]             `[[` <- base::`[[`
[08:27:41.403]             `+` <- base::`+`
[08:27:41.403]             `<<-` <- base::`<<-`
[08:27:41.403]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.403]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.403]                   3L)]
[08:27:41.403]             }
[08:27:41.403]             function(cond) {
[08:27:41.403]                 is_error <- inherits(cond, "error")
[08:27:41.403]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.403]                   NULL)
[08:27:41.403]                 if (is_error) {
[08:27:41.403]                   sessionInformation <- function() {
[08:27:41.403]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.403]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.403]                       search = base::search(), system = base::Sys.info())
[08:27:41.403]                   }
[08:27:41.403]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.403]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.403]                     cond$call), session = sessionInformation(), 
[08:27:41.403]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.403]                   signalCondition(cond)
[08:27:41.403]                 }
[08:27:41.403]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.403]                 "immediateCondition"))) {
[08:27:41.403]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.403]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.403]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.403]                   if (TRUE && !signal) {
[08:27:41.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.403]                     {
[08:27:41.403]                       inherits <- base::inherits
[08:27:41.403]                       invokeRestart <- base::invokeRestart
[08:27:41.403]                       is.null <- base::is.null
[08:27:41.403]                       muffled <- FALSE
[08:27:41.403]                       if (inherits(cond, "message")) {
[08:27:41.403]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.403]                         if (muffled) 
[08:27:41.403]                           invokeRestart("muffleMessage")
[08:27:41.403]                       }
[08:27:41.403]                       else if (inherits(cond, "warning")) {
[08:27:41.403]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.403]                         if (muffled) 
[08:27:41.403]                           invokeRestart("muffleWarning")
[08:27:41.403]                       }
[08:27:41.403]                       else if (inherits(cond, "condition")) {
[08:27:41.403]                         if (!is.null(pattern)) {
[08:27:41.403]                           computeRestarts <- base::computeRestarts
[08:27:41.403]                           grepl <- base::grepl
[08:27:41.403]                           restarts <- computeRestarts(cond)
[08:27:41.403]                           for (restart in restarts) {
[08:27:41.403]                             name <- restart$name
[08:27:41.403]                             if (is.null(name)) 
[08:27:41.403]                               next
[08:27:41.403]                             if (!grepl(pattern, name)) 
[08:27:41.403]                               next
[08:27:41.403]                             invokeRestart(restart)
[08:27:41.403]                             muffled <- TRUE
[08:27:41.403]                             break
[08:27:41.403]                           }
[08:27:41.403]                         }
[08:27:41.403]                       }
[08:27:41.403]                       invisible(muffled)
[08:27:41.403]                     }
[08:27:41.403]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.403]                   }
[08:27:41.403]                 }
[08:27:41.403]                 else {
[08:27:41.403]                   if (TRUE) {
[08:27:41.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.403]                     {
[08:27:41.403]                       inherits <- base::inherits
[08:27:41.403]                       invokeRestart <- base::invokeRestart
[08:27:41.403]                       is.null <- base::is.null
[08:27:41.403]                       muffled <- FALSE
[08:27:41.403]                       if (inherits(cond, "message")) {
[08:27:41.403]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.403]                         if (muffled) 
[08:27:41.403]                           invokeRestart("muffleMessage")
[08:27:41.403]                       }
[08:27:41.403]                       else if (inherits(cond, "warning")) {
[08:27:41.403]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.403]                         if (muffled) 
[08:27:41.403]                           invokeRestart("muffleWarning")
[08:27:41.403]                       }
[08:27:41.403]                       else if (inherits(cond, "condition")) {
[08:27:41.403]                         if (!is.null(pattern)) {
[08:27:41.403]                           computeRestarts <- base::computeRestarts
[08:27:41.403]                           grepl <- base::grepl
[08:27:41.403]                           restarts <- computeRestarts(cond)
[08:27:41.403]                           for (restart in restarts) {
[08:27:41.403]                             name <- restart$name
[08:27:41.403]                             if (is.null(name)) 
[08:27:41.403]                               next
[08:27:41.403]                             if (!grepl(pattern, name)) 
[08:27:41.403]                               next
[08:27:41.403]                             invokeRestart(restart)
[08:27:41.403]                             muffled <- TRUE
[08:27:41.403]                             break
[08:27:41.403]                           }
[08:27:41.403]                         }
[08:27:41.403]                       }
[08:27:41.403]                       invisible(muffled)
[08:27:41.403]                     }
[08:27:41.403]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.403]                   }
[08:27:41.403]                 }
[08:27:41.403]             }
[08:27:41.403]         }))
[08:27:41.403]     }, error = function(ex) {
[08:27:41.403]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.403]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.403]                 ...future.rng), started = ...future.startTime, 
[08:27:41.403]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.403]             version = "1.8"), class = "FutureResult")
[08:27:41.403]     }, finally = {
[08:27:41.403]         if (!identical(...future.workdir, getwd())) 
[08:27:41.403]             setwd(...future.workdir)
[08:27:41.403]         {
[08:27:41.403]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.403]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.403]             }
[08:27:41.403]             base::options(...future.oldOptions)
[08:27:41.403]             if (.Platform$OS.type == "windows") {
[08:27:41.403]                 old_names <- names(...future.oldEnvVars)
[08:27:41.403]                 envs <- base::Sys.getenv()
[08:27:41.403]                 names <- names(envs)
[08:27:41.403]                 common <- intersect(names, old_names)
[08:27:41.403]                 added <- setdiff(names, old_names)
[08:27:41.403]                 removed <- setdiff(old_names, names)
[08:27:41.403]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.403]                   envs[common]]
[08:27:41.403]                 NAMES <- toupper(changed)
[08:27:41.403]                 args <- list()
[08:27:41.403]                 for (kk in seq_along(NAMES)) {
[08:27:41.403]                   name <- changed[[kk]]
[08:27:41.403]                   NAME <- NAMES[[kk]]
[08:27:41.403]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.403]                     next
[08:27:41.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.403]                 }
[08:27:41.403]                 NAMES <- toupper(added)
[08:27:41.403]                 for (kk in seq_along(NAMES)) {
[08:27:41.403]                   name <- added[[kk]]
[08:27:41.403]                   NAME <- NAMES[[kk]]
[08:27:41.403]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.403]                     next
[08:27:41.403]                   args[[name]] <- ""
[08:27:41.403]                 }
[08:27:41.403]                 NAMES <- toupper(removed)
[08:27:41.403]                 for (kk in seq_along(NAMES)) {
[08:27:41.403]                   name <- removed[[kk]]
[08:27:41.403]                   NAME <- NAMES[[kk]]
[08:27:41.403]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.403]                     next
[08:27:41.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.403]                 }
[08:27:41.403]                 if (length(args) > 0) 
[08:27:41.403]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.403]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.403]             }
[08:27:41.403]             else {
[08:27:41.403]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.403]             }
[08:27:41.403]             {
[08:27:41.403]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.403]                   0L) {
[08:27:41.403]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.403]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.403]                   base::options(opts)
[08:27:41.403]                 }
[08:27:41.403]                 {
[08:27:41.403]                   {
[08:27:41.403]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:41.403]                     NULL
[08:27:41.403]                   }
[08:27:41.403]                   options(future.plan = NULL)
[08:27:41.403]                   if (is.na(NA_character_)) 
[08:27:41.403]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.403]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.403]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.403]                     .init = FALSE)
[08:27:41.403]                 }
[08:27:41.403]             }
[08:27:41.403]         }
[08:27:41.403]     })
[08:27:41.403]     if (TRUE) {
[08:27:41.403]         base::sink(type = "output", split = FALSE)
[08:27:41.403]         if (TRUE) {
[08:27:41.403]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.403]         }
[08:27:41.403]         else {
[08:27:41.403]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.403]         }
[08:27:41.403]         base::close(...future.stdout)
[08:27:41.403]         ...future.stdout <- NULL
[08:27:41.403]     }
[08:27:41.403]     ...future.result$conditions <- ...future.conditions
[08:27:41.403]     ...future.result$finished <- base::Sys.time()
[08:27:41.403]     ...future.result
[08:27:41.403] }
[08:27:41.406] requestCore(): workers = 2
[08:27:41.408] MulticoreFuture started
[08:27:41.409] - Launch lazy future ... done
[08:27:41.409] run() for ‘MulticoreFuture’ ... done
[08:27:41.409] plan(): Setting new future strategy stack:
[08:27:41.410] result() for MulticoreFuture ...
[08:27:41.409] List of future strategies:
[08:27:41.409] 1. sequential:
[08:27:41.409]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.409]    - tweaked: FALSE
[08:27:41.409]    - call: NULL
[08:27:41.410] plan(): nbrOfWorkers() = 1
[08:27:41.412] plan(): Setting new future strategy stack:
[08:27:41.412] List of future strategies:
[08:27:41.412] 1. multicore:
[08:27:41.412]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:41.412]    - tweaked: FALSE
[08:27:41.412]    - call: plan(strategy)
[08:27:41.416] plan(): nbrOfWorkers() = 2
[08:27:41.421] result() for MulticoreFuture ...
[08:27:41.421] result() for MulticoreFuture ... done
[08:27:41.421] signalConditions() ...
[08:27:41.421]  - include = ‘immediateCondition’
[08:27:41.422]  - exclude = 
[08:27:41.422]  - resignal = FALSE
[08:27:41.422]  - Number of conditions: 1
[08:27:41.422] signalConditions() ... done
[08:27:41.422] result() for MulticoreFuture ... done
[08:27:41.422] result() for MulticoreFuture ...
[08:27:41.422] result() for MulticoreFuture ... done
[08:27:41.423] signalConditions() ...
[08:27:41.423]  - include = ‘immediateCondition’
[08:27:41.423]  - exclude = 
[08:27:41.423]  - resignal = FALSE
[08:27:41.423]  - Number of conditions: 1
[08:27:41.423] signalConditions() ... done
[08:27:41.423] Future state: ‘finished’
[08:27:41.424] result() for MulticoreFuture ...
[08:27:41.424] result() for MulticoreFuture ... done
[08:27:41.424] signalConditions() ...
[08:27:41.424]  - include = ‘condition’
[08:27:41.424]  - exclude = ‘immediateCondition’
[08:27:41.424]  - resignal = TRUE
[08:27:41.424]  - Number of conditions: 1
[08:27:41.424]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:27:41.425] signalConditions() ... done
[08:27:41.425] getGlobalsAndPackages() ...
[08:27:41.425] Searching for globals...
[08:27:41.427] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[08:27:41.428] Searching for globals ... DONE
[08:27:41.428] Resolving globals: FALSE
[08:27:41.428] The total size of the 1 globals is 35 bytes (35 bytes)
[08:27:41.429] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:27:41.429] - globals: [1] ‘ii’
[08:27:41.429] 
[08:27:41.429] getGlobalsAndPackages() ... DONE
[08:27:41.430] run() for ‘Future’ ...
[08:27:41.430] - state: ‘created’
[08:27:41.430] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:41.432] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:41.432] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:41.432]   - Field: ‘label’
[08:27:41.433]   - Field: ‘local’
[08:27:41.433]   - Field: ‘owner’
[08:27:41.433]   - Field: ‘envir’
[08:27:41.433]   - Field: ‘workers’
[08:27:41.433]   - Field: ‘packages’
[08:27:41.433]   - Field: ‘gc’
[08:27:41.433]   - Field: ‘job’
[08:27:41.433]   - Field: ‘conditions’
[08:27:41.433]   - Field: ‘expr’
[08:27:41.433]   - Field: ‘uuid’
[08:27:41.434]   - Field: ‘seed’
[08:27:41.434]   - Field: ‘version’
[08:27:41.434]   - Field: ‘result’
[08:27:41.434]   - Field: ‘asynchronous’
[08:27:41.434]   - Field: ‘calls’
[08:27:41.434]   - Field: ‘globals’
[08:27:41.434]   - Field: ‘stdout’
[08:27:41.434]   - Field: ‘earlySignal’
[08:27:41.434]   - Field: ‘lazy’
[08:27:41.434]   - Field: ‘state’
[08:27:41.435] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:41.435] - Launch lazy future ...
[08:27:41.435] Packages needed by the future expression (n = 0): <none>
[08:27:41.435] Packages needed by future strategies (n = 0): <none>
[08:27:41.436] {
[08:27:41.436]     {
[08:27:41.436]         {
[08:27:41.436]             ...future.startTime <- base::Sys.time()
[08:27:41.436]             {
[08:27:41.436]                 {
[08:27:41.436]                   {
[08:27:41.436]                     {
[08:27:41.436]                       base::local({
[08:27:41.436]                         has_future <- base::requireNamespace("future", 
[08:27:41.436]                           quietly = TRUE)
[08:27:41.436]                         if (has_future) {
[08:27:41.436]                           ns <- base::getNamespace("future")
[08:27:41.436]                           version <- ns[[".package"]][["version"]]
[08:27:41.436]                           if (is.null(version)) 
[08:27:41.436]                             version <- utils::packageVersion("future")
[08:27:41.436]                         }
[08:27:41.436]                         else {
[08:27:41.436]                           version <- NULL
[08:27:41.436]                         }
[08:27:41.436]                         if (!has_future || version < "1.8.0") {
[08:27:41.436]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.436]                             "", base::R.version$version.string), 
[08:27:41.436]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:41.436]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.436]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.436]                               "release", "version")], collapse = " "), 
[08:27:41.436]                             hostname = base::Sys.info()[["nodename"]])
[08:27:41.436]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.436]                             info)
[08:27:41.436]                           info <- base::paste(info, collapse = "; ")
[08:27:41.436]                           if (!has_future) {
[08:27:41.436]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.436]                               info)
[08:27:41.436]                           }
[08:27:41.436]                           else {
[08:27:41.436]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.436]                               info, version)
[08:27:41.436]                           }
[08:27:41.436]                           base::stop(msg)
[08:27:41.436]                         }
[08:27:41.436]                       })
[08:27:41.436]                     }
[08:27:41.436]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:41.436]                     base::options(mc.cores = 1L)
[08:27:41.436]                   }
[08:27:41.436]                   ...future.strategy.old <- future::plan("list")
[08:27:41.436]                   options(future.plan = NULL)
[08:27:41.436]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.436]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.436]                 }
[08:27:41.436]                 ...future.workdir <- getwd()
[08:27:41.436]             }
[08:27:41.436]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.436]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.436]         }
[08:27:41.436]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.436]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.436]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.436]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.436]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.436]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.436]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.436]             base::names(...future.oldOptions))
[08:27:41.436]     }
[08:27:41.436]     if (FALSE) {
[08:27:41.436]     }
[08:27:41.436]     else {
[08:27:41.436]         if (TRUE) {
[08:27:41.436]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.436]                 open = "w")
[08:27:41.436]         }
[08:27:41.436]         else {
[08:27:41.436]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.436]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.436]         }
[08:27:41.436]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.436]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.436]             base::sink(type = "output", split = FALSE)
[08:27:41.436]             base::close(...future.stdout)
[08:27:41.436]         }, add = TRUE)
[08:27:41.436]     }
[08:27:41.436]     ...future.frame <- base::sys.nframe()
[08:27:41.436]     ...future.conditions <- base::list()
[08:27:41.436]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.436]     if (FALSE) {
[08:27:41.436]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.436]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.436]     }
[08:27:41.436]     ...future.result <- base::tryCatch({
[08:27:41.436]         base::withCallingHandlers({
[08:27:41.436]             ...future.value <- base::withVisible(base::local({
[08:27:41.436]                 withCallingHandlers({
[08:27:41.436]                   {
[08:27:41.436]                     if (ii%%2 == 0) 
[08:27:41.436]                       stop("Woops!")
[08:27:41.436]                     ii
[08:27:41.436]                   }
[08:27:41.436]                 }, immediateCondition = function(cond) {
[08:27:41.436]                   save_rds <- function (object, pathname, ...) 
[08:27:41.436]                   {
[08:27:41.436]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:41.436]                     if (file_test("-f", pathname_tmp)) {
[08:27:41.436]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.436]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:41.436]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.436]                         fi_tmp[["mtime"]])
[08:27:41.436]                     }
[08:27:41.436]                     tryCatch({
[08:27:41.436]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:41.436]                     }, error = function(ex) {
[08:27:41.436]                       msg <- conditionMessage(ex)
[08:27:41.436]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.436]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:41.436]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.436]                         fi_tmp[["mtime"]], msg)
[08:27:41.436]                       ex$message <- msg
[08:27:41.436]                       stop(ex)
[08:27:41.436]                     })
[08:27:41.436]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:41.436]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:41.436]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:41.436]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.436]                       fi <- file.info(pathname)
[08:27:41.436]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:41.436]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.436]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:41.436]                         fi[["size"]], fi[["mtime"]])
[08:27:41.436]                       stop(msg)
[08:27:41.436]                     }
[08:27:41.436]                     invisible(pathname)
[08:27:41.436]                   }
[08:27:41.436]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:41.436]                     rootPath = tempdir()) 
[08:27:41.436]                   {
[08:27:41.436]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:41.436]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:41.436]                       tmpdir = path, fileext = ".rds")
[08:27:41.436]                     save_rds(obj, file)
[08:27:41.436]                   }
[08:27:41.436]                   saveImmediateCondition(cond, path = "/tmp/RtmpOWg6bo/.future/immediateConditions")
[08:27:41.436]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.436]                   {
[08:27:41.436]                     inherits <- base::inherits
[08:27:41.436]                     invokeRestart <- base::invokeRestart
[08:27:41.436]                     is.null <- base::is.null
[08:27:41.436]                     muffled <- FALSE
[08:27:41.436]                     if (inherits(cond, "message")) {
[08:27:41.436]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:41.436]                       if (muffled) 
[08:27:41.436]                         invokeRestart("muffleMessage")
[08:27:41.436]                     }
[08:27:41.436]                     else if (inherits(cond, "warning")) {
[08:27:41.436]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:41.436]                       if (muffled) 
[08:27:41.436]                         invokeRestart("muffleWarning")
[08:27:41.436]                     }
[08:27:41.436]                     else if (inherits(cond, "condition")) {
[08:27:41.436]                       if (!is.null(pattern)) {
[08:27:41.436]                         computeRestarts <- base::computeRestarts
[08:27:41.436]                         grepl <- base::grepl
[08:27:41.436]                         restarts <- computeRestarts(cond)
[08:27:41.436]                         for (restart in restarts) {
[08:27:41.436]                           name <- restart$name
[08:27:41.436]                           if (is.null(name)) 
[08:27:41.436]                             next
[08:27:41.436]                           if (!grepl(pattern, name)) 
[08:27:41.436]                             next
[08:27:41.436]                           invokeRestart(restart)
[08:27:41.436]                           muffled <- TRUE
[08:27:41.436]                           break
[08:27:41.436]                         }
[08:27:41.436]                       }
[08:27:41.436]                     }
[08:27:41.436]                     invisible(muffled)
[08:27:41.436]                   }
[08:27:41.436]                   muffleCondition(cond)
[08:27:41.436]                 })
[08:27:41.436]             }))
[08:27:41.436]             future::FutureResult(value = ...future.value$value, 
[08:27:41.436]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.436]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.436]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.436]                     ...future.globalenv.names))
[08:27:41.436]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.436]         }, condition = base::local({
[08:27:41.436]             c <- base::c
[08:27:41.436]             inherits <- base::inherits
[08:27:41.436]             invokeRestart <- base::invokeRestart
[08:27:41.436]             length <- base::length
[08:27:41.436]             list <- base::list
[08:27:41.436]             seq.int <- base::seq.int
[08:27:41.436]             signalCondition <- base::signalCondition
[08:27:41.436]             sys.calls <- base::sys.calls
[08:27:41.436]             `[[` <- base::`[[`
[08:27:41.436]             `+` <- base::`+`
[08:27:41.436]             `<<-` <- base::`<<-`
[08:27:41.436]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.436]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.436]                   3L)]
[08:27:41.436]             }
[08:27:41.436]             function(cond) {
[08:27:41.436]                 is_error <- inherits(cond, "error")
[08:27:41.436]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.436]                   NULL)
[08:27:41.436]                 if (is_error) {
[08:27:41.436]                   sessionInformation <- function() {
[08:27:41.436]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.436]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.436]                       search = base::search(), system = base::Sys.info())
[08:27:41.436]                   }
[08:27:41.436]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.436]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.436]                     cond$call), session = sessionInformation(), 
[08:27:41.436]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.436]                   signalCondition(cond)
[08:27:41.436]                 }
[08:27:41.436]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.436]                 "immediateCondition"))) {
[08:27:41.436]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.436]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.436]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.436]                   if (TRUE && !signal) {
[08:27:41.436]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.436]                     {
[08:27:41.436]                       inherits <- base::inherits
[08:27:41.436]                       invokeRestart <- base::invokeRestart
[08:27:41.436]                       is.null <- base::is.null
[08:27:41.436]                       muffled <- FALSE
[08:27:41.436]                       if (inherits(cond, "message")) {
[08:27:41.436]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.436]                         if (muffled) 
[08:27:41.436]                           invokeRestart("muffleMessage")
[08:27:41.436]                       }
[08:27:41.436]                       else if (inherits(cond, "warning")) {
[08:27:41.436]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.436]                         if (muffled) 
[08:27:41.436]                           invokeRestart("muffleWarning")
[08:27:41.436]                       }
[08:27:41.436]                       else if (inherits(cond, "condition")) {
[08:27:41.436]                         if (!is.null(pattern)) {
[08:27:41.436]                           computeRestarts <- base::computeRestarts
[08:27:41.436]                           grepl <- base::grepl
[08:27:41.436]                           restarts <- computeRestarts(cond)
[08:27:41.436]                           for (restart in restarts) {
[08:27:41.436]                             name <- restart$name
[08:27:41.436]                             if (is.null(name)) 
[08:27:41.436]                               next
[08:27:41.436]                             if (!grepl(pattern, name)) 
[08:27:41.436]                               next
[08:27:41.436]                             invokeRestart(restart)
[08:27:41.436]                             muffled <- TRUE
[08:27:41.436]                             break
[08:27:41.436]                           }
[08:27:41.436]                         }
[08:27:41.436]                       }
[08:27:41.436]                       invisible(muffled)
[08:27:41.436]                     }
[08:27:41.436]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.436]                   }
[08:27:41.436]                 }
[08:27:41.436]                 else {
[08:27:41.436]                   if (TRUE) {
[08:27:41.436]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.436]                     {
[08:27:41.436]                       inherits <- base::inherits
[08:27:41.436]                       invokeRestart <- base::invokeRestart
[08:27:41.436]                       is.null <- base::is.null
[08:27:41.436]                       muffled <- FALSE
[08:27:41.436]                       if (inherits(cond, "message")) {
[08:27:41.436]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.436]                         if (muffled) 
[08:27:41.436]                           invokeRestart("muffleMessage")
[08:27:41.436]                       }
[08:27:41.436]                       else if (inherits(cond, "warning")) {
[08:27:41.436]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.436]                         if (muffled) 
[08:27:41.436]                           invokeRestart("muffleWarning")
[08:27:41.436]                       }
[08:27:41.436]                       else if (inherits(cond, "condition")) {
[08:27:41.436]                         if (!is.null(pattern)) {
[08:27:41.436]                           computeRestarts <- base::computeRestarts
[08:27:41.436]                           grepl <- base::grepl
[08:27:41.436]                           restarts <- computeRestarts(cond)
[08:27:41.436]                           for (restart in restarts) {
[08:27:41.436]                             name <- restart$name
[08:27:41.436]                             if (is.null(name)) 
[08:27:41.436]                               next
[08:27:41.436]                             if (!grepl(pattern, name)) 
[08:27:41.436]                               next
[08:27:41.436]                             invokeRestart(restart)
[08:27:41.436]                             muffled <- TRUE
[08:27:41.436]                             break
[08:27:41.436]                           }
[08:27:41.436]                         }
[08:27:41.436]                       }
[08:27:41.436]                       invisible(muffled)
[08:27:41.436]                     }
[08:27:41.436]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.436]                   }
[08:27:41.436]                 }
[08:27:41.436]             }
[08:27:41.436]         }))
[08:27:41.436]     }, error = function(ex) {
[08:27:41.436]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.436]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.436]                 ...future.rng), started = ...future.startTime, 
[08:27:41.436]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.436]             version = "1.8"), class = "FutureResult")
[08:27:41.436]     }, finally = {
[08:27:41.436]         if (!identical(...future.workdir, getwd())) 
[08:27:41.436]             setwd(...future.workdir)
[08:27:41.436]         {
[08:27:41.436]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.436]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.436]             }
[08:27:41.436]             base::options(...future.oldOptions)
[08:27:41.436]             if (.Platform$OS.type == "windows") {
[08:27:41.436]                 old_names <- names(...future.oldEnvVars)
[08:27:41.436]                 envs <- base::Sys.getenv()
[08:27:41.436]                 names <- names(envs)
[08:27:41.436]                 common <- intersect(names, old_names)
[08:27:41.436]                 added <- setdiff(names, old_names)
[08:27:41.436]                 removed <- setdiff(old_names, names)
[08:27:41.436]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.436]                   envs[common]]
[08:27:41.436]                 NAMES <- toupper(changed)
[08:27:41.436]                 args <- list()
[08:27:41.436]                 for (kk in seq_along(NAMES)) {
[08:27:41.436]                   name <- changed[[kk]]
[08:27:41.436]                   NAME <- NAMES[[kk]]
[08:27:41.436]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.436]                     next
[08:27:41.436]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.436]                 }
[08:27:41.436]                 NAMES <- toupper(added)
[08:27:41.436]                 for (kk in seq_along(NAMES)) {
[08:27:41.436]                   name <- added[[kk]]
[08:27:41.436]                   NAME <- NAMES[[kk]]
[08:27:41.436]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.436]                     next
[08:27:41.436]                   args[[name]] <- ""
[08:27:41.436]                 }
[08:27:41.436]                 NAMES <- toupper(removed)
[08:27:41.436]                 for (kk in seq_along(NAMES)) {
[08:27:41.436]                   name <- removed[[kk]]
[08:27:41.436]                   NAME <- NAMES[[kk]]
[08:27:41.436]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.436]                     next
[08:27:41.436]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.436]                 }
[08:27:41.436]                 if (length(args) > 0) 
[08:27:41.436]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.436]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.436]             }
[08:27:41.436]             else {
[08:27:41.436]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.436]             }
[08:27:41.436]             {
[08:27:41.436]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.436]                   0L) {
[08:27:41.436]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.436]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.436]                   base::options(opts)
[08:27:41.436]                 }
[08:27:41.436]                 {
[08:27:41.436]                   {
[08:27:41.436]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:41.436]                     NULL
[08:27:41.436]                   }
[08:27:41.436]                   options(future.plan = NULL)
[08:27:41.436]                   if (is.na(NA_character_)) 
[08:27:41.436]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.436]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.436]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.436]                     .init = FALSE)
[08:27:41.436]                 }
[08:27:41.436]             }
[08:27:41.436]         }
[08:27:41.436]     })
[08:27:41.436]     if (TRUE) {
[08:27:41.436]         base::sink(type = "output", split = FALSE)
[08:27:41.436]         if (TRUE) {
[08:27:41.436]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.436]         }
[08:27:41.436]         else {
[08:27:41.436]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.436]         }
[08:27:41.436]         base::close(...future.stdout)
[08:27:41.436]         ...future.stdout <- NULL
[08:27:41.436]     }
[08:27:41.436]     ...future.result$conditions <- ...future.conditions
[08:27:41.436]     ...future.result$finished <- base::Sys.time()
[08:27:41.436]     ...future.result
[08:27:41.436] }
[08:27:41.438] assign_globals() ...
[08:27:41.438] List of 1
[08:27:41.438]  $ ii: int 1
[08:27:41.438]  - attr(*, "where")=List of 1
[08:27:41.438]   ..$ ii:<environment: R_EmptyEnv> 
[08:27:41.438]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:41.438]  - attr(*, "resolved")= logi FALSE
[08:27:41.438]  - attr(*, "total_size")= num 35
[08:27:41.438]  - attr(*, "already-done")= logi TRUE
[08:27:41.444] - copied ‘ii’ to environment
[08:27:41.444] assign_globals() ... done
[08:27:41.444] requestCore(): workers = 2
[08:27:41.447] MulticoreFuture started
[08:27:41.447] - Launch lazy future ... done
[08:27:41.448] plan(): Setting new future strategy stack:
[08:27:41.448] run() for ‘MulticoreFuture’ ... done
[08:27:41.448] List of future strategies:
[08:27:41.448] 1. sequential:
[08:27:41.448]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.448]    - tweaked: FALSE
[08:27:41.448]    - call: NULL
[08:27:41.449] getGlobalsAndPackages() ...
[08:27:41.449] plan(): nbrOfWorkers() = 1
[08:27:41.449] Searching for globals...
[08:27:41.451] plan(): Setting new future strategy stack:
[08:27:41.452] List of future strategies:
[08:27:41.452] 1. multicore:
[08:27:41.452]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:41.452]    - tweaked: FALSE
[08:27:41.452]    - call: plan(strategy)
[08:27:41.454] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[08:27:41.455] plan(): nbrOfWorkers() = 2
[08:27:41.455] Searching for globals ... DONE
[08:27:41.455] Resolving globals: FALSE
[08:27:41.456] The total size of the 1 globals is 35 bytes (35 bytes)
[08:27:41.457] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:27:41.457] - globals: [1] ‘ii’
[08:27:41.457] 
[08:27:41.457] getGlobalsAndPackages() ... DONE
[08:27:41.458] run() for ‘Future’ ...
[08:27:41.458] - state: ‘created’
[08:27:41.459] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:41.462] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:41.462] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:41.462]   - Field: ‘label’
[08:27:41.462]   - Field: ‘local’
[08:27:41.463]   - Field: ‘owner’
[08:27:41.463]   - Field: ‘envir’
[08:27:41.463]   - Field: ‘workers’
[08:27:41.463]   - Field: ‘packages’
[08:27:41.463]   - Field: ‘gc’
[08:27:41.463]   - Field: ‘job’
[08:27:41.464]   - Field: ‘conditions’
[08:27:41.464]   - Field: ‘expr’
[08:27:41.464]   - Field: ‘uuid’
[08:27:41.464]   - Field: ‘seed’
[08:27:41.464]   - Field: ‘version’
[08:27:41.465]   - Field: ‘result’
[08:27:41.465]   - Field: ‘asynchronous’
[08:27:41.465]   - Field: ‘calls’
[08:27:41.465]   - Field: ‘globals’
[08:27:41.465]   - Field: ‘stdout’
[08:27:41.466]   - Field: ‘earlySignal’
[08:27:41.466]   - Field: ‘lazy’
[08:27:41.466]   - Field: ‘state’
[08:27:41.466] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:41.466] - Launch lazy future ...
[08:27:41.467] Packages needed by the future expression (n = 0): <none>
[08:27:41.467] Packages needed by future strategies (n = 0): <none>
[08:27:41.468] {
[08:27:41.468]     {
[08:27:41.468]         {
[08:27:41.468]             ...future.startTime <- base::Sys.time()
[08:27:41.468]             {
[08:27:41.468]                 {
[08:27:41.468]                   {
[08:27:41.468]                     {
[08:27:41.468]                       base::local({
[08:27:41.468]                         has_future <- base::requireNamespace("future", 
[08:27:41.468]                           quietly = TRUE)
[08:27:41.468]                         if (has_future) {
[08:27:41.468]                           ns <- base::getNamespace("future")
[08:27:41.468]                           version <- ns[[".package"]][["version"]]
[08:27:41.468]                           if (is.null(version)) 
[08:27:41.468]                             version <- utils::packageVersion("future")
[08:27:41.468]                         }
[08:27:41.468]                         else {
[08:27:41.468]                           version <- NULL
[08:27:41.468]                         }
[08:27:41.468]                         if (!has_future || version < "1.8.0") {
[08:27:41.468]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.468]                             "", base::R.version$version.string), 
[08:27:41.468]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:41.468]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.468]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.468]                               "release", "version")], collapse = " "), 
[08:27:41.468]                             hostname = base::Sys.info()[["nodename"]])
[08:27:41.468]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.468]                             info)
[08:27:41.468]                           info <- base::paste(info, collapse = "; ")
[08:27:41.468]                           if (!has_future) {
[08:27:41.468]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.468]                               info)
[08:27:41.468]                           }
[08:27:41.468]                           else {
[08:27:41.468]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.468]                               info, version)
[08:27:41.468]                           }
[08:27:41.468]                           base::stop(msg)
[08:27:41.468]                         }
[08:27:41.468]                       })
[08:27:41.468]                     }
[08:27:41.468]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:41.468]                     base::options(mc.cores = 1L)
[08:27:41.468]                   }
[08:27:41.468]                   ...future.strategy.old <- future::plan("list")
[08:27:41.468]                   options(future.plan = NULL)
[08:27:41.468]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.468]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.468]                 }
[08:27:41.468]                 ...future.workdir <- getwd()
[08:27:41.468]             }
[08:27:41.468]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.468]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.468]         }
[08:27:41.468]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.468]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.468]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.468]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.468]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.468]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.468]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.468]             base::names(...future.oldOptions))
[08:27:41.468]     }
[08:27:41.468]     if (FALSE) {
[08:27:41.468]     }
[08:27:41.468]     else {
[08:27:41.468]         if (TRUE) {
[08:27:41.468]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.468]                 open = "w")
[08:27:41.468]         }
[08:27:41.468]         else {
[08:27:41.468]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.468]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.468]         }
[08:27:41.468]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.468]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.468]             base::sink(type = "output", split = FALSE)
[08:27:41.468]             base::close(...future.stdout)
[08:27:41.468]         }, add = TRUE)
[08:27:41.468]     }
[08:27:41.468]     ...future.frame <- base::sys.nframe()
[08:27:41.468]     ...future.conditions <- base::list()
[08:27:41.468]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.468]     if (FALSE) {
[08:27:41.468]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.468]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.468]     }
[08:27:41.468]     ...future.result <- base::tryCatch({
[08:27:41.468]         base::withCallingHandlers({
[08:27:41.468]             ...future.value <- base::withVisible(base::local({
[08:27:41.468]                 withCallingHandlers({
[08:27:41.468]                   {
[08:27:41.468]                     if (ii%%2 == 0) 
[08:27:41.468]                       stop("Woops!")
[08:27:41.468]                     ii
[08:27:41.468]                   }
[08:27:41.468]                 }, immediateCondition = function(cond) {
[08:27:41.468]                   save_rds <- function (object, pathname, ...) 
[08:27:41.468]                   {
[08:27:41.468]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:41.468]                     if (file_test("-f", pathname_tmp)) {
[08:27:41.468]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.468]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:41.468]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.468]                         fi_tmp[["mtime"]])
[08:27:41.468]                     }
[08:27:41.468]                     tryCatch({
[08:27:41.468]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:41.468]                     }, error = function(ex) {
[08:27:41.468]                       msg <- conditionMessage(ex)
[08:27:41.468]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.468]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:41.468]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.468]                         fi_tmp[["mtime"]], msg)
[08:27:41.468]                       ex$message <- msg
[08:27:41.468]                       stop(ex)
[08:27:41.468]                     })
[08:27:41.468]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:41.468]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:41.468]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:41.468]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.468]                       fi <- file.info(pathname)
[08:27:41.468]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:41.468]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.468]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:41.468]                         fi[["size"]], fi[["mtime"]])
[08:27:41.468]                       stop(msg)
[08:27:41.468]                     }
[08:27:41.468]                     invisible(pathname)
[08:27:41.468]                   }
[08:27:41.468]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:41.468]                     rootPath = tempdir()) 
[08:27:41.468]                   {
[08:27:41.468]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:41.468]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:41.468]                       tmpdir = path, fileext = ".rds")
[08:27:41.468]                     save_rds(obj, file)
[08:27:41.468]                   }
[08:27:41.468]                   saveImmediateCondition(cond, path = "/tmp/RtmpOWg6bo/.future/immediateConditions")
[08:27:41.468]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.468]                   {
[08:27:41.468]                     inherits <- base::inherits
[08:27:41.468]                     invokeRestart <- base::invokeRestart
[08:27:41.468]                     is.null <- base::is.null
[08:27:41.468]                     muffled <- FALSE
[08:27:41.468]                     if (inherits(cond, "message")) {
[08:27:41.468]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:41.468]                       if (muffled) 
[08:27:41.468]                         invokeRestart("muffleMessage")
[08:27:41.468]                     }
[08:27:41.468]                     else if (inherits(cond, "warning")) {
[08:27:41.468]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:41.468]                       if (muffled) 
[08:27:41.468]                         invokeRestart("muffleWarning")
[08:27:41.468]                     }
[08:27:41.468]                     else if (inherits(cond, "condition")) {
[08:27:41.468]                       if (!is.null(pattern)) {
[08:27:41.468]                         computeRestarts <- base::computeRestarts
[08:27:41.468]                         grepl <- base::grepl
[08:27:41.468]                         restarts <- computeRestarts(cond)
[08:27:41.468]                         for (restart in restarts) {
[08:27:41.468]                           name <- restart$name
[08:27:41.468]                           if (is.null(name)) 
[08:27:41.468]                             next
[08:27:41.468]                           if (!grepl(pattern, name)) 
[08:27:41.468]                             next
[08:27:41.468]                           invokeRestart(restart)
[08:27:41.468]                           muffled <- TRUE
[08:27:41.468]                           break
[08:27:41.468]                         }
[08:27:41.468]                       }
[08:27:41.468]                     }
[08:27:41.468]                     invisible(muffled)
[08:27:41.468]                   }
[08:27:41.468]                   muffleCondition(cond)
[08:27:41.468]                 })
[08:27:41.468]             }))
[08:27:41.468]             future::FutureResult(value = ...future.value$value, 
[08:27:41.468]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.468]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.468]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.468]                     ...future.globalenv.names))
[08:27:41.468]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.468]         }, condition = base::local({
[08:27:41.468]             c <- base::c
[08:27:41.468]             inherits <- base::inherits
[08:27:41.468]             invokeRestart <- base::invokeRestart
[08:27:41.468]             length <- base::length
[08:27:41.468]             list <- base::list
[08:27:41.468]             seq.int <- base::seq.int
[08:27:41.468]             signalCondition <- base::signalCondition
[08:27:41.468]             sys.calls <- base::sys.calls
[08:27:41.468]             `[[` <- base::`[[`
[08:27:41.468]             `+` <- base::`+`
[08:27:41.468]             `<<-` <- base::`<<-`
[08:27:41.468]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.468]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.468]                   3L)]
[08:27:41.468]             }
[08:27:41.468]             function(cond) {
[08:27:41.468]                 is_error <- inherits(cond, "error")
[08:27:41.468]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.468]                   NULL)
[08:27:41.468]                 if (is_error) {
[08:27:41.468]                   sessionInformation <- function() {
[08:27:41.468]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.468]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.468]                       search = base::search(), system = base::Sys.info())
[08:27:41.468]                   }
[08:27:41.468]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.468]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.468]                     cond$call), session = sessionInformation(), 
[08:27:41.468]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.468]                   signalCondition(cond)
[08:27:41.468]                 }
[08:27:41.468]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.468]                 "immediateCondition"))) {
[08:27:41.468]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.468]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.468]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.468]                   if (TRUE && !signal) {
[08:27:41.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.468]                     {
[08:27:41.468]                       inherits <- base::inherits
[08:27:41.468]                       invokeRestart <- base::invokeRestart
[08:27:41.468]                       is.null <- base::is.null
[08:27:41.468]                       muffled <- FALSE
[08:27:41.468]                       if (inherits(cond, "message")) {
[08:27:41.468]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.468]                         if (muffled) 
[08:27:41.468]                           invokeRestart("muffleMessage")
[08:27:41.468]                       }
[08:27:41.468]                       else if (inherits(cond, "warning")) {
[08:27:41.468]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.468]                         if (muffled) 
[08:27:41.468]                           invokeRestart("muffleWarning")
[08:27:41.468]                       }
[08:27:41.468]                       else if (inherits(cond, "condition")) {
[08:27:41.468]                         if (!is.null(pattern)) {
[08:27:41.468]                           computeRestarts <- base::computeRestarts
[08:27:41.468]                           grepl <- base::grepl
[08:27:41.468]                           restarts <- computeRestarts(cond)
[08:27:41.468]                           for (restart in restarts) {
[08:27:41.468]                             name <- restart$name
[08:27:41.468]                             if (is.null(name)) 
[08:27:41.468]                               next
[08:27:41.468]                             if (!grepl(pattern, name)) 
[08:27:41.468]                               next
[08:27:41.468]                             invokeRestart(restart)
[08:27:41.468]                             muffled <- TRUE
[08:27:41.468]                             break
[08:27:41.468]                           }
[08:27:41.468]                         }
[08:27:41.468]                       }
[08:27:41.468]                       invisible(muffled)
[08:27:41.468]                     }
[08:27:41.468]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.468]                   }
[08:27:41.468]                 }
[08:27:41.468]                 else {
[08:27:41.468]                   if (TRUE) {
[08:27:41.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.468]                     {
[08:27:41.468]                       inherits <- base::inherits
[08:27:41.468]                       invokeRestart <- base::invokeRestart
[08:27:41.468]                       is.null <- base::is.null
[08:27:41.468]                       muffled <- FALSE
[08:27:41.468]                       if (inherits(cond, "message")) {
[08:27:41.468]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.468]                         if (muffled) 
[08:27:41.468]                           invokeRestart("muffleMessage")
[08:27:41.468]                       }
[08:27:41.468]                       else if (inherits(cond, "warning")) {
[08:27:41.468]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.468]                         if (muffled) 
[08:27:41.468]                           invokeRestart("muffleWarning")
[08:27:41.468]                       }
[08:27:41.468]                       else if (inherits(cond, "condition")) {
[08:27:41.468]                         if (!is.null(pattern)) {
[08:27:41.468]                           computeRestarts <- base::computeRestarts
[08:27:41.468]                           grepl <- base::grepl
[08:27:41.468]                           restarts <- computeRestarts(cond)
[08:27:41.468]                           for (restart in restarts) {
[08:27:41.468]                             name <- restart$name
[08:27:41.468]                             if (is.null(name)) 
[08:27:41.468]                               next
[08:27:41.468]                             if (!grepl(pattern, name)) 
[08:27:41.468]                               next
[08:27:41.468]                             invokeRestart(restart)
[08:27:41.468]                             muffled <- TRUE
[08:27:41.468]                             break
[08:27:41.468]                           }
[08:27:41.468]                         }
[08:27:41.468]                       }
[08:27:41.468]                       invisible(muffled)
[08:27:41.468]                     }
[08:27:41.468]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.468]                   }
[08:27:41.468]                 }
[08:27:41.468]             }
[08:27:41.468]         }))
[08:27:41.468]     }, error = function(ex) {
[08:27:41.468]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.468]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.468]                 ...future.rng), started = ...future.startTime, 
[08:27:41.468]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.468]             version = "1.8"), class = "FutureResult")
[08:27:41.468]     }, finally = {
[08:27:41.468]         if (!identical(...future.workdir, getwd())) 
[08:27:41.468]             setwd(...future.workdir)
[08:27:41.468]         {
[08:27:41.468]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.468]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.468]             }
[08:27:41.468]             base::options(...future.oldOptions)
[08:27:41.468]             if (.Platform$OS.type == "windows") {
[08:27:41.468]                 old_names <- names(...future.oldEnvVars)
[08:27:41.468]                 envs <- base::Sys.getenv()
[08:27:41.468]                 names <- names(envs)
[08:27:41.468]                 common <- intersect(names, old_names)
[08:27:41.468]                 added <- setdiff(names, old_names)
[08:27:41.468]                 removed <- setdiff(old_names, names)
[08:27:41.468]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.468]                   envs[common]]
[08:27:41.468]                 NAMES <- toupper(changed)
[08:27:41.468]                 args <- list()
[08:27:41.468]                 for (kk in seq_along(NAMES)) {
[08:27:41.468]                   name <- changed[[kk]]
[08:27:41.468]                   NAME <- NAMES[[kk]]
[08:27:41.468]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.468]                     next
[08:27:41.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.468]                 }
[08:27:41.468]                 NAMES <- toupper(added)
[08:27:41.468]                 for (kk in seq_along(NAMES)) {
[08:27:41.468]                   name <- added[[kk]]
[08:27:41.468]                   NAME <- NAMES[[kk]]
[08:27:41.468]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.468]                     next
[08:27:41.468]                   args[[name]] <- ""
[08:27:41.468]                 }
[08:27:41.468]                 NAMES <- toupper(removed)
[08:27:41.468]                 for (kk in seq_along(NAMES)) {
[08:27:41.468]                   name <- removed[[kk]]
[08:27:41.468]                   NAME <- NAMES[[kk]]
[08:27:41.468]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.468]                     next
[08:27:41.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.468]                 }
[08:27:41.468]                 if (length(args) > 0) 
[08:27:41.468]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.468]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.468]             }
[08:27:41.468]             else {
[08:27:41.468]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.468]             }
[08:27:41.468]             {
[08:27:41.468]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.468]                   0L) {
[08:27:41.468]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.468]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.468]                   base::options(opts)
[08:27:41.468]                 }
[08:27:41.468]                 {
[08:27:41.468]                   {
[08:27:41.468]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:41.468]                     NULL
[08:27:41.468]                   }
[08:27:41.468]                   options(future.plan = NULL)
[08:27:41.468]                   if (is.na(NA_character_)) 
[08:27:41.468]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.468]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.468]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.468]                     .init = FALSE)
[08:27:41.468]                 }
[08:27:41.468]             }
[08:27:41.468]         }
[08:27:41.468]     })
[08:27:41.468]     if (TRUE) {
[08:27:41.468]         base::sink(type = "output", split = FALSE)
[08:27:41.468]         if (TRUE) {
[08:27:41.468]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.468]         }
[08:27:41.468]         else {
[08:27:41.468]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.468]         }
[08:27:41.468]         base::close(...future.stdout)
[08:27:41.468]         ...future.stdout <- NULL
[08:27:41.468]     }
[08:27:41.468]     ...future.result$conditions <- ...future.conditions
[08:27:41.468]     ...future.result$finished <- base::Sys.time()
[08:27:41.468]     ...future.result
[08:27:41.468] }
[08:27:41.472] assign_globals() ...
[08:27:41.472] List of 1
[08:27:41.472]  $ ii: int 2
[08:27:41.472]  - attr(*, "where")=List of 1
[08:27:41.472]   ..$ ii:<environment: R_EmptyEnv> 
[08:27:41.472]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:41.472]  - attr(*, "resolved")= logi FALSE
[08:27:41.472]  - attr(*, "total_size")= num 35
[08:27:41.472]  - attr(*, "already-done")= logi TRUE
[08:27:41.477] - copied ‘ii’ to environment
[08:27:41.477] assign_globals() ... done
[08:27:41.477] requestCore(): workers = 2
[08:27:41.480] MulticoreFuture started
[08:27:41.480] - Launch lazy future ... done
[08:27:41.480] run() for ‘MulticoreFuture’ ... done
[08:27:41.481] plan(): Setting new future strategy stack:
[08:27:41.481] List of future strategies:
[08:27:41.481] 1. sequential:
[08:27:41.481]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.481]    - tweaked: FALSE
[08:27:41.481]    - call: NULL
[08:27:41.482] getGlobalsAndPackages() ...
[08:27:41.482] plan(): nbrOfWorkers() = 1
[08:27:41.482] Searching for globals...
[08:27:41.484] plan(): Setting new future strategy stack:
[08:27:41.484] List of future strategies:
[08:27:41.484] 1. multicore:
[08:27:41.484]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:41.484]    - tweaked: FALSE
[08:27:41.484]    - call: plan(strategy)
[08:27:41.486] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[08:27:41.486] Searching for globals ... DONE
[08:27:41.486] Resolving globals: FALSE
[08:27:41.487] plan(): nbrOfWorkers() = 2
[08:27:41.487] The total size of the 1 globals is 35 bytes (35 bytes)
[08:27:41.488] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:27:41.488] - globals: [1] ‘ii’
[08:27:41.488] 
[08:27:41.489] getGlobalsAndPackages() ... DONE
[08:27:41.489] run() for ‘Future’ ...
[08:27:41.489] - state: ‘created’
[08:27:41.490] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:41.493] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:41.493] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:41.493]   - Field: ‘label’
[08:27:41.493]   - Field: ‘local’
[08:27:41.493]   - Field: ‘owner’
[08:27:41.494]   - Field: ‘envir’
[08:27:41.494]   - Field: ‘workers’
[08:27:41.494]   - Field: ‘packages’
[08:27:41.494]   - Field: ‘gc’
[08:27:41.494]   - Field: ‘job’
[08:27:41.494]   - Field: ‘conditions’
[08:27:41.495]   - Field: ‘expr’
[08:27:41.495]   - Field: ‘uuid’
[08:27:41.495]   - Field: ‘seed’
[08:27:41.495]   - Field: ‘version’
[08:27:41.495]   - Field: ‘result’
[08:27:41.495]   - Field: ‘asynchronous’
[08:27:41.496]   - Field: ‘calls’
[08:27:41.496]   - Field: ‘globals’
[08:27:41.496]   - Field: ‘stdout’
[08:27:41.496]   - Field: ‘earlySignal’
[08:27:41.496]   - Field: ‘lazy’
[08:27:41.496]   - Field: ‘state’
[08:27:41.497] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:41.497] - Launch lazy future ...
[08:27:41.498] Packages needed by the future expression (n = 0): <none>
[08:27:41.498] Packages needed by future strategies (n = 0): <none>
[08:27:41.502] {
[08:27:41.502]     {
[08:27:41.502]         {
[08:27:41.502]             ...future.startTime <- base::Sys.time()
[08:27:41.502]             {
[08:27:41.502]                 {
[08:27:41.502]                   {
[08:27:41.502]                     {
[08:27:41.502]                       base::local({
[08:27:41.502]                         has_future <- base::requireNamespace("future", 
[08:27:41.502]                           quietly = TRUE)
[08:27:41.502]                         if (has_future) {
[08:27:41.502]                           ns <- base::getNamespace("future")
[08:27:41.502]                           version <- ns[[".package"]][["version"]]
[08:27:41.502]                           if (is.null(version)) 
[08:27:41.502]                             version <- utils::packageVersion("future")
[08:27:41.502]                         }
[08:27:41.502]                         else {
[08:27:41.502]                           version <- NULL
[08:27:41.502]                         }
[08:27:41.502]                         if (!has_future || version < "1.8.0") {
[08:27:41.502]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.502]                             "", base::R.version$version.string), 
[08:27:41.502]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:41.502]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.502]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.502]                               "release", "version")], collapse = " "), 
[08:27:41.502]                             hostname = base::Sys.info()[["nodename"]])
[08:27:41.502]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.502]                             info)
[08:27:41.502]                           info <- base::paste(info, collapse = "; ")
[08:27:41.502]                           if (!has_future) {
[08:27:41.502]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.502]                               info)
[08:27:41.502]                           }
[08:27:41.502]                           else {
[08:27:41.502]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.502]                               info, version)
[08:27:41.502]                           }
[08:27:41.502]                           base::stop(msg)
[08:27:41.502]                         }
[08:27:41.502]                       })
[08:27:41.502]                     }
[08:27:41.502]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:41.502]                     base::options(mc.cores = 1L)
[08:27:41.502]                   }
[08:27:41.502]                   ...future.strategy.old <- future::plan("list")
[08:27:41.502]                   options(future.plan = NULL)
[08:27:41.502]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.502]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.502]                 }
[08:27:41.502]                 ...future.workdir <- getwd()
[08:27:41.502]             }
[08:27:41.502]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.502]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.502]         }
[08:27:41.502]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.502]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.502]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.502]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.502]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.502]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.502]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.502]             base::names(...future.oldOptions))
[08:27:41.502]     }
[08:27:41.502]     if (FALSE) {
[08:27:41.502]     }
[08:27:41.502]     else {
[08:27:41.502]         if (TRUE) {
[08:27:41.502]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.502]                 open = "w")
[08:27:41.502]         }
[08:27:41.502]         else {
[08:27:41.502]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.502]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.502]         }
[08:27:41.502]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.502]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.502]             base::sink(type = "output", split = FALSE)
[08:27:41.502]             base::close(...future.stdout)
[08:27:41.502]         }, add = TRUE)
[08:27:41.502]     }
[08:27:41.502]     ...future.frame <- base::sys.nframe()
[08:27:41.502]     ...future.conditions <- base::list()
[08:27:41.502]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.502]     if (FALSE) {
[08:27:41.502]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.502]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.502]     }
[08:27:41.502]     ...future.result <- base::tryCatch({
[08:27:41.502]         base::withCallingHandlers({
[08:27:41.502]             ...future.value <- base::withVisible(base::local({
[08:27:41.502]                 withCallingHandlers({
[08:27:41.502]                   {
[08:27:41.502]                     if (ii%%2 == 0) 
[08:27:41.502]                       stop("Woops!")
[08:27:41.502]                     ii
[08:27:41.502]                   }
[08:27:41.502]                 }, immediateCondition = function(cond) {
[08:27:41.502]                   save_rds <- function (object, pathname, ...) 
[08:27:41.502]                   {
[08:27:41.502]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:41.502]                     if (file_test("-f", pathname_tmp)) {
[08:27:41.502]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.502]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:41.502]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.502]                         fi_tmp[["mtime"]])
[08:27:41.502]                     }
[08:27:41.502]                     tryCatch({
[08:27:41.502]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:41.502]                     }, error = function(ex) {
[08:27:41.502]                       msg <- conditionMessage(ex)
[08:27:41.502]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.502]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:41.502]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.502]                         fi_tmp[["mtime"]], msg)
[08:27:41.502]                       ex$message <- msg
[08:27:41.502]                       stop(ex)
[08:27:41.502]                     })
[08:27:41.502]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:41.502]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:41.502]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:41.502]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.502]                       fi <- file.info(pathname)
[08:27:41.502]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:41.502]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.502]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:41.502]                         fi[["size"]], fi[["mtime"]])
[08:27:41.502]                       stop(msg)
[08:27:41.502]                     }
[08:27:41.502]                     invisible(pathname)
[08:27:41.502]                   }
[08:27:41.502]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:41.502]                     rootPath = tempdir()) 
[08:27:41.502]                   {
[08:27:41.502]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:41.502]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:41.502]                       tmpdir = path, fileext = ".rds")
[08:27:41.502]                     save_rds(obj, file)
[08:27:41.502]                   }
[08:27:41.502]                   saveImmediateCondition(cond, path = "/tmp/RtmpOWg6bo/.future/immediateConditions")
[08:27:41.502]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.502]                   {
[08:27:41.502]                     inherits <- base::inherits
[08:27:41.502]                     invokeRestart <- base::invokeRestart
[08:27:41.502]                     is.null <- base::is.null
[08:27:41.502]                     muffled <- FALSE
[08:27:41.502]                     if (inherits(cond, "message")) {
[08:27:41.502]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:41.502]                       if (muffled) 
[08:27:41.502]                         invokeRestart("muffleMessage")
[08:27:41.502]                     }
[08:27:41.502]                     else if (inherits(cond, "warning")) {
[08:27:41.502]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:41.502]                       if (muffled) 
[08:27:41.502]                         invokeRestart("muffleWarning")
[08:27:41.502]                     }
[08:27:41.502]                     else if (inherits(cond, "condition")) {
[08:27:41.502]                       if (!is.null(pattern)) {
[08:27:41.502]                         computeRestarts <- base::computeRestarts
[08:27:41.502]                         grepl <- base::grepl
[08:27:41.502]                         restarts <- computeRestarts(cond)
[08:27:41.502]                         for (restart in restarts) {
[08:27:41.502]                           name <- restart$name
[08:27:41.502]                           if (is.null(name)) 
[08:27:41.502]                             next
[08:27:41.502]                           if (!grepl(pattern, name)) 
[08:27:41.502]                             next
[08:27:41.502]                           invokeRestart(restart)
[08:27:41.502]                           muffled <- TRUE
[08:27:41.502]                           break
[08:27:41.502]                         }
[08:27:41.502]                       }
[08:27:41.502]                     }
[08:27:41.502]                     invisible(muffled)
[08:27:41.502]                   }
[08:27:41.502]                   muffleCondition(cond)
[08:27:41.502]                 })
[08:27:41.502]             }))
[08:27:41.502]             future::FutureResult(value = ...future.value$value, 
[08:27:41.502]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.502]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.502]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.502]                     ...future.globalenv.names))
[08:27:41.502]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.502]         }, condition = base::local({
[08:27:41.502]             c <- base::c
[08:27:41.502]             inherits <- base::inherits
[08:27:41.502]             invokeRestart <- base::invokeRestart
[08:27:41.502]             length <- base::length
[08:27:41.502]             list <- base::list
[08:27:41.502]             seq.int <- base::seq.int
[08:27:41.502]             signalCondition <- base::signalCondition
[08:27:41.502]             sys.calls <- base::sys.calls
[08:27:41.502]             `[[` <- base::`[[`
[08:27:41.502]             `+` <- base::`+`
[08:27:41.502]             `<<-` <- base::`<<-`
[08:27:41.502]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.502]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.502]                   3L)]
[08:27:41.502]             }
[08:27:41.502]             function(cond) {
[08:27:41.502]                 is_error <- inherits(cond, "error")
[08:27:41.502]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.502]                   NULL)
[08:27:41.502]                 if (is_error) {
[08:27:41.502]                   sessionInformation <- function() {
[08:27:41.502]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.502]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.502]                       search = base::search(), system = base::Sys.info())
[08:27:41.502]                   }
[08:27:41.502]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.502]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.502]                     cond$call), session = sessionInformation(), 
[08:27:41.502]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.502]                   signalCondition(cond)
[08:27:41.502]                 }
[08:27:41.502]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.502]                 "immediateCondition"))) {
[08:27:41.502]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.502]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.502]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.502]                   if (TRUE && !signal) {
[08:27:41.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.502]                     {
[08:27:41.502]                       inherits <- base::inherits
[08:27:41.502]                       invokeRestart <- base::invokeRestart
[08:27:41.502]                       is.null <- base::is.null
[08:27:41.502]                       muffled <- FALSE
[08:27:41.502]                       if (inherits(cond, "message")) {
[08:27:41.502]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.502]                         if (muffled) 
[08:27:41.502]                           invokeRestart("muffleMessage")
[08:27:41.502]                       }
[08:27:41.502]                       else if (inherits(cond, "warning")) {
[08:27:41.502]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.502]                         if (muffled) 
[08:27:41.502]                           invokeRestart("muffleWarning")
[08:27:41.502]                       }
[08:27:41.502]                       else if (inherits(cond, "condition")) {
[08:27:41.502]                         if (!is.null(pattern)) {
[08:27:41.502]                           computeRestarts <- base::computeRestarts
[08:27:41.502]                           grepl <- base::grepl
[08:27:41.502]                           restarts <- computeRestarts(cond)
[08:27:41.502]                           for (restart in restarts) {
[08:27:41.502]                             name <- restart$name
[08:27:41.502]                             if (is.null(name)) 
[08:27:41.502]                               next
[08:27:41.502]                             if (!grepl(pattern, name)) 
[08:27:41.502]                               next
[08:27:41.502]                             invokeRestart(restart)
[08:27:41.502]                             muffled <- TRUE
[08:27:41.502]                             break
[08:27:41.502]                           }
[08:27:41.502]                         }
[08:27:41.502]                       }
[08:27:41.502]                       invisible(muffled)
[08:27:41.502]                     }
[08:27:41.502]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.502]                   }
[08:27:41.502]                 }
[08:27:41.502]                 else {
[08:27:41.502]                   if (TRUE) {
[08:27:41.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.502]                     {
[08:27:41.502]                       inherits <- base::inherits
[08:27:41.502]                       invokeRestart <- base::invokeRestart
[08:27:41.502]                       is.null <- base::is.null
[08:27:41.502]                       muffled <- FALSE
[08:27:41.502]                       if (inherits(cond, "message")) {
[08:27:41.502]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.502]                         if (muffled) 
[08:27:41.502]                           invokeRestart("muffleMessage")
[08:27:41.502]                       }
[08:27:41.502]                       else if (inherits(cond, "warning")) {
[08:27:41.502]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.502]                         if (muffled) 
[08:27:41.502]                           invokeRestart("muffleWarning")
[08:27:41.502]                       }
[08:27:41.502]                       else if (inherits(cond, "condition")) {
[08:27:41.502]                         if (!is.null(pattern)) {
[08:27:41.502]                           computeRestarts <- base::computeRestarts
[08:27:41.502]                           grepl <- base::grepl
[08:27:41.502]                           restarts <- computeRestarts(cond)
[08:27:41.502]                           for (restart in restarts) {
[08:27:41.502]                             name <- restart$name
[08:27:41.502]                             if (is.null(name)) 
[08:27:41.502]                               next
[08:27:41.502]                             if (!grepl(pattern, name)) 
[08:27:41.502]                               next
[08:27:41.502]                             invokeRestart(restart)
[08:27:41.502]                             muffled <- TRUE
[08:27:41.502]                             break
[08:27:41.502]                           }
[08:27:41.502]                         }
[08:27:41.502]                       }
[08:27:41.502]                       invisible(muffled)
[08:27:41.502]                     }
[08:27:41.502]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.502]                   }
[08:27:41.502]                 }
[08:27:41.502]             }
[08:27:41.502]         }))
[08:27:41.502]     }, error = function(ex) {
[08:27:41.502]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.502]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.502]                 ...future.rng), started = ...future.startTime, 
[08:27:41.502]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.502]             version = "1.8"), class = "FutureResult")
[08:27:41.502]     }, finally = {
[08:27:41.502]         if (!identical(...future.workdir, getwd())) 
[08:27:41.502]             setwd(...future.workdir)
[08:27:41.502]         {
[08:27:41.502]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.502]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.502]             }
[08:27:41.502]             base::options(...future.oldOptions)
[08:27:41.502]             if (.Platform$OS.type == "windows") {
[08:27:41.502]                 old_names <- names(...future.oldEnvVars)
[08:27:41.502]                 envs <- base::Sys.getenv()
[08:27:41.502]                 names <- names(envs)
[08:27:41.502]                 common <- intersect(names, old_names)
[08:27:41.502]                 added <- setdiff(names, old_names)
[08:27:41.502]                 removed <- setdiff(old_names, names)
[08:27:41.502]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.502]                   envs[common]]
[08:27:41.502]                 NAMES <- toupper(changed)
[08:27:41.502]                 args <- list()
[08:27:41.502]                 for (kk in seq_along(NAMES)) {
[08:27:41.502]                   name <- changed[[kk]]
[08:27:41.502]                   NAME <- NAMES[[kk]]
[08:27:41.502]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.502]                     next
[08:27:41.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.502]                 }
[08:27:41.502]                 NAMES <- toupper(added)
[08:27:41.502]                 for (kk in seq_along(NAMES)) {
[08:27:41.502]                   name <- added[[kk]]
[08:27:41.502]                   NAME <- NAMES[[kk]]
[08:27:41.502]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.502]                     next
[08:27:41.502]                   args[[name]] <- ""
[08:27:41.502]                 }
[08:27:41.502]                 NAMES <- toupper(removed)
[08:27:41.502]                 for (kk in seq_along(NAMES)) {
[08:27:41.502]                   name <- removed[[kk]]
[08:27:41.502]                   NAME <- NAMES[[kk]]
[08:27:41.502]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.502]                     next
[08:27:41.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.502]                 }
[08:27:41.502]                 if (length(args) > 0) 
[08:27:41.502]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.502]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.502]             }
[08:27:41.502]             else {
[08:27:41.502]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.502]             }
[08:27:41.502]             {
[08:27:41.502]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.502]                   0L) {
[08:27:41.502]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.502]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.502]                   base::options(opts)
[08:27:41.502]                 }
[08:27:41.502]                 {
[08:27:41.502]                   {
[08:27:41.502]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:41.502]                     NULL
[08:27:41.502]                   }
[08:27:41.502]                   options(future.plan = NULL)
[08:27:41.502]                   if (is.na(NA_character_)) 
[08:27:41.502]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.502]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.502]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.502]                     .init = FALSE)
[08:27:41.502]                 }
[08:27:41.502]             }
[08:27:41.502]         }
[08:27:41.502]     })
[08:27:41.502]     if (TRUE) {
[08:27:41.502]         base::sink(type = "output", split = FALSE)
[08:27:41.502]         if (TRUE) {
[08:27:41.502]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.502]         }
[08:27:41.502]         else {
[08:27:41.502]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.502]         }
[08:27:41.502]         base::close(...future.stdout)
[08:27:41.502]         ...future.stdout <- NULL
[08:27:41.502]     }
[08:27:41.502]     ...future.result$conditions <- ...future.conditions
[08:27:41.502]     ...future.result$finished <- base::Sys.time()
[08:27:41.502]     ...future.result
[08:27:41.502] }
[08:27:41.505] assign_globals() ...
[08:27:41.505] List of 1
[08:27:41.505]  $ ii: int 3
[08:27:41.505]  - attr(*, "where")=List of 1
[08:27:41.505]   ..$ ii:<environment: R_EmptyEnv> 
[08:27:41.505]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:41.505]  - attr(*, "resolved")= logi FALSE
[08:27:41.505]  - attr(*, "total_size")= num 35
[08:27:41.505]  - attr(*, "already-done")= logi TRUE
[08:27:41.509] - copied ‘ii’ to environment
[08:27:41.509] assign_globals() ... done
[08:27:41.510] requestCore(): workers = 2
[08:27:41.510] Poll #1 (0): usedCores() = 2, workers = 2
[08:27:41.522] result() for MulticoreFuture ...
[08:27:41.522] result() for MulticoreFuture ...
[08:27:41.523] result() for MulticoreFuture ... done
[08:27:41.523] result() for MulticoreFuture ... done
[08:27:41.523] result() for MulticoreFuture ...
[08:27:41.523] result() for MulticoreFuture ... done
[08:27:41.526] MulticoreFuture started
[08:27:41.526] - Launch lazy future ... done
[08:27:41.527] run() for ‘MulticoreFuture’ ... done
[08:27:41.527] plan(): Setting new future strategy stack:
[08:27:41.527] result() for MulticoreFuture ...
[08:27:41.528] result() for MulticoreFuture ... done
[08:27:41.528] result() for MulticoreFuture ...
[08:27:41.528] result() for MulticoreFuture ... done
[08:27:41.529] result() for MulticoreFuture ...
[08:27:41.527] List of future strategies:
[08:27:41.527] 1. sequential:
[08:27:41.527]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.527]    - tweaked: FALSE
[08:27:41.527]    - call: NULL
[08:27:41.529] plan(): nbrOfWorkers() = 1
[08:27:41.532] plan(): Setting new future strategy stack:
[08:27:41.532] List of future strategies:
[08:27:41.532] 1. multicore:
[08:27:41.532]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:41.532]    - tweaked: FALSE
[08:27:41.532]    - call: plan(strategy)
[08:27:41.534] result() for MulticoreFuture ...
[08:27:41.534] result() for MulticoreFuture ... done
[08:27:41.534] signalConditions() ...
[08:27:41.535]  - include = ‘immediateCondition’
[08:27:41.535]  - exclude = 
[08:27:41.535]  - resignal = FALSE
[08:27:41.535]  - Number of conditions: 1
[08:27:41.536] signalConditions() ... done
[08:27:41.536] result() for MulticoreFuture ... done
[08:27:41.536] result() for MulticoreFuture ...
[08:27:41.536] result() for MulticoreFuture ... done
[08:27:41.536] signalConditions() ...
[08:27:41.537] plan(): nbrOfWorkers() = 2
[08:27:41.537]  - include = ‘immediateCondition’
[08:27:41.537]  - exclude = 
[08:27:41.537]  - resignal = FALSE
[08:27:41.537]  - Number of conditions: 1
[08:27:41.537] signalConditions() ... done
[08:27:41.538] Future state: ‘finished’
[08:27:41.538] result() for MulticoreFuture ...
[08:27:41.538] result() for MulticoreFuture ... done
[08:27:41.538] signalConditions() ...
[08:27:41.538]  - include = ‘condition’
[08:27:41.538]  - exclude = ‘immediateCondition’
[08:27:41.538]  - resignal = TRUE
[08:27:41.539]  - Number of conditions: 1
[08:27:41.539]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:27:41.539] signalConditions() ... done
[08:27:41.539] result() for MulticoreFuture ...
[08:27:41.540] result() for MulticoreFuture ...
[08:27:41.541] result() for MulticoreFuture ... done
[08:27:41.541] result() for MulticoreFuture ... done
[08:27:41.541] result() for MulticoreFuture ...
[08:27:41.541] result() for MulticoreFuture ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[08:27:41.542] result() for MulticoreFuture ...
[08:27:41.542] result() for MulticoreFuture ... done
[08:27:41.542] result() for MulticoreFuture ...
[08:27:41.542] result() for MulticoreFuture ... done
[08:27:41.542] signalConditions() ...
[08:27:41.543]  - include = ‘immediateCondition’
[08:27:41.543]  - exclude = 
[08:27:41.543]  - resignal = FALSE
[08:27:41.543]  - Number of conditions: 1
[08:27:41.543] signalConditions() ... done
[08:27:41.543] Future state: ‘finished’
[08:27:41.544] result() for MulticoreFuture ...
[08:27:41.544] result() for MulticoreFuture ... done
[08:27:41.544] signalConditions() ...
[08:27:41.544]  - include = ‘condition’
[08:27:41.544]  - exclude = ‘immediateCondition’
[08:27:41.544]  - resignal = TRUE
[08:27:41.544]  - Number of conditions: 1
[08:27:41.544]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:27:41.544] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[08:27:41.545] result() for MulticoreFuture ...
[08:27:41.545] result() for MulticoreFuture ... done
[08:27:41.545] result() for MulticoreFuture ...
[08:27:41.545] result() for MulticoreFuture ... done
[08:27:41.545] signalConditions() ...
[08:27:41.545]  - include = ‘immediateCondition’
[08:27:41.546]  - exclude = 
[08:27:41.546]  - resignal = FALSE
[08:27:41.546]  - Number of conditions: 1
[08:27:41.546] signalConditions() ... done
[08:27:41.546] Future state: ‘finished’
[08:27:41.546] result() for MulticoreFuture ...
[08:27:41.546] result() for MulticoreFuture ... done
[08:27:41.546] signalConditions() ...
[08:27:41.546]  - include = ‘condition’
[08:27:41.546]  - exclude = ‘immediateCondition’
[08:27:41.547]  - resignal = TRUE
[08:27:41.547]  - Number of conditions: 1
[08:27:41.547]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:27:41.547] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[08:27:41.547] getGlobalsAndPackages() ...
[08:27:41.547] Searching for globals...
[08:27:41.550] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[08:27:41.550] Searching for globals ... DONE
[08:27:41.550] Resolving globals: FALSE
[08:27:41.551] 
[08:27:41.551] 
[08:27:41.551] getGlobalsAndPackages() ... DONE
[08:27:41.551] run() for ‘Future’ ...
[08:27:41.551] - state: ‘created’
[08:27:41.552] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:41.554] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:41.556] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:41.556]   - Field: ‘label’
[08:27:41.557]   - Field: ‘local’
[08:27:41.557]   - Field: ‘owner’
[08:27:41.557]   - Field: ‘envir’
[08:27:41.557]   - Field: ‘workers’
[08:27:41.557]   - Field: ‘packages’
[08:27:41.557]   - Field: ‘gc’
[08:27:41.557]   - Field: ‘job’
[08:27:41.558]   - Field: ‘conditions’
[08:27:41.558]   - Field: ‘expr’
[08:27:41.558]   - Field: ‘uuid’
[08:27:41.558]   - Field: ‘seed’
[08:27:41.558]   - Field: ‘version’
[08:27:41.558]   - Field: ‘result’
[08:27:41.558]   - Field: ‘asynchronous’
[08:27:41.558]   - Field: ‘calls’
[08:27:41.559]   - Field: ‘globals’
[08:27:41.559]   - Field: ‘stdout’
[08:27:41.559]   - Field: ‘earlySignal’
[08:27:41.559]   - Field: ‘lazy’
[08:27:41.559]   - Field: ‘state’
[08:27:41.559] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:41.559] - Launch lazy future ...
[08:27:41.560] Packages needed by the future expression (n = 0): <none>
[08:27:41.560] Packages needed by future strategies (n = 0): <none>
[08:27:41.560] {
[08:27:41.560]     {
[08:27:41.560]         {
[08:27:41.560]             ...future.startTime <- base::Sys.time()
[08:27:41.560]             {
[08:27:41.560]                 {
[08:27:41.560]                   {
[08:27:41.560]                     {
[08:27:41.560]                       base::local({
[08:27:41.560]                         has_future <- base::requireNamespace("future", 
[08:27:41.560]                           quietly = TRUE)
[08:27:41.560]                         if (has_future) {
[08:27:41.560]                           ns <- base::getNamespace("future")
[08:27:41.560]                           version <- ns[[".package"]][["version"]]
[08:27:41.560]                           if (is.null(version)) 
[08:27:41.560]                             version <- utils::packageVersion("future")
[08:27:41.560]                         }
[08:27:41.560]                         else {
[08:27:41.560]                           version <- NULL
[08:27:41.560]                         }
[08:27:41.560]                         if (!has_future || version < "1.8.0") {
[08:27:41.560]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.560]                             "", base::R.version$version.string), 
[08:27:41.560]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:41.560]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.560]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.560]                               "release", "version")], collapse = " "), 
[08:27:41.560]                             hostname = base::Sys.info()[["nodename"]])
[08:27:41.560]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.560]                             info)
[08:27:41.560]                           info <- base::paste(info, collapse = "; ")
[08:27:41.560]                           if (!has_future) {
[08:27:41.560]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.560]                               info)
[08:27:41.560]                           }
[08:27:41.560]                           else {
[08:27:41.560]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.560]                               info, version)
[08:27:41.560]                           }
[08:27:41.560]                           base::stop(msg)
[08:27:41.560]                         }
[08:27:41.560]                       })
[08:27:41.560]                     }
[08:27:41.560]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:41.560]                     base::options(mc.cores = 1L)
[08:27:41.560]                   }
[08:27:41.560]                   ...future.strategy.old <- future::plan("list")
[08:27:41.560]                   options(future.plan = NULL)
[08:27:41.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.560]                 }
[08:27:41.560]                 ...future.workdir <- getwd()
[08:27:41.560]             }
[08:27:41.560]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.560]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.560]         }
[08:27:41.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.560]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.560]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.560]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.560]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.560]             base::names(...future.oldOptions))
[08:27:41.560]     }
[08:27:41.560]     if (FALSE) {
[08:27:41.560]     }
[08:27:41.560]     else {
[08:27:41.560]         if (TRUE) {
[08:27:41.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.560]                 open = "w")
[08:27:41.560]         }
[08:27:41.560]         else {
[08:27:41.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.560]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.560]         }
[08:27:41.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.560]             base::sink(type = "output", split = FALSE)
[08:27:41.560]             base::close(...future.stdout)
[08:27:41.560]         }, add = TRUE)
[08:27:41.560]     }
[08:27:41.560]     ...future.frame <- base::sys.nframe()
[08:27:41.560]     ...future.conditions <- base::list()
[08:27:41.560]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.560]     if (FALSE) {
[08:27:41.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.560]     }
[08:27:41.560]     ...future.result <- base::tryCatch({
[08:27:41.560]         base::withCallingHandlers({
[08:27:41.560]             ...future.value <- base::withVisible(base::local({
[08:27:41.560]                 withCallingHandlers({
[08:27:41.560]                   {
[08:27:41.560]                     cat("Processing: ")
[08:27:41.560]                     for (ii in 1:10) {
[08:27:41.560]                       cat(".")
[08:27:41.560]                     }
[08:27:41.560]                     cat(" [100%]\n")
[08:27:41.560]                     4
[08:27:41.560]                   }
[08:27:41.560]                 }, immediateCondition = function(cond) {
[08:27:41.560]                   save_rds <- function (object, pathname, ...) 
[08:27:41.560]                   {
[08:27:41.560]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:41.560]                     if (file_test("-f", pathname_tmp)) {
[08:27:41.560]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.560]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:41.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.560]                         fi_tmp[["mtime"]])
[08:27:41.560]                     }
[08:27:41.560]                     tryCatch({
[08:27:41.560]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:41.560]                     }, error = function(ex) {
[08:27:41.560]                       msg <- conditionMessage(ex)
[08:27:41.560]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.560]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:41.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.560]                         fi_tmp[["mtime"]], msg)
[08:27:41.560]                       ex$message <- msg
[08:27:41.560]                       stop(ex)
[08:27:41.560]                     })
[08:27:41.560]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:41.560]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:41.560]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:41.560]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.560]                       fi <- file.info(pathname)
[08:27:41.560]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:41.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.560]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:41.560]                         fi[["size"]], fi[["mtime"]])
[08:27:41.560]                       stop(msg)
[08:27:41.560]                     }
[08:27:41.560]                     invisible(pathname)
[08:27:41.560]                   }
[08:27:41.560]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:41.560]                     rootPath = tempdir()) 
[08:27:41.560]                   {
[08:27:41.560]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:41.560]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:41.560]                       tmpdir = path, fileext = ".rds")
[08:27:41.560]                     save_rds(obj, file)
[08:27:41.560]                   }
[08:27:41.560]                   saveImmediateCondition(cond, path = "/tmp/RtmpOWg6bo/.future/immediateConditions")
[08:27:41.560]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.560]                   {
[08:27:41.560]                     inherits <- base::inherits
[08:27:41.560]                     invokeRestart <- base::invokeRestart
[08:27:41.560]                     is.null <- base::is.null
[08:27:41.560]                     muffled <- FALSE
[08:27:41.560]                     if (inherits(cond, "message")) {
[08:27:41.560]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:41.560]                       if (muffled) 
[08:27:41.560]                         invokeRestart("muffleMessage")
[08:27:41.560]                     }
[08:27:41.560]                     else if (inherits(cond, "warning")) {
[08:27:41.560]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:41.560]                       if (muffled) 
[08:27:41.560]                         invokeRestart("muffleWarning")
[08:27:41.560]                     }
[08:27:41.560]                     else if (inherits(cond, "condition")) {
[08:27:41.560]                       if (!is.null(pattern)) {
[08:27:41.560]                         computeRestarts <- base::computeRestarts
[08:27:41.560]                         grepl <- base::grepl
[08:27:41.560]                         restarts <- computeRestarts(cond)
[08:27:41.560]                         for (restart in restarts) {
[08:27:41.560]                           name <- restart$name
[08:27:41.560]                           if (is.null(name)) 
[08:27:41.560]                             next
[08:27:41.560]                           if (!grepl(pattern, name)) 
[08:27:41.560]                             next
[08:27:41.560]                           invokeRestart(restart)
[08:27:41.560]                           muffled <- TRUE
[08:27:41.560]                           break
[08:27:41.560]                         }
[08:27:41.560]                       }
[08:27:41.560]                     }
[08:27:41.560]                     invisible(muffled)
[08:27:41.560]                   }
[08:27:41.560]                   muffleCondition(cond)
[08:27:41.560]                 })
[08:27:41.560]             }))
[08:27:41.560]             future::FutureResult(value = ...future.value$value, 
[08:27:41.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.560]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.560]                     ...future.globalenv.names))
[08:27:41.560]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.560]         }, condition = base::local({
[08:27:41.560]             c <- base::c
[08:27:41.560]             inherits <- base::inherits
[08:27:41.560]             invokeRestart <- base::invokeRestart
[08:27:41.560]             length <- base::length
[08:27:41.560]             list <- base::list
[08:27:41.560]             seq.int <- base::seq.int
[08:27:41.560]             signalCondition <- base::signalCondition
[08:27:41.560]             sys.calls <- base::sys.calls
[08:27:41.560]             `[[` <- base::`[[`
[08:27:41.560]             `+` <- base::`+`
[08:27:41.560]             `<<-` <- base::`<<-`
[08:27:41.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.560]                   3L)]
[08:27:41.560]             }
[08:27:41.560]             function(cond) {
[08:27:41.560]                 is_error <- inherits(cond, "error")
[08:27:41.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.560]                   NULL)
[08:27:41.560]                 if (is_error) {
[08:27:41.560]                   sessionInformation <- function() {
[08:27:41.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.560]                       search = base::search(), system = base::Sys.info())
[08:27:41.560]                   }
[08:27:41.560]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.560]                     cond$call), session = sessionInformation(), 
[08:27:41.560]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.560]                   signalCondition(cond)
[08:27:41.560]                 }
[08:27:41.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.560]                 "immediateCondition"))) {
[08:27:41.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.560]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.560]                   if (TRUE && !signal) {
[08:27:41.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.560]                     {
[08:27:41.560]                       inherits <- base::inherits
[08:27:41.560]                       invokeRestart <- base::invokeRestart
[08:27:41.560]                       is.null <- base::is.null
[08:27:41.560]                       muffled <- FALSE
[08:27:41.560]                       if (inherits(cond, "message")) {
[08:27:41.560]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.560]                         if (muffled) 
[08:27:41.560]                           invokeRestart("muffleMessage")
[08:27:41.560]                       }
[08:27:41.560]                       else if (inherits(cond, "warning")) {
[08:27:41.560]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.560]                         if (muffled) 
[08:27:41.560]                           invokeRestart("muffleWarning")
[08:27:41.560]                       }
[08:27:41.560]                       else if (inherits(cond, "condition")) {
[08:27:41.560]                         if (!is.null(pattern)) {
[08:27:41.560]                           computeRestarts <- base::computeRestarts
[08:27:41.560]                           grepl <- base::grepl
[08:27:41.560]                           restarts <- computeRestarts(cond)
[08:27:41.560]                           for (restart in restarts) {
[08:27:41.560]                             name <- restart$name
[08:27:41.560]                             if (is.null(name)) 
[08:27:41.560]                               next
[08:27:41.560]                             if (!grepl(pattern, name)) 
[08:27:41.560]                               next
[08:27:41.560]                             invokeRestart(restart)
[08:27:41.560]                             muffled <- TRUE
[08:27:41.560]                             break
[08:27:41.560]                           }
[08:27:41.560]                         }
[08:27:41.560]                       }
[08:27:41.560]                       invisible(muffled)
[08:27:41.560]                     }
[08:27:41.560]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.560]                   }
[08:27:41.560]                 }
[08:27:41.560]                 else {
[08:27:41.560]                   if (TRUE) {
[08:27:41.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.560]                     {
[08:27:41.560]                       inherits <- base::inherits
[08:27:41.560]                       invokeRestart <- base::invokeRestart
[08:27:41.560]                       is.null <- base::is.null
[08:27:41.560]                       muffled <- FALSE
[08:27:41.560]                       if (inherits(cond, "message")) {
[08:27:41.560]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.560]                         if (muffled) 
[08:27:41.560]                           invokeRestart("muffleMessage")
[08:27:41.560]                       }
[08:27:41.560]                       else if (inherits(cond, "warning")) {
[08:27:41.560]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.560]                         if (muffled) 
[08:27:41.560]                           invokeRestart("muffleWarning")
[08:27:41.560]                       }
[08:27:41.560]                       else if (inherits(cond, "condition")) {
[08:27:41.560]                         if (!is.null(pattern)) {
[08:27:41.560]                           computeRestarts <- base::computeRestarts
[08:27:41.560]                           grepl <- base::grepl
[08:27:41.560]                           restarts <- computeRestarts(cond)
[08:27:41.560]                           for (restart in restarts) {
[08:27:41.560]                             name <- restart$name
[08:27:41.560]                             if (is.null(name)) 
[08:27:41.560]                               next
[08:27:41.560]                             if (!grepl(pattern, name)) 
[08:27:41.560]                               next
[08:27:41.560]                             invokeRestart(restart)
[08:27:41.560]                             muffled <- TRUE
[08:27:41.560]                             break
[08:27:41.560]                           }
[08:27:41.560]                         }
[08:27:41.560]                       }
[08:27:41.560]                       invisible(muffled)
[08:27:41.560]                     }
[08:27:41.560]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.560]                   }
[08:27:41.560]                 }
[08:27:41.560]             }
[08:27:41.560]         }))
[08:27:41.560]     }, error = function(ex) {
[08:27:41.560]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.560]                 ...future.rng), started = ...future.startTime, 
[08:27:41.560]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.560]             version = "1.8"), class = "FutureResult")
[08:27:41.560]     }, finally = {
[08:27:41.560]         if (!identical(...future.workdir, getwd())) 
[08:27:41.560]             setwd(...future.workdir)
[08:27:41.560]         {
[08:27:41.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.560]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.560]             }
[08:27:41.560]             base::options(...future.oldOptions)
[08:27:41.560]             if (.Platform$OS.type == "windows") {
[08:27:41.560]                 old_names <- names(...future.oldEnvVars)
[08:27:41.560]                 envs <- base::Sys.getenv()
[08:27:41.560]                 names <- names(envs)
[08:27:41.560]                 common <- intersect(names, old_names)
[08:27:41.560]                 added <- setdiff(names, old_names)
[08:27:41.560]                 removed <- setdiff(old_names, names)
[08:27:41.560]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.560]                   envs[common]]
[08:27:41.560]                 NAMES <- toupper(changed)
[08:27:41.560]                 args <- list()
[08:27:41.560]                 for (kk in seq_along(NAMES)) {
[08:27:41.560]                   name <- changed[[kk]]
[08:27:41.560]                   NAME <- NAMES[[kk]]
[08:27:41.560]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.560]                     next
[08:27:41.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.560]                 }
[08:27:41.560]                 NAMES <- toupper(added)
[08:27:41.560]                 for (kk in seq_along(NAMES)) {
[08:27:41.560]                   name <- added[[kk]]
[08:27:41.560]                   NAME <- NAMES[[kk]]
[08:27:41.560]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.560]                     next
[08:27:41.560]                   args[[name]] <- ""
[08:27:41.560]                 }
[08:27:41.560]                 NAMES <- toupper(removed)
[08:27:41.560]                 for (kk in seq_along(NAMES)) {
[08:27:41.560]                   name <- removed[[kk]]
[08:27:41.560]                   NAME <- NAMES[[kk]]
[08:27:41.560]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.560]                     next
[08:27:41.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.560]                 }
[08:27:41.560]                 if (length(args) > 0) 
[08:27:41.560]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.560]             }
[08:27:41.560]             else {
[08:27:41.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.560]             }
[08:27:41.560]             {
[08:27:41.560]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.560]                   0L) {
[08:27:41.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.560]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.560]                   base::options(opts)
[08:27:41.560]                 }
[08:27:41.560]                 {
[08:27:41.560]                   {
[08:27:41.560]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:41.560]                     NULL
[08:27:41.560]                   }
[08:27:41.560]                   options(future.plan = NULL)
[08:27:41.560]                   if (is.na(NA_character_)) 
[08:27:41.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.560]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.560]                     .init = FALSE)
[08:27:41.560]                 }
[08:27:41.560]             }
[08:27:41.560]         }
[08:27:41.560]     })
[08:27:41.560]     if (TRUE) {
[08:27:41.560]         base::sink(type = "output", split = FALSE)
[08:27:41.560]         if (TRUE) {
[08:27:41.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.560]         }
[08:27:41.560]         else {
[08:27:41.560]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.560]         }
[08:27:41.560]         base::close(...future.stdout)
[08:27:41.560]         ...future.stdout <- NULL
[08:27:41.560]     }
[08:27:41.560]     ...future.result$conditions <- ...future.conditions
[08:27:41.560]     ...future.result$finished <- base::Sys.time()
[08:27:41.560]     ...future.result
[08:27:41.560] }
[08:27:41.563] requestCore(): workers = 2
[08:27:41.565] MulticoreFuture started
[08:27:41.565] - Launch lazy future ... done
[08:27:41.566] run() for ‘MulticoreFuture’ ... done
[08:27:41.566] plan(): Setting new future strategy stack:
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[08:27:41.567] result() for MulticoreFuture ...
[08:27:41.567] result() for MulticoreFuture ... done
[08:27:41.567] result() for MulticoreFuture ...
[08:27:41.566] List of future strategies:
[08:27:41.566] 1. sequential:
[08:27:41.566]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.566]    - tweaked: FALSE
[08:27:41.566]    - call: NULL
[08:27:41.567] result() for MulticoreFuture ... done
[08:27:41.567] signalConditions() ...
[08:27:41.567] plan(): nbrOfWorkers() = 1
[08:27:41.568]  - include = ‘immediateCondition’
[08:27:41.568]  - exclude = 
[08:27:41.568]  - resignal = FALSE
[08:27:41.568]  - Number of conditions: 1
[08:27:41.568] signalConditions() ... done
[08:27:41.568] Future state: ‘finished’
[08:27:41.569] result() for MulticoreFuture ...
[08:27:41.569] result() for MulticoreFuture ... done
[08:27:41.569] signalConditions() ...
[08:27:41.569]  - include = ‘condition’
[08:27:41.569]  - exclude = ‘immediateCondition’
[08:27:41.569] plan(): Setting new future strategy stack:
[08:27:41.569]  - resignal = TRUE
[08:27:41.570]  - Number of conditions: 1
[08:27:41.570]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:27:41.569] List of future strategies:
[08:27:41.569] 1. multicore:
[08:27:41.569]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:41.569]    - tweaked: FALSE
[08:27:41.569]    - call: plan(strategy)
[08:27:41.570] signalConditions() ... done
v3: <simpleError> (as expect)
[08:27:41.570] result() for MulticoreFuture ...
[08:27:41.572] plan(): nbrOfWorkers() = 2
[08:27:41.573] result() for MulticoreFuture ...
[08:27:41.573] result() for MulticoreFuture ... done
[08:27:41.573] result() for MulticoreFuture ... done
[08:27:41.574] result() for MulticoreFuture ...
[08:27:41.574] result() for MulticoreFuture ... done
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[08:27:41.574] getGlobalsAndPackages() ...
[08:27:41.575] Searching for globals...
[08:27:41.575] 
[08:27:41.575] Searching for globals ... DONE
[08:27:41.575] - globals: [0] <none>
[08:27:41.575] getGlobalsAndPackages() ... DONE
[08:27:41.576] run() for ‘Future’ ...
[08:27:41.576] - state: ‘created’
[08:27:41.576] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:41.578] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:41.578] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:41.579]   - Field: ‘label’
[08:27:41.579]   - Field: ‘local’
[08:27:41.579]   - Field: ‘owner’
[08:27:41.579]   - Field: ‘envir’
[08:27:41.579]   - Field: ‘workers’
[08:27:41.579]   - Field: ‘packages’
[08:27:41.579]   - Field: ‘gc’
[08:27:41.579]   - Field: ‘job’
[08:27:41.579]   - Field: ‘conditions’
[08:27:41.580]   - Field: ‘expr’
[08:27:41.580]   - Field: ‘uuid’
[08:27:41.580]   - Field: ‘seed’
[08:27:41.580]   - Field: ‘version’
[08:27:41.580]   - Field: ‘result’
[08:27:41.580]   - Field: ‘asynchronous’
[08:27:41.580]   - Field: ‘calls’
[08:27:41.580]   - Field: ‘globals’
[08:27:41.580]   - Field: ‘stdout’
[08:27:41.581]   - Field: ‘earlySignal’
[08:27:41.581]   - Field: ‘lazy’
[08:27:41.581]   - Field: ‘state’
[08:27:41.581] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:41.581] - Launch lazy future ...
[08:27:41.581] Packages needed by the future expression (n = 0): <none>
[08:27:41.581] Packages needed by future strategies (n = 0): <none>
[08:27:41.582] {
[08:27:41.582]     {
[08:27:41.582]         {
[08:27:41.582]             ...future.startTime <- base::Sys.time()
[08:27:41.582]             {
[08:27:41.582]                 {
[08:27:41.582]                   {
[08:27:41.582]                     {
[08:27:41.582]                       base::local({
[08:27:41.582]                         has_future <- base::requireNamespace("future", 
[08:27:41.582]                           quietly = TRUE)
[08:27:41.582]                         if (has_future) {
[08:27:41.582]                           ns <- base::getNamespace("future")
[08:27:41.582]                           version <- ns[[".package"]][["version"]]
[08:27:41.582]                           if (is.null(version)) 
[08:27:41.582]                             version <- utils::packageVersion("future")
[08:27:41.582]                         }
[08:27:41.582]                         else {
[08:27:41.582]                           version <- NULL
[08:27:41.582]                         }
[08:27:41.582]                         if (!has_future || version < "1.8.0") {
[08:27:41.582]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.582]                             "", base::R.version$version.string), 
[08:27:41.582]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:41.582]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.582]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.582]                               "release", "version")], collapse = " "), 
[08:27:41.582]                             hostname = base::Sys.info()[["nodename"]])
[08:27:41.582]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.582]                             info)
[08:27:41.582]                           info <- base::paste(info, collapse = "; ")
[08:27:41.582]                           if (!has_future) {
[08:27:41.582]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.582]                               info)
[08:27:41.582]                           }
[08:27:41.582]                           else {
[08:27:41.582]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.582]                               info, version)
[08:27:41.582]                           }
[08:27:41.582]                           base::stop(msg)
[08:27:41.582]                         }
[08:27:41.582]                       })
[08:27:41.582]                     }
[08:27:41.582]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:41.582]                     base::options(mc.cores = 1L)
[08:27:41.582]                   }
[08:27:41.582]                   ...future.strategy.old <- future::plan("list")
[08:27:41.582]                   options(future.plan = NULL)
[08:27:41.582]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.582]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.582]                 }
[08:27:41.582]                 ...future.workdir <- getwd()
[08:27:41.582]             }
[08:27:41.582]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.582]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.582]         }
[08:27:41.582]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.582]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.582]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.582]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.582]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.582]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.582]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.582]             base::names(...future.oldOptions))
[08:27:41.582]     }
[08:27:41.582]     if (FALSE) {
[08:27:41.582]     }
[08:27:41.582]     else {
[08:27:41.582]         if (TRUE) {
[08:27:41.582]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.582]                 open = "w")
[08:27:41.582]         }
[08:27:41.582]         else {
[08:27:41.582]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.582]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.582]         }
[08:27:41.582]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.582]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.582]             base::sink(type = "output", split = FALSE)
[08:27:41.582]             base::close(...future.stdout)
[08:27:41.582]         }, add = TRUE)
[08:27:41.582]     }
[08:27:41.582]     ...future.frame <- base::sys.nframe()
[08:27:41.582]     ...future.conditions <- base::list()
[08:27:41.582]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.582]     if (FALSE) {
[08:27:41.582]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.582]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.582]     }
[08:27:41.582]     ...future.result <- base::tryCatch({
[08:27:41.582]         base::withCallingHandlers({
[08:27:41.582]             ...future.value <- base::withVisible(base::local({
[08:27:41.582]                 withCallingHandlers({
[08:27:41.582]                   1
[08:27:41.582]                 }, immediateCondition = function(cond) {
[08:27:41.582]                   save_rds <- function (object, pathname, ...) 
[08:27:41.582]                   {
[08:27:41.582]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:41.582]                     if (file_test("-f", pathname_tmp)) {
[08:27:41.582]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.582]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:41.582]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.582]                         fi_tmp[["mtime"]])
[08:27:41.582]                     }
[08:27:41.582]                     tryCatch({
[08:27:41.582]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:41.582]                     }, error = function(ex) {
[08:27:41.582]                       msg <- conditionMessage(ex)
[08:27:41.582]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.582]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:41.582]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.582]                         fi_tmp[["mtime"]], msg)
[08:27:41.582]                       ex$message <- msg
[08:27:41.582]                       stop(ex)
[08:27:41.582]                     })
[08:27:41.582]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:41.582]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:41.582]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:41.582]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.582]                       fi <- file.info(pathname)
[08:27:41.582]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:41.582]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.582]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:41.582]                         fi[["size"]], fi[["mtime"]])
[08:27:41.582]                       stop(msg)
[08:27:41.582]                     }
[08:27:41.582]                     invisible(pathname)
[08:27:41.582]                   }
[08:27:41.582]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:41.582]                     rootPath = tempdir()) 
[08:27:41.582]                   {
[08:27:41.582]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:41.582]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:41.582]                       tmpdir = path, fileext = ".rds")
[08:27:41.582]                     save_rds(obj, file)
[08:27:41.582]                   }
[08:27:41.582]                   saveImmediateCondition(cond, path = "/tmp/RtmpOWg6bo/.future/immediateConditions")
[08:27:41.582]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.582]                   {
[08:27:41.582]                     inherits <- base::inherits
[08:27:41.582]                     invokeRestart <- base::invokeRestart
[08:27:41.582]                     is.null <- base::is.null
[08:27:41.582]                     muffled <- FALSE
[08:27:41.582]                     if (inherits(cond, "message")) {
[08:27:41.582]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:41.582]                       if (muffled) 
[08:27:41.582]                         invokeRestart("muffleMessage")
[08:27:41.582]                     }
[08:27:41.582]                     else if (inherits(cond, "warning")) {
[08:27:41.582]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:41.582]                       if (muffled) 
[08:27:41.582]                         invokeRestart("muffleWarning")
[08:27:41.582]                     }
[08:27:41.582]                     else if (inherits(cond, "condition")) {
[08:27:41.582]                       if (!is.null(pattern)) {
[08:27:41.582]                         computeRestarts <- base::computeRestarts
[08:27:41.582]                         grepl <- base::grepl
[08:27:41.582]                         restarts <- computeRestarts(cond)
[08:27:41.582]                         for (restart in restarts) {
[08:27:41.582]                           name <- restart$name
[08:27:41.582]                           if (is.null(name)) 
[08:27:41.582]                             next
[08:27:41.582]                           if (!grepl(pattern, name)) 
[08:27:41.582]                             next
[08:27:41.582]                           invokeRestart(restart)
[08:27:41.582]                           muffled <- TRUE
[08:27:41.582]                           break
[08:27:41.582]                         }
[08:27:41.582]                       }
[08:27:41.582]                     }
[08:27:41.582]                     invisible(muffled)
[08:27:41.582]                   }
[08:27:41.582]                   muffleCondition(cond)
[08:27:41.582]                 })
[08:27:41.582]             }))
[08:27:41.582]             future::FutureResult(value = ...future.value$value, 
[08:27:41.582]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.582]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.582]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.582]                     ...future.globalenv.names))
[08:27:41.582]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.582]         }, condition = base::local({
[08:27:41.582]             c <- base::c
[08:27:41.582]             inherits <- base::inherits
[08:27:41.582]             invokeRestart <- base::invokeRestart
[08:27:41.582]             length <- base::length
[08:27:41.582]             list <- base::list
[08:27:41.582]             seq.int <- base::seq.int
[08:27:41.582]             signalCondition <- base::signalCondition
[08:27:41.582]             sys.calls <- base::sys.calls
[08:27:41.582]             `[[` <- base::`[[`
[08:27:41.582]             `+` <- base::`+`
[08:27:41.582]             `<<-` <- base::`<<-`
[08:27:41.582]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.582]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.582]                   3L)]
[08:27:41.582]             }
[08:27:41.582]             function(cond) {
[08:27:41.582]                 is_error <- inherits(cond, "error")
[08:27:41.582]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.582]                   NULL)
[08:27:41.582]                 if (is_error) {
[08:27:41.582]                   sessionInformation <- function() {
[08:27:41.582]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.582]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.582]                       search = base::search(), system = base::Sys.info())
[08:27:41.582]                   }
[08:27:41.582]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.582]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.582]                     cond$call), session = sessionInformation(), 
[08:27:41.582]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.582]                   signalCondition(cond)
[08:27:41.582]                 }
[08:27:41.582]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.582]                 "immediateCondition"))) {
[08:27:41.582]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.582]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.582]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.582]                   if (TRUE && !signal) {
[08:27:41.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.582]                     {
[08:27:41.582]                       inherits <- base::inherits
[08:27:41.582]                       invokeRestart <- base::invokeRestart
[08:27:41.582]                       is.null <- base::is.null
[08:27:41.582]                       muffled <- FALSE
[08:27:41.582]                       if (inherits(cond, "message")) {
[08:27:41.582]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.582]                         if (muffled) 
[08:27:41.582]                           invokeRestart("muffleMessage")
[08:27:41.582]                       }
[08:27:41.582]                       else if (inherits(cond, "warning")) {
[08:27:41.582]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.582]                         if (muffled) 
[08:27:41.582]                           invokeRestart("muffleWarning")
[08:27:41.582]                       }
[08:27:41.582]                       else if (inherits(cond, "condition")) {
[08:27:41.582]                         if (!is.null(pattern)) {
[08:27:41.582]                           computeRestarts <- base::computeRestarts
[08:27:41.582]                           grepl <- base::grepl
[08:27:41.582]                           restarts <- computeRestarts(cond)
[08:27:41.582]                           for (restart in restarts) {
[08:27:41.582]                             name <- restart$name
[08:27:41.582]                             if (is.null(name)) 
[08:27:41.582]                               next
[08:27:41.582]                             if (!grepl(pattern, name)) 
[08:27:41.582]                               next
[08:27:41.582]                             invokeRestart(restart)
[08:27:41.582]                             muffled <- TRUE
[08:27:41.582]                             break
[08:27:41.582]                           }
[08:27:41.582]                         }
[08:27:41.582]                       }
[08:27:41.582]                       invisible(muffled)
[08:27:41.582]                     }
[08:27:41.582]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.582]                   }
[08:27:41.582]                 }
[08:27:41.582]                 else {
[08:27:41.582]                   if (TRUE) {
[08:27:41.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.582]                     {
[08:27:41.582]                       inherits <- base::inherits
[08:27:41.582]                       invokeRestart <- base::invokeRestart
[08:27:41.582]                       is.null <- base::is.null
[08:27:41.582]                       muffled <- FALSE
[08:27:41.582]                       if (inherits(cond, "message")) {
[08:27:41.582]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.582]                         if (muffled) 
[08:27:41.582]                           invokeRestart("muffleMessage")
[08:27:41.582]                       }
[08:27:41.582]                       else if (inherits(cond, "warning")) {
[08:27:41.582]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.582]                         if (muffled) 
[08:27:41.582]                           invokeRestart("muffleWarning")
[08:27:41.582]                       }
[08:27:41.582]                       else if (inherits(cond, "condition")) {
[08:27:41.582]                         if (!is.null(pattern)) {
[08:27:41.582]                           computeRestarts <- base::computeRestarts
[08:27:41.582]                           grepl <- base::grepl
[08:27:41.582]                           restarts <- computeRestarts(cond)
[08:27:41.582]                           for (restart in restarts) {
[08:27:41.582]                             name <- restart$name
[08:27:41.582]                             if (is.null(name)) 
[08:27:41.582]                               next
[08:27:41.582]                             if (!grepl(pattern, name)) 
[08:27:41.582]                               next
[08:27:41.582]                             invokeRestart(restart)
[08:27:41.582]                             muffled <- TRUE
[08:27:41.582]                             break
[08:27:41.582]                           }
[08:27:41.582]                         }
[08:27:41.582]                       }
[08:27:41.582]                       invisible(muffled)
[08:27:41.582]                     }
[08:27:41.582]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.582]                   }
[08:27:41.582]                 }
[08:27:41.582]             }
[08:27:41.582]         }))
[08:27:41.582]     }, error = function(ex) {
[08:27:41.582]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.582]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.582]                 ...future.rng), started = ...future.startTime, 
[08:27:41.582]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.582]             version = "1.8"), class = "FutureResult")
[08:27:41.582]     }, finally = {
[08:27:41.582]         if (!identical(...future.workdir, getwd())) 
[08:27:41.582]             setwd(...future.workdir)
[08:27:41.582]         {
[08:27:41.582]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.582]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.582]             }
[08:27:41.582]             base::options(...future.oldOptions)
[08:27:41.582]             if (.Platform$OS.type == "windows") {
[08:27:41.582]                 old_names <- names(...future.oldEnvVars)
[08:27:41.582]                 envs <- base::Sys.getenv()
[08:27:41.582]                 names <- names(envs)
[08:27:41.582]                 common <- intersect(names, old_names)
[08:27:41.582]                 added <- setdiff(names, old_names)
[08:27:41.582]                 removed <- setdiff(old_names, names)
[08:27:41.582]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.582]                   envs[common]]
[08:27:41.582]                 NAMES <- toupper(changed)
[08:27:41.582]                 args <- list()
[08:27:41.582]                 for (kk in seq_along(NAMES)) {
[08:27:41.582]                   name <- changed[[kk]]
[08:27:41.582]                   NAME <- NAMES[[kk]]
[08:27:41.582]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.582]                     next
[08:27:41.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.582]                 }
[08:27:41.582]                 NAMES <- toupper(added)
[08:27:41.582]                 for (kk in seq_along(NAMES)) {
[08:27:41.582]                   name <- added[[kk]]
[08:27:41.582]                   NAME <- NAMES[[kk]]
[08:27:41.582]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.582]                     next
[08:27:41.582]                   args[[name]] <- ""
[08:27:41.582]                 }
[08:27:41.582]                 NAMES <- toupper(removed)
[08:27:41.582]                 for (kk in seq_along(NAMES)) {
[08:27:41.582]                   name <- removed[[kk]]
[08:27:41.582]                   NAME <- NAMES[[kk]]
[08:27:41.582]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.582]                     next
[08:27:41.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.582]                 }
[08:27:41.582]                 if (length(args) > 0) 
[08:27:41.582]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.582]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.582]             }
[08:27:41.582]             else {
[08:27:41.582]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.582]             }
[08:27:41.582]             {
[08:27:41.582]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.582]                   0L) {
[08:27:41.582]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.582]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.582]                   base::options(opts)
[08:27:41.582]                 }
[08:27:41.582]                 {
[08:27:41.582]                   {
[08:27:41.582]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:41.582]                     NULL
[08:27:41.582]                   }
[08:27:41.582]                   options(future.plan = NULL)
[08:27:41.582]                   if (is.na(NA_character_)) 
[08:27:41.582]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.582]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.582]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.582]                     .init = FALSE)
[08:27:41.582]                 }
[08:27:41.582]             }
[08:27:41.582]         }
[08:27:41.582]     })
[08:27:41.582]     if (TRUE) {
[08:27:41.582]         base::sink(type = "output", split = FALSE)
[08:27:41.582]         if (TRUE) {
[08:27:41.582]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.582]         }
[08:27:41.582]         else {
[08:27:41.582]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.582]         }
[08:27:41.582]         base::close(...future.stdout)
[08:27:41.582]         ...future.stdout <- NULL
[08:27:41.582]     }
[08:27:41.582]     ...future.result$conditions <- ...future.conditions
[08:27:41.582]     ...future.result$finished <- base::Sys.time()
[08:27:41.582]     ...future.result
[08:27:41.582] }
[08:27:41.585] requestCore(): workers = 2
[08:27:41.587] MulticoreFuture started
[08:27:41.587] - Launch lazy future ... done
[08:27:41.587] run() for ‘MulticoreFuture’ ... done
[08:27:41.588] plan(): Setting new future strategy stack:
[08:27:41.588] result() for MulticoreFuture ...
[08:27:41.588] List of future strategies:
[08:27:41.588] 1. sequential:
[08:27:41.588]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.588]    - tweaked: FALSE
[08:27:41.588]    - call: NULL
[08:27:41.589] plan(): nbrOfWorkers() = 1
[08:27:41.591] plan(): Setting new future strategy stack:
[08:27:41.591] List of future strategies:
[08:27:41.591] 1. multicore:
[08:27:41.591]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:41.591]    - tweaked: FALSE
[08:27:41.591]    - call: plan(strategy)
[08:27:41.594] plan(): nbrOfWorkers() = 2
[08:27:41.595] result() for MulticoreFuture ...
[08:27:41.595] result() for MulticoreFuture ... done
[08:27:41.595] result() for MulticoreFuture ... done
[08:27:41.595] result() for MulticoreFuture ...
[08:27:41.595] result() for MulticoreFuture ... done
c = 1
[08:27:41.596] getGlobalsAndPackages() ...
[08:27:41.596] Searching for globals...
[08:27:41.597] 
[08:27:41.597] Searching for globals ... DONE
[08:27:41.597] - globals: [0] <none>
[08:27:41.597] getGlobalsAndPackages() ... DONE
[08:27:41.597] run() for ‘Future’ ...
[08:27:41.597] - state: ‘created’
[08:27:41.598] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:41.600] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:41.600] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:41.600]   - Field: ‘label’
[08:27:41.600]   - Field: ‘local’
[08:27:41.600]   - Field: ‘owner’
[08:27:41.600]   - Field: ‘envir’
[08:27:41.601]   - Field: ‘workers’
[08:27:41.601]   - Field: ‘packages’
[08:27:41.601]   - Field: ‘gc’
[08:27:41.601]   - Field: ‘job’
[08:27:41.601]   - Field: ‘conditions’
[08:27:41.601]   - Field: ‘expr’
[08:27:41.601]   - Field: ‘uuid’
[08:27:41.601]   - Field: ‘seed’
[08:27:41.601]   - Field: ‘version’
[08:27:41.602]   - Field: ‘result’
[08:27:41.602]   - Field: ‘asynchronous’
[08:27:41.602]   - Field: ‘calls’
[08:27:41.602]   - Field: ‘globals’
[08:27:41.602]   - Field: ‘stdout’
[08:27:41.602]   - Field: ‘earlySignal’
[08:27:41.602]   - Field: ‘lazy’
[08:27:41.602]   - Field: ‘state’
[08:27:41.605] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:41.605] - Launch lazy future ...
[08:27:41.606] Packages needed by the future expression (n = 0): <none>
[08:27:41.606] Packages needed by future strategies (n = 0): <none>
[08:27:41.607] {
[08:27:41.607]     {
[08:27:41.607]         {
[08:27:41.607]             ...future.startTime <- base::Sys.time()
[08:27:41.607]             {
[08:27:41.607]                 {
[08:27:41.607]                   {
[08:27:41.607]                     {
[08:27:41.607]                       base::local({
[08:27:41.607]                         has_future <- base::requireNamespace("future", 
[08:27:41.607]                           quietly = TRUE)
[08:27:41.607]                         if (has_future) {
[08:27:41.607]                           ns <- base::getNamespace("future")
[08:27:41.607]                           version <- ns[[".package"]][["version"]]
[08:27:41.607]                           if (is.null(version)) 
[08:27:41.607]                             version <- utils::packageVersion("future")
[08:27:41.607]                         }
[08:27:41.607]                         else {
[08:27:41.607]                           version <- NULL
[08:27:41.607]                         }
[08:27:41.607]                         if (!has_future || version < "1.8.0") {
[08:27:41.607]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.607]                             "", base::R.version$version.string), 
[08:27:41.607]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:41.607]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.607]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.607]                               "release", "version")], collapse = " "), 
[08:27:41.607]                             hostname = base::Sys.info()[["nodename"]])
[08:27:41.607]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.607]                             info)
[08:27:41.607]                           info <- base::paste(info, collapse = "; ")
[08:27:41.607]                           if (!has_future) {
[08:27:41.607]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.607]                               info)
[08:27:41.607]                           }
[08:27:41.607]                           else {
[08:27:41.607]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.607]                               info, version)
[08:27:41.607]                           }
[08:27:41.607]                           base::stop(msg)
[08:27:41.607]                         }
[08:27:41.607]                       })
[08:27:41.607]                     }
[08:27:41.607]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:41.607]                     base::options(mc.cores = 1L)
[08:27:41.607]                   }
[08:27:41.607]                   ...future.strategy.old <- future::plan("list")
[08:27:41.607]                   options(future.plan = NULL)
[08:27:41.607]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.607]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.607]                 }
[08:27:41.607]                 ...future.workdir <- getwd()
[08:27:41.607]             }
[08:27:41.607]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.607]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.607]         }
[08:27:41.607]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.607]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.607]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.607]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.607]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.607]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.607]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.607]             base::names(...future.oldOptions))
[08:27:41.607]     }
[08:27:41.607]     if (FALSE) {
[08:27:41.607]     }
[08:27:41.607]     else {
[08:27:41.607]         if (TRUE) {
[08:27:41.607]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.607]                 open = "w")
[08:27:41.607]         }
[08:27:41.607]         else {
[08:27:41.607]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.607]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.607]         }
[08:27:41.607]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.607]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.607]             base::sink(type = "output", split = FALSE)
[08:27:41.607]             base::close(...future.stdout)
[08:27:41.607]         }, add = TRUE)
[08:27:41.607]     }
[08:27:41.607]     ...future.frame <- base::sys.nframe()
[08:27:41.607]     ...future.conditions <- base::list()
[08:27:41.607]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.607]     if (FALSE) {
[08:27:41.607]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.607]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.607]     }
[08:27:41.607]     ...future.result <- base::tryCatch({
[08:27:41.607]         base::withCallingHandlers({
[08:27:41.607]             ...future.value <- base::withVisible(base::local({
[08:27:41.607]                 withCallingHandlers({
[08:27:41.607]                   1
[08:27:41.607]                 }, immediateCondition = function(cond) {
[08:27:41.607]                   save_rds <- function (object, pathname, ...) 
[08:27:41.607]                   {
[08:27:41.607]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:41.607]                     if (file_test("-f", pathname_tmp)) {
[08:27:41.607]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.607]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:41.607]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.607]                         fi_tmp[["mtime"]])
[08:27:41.607]                     }
[08:27:41.607]                     tryCatch({
[08:27:41.607]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:41.607]                     }, error = function(ex) {
[08:27:41.607]                       msg <- conditionMessage(ex)
[08:27:41.607]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.607]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:41.607]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.607]                         fi_tmp[["mtime"]], msg)
[08:27:41.607]                       ex$message <- msg
[08:27:41.607]                       stop(ex)
[08:27:41.607]                     })
[08:27:41.607]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:41.607]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:41.607]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:41.607]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.607]                       fi <- file.info(pathname)
[08:27:41.607]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:41.607]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.607]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:41.607]                         fi[["size"]], fi[["mtime"]])
[08:27:41.607]                       stop(msg)
[08:27:41.607]                     }
[08:27:41.607]                     invisible(pathname)
[08:27:41.607]                   }
[08:27:41.607]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:41.607]                     rootPath = tempdir()) 
[08:27:41.607]                   {
[08:27:41.607]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:41.607]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:41.607]                       tmpdir = path, fileext = ".rds")
[08:27:41.607]                     save_rds(obj, file)
[08:27:41.607]                   }
[08:27:41.607]                   saveImmediateCondition(cond, path = "/tmp/RtmpOWg6bo/.future/immediateConditions")
[08:27:41.607]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.607]                   {
[08:27:41.607]                     inherits <- base::inherits
[08:27:41.607]                     invokeRestart <- base::invokeRestart
[08:27:41.607]                     is.null <- base::is.null
[08:27:41.607]                     muffled <- FALSE
[08:27:41.607]                     if (inherits(cond, "message")) {
[08:27:41.607]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:41.607]                       if (muffled) 
[08:27:41.607]                         invokeRestart("muffleMessage")
[08:27:41.607]                     }
[08:27:41.607]                     else if (inherits(cond, "warning")) {
[08:27:41.607]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:41.607]                       if (muffled) 
[08:27:41.607]                         invokeRestart("muffleWarning")
[08:27:41.607]                     }
[08:27:41.607]                     else if (inherits(cond, "condition")) {
[08:27:41.607]                       if (!is.null(pattern)) {
[08:27:41.607]                         computeRestarts <- base::computeRestarts
[08:27:41.607]                         grepl <- base::grepl
[08:27:41.607]                         restarts <- computeRestarts(cond)
[08:27:41.607]                         for (restart in restarts) {
[08:27:41.607]                           name <- restart$name
[08:27:41.607]                           if (is.null(name)) 
[08:27:41.607]                             next
[08:27:41.607]                           if (!grepl(pattern, name)) 
[08:27:41.607]                             next
[08:27:41.607]                           invokeRestart(restart)
[08:27:41.607]                           muffled <- TRUE
[08:27:41.607]                           break
[08:27:41.607]                         }
[08:27:41.607]                       }
[08:27:41.607]                     }
[08:27:41.607]                     invisible(muffled)
[08:27:41.607]                   }
[08:27:41.607]                   muffleCondition(cond)
[08:27:41.607]                 })
[08:27:41.607]             }))
[08:27:41.607]             future::FutureResult(value = ...future.value$value, 
[08:27:41.607]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.607]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.607]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.607]                     ...future.globalenv.names))
[08:27:41.607]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.607]         }, condition = base::local({
[08:27:41.607]             c <- base::c
[08:27:41.607]             inherits <- base::inherits
[08:27:41.607]             invokeRestart <- base::invokeRestart
[08:27:41.607]             length <- base::length
[08:27:41.607]             list <- base::list
[08:27:41.607]             seq.int <- base::seq.int
[08:27:41.607]             signalCondition <- base::signalCondition
[08:27:41.607]             sys.calls <- base::sys.calls
[08:27:41.607]             `[[` <- base::`[[`
[08:27:41.607]             `+` <- base::`+`
[08:27:41.607]             `<<-` <- base::`<<-`
[08:27:41.607]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.607]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.607]                   3L)]
[08:27:41.607]             }
[08:27:41.607]             function(cond) {
[08:27:41.607]                 is_error <- inherits(cond, "error")
[08:27:41.607]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.607]                   NULL)
[08:27:41.607]                 if (is_error) {
[08:27:41.607]                   sessionInformation <- function() {
[08:27:41.607]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.607]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.607]                       search = base::search(), system = base::Sys.info())
[08:27:41.607]                   }
[08:27:41.607]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.607]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.607]                     cond$call), session = sessionInformation(), 
[08:27:41.607]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.607]                   signalCondition(cond)
[08:27:41.607]                 }
[08:27:41.607]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.607]                 "immediateCondition"))) {
[08:27:41.607]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.607]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.607]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.607]                   if (TRUE && !signal) {
[08:27:41.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.607]                     {
[08:27:41.607]                       inherits <- base::inherits
[08:27:41.607]                       invokeRestart <- base::invokeRestart
[08:27:41.607]                       is.null <- base::is.null
[08:27:41.607]                       muffled <- FALSE
[08:27:41.607]                       if (inherits(cond, "message")) {
[08:27:41.607]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.607]                         if (muffled) 
[08:27:41.607]                           invokeRestart("muffleMessage")
[08:27:41.607]                       }
[08:27:41.607]                       else if (inherits(cond, "warning")) {
[08:27:41.607]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.607]                         if (muffled) 
[08:27:41.607]                           invokeRestart("muffleWarning")
[08:27:41.607]                       }
[08:27:41.607]                       else if (inherits(cond, "condition")) {
[08:27:41.607]                         if (!is.null(pattern)) {
[08:27:41.607]                           computeRestarts <- base::computeRestarts
[08:27:41.607]                           grepl <- base::grepl
[08:27:41.607]                           restarts <- computeRestarts(cond)
[08:27:41.607]                           for (restart in restarts) {
[08:27:41.607]                             name <- restart$name
[08:27:41.607]                             if (is.null(name)) 
[08:27:41.607]                               next
[08:27:41.607]                             if (!grepl(pattern, name)) 
[08:27:41.607]                               next
[08:27:41.607]                             invokeRestart(restart)
[08:27:41.607]                             muffled <- TRUE
[08:27:41.607]                             break
[08:27:41.607]                           }
[08:27:41.607]                         }
[08:27:41.607]                       }
[08:27:41.607]                       invisible(muffled)
[08:27:41.607]                     }
[08:27:41.607]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.607]                   }
[08:27:41.607]                 }
[08:27:41.607]                 else {
[08:27:41.607]                   if (TRUE) {
[08:27:41.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.607]                     {
[08:27:41.607]                       inherits <- base::inherits
[08:27:41.607]                       invokeRestart <- base::invokeRestart
[08:27:41.607]                       is.null <- base::is.null
[08:27:41.607]                       muffled <- FALSE
[08:27:41.607]                       if (inherits(cond, "message")) {
[08:27:41.607]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.607]                         if (muffled) 
[08:27:41.607]                           invokeRestart("muffleMessage")
[08:27:41.607]                       }
[08:27:41.607]                       else if (inherits(cond, "warning")) {
[08:27:41.607]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.607]                         if (muffled) 
[08:27:41.607]                           invokeRestart("muffleWarning")
[08:27:41.607]                       }
[08:27:41.607]                       else if (inherits(cond, "condition")) {
[08:27:41.607]                         if (!is.null(pattern)) {
[08:27:41.607]                           computeRestarts <- base::computeRestarts
[08:27:41.607]                           grepl <- base::grepl
[08:27:41.607]                           restarts <- computeRestarts(cond)
[08:27:41.607]                           for (restart in restarts) {
[08:27:41.607]                             name <- restart$name
[08:27:41.607]                             if (is.null(name)) 
[08:27:41.607]                               next
[08:27:41.607]                             if (!grepl(pattern, name)) 
[08:27:41.607]                               next
[08:27:41.607]                             invokeRestart(restart)
[08:27:41.607]                             muffled <- TRUE
[08:27:41.607]                             break
[08:27:41.607]                           }
[08:27:41.607]                         }
[08:27:41.607]                       }
[08:27:41.607]                       invisible(muffled)
[08:27:41.607]                     }
[08:27:41.607]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.607]                   }
[08:27:41.607]                 }
[08:27:41.607]             }
[08:27:41.607]         }))
[08:27:41.607]     }, error = function(ex) {
[08:27:41.607]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.607]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.607]                 ...future.rng), started = ...future.startTime, 
[08:27:41.607]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.607]             version = "1.8"), class = "FutureResult")
[08:27:41.607]     }, finally = {
[08:27:41.607]         if (!identical(...future.workdir, getwd())) 
[08:27:41.607]             setwd(...future.workdir)
[08:27:41.607]         {
[08:27:41.607]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.607]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.607]             }
[08:27:41.607]             base::options(...future.oldOptions)
[08:27:41.607]             if (.Platform$OS.type == "windows") {
[08:27:41.607]                 old_names <- names(...future.oldEnvVars)
[08:27:41.607]                 envs <- base::Sys.getenv()
[08:27:41.607]                 names <- names(envs)
[08:27:41.607]                 common <- intersect(names, old_names)
[08:27:41.607]                 added <- setdiff(names, old_names)
[08:27:41.607]                 removed <- setdiff(old_names, names)
[08:27:41.607]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.607]                   envs[common]]
[08:27:41.607]                 NAMES <- toupper(changed)
[08:27:41.607]                 args <- list()
[08:27:41.607]                 for (kk in seq_along(NAMES)) {
[08:27:41.607]                   name <- changed[[kk]]
[08:27:41.607]                   NAME <- NAMES[[kk]]
[08:27:41.607]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.607]                     next
[08:27:41.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.607]                 }
[08:27:41.607]                 NAMES <- toupper(added)
[08:27:41.607]                 for (kk in seq_along(NAMES)) {
[08:27:41.607]                   name <- added[[kk]]
[08:27:41.607]                   NAME <- NAMES[[kk]]
[08:27:41.607]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.607]                     next
[08:27:41.607]                   args[[name]] <- ""
[08:27:41.607]                 }
[08:27:41.607]                 NAMES <- toupper(removed)
[08:27:41.607]                 for (kk in seq_along(NAMES)) {
[08:27:41.607]                   name <- removed[[kk]]
[08:27:41.607]                   NAME <- NAMES[[kk]]
[08:27:41.607]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.607]                     next
[08:27:41.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.607]                 }
[08:27:41.607]                 if (length(args) > 0) 
[08:27:41.607]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.607]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.607]             }
[08:27:41.607]             else {
[08:27:41.607]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.607]             }
[08:27:41.607]             {
[08:27:41.607]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.607]                   0L) {
[08:27:41.607]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.607]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.607]                   base::options(opts)
[08:27:41.607]                 }
[08:27:41.607]                 {
[08:27:41.607]                   {
[08:27:41.607]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:41.607]                     NULL
[08:27:41.607]                   }
[08:27:41.607]                   options(future.plan = NULL)
[08:27:41.607]                   if (is.na(NA_character_)) 
[08:27:41.607]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.607]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.607]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.607]                     .init = FALSE)
[08:27:41.607]                 }
[08:27:41.607]             }
[08:27:41.607]         }
[08:27:41.607]     })
[08:27:41.607]     if (TRUE) {
[08:27:41.607]         base::sink(type = "output", split = FALSE)
[08:27:41.607]         if (TRUE) {
[08:27:41.607]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.607]         }
[08:27:41.607]         else {
[08:27:41.607]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.607]         }
[08:27:41.607]         base::close(...future.stdout)
[08:27:41.607]         ...future.stdout <- NULL
[08:27:41.607]     }
[08:27:41.607]     ...future.result$conditions <- ...future.conditions
[08:27:41.607]     ...future.result$finished <- base::Sys.time()
[08:27:41.607]     ...future.result
[08:27:41.607] }
[08:27:41.609] requestCore(): workers = 2
[08:27:41.612] MulticoreFuture started
[08:27:41.612] - Launch lazy future ... done
[08:27:41.612] run() for ‘MulticoreFuture’ ... done
[08:27:41.613] plan(): Setting new future strategy stack:
[08:27:41.613] result() for MulticoreFuture ...
[08:27:41.613] List of future strategies:
[08:27:41.613] 1. sequential:
[08:27:41.613]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.613]    - tweaked: FALSE
[08:27:41.613]    - call: NULL
[08:27:41.614] plan(): nbrOfWorkers() = 1
[08:27:41.616] plan(): Setting new future strategy stack:
[08:27:41.616] List of future strategies:
[08:27:41.616] 1. multicore:
[08:27:41.616]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:41.616]    - tweaked: FALSE
[08:27:41.616]    - call: plan(strategy)
[08:27:41.620] plan(): nbrOfWorkers() = 2
[08:27:41.621] result() for MulticoreFuture ...
[08:27:41.621] result() for MulticoreFuture ... done
[08:27:41.621] result() for MulticoreFuture ... done
[08:27:41.621] result() for MulticoreFuture ...
[08:27:41.621] result() for MulticoreFuture ... done
d = 1
** Nested future assignments
[08:27:41.622] getGlobalsAndPackages() ...
[08:27:41.622] Searching for globals...
[08:27:41.627] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[08:27:41.628] Searching for globals ... DONE
[08:27:41.628] Resolving globals: FALSE
[08:27:41.628] 
[08:27:41.628] - packages: [1] ‘future’
[08:27:41.629] getGlobalsAndPackages() ... DONE
[08:27:41.629] run() for ‘Future’ ...
[08:27:41.629] - state: ‘created’
[08:27:41.629] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:41.632] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:41.632] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:41.632]   - Field: ‘label’
[08:27:41.632]   - Field: ‘local’
[08:27:41.632]   - Field: ‘owner’
[08:27:41.632]   - Field: ‘envir’
[08:27:41.632]   - Field: ‘workers’
[08:27:41.632]   - Field: ‘packages’
[08:27:41.633]   - Field: ‘gc’
[08:27:41.633]   - Field: ‘job’
[08:27:41.633]   - Field: ‘conditions’
[08:27:41.633]   - Field: ‘expr’
[08:27:41.633]   - Field: ‘uuid’
[08:27:41.633]   - Field: ‘seed’
[08:27:41.633]   - Field: ‘version’
[08:27:41.633]   - Field: ‘result’
[08:27:41.633]   - Field: ‘asynchronous’
[08:27:41.634]   - Field: ‘calls’
[08:27:41.634]   - Field: ‘globals’
[08:27:41.634]   - Field: ‘stdout’
[08:27:41.634]   - Field: ‘earlySignal’
[08:27:41.634]   - Field: ‘lazy’
[08:27:41.634]   - Field: ‘state’
[08:27:41.634] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:41.634] - Launch lazy future ...
[08:27:41.635] Packages needed by the future expression (n = 1): ‘future’
[08:27:41.635] Packages needed by future strategies (n = 0): <none>
[08:27:41.635] {
[08:27:41.635]     {
[08:27:41.635]         {
[08:27:41.635]             ...future.startTime <- base::Sys.time()
[08:27:41.635]             {
[08:27:41.635]                 {
[08:27:41.635]                   {
[08:27:41.635]                     {
[08:27:41.635]                       {
[08:27:41.635]                         base::local({
[08:27:41.635]                           has_future <- base::requireNamespace("future", 
[08:27:41.635]                             quietly = TRUE)
[08:27:41.635]                           if (has_future) {
[08:27:41.635]                             ns <- base::getNamespace("future")
[08:27:41.635]                             version <- ns[[".package"]][["version"]]
[08:27:41.635]                             if (is.null(version)) 
[08:27:41.635]                               version <- utils::packageVersion("future")
[08:27:41.635]                           }
[08:27:41.635]                           else {
[08:27:41.635]                             version <- NULL
[08:27:41.635]                           }
[08:27:41.635]                           if (!has_future || version < "1.8.0") {
[08:27:41.635]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.635]                               "", base::R.version$version.string), 
[08:27:41.635]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:41.635]                                 base::R.version$platform, 8 * 
[08:27:41.635]                                   base::.Machine$sizeof.pointer), 
[08:27:41.635]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.635]                                 "release", "version")], collapse = " "), 
[08:27:41.635]                               hostname = base::Sys.info()[["nodename"]])
[08:27:41.635]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.635]                               info)
[08:27:41.635]                             info <- base::paste(info, collapse = "; ")
[08:27:41.635]                             if (!has_future) {
[08:27:41.635]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.635]                                 info)
[08:27:41.635]                             }
[08:27:41.635]                             else {
[08:27:41.635]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.635]                                 info, version)
[08:27:41.635]                             }
[08:27:41.635]                             base::stop(msg)
[08:27:41.635]                           }
[08:27:41.635]                         })
[08:27:41.635]                       }
[08:27:41.635]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:41.635]                       base::options(mc.cores = 1L)
[08:27:41.635]                     }
[08:27:41.635]                     base::local({
[08:27:41.635]                       for (pkg in "future") {
[08:27:41.635]                         base::loadNamespace(pkg)
[08:27:41.635]                         base::library(pkg, character.only = TRUE)
[08:27:41.635]                       }
[08:27:41.635]                     })
[08:27:41.635]                   }
[08:27:41.635]                   ...future.strategy.old <- future::plan("list")
[08:27:41.635]                   options(future.plan = NULL)
[08:27:41.635]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.635]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.635]                 }
[08:27:41.635]                 ...future.workdir <- getwd()
[08:27:41.635]             }
[08:27:41.635]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.635]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.635]         }
[08:27:41.635]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.635]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.635]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.635]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.635]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.635]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.635]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.635]             base::names(...future.oldOptions))
[08:27:41.635]     }
[08:27:41.635]     if (FALSE) {
[08:27:41.635]     }
[08:27:41.635]     else {
[08:27:41.635]         if (TRUE) {
[08:27:41.635]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.635]                 open = "w")
[08:27:41.635]         }
[08:27:41.635]         else {
[08:27:41.635]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.635]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.635]         }
[08:27:41.635]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.635]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.635]             base::sink(type = "output", split = FALSE)
[08:27:41.635]             base::close(...future.stdout)
[08:27:41.635]         }, add = TRUE)
[08:27:41.635]     }
[08:27:41.635]     ...future.frame <- base::sys.nframe()
[08:27:41.635]     ...future.conditions <- base::list()
[08:27:41.635]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.635]     if (FALSE) {
[08:27:41.635]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.635]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.635]     }
[08:27:41.635]     ...future.result <- base::tryCatch({
[08:27:41.635]         base::withCallingHandlers({
[08:27:41.635]             ...future.value <- base::withVisible(base::local({
[08:27:41.635]                 withCallingHandlers({
[08:27:41.635]                   {
[08:27:41.635]                     b <- 1
[08:27:41.635]                     c %<-% 2
[08:27:41.635]                     d <- 3
[08:27:41.635]                     4 %->% e
[08:27:41.635]                     b + c + d + e
[08:27:41.635]                   }
[08:27:41.635]                 }, immediateCondition = function(cond) {
[08:27:41.635]                   save_rds <- function (object, pathname, ...) 
[08:27:41.635]                   {
[08:27:41.635]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:41.635]                     if (file_test("-f", pathname_tmp)) {
[08:27:41.635]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.635]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:41.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.635]                         fi_tmp[["mtime"]])
[08:27:41.635]                     }
[08:27:41.635]                     tryCatch({
[08:27:41.635]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:41.635]                     }, error = function(ex) {
[08:27:41.635]                       msg <- conditionMessage(ex)
[08:27:41.635]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.635]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:41.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.635]                         fi_tmp[["mtime"]], msg)
[08:27:41.635]                       ex$message <- msg
[08:27:41.635]                       stop(ex)
[08:27:41.635]                     })
[08:27:41.635]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:41.635]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:41.635]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:41.635]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.635]                       fi <- file.info(pathname)
[08:27:41.635]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:41.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.635]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:41.635]                         fi[["size"]], fi[["mtime"]])
[08:27:41.635]                       stop(msg)
[08:27:41.635]                     }
[08:27:41.635]                     invisible(pathname)
[08:27:41.635]                   }
[08:27:41.635]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:41.635]                     rootPath = tempdir()) 
[08:27:41.635]                   {
[08:27:41.635]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:41.635]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:41.635]                       tmpdir = path, fileext = ".rds")
[08:27:41.635]                     save_rds(obj, file)
[08:27:41.635]                   }
[08:27:41.635]                   saveImmediateCondition(cond, path = "/tmp/RtmpOWg6bo/.future/immediateConditions")
[08:27:41.635]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.635]                   {
[08:27:41.635]                     inherits <- base::inherits
[08:27:41.635]                     invokeRestart <- base::invokeRestart
[08:27:41.635]                     is.null <- base::is.null
[08:27:41.635]                     muffled <- FALSE
[08:27:41.635]                     if (inherits(cond, "message")) {
[08:27:41.635]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:41.635]                       if (muffled) 
[08:27:41.635]                         invokeRestart("muffleMessage")
[08:27:41.635]                     }
[08:27:41.635]                     else if (inherits(cond, "warning")) {
[08:27:41.635]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:41.635]                       if (muffled) 
[08:27:41.635]                         invokeRestart("muffleWarning")
[08:27:41.635]                     }
[08:27:41.635]                     else if (inherits(cond, "condition")) {
[08:27:41.635]                       if (!is.null(pattern)) {
[08:27:41.635]                         computeRestarts <- base::computeRestarts
[08:27:41.635]                         grepl <- base::grepl
[08:27:41.635]                         restarts <- computeRestarts(cond)
[08:27:41.635]                         for (restart in restarts) {
[08:27:41.635]                           name <- restart$name
[08:27:41.635]                           if (is.null(name)) 
[08:27:41.635]                             next
[08:27:41.635]                           if (!grepl(pattern, name)) 
[08:27:41.635]                             next
[08:27:41.635]                           invokeRestart(restart)
[08:27:41.635]                           muffled <- TRUE
[08:27:41.635]                           break
[08:27:41.635]                         }
[08:27:41.635]                       }
[08:27:41.635]                     }
[08:27:41.635]                     invisible(muffled)
[08:27:41.635]                   }
[08:27:41.635]                   muffleCondition(cond)
[08:27:41.635]                 })
[08:27:41.635]             }))
[08:27:41.635]             future::FutureResult(value = ...future.value$value, 
[08:27:41.635]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.635]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.635]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.635]                     ...future.globalenv.names))
[08:27:41.635]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.635]         }, condition = base::local({
[08:27:41.635]             c <- base::c
[08:27:41.635]             inherits <- base::inherits
[08:27:41.635]             invokeRestart <- base::invokeRestart
[08:27:41.635]             length <- base::length
[08:27:41.635]             list <- base::list
[08:27:41.635]             seq.int <- base::seq.int
[08:27:41.635]             signalCondition <- base::signalCondition
[08:27:41.635]             sys.calls <- base::sys.calls
[08:27:41.635]             `[[` <- base::`[[`
[08:27:41.635]             `+` <- base::`+`
[08:27:41.635]             `<<-` <- base::`<<-`
[08:27:41.635]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.635]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.635]                   3L)]
[08:27:41.635]             }
[08:27:41.635]             function(cond) {
[08:27:41.635]                 is_error <- inherits(cond, "error")
[08:27:41.635]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.635]                   NULL)
[08:27:41.635]                 if (is_error) {
[08:27:41.635]                   sessionInformation <- function() {
[08:27:41.635]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.635]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.635]                       search = base::search(), system = base::Sys.info())
[08:27:41.635]                   }
[08:27:41.635]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.635]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.635]                     cond$call), session = sessionInformation(), 
[08:27:41.635]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.635]                   signalCondition(cond)
[08:27:41.635]                 }
[08:27:41.635]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.635]                 "immediateCondition"))) {
[08:27:41.635]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.635]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.635]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.635]                   if (TRUE && !signal) {
[08:27:41.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.635]                     {
[08:27:41.635]                       inherits <- base::inherits
[08:27:41.635]                       invokeRestart <- base::invokeRestart
[08:27:41.635]                       is.null <- base::is.null
[08:27:41.635]                       muffled <- FALSE
[08:27:41.635]                       if (inherits(cond, "message")) {
[08:27:41.635]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.635]                         if (muffled) 
[08:27:41.635]                           invokeRestart("muffleMessage")
[08:27:41.635]                       }
[08:27:41.635]                       else if (inherits(cond, "warning")) {
[08:27:41.635]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.635]                         if (muffled) 
[08:27:41.635]                           invokeRestart("muffleWarning")
[08:27:41.635]                       }
[08:27:41.635]                       else if (inherits(cond, "condition")) {
[08:27:41.635]                         if (!is.null(pattern)) {
[08:27:41.635]                           computeRestarts <- base::computeRestarts
[08:27:41.635]                           grepl <- base::grepl
[08:27:41.635]                           restarts <- computeRestarts(cond)
[08:27:41.635]                           for (restart in restarts) {
[08:27:41.635]                             name <- restart$name
[08:27:41.635]                             if (is.null(name)) 
[08:27:41.635]                               next
[08:27:41.635]                             if (!grepl(pattern, name)) 
[08:27:41.635]                               next
[08:27:41.635]                             invokeRestart(restart)
[08:27:41.635]                             muffled <- TRUE
[08:27:41.635]                             break
[08:27:41.635]                           }
[08:27:41.635]                         }
[08:27:41.635]                       }
[08:27:41.635]                       invisible(muffled)
[08:27:41.635]                     }
[08:27:41.635]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.635]                   }
[08:27:41.635]                 }
[08:27:41.635]                 else {
[08:27:41.635]                   if (TRUE) {
[08:27:41.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.635]                     {
[08:27:41.635]                       inherits <- base::inherits
[08:27:41.635]                       invokeRestart <- base::invokeRestart
[08:27:41.635]                       is.null <- base::is.null
[08:27:41.635]                       muffled <- FALSE
[08:27:41.635]                       if (inherits(cond, "message")) {
[08:27:41.635]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.635]                         if (muffled) 
[08:27:41.635]                           invokeRestart("muffleMessage")
[08:27:41.635]                       }
[08:27:41.635]                       else if (inherits(cond, "warning")) {
[08:27:41.635]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.635]                         if (muffled) 
[08:27:41.635]                           invokeRestart("muffleWarning")
[08:27:41.635]                       }
[08:27:41.635]                       else if (inherits(cond, "condition")) {
[08:27:41.635]                         if (!is.null(pattern)) {
[08:27:41.635]                           computeRestarts <- base::computeRestarts
[08:27:41.635]                           grepl <- base::grepl
[08:27:41.635]                           restarts <- computeRestarts(cond)
[08:27:41.635]                           for (restart in restarts) {
[08:27:41.635]                             name <- restart$name
[08:27:41.635]                             if (is.null(name)) 
[08:27:41.635]                               next
[08:27:41.635]                             if (!grepl(pattern, name)) 
[08:27:41.635]                               next
[08:27:41.635]                             invokeRestart(restart)
[08:27:41.635]                             muffled <- TRUE
[08:27:41.635]                             break
[08:27:41.635]                           }
[08:27:41.635]                         }
[08:27:41.635]                       }
[08:27:41.635]                       invisible(muffled)
[08:27:41.635]                     }
[08:27:41.635]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.635]                   }
[08:27:41.635]                 }
[08:27:41.635]             }
[08:27:41.635]         }))
[08:27:41.635]     }, error = function(ex) {
[08:27:41.635]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.635]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.635]                 ...future.rng), started = ...future.startTime, 
[08:27:41.635]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.635]             version = "1.8"), class = "FutureResult")
[08:27:41.635]     }, finally = {
[08:27:41.635]         if (!identical(...future.workdir, getwd())) 
[08:27:41.635]             setwd(...future.workdir)
[08:27:41.635]         {
[08:27:41.635]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.635]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.635]             }
[08:27:41.635]             base::options(...future.oldOptions)
[08:27:41.635]             if (.Platform$OS.type == "windows") {
[08:27:41.635]                 old_names <- names(...future.oldEnvVars)
[08:27:41.635]                 envs <- base::Sys.getenv()
[08:27:41.635]                 names <- names(envs)
[08:27:41.635]                 common <- intersect(names, old_names)
[08:27:41.635]                 added <- setdiff(names, old_names)
[08:27:41.635]                 removed <- setdiff(old_names, names)
[08:27:41.635]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.635]                   envs[common]]
[08:27:41.635]                 NAMES <- toupper(changed)
[08:27:41.635]                 args <- list()
[08:27:41.635]                 for (kk in seq_along(NAMES)) {
[08:27:41.635]                   name <- changed[[kk]]
[08:27:41.635]                   NAME <- NAMES[[kk]]
[08:27:41.635]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.635]                     next
[08:27:41.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.635]                 }
[08:27:41.635]                 NAMES <- toupper(added)
[08:27:41.635]                 for (kk in seq_along(NAMES)) {
[08:27:41.635]                   name <- added[[kk]]
[08:27:41.635]                   NAME <- NAMES[[kk]]
[08:27:41.635]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.635]                     next
[08:27:41.635]                   args[[name]] <- ""
[08:27:41.635]                 }
[08:27:41.635]                 NAMES <- toupper(removed)
[08:27:41.635]                 for (kk in seq_along(NAMES)) {
[08:27:41.635]                   name <- removed[[kk]]
[08:27:41.635]                   NAME <- NAMES[[kk]]
[08:27:41.635]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.635]                     next
[08:27:41.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.635]                 }
[08:27:41.635]                 if (length(args) > 0) 
[08:27:41.635]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.635]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.635]             }
[08:27:41.635]             else {
[08:27:41.635]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.635]             }
[08:27:41.635]             {
[08:27:41.635]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.635]                   0L) {
[08:27:41.635]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.635]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.635]                   base::options(opts)
[08:27:41.635]                 }
[08:27:41.635]                 {
[08:27:41.635]                   {
[08:27:41.635]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:41.635]                     NULL
[08:27:41.635]                   }
[08:27:41.635]                   options(future.plan = NULL)
[08:27:41.635]                   if (is.na(NA_character_)) 
[08:27:41.635]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.635]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.635]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.635]                     .init = FALSE)
[08:27:41.635]                 }
[08:27:41.635]             }
[08:27:41.635]         }
[08:27:41.635]     })
[08:27:41.635]     if (TRUE) {
[08:27:41.635]         base::sink(type = "output", split = FALSE)
[08:27:41.635]         if (TRUE) {
[08:27:41.635]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.635]         }
[08:27:41.635]         else {
[08:27:41.635]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.635]         }
[08:27:41.635]         base::close(...future.stdout)
[08:27:41.635]         ...future.stdout <- NULL
[08:27:41.635]     }
[08:27:41.635]     ...future.result$conditions <- ...future.conditions
[08:27:41.635]     ...future.result$finished <- base::Sys.time()
[08:27:41.635]     ...future.result
[08:27:41.635] }
[08:27:41.638] requestCore(): workers = 2
[08:27:41.640] MulticoreFuture started
[08:27:41.641] - Launch lazy future ... done
[08:27:41.641] run() for ‘MulticoreFuture’ ... done
[08:27:41.641] result() for MulticoreFuture ...
[08:27:41.642] plan(): Setting new future strategy stack:
[08:27:41.642] List of future strategies:
[08:27:41.642] 1. sequential:
[08:27:41.642]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.642]    - tweaked: FALSE
[08:27:41.642]    - call: NULL
[08:27:41.643] plan(): nbrOfWorkers() = 1
[08:27:41.677] plan(): Setting new future strategy stack:
[08:27:41.678] List of future strategies:
[08:27:41.678] 1. multicore:
[08:27:41.678]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:41.678]    - tweaked: FALSE
[08:27:41.678]    - call: plan(strategy)
[08:27:41.680] plan(): nbrOfWorkers() = 2
[08:27:41.681] result() for MulticoreFuture ...
[08:27:41.682] result() for MulticoreFuture ... done
[08:27:41.682] signalConditions() ...
[08:27:41.682]  - include = ‘immediateCondition’
[08:27:41.682]  - exclude = 
[08:27:41.682]  - resignal = FALSE
[08:27:41.682]  - Number of conditions: 88
[08:27:41.682] signalConditions() ... done
[08:27:41.683] result() for MulticoreFuture ... done
[08:27:41.683] result() for MulticoreFuture ...
[08:27:41.683] result() for MulticoreFuture ... done
[08:27:41.683] signalConditions() ...
[08:27:41.683]  - include = ‘immediateCondition’
[08:27:41.683]  - exclude = 
[08:27:41.683]  - resignal = FALSE
[08:27:41.683]  - Number of conditions: 88
[08:27:41.683] signalConditions() ... done
[08:27:41.684] Future state: ‘finished’
[08:27:41.684] result() for MulticoreFuture ...
[08:27:41.684] result() for MulticoreFuture ... done
[08:27:41.684] signalConditions() ...
[08:27:41.684]  - include = ‘condition’
[08:27:41.684]  - exclude = ‘immediateCondition’
[08:27:41.684]  - resignal = TRUE
[08:27:41.684]  - Number of conditions: 88
[08:27:41.685]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.645] getGlobalsAndPackages() ...
[08:27:41.685]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.645] Searching for globals...
[08:27:41.685]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.646] 
[08:27:41.685]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.646] Searching for globals ... DONE
[08:27:41.685]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.646] - globals: [0] <none>
[08:27:41.685]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.646] getGlobalsAndPackages() ... DONE
[08:27:41.686]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.647] run() for ‘Future’ ...
[08:27:41.686]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.647] - state: ‘created’
[08:27:41.686]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.647] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:41.689]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.648] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:41.689]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.648] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:41.689]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.648]   - Field: ‘label’
[08:27:41.689]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.649]   - Field: ‘local’
[08:27:41.690]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.649]   - Field: ‘owner’
[08:27:41.690]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.649]   - Field: ‘envir’
[08:27:41.690]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.649]   - Field: ‘packages’
[08:27:41.690]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.649]   - Field: ‘gc’
[08:27:41.690]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.649]   - Field: ‘conditions’
[08:27:41.691]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.650]   - Field: ‘expr’
[08:27:41.691]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.650]   - Field: ‘uuid’
[08:27:41.691]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.650]   - Field: ‘seed’
[08:27:41.691]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.650]   - Field: ‘version’
[08:27:41.691]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.650]   - Field: ‘result’
[08:27:41.692]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.650]   - Field: ‘asynchronous’
[08:27:41.692]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.655]   - Field: ‘calls’
[08:27:41.692]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.655]   - Field: ‘globals’
[08:27:41.692]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.655]   - Field: ‘stdout’
[08:27:41.692]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.655]   - Field: ‘earlySignal’
[08:27:41.692]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.656]   - Field: ‘lazy’
[08:27:41.693]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.656]   - Field: ‘state’
[08:27:41.693]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.656] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:41.693]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.657] - Launch lazy future ...
[08:27:41.693]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.657] Packages needed by the future expression (n = 0): <none>
[08:27:41.693]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.657] Packages needed by future strategies (n = 0): <none>
[08:27:41.693]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.658] {
[08:27:41.658]     {
[08:27:41.658]         {
[08:27:41.658]             ...future.startTime <- base::Sys.time()
[08:27:41.658]             {
[08:27:41.658]                 {
[08:27:41.658]                   {
[08:27:41.658]                     base::local({
[08:27:41.658]                       has_future <- base::requireNamespace("future", 
[08:27:41.658]                         quietly = TRUE)
[08:27:41.658]                       if (has_future) {
[08:27:41.658]                         ns <- base::getNamespace("future")
[08:27:41.658]                         version <- ns[[".package"]][["version"]]
[08:27:41.658]                         if (is.null(version)) 
[08:27:41.658]                           version <- utils::packageVersion("future")
[08:27:41.658]                       }
[08:27:41.658]                       else {
[08:27:41.658]                         version <- NULL
[08:27:41.658]                       }
[08:27:41.658]                       if (!has_future || version < "1.8.0") {
[08:27:41.658]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.658]                           "", base::R.version$version.string), 
[08:27:41.658]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:41.658]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.658]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.658]                             "release", "version")], collapse = " "), 
[08:27:41.658]                           hostname = base::Sys.info()[["nodename"]])
[08:27:41.658]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.658]                           info)
[08:27:41.658]                         info <- base::paste(info, collapse = "; ")
[08:27:41.658]                         if (!has_future) {
[08:27:41.658]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.658]                             info)
[08:27:41.658]                         }
[08:27:41.658]                         else {
[08:27:41.658]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.658]                             info, version)
[08:27:41.658]                         }
[08:27:41.658]                         base::stop(msg)
[08:27:41.658]                       }
[08:27:41.658]                     })
[08:27:41.658]                   }
[08:27:41.658]                   ...future.strategy.old <- future::plan("list")
[08:27:41.658]                   options(future.plan = NULL)
[08:27:41.658]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.658]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.658]                 }
[08:27:41.658]                 ...future.workdir <- getwd()
[08:27:41.658]             }
[08:27:41.658]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.658]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.658]         }
[08:27:41.658]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.658]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.658]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.658]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.658]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.658]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.658]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.658]             base::names(...future.oldOptions))
[08:27:41.658]     }
[08:27:41.658]     if (FALSE) {
[08:27:41.658]     }
[08:27:41.658]     else {
[08:27:41.658]         if (TRUE) {
[08:27:41.658]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.658]                 open = "w")
[08:27:41.658]         }
[08:27:41.658]         else {
[08:27:41.658]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.658]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.658]         }
[08:27:41.658]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.658]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.658]             base::sink(type = "output", split = FALSE)
[08:27:41.658]             base::close(...future.stdout)
[08:27:41.658]         }, add = TRUE)
[08:27:41.658]     }
[08:27:41.658]     ...future.frame <- base::sys.nframe()
[08:27:41.658]     ...future.conditions <- base::list()
[08:27:41.658]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.658]     if (FALSE) {
[08:27:41.658]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.658]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.658]     }
[08:27:41.658]     ...future.result <- base::tryCatch({
[08:27:41.658]         base::withCallingHandlers({
[08:27:41.658]             ...future.value <- base::withVisible(base::local(2))
[08:27:41.658]             future::FutureResult(value = ...future.value$value, 
[08:27:41.658]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.658]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.658]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.658]                     ...future.globalenv.names))
[08:27:41.658]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.658]         }, condition = base::local({
[08:27:41.658]             c <- base::c
[08:27:41.658]             inherits <- base::inherits
[08:27:41.658]             invokeRestart <- base::invokeRestart
[08:27:41.658]             length <- base::length
[08:27:41.658]             list <- base::list
[08:27:41.658]             seq.int <- base::seq.int
[08:27:41.658]             signalCondition <- base::signalCondition
[08:27:41.658]             sys.calls <- base::sys.calls
[08:27:41.658]             `[[` <- base::`[[`
[08:27:41.658]             `+` <- base::`+`
[08:27:41.658]             `<<-` <- base::`<<-`
[08:27:41.658]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.658]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.658]                   3L)]
[08:27:41.658]             }
[08:27:41.658]             function(cond) {
[08:27:41.658]                 is_error <- inherits(cond, "error")
[08:27:41.658]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.658]                   NULL)
[08:27:41.658]                 if (is_error) {
[08:27:41.658]                   sessionInformation <- function() {
[08:27:41.658]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.658]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.658]                       search = base::search(), system = base::Sys.info())
[08:27:41.658]                   }
[08:27:41.658]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.658]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.658]                     cond$call), session = sessionInformation(), 
[08:27:41.658]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.658]                   signalCondition(cond)
[08:27:41.658]                 }
[08:27:41.658]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.658]                 "immediateCondition"))) {
[08:27:41.658]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.658]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.658]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.658]                   if (TRUE && !signal) {
[08:27:41.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.658]                     {
[08:27:41.658]                       inherits <- base::inherits
[08:27:41.658]                       invokeRestart <- base::invokeRestart
[08:27:41.658]                       is.null <- base::is.null
[08:27:41.658]                       muffled <- FALSE
[08:27:41.658]                       if (inherits(cond, "message")) {
[08:27:41.658]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.658]                         if (muffled) 
[08:27:41.658]                           invokeRestart("muffleMessage")
[08:27:41.658]                       }
[08:27:41.658]                       else if (inherits(cond, "warning")) {
[08:27:41.658]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.658]                         if (muffled) 
[08:27:41.658]                           invokeRestart("muffleWarning")
[08:27:41.658]                       }
[08:27:41.658]                       else if (inherits(cond, "condition")) {
[08:27:41.658]                         if (!is.null(pattern)) {
[08:27:41.658]                           computeRestarts <- base::computeRestarts
[08:27:41.658]                           grepl <- base::grepl
[08:27:41.658]                           restarts <- computeRestarts(cond)
[08:27:41.658]                           for (restart in restarts) {
[08:27:41.658]                             name <- restart$name
[08:27:41.658]                             if (is.null(name)) 
[08:27:41.658]                               next
[08:27:41.658]                             if (!grepl(pattern, name)) 
[08:27:41.658]                               next
[08:27:41.658]                             invokeRestart(restart)
[08:27:41.658]                             muffled <- TRUE
[08:27:41.658]                             break
[08:27:41.658]                           }
[08:27:41.658]                         }
[08:27:41.658]                       }
[08:27:41.658]                       invisible(muffled)
[08:27:41.658]                     }
[08:27:41.658]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.658]                   }
[08:27:41.658]                 }
[08:27:41.658]                 else {
[08:27:41.658]                   if (TRUE) {
[08:27:41.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.658]                     {
[08:27:41.658]                       inherits <- base::inherits
[08:27:41.658]                       invokeRestart <- base::invokeRestart
[08:27:41.658]                       is.null <- base::is.null
[08:27:41.658]                       muffled <- FALSE
[08:27:41.658]                       if (inherits(cond, "message")) {
[08:27:41.658]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.658]                         if (muffled) 
[08:27:41.658]                           invokeRestart("muffleMessage")
[08:27:41.658]                       }
[08:27:41.658]                       else if (inherits(cond, "warning")) {
[08:27:41.658]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.658]                         if (muffled) 
[08:27:41.658]                           invokeRestart("muffleWarning")
[08:27:41.658]                       }
[08:27:41.658]                       else if (inherits(cond, "condition")) {
[08:27:41.658]                         if (!is.null(pattern)) {
[08:27:41.658]                           computeRestarts <- base::computeRestarts
[08:27:41.658]                           grepl <- base::grepl
[08:27:41.658]                           restarts <- computeRestarts(cond)
[08:27:41.658]                           for (restart in restarts) {
[08:27:41.658]                             name <- restart$name
[08:27:41.658]                             if (is.null(name)) 
[08:27:41.658]                               next
[08:27:41.658]                             if (!grepl(pattern, name)) 
[08:27:41.658]                               next
[08:27:41.658]                             invokeRestart(restart)
[08:27:41.658]                             muffled <- TRUE
[08:27:41.658]                             break
[08:27:41.658]                           }
[08:27:41.658]                         }
[08:27:41.658]                       }
[08:27:41.658]                       invisible(muffled)
[08:27:41.658]                     }
[08:27:41.658]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.658]                   }
[08:27:41.658]                 }
[08:27:41.658]             }
[08:27:41.658]         }))
[08:27:41.658]     }, error = function(ex) {
[08:27:41.658]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.658]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.658]                 ...future.rng), started = ...future.startTime, 
[08:27:41.658]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.658]             version = "1.8"), class = "FutureResult")
[08:27:41.658]     }, finally = {
[08:27:41.658]         if (!identical(...future.workdir, getwd())) 
[08:27:41.658]             setwd(...future.workdir)
[08:27:41.658]         {
[08:27:41.658]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.658]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.658]             }
[08:27:41.658]             base::options(...future.oldOptions)
[08:27:41.658]             if (.Platform$OS.type == "windows") {
[08:27:41.658]                 old_names <- names(...future.oldEnvVars)
[08:27:41.658]                 envs <- base::Sys.getenv()
[08:27:41.658]                 names <- names(envs)
[08:27:41.658]                 common <- intersect(names, old_names)
[08:27:41.658]                 added <- setdiff(names, old_names)
[08:27:41.658]                 removed <- setdiff(old_names, names)
[08:27:41.658]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.658]                   envs[common]]
[08:27:41.658]                 NAMES <- toupper(changed)
[08:27:41.658]                 args <- list()
[08:27:41.658]                 for (kk in seq_along(NAMES)) {
[08:27:41.658]                   name <- changed[[kk]]
[08:27:41.658]                   NAME <- NAMES[[kk]]
[08:27:41.658]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.658]                     next
[08:27:41.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.658]                 }
[08:27:41.658]                 NAMES <- toupper(added)
[08:27:41.658]                 for (kk in seq_along(NAMES)) {
[08:27:41.658]                   name <- added[[kk]]
[08:27:41.658]                   NAME <- NAMES[[kk]]
[08:27:41.658]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.658]                     next
[08:27:41.658]                   args[[name]] <- ""
[08:27:41.658]                 }
[08:27:41.658]                 NAMES <- toupper(removed)
[08:27:41.658]                 for (kk in seq_along(NAMES)) {
[08:27:41.658]                   name <- removed[[kk]]
[08:27:41.658]                   NAME <- NAMES[[kk]]
[08:27:41.658]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.658]                     next
[08:27:41.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.658]                 }
[08:27:41.658]                 if (length(args) > 0) 
[08:27:41.658]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.658]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.658]             }
[08:27:41.658]             else {
[08:27:41.658]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.658]             }
[08:27:41.658]             {
[08:27:41.658]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.658]                   0L) {
[08:27:41.658]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.658]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.658]                   base::options(opts)
[08:27:41.658]                 }
[08:27:41.658]                 {
[08:27:41.658]                   {
[08:27:41.658]                     NULL
[08:27:41.658]                     RNGkind("Mersenne-Twister")
[08:27:41.658]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:41.658]                       inherits = FALSE)
[08:27:41.658]                   }
[08:27:41.658]                   options(future.plan = NULL)
[08:27:41.658]                   if (is.na(NA_character_)) 
[08:27:41.658]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.658]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.658]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.658]                     .init = FALSE)
[08:27:41.658]                 }
[08:27:41.658]             }
[08:27:41.658]         }
[08:27:41.658]     })
[08:27:41.658]     if (TRUE) {
[08:27:41.658]         base::sink(type = "output", split = FALSE)
[08:27:41.658]         if (TRUE) {
[08:27:41.658]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.658]         }
[08:27:41.658]         else {
[08:27:41.658]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.658]         }
[08:27:41.658]         base::close(...future.stdout)
[08:27:41.658]         ...future.stdout <- NULL
[08:27:41.658]     }
[08:27:41.658]     ...future.result$conditions <- ...future.conditions
[08:27:41.658]     ...future.result$finished <- base::Sys.time()
[08:27:41.658]     ...future.result
[08:27:41.658] }
[08:27:41.694]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.660] plan(): Setting new future strategy stack:
[08:27:41.694]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.661] List of future strategies:
[08:27:41.661] 1. sequential:
[08:27:41.661]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.661]    - tweaked: FALSE
[08:27:41.661]    - call: NULL
[08:27:41.694]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.661] plan(): nbrOfWorkers() = 1
[08:27:41.694]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.663] plan(): Setting new future strategy stack:
[08:27:41.694]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.663] List of future strategies:
[08:27:41.663] 1. sequential:
[08:27:41.663]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.663]    - tweaked: FALSE
[08:27:41.663]    - call: NULL
[08:27:41.695]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.664] plan(): nbrOfWorkers() = 1
[08:27:41.695]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.664] SequentialFuture started (and completed)
[08:27:41.695]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.664] - Launch lazy future ... done
[08:27:41.695]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.664] run() for ‘SequentialFuture’ ... done
[08:27:41.695]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.665] getGlobalsAndPackages() ...
[08:27:41.695]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.665] Searching for globals...
[08:27:41.696]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.665] 
[08:27:41.696]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.666] Searching for globals ... DONE
[08:27:41.696]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.666] - globals: [0] <none>
[08:27:41.696]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.666] getGlobalsAndPackages() ... DONE
[08:27:41.696]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.666] run() for ‘Future’ ...
[08:27:41.696]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.667] - state: ‘created’
[08:27:41.696]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.667] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:41.697]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.667] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:41.697]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.667] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:41.697]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.668]   - Field: ‘label’
[08:27:41.697]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.668]   - Field: ‘local’
[08:27:41.697]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.668]   - Field: ‘owner’
[08:27:41.697]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.668]   - Field: ‘envir’
[08:27:41.698]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.668]   - Field: ‘packages’
[08:27:41.698]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.668]   - Field: ‘gc’
[08:27:41.698]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.669]   - Field: ‘conditions’
[08:27:41.698]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.669]   - Field: ‘expr’
[08:27:41.698]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.669]   - Field: ‘uuid’
[08:27:41.698]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.669]   - Field: ‘seed’
[08:27:41.698]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.669]   - Field: ‘version’
[08:27:41.699]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.669]   - Field: ‘result’
[08:27:41.699]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.670]   - Field: ‘asynchronous’
[08:27:41.699]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.670]   - Field: ‘calls’
[08:27:41.699]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.670]   - Field: ‘globals’
[08:27:41.699]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.670]   - Field: ‘stdout’
[08:27:41.699]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.670]   - Field: ‘earlySignal’
[08:27:41.699]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.670]   - Field: ‘lazy’
[08:27:41.700]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.670]   - Field: ‘state’
[08:27:41.700]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.671] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:41.700]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.671] - Launch lazy future ...
[08:27:41.700]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.671] Packages needed by the future expression (n = 0): <none>
[08:27:41.700]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.671] Packages needed by future strategies (n = 0): <none>
[08:27:41.700]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.672] {
[08:27:41.672]     {
[08:27:41.672]         {
[08:27:41.672]             ...future.startTime <- base::Sys.time()
[08:27:41.672]             {
[08:27:41.672]                 {
[08:27:41.672]                   {
[08:27:41.672]                     base::local({
[08:27:41.672]                       has_future <- base::requireNamespace("future", 
[08:27:41.672]                         quietly = TRUE)
[08:27:41.672]                       if (has_future) {
[08:27:41.672]                         ns <- base::getNamespace("future")
[08:27:41.672]                         version <- ns[[".package"]][["version"]]
[08:27:41.672]                         if (is.null(version)) 
[08:27:41.672]                           version <- utils::packageVersion("future")
[08:27:41.672]                       }
[08:27:41.672]                       else {
[08:27:41.672]                         version <- NULL
[08:27:41.672]                       }
[08:27:41.672]                       if (!has_future || version < "1.8.0") {
[08:27:41.672]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.672]                           "", base::R.version$version.string), 
[08:27:41.672]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:41.672]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.672]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.672]                             "release", "version")], collapse = " "), 
[08:27:41.672]                           hostname = base::Sys.info()[["nodename"]])
[08:27:41.672]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.672]                           info)
[08:27:41.672]                         info <- base::paste(info, collapse = "; ")
[08:27:41.672]                         if (!has_future) {
[08:27:41.672]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.672]                             info)
[08:27:41.672]                         }
[08:27:41.672]                         else {
[08:27:41.672]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.672]                             info, version)
[08:27:41.672]                         }
[08:27:41.672]                         base::stop(msg)
[08:27:41.672]                       }
[08:27:41.672]                     })
[08:27:41.672]                   }
[08:27:41.672]                   ...future.strategy.old <- future::plan("list")
[08:27:41.672]                   options(future.plan = NULL)
[08:27:41.672]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.672]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.672]                 }
[08:27:41.672]                 ...future.workdir <- getwd()
[08:27:41.672]             }
[08:27:41.672]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.672]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.672]         }
[08:27:41.672]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.672]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.672]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.672]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.672]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.672]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.672]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.672]             base::names(...future.oldOptions))
[08:27:41.672]     }
[08:27:41.672]     if (FALSE) {
[08:27:41.672]     }
[08:27:41.672]     else {
[08:27:41.672]         if (TRUE) {
[08:27:41.672]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.672]                 open = "w")
[08:27:41.672]         }
[08:27:41.672]         else {
[08:27:41.672]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.672]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.672]         }
[08:27:41.672]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.672]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.672]             base::sink(type = "output", split = FALSE)
[08:27:41.672]             base::close(...future.stdout)
[08:27:41.672]         }, add = TRUE)
[08:27:41.672]     }
[08:27:41.672]     ...future.frame <- base::sys.nframe()
[08:27:41.672]     ...future.conditions <- base::list()
[08:27:41.672]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.672]     if (FALSE) {
[08:27:41.672]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.672]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.672]     }
[08:27:41.672]     ...future.result <- base::tryCatch({
[08:27:41.672]         base::withCallingHandlers({
[08:27:41.672]             ...future.value <- base::withVisible(base::local(4))
[08:27:41.672]             future::FutureResult(value = ...future.value$value, 
[08:27:41.672]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.672]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.672]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.672]                     ...future.globalenv.names))
[08:27:41.672]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.672]         }, condition = base::local({
[08:27:41.672]             c <- base::c
[08:27:41.672]             inherits <- base::inherits
[08:27:41.672]             invokeRestart <- base::invokeRestart
[08:27:41.672]             length <- base::length
[08:27:41.672]             list <- base::list
[08:27:41.672]             seq.int <- base::seq.int
[08:27:41.672]             signalCondition <- base::signalCondition
[08:27:41.672]             sys.calls <- base::sys.calls
[08:27:41.672]             `[[` <- base::`[[`
[08:27:41.672]             `+` <- base::`+`
[08:27:41.672]             `<<-` <- base::`<<-`
[08:27:41.672]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.672]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.672]                   3L)]
[08:27:41.672]             }
[08:27:41.672]             function(cond) {
[08:27:41.672]                 is_error <- inherits(cond, "error")
[08:27:41.672]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.672]                   NULL)
[08:27:41.672]                 if (is_error) {
[08:27:41.672]                   sessionInformation <- function() {
[08:27:41.672]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.672]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.672]                       search = base::search(), system = base::Sys.info())
[08:27:41.672]                   }
[08:27:41.672]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.672]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.672]                     cond$call), session = sessionInformation(), 
[08:27:41.672]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.672]                   signalCondition(cond)
[08:27:41.672]                 }
[08:27:41.672]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.672]                 "immediateCondition"))) {
[08:27:41.672]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.672]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.672]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.672]                   if (TRUE && !signal) {
[08:27:41.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.672]                     {
[08:27:41.672]                       inherits <- base::inherits
[08:27:41.672]                       invokeRestart <- base::invokeRestart
[08:27:41.672]                       is.null <- base::is.null
[08:27:41.672]                       muffled <- FALSE
[08:27:41.672]                       if (inherits(cond, "message")) {
[08:27:41.672]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.672]                         if (muffled) 
[08:27:41.672]                           invokeRestart("muffleMessage")
[08:27:41.672]                       }
[08:27:41.672]                       else if (inherits(cond, "warning")) {
[08:27:41.672]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.672]                         if (muffled) 
[08:27:41.672]                           invokeRestart("muffleWarning")
[08:27:41.672]                       }
[08:27:41.672]                       else if (inherits(cond, "condition")) {
[08:27:41.672]                         if (!is.null(pattern)) {
[08:27:41.672]                           computeRestarts <- base::computeRestarts
[08:27:41.672]                           grepl <- base::grepl
[08:27:41.672]                           restarts <- computeRestarts(cond)
[08:27:41.672]                           for (restart in restarts) {
[08:27:41.672]                             name <- restart$name
[08:27:41.672]                             if (is.null(name)) 
[08:27:41.672]                               next
[08:27:41.672]                             if (!grepl(pattern, name)) 
[08:27:41.672]                               next
[08:27:41.672]                             invokeRestart(restart)
[08:27:41.672]                             muffled <- TRUE
[08:27:41.672]                             break
[08:27:41.672]                           }
[08:27:41.672]                         }
[08:27:41.672]                       }
[08:27:41.672]                       invisible(muffled)
[08:27:41.672]                     }
[08:27:41.672]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.672]                   }
[08:27:41.672]                 }
[08:27:41.672]                 else {
[08:27:41.672]                   if (TRUE) {
[08:27:41.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.672]                     {
[08:27:41.672]                       inherits <- base::inherits
[08:27:41.672]                       invokeRestart <- base::invokeRestart
[08:27:41.672]                       is.null <- base::is.null
[08:27:41.672]                       muffled <- FALSE
[08:27:41.672]                       if (inherits(cond, "message")) {
[08:27:41.672]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.672]                         if (muffled) 
[08:27:41.672]                           invokeRestart("muffleMessage")
[08:27:41.672]                       }
[08:27:41.672]                       else if (inherits(cond, "warning")) {
[08:27:41.672]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.672]                         if (muffled) 
[08:27:41.672]                           invokeRestart("muffleWarning")
[08:27:41.672]                       }
[08:27:41.672]                       else if (inherits(cond, "condition")) {
[08:27:41.672]                         if (!is.null(pattern)) {
[08:27:41.672]                           computeRestarts <- base::computeRestarts
[08:27:41.672]                           grepl <- base::grepl
[08:27:41.672]                           restarts <- computeRestarts(cond)
[08:27:41.672]                           for (restart in restarts) {
[08:27:41.672]                             name <- restart$name
[08:27:41.672]                             if (is.null(name)) 
[08:27:41.672]                               next
[08:27:41.672]                             if (!grepl(pattern, name)) 
[08:27:41.672]                               next
[08:27:41.672]                             invokeRestart(restart)
[08:27:41.672]                             muffled <- TRUE
[08:27:41.672]                             break
[08:27:41.672]                           }
[08:27:41.672]                         }
[08:27:41.672]                       }
[08:27:41.672]                       invisible(muffled)
[08:27:41.672]                     }
[08:27:41.672]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.672]                   }
[08:27:41.672]                 }
[08:27:41.672]             }
[08:27:41.672]         }))
[08:27:41.672]     }, error = function(ex) {
[08:27:41.672]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.672]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.672]                 ...future.rng), started = ...future.startTime, 
[08:27:41.672]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.672]             version = "1.8"), class = "FutureResult")
[08:27:41.672]     }, finally = {
[08:27:41.672]         if (!identical(...future.workdir, getwd())) 
[08:27:41.672]             setwd(...future.workdir)
[08:27:41.672]         {
[08:27:41.672]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.672]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.672]             }
[08:27:41.672]             base::options(...future.oldOptions)
[08:27:41.672]             if (.Platform$OS.type == "windows") {
[08:27:41.672]                 old_names <- names(...future.oldEnvVars)
[08:27:41.672]                 envs <- base::Sys.getenv()
[08:27:41.672]                 names <- names(envs)
[08:27:41.672]                 common <- intersect(names, old_names)
[08:27:41.672]                 added <- setdiff(names, old_names)
[08:27:41.672]                 removed <- setdiff(old_names, names)
[08:27:41.672]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.672]                   envs[common]]
[08:27:41.672]                 NAMES <- toupper(changed)
[08:27:41.672]                 args <- list()
[08:27:41.672]                 for (kk in seq_along(NAMES)) {
[08:27:41.672]                   name <- changed[[kk]]
[08:27:41.672]                   NAME <- NAMES[[kk]]
[08:27:41.672]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.672]                     next
[08:27:41.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.672]                 }
[08:27:41.672]                 NAMES <- toupper(added)
[08:27:41.672]                 for (kk in seq_along(NAMES)) {
[08:27:41.672]                   name <- added[[kk]]
[08:27:41.672]                   NAME <- NAMES[[kk]]
[08:27:41.672]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.672]                     next
[08:27:41.672]                   args[[name]] <- ""
[08:27:41.672]                 }
[08:27:41.672]                 NAMES <- toupper(removed)
[08:27:41.672]                 for (kk in seq_along(NAMES)) {
[08:27:41.672]                   name <- removed[[kk]]
[08:27:41.672]                   NAME <- NAMES[[kk]]
[08:27:41.672]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.672]                     next
[08:27:41.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.672]                 }
[08:27:41.672]                 if (length(args) > 0) 
[08:27:41.672]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.672]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.672]             }
[08:27:41.672]             else {
[08:27:41.672]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.672]             }
[08:27:41.672]             {
[08:27:41.672]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.672]                   0L) {
[08:27:41.672]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.672]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.672]                   base::options(opts)
[08:27:41.672]                 }
[08:27:41.672]                 {
[08:27:41.672]                   {
[08:27:41.672]                     NULL
[08:27:41.672]                     RNGkind("Mersenne-Twister")
[08:27:41.672]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:41.672]                       inherits = FALSE)
[08:27:41.672]                   }
[08:27:41.672]                   options(future.plan = NULL)
[08:27:41.672]                   if (is.na(NA_character_)) 
[08:27:41.672]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.672]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.672]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.672]                     .init = FALSE)
[08:27:41.672]                 }
[08:27:41.672]             }
[08:27:41.672]         }
[08:27:41.672]     })
[08:27:41.672]     if (TRUE) {
[08:27:41.672]         base::sink(type = "output", split = FALSE)
[08:27:41.672]         if (TRUE) {
[08:27:41.672]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.672]         }
[08:27:41.672]         else {
[08:27:41.672]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.672]         }
[08:27:41.672]         base::close(...future.stdout)
[08:27:41.672]         ...future.stdout <- NULL
[08:27:41.672]     }
[08:27:41.672]     ...future.result$conditions <- ...future.conditions
[08:27:41.672]     ...future.result$finished <- base::Sys.time()
[08:27:41.672]     ...future.result
[08:27:41.672] }
[08:27:41.701]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.674] plan(): Setting new future strategy stack:
[08:27:41.701]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.674] List of future strategies:
[08:27:41.674] 1. sequential:
[08:27:41.674]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.674]    - tweaked: FALSE
[08:27:41.674]    - call: NULL
[08:27:41.701]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.674] plan(): nbrOfWorkers() = 1
[08:27:41.701]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.675] plan(): Setting new future strategy stack:
[08:27:41.701]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.675] List of future strategies:
[08:27:41.675] 1. sequential:
[08:27:41.675]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.675]    - tweaked: FALSE
[08:27:41.675]    - call: NULL
[08:27:41.701]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.676] plan(): nbrOfWorkers() = 1
[08:27:41.702]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.676] SequentialFuture started (and completed)
[08:27:41.702]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.676] - Launch lazy future ... done
[08:27:41.702]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[08:27:41.677] run() for ‘SequentialFuture’ ... done
[08:27:41.702] signalConditions() ... done
a = 10
[08:27:41.703] getGlobalsAndPackages() ...
[08:27:41.703] Searching for globals...
[08:27:41.704] - globals found: [3] ‘{’, ‘+’, ‘a’
[08:27:41.704] Searching for globals ... DONE
[08:27:41.704] Resolving globals: FALSE
[08:27:41.705] The total size of the 1 globals is 39 bytes (39 bytes)
[08:27:41.705] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[08:27:41.705] - globals: [1] ‘a’
[08:27:41.705] 
[08:27:41.705] getGlobalsAndPackages() ... DONE
[08:27:41.706] run() for ‘Future’ ...
[08:27:41.706] - state: ‘created’
[08:27:41.706] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:41.708] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:41.708] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:41.708]   - Field: ‘label’
[08:27:41.708]   - Field: ‘local’
[08:27:41.708]   - Field: ‘owner’
[08:27:41.708]   - Field: ‘envir’
[08:27:41.708]   - Field: ‘workers’
[08:27:41.709]   - Field: ‘packages’
[08:27:41.709]   - Field: ‘gc’
[08:27:41.709]   - Field: ‘job’
[08:27:41.709]   - Field: ‘conditions’
[08:27:41.709]   - Field: ‘expr’
[08:27:41.709]   - Field: ‘uuid’
[08:27:41.709]   - Field: ‘seed’
[08:27:41.709]   - Field: ‘version’
[08:27:41.709]   - Field: ‘result’
[08:27:41.709]   - Field: ‘asynchronous’
[08:27:41.709]   - Field: ‘calls’
[08:27:41.710]   - Field: ‘globals’
[08:27:41.710]   - Field: ‘stdout’
[08:27:41.710]   - Field: ‘earlySignal’
[08:27:41.710]   - Field: ‘lazy’
[08:27:41.710]   - Field: ‘state’
[08:27:41.710] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:41.710] - Launch lazy future ...
[08:27:41.710] Packages needed by the future expression (n = 0): <none>
[08:27:41.710] Packages needed by future strategies (n = 0): <none>
[08:27:41.713] {
[08:27:41.713]     {
[08:27:41.713]         {
[08:27:41.713]             ...future.startTime <- base::Sys.time()
[08:27:41.713]             {
[08:27:41.713]                 {
[08:27:41.713]                   {
[08:27:41.713]                     {
[08:27:41.713]                       base::local({
[08:27:41.713]                         has_future <- base::requireNamespace("future", 
[08:27:41.713]                           quietly = TRUE)
[08:27:41.713]                         if (has_future) {
[08:27:41.713]                           ns <- base::getNamespace("future")
[08:27:41.713]                           version <- ns[[".package"]][["version"]]
[08:27:41.713]                           if (is.null(version)) 
[08:27:41.713]                             version <- utils::packageVersion("future")
[08:27:41.713]                         }
[08:27:41.713]                         else {
[08:27:41.713]                           version <- NULL
[08:27:41.713]                         }
[08:27:41.713]                         if (!has_future || version < "1.8.0") {
[08:27:41.713]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:41.713]                             "", base::R.version$version.string), 
[08:27:41.713]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:41.713]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:41.713]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:41.713]                               "release", "version")], collapse = " "), 
[08:27:41.713]                             hostname = base::Sys.info()[["nodename"]])
[08:27:41.713]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:41.713]                             info)
[08:27:41.713]                           info <- base::paste(info, collapse = "; ")
[08:27:41.713]                           if (!has_future) {
[08:27:41.713]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:41.713]                               info)
[08:27:41.713]                           }
[08:27:41.713]                           else {
[08:27:41.713]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:41.713]                               info, version)
[08:27:41.713]                           }
[08:27:41.713]                           base::stop(msg)
[08:27:41.713]                         }
[08:27:41.713]                       })
[08:27:41.713]                     }
[08:27:41.713]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:41.713]                     base::options(mc.cores = 1L)
[08:27:41.713]                   }
[08:27:41.713]                   ...future.strategy.old <- future::plan("list")
[08:27:41.713]                   options(future.plan = NULL)
[08:27:41.713]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.713]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:41.713]                 }
[08:27:41.713]                 ...future.workdir <- getwd()
[08:27:41.713]             }
[08:27:41.713]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:41.713]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:41.713]         }
[08:27:41.713]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:41.713]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:41.713]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:41.713]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:41.713]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:41.713]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:41.713]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:41.713]             base::names(...future.oldOptions))
[08:27:41.713]     }
[08:27:41.713]     if (FALSE) {
[08:27:41.713]     }
[08:27:41.713]     else {
[08:27:41.713]         if (TRUE) {
[08:27:41.713]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:41.713]                 open = "w")
[08:27:41.713]         }
[08:27:41.713]         else {
[08:27:41.713]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:41.713]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:41.713]         }
[08:27:41.713]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:41.713]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:41.713]             base::sink(type = "output", split = FALSE)
[08:27:41.713]             base::close(...future.stdout)
[08:27:41.713]         }, add = TRUE)
[08:27:41.713]     }
[08:27:41.713]     ...future.frame <- base::sys.nframe()
[08:27:41.713]     ...future.conditions <- base::list()
[08:27:41.713]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:41.713]     if (FALSE) {
[08:27:41.713]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:41.713]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:41.713]     }
[08:27:41.713]     ...future.result <- base::tryCatch({
[08:27:41.713]         base::withCallingHandlers({
[08:27:41.713]             ...future.value <- base::withVisible(base::local({
[08:27:41.713]                 withCallingHandlers({
[08:27:41.713]                   {
[08:27:41.713]                     a + 1
[08:27:41.713]                   }
[08:27:41.713]                 }, immediateCondition = function(cond) {
[08:27:41.713]                   save_rds <- function (object, pathname, ...) 
[08:27:41.713]                   {
[08:27:41.713]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:41.713]                     if (file_test("-f", pathname_tmp)) {
[08:27:41.713]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.713]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:41.713]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.713]                         fi_tmp[["mtime"]])
[08:27:41.713]                     }
[08:27:41.713]                     tryCatch({
[08:27:41.713]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:41.713]                     }, error = function(ex) {
[08:27:41.713]                       msg <- conditionMessage(ex)
[08:27:41.713]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.713]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:41.713]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.713]                         fi_tmp[["mtime"]], msg)
[08:27:41.713]                       ex$message <- msg
[08:27:41.713]                       stop(ex)
[08:27:41.713]                     })
[08:27:41.713]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:41.713]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:41.713]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:41.713]                       fi_tmp <- file.info(pathname_tmp)
[08:27:41.713]                       fi <- file.info(pathname)
[08:27:41.713]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:41.713]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:41.713]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:41.713]                         fi[["size"]], fi[["mtime"]])
[08:27:41.713]                       stop(msg)
[08:27:41.713]                     }
[08:27:41.713]                     invisible(pathname)
[08:27:41.713]                   }
[08:27:41.713]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:41.713]                     rootPath = tempdir()) 
[08:27:41.713]                   {
[08:27:41.713]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:41.713]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:41.713]                       tmpdir = path, fileext = ".rds")
[08:27:41.713]                     save_rds(obj, file)
[08:27:41.713]                   }
[08:27:41.713]                   saveImmediateCondition(cond, path = "/tmp/RtmpOWg6bo/.future/immediateConditions")
[08:27:41.713]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.713]                   {
[08:27:41.713]                     inherits <- base::inherits
[08:27:41.713]                     invokeRestart <- base::invokeRestart
[08:27:41.713]                     is.null <- base::is.null
[08:27:41.713]                     muffled <- FALSE
[08:27:41.713]                     if (inherits(cond, "message")) {
[08:27:41.713]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:41.713]                       if (muffled) 
[08:27:41.713]                         invokeRestart("muffleMessage")
[08:27:41.713]                     }
[08:27:41.713]                     else if (inherits(cond, "warning")) {
[08:27:41.713]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:41.713]                       if (muffled) 
[08:27:41.713]                         invokeRestart("muffleWarning")
[08:27:41.713]                     }
[08:27:41.713]                     else if (inherits(cond, "condition")) {
[08:27:41.713]                       if (!is.null(pattern)) {
[08:27:41.713]                         computeRestarts <- base::computeRestarts
[08:27:41.713]                         grepl <- base::grepl
[08:27:41.713]                         restarts <- computeRestarts(cond)
[08:27:41.713]                         for (restart in restarts) {
[08:27:41.713]                           name <- restart$name
[08:27:41.713]                           if (is.null(name)) 
[08:27:41.713]                             next
[08:27:41.713]                           if (!grepl(pattern, name)) 
[08:27:41.713]                             next
[08:27:41.713]                           invokeRestart(restart)
[08:27:41.713]                           muffled <- TRUE
[08:27:41.713]                           break
[08:27:41.713]                         }
[08:27:41.713]                       }
[08:27:41.713]                     }
[08:27:41.713]                     invisible(muffled)
[08:27:41.713]                   }
[08:27:41.713]                   muffleCondition(cond)
[08:27:41.713]                 })
[08:27:41.713]             }))
[08:27:41.713]             future::FutureResult(value = ...future.value$value, 
[08:27:41.713]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.713]                   ...future.rng), globalenv = if (FALSE) 
[08:27:41.713]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:41.713]                     ...future.globalenv.names))
[08:27:41.713]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:41.713]         }, condition = base::local({
[08:27:41.713]             c <- base::c
[08:27:41.713]             inherits <- base::inherits
[08:27:41.713]             invokeRestart <- base::invokeRestart
[08:27:41.713]             length <- base::length
[08:27:41.713]             list <- base::list
[08:27:41.713]             seq.int <- base::seq.int
[08:27:41.713]             signalCondition <- base::signalCondition
[08:27:41.713]             sys.calls <- base::sys.calls
[08:27:41.713]             `[[` <- base::`[[`
[08:27:41.713]             `+` <- base::`+`
[08:27:41.713]             `<<-` <- base::`<<-`
[08:27:41.713]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:41.713]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:41.713]                   3L)]
[08:27:41.713]             }
[08:27:41.713]             function(cond) {
[08:27:41.713]                 is_error <- inherits(cond, "error")
[08:27:41.713]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:41.713]                   NULL)
[08:27:41.713]                 if (is_error) {
[08:27:41.713]                   sessionInformation <- function() {
[08:27:41.713]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:41.713]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:41.713]                       search = base::search(), system = base::Sys.info())
[08:27:41.713]                   }
[08:27:41.713]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.713]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:41.713]                     cond$call), session = sessionInformation(), 
[08:27:41.713]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:41.713]                   signalCondition(cond)
[08:27:41.713]                 }
[08:27:41.713]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:41.713]                 "immediateCondition"))) {
[08:27:41.713]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:41.713]                   ...future.conditions[[length(...future.conditions) + 
[08:27:41.713]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:41.713]                   if (TRUE && !signal) {
[08:27:41.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.713]                     {
[08:27:41.713]                       inherits <- base::inherits
[08:27:41.713]                       invokeRestart <- base::invokeRestart
[08:27:41.713]                       is.null <- base::is.null
[08:27:41.713]                       muffled <- FALSE
[08:27:41.713]                       if (inherits(cond, "message")) {
[08:27:41.713]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.713]                         if (muffled) 
[08:27:41.713]                           invokeRestart("muffleMessage")
[08:27:41.713]                       }
[08:27:41.713]                       else if (inherits(cond, "warning")) {
[08:27:41.713]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.713]                         if (muffled) 
[08:27:41.713]                           invokeRestart("muffleWarning")
[08:27:41.713]                       }
[08:27:41.713]                       else if (inherits(cond, "condition")) {
[08:27:41.713]                         if (!is.null(pattern)) {
[08:27:41.713]                           computeRestarts <- base::computeRestarts
[08:27:41.713]                           grepl <- base::grepl
[08:27:41.713]                           restarts <- computeRestarts(cond)
[08:27:41.713]                           for (restart in restarts) {
[08:27:41.713]                             name <- restart$name
[08:27:41.713]                             if (is.null(name)) 
[08:27:41.713]                               next
[08:27:41.713]                             if (!grepl(pattern, name)) 
[08:27:41.713]                               next
[08:27:41.713]                             invokeRestart(restart)
[08:27:41.713]                             muffled <- TRUE
[08:27:41.713]                             break
[08:27:41.713]                           }
[08:27:41.713]                         }
[08:27:41.713]                       }
[08:27:41.713]                       invisible(muffled)
[08:27:41.713]                     }
[08:27:41.713]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.713]                   }
[08:27:41.713]                 }
[08:27:41.713]                 else {
[08:27:41.713]                   if (TRUE) {
[08:27:41.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:41.713]                     {
[08:27:41.713]                       inherits <- base::inherits
[08:27:41.713]                       invokeRestart <- base::invokeRestart
[08:27:41.713]                       is.null <- base::is.null
[08:27:41.713]                       muffled <- FALSE
[08:27:41.713]                       if (inherits(cond, "message")) {
[08:27:41.713]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:41.713]                         if (muffled) 
[08:27:41.713]                           invokeRestart("muffleMessage")
[08:27:41.713]                       }
[08:27:41.713]                       else if (inherits(cond, "warning")) {
[08:27:41.713]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:41.713]                         if (muffled) 
[08:27:41.713]                           invokeRestart("muffleWarning")
[08:27:41.713]                       }
[08:27:41.713]                       else if (inherits(cond, "condition")) {
[08:27:41.713]                         if (!is.null(pattern)) {
[08:27:41.713]                           computeRestarts <- base::computeRestarts
[08:27:41.713]                           grepl <- base::grepl
[08:27:41.713]                           restarts <- computeRestarts(cond)
[08:27:41.713]                           for (restart in restarts) {
[08:27:41.713]                             name <- restart$name
[08:27:41.713]                             if (is.null(name)) 
[08:27:41.713]                               next
[08:27:41.713]                             if (!grepl(pattern, name)) 
[08:27:41.713]                               next
[08:27:41.713]                             invokeRestart(restart)
[08:27:41.713]                             muffled <- TRUE
[08:27:41.713]                             break
[08:27:41.713]                           }
[08:27:41.713]                         }
[08:27:41.713]                       }
[08:27:41.713]                       invisible(muffled)
[08:27:41.713]                     }
[08:27:41.713]                     muffleCondition(cond, pattern = "^muffle")
[08:27:41.713]                   }
[08:27:41.713]                 }
[08:27:41.713]             }
[08:27:41.713]         }))
[08:27:41.713]     }, error = function(ex) {
[08:27:41.713]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:41.713]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:41.713]                 ...future.rng), started = ...future.startTime, 
[08:27:41.713]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:41.713]             version = "1.8"), class = "FutureResult")
[08:27:41.713]     }, finally = {
[08:27:41.713]         if (!identical(...future.workdir, getwd())) 
[08:27:41.713]             setwd(...future.workdir)
[08:27:41.713]         {
[08:27:41.713]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:41.713]                 ...future.oldOptions$nwarnings <- NULL
[08:27:41.713]             }
[08:27:41.713]             base::options(...future.oldOptions)
[08:27:41.713]             if (.Platform$OS.type == "windows") {
[08:27:41.713]                 old_names <- names(...future.oldEnvVars)
[08:27:41.713]                 envs <- base::Sys.getenv()
[08:27:41.713]                 names <- names(envs)
[08:27:41.713]                 common <- intersect(names, old_names)
[08:27:41.713]                 added <- setdiff(names, old_names)
[08:27:41.713]                 removed <- setdiff(old_names, names)
[08:27:41.713]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:41.713]                   envs[common]]
[08:27:41.713]                 NAMES <- toupper(changed)
[08:27:41.713]                 args <- list()
[08:27:41.713]                 for (kk in seq_along(NAMES)) {
[08:27:41.713]                   name <- changed[[kk]]
[08:27:41.713]                   NAME <- NAMES[[kk]]
[08:27:41.713]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.713]                     next
[08:27:41.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.713]                 }
[08:27:41.713]                 NAMES <- toupper(added)
[08:27:41.713]                 for (kk in seq_along(NAMES)) {
[08:27:41.713]                   name <- added[[kk]]
[08:27:41.713]                   NAME <- NAMES[[kk]]
[08:27:41.713]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.713]                     next
[08:27:41.713]                   args[[name]] <- ""
[08:27:41.713]                 }
[08:27:41.713]                 NAMES <- toupper(removed)
[08:27:41.713]                 for (kk in seq_along(NAMES)) {
[08:27:41.713]                   name <- removed[[kk]]
[08:27:41.713]                   NAME <- NAMES[[kk]]
[08:27:41.713]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:41.713]                     next
[08:27:41.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:41.713]                 }
[08:27:41.713]                 if (length(args) > 0) 
[08:27:41.713]                   base::do.call(base::Sys.setenv, args = args)
[08:27:41.713]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:41.713]             }
[08:27:41.713]             else {
[08:27:41.713]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:41.713]             }
[08:27:41.713]             {
[08:27:41.713]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:41.713]                   0L) {
[08:27:41.713]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:41.713]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:41.713]                   base::options(opts)
[08:27:41.713]                 }
[08:27:41.713]                 {
[08:27:41.713]                   {
[08:27:41.713]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:41.713]                     NULL
[08:27:41.713]                   }
[08:27:41.713]                   options(future.plan = NULL)
[08:27:41.713]                   if (is.na(NA_character_)) 
[08:27:41.713]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:41.713]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:41.713]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:41.713]                     .init = FALSE)
[08:27:41.713]                 }
[08:27:41.713]             }
[08:27:41.713]         }
[08:27:41.713]     })
[08:27:41.713]     if (TRUE) {
[08:27:41.713]         base::sink(type = "output", split = FALSE)
[08:27:41.713]         if (TRUE) {
[08:27:41.713]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:41.713]         }
[08:27:41.713]         else {
[08:27:41.713]             ...future.result["stdout"] <- base::list(NULL)
[08:27:41.713]         }
[08:27:41.713]         base::close(...future.stdout)
[08:27:41.713]         ...future.stdout <- NULL
[08:27:41.713]     }
[08:27:41.713]     ...future.result$conditions <- ...future.conditions
[08:27:41.713]     ...future.result$finished <- base::Sys.time()
[08:27:41.713]     ...future.result
[08:27:41.713] }
[08:27:41.715] assign_globals() ...
[08:27:41.715] List of 1
[08:27:41.715]  $ a: num 10
[08:27:41.715]  - attr(*, "where")=List of 1
[08:27:41.715]   ..$ a:<environment: R_EmptyEnv> 
[08:27:41.715]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:41.715]  - attr(*, "resolved")= logi FALSE
[08:27:41.715]  - attr(*, "total_size")= num 39
[08:27:41.715]  - attr(*, "already-done")= logi TRUE
[08:27:41.718] - copied ‘a’ to environment
[08:27:41.718] assign_globals() ... done
[08:27:41.719] requestCore(): workers = 2
[08:27:41.721] MulticoreFuture started
[08:27:41.722] - Launch lazy future ... done
[08:27:41.722] run() for ‘MulticoreFuture’ ... done
[08:27:41.722] plan(): Setting new future strategy stack:
[08:27:41.723] result() for MulticoreFuture ...
[08:27:41.722] List of future strategies:
[08:27:41.722] 1. sequential:
[08:27:41.722]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:41.722]    - tweaked: FALSE
[08:27:41.722]    - call: NULL
[08:27:41.723] plan(): nbrOfWorkers() = 1
[08:27:41.726] plan(): Setting new future strategy stack:
[08:27:41.726] List of future strategies:
[08:27:41.726] 1. multicore:
[08:27:41.726]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:41.726]    - tweaked: FALSE
[08:27:41.726]    - call: plan(strategy)
[08:27:41.729] plan(): nbrOfWorkers() = 2
[08:27:41.730] result() for MulticoreFuture ...
[08:27:41.730] result() for MulticoreFuture ... done
[08:27:41.730] result() for MulticoreFuture ... done
[08:27:41.730] result() for MulticoreFuture ...
[08:27:41.731] result() for MulticoreFuture ... done
b = 11
*** %<-% with ‘multicore’ futures ... DONE
*** %<-% with ‘multisession’ futures ...
[08:27:41.731] plan(): Setting new future strategy stack:
[08:27:41.732] List of future strategies:
[08:27:41.732] 1. multisession:
[08:27:41.732]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:27:41.732]    - tweaked: FALSE
[08:27:41.732]    - call: plan(strategy)
[08:27:41.732] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:27:41.732] multisession:
[08:27:41.732] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:27:41.732] - tweaked: FALSE
[08:27:41.732] - call: plan(strategy)
[08:27:41.737] getGlobalsAndPackages() ...
[08:27:41.737] Not searching for globals
[08:27:41.738] - globals: [0] <none>
[08:27:41.738] getGlobalsAndPackages() ... DONE
[08:27:42.241] Packages needed by the future expression (n = 0): <none>
[08:27:42.241] Packages needed by future strategies (n = 0): <none>
[08:27:42.242] {
[08:27:42.242]     {
[08:27:42.242]         {
[08:27:42.242]             ...future.startTime <- base::Sys.time()
[08:27:42.242]             {
[08:27:42.242]                 {
[08:27:42.242]                   {
[08:27:42.242]                     {
[08:27:42.242]                       base::local({
[08:27:42.242]                         has_future <- base::requireNamespace("future", 
[08:27:42.242]                           quietly = TRUE)
[08:27:42.242]                         if (has_future) {
[08:27:42.242]                           ns <- base::getNamespace("future")
[08:27:42.242]                           version <- ns[[".package"]][["version"]]
[08:27:42.242]                           if (is.null(version)) 
[08:27:42.242]                             version <- utils::packageVersion("future")
[08:27:42.242]                         }
[08:27:42.242]                         else {
[08:27:42.242]                           version <- NULL
[08:27:42.242]                         }
[08:27:42.242]                         if (!has_future || version < "1.8.0") {
[08:27:42.242]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:42.242]                             "", base::R.version$version.string), 
[08:27:42.242]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:42.242]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:42.242]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:42.242]                               "release", "version")], collapse = " "), 
[08:27:42.242]                             hostname = base::Sys.info()[["nodename"]])
[08:27:42.242]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:42.242]                             info)
[08:27:42.242]                           info <- base::paste(info, collapse = "; ")
[08:27:42.242]                           if (!has_future) {
[08:27:42.242]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:42.242]                               info)
[08:27:42.242]                           }
[08:27:42.242]                           else {
[08:27:42.242]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:42.242]                               info, version)
[08:27:42.242]                           }
[08:27:42.242]                           base::stop(msg)
[08:27:42.242]                         }
[08:27:42.242]                       })
[08:27:42.242]                     }
[08:27:42.242]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:42.242]                     base::options(mc.cores = 1L)
[08:27:42.242]                   }
[08:27:42.242]                   ...future.strategy.old <- future::plan("list")
[08:27:42.242]                   options(future.plan = NULL)
[08:27:42.242]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:42.242]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:42.242]                 }
[08:27:42.242]                 ...future.workdir <- getwd()
[08:27:42.242]             }
[08:27:42.242]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:42.242]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:42.242]         }
[08:27:42.242]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:42.242]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:42.242]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:42.242]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:42.242]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:42.242]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:42.242]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:42.242]             base::names(...future.oldOptions))
[08:27:42.242]     }
[08:27:42.242]     if (FALSE) {
[08:27:42.242]     }
[08:27:42.242]     else {
[08:27:42.242]         if (TRUE) {
[08:27:42.242]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:42.242]                 open = "w")
[08:27:42.242]         }
[08:27:42.242]         else {
[08:27:42.242]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:42.242]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:42.242]         }
[08:27:42.242]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:42.242]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:42.242]             base::sink(type = "output", split = FALSE)
[08:27:42.242]             base::close(...future.stdout)
[08:27:42.242]         }, add = TRUE)
[08:27:42.242]     }
[08:27:42.242]     ...future.frame <- base::sys.nframe()
[08:27:42.242]     ...future.conditions <- base::list()
[08:27:42.242]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:42.242]     if (FALSE) {
[08:27:42.242]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:42.242]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:42.242]     }
[08:27:42.242]     ...future.result <- base::tryCatch({
[08:27:42.242]         base::withCallingHandlers({
[08:27:42.242]             ...future.value <- base::withVisible(base::local({
[08:27:42.242]                 ...future.makeSendCondition <- base::local({
[08:27:42.242]                   sendCondition <- NULL
[08:27:42.242]                   function(frame = 1L) {
[08:27:42.242]                     if (is.function(sendCondition)) 
[08:27:42.242]                       return(sendCondition)
[08:27:42.242]                     ns <- getNamespace("parallel")
[08:27:42.242]                     if (exists("sendData", mode = "function", 
[08:27:42.242]                       envir = ns)) {
[08:27:42.242]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:42.242]                         envir = ns)
[08:27:42.242]                       envir <- sys.frame(frame)
[08:27:42.242]                       master <- NULL
[08:27:42.242]                       while (!identical(envir, .GlobalEnv) && 
[08:27:42.242]                         !identical(envir, emptyenv())) {
[08:27:42.242]                         if (exists("master", mode = "list", envir = envir, 
[08:27:42.242]                           inherits = FALSE)) {
[08:27:42.242]                           master <- get("master", mode = "list", 
[08:27:42.242]                             envir = envir, inherits = FALSE)
[08:27:42.242]                           if (inherits(master, c("SOCKnode", 
[08:27:42.242]                             "SOCK0node"))) {
[08:27:42.242]                             sendCondition <<- function(cond) {
[08:27:42.242]                               data <- list(type = "VALUE", value = cond, 
[08:27:42.242]                                 success = TRUE)
[08:27:42.242]                               parallel_sendData(master, data)
[08:27:42.242]                             }
[08:27:42.242]                             return(sendCondition)
[08:27:42.242]                           }
[08:27:42.242]                         }
[08:27:42.242]                         frame <- frame + 1L
[08:27:42.242]                         envir <- sys.frame(frame)
[08:27:42.242]                       }
[08:27:42.242]                     }
[08:27:42.242]                     sendCondition <<- function(cond) NULL
[08:27:42.242]                   }
[08:27:42.242]                 })
[08:27:42.242]                 withCallingHandlers({
[08:27:42.242]                   NA
[08:27:42.242]                 }, immediateCondition = function(cond) {
[08:27:42.242]                   sendCondition <- ...future.makeSendCondition()
[08:27:42.242]                   sendCondition(cond)
[08:27:42.242]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.242]                   {
[08:27:42.242]                     inherits <- base::inherits
[08:27:42.242]                     invokeRestart <- base::invokeRestart
[08:27:42.242]                     is.null <- base::is.null
[08:27:42.242]                     muffled <- FALSE
[08:27:42.242]                     if (inherits(cond, "message")) {
[08:27:42.242]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:42.242]                       if (muffled) 
[08:27:42.242]                         invokeRestart("muffleMessage")
[08:27:42.242]                     }
[08:27:42.242]                     else if (inherits(cond, "warning")) {
[08:27:42.242]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:42.242]                       if (muffled) 
[08:27:42.242]                         invokeRestart("muffleWarning")
[08:27:42.242]                     }
[08:27:42.242]                     else if (inherits(cond, "condition")) {
[08:27:42.242]                       if (!is.null(pattern)) {
[08:27:42.242]                         computeRestarts <- base::computeRestarts
[08:27:42.242]                         grepl <- base::grepl
[08:27:42.242]                         restarts <- computeRestarts(cond)
[08:27:42.242]                         for (restart in restarts) {
[08:27:42.242]                           name <- restart$name
[08:27:42.242]                           if (is.null(name)) 
[08:27:42.242]                             next
[08:27:42.242]                           if (!grepl(pattern, name)) 
[08:27:42.242]                             next
[08:27:42.242]                           invokeRestart(restart)
[08:27:42.242]                           muffled <- TRUE
[08:27:42.242]                           break
[08:27:42.242]                         }
[08:27:42.242]                       }
[08:27:42.242]                     }
[08:27:42.242]                     invisible(muffled)
[08:27:42.242]                   }
[08:27:42.242]                   muffleCondition(cond)
[08:27:42.242]                 })
[08:27:42.242]             }))
[08:27:42.242]             future::FutureResult(value = ...future.value$value, 
[08:27:42.242]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:42.242]                   ...future.rng), globalenv = if (FALSE) 
[08:27:42.242]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:42.242]                     ...future.globalenv.names))
[08:27:42.242]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:42.242]         }, condition = base::local({
[08:27:42.242]             c <- base::c
[08:27:42.242]             inherits <- base::inherits
[08:27:42.242]             invokeRestart <- base::invokeRestart
[08:27:42.242]             length <- base::length
[08:27:42.242]             list <- base::list
[08:27:42.242]             seq.int <- base::seq.int
[08:27:42.242]             signalCondition <- base::signalCondition
[08:27:42.242]             sys.calls <- base::sys.calls
[08:27:42.242]             `[[` <- base::`[[`
[08:27:42.242]             `+` <- base::`+`
[08:27:42.242]             `<<-` <- base::`<<-`
[08:27:42.242]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:42.242]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:42.242]                   3L)]
[08:27:42.242]             }
[08:27:42.242]             function(cond) {
[08:27:42.242]                 is_error <- inherits(cond, "error")
[08:27:42.242]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:42.242]                   NULL)
[08:27:42.242]                 if (is_error) {
[08:27:42.242]                   sessionInformation <- function() {
[08:27:42.242]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:42.242]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:42.242]                       search = base::search(), system = base::Sys.info())
[08:27:42.242]                   }
[08:27:42.242]                   ...future.conditions[[length(...future.conditions) + 
[08:27:42.242]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:42.242]                     cond$call), session = sessionInformation(), 
[08:27:42.242]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:42.242]                   signalCondition(cond)
[08:27:42.242]                 }
[08:27:42.242]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:42.242]                 "immediateCondition"))) {
[08:27:42.242]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:42.242]                   ...future.conditions[[length(...future.conditions) + 
[08:27:42.242]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:42.242]                   if (TRUE && !signal) {
[08:27:42.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.242]                     {
[08:27:42.242]                       inherits <- base::inherits
[08:27:42.242]                       invokeRestart <- base::invokeRestart
[08:27:42.242]                       is.null <- base::is.null
[08:27:42.242]                       muffled <- FALSE
[08:27:42.242]                       if (inherits(cond, "message")) {
[08:27:42.242]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:42.242]                         if (muffled) 
[08:27:42.242]                           invokeRestart("muffleMessage")
[08:27:42.242]                       }
[08:27:42.242]                       else if (inherits(cond, "warning")) {
[08:27:42.242]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:42.242]                         if (muffled) 
[08:27:42.242]                           invokeRestart("muffleWarning")
[08:27:42.242]                       }
[08:27:42.242]                       else if (inherits(cond, "condition")) {
[08:27:42.242]                         if (!is.null(pattern)) {
[08:27:42.242]                           computeRestarts <- base::computeRestarts
[08:27:42.242]                           grepl <- base::grepl
[08:27:42.242]                           restarts <- computeRestarts(cond)
[08:27:42.242]                           for (restart in restarts) {
[08:27:42.242]                             name <- restart$name
[08:27:42.242]                             if (is.null(name)) 
[08:27:42.242]                               next
[08:27:42.242]                             if (!grepl(pattern, name)) 
[08:27:42.242]                               next
[08:27:42.242]                             invokeRestart(restart)
[08:27:42.242]                             muffled <- TRUE
[08:27:42.242]                             break
[08:27:42.242]                           }
[08:27:42.242]                         }
[08:27:42.242]                       }
[08:27:42.242]                       invisible(muffled)
[08:27:42.242]                     }
[08:27:42.242]                     muffleCondition(cond, pattern = "^muffle")
[08:27:42.242]                   }
[08:27:42.242]                 }
[08:27:42.242]                 else {
[08:27:42.242]                   if (TRUE) {
[08:27:42.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.242]                     {
[08:27:42.242]                       inherits <- base::inherits
[08:27:42.242]                       invokeRestart <- base::invokeRestart
[08:27:42.242]                       is.null <- base::is.null
[08:27:42.242]                       muffled <- FALSE
[08:27:42.242]                       if (inherits(cond, "message")) {
[08:27:42.242]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:42.242]                         if (muffled) 
[08:27:42.242]                           invokeRestart("muffleMessage")
[08:27:42.242]                       }
[08:27:42.242]                       else if (inherits(cond, "warning")) {
[08:27:42.242]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:42.242]                         if (muffled) 
[08:27:42.242]                           invokeRestart("muffleWarning")
[08:27:42.242]                       }
[08:27:42.242]                       else if (inherits(cond, "condition")) {
[08:27:42.242]                         if (!is.null(pattern)) {
[08:27:42.242]                           computeRestarts <- base::computeRestarts
[08:27:42.242]                           grepl <- base::grepl
[08:27:42.242]                           restarts <- computeRestarts(cond)
[08:27:42.242]                           for (restart in restarts) {
[08:27:42.242]                             name <- restart$name
[08:27:42.242]                             if (is.null(name)) 
[08:27:42.242]                               next
[08:27:42.242]                             if (!grepl(pattern, name)) 
[08:27:42.242]                               next
[08:27:42.242]                             invokeRestart(restart)
[08:27:42.242]                             muffled <- TRUE
[08:27:42.242]                             break
[08:27:42.242]                           }
[08:27:42.242]                         }
[08:27:42.242]                       }
[08:27:42.242]                       invisible(muffled)
[08:27:42.242]                     }
[08:27:42.242]                     muffleCondition(cond, pattern = "^muffle")
[08:27:42.242]                   }
[08:27:42.242]                 }
[08:27:42.242]             }
[08:27:42.242]         }))
[08:27:42.242]     }, error = function(ex) {
[08:27:42.242]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:42.242]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:42.242]                 ...future.rng), started = ...future.startTime, 
[08:27:42.242]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:42.242]             version = "1.8"), class = "FutureResult")
[08:27:42.242]     }, finally = {
[08:27:42.242]         if (!identical(...future.workdir, getwd())) 
[08:27:42.242]             setwd(...future.workdir)
[08:27:42.242]         {
[08:27:42.242]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:42.242]                 ...future.oldOptions$nwarnings <- NULL
[08:27:42.242]             }
[08:27:42.242]             base::options(...future.oldOptions)
[08:27:42.242]             if (.Platform$OS.type == "windows") {
[08:27:42.242]                 old_names <- names(...future.oldEnvVars)
[08:27:42.242]                 envs <- base::Sys.getenv()
[08:27:42.242]                 names <- names(envs)
[08:27:42.242]                 common <- intersect(names, old_names)
[08:27:42.242]                 added <- setdiff(names, old_names)
[08:27:42.242]                 removed <- setdiff(old_names, names)
[08:27:42.242]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:42.242]                   envs[common]]
[08:27:42.242]                 NAMES <- toupper(changed)
[08:27:42.242]                 args <- list()
[08:27:42.242]                 for (kk in seq_along(NAMES)) {
[08:27:42.242]                   name <- changed[[kk]]
[08:27:42.242]                   NAME <- NAMES[[kk]]
[08:27:42.242]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.242]                     next
[08:27:42.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:42.242]                 }
[08:27:42.242]                 NAMES <- toupper(added)
[08:27:42.242]                 for (kk in seq_along(NAMES)) {
[08:27:42.242]                   name <- added[[kk]]
[08:27:42.242]                   NAME <- NAMES[[kk]]
[08:27:42.242]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.242]                     next
[08:27:42.242]                   args[[name]] <- ""
[08:27:42.242]                 }
[08:27:42.242]                 NAMES <- toupper(removed)
[08:27:42.242]                 for (kk in seq_along(NAMES)) {
[08:27:42.242]                   name <- removed[[kk]]
[08:27:42.242]                   NAME <- NAMES[[kk]]
[08:27:42.242]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.242]                     next
[08:27:42.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:42.242]                 }
[08:27:42.242]                 if (length(args) > 0) 
[08:27:42.242]                   base::do.call(base::Sys.setenv, args = args)
[08:27:42.242]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:42.242]             }
[08:27:42.242]             else {
[08:27:42.242]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:42.242]             }
[08:27:42.242]             {
[08:27:42.242]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:42.242]                   0L) {
[08:27:42.242]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:42.242]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:42.242]                   base::options(opts)
[08:27:42.242]                 }
[08:27:42.242]                 {
[08:27:42.242]                   {
[08:27:42.242]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:42.242]                     NULL
[08:27:42.242]                   }
[08:27:42.242]                   options(future.plan = NULL)
[08:27:42.242]                   if (is.na(NA_character_)) 
[08:27:42.242]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:42.242]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:42.242]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:42.242]                     .init = FALSE)
[08:27:42.242]                 }
[08:27:42.242]             }
[08:27:42.242]         }
[08:27:42.242]     })
[08:27:42.242]     if (TRUE) {
[08:27:42.242]         base::sink(type = "output", split = FALSE)
[08:27:42.242]         if (TRUE) {
[08:27:42.242]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:42.242]         }
[08:27:42.242]         else {
[08:27:42.242]             ...future.result["stdout"] <- base::list(NULL)
[08:27:42.242]         }
[08:27:42.242]         base::close(...future.stdout)
[08:27:42.242]         ...future.stdout <- NULL
[08:27:42.242]     }
[08:27:42.242]     ...future.result$conditions <- ...future.conditions
[08:27:42.242]     ...future.result$finished <- base::Sys.time()
[08:27:42.242]     ...future.result
[08:27:42.242] }
[08:27:42.297] MultisessionFuture started
[08:27:42.298] result() for ClusterFuture ...
[08:27:42.298] receiveMessageFromWorker() for ClusterFuture ...
[08:27:42.298] - Validating connection of MultisessionFuture
[08:27:42.330] - received message: FutureResult
[08:27:42.330] - Received FutureResult
[08:27:42.330] - Erased future from FutureRegistry
[08:27:42.330] result() for ClusterFuture ...
[08:27:42.330] - result already collected: FutureResult
[08:27:42.331] result() for ClusterFuture ... done
[08:27:42.331] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:42.331] result() for ClusterFuture ... done
[08:27:42.331] result() for ClusterFuture ...
[08:27:42.331] - result already collected: FutureResult
[08:27:42.331] result() for ClusterFuture ... done
[08:27:42.331] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:27:42.333] plan(): nbrOfWorkers() = 2
** Future evaluation without globals
[08:27:42.333] getGlobalsAndPackages() ...
[08:27:42.333] Searching for globals...
[08:27:42.334] - globals found: [2] ‘{’, ‘<-’
[08:27:42.334] Searching for globals ... DONE
[08:27:42.334] Resolving globals: FALSE
[08:27:42.335] 
[08:27:42.335] 
[08:27:42.335] getGlobalsAndPackages() ... DONE
[08:27:42.335] run() for ‘Future’ ...
[08:27:42.335] - state: ‘created’
[08:27:42.335] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:42.349] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:42.350] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:42.350]   - Field: ‘node’
[08:27:42.350]   - Field: ‘label’
[08:27:42.350]   - Field: ‘local’
[08:27:42.350]   - Field: ‘owner’
[08:27:42.350]   - Field: ‘envir’
[08:27:42.350]   - Field: ‘workers’
[08:27:42.350]   - Field: ‘packages’
[08:27:42.350]   - Field: ‘gc’
[08:27:42.350]   - Field: ‘conditions’
[08:27:42.350]   - Field: ‘persistent’
[08:27:42.351]   - Field: ‘expr’
[08:27:42.351]   - Field: ‘uuid’
[08:27:42.351]   - Field: ‘seed’
[08:27:42.351]   - Field: ‘version’
[08:27:42.351]   - Field: ‘result’
[08:27:42.351]   - Field: ‘asynchronous’
[08:27:42.351]   - Field: ‘calls’
[08:27:42.351]   - Field: ‘globals’
[08:27:42.351]   - Field: ‘stdout’
[08:27:42.351]   - Field: ‘earlySignal’
[08:27:42.351]   - Field: ‘lazy’
[08:27:42.351]   - Field: ‘state’
[08:27:42.352] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:42.352] - Launch lazy future ...
[08:27:42.352] Packages needed by the future expression (n = 0): <none>
[08:27:42.352] Packages needed by future strategies (n = 0): <none>
[08:27:42.353] {
[08:27:42.353]     {
[08:27:42.353]         {
[08:27:42.353]             ...future.startTime <- base::Sys.time()
[08:27:42.353]             {
[08:27:42.353]                 {
[08:27:42.353]                   {
[08:27:42.353]                     {
[08:27:42.353]                       base::local({
[08:27:42.353]                         has_future <- base::requireNamespace("future", 
[08:27:42.353]                           quietly = TRUE)
[08:27:42.353]                         if (has_future) {
[08:27:42.353]                           ns <- base::getNamespace("future")
[08:27:42.353]                           version <- ns[[".package"]][["version"]]
[08:27:42.353]                           if (is.null(version)) 
[08:27:42.353]                             version <- utils::packageVersion("future")
[08:27:42.353]                         }
[08:27:42.353]                         else {
[08:27:42.353]                           version <- NULL
[08:27:42.353]                         }
[08:27:42.353]                         if (!has_future || version < "1.8.0") {
[08:27:42.353]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:42.353]                             "", base::R.version$version.string), 
[08:27:42.353]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:42.353]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:42.353]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:42.353]                               "release", "version")], collapse = " "), 
[08:27:42.353]                             hostname = base::Sys.info()[["nodename"]])
[08:27:42.353]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:42.353]                             info)
[08:27:42.353]                           info <- base::paste(info, collapse = "; ")
[08:27:42.353]                           if (!has_future) {
[08:27:42.353]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:42.353]                               info)
[08:27:42.353]                           }
[08:27:42.353]                           else {
[08:27:42.353]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:42.353]                               info, version)
[08:27:42.353]                           }
[08:27:42.353]                           base::stop(msg)
[08:27:42.353]                         }
[08:27:42.353]                       })
[08:27:42.353]                     }
[08:27:42.353]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:42.353]                     base::options(mc.cores = 1L)
[08:27:42.353]                   }
[08:27:42.353]                   ...future.strategy.old <- future::plan("list")
[08:27:42.353]                   options(future.plan = NULL)
[08:27:42.353]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:42.353]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:42.353]                 }
[08:27:42.353]                 ...future.workdir <- getwd()
[08:27:42.353]             }
[08:27:42.353]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:42.353]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:42.353]         }
[08:27:42.353]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:42.353]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:42.353]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:42.353]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:42.353]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:42.353]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:42.353]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:42.353]             base::names(...future.oldOptions))
[08:27:42.353]     }
[08:27:42.353]     if (FALSE) {
[08:27:42.353]     }
[08:27:42.353]     else {
[08:27:42.353]         if (TRUE) {
[08:27:42.353]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:42.353]                 open = "w")
[08:27:42.353]         }
[08:27:42.353]         else {
[08:27:42.353]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:42.353]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:42.353]         }
[08:27:42.353]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:42.353]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:42.353]             base::sink(type = "output", split = FALSE)
[08:27:42.353]             base::close(...future.stdout)
[08:27:42.353]         }, add = TRUE)
[08:27:42.353]     }
[08:27:42.353]     ...future.frame <- base::sys.nframe()
[08:27:42.353]     ...future.conditions <- base::list()
[08:27:42.353]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:42.353]     if (FALSE) {
[08:27:42.353]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:42.353]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:42.353]     }
[08:27:42.353]     ...future.result <- base::tryCatch({
[08:27:42.353]         base::withCallingHandlers({
[08:27:42.353]             ...future.value <- base::withVisible(base::local({
[08:27:42.353]                 ...future.makeSendCondition <- base::local({
[08:27:42.353]                   sendCondition <- NULL
[08:27:42.353]                   function(frame = 1L) {
[08:27:42.353]                     if (is.function(sendCondition)) 
[08:27:42.353]                       return(sendCondition)
[08:27:42.353]                     ns <- getNamespace("parallel")
[08:27:42.353]                     if (exists("sendData", mode = "function", 
[08:27:42.353]                       envir = ns)) {
[08:27:42.353]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:42.353]                         envir = ns)
[08:27:42.353]                       envir <- sys.frame(frame)
[08:27:42.353]                       master <- NULL
[08:27:42.353]                       while (!identical(envir, .GlobalEnv) && 
[08:27:42.353]                         !identical(envir, emptyenv())) {
[08:27:42.353]                         if (exists("master", mode = "list", envir = envir, 
[08:27:42.353]                           inherits = FALSE)) {
[08:27:42.353]                           master <- get("master", mode = "list", 
[08:27:42.353]                             envir = envir, inherits = FALSE)
[08:27:42.353]                           if (inherits(master, c("SOCKnode", 
[08:27:42.353]                             "SOCK0node"))) {
[08:27:42.353]                             sendCondition <<- function(cond) {
[08:27:42.353]                               data <- list(type = "VALUE", value = cond, 
[08:27:42.353]                                 success = TRUE)
[08:27:42.353]                               parallel_sendData(master, data)
[08:27:42.353]                             }
[08:27:42.353]                             return(sendCondition)
[08:27:42.353]                           }
[08:27:42.353]                         }
[08:27:42.353]                         frame <- frame + 1L
[08:27:42.353]                         envir <- sys.frame(frame)
[08:27:42.353]                       }
[08:27:42.353]                     }
[08:27:42.353]                     sendCondition <<- function(cond) NULL
[08:27:42.353]                   }
[08:27:42.353]                 })
[08:27:42.353]                 withCallingHandlers({
[08:27:42.353]                   {
[08:27:42.353]                     x <- 1
[08:27:42.353]                   }
[08:27:42.353]                 }, immediateCondition = function(cond) {
[08:27:42.353]                   sendCondition <- ...future.makeSendCondition()
[08:27:42.353]                   sendCondition(cond)
[08:27:42.353]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.353]                   {
[08:27:42.353]                     inherits <- base::inherits
[08:27:42.353]                     invokeRestart <- base::invokeRestart
[08:27:42.353]                     is.null <- base::is.null
[08:27:42.353]                     muffled <- FALSE
[08:27:42.353]                     if (inherits(cond, "message")) {
[08:27:42.353]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:42.353]                       if (muffled) 
[08:27:42.353]                         invokeRestart("muffleMessage")
[08:27:42.353]                     }
[08:27:42.353]                     else if (inherits(cond, "warning")) {
[08:27:42.353]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:42.353]                       if (muffled) 
[08:27:42.353]                         invokeRestart("muffleWarning")
[08:27:42.353]                     }
[08:27:42.353]                     else if (inherits(cond, "condition")) {
[08:27:42.353]                       if (!is.null(pattern)) {
[08:27:42.353]                         computeRestarts <- base::computeRestarts
[08:27:42.353]                         grepl <- base::grepl
[08:27:42.353]                         restarts <- computeRestarts(cond)
[08:27:42.353]                         for (restart in restarts) {
[08:27:42.353]                           name <- restart$name
[08:27:42.353]                           if (is.null(name)) 
[08:27:42.353]                             next
[08:27:42.353]                           if (!grepl(pattern, name)) 
[08:27:42.353]                             next
[08:27:42.353]                           invokeRestart(restart)
[08:27:42.353]                           muffled <- TRUE
[08:27:42.353]                           break
[08:27:42.353]                         }
[08:27:42.353]                       }
[08:27:42.353]                     }
[08:27:42.353]                     invisible(muffled)
[08:27:42.353]                   }
[08:27:42.353]                   muffleCondition(cond)
[08:27:42.353]                 })
[08:27:42.353]             }))
[08:27:42.353]             future::FutureResult(value = ...future.value$value, 
[08:27:42.353]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:42.353]                   ...future.rng), globalenv = if (FALSE) 
[08:27:42.353]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:42.353]                     ...future.globalenv.names))
[08:27:42.353]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:42.353]         }, condition = base::local({
[08:27:42.353]             c <- base::c
[08:27:42.353]             inherits <- base::inherits
[08:27:42.353]             invokeRestart <- base::invokeRestart
[08:27:42.353]             length <- base::length
[08:27:42.353]             list <- base::list
[08:27:42.353]             seq.int <- base::seq.int
[08:27:42.353]             signalCondition <- base::signalCondition
[08:27:42.353]             sys.calls <- base::sys.calls
[08:27:42.353]             `[[` <- base::`[[`
[08:27:42.353]             `+` <- base::`+`
[08:27:42.353]             `<<-` <- base::`<<-`
[08:27:42.353]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:42.353]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:42.353]                   3L)]
[08:27:42.353]             }
[08:27:42.353]             function(cond) {
[08:27:42.353]                 is_error <- inherits(cond, "error")
[08:27:42.353]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:42.353]                   NULL)
[08:27:42.353]                 if (is_error) {
[08:27:42.353]                   sessionInformation <- function() {
[08:27:42.353]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:42.353]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:42.353]                       search = base::search(), system = base::Sys.info())
[08:27:42.353]                   }
[08:27:42.353]                   ...future.conditions[[length(...future.conditions) + 
[08:27:42.353]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:42.353]                     cond$call), session = sessionInformation(), 
[08:27:42.353]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:42.353]                   signalCondition(cond)
[08:27:42.353]                 }
[08:27:42.353]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:42.353]                 "immediateCondition"))) {
[08:27:42.353]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:42.353]                   ...future.conditions[[length(...future.conditions) + 
[08:27:42.353]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:42.353]                   if (TRUE && !signal) {
[08:27:42.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.353]                     {
[08:27:42.353]                       inherits <- base::inherits
[08:27:42.353]                       invokeRestart <- base::invokeRestart
[08:27:42.353]                       is.null <- base::is.null
[08:27:42.353]                       muffled <- FALSE
[08:27:42.353]                       if (inherits(cond, "message")) {
[08:27:42.353]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:42.353]                         if (muffled) 
[08:27:42.353]                           invokeRestart("muffleMessage")
[08:27:42.353]                       }
[08:27:42.353]                       else if (inherits(cond, "warning")) {
[08:27:42.353]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:42.353]                         if (muffled) 
[08:27:42.353]                           invokeRestart("muffleWarning")
[08:27:42.353]                       }
[08:27:42.353]                       else if (inherits(cond, "condition")) {
[08:27:42.353]                         if (!is.null(pattern)) {
[08:27:42.353]                           computeRestarts <- base::computeRestarts
[08:27:42.353]                           grepl <- base::grepl
[08:27:42.353]                           restarts <- computeRestarts(cond)
[08:27:42.353]                           for (restart in restarts) {
[08:27:42.353]                             name <- restart$name
[08:27:42.353]                             if (is.null(name)) 
[08:27:42.353]                               next
[08:27:42.353]                             if (!grepl(pattern, name)) 
[08:27:42.353]                               next
[08:27:42.353]                             invokeRestart(restart)
[08:27:42.353]                             muffled <- TRUE
[08:27:42.353]                             break
[08:27:42.353]                           }
[08:27:42.353]                         }
[08:27:42.353]                       }
[08:27:42.353]                       invisible(muffled)
[08:27:42.353]                     }
[08:27:42.353]                     muffleCondition(cond, pattern = "^muffle")
[08:27:42.353]                   }
[08:27:42.353]                 }
[08:27:42.353]                 else {
[08:27:42.353]                   if (TRUE) {
[08:27:42.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.353]                     {
[08:27:42.353]                       inherits <- base::inherits
[08:27:42.353]                       invokeRestart <- base::invokeRestart
[08:27:42.353]                       is.null <- base::is.null
[08:27:42.353]                       muffled <- FALSE
[08:27:42.353]                       if (inherits(cond, "message")) {
[08:27:42.353]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:42.353]                         if (muffled) 
[08:27:42.353]                           invokeRestart("muffleMessage")
[08:27:42.353]                       }
[08:27:42.353]                       else if (inherits(cond, "warning")) {
[08:27:42.353]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:42.353]                         if (muffled) 
[08:27:42.353]                           invokeRestart("muffleWarning")
[08:27:42.353]                       }
[08:27:42.353]                       else if (inherits(cond, "condition")) {
[08:27:42.353]                         if (!is.null(pattern)) {
[08:27:42.353]                           computeRestarts <- base::computeRestarts
[08:27:42.353]                           grepl <- base::grepl
[08:27:42.353]                           restarts <- computeRestarts(cond)
[08:27:42.353]                           for (restart in restarts) {
[08:27:42.353]                             name <- restart$name
[08:27:42.353]                             if (is.null(name)) 
[08:27:42.353]                               next
[08:27:42.353]                             if (!grepl(pattern, name)) 
[08:27:42.353]                               next
[08:27:42.353]                             invokeRestart(restart)
[08:27:42.353]                             muffled <- TRUE
[08:27:42.353]                             break
[08:27:42.353]                           }
[08:27:42.353]                         }
[08:27:42.353]                       }
[08:27:42.353]                       invisible(muffled)
[08:27:42.353]                     }
[08:27:42.353]                     muffleCondition(cond, pattern = "^muffle")
[08:27:42.353]                   }
[08:27:42.353]                 }
[08:27:42.353]             }
[08:27:42.353]         }))
[08:27:42.353]     }, error = function(ex) {
[08:27:42.353]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:42.353]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:42.353]                 ...future.rng), started = ...future.startTime, 
[08:27:42.353]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:42.353]             version = "1.8"), class = "FutureResult")
[08:27:42.353]     }, finally = {
[08:27:42.353]         if (!identical(...future.workdir, getwd())) 
[08:27:42.353]             setwd(...future.workdir)
[08:27:42.353]         {
[08:27:42.353]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:42.353]                 ...future.oldOptions$nwarnings <- NULL
[08:27:42.353]             }
[08:27:42.353]             base::options(...future.oldOptions)
[08:27:42.353]             if (.Platform$OS.type == "windows") {
[08:27:42.353]                 old_names <- names(...future.oldEnvVars)
[08:27:42.353]                 envs <- base::Sys.getenv()
[08:27:42.353]                 names <- names(envs)
[08:27:42.353]                 common <- intersect(names, old_names)
[08:27:42.353]                 added <- setdiff(names, old_names)
[08:27:42.353]                 removed <- setdiff(old_names, names)
[08:27:42.353]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:42.353]                   envs[common]]
[08:27:42.353]                 NAMES <- toupper(changed)
[08:27:42.353]                 args <- list()
[08:27:42.353]                 for (kk in seq_along(NAMES)) {
[08:27:42.353]                   name <- changed[[kk]]
[08:27:42.353]                   NAME <- NAMES[[kk]]
[08:27:42.353]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.353]                     next
[08:27:42.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:42.353]                 }
[08:27:42.353]                 NAMES <- toupper(added)
[08:27:42.353]                 for (kk in seq_along(NAMES)) {
[08:27:42.353]                   name <- added[[kk]]
[08:27:42.353]                   NAME <- NAMES[[kk]]
[08:27:42.353]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.353]                     next
[08:27:42.353]                   args[[name]] <- ""
[08:27:42.353]                 }
[08:27:42.353]                 NAMES <- toupper(removed)
[08:27:42.353]                 for (kk in seq_along(NAMES)) {
[08:27:42.353]                   name <- removed[[kk]]
[08:27:42.353]                   NAME <- NAMES[[kk]]
[08:27:42.353]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.353]                     next
[08:27:42.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:42.353]                 }
[08:27:42.353]                 if (length(args) > 0) 
[08:27:42.353]                   base::do.call(base::Sys.setenv, args = args)
[08:27:42.353]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:42.353]             }
[08:27:42.353]             else {
[08:27:42.353]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:42.353]             }
[08:27:42.353]             {
[08:27:42.353]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:42.353]                   0L) {
[08:27:42.353]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:42.353]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:42.353]                   base::options(opts)
[08:27:42.353]                 }
[08:27:42.353]                 {
[08:27:42.353]                   {
[08:27:42.353]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:42.353]                     NULL
[08:27:42.353]                   }
[08:27:42.353]                   options(future.plan = NULL)
[08:27:42.353]                   if (is.na(NA_character_)) 
[08:27:42.353]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:42.353]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:42.353]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:42.353]                     .init = FALSE)
[08:27:42.353]                 }
[08:27:42.353]             }
[08:27:42.353]         }
[08:27:42.353]     })
[08:27:42.353]     if (TRUE) {
[08:27:42.353]         base::sink(type = "output", split = FALSE)
[08:27:42.353]         if (TRUE) {
[08:27:42.353]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:42.353]         }
[08:27:42.353]         else {
[08:27:42.353]             ...future.result["stdout"] <- base::list(NULL)
[08:27:42.353]         }
[08:27:42.353]         base::close(...future.stdout)
[08:27:42.353]         ...future.stdout <- NULL
[08:27:42.353]     }
[08:27:42.353]     ...future.result$conditions <- ...future.conditions
[08:27:42.353]     ...future.result$finished <- base::Sys.time()
[08:27:42.353]     ...future.result
[08:27:42.353] }
[08:27:42.356] MultisessionFuture started
[08:27:42.356] - Launch lazy future ... done
[08:27:42.356] run() for ‘MultisessionFuture’ ... done
[08:27:42.356] result() for ClusterFuture ...
[08:27:42.356] receiveMessageFromWorker() for ClusterFuture ...
[08:27:42.356] - Validating connection of MultisessionFuture
[08:27:42.398] - received message: FutureResult
[08:27:42.399] - Received FutureResult
[08:27:42.399] - Erased future from FutureRegistry
[08:27:42.399] result() for ClusterFuture ...
[08:27:42.399] - result already collected: FutureResult
[08:27:42.399] result() for ClusterFuture ... done
[08:27:42.399] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:42.399] result() for ClusterFuture ... done
[08:27:42.399] result() for ClusterFuture ...
[08:27:42.400] - result already collected: FutureResult
[08:27:42.400] result() for ClusterFuture ... done
** Future evaluation with globals
[08:27:42.400] getGlobalsAndPackages() ...
[08:27:42.400] Searching for globals...
[08:27:42.401] - globals found: [3] ‘{’, ‘<-’, ‘a’
[08:27:42.401] Searching for globals ... DONE
[08:27:42.402] Resolving globals: FALSE
[08:27:42.402] The total size of the 1 globals is 39 bytes (39 bytes)
[08:27:42.402] The total size of the 1 globals exported for future expression (‘{; x <- a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[08:27:42.402] - globals: [1] ‘a’
[08:27:42.403] 
[08:27:42.403] getGlobalsAndPackages() ... DONE
[08:27:42.403] run() for ‘Future’ ...
[08:27:42.403] - state: ‘created’
[08:27:42.403] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:42.419] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:42.419] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:42.419]   - Field: ‘node’
[08:27:42.419]   - Field: ‘label’
[08:27:42.419]   - Field: ‘local’
[08:27:42.419]   - Field: ‘owner’
[08:27:42.420]   - Field: ‘envir’
[08:27:42.420]   - Field: ‘workers’
[08:27:42.420]   - Field: ‘packages’
[08:27:42.420]   - Field: ‘gc’
[08:27:42.420]   - Field: ‘conditions’
[08:27:42.420]   - Field: ‘persistent’
[08:27:42.420]   - Field: ‘expr’
[08:27:42.420]   - Field: ‘uuid’
[08:27:42.420]   - Field: ‘seed’
[08:27:42.420]   - Field: ‘version’
[08:27:42.421]   - Field: ‘result’
[08:27:42.421]   - Field: ‘asynchronous’
[08:27:42.421]   - Field: ‘calls’
[08:27:42.421]   - Field: ‘globals’
[08:27:42.421]   - Field: ‘stdout’
[08:27:42.421]   - Field: ‘earlySignal’
[08:27:42.421]   - Field: ‘lazy’
[08:27:42.421]   - Field: ‘state’
[08:27:42.421] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:42.422] - Launch lazy future ...
[08:27:42.422] Packages needed by the future expression (n = 0): <none>
[08:27:42.422] Packages needed by future strategies (n = 0): <none>
[08:27:42.423] {
[08:27:42.423]     {
[08:27:42.423]         {
[08:27:42.423]             ...future.startTime <- base::Sys.time()
[08:27:42.423]             {
[08:27:42.423]                 {
[08:27:42.423]                   {
[08:27:42.423]                     {
[08:27:42.423]                       base::local({
[08:27:42.423]                         has_future <- base::requireNamespace("future", 
[08:27:42.423]                           quietly = TRUE)
[08:27:42.423]                         if (has_future) {
[08:27:42.423]                           ns <- base::getNamespace("future")
[08:27:42.423]                           version <- ns[[".package"]][["version"]]
[08:27:42.423]                           if (is.null(version)) 
[08:27:42.423]                             version <- utils::packageVersion("future")
[08:27:42.423]                         }
[08:27:42.423]                         else {
[08:27:42.423]                           version <- NULL
[08:27:42.423]                         }
[08:27:42.423]                         if (!has_future || version < "1.8.0") {
[08:27:42.423]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:42.423]                             "", base::R.version$version.string), 
[08:27:42.423]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:42.423]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:42.423]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:42.423]                               "release", "version")], collapse = " "), 
[08:27:42.423]                             hostname = base::Sys.info()[["nodename"]])
[08:27:42.423]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:42.423]                             info)
[08:27:42.423]                           info <- base::paste(info, collapse = "; ")
[08:27:42.423]                           if (!has_future) {
[08:27:42.423]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:42.423]                               info)
[08:27:42.423]                           }
[08:27:42.423]                           else {
[08:27:42.423]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:42.423]                               info, version)
[08:27:42.423]                           }
[08:27:42.423]                           base::stop(msg)
[08:27:42.423]                         }
[08:27:42.423]                       })
[08:27:42.423]                     }
[08:27:42.423]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:42.423]                     base::options(mc.cores = 1L)
[08:27:42.423]                   }
[08:27:42.423]                   ...future.strategy.old <- future::plan("list")
[08:27:42.423]                   options(future.plan = NULL)
[08:27:42.423]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:42.423]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:42.423]                 }
[08:27:42.423]                 ...future.workdir <- getwd()
[08:27:42.423]             }
[08:27:42.423]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:42.423]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:42.423]         }
[08:27:42.423]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:42.423]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:42.423]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:42.423]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:42.423]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:42.423]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:42.423]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:42.423]             base::names(...future.oldOptions))
[08:27:42.423]     }
[08:27:42.423]     if (FALSE) {
[08:27:42.423]     }
[08:27:42.423]     else {
[08:27:42.423]         if (TRUE) {
[08:27:42.423]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:42.423]                 open = "w")
[08:27:42.423]         }
[08:27:42.423]         else {
[08:27:42.423]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:42.423]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:42.423]         }
[08:27:42.423]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:42.423]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:42.423]             base::sink(type = "output", split = FALSE)
[08:27:42.423]             base::close(...future.stdout)
[08:27:42.423]         }, add = TRUE)
[08:27:42.423]     }
[08:27:42.423]     ...future.frame <- base::sys.nframe()
[08:27:42.423]     ...future.conditions <- base::list()
[08:27:42.423]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:42.423]     if (FALSE) {
[08:27:42.423]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:42.423]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:42.423]     }
[08:27:42.423]     ...future.result <- base::tryCatch({
[08:27:42.423]         base::withCallingHandlers({
[08:27:42.423]             ...future.value <- base::withVisible(base::local({
[08:27:42.423]                 ...future.makeSendCondition <- base::local({
[08:27:42.423]                   sendCondition <- NULL
[08:27:42.423]                   function(frame = 1L) {
[08:27:42.423]                     if (is.function(sendCondition)) 
[08:27:42.423]                       return(sendCondition)
[08:27:42.423]                     ns <- getNamespace("parallel")
[08:27:42.423]                     if (exists("sendData", mode = "function", 
[08:27:42.423]                       envir = ns)) {
[08:27:42.423]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:42.423]                         envir = ns)
[08:27:42.423]                       envir <- sys.frame(frame)
[08:27:42.423]                       master <- NULL
[08:27:42.423]                       while (!identical(envir, .GlobalEnv) && 
[08:27:42.423]                         !identical(envir, emptyenv())) {
[08:27:42.423]                         if (exists("master", mode = "list", envir = envir, 
[08:27:42.423]                           inherits = FALSE)) {
[08:27:42.423]                           master <- get("master", mode = "list", 
[08:27:42.423]                             envir = envir, inherits = FALSE)
[08:27:42.423]                           if (inherits(master, c("SOCKnode", 
[08:27:42.423]                             "SOCK0node"))) {
[08:27:42.423]                             sendCondition <<- function(cond) {
[08:27:42.423]                               data <- list(type = "VALUE", value = cond, 
[08:27:42.423]                                 success = TRUE)
[08:27:42.423]                               parallel_sendData(master, data)
[08:27:42.423]                             }
[08:27:42.423]                             return(sendCondition)
[08:27:42.423]                           }
[08:27:42.423]                         }
[08:27:42.423]                         frame <- frame + 1L
[08:27:42.423]                         envir <- sys.frame(frame)
[08:27:42.423]                       }
[08:27:42.423]                     }
[08:27:42.423]                     sendCondition <<- function(cond) NULL
[08:27:42.423]                   }
[08:27:42.423]                 })
[08:27:42.423]                 withCallingHandlers({
[08:27:42.423]                   {
[08:27:42.423]                     x <- a
[08:27:42.423]                   }
[08:27:42.423]                 }, immediateCondition = function(cond) {
[08:27:42.423]                   sendCondition <- ...future.makeSendCondition()
[08:27:42.423]                   sendCondition(cond)
[08:27:42.423]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.423]                   {
[08:27:42.423]                     inherits <- base::inherits
[08:27:42.423]                     invokeRestart <- base::invokeRestart
[08:27:42.423]                     is.null <- base::is.null
[08:27:42.423]                     muffled <- FALSE
[08:27:42.423]                     if (inherits(cond, "message")) {
[08:27:42.423]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:42.423]                       if (muffled) 
[08:27:42.423]                         invokeRestart("muffleMessage")
[08:27:42.423]                     }
[08:27:42.423]                     else if (inherits(cond, "warning")) {
[08:27:42.423]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:42.423]                       if (muffled) 
[08:27:42.423]                         invokeRestart("muffleWarning")
[08:27:42.423]                     }
[08:27:42.423]                     else if (inherits(cond, "condition")) {
[08:27:42.423]                       if (!is.null(pattern)) {
[08:27:42.423]                         computeRestarts <- base::computeRestarts
[08:27:42.423]                         grepl <- base::grepl
[08:27:42.423]                         restarts <- computeRestarts(cond)
[08:27:42.423]                         for (restart in restarts) {
[08:27:42.423]                           name <- restart$name
[08:27:42.423]                           if (is.null(name)) 
[08:27:42.423]                             next
[08:27:42.423]                           if (!grepl(pattern, name)) 
[08:27:42.423]                             next
[08:27:42.423]                           invokeRestart(restart)
[08:27:42.423]                           muffled <- TRUE
[08:27:42.423]                           break
[08:27:42.423]                         }
[08:27:42.423]                       }
[08:27:42.423]                     }
[08:27:42.423]                     invisible(muffled)
[08:27:42.423]                   }
[08:27:42.423]                   muffleCondition(cond)
[08:27:42.423]                 })
[08:27:42.423]             }))
[08:27:42.423]             future::FutureResult(value = ...future.value$value, 
[08:27:42.423]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:42.423]                   ...future.rng), globalenv = if (FALSE) 
[08:27:42.423]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:42.423]                     ...future.globalenv.names))
[08:27:42.423]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:42.423]         }, condition = base::local({
[08:27:42.423]             c <- base::c
[08:27:42.423]             inherits <- base::inherits
[08:27:42.423]             invokeRestart <- base::invokeRestart
[08:27:42.423]             length <- base::length
[08:27:42.423]             list <- base::list
[08:27:42.423]             seq.int <- base::seq.int
[08:27:42.423]             signalCondition <- base::signalCondition
[08:27:42.423]             sys.calls <- base::sys.calls
[08:27:42.423]             `[[` <- base::`[[`
[08:27:42.423]             `+` <- base::`+`
[08:27:42.423]             `<<-` <- base::`<<-`
[08:27:42.423]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:42.423]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:42.423]                   3L)]
[08:27:42.423]             }
[08:27:42.423]             function(cond) {
[08:27:42.423]                 is_error <- inherits(cond, "error")
[08:27:42.423]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:42.423]                   NULL)
[08:27:42.423]                 if (is_error) {
[08:27:42.423]                   sessionInformation <- function() {
[08:27:42.423]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:42.423]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:42.423]                       search = base::search(), system = base::Sys.info())
[08:27:42.423]                   }
[08:27:42.423]                   ...future.conditions[[length(...future.conditions) + 
[08:27:42.423]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:42.423]                     cond$call), session = sessionInformation(), 
[08:27:42.423]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:42.423]                   signalCondition(cond)
[08:27:42.423]                 }
[08:27:42.423]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:42.423]                 "immediateCondition"))) {
[08:27:42.423]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:42.423]                   ...future.conditions[[length(...future.conditions) + 
[08:27:42.423]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:42.423]                   if (TRUE && !signal) {
[08:27:42.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.423]                     {
[08:27:42.423]                       inherits <- base::inherits
[08:27:42.423]                       invokeRestart <- base::invokeRestart
[08:27:42.423]                       is.null <- base::is.null
[08:27:42.423]                       muffled <- FALSE
[08:27:42.423]                       if (inherits(cond, "message")) {
[08:27:42.423]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:42.423]                         if (muffled) 
[08:27:42.423]                           invokeRestart("muffleMessage")
[08:27:42.423]                       }
[08:27:42.423]                       else if (inherits(cond, "warning")) {
[08:27:42.423]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:42.423]                         if (muffled) 
[08:27:42.423]                           invokeRestart("muffleWarning")
[08:27:42.423]                       }
[08:27:42.423]                       else if (inherits(cond, "condition")) {
[08:27:42.423]                         if (!is.null(pattern)) {
[08:27:42.423]                           computeRestarts <- base::computeRestarts
[08:27:42.423]                           grepl <- base::grepl
[08:27:42.423]                           restarts <- computeRestarts(cond)
[08:27:42.423]                           for (restart in restarts) {
[08:27:42.423]                             name <- restart$name
[08:27:42.423]                             if (is.null(name)) 
[08:27:42.423]                               next
[08:27:42.423]                             if (!grepl(pattern, name)) 
[08:27:42.423]                               next
[08:27:42.423]                             invokeRestart(restart)
[08:27:42.423]                             muffled <- TRUE
[08:27:42.423]                             break
[08:27:42.423]                           }
[08:27:42.423]                         }
[08:27:42.423]                       }
[08:27:42.423]                       invisible(muffled)
[08:27:42.423]                     }
[08:27:42.423]                     muffleCondition(cond, pattern = "^muffle")
[08:27:42.423]                   }
[08:27:42.423]                 }
[08:27:42.423]                 else {
[08:27:42.423]                   if (TRUE) {
[08:27:42.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.423]                     {
[08:27:42.423]                       inherits <- base::inherits
[08:27:42.423]                       invokeRestart <- base::invokeRestart
[08:27:42.423]                       is.null <- base::is.null
[08:27:42.423]                       muffled <- FALSE
[08:27:42.423]                       if (inherits(cond, "message")) {
[08:27:42.423]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:42.423]                         if (muffled) 
[08:27:42.423]                           invokeRestart("muffleMessage")
[08:27:42.423]                       }
[08:27:42.423]                       else if (inherits(cond, "warning")) {
[08:27:42.423]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:42.423]                         if (muffled) 
[08:27:42.423]                           invokeRestart("muffleWarning")
[08:27:42.423]                       }
[08:27:42.423]                       else if (inherits(cond, "condition")) {
[08:27:42.423]                         if (!is.null(pattern)) {
[08:27:42.423]                           computeRestarts <- base::computeRestarts
[08:27:42.423]                           grepl <- base::grepl
[08:27:42.423]                           restarts <- computeRestarts(cond)
[08:27:42.423]                           for (restart in restarts) {
[08:27:42.423]                             name <- restart$name
[08:27:42.423]                             if (is.null(name)) 
[08:27:42.423]                               next
[08:27:42.423]                             if (!grepl(pattern, name)) 
[08:27:42.423]                               next
[08:27:42.423]                             invokeRestart(restart)
[08:27:42.423]                             muffled <- TRUE
[08:27:42.423]                             break
[08:27:42.423]                           }
[08:27:42.423]                         }
[08:27:42.423]                       }
[08:27:42.423]                       invisible(muffled)
[08:27:42.423]                     }
[08:27:42.423]                     muffleCondition(cond, pattern = "^muffle")
[08:27:42.423]                   }
[08:27:42.423]                 }
[08:27:42.423]             }
[08:27:42.423]         }))
[08:27:42.423]     }, error = function(ex) {
[08:27:42.423]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:42.423]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:42.423]                 ...future.rng), started = ...future.startTime, 
[08:27:42.423]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:42.423]             version = "1.8"), class = "FutureResult")
[08:27:42.423]     }, finally = {
[08:27:42.423]         if (!identical(...future.workdir, getwd())) 
[08:27:42.423]             setwd(...future.workdir)
[08:27:42.423]         {
[08:27:42.423]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:42.423]                 ...future.oldOptions$nwarnings <- NULL
[08:27:42.423]             }
[08:27:42.423]             base::options(...future.oldOptions)
[08:27:42.423]             if (.Platform$OS.type == "windows") {
[08:27:42.423]                 old_names <- names(...future.oldEnvVars)
[08:27:42.423]                 envs <- base::Sys.getenv()
[08:27:42.423]                 names <- names(envs)
[08:27:42.423]                 common <- intersect(names, old_names)
[08:27:42.423]                 added <- setdiff(names, old_names)
[08:27:42.423]                 removed <- setdiff(old_names, names)
[08:27:42.423]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:42.423]                   envs[common]]
[08:27:42.423]                 NAMES <- toupper(changed)
[08:27:42.423]                 args <- list()
[08:27:42.423]                 for (kk in seq_along(NAMES)) {
[08:27:42.423]                   name <- changed[[kk]]
[08:27:42.423]                   NAME <- NAMES[[kk]]
[08:27:42.423]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.423]                     next
[08:27:42.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:42.423]                 }
[08:27:42.423]                 NAMES <- toupper(added)
[08:27:42.423]                 for (kk in seq_along(NAMES)) {
[08:27:42.423]                   name <- added[[kk]]
[08:27:42.423]                   NAME <- NAMES[[kk]]
[08:27:42.423]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.423]                     next
[08:27:42.423]                   args[[name]] <- ""
[08:27:42.423]                 }
[08:27:42.423]                 NAMES <- toupper(removed)
[08:27:42.423]                 for (kk in seq_along(NAMES)) {
[08:27:42.423]                   name <- removed[[kk]]
[08:27:42.423]                   NAME <- NAMES[[kk]]
[08:27:42.423]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.423]                     next
[08:27:42.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:42.423]                 }
[08:27:42.423]                 if (length(args) > 0) 
[08:27:42.423]                   base::do.call(base::Sys.setenv, args = args)
[08:27:42.423]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:42.423]             }
[08:27:42.423]             else {
[08:27:42.423]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:42.423]             }
[08:27:42.423]             {
[08:27:42.423]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:42.423]                   0L) {
[08:27:42.423]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:42.423]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:42.423]                   base::options(opts)
[08:27:42.423]                 }
[08:27:42.423]                 {
[08:27:42.423]                   {
[08:27:42.423]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:42.423]                     NULL
[08:27:42.423]                   }
[08:27:42.423]                   options(future.plan = NULL)
[08:27:42.423]                   if (is.na(NA_character_)) 
[08:27:42.423]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:42.423]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:42.423]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:42.423]                     .init = FALSE)
[08:27:42.423]                 }
[08:27:42.423]             }
[08:27:42.423]         }
[08:27:42.423]     })
[08:27:42.423]     if (TRUE) {
[08:27:42.423]         base::sink(type = "output", split = FALSE)
[08:27:42.423]         if (TRUE) {
[08:27:42.423]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:42.423]         }
[08:27:42.423]         else {
[08:27:42.423]             ...future.result["stdout"] <- base::list(NULL)
[08:27:42.423]         }
[08:27:42.423]         base::close(...future.stdout)
[08:27:42.423]         ...future.stdout <- NULL
[08:27:42.423]     }
[08:27:42.423]     ...future.result$conditions <- ...future.conditions
[08:27:42.423]     ...future.result$finished <- base::Sys.time()
[08:27:42.423]     ...future.result
[08:27:42.423] }
[08:27:42.426] Exporting 1 global objects (346 bytes) to cluster node #1 ...
[08:27:42.426] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[08:27:42.430] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[08:27:42.430] Exporting 1 global objects (346 bytes) to cluster node #1 ... DONE
[08:27:42.431] MultisessionFuture started
[08:27:42.431] - Launch lazy future ... done
[08:27:42.431] run() for ‘MultisessionFuture’ ... done
[08:27:42.432] result() for ClusterFuture ...
[08:27:42.432] receiveMessageFromWorker() for ClusterFuture ...
[08:27:42.432] - Validating connection of MultisessionFuture
[08:27:42.474] - received message: FutureResult
[08:27:42.474] - Received FutureResult
[08:27:42.474] - Erased future from FutureRegistry
[08:27:42.474] result() for ClusterFuture ...
[08:27:42.474] - result already collected: FutureResult
[08:27:42.474] result() for ClusterFuture ... done
[08:27:42.475] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:42.475] result() for ClusterFuture ... done
[08:27:42.475] result() for ClusterFuture ...
[08:27:42.475] - result already collected: FutureResult
[08:27:42.475] result() for ClusterFuture ... done
** Future evaluation with errors
[08:27:42.476] getGlobalsAndPackages() ...
[08:27:42.476] Searching for globals...
[08:27:42.478] - globals found: [3] ‘{’, ‘<-’, ‘stop’
[08:27:42.478] Searching for globals ... DONE
[08:27:42.478] Resolving globals: FALSE
[08:27:42.478] 
[08:27:42.478] 
[08:27:42.479] getGlobalsAndPackages() ... DONE
[08:27:42.479] run() for ‘Future’ ...
[08:27:42.479] - state: ‘created’
[08:27:42.479] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:42.494] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:42.494] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:42.494]   - Field: ‘node’
[08:27:42.495]   - Field: ‘label’
[08:27:42.495]   - Field: ‘local’
[08:27:42.495]   - Field: ‘owner’
[08:27:42.495]   - Field: ‘envir’
[08:27:42.495]   - Field: ‘workers’
[08:27:42.495]   - Field: ‘packages’
[08:27:42.495]   - Field: ‘gc’
[08:27:42.495]   - Field: ‘conditions’
[08:27:42.495]   - Field: ‘persistent’
[08:27:42.495]   - Field: ‘expr’
[08:27:42.496]   - Field: ‘uuid’
[08:27:42.496]   - Field: ‘seed’
[08:27:42.496]   - Field: ‘version’
[08:27:42.496]   - Field: ‘result’
[08:27:42.496]   - Field: ‘asynchronous’
[08:27:42.496]   - Field: ‘calls’
[08:27:42.496]   - Field: ‘globals’
[08:27:42.496]   - Field: ‘stdout’
[08:27:42.496]   - Field: ‘earlySignal’
[08:27:42.497]   - Field: ‘lazy’
[08:27:42.497]   - Field: ‘state’
[08:27:42.497] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:42.497] - Launch lazy future ...
[08:27:42.497] Packages needed by the future expression (n = 0): <none>
[08:27:42.497] Packages needed by future strategies (n = 0): <none>
[08:27:42.498] {
[08:27:42.498]     {
[08:27:42.498]         {
[08:27:42.498]             ...future.startTime <- base::Sys.time()
[08:27:42.498]             {
[08:27:42.498]                 {
[08:27:42.498]                   {
[08:27:42.498]                     {
[08:27:42.498]                       base::local({
[08:27:42.498]                         has_future <- base::requireNamespace("future", 
[08:27:42.498]                           quietly = TRUE)
[08:27:42.498]                         if (has_future) {
[08:27:42.498]                           ns <- base::getNamespace("future")
[08:27:42.498]                           version <- ns[[".package"]][["version"]]
[08:27:42.498]                           if (is.null(version)) 
[08:27:42.498]                             version <- utils::packageVersion("future")
[08:27:42.498]                         }
[08:27:42.498]                         else {
[08:27:42.498]                           version <- NULL
[08:27:42.498]                         }
[08:27:42.498]                         if (!has_future || version < "1.8.0") {
[08:27:42.498]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:42.498]                             "", base::R.version$version.string), 
[08:27:42.498]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:42.498]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:42.498]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:42.498]                               "release", "version")], collapse = " "), 
[08:27:42.498]                             hostname = base::Sys.info()[["nodename"]])
[08:27:42.498]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:42.498]                             info)
[08:27:42.498]                           info <- base::paste(info, collapse = "; ")
[08:27:42.498]                           if (!has_future) {
[08:27:42.498]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:42.498]                               info)
[08:27:42.498]                           }
[08:27:42.498]                           else {
[08:27:42.498]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:42.498]                               info, version)
[08:27:42.498]                           }
[08:27:42.498]                           base::stop(msg)
[08:27:42.498]                         }
[08:27:42.498]                       })
[08:27:42.498]                     }
[08:27:42.498]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:42.498]                     base::options(mc.cores = 1L)
[08:27:42.498]                   }
[08:27:42.498]                   ...future.strategy.old <- future::plan("list")
[08:27:42.498]                   options(future.plan = NULL)
[08:27:42.498]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:42.498]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:42.498]                 }
[08:27:42.498]                 ...future.workdir <- getwd()
[08:27:42.498]             }
[08:27:42.498]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:42.498]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:42.498]         }
[08:27:42.498]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:42.498]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:42.498]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:42.498]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:42.498]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:42.498]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:42.498]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:42.498]             base::names(...future.oldOptions))
[08:27:42.498]     }
[08:27:42.498]     if (FALSE) {
[08:27:42.498]     }
[08:27:42.498]     else {
[08:27:42.498]         if (TRUE) {
[08:27:42.498]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:42.498]                 open = "w")
[08:27:42.498]         }
[08:27:42.498]         else {
[08:27:42.498]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:42.498]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:42.498]         }
[08:27:42.498]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:42.498]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:42.498]             base::sink(type = "output", split = FALSE)
[08:27:42.498]             base::close(...future.stdout)
[08:27:42.498]         }, add = TRUE)
[08:27:42.498]     }
[08:27:42.498]     ...future.frame <- base::sys.nframe()
[08:27:42.498]     ...future.conditions <- base::list()
[08:27:42.498]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:42.498]     if (FALSE) {
[08:27:42.498]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:42.498]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:42.498]     }
[08:27:42.498]     ...future.result <- base::tryCatch({
[08:27:42.498]         base::withCallingHandlers({
[08:27:42.498]             ...future.value <- base::withVisible(base::local({
[08:27:42.498]                 ...future.makeSendCondition <- base::local({
[08:27:42.498]                   sendCondition <- NULL
[08:27:42.498]                   function(frame = 1L) {
[08:27:42.498]                     if (is.function(sendCondition)) 
[08:27:42.498]                       return(sendCondition)
[08:27:42.498]                     ns <- getNamespace("parallel")
[08:27:42.498]                     if (exists("sendData", mode = "function", 
[08:27:42.498]                       envir = ns)) {
[08:27:42.498]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:42.498]                         envir = ns)
[08:27:42.498]                       envir <- sys.frame(frame)
[08:27:42.498]                       master <- NULL
[08:27:42.498]                       while (!identical(envir, .GlobalEnv) && 
[08:27:42.498]                         !identical(envir, emptyenv())) {
[08:27:42.498]                         if (exists("master", mode = "list", envir = envir, 
[08:27:42.498]                           inherits = FALSE)) {
[08:27:42.498]                           master <- get("master", mode = "list", 
[08:27:42.498]                             envir = envir, inherits = FALSE)
[08:27:42.498]                           if (inherits(master, c("SOCKnode", 
[08:27:42.498]                             "SOCK0node"))) {
[08:27:42.498]                             sendCondition <<- function(cond) {
[08:27:42.498]                               data <- list(type = "VALUE", value = cond, 
[08:27:42.498]                                 success = TRUE)
[08:27:42.498]                               parallel_sendData(master, data)
[08:27:42.498]                             }
[08:27:42.498]                             return(sendCondition)
[08:27:42.498]                           }
[08:27:42.498]                         }
[08:27:42.498]                         frame <- frame + 1L
[08:27:42.498]                         envir <- sys.frame(frame)
[08:27:42.498]                       }
[08:27:42.498]                     }
[08:27:42.498]                     sendCondition <<- function(cond) NULL
[08:27:42.498]                   }
[08:27:42.498]                 })
[08:27:42.498]                 withCallingHandlers({
[08:27:42.498]                   {
[08:27:42.498]                     x <- 3
[08:27:42.498]                     stop("Woops!")
[08:27:42.498]                     x
[08:27:42.498]                   }
[08:27:42.498]                 }, immediateCondition = function(cond) {
[08:27:42.498]                   sendCondition <- ...future.makeSendCondition()
[08:27:42.498]                   sendCondition(cond)
[08:27:42.498]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.498]                   {
[08:27:42.498]                     inherits <- base::inherits
[08:27:42.498]                     invokeRestart <- base::invokeRestart
[08:27:42.498]                     is.null <- base::is.null
[08:27:42.498]                     muffled <- FALSE
[08:27:42.498]                     if (inherits(cond, "message")) {
[08:27:42.498]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:42.498]                       if (muffled) 
[08:27:42.498]                         invokeRestart("muffleMessage")
[08:27:42.498]                     }
[08:27:42.498]                     else if (inherits(cond, "warning")) {
[08:27:42.498]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:42.498]                       if (muffled) 
[08:27:42.498]                         invokeRestart("muffleWarning")
[08:27:42.498]                     }
[08:27:42.498]                     else if (inherits(cond, "condition")) {
[08:27:42.498]                       if (!is.null(pattern)) {
[08:27:42.498]                         computeRestarts <- base::computeRestarts
[08:27:42.498]                         grepl <- base::grepl
[08:27:42.498]                         restarts <- computeRestarts(cond)
[08:27:42.498]                         for (restart in restarts) {
[08:27:42.498]                           name <- restart$name
[08:27:42.498]                           if (is.null(name)) 
[08:27:42.498]                             next
[08:27:42.498]                           if (!grepl(pattern, name)) 
[08:27:42.498]                             next
[08:27:42.498]                           invokeRestart(restart)
[08:27:42.498]                           muffled <- TRUE
[08:27:42.498]                           break
[08:27:42.498]                         }
[08:27:42.498]                       }
[08:27:42.498]                     }
[08:27:42.498]                     invisible(muffled)
[08:27:42.498]                   }
[08:27:42.498]                   muffleCondition(cond)
[08:27:42.498]                 })
[08:27:42.498]             }))
[08:27:42.498]             future::FutureResult(value = ...future.value$value, 
[08:27:42.498]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:42.498]                   ...future.rng), globalenv = if (FALSE) 
[08:27:42.498]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:42.498]                     ...future.globalenv.names))
[08:27:42.498]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:42.498]         }, condition = base::local({
[08:27:42.498]             c <- base::c
[08:27:42.498]             inherits <- base::inherits
[08:27:42.498]             invokeRestart <- base::invokeRestart
[08:27:42.498]             length <- base::length
[08:27:42.498]             list <- base::list
[08:27:42.498]             seq.int <- base::seq.int
[08:27:42.498]             signalCondition <- base::signalCondition
[08:27:42.498]             sys.calls <- base::sys.calls
[08:27:42.498]             `[[` <- base::`[[`
[08:27:42.498]             `+` <- base::`+`
[08:27:42.498]             `<<-` <- base::`<<-`
[08:27:42.498]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:42.498]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:42.498]                   3L)]
[08:27:42.498]             }
[08:27:42.498]             function(cond) {
[08:27:42.498]                 is_error <- inherits(cond, "error")
[08:27:42.498]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:42.498]                   NULL)
[08:27:42.498]                 if (is_error) {
[08:27:42.498]                   sessionInformation <- function() {
[08:27:42.498]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:42.498]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:42.498]                       search = base::search(), system = base::Sys.info())
[08:27:42.498]                   }
[08:27:42.498]                   ...future.conditions[[length(...future.conditions) + 
[08:27:42.498]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:42.498]                     cond$call), session = sessionInformation(), 
[08:27:42.498]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:42.498]                   signalCondition(cond)
[08:27:42.498]                 }
[08:27:42.498]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:42.498]                 "immediateCondition"))) {
[08:27:42.498]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:42.498]                   ...future.conditions[[length(...future.conditions) + 
[08:27:42.498]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:42.498]                   if (TRUE && !signal) {
[08:27:42.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.498]                     {
[08:27:42.498]                       inherits <- base::inherits
[08:27:42.498]                       invokeRestart <- base::invokeRestart
[08:27:42.498]                       is.null <- base::is.null
[08:27:42.498]                       muffled <- FALSE
[08:27:42.498]                       if (inherits(cond, "message")) {
[08:27:42.498]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:42.498]                         if (muffled) 
[08:27:42.498]                           invokeRestart("muffleMessage")
[08:27:42.498]                       }
[08:27:42.498]                       else if (inherits(cond, "warning")) {
[08:27:42.498]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:42.498]                         if (muffled) 
[08:27:42.498]                           invokeRestart("muffleWarning")
[08:27:42.498]                       }
[08:27:42.498]                       else if (inherits(cond, "condition")) {
[08:27:42.498]                         if (!is.null(pattern)) {
[08:27:42.498]                           computeRestarts <- base::computeRestarts
[08:27:42.498]                           grepl <- base::grepl
[08:27:42.498]                           restarts <- computeRestarts(cond)
[08:27:42.498]                           for (restart in restarts) {
[08:27:42.498]                             name <- restart$name
[08:27:42.498]                             if (is.null(name)) 
[08:27:42.498]                               next
[08:27:42.498]                             if (!grepl(pattern, name)) 
[08:27:42.498]                               next
[08:27:42.498]                             invokeRestart(restart)
[08:27:42.498]                             muffled <- TRUE
[08:27:42.498]                             break
[08:27:42.498]                           }
[08:27:42.498]                         }
[08:27:42.498]                       }
[08:27:42.498]                       invisible(muffled)
[08:27:42.498]                     }
[08:27:42.498]                     muffleCondition(cond, pattern = "^muffle")
[08:27:42.498]                   }
[08:27:42.498]                 }
[08:27:42.498]                 else {
[08:27:42.498]                   if (TRUE) {
[08:27:42.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.498]                     {
[08:27:42.498]                       inherits <- base::inherits
[08:27:42.498]                       invokeRestart <- base::invokeRestart
[08:27:42.498]                       is.null <- base::is.null
[08:27:42.498]                       muffled <- FALSE
[08:27:42.498]                       if (inherits(cond, "message")) {
[08:27:42.498]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:42.498]                         if (muffled) 
[08:27:42.498]                           invokeRestart("muffleMessage")
[08:27:42.498]                       }
[08:27:42.498]                       else if (inherits(cond, "warning")) {
[08:27:42.498]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:42.498]                         if (muffled) 
[08:27:42.498]                           invokeRestart("muffleWarning")
[08:27:42.498]                       }
[08:27:42.498]                       else if (inherits(cond, "condition")) {
[08:27:42.498]                         if (!is.null(pattern)) {
[08:27:42.498]                           computeRestarts <- base::computeRestarts
[08:27:42.498]                           grepl <- base::grepl
[08:27:42.498]                           restarts <- computeRestarts(cond)
[08:27:42.498]                           for (restart in restarts) {
[08:27:42.498]                             name <- restart$name
[08:27:42.498]                             if (is.null(name)) 
[08:27:42.498]                               next
[08:27:42.498]                             if (!grepl(pattern, name)) 
[08:27:42.498]                               next
[08:27:42.498]                             invokeRestart(restart)
[08:27:42.498]                             muffled <- TRUE
[08:27:42.498]                             break
[08:27:42.498]                           }
[08:27:42.498]                         }
[08:27:42.498]                       }
[08:27:42.498]                       invisible(muffled)
[08:27:42.498]                     }
[08:27:42.498]                     muffleCondition(cond, pattern = "^muffle")
[08:27:42.498]                   }
[08:27:42.498]                 }
[08:27:42.498]             }
[08:27:42.498]         }))
[08:27:42.498]     }, error = function(ex) {
[08:27:42.498]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:42.498]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:42.498]                 ...future.rng), started = ...future.startTime, 
[08:27:42.498]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:42.498]             version = "1.8"), class = "FutureResult")
[08:27:42.498]     }, finally = {
[08:27:42.498]         if (!identical(...future.workdir, getwd())) 
[08:27:42.498]             setwd(...future.workdir)
[08:27:42.498]         {
[08:27:42.498]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:42.498]                 ...future.oldOptions$nwarnings <- NULL
[08:27:42.498]             }
[08:27:42.498]             base::options(...future.oldOptions)
[08:27:42.498]             if (.Platform$OS.type == "windows") {
[08:27:42.498]                 old_names <- names(...future.oldEnvVars)
[08:27:42.498]                 envs <- base::Sys.getenv()
[08:27:42.498]                 names <- names(envs)
[08:27:42.498]                 common <- intersect(names, old_names)
[08:27:42.498]                 added <- setdiff(names, old_names)
[08:27:42.498]                 removed <- setdiff(old_names, names)
[08:27:42.498]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:42.498]                   envs[common]]
[08:27:42.498]                 NAMES <- toupper(changed)
[08:27:42.498]                 args <- list()
[08:27:42.498]                 for (kk in seq_along(NAMES)) {
[08:27:42.498]                   name <- changed[[kk]]
[08:27:42.498]                   NAME <- NAMES[[kk]]
[08:27:42.498]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.498]                     next
[08:27:42.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:42.498]                 }
[08:27:42.498]                 NAMES <- toupper(added)
[08:27:42.498]                 for (kk in seq_along(NAMES)) {
[08:27:42.498]                   name <- added[[kk]]
[08:27:42.498]                   NAME <- NAMES[[kk]]
[08:27:42.498]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.498]                     next
[08:27:42.498]                   args[[name]] <- ""
[08:27:42.498]                 }
[08:27:42.498]                 NAMES <- toupper(removed)
[08:27:42.498]                 for (kk in seq_along(NAMES)) {
[08:27:42.498]                   name <- removed[[kk]]
[08:27:42.498]                   NAME <- NAMES[[kk]]
[08:27:42.498]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.498]                     next
[08:27:42.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:42.498]                 }
[08:27:42.498]                 if (length(args) > 0) 
[08:27:42.498]                   base::do.call(base::Sys.setenv, args = args)
[08:27:42.498]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:42.498]             }
[08:27:42.498]             else {
[08:27:42.498]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:42.498]             }
[08:27:42.498]             {
[08:27:42.498]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:42.498]                   0L) {
[08:27:42.498]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:42.498]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:42.498]                   base::options(opts)
[08:27:42.498]                 }
[08:27:42.498]                 {
[08:27:42.498]                   {
[08:27:42.498]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:42.498]                     NULL
[08:27:42.498]                   }
[08:27:42.498]                   options(future.plan = NULL)
[08:27:42.498]                   if (is.na(NA_character_)) 
[08:27:42.498]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:42.498]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:42.498]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:42.498]                     .init = FALSE)
[08:27:42.498]                 }
[08:27:42.498]             }
[08:27:42.498]         }
[08:27:42.498]     })
[08:27:42.498]     if (TRUE) {
[08:27:42.498]         base::sink(type = "output", split = FALSE)
[08:27:42.498]         if (TRUE) {
[08:27:42.498]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:42.498]         }
[08:27:42.498]         else {
[08:27:42.498]             ...future.result["stdout"] <- base::list(NULL)
[08:27:42.498]         }
[08:27:42.498]         base::close(...future.stdout)
[08:27:42.498]         ...future.stdout <- NULL
[08:27:42.498]     }
[08:27:42.498]     ...future.result$conditions <- ...future.conditions
[08:27:42.498]     ...future.result$finished <- base::Sys.time()
[08:27:42.498]     ...future.result
[08:27:42.498] }
[08:27:42.502] MultisessionFuture started
[08:27:42.502] - Launch lazy future ... done
[08:27:42.502] run() for ‘MultisessionFuture’ ... done
[08:27:42.502] result() for ClusterFuture ...
[08:27:42.502] receiveMessageFromWorker() for ClusterFuture ...
[08:27:42.502] - Validating connection of MultisessionFuture
[08:27:42.545] - received message: FutureResult
[08:27:42.546] - Received FutureResult
[08:27:42.546] - Erased future from FutureRegistry
[08:27:42.546] result() for ClusterFuture ...
[08:27:42.546] - result already collected: FutureResult
[08:27:42.546] result() for ClusterFuture ... done
[08:27:42.546] signalConditions() ...
[08:27:42.546]  - include = ‘immediateCondition’
[08:27:42.547]  - exclude = 
[08:27:42.547]  - resignal = FALSE
[08:27:42.547]  - Number of conditions: 1
[08:27:42.547] signalConditions() ... done
[08:27:42.547] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:42.547] result() for ClusterFuture ... done
[08:27:42.547] result() for ClusterFuture ...
[08:27:42.547] - result already collected: FutureResult
[08:27:42.547] result() for ClusterFuture ... done
[08:27:42.548] signalConditions() ...
[08:27:42.548]  - include = ‘immediateCondition’
[08:27:42.548]  - exclude = 
[08:27:42.548]  - resignal = FALSE
[08:27:42.548]  - Number of conditions: 1
[08:27:42.548] signalConditions() ... done
[08:27:42.548] Future state: ‘finished’
[08:27:42.548] result() for ClusterFuture ...
[08:27:42.548] - result already collected: FutureResult
[08:27:42.549] result() for ClusterFuture ... done
[08:27:42.549] signalConditions() ...
[08:27:42.549]  - include = ‘condition’
[08:27:42.549]  - exclude = ‘immediateCondition’
[08:27:42.549]  - resignal = TRUE
[08:27:42.549]  - Number of conditions: 1
[08:27:42.549]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:27:42.549] signalConditions() ... done
[08:27:42.550] getGlobalsAndPackages() ...
[08:27:42.550] Searching for globals...
[08:27:42.552] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[08:27:42.552] Searching for globals ... DONE
[08:27:42.552] Resolving globals: FALSE
[08:27:42.553] The total size of the 1 globals is 35 bytes (35 bytes)
[08:27:42.553] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:27:42.554] - globals: [1] ‘ii’
[08:27:42.554] 
[08:27:42.554] getGlobalsAndPackages() ... DONE
[08:27:42.554] run() for ‘Future’ ...
[08:27:42.554] - state: ‘created’
[08:27:42.554] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:42.570] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:42.570] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:42.570]   - Field: ‘node’
[08:27:42.570]   - Field: ‘label’
[08:27:42.570]   - Field: ‘local’
[08:27:42.570]   - Field: ‘owner’
[08:27:42.570]   - Field: ‘envir’
[08:27:42.570]   - Field: ‘workers’
[08:27:42.570]   - Field: ‘packages’
[08:27:42.571]   - Field: ‘gc’
[08:27:42.571]   - Field: ‘conditions’
[08:27:42.571]   - Field: ‘persistent’
[08:27:42.571]   - Field: ‘expr’
[08:27:42.571]   - Field: ‘uuid’
[08:27:42.571]   - Field: ‘seed’
[08:27:42.571]   - Field: ‘version’
[08:27:42.571]   - Field: ‘result’
[08:27:42.571]   - Field: ‘asynchronous’
[08:27:42.572]   - Field: ‘calls’
[08:27:42.572]   - Field: ‘globals’
[08:27:42.572]   - Field: ‘stdout’
[08:27:42.572]   - Field: ‘earlySignal’
[08:27:42.572]   - Field: ‘lazy’
[08:27:42.572]   - Field: ‘state’
[08:27:42.572] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:42.572] - Launch lazy future ...
[08:27:42.573] Packages needed by the future expression (n = 0): <none>
[08:27:42.573] Packages needed by future strategies (n = 0): <none>
[08:27:42.573] {
[08:27:42.573]     {
[08:27:42.573]         {
[08:27:42.573]             ...future.startTime <- base::Sys.time()
[08:27:42.573]             {
[08:27:42.573]                 {
[08:27:42.573]                   {
[08:27:42.573]                     {
[08:27:42.573]                       base::local({
[08:27:42.573]                         has_future <- base::requireNamespace("future", 
[08:27:42.573]                           quietly = TRUE)
[08:27:42.573]                         if (has_future) {
[08:27:42.573]                           ns <- base::getNamespace("future")
[08:27:42.573]                           version <- ns[[".package"]][["version"]]
[08:27:42.573]                           if (is.null(version)) 
[08:27:42.573]                             version <- utils::packageVersion("future")
[08:27:42.573]                         }
[08:27:42.573]                         else {
[08:27:42.573]                           version <- NULL
[08:27:42.573]                         }
[08:27:42.573]                         if (!has_future || version < "1.8.0") {
[08:27:42.573]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:42.573]                             "", base::R.version$version.string), 
[08:27:42.573]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:42.573]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:42.573]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:42.573]                               "release", "version")], collapse = " "), 
[08:27:42.573]                             hostname = base::Sys.info()[["nodename"]])
[08:27:42.573]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:42.573]                             info)
[08:27:42.573]                           info <- base::paste(info, collapse = "; ")
[08:27:42.573]                           if (!has_future) {
[08:27:42.573]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:42.573]                               info)
[08:27:42.573]                           }
[08:27:42.573]                           else {
[08:27:42.573]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:42.573]                               info, version)
[08:27:42.573]                           }
[08:27:42.573]                           base::stop(msg)
[08:27:42.573]                         }
[08:27:42.573]                       })
[08:27:42.573]                     }
[08:27:42.573]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:42.573]                     base::options(mc.cores = 1L)
[08:27:42.573]                   }
[08:27:42.573]                   ...future.strategy.old <- future::plan("list")
[08:27:42.573]                   options(future.plan = NULL)
[08:27:42.573]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:42.573]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:42.573]                 }
[08:27:42.573]                 ...future.workdir <- getwd()
[08:27:42.573]             }
[08:27:42.573]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:42.573]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:42.573]         }
[08:27:42.573]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:42.573]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:42.573]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:42.573]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:42.573]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:42.573]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:42.573]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:42.573]             base::names(...future.oldOptions))
[08:27:42.573]     }
[08:27:42.573]     if (FALSE) {
[08:27:42.573]     }
[08:27:42.573]     else {
[08:27:42.573]         if (TRUE) {
[08:27:42.573]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:42.573]                 open = "w")
[08:27:42.573]         }
[08:27:42.573]         else {
[08:27:42.573]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:42.573]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:42.573]         }
[08:27:42.573]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:42.573]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:42.573]             base::sink(type = "output", split = FALSE)
[08:27:42.573]             base::close(...future.stdout)
[08:27:42.573]         }, add = TRUE)
[08:27:42.573]     }
[08:27:42.573]     ...future.frame <- base::sys.nframe()
[08:27:42.573]     ...future.conditions <- base::list()
[08:27:42.573]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:42.573]     if (FALSE) {
[08:27:42.573]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:42.573]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:42.573]     }
[08:27:42.573]     ...future.result <- base::tryCatch({
[08:27:42.573]         base::withCallingHandlers({
[08:27:42.573]             ...future.value <- base::withVisible(base::local({
[08:27:42.573]                 ...future.makeSendCondition <- base::local({
[08:27:42.573]                   sendCondition <- NULL
[08:27:42.573]                   function(frame = 1L) {
[08:27:42.573]                     if (is.function(sendCondition)) 
[08:27:42.573]                       return(sendCondition)
[08:27:42.573]                     ns <- getNamespace("parallel")
[08:27:42.573]                     if (exists("sendData", mode = "function", 
[08:27:42.573]                       envir = ns)) {
[08:27:42.573]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:42.573]                         envir = ns)
[08:27:42.573]                       envir <- sys.frame(frame)
[08:27:42.573]                       master <- NULL
[08:27:42.573]                       while (!identical(envir, .GlobalEnv) && 
[08:27:42.573]                         !identical(envir, emptyenv())) {
[08:27:42.573]                         if (exists("master", mode = "list", envir = envir, 
[08:27:42.573]                           inherits = FALSE)) {
[08:27:42.573]                           master <- get("master", mode = "list", 
[08:27:42.573]                             envir = envir, inherits = FALSE)
[08:27:42.573]                           if (inherits(master, c("SOCKnode", 
[08:27:42.573]                             "SOCK0node"))) {
[08:27:42.573]                             sendCondition <<- function(cond) {
[08:27:42.573]                               data <- list(type = "VALUE", value = cond, 
[08:27:42.573]                                 success = TRUE)
[08:27:42.573]                               parallel_sendData(master, data)
[08:27:42.573]                             }
[08:27:42.573]                             return(sendCondition)
[08:27:42.573]                           }
[08:27:42.573]                         }
[08:27:42.573]                         frame <- frame + 1L
[08:27:42.573]                         envir <- sys.frame(frame)
[08:27:42.573]                       }
[08:27:42.573]                     }
[08:27:42.573]                     sendCondition <<- function(cond) NULL
[08:27:42.573]                   }
[08:27:42.573]                 })
[08:27:42.573]                 withCallingHandlers({
[08:27:42.573]                   {
[08:27:42.573]                     if (ii%%2 == 0) 
[08:27:42.573]                       stop("Woops!")
[08:27:42.573]                     ii
[08:27:42.573]                   }
[08:27:42.573]                 }, immediateCondition = function(cond) {
[08:27:42.573]                   sendCondition <- ...future.makeSendCondition()
[08:27:42.573]                   sendCondition(cond)
[08:27:42.573]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.573]                   {
[08:27:42.573]                     inherits <- base::inherits
[08:27:42.573]                     invokeRestart <- base::invokeRestart
[08:27:42.573]                     is.null <- base::is.null
[08:27:42.573]                     muffled <- FALSE
[08:27:42.573]                     if (inherits(cond, "message")) {
[08:27:42.573]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:42.573]                       if (muffled) 
[08:27:42.573]                         invokeRestart("muffleMessage")
[08:27:42.573]                     }
[08:27:42.573]                     else if (inherits(cond, "warning")) {
[08:27:42.573]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:42.573]                       if (muffled) 
[08:27:42.573]                         invokeRestart("muffleWarning")
[08:27:42.573]                     }
[08:27:42.573]                     else if (inherits(cond, "condition")) {
[08:27:42.573]                       if (!is.null(pattern)) {
[08:27:42.573]                         computeRestarts <- base::computeRestarts
[08:27:42.573]                         grepl <- base::grepl
[08:27:42.573]                         restarts <- computeRestarts(cond)
[08:27:42.573]                         for (restart in restarts) {
[08:27:42.573]                           name <- restart$name
[08:27:42.573]                           if (is.null(name)) 
[08:27:42.573]                             next
[08:27:42.573]                           if (!grepl(pattern, name)) 
[08:27:42.573]                             next
[08:27:42.573]                           invokeRestart(restart)
[08:27:42.573]                           muffled <- TRUE
[08:27:42.573]                           break
[08:27:42.573]                         }
[08:27:42.573]                       }
[08:27:42.573]                     }
[08:27:42.573]                     invisible(muffled)
[08:27:42.573]                   }
[08:27:42.573]                   muffleCondition(cond)
[08:27:42.573]                 })
[08:27:42.573]             }))
[08:27:42.573]             future::FutureResult(value = ...future.value$value, 
[08:27:42.573]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:42.573]                   ...future.rng), globalenv = if (FALSE) 
[08:27:42.573]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:42.573]                     ...future.globalenv.names))
[08:27:42.573]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:42.573]         }, condition = base::local({
[08:27:42.573]             c <- base::c
[08:27:42.573]             inherits <- base::inherits
[08:27:42.573]             invokeRestart <- base::invokeRestart
[08:27:42.573]             length <- base::length
[08:27:42.573]             list <- base::list
[08:27:42.573]             seq.int <- base::seq.int
[08:27:42.573]             signalCondition <- base::signalCondition
[08:27:42.573]             sys.calls <- base::sys.calls
[08:27:42.573]             `[[` <- base::`[[`
[08:27:42.573]             `+` <- base::`+`
[08:27:42.573]             `<<-` <- base::`<<-`
[08:27:42.573]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:42.573]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:42.573]                   3L)]
[08:27:42.573]             }
[08:27:42.573]             function(cond) {
[08:27:42.573]                 is_error <- inherits(cond, "error")
[08:27:42.573]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:42.573]                   NULL)
[08:27:42.573]                 if (is_error) {
[08:27:42.573]                   sessionInformation <- function() {
[08:27:42.573]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:42.573]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:42.573]                       search = base::search(), system = base::Sys.info())
[08:27:42.573]                   }
[08:27:42.573]                   ...future.conditions[[length(...future.conditions) + 
[08:27:42.573]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:42.573]                     cond$call), session = sessionInformation(), 
[08:27:42.573]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:42.573]                   signalCondition(cond)
[08:27:42.573]                 }
[08:27:42.573]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:42.573]                 "immediateCondition"))) {
[08:27:42.573]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:42.573]                   ...future.conditions[[length(...future.conditions) + 
[08:27:42.573]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:42.573]                   if (TRUE && !signal) {
[08:27:42.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.573]                     {
[08:27:42.573]                       inherits <- base::inherits
[08:27:42.573]                       invokeRestart <- base::invokeRestart
[08:27:42.573]                       is.null <- base::is.null
[08:27:42.573]                       muffled <- FALSE
[08:27:42.573]                       if (inherits(cond, "message")) {
[08:27:42.573]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:42.573]                         if (muffled) 
[08:27:42.573]                           invokeRestart("muffleMessage")
[08:27:42.573]                       }
[08:27:42.573]                       else if (inherits(cond, "warning")) {
[08:27:42.573]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:42.573]                         if (muffled) 
[08:27:42.573]                           invokeRestart("muffleWarning")
[08:27:42.573]                       }
[08:27:42.573]                       else if (inherits(cond, "condition")) {
[08:27:42.573]                         if (!is.null(pattern)) {
[08:27:42.573]                           computeRestarts <- base::computeRestarts
[08:27:42.573]                           grepl <- base::grepl
[08:27:42.573]                           restarts <- computeRestarts(cond)
[08:27:42.573]                           for (restart in restarts) {
[08:27:42.573]                             name <- restart$name
[08:27:42.573]                             if (is.null(name)) 
[08:27:42.573]                               next
[08:27:42.573]                             if (!grepl(pattern, name)) 
[08:27:42.573]                               next
[08:27:42.573]                             invokeRestart(restart)
[08:27:42.573]                             muffled <- TRUE
[08:27:42.573]                             break
[08:27:42.573]                           }
[08:27:42.573]                         }
[08:27:42.573]                       }
[08:27:42.573]                       invisible(muffled)
[08:27:42.573]                     }
[08:27:42.573]                     muffleCondition(cond, pattern = "^muffle")
[08:27:42.573]                   }
[08:27:42.573]                 }
[08:27:42.573]                 else {
[08:27:42.573]                   if (TRUE) {
[08:27:42.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.573]                     {
[08:27:42.573]                       inherits <- base::inherits
[08:27:42.573]                       invokeRestart <- base::invokeRestart
[08:27:42.573]                       is.null <- base::is.null
[08:27:42.573]                       muffled <- FALSE
[08:27:42.573]                       if (inherits(cond, "message")) {
[08:27:42.573]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:42.573]                         if (muffled) 
[08:27:42.573]                           invokeRestart("muffleMessage")
[08:27:42.573]                       }
[08:27:42.573]                       else if (inherits(cond, "warning")) {
[08:27:42.573]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:42.573]                         if (muffled) 
[08:27:42.573]                           invokeRestart("muffleWarning")
[08:27:42.573]                       }
[08:27:42.573]                       else if (inherits(cond, "condition")) {
[08:27:42.573]                         if (!is.null(pattern)) {
[08:27:42.573]                           computeRestarts <- base::computeRestarts
[08:27:42.573]                           grepl <- base::grepl
[08:27:42.573]                           restarts <- computeRestarts(cond)
[08:27:42.573]                           for (restart in restarts) {
[08:27:42.573]                             name <- restart$name
[08:27:42.573]                             if (is.null(name)) 
[08:27:42.573]                               next
[08:27:42.573]                             if (!grepl(pattern, name)) 
[08:27:42.573]                               next
[08:27:42.573]                             invokeRestart(restart)
[08:27:42.573]                             muffled <- TRUE
[08:27:42.573]                             break
[08:27:42.573]                           }
[08:27:42.573]                         }
[08:27:42.573]                       }
[08:27:42.573]                       invisible(muffled)
[08:27:42.573]                     }
[08:27:42.573]                     muffleCondition(cond, pattern = "^muffle")
[08:27:42.573]                   }
[08:27:42.573]                 }
[08:27:42.573]             }
[08:27:42.573]         }))
[08:27:42.573]     }, error = function(ex) {
[08:27:42.573]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:42.573]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:42.573]                 ...future.rng), started = ...future.startTime, 
[08:27:42.573]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:42.573]             version = "1.8"), class = "FutureResult")
[08:27:42.573]     }, finally = {
[08:27:42.573]         if (!identical(...future.workdir, getwd())) 
[08:27:42.573]             setwd(...future.workdir)
[08:27:42.573]         {
[08:27:42.573]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:42.573]                 ...future.oldOptions$nwarnings <- NULL
[08:27:42.573]             }
[08:27:42.573]             base::options(...future.oldOptions)
[08:27:42.573]             if (.Platform$OS.type == "windows") {
[08:27:42.573]                 old_names <- names(...future.oldEnvVars)
[08:27:42.573]                 envs <- base::Sys.getenv()
[08:27:42.573]                 names <- names(envs)
[08:27:42.573]                 common <- intersect(names, old_names)
[08:27:42.573]                 added <- setdiff(names, old_names)
[08:27:42.573]                 removed <- setdiff(old_names, names)
[08:27:42.573]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:42.573]                   envs[common]]
[08:27:42.573]                 NAMES <- toupper(changed)
[08:27:42.573]                 args <- list()
[08:27:42.573]                 for (kk in seq_along(NAMES)) {
[08:27:42.573]                   name <- changed[[kk]]
[08:27:42.573]                   NAME <- NAMES[[kk]]
[08:27:42.573]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.573]                     next
[08:27:42.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:42.573]                 }
[08:27:42.573]                 NAMES <- toupper(added)
[08:27:42.573]                 for (kk in seq_along(NAMES)) {
[08:27:42.573]                   name <- added[[kk]]
[08:27:42.573]                   NAME <- NAMES[[kk]]
[08:27:42.573]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.573]                     next
[08:27:42.573]                   args[[name]] <- ""
[08:27:42.573]                 }
[08:27:42.573]                 NAMES <- toupper(removed)
[08:27:42.573]                 for (kk in seq_along(NAMES)) {
[08:27:42.573]                   name <- removed[[kk]]
[08:27:42.573]                   NAME <- NAMES[[kk]]
[08:27:42.573]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.573]                     next
[08:27:42.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:42.573]                 }
[08:27:42.573]                 if (length(args) > 0) 
[08:27:42.573]                   base::do.call(base::Sys.setenv, args = args)
[08:27:42.573]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:42.573]             }
[08:27:42.573]             else {
[08:27:42.573]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:42.573]             }
[08:27:42.573]             {
[08:27:42.573]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:42.573]                   0L) {
[08:27:42.573]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:42.573]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:42.573]                   base::options(opts)
[08:27:42.573]                 }
[08:27:42.573]                 {
[08:27:42.573]                   {
[08:27:42.573]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:42.573]                     NULL
[08:27:42.573]                   }
[08:27:42.573]                   options(future.plan = NULL)
[08:27:42.573]                   if (is.na(NA_character_)) 
[08:27:42.573]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:42.573]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:42.573]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:42.573]                     .init = FALSE)
[08:27:42.573]                 }
[08:27:42.573]             }
[08:27:42.573]         }
[08:27:42.573]     })
[08:27:42.573]     if (TRUE) {
[08:27:42.573]         base::sink(type = "output", split = FALSE)
[08:27:42.573]         if (TRUE) {
[08:27:42.573]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:42.573]         }
[08:27:42.573]         else {
[08:27:42.573]             ...future.result["stdout"] <- base::list(NULL)
[08:27:42.573]         }
[08:27:42.573]         base::close(...future.stdout)
[08:27:42.573]         ...future.stdout <- NULL
[08:27:42.573]     }
[08:27:42.573]     ...future.result$conditions <- ...future.conditions
[08:27:42.573]     ...future.result$finished <- base::Sys.time()
[08:27:42.573]     ...future.result
[08:27:42.573] }
[08:27:42.577] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[08:27:42.577] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[08:27:42.577] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[08:27:42.577] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[08:27:42.578] MultisessionFuture started
[08:27:42.578] - Launch lazy future ... done
[08:27:42.578] run() for ‘MultisessionFuture’ ... done
[08:27:42.579] getGlobalsAndPackages() ...
[08:27:42.579] Searching for globals...
[08:27:42.581] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[08:27:42.581] Searching for globals ... DONE
[08:27:42.581] Resolving globals: FALSE
[08:27:42.582] The total size of the 1 globals is 35 bytes (35 bytes)
[08:27:42.582] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:27:42.582] - globals: [1] ‘ii’
[08:27:42.583] 
[08:27:42.583] getGlobalsAndPackages() ... DONE
[08:27:42.583] run() for ‘Future’ ...
[08:27:42.583] - state: ‘created’
[08:27:42.583] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:42.598] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:42.598] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:42.599]   - Field: ‘node’
[08:27:42.599]   - Field: ‘label’
[08:27:42.599]   - Field: ‘local’
[08:27:42.599]   - Field: ‘owner’
[08:27:42.599]   - Field: ‘envir’
[08:27:42.599]   - Field: ‘workers’
[08:27:42.599]   - Field: ‘packages’
[08:27:42.599]   - Field: ‘gc’
[08:27:42.599]   - Field: ‘conditions’
[08:27:42.599]   - Field: ‘persistent’
[08:27:42.600]   - Field: ‘expr’
[08:27:42.600]   - Field: ‘uuid’
[08:27:42.600]   - Field: ‘seed’
[08:27:42.600]   - Field: ‘version’
[08:27:42.600]   - Field: ‘result’
[08:27:42.600]   - Field: ‘asynchronous’
[08:27:42.600]   - Field: ‘calls’
[08:27:42.600]   - Field: ‘globals’
[08:27:42.600]   - Field: ‘stdout’
[08:27:42.601]   - Field: ‘earlySignal’
[08:27:42.601]   - Field: ‘lazy’
[08:27:42.601]   - Field: ‘state’
[08:27:42.601] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:42.601] - Launch lazy future ...
[08:27:42.601] Packages needed by the future expression (n = 0): <none>
[08:27:42.601] Packages needed by future strategies (n = 0): <none>
[08:27:42.602] {
[08:27:42.602]     {
[08:27:42.602]         {
[08:27:42.602]             ...future.startTime <- base::Sys.time()
[08:27:42.602]             {
[08:27:42.602]                 {
[08:27:42.602]                   {
[08:27:42.602]                     {
[08:27:42.602]                       base::local({
[08:27:42.602]                         has_future <- base::requireNamespace("future", 
[08:27:42.602]                           quietly = TRUE)
[08:27:42.602]                         if (has_future) {
[08:27:42.602]                           ns <- base::getNamespace("future")
[08:27:42.602]                           version <- ns[[".package"]][["version"]]
[08:27:42.602]                           if (is.null(version)) 
[08:27:42.602]                             version <- utils::packageVersion("future")
[08:27:42.602]                         }
[08:27:42.602]                         else {
[08:27:42.602]                           version <- NULL
[08:27:42.602]                         }
[08:27:42.602]                         if (!has_future || version < "1.8.0") {
[08:27:42.602]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:42.602]                             "", base::R.version$version.string), 
[08:27:42.602]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:42.602]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:42.602]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:42.602]                               "release", "version")], collapse = " "), 
[08:27:42.602]                             hostname = base::Sys.info()[["nodename"]])
[08:27:42.602]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:42.602]                             info)
[08:27:42.602]                           info <- base::paste(info, collapse = "; ")
[08:27:42.602]                           if (!has_future) {
[08:27:42.602]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:42.602]                               info)
[08:27:42.602]                           }
[08:27:42.602]                           else {
[08:27:42.602]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:42.602]                               info, version)
[08:27:42.602]                           }
[08:27:42.602]                           base::stop(msg)
[08:27:42.602]                         }
[08:27:42.602]                       })
[08:27:42.602]                     }
[08:27:42.602]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:42.602]                     base::options(mc.cores = 1L)
[08:27:42.602]                   }
[08:27:42.602]                   ...future.strategy.old <- future::plan("list")
[08:27:42.602]                   options(future.plan = NULL)
[08:27:42.602]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:42.602]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:42.602]                 }
[08:27:42.602]                 ...future.workdir <- getwd()
[08:27:42.602]             }
[08:27:42.602]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:42.602]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:42.602]         }
[08:27:42.602]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:42.602]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:42.602]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:42.602]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:42.602]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:42.602]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:42.602]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:42.602]             base::names(...future.oldOptions))
[08:27:42.602]     }
[08:27:42.602]     if (FALSE) {
[08:27:42.602]     }
[08:27:42.602]     else {
[08:27:42.602]         if (TRUE) {
[08:27:42.602]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:42.602]                 open = "w")
[08:27:42.602]         }
[08:27:42.602]         else {
[08:27:42.602]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:42.602]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:42.602]         }
[08:27:42.602]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:42.602]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:42.602]             base::sink(type = "output", split = FALSE)
[08:27:42.602]             base::close(...future.stdout)
[08:27:42.602]         }, add = TRUE)
[08:27:42.602]     }
[08:27:42.602]     ...future.frame <- base::sys.nframe()
[08:27:42.602]     ...future.conditions <- base::list()
[08:27:42.602]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:42.602]     if (FALSE) {
[08:27:42.602]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:42.602]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:42.602]     }
[08:27:42.602]     ...future.result <- base::tryCatch({
[08:27:42.602]         base::withCallingHandlers({
[08:27:42.602]             ...future.value <- base::withVisible(base::local({
[08:27:42.602]                 ...future.makeSendCondition <- base::local({
[08:27:42.602]                   sendCondition <- NULL
[08:27:42.602]                   function(frame = 1L) {
[08:27:42.602]                     if (is.function(sendCondition)) 
[08:27:42.602]                       return(sendCondition)
[08:27:42.602]                     ns <- getNamespace("parallel")
[08:27:42.602]                     if (exists("sendData", mode = "function", 
[08:27:42.602]                       envir = ns)) {
[08:27:42.602]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:42.602]                         envir = ns)
[08:27:42.602]                       envir <- sys.frame(frame)
[08:27:42.602]                       master <- NULL
[08:27:42.602]                       while (!identical(envir, .GlobalEnv) && 
[08:27:42.602]                         !identical(envir, emptyenv())) {
[08:27:42.602]                         if (exists("master", mode = "list", envir = envir, 
[08:27:42.602]                           inherits = FALSE)) {
[08:27:42.602]                           master <- get("master", mode = "list", 
[08:27:42.602]                             envir = envir, inherits = FALSE)
[08:27:42.602]                           if (inherits(master, c("SOCKnode", 
[08:27:42.602]                             "SOCK0node"))) {
[08:27:42.602]                             sendCondition <<- function(cond) {
[08:27:42.602]                               data <- list(type = "VALUE", value = cond, 
[08:27:42.602]                                 success = TRUE)
[08:27:42.602]                               parallel_sendData(master, data)
[08:27:42.602]                             }
[08:27:42.602]                             return(sendCondition)
[08:27:42.602]                           }
[08:27:42.602]                         }
[08:27:42.602]                         frame <- frame + 1L
[08:27:42.602]                         envir <- sys.frame(frame)
[08:27:42.602]                       }
[08:27:42.602]                     }
[08:27:42.602]                     sendCondition <<- function(cond) NULL
[08:27:42.602]                   }
[08:27:42.602]                 })
[08:27:42.602]                 withCallingHandlers({
[08:27:42.602]                   {
[08:27:42.602]                     if (ii%%2 == 0) 
[08:27:42.602]                       stop("Woops!")
[08:27:42.602]                     ii
[08:27:42.602]                   }
[08:27:42.602]                 }, immediateCondition = function(cond) {
[08:27:42.602]                   sendCondition <- ...future.makeSendCondition()
[08:27:42.602]                   sendCondition(cond)
[08:27:42.602]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.602]                   {
[08:27:42.602]                     inherits <- base::inherits
[08:27:42.602]                     invokeRestart <- base::invokeRestart
[08:27:42.602]                     is.null <- base::is.null
[08:27:42.602]                     muffled <- FALSE
[08:27:42.602]                     if (inherits(cond, "message")) {
[08:27:42.602]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:42.602]                       if (muffled) 
[08:27:42.602]                         invokeRestart("muffleMessage")
[08:27:42.602]                     }
[08:27:42.602]                     else if (inherits(cond, "warning")) {
[08:27:42.602]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:42.602]                       if (muffled) 
[08:27:42.602]                         invokeRestart("muffleWarning")
[08:27:42.602]                     }
[08:27:42.602]                     else if (inherits(cond, "condition")) {
[08:27:42.602]                       if (!is.null(pattern)) {
[08:27:42.602]                         computeRestarts <- base::computeRestarts
[08:27:42.602]                         grepl <- base::grepl
[08:27:42.602]                         restarts <- computeRestarts(cond)
[08:27:42.602]                         for (restart in restarts) {
[08:27:42.602]                           name <- restart$name
[08:27:42.602]                           if (is.null(name)) 
[08:27:42.602]                             next
[08:27:42.602]                           if (!grepl(pattern, name)) 
[08:27:42.602]                             next
[08:27:42.602]                           invokeRestart(restart)
[08:27:42.602]                           muffled <- TRUE
[08:27:42.602]                           break
[08:27:42.602]                         }
[08:27:42.602]                       }
[08:27:42.602]                     }
[08:27:42.602]                     invisible(muffled)
[08:27:42.602]                   }
[08:27:42.602]                   muffleCondition(cond)
[08:27:42.602]                 })
[08:27:42.602]             }))
[08:27:42.602]             future::FutureResult(value = ...future.value$value, 
[08:27:42.602]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:42.602]                   ...future.rng), globalenv = if (FALSE) 
[08:27:42.602]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:42.602]                     ...future.globalenv.names))
[08:27:42.602]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:42.602]         }, condition = base::local({
[08:27:42.602]             c <- base::c
[08:27:42.602]             inherits <- base::inherits
[08:27:42.602]             invokeRestart <- base::invokeRestart
[08:27:42.602]             length <- base::length
[08:27:42.602]             list <- base::list
[08:27:42.602]             seq.int <- base::seq.int
[08:27:42.602]             signalCondition <- base::signalCondition
[08:27:42.602]             sys.calls <- base::sys.calls
[08:27:42.602]             `[[` <- base::`[[`
[08:27:42.602]             `+` <- base::`+`
[08:27:42.602]             `<<-` <- base::`<<-`
[08:27:42.602]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:42.602]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:42.602]                   3L)]
[08:27:42.602]             }
[08:27:42.602]             function(cond) {
[08:27:42.602]                 is_error <- inherits(cond, "error")
[08:27:42.602]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:42.602]                   NULL)
[08:27:42.602]                 if (is_error) {
[08:27:42.602]                   sessionInformation <- function() {
[08:27:42.602]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:42.602]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:42.602]                       search = base::search(), system = base::Sys.info())
[08:27:42.602]                   }
[08:27:42.602]                   ...future.conditions[[length(...future.conditions) + 
[08:27:42.602]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:42.602]                     cond$call), session = sessionInformation(), 
[08:27:42.602]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:42.602]                   signalCondition(cond)
[08:27:42.602]                 }
[08:27:42.602]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:42.602]                 "immediateCondition"))) {
[08:27:42.602]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:42.602]                   ...future.conditions[[length(...future.conditions) + 
[08:27:42.602]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:42.602]                   if (TRUE && !signal) {
[08:27:42.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.602]                     {
[08:27:42.602]                       inherits <- base::inherits
[08:27:42.602]                       invokeRestart <- base::invokeRestart
[08:27:42.602]                       is.null <- base::is.null
[08:27:42.602]                       muffled <- FALSE
[08:27:42.602]                       if (inherits(cond, "message")) {
[08:27:42.602]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:42.602]                         if (muffled) 
[08:27:42.602]                           invokeRestart("muffleMessage")
[08:27:42.602]                       }
[08:27:42.602]                       else if (inherits(cond, "warning")) {
[08:27:42.602]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:42.602]                         if (muffled) 
[08:27:42.602]                           invokeRestart("muffleWarning")
[08:27:42.602]                       }
[08:27:42.602]                       else if (inherits(cond, "condition")) {
[08:27:42.602]                         if (!is.null(pattern)) {
[08:27:42.602]                           computeRestarts <- base::computeRestarts
[08:27:42.602]                           grepl <- base::grepl
[08:27:42.602]                           restarts <- computeRestarts(cond)
[08:27:42.602]                           for (restart in restarts) {
[08:27:42.602]                             name <- restart$name
[08:27:42.602]                             if (is.null(name)) 
[08:27:42.602]                               next
[08:27:42.602]                             if (!grepl(pattern, name)) 
[08:27:42.602]                               next
[08:27:42.602]                             invokeRestart(restart)
[08:27:42.602]                             muffled <- TRUE
[08:27:42.602]                             break
[08:27:42.602]                           }
[08:27:42.602]                         }
[08:27:42.602]                       }
[08:27:42.602]                       invisible(muffled)
[08:27:42.602]                     }
[08:27:42.602]                     muffleCondition(cond, pattern = "^muffle")
[08:27:42.602]                   }
[08:27:42.602]                 }
[08:27:42.602]                 else {
[08:27:42.602]                   if (TRUE) {
[08:27:42.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.602]                     {
[08:27:42.602]                       inherits <- base::inherits
[08:27:42.602]                       invokeRestart <- base::invokeRestart
[08:27:42.602]                       is.null <- base::is.null
[08:27:42.602]                       muffled <- FALSE
[08:27:42.602]                       if (inherits(cond, "message")) {
[08:27:42.602]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:42.602]                         if (muffled) 
[08:27:42.602]                           invokeRestart("muffleMessage")
[08:27:42.602]                       }
[08:27:42.602]                       else if (inherits(cond, "warning")) {
[08:27:42.602]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:42.602]                         if (muffled) 
[08:27:42.602]                           invokeRestart("muffleWarning")
[08:27:42.602]                       }
[08:27:42.602]                       else if (inherits(cond, "condition")) {
[08:27:42.602]                         if (!is.null(pattern)) {
[08:27:42.602]                           computeRestarts <- base::computeRestarts
[08:27:42.602]                           grepl <- base::grepl
[08:27:42.602]                           restarts <- computeRestarts(cond)
[08:27:42.602]                           for (restart in restarts) {
[08:27:42.602]                             name <- restart$name
[08:27:42.602]                             if (is.null(name)) 
[08:27:42.602]                               next
[08:27:42.602]                             if (!grepl(pattern, name)) 
[08:27:42.602]                               next
[08:27:42.602]                             invokeRestart(restart)
[08:27:42.602]                             muffled <- TRUE
[08:27:42.602]                             break
[08:27:42.602]                           }
[08:27:42.602]                         }
[08:27:42.602]                       }
[08:27:42.602]                       invisible(muffled)
[08:27:42.602]                     }
[08:27:42.602]                     muffleCondition(cond, pattern = "^muffle")
[08:27:42.602]                   }
[08:27:42.602]                 }
[08:27:42.602]             }
[08:27:42.602]         }))
[08:27:42.602]     }, error = function(ex) {
[08:27:42.602]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:42.602]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:42.602]                 ...future.rng), started = ...future.startTime, 
[08:27:42.602]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:42.602]             version = "1.8"), class = "FutureResult")
[08:27:42.602]     }, finally = {
[08:27:42.602]         if (!identical(...future.workdir, getwd())) 
[08:27:42.602]             setwd(...future.workdir)
[08:27:42.602]         {
[08:27:42.602]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:42.602]                 ...future.oldOptions$nwarnings <- NULL
[08:27:42.602]             }
[08:27:42.602]             base::options(...future.oldOptions)
[08:27:42.602]             if (.Platform$OS.type == "windows") {
[08:27:42.602]                 old_names <- names(...future.oldEnvVars)
[08:27:42.602]                 envs <- base::Sys.getenv()
[08:27:42.602]                 names <- names(envs)
[08:27:42.602]                 common <- intersect(names, old_names)
[08:27:42.602]                 added <- setdiff(names, old_names)
[08:27:42.602]                 removed <- setdiff(old_names, names)
[08:27:42.602]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:42.602]                   envs[common]]
[08:27:42.602]                 NAMES <- toupper(changed)
[08:27:42.602]                 args <- list()
[08:27:42.602]                 for (kk in seq_along(NAMES)) {
[08:27:42.602]                   name <- changed[[kk]]
[08:27:42.602]                   NAME <- NAMES[[kk]]
[08:27:42.602]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.602]                     next
[08:27:42.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:42.602]                 }
[08:27:42.602]                 NAMES <- toupper(added)
[08:27:42.602]                 for (kk in seq_along(NAMES)) {
[08:27:42.602]                   name <- added[[kk]]
[08:27:42.602]                   NAME <- NAMES[[kk]]
[08:27:42.602]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.602]                     next
[08:27:42.602]                   args[[name]] <- ""
[08:27:42.602]                 }
[08:27:42.602]                 NAMES <- toupper(removed)
[08:27:42.602]                 for (kk in seq_along(NAMES)) {
[08:27:42.602]                   name <- removed[[kk]]
[08:27:42.602]                   NAME <- NAMES[[kk]]
[08:27:42.602]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.602]                     next
[08:27:42.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:42.602]                 }
[08:27:42.602]                 if (length(args) > 0) 
[08:27:42.602]                   base::do.call(base::Sys.setenv, args = args)
[08:27:42.602]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:42.602]             }
[08:27:42.602]             else {
[08:27:42.602]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:42.602]             }
[08:27:42.602]             {
[08:27:42.602]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:42.602]                   0L) {
[08:27:42.602]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:42.602]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:42.602]                   base::options(opts)
[08:27:42.602]                 }
[08:27:42.602]                 {
[08:27:42.602]                   {
[08:27:42.602]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:42.602]                     NULL
[08:27:42.602]                   }
[08:27:42.602]                   options(future.plan = NULL)
[08:27:42.602]                   if (is.na(NA_character_)) 
[08:27:42.602]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:42.602]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:42.602]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:42.602]                     .init = FALSE)
[08:27:42.602]                 }
[08:27:42.602]             }
[08:27:42.602]         }
[08:27:42.602]     })
[08:27:42.602]     if (TRUE) {
[08:27:42.602]         base::sink(type = "output", split = FALSE)
[08:27:42.602]         if (TRUE) {
[08:27:42.602]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:42.602]         }
[08:27:42.602]         else {
[08:27:42.602]             ...future.result["stdout"] <- base::list(NULL)
[08:27:42.602]         }
[08:27:42.602]         base::close(...future.stdout)
[08:27:42.602]         ...future.stdout <- NULL
[08:27:42.602]     }
[08:27:42.602]     ...future.result$conditions <- ...future.conditions
[08:27:42.602]     ...future.result$finished <- base::Sys.time()
[08:27:42.602]     ...future.result
[08:27:42.602] }
[08:27:42.656] Exporting 1 global objects (344 bytes) to cluster node #2 ...
[08:27:42.657] Exporting ‘ii’ (35 bytes) to cluster node #2 ...
[08:27:42.657] Exporting ‘ii’ (35 bytes) to cluster node #2 ... DONE
[08:27:42.657] Exporting 1 global objects (344 bytes) to cluster node #2 ... DONE
[08:27:42.658] MultisessionFuture started
[08:27:42.658] - Launch lazy future ... done
[08:27:42.658] run() for ‘MultisessionFuture’ ... done
[08:27:42.659] getGlobalsAndPackages() ...
[08:27:42.659] Searching for globals...
[08:27:42.661] - globals found: [6] ‘{’, ‘if’, ‘==’, ‘%%’, ‘ii’, ‘stop’
[08:27:42.661] Searching for globals ... DONE
[08:27:42.661] Resolving globals: FALSE
[08:27:42.662] The total size of the 1 globals is 35 bytes (35 bytes)
[08:27:42.662] The total size of the 1 globals exported for future expression (‘{; if (ii%%2 == 0); stop("Woops!"); ii; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:27:42.662] - globals: [1] ‘ii’
[08:27:42.663] 
[08:27:42.663] getGlobalsAndPackages() ... DONE
[08:27:42.663] run() for ‘Future’ ...
[08:27:42.663] - state: ‘created’
[08:27:42.663] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:42.678] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:42.678] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:42.679]   - Field: ‘node’
[08:27:42.679]   - Field: ‘label’
[08:27:42.679]   - Field: ‘local’
[08:27:42.679]   - Field: ‘owner’
[08:27:42.679]   - Field: ‘envir’
[08:27:42.679]   - Field: ‘workers’
[08:27:42.679]   - Field: ‘packages’
[08:27:42.679]   - Field: ‘gc’
[08:27:42.679]   - Field: ‘conditions’
[08:27:42.679]   - Field: ‘persistent’
[08:27:42.680]   - Field: ‘expr’
[08:27:42.680]   - Field: ‘uuid’
[08:27:42.682]   - Field: ‘seed’
[08:27:42.683]   - Field: ‘version’
[08:27:42.683]   - Field: ‘result’
[08:27:42.683]   - Field: ‘asynchronous’
[08:27:42.683]   - Field: ‘calls’
[08:27:42.683]   - Field: ‘globals’
[08:27:42.683]   - Field: ‘stdout’
[08:27:42.683]   - Field: ‘earlySignal’
[08:27:42.683]   - Field: ‘lazy’
[08:27:42.683]   - Field: ‘state’
[08:27:42.683] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:42.683] - Launch lazy future ...
[08:27:42.684] Packages needed by the future expression (n = 0): <none>
[08:27:42.684] Packages needed by future strategies (n = 0): <none>
[08:27:42.684] {
[08:27:42.684]     {
[08:27:42.684]         {
[08:27:42.684]             ...future.startTime <- base::Sys.time()
[08:27:42.684]             {
[08:27:42.684]                 {
[08:27:42.684]                   {
[08:27:42.684]                     {
[08:27:42.684]                       base::local({
[08:27:42.684]                         has_future <- base::requireNamespace("future", 
[08:27:42.684]                           quietly = TRUE)
[08:27:42.684]                         if (has_future) {
[08:27:42.684]                           ns <- base::getNamespace("future")
[08:27:42.684]                           version <- ns[[".package"]][["version"]]
[08:27:42.684]                           if (is.null(version)) 
[08:27:42.684]                             version <- utils::packageVersion("future")
[08:27:42.684]                         }
[08:27:42.684]                         else {
[08:27:42.684]                           version <- NULL
[08:27:42.684]                         }
[08:27:42.684]                         if (!has_future || version < "1.8.0") {
[08:27:42.684]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:42.684]                             "", base::R.version$version.string), 
[08:27:42.684]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:42.684]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:42.684]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:42.684]                               "release", "version")], collapse = " "), 
[08:27:42.684]                             hostname = base::Sys.info()[["nodename"]])
[08:27:42.684]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:42.684]                             info)
[08:27:42.684]                           info <- base::paste(info, collapse = "; ")
[08:27:42.684]                           if (!has_future) {
[08:27:42.684]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:42.684]                               info)
[08:27:42.684]                           }
[08:27:42.684]                           else {
[08:27:42.684]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:42.684]                               info, version)
[08:27:42.684]                           }
[08:27:42.684]                           base::stop(msg)
[08:27:42.684]                         }
[08:27:42.684]                       })
[08:27:42.684]                     }
[08:27:42.684]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:42.684]                     base::options(mc.cores = 1L)
[08:27:42.684]                   }
[08:27:42.684]                   ...future.strategy.old <- future::plan("list")
[08:27:42.684]                   options(future.plan = NULL)
[08:27:42.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:42.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:42.684]                 }
[08:27:42.684]                 ...future.workdir <- getwd()
[08:27:42.684]             }
[08:27:42.684]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:42.684]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:42.684]         }
[08:27:42.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:42.684]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:42.684]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:42.684]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:42.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:42.684]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:42.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:42.684]             base::names(...future.oldOptions))
[08:27:42.684]     }
[08:27:42.684]     if (FALSE) {
[08:27:42.684]     }
[08:27:42.684]     else {
[08:27:42.684]         if (TRUE) {
[08:27:42.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:42.684]                 open = "w")
[08:27:42.684]         }
[08:27:42.684]         else {
[08:27:42.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:42.684]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:42.684]         }
[08:27:42.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:42.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:42.684]             base::sink(type = "output", split = FALSE)
[08:27:42.684]             base::close(...future.stdout)
[08:27:42.684]         }, add = TRUE)
[08:27:42.684]     }
[08:27:42.684]     ...future.frame <- base::sys.nframe()
[08:27:42.684]     ...future.conditions <- base::list()
[08:27:42.684]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:42.684]     if (FALSE) {
[08:27:42.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:42.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:42.684]     }
[08:27:42.684]     ...future.result <- base::tryCatch({
[08:27:42.684]         base::withCallingHandlers({
[08:27:42.684]             ...future.value <- base::withVisible(base::local({
[08:27:42.684]                 ...future.makeSendCondition <- base::local({
[08:27:42.684]                   sendCondition <- NULL
[08:27:42.684]                   function(frame = 1L) {
[08:27:42.684]                     if (is.function(sendCondition)) 
[08:27:42.684]                       return(sendCondition)
[08:27:42.684]                     ns <- getNamespace("parallel")
[08:27:42.684]                     if (exists("sendData", mode = "function", 
[08:27:42.684]                       envir = ns)) {
[08:27:42.684]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:42.684]                         envir = ns)
[08:27:42.684]                       envir <- sys.frame(frame)
[08:27:42.684]                       master <- NULL
[08:27:42.684]                       while (!identical(envir, .GlobalEnv) && 
[08:27:42.684]                         !identical(envir, emptyenv())) {
[08:27:42.684]                         if (exists("master", mode = "list", envir = envir, 
[08:27:42.684]                           inherits = FALSE)) {
[08:27:42.684]                           master <- get("master", mode = "list", 
[08:27:42.684]                             envir = envir, inherits = FALSE)
[08:27:42.684]                           if (inherits(master, c("SOCKnode", 
[08:27:42.684]                             "SOCK0node"))) {
[08:27:42.684]                             sendCondition <<- function(cond) {
[08:27:42.684]                               data <- list(type = "VALUE", value = cond, 
[08:27:42.684]                                 success = TRUE)
[08:27:42.684]                               parallel_sendData(master, data)
[08:27:42.684]                             }
[08:27:42.684]                             return(sendCondition)
[08:27:42.684]                           }
[08:27:42.684]                         }
[08:27:42.684]                         frame <- frame + 1L
[08:27:42.684]                         envir <- sys.frame(frame)
[08:27:42.684]                       }
[08:27:42.684]                     }
[08:27:42.684]                     sendCondition <<- function(cond) NULL
[08:27:42.684]                   }
[08:27:42.684]                 })
[08:27:42.684]                 withCallingHandlers({
[08:27:42.684]                   {
[08:27:42.684]                     if (ii%%2 == 0) 
[08:27:42.684]                       stop("Woops!")
[08:27:42.684]                     ii
[08:27:42.684]                   }
[08:27:42.684]                 }, immediateCondition = function(cond) {
[08:27:42.684]                   sendCondition <- ...future.makeSendCondition()
[08:27:42.684]                   sendCondition(cond)
[08:27:42.684]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.684]                   {
[08:27:42.684]                     inherits <- base::inherits
[08:27:42.684]                     invokeRestart <- base::invokeRestart
[08:27:42.684]                     is.null <- base::is.null
[08:27:42.684]                     muffled <- FALSE
[08:27:42.684]                     if (inherits(cond, "message")) {
[08:27:42.684]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:42.684]                       if (muffled) 
[08:27:42.684]                         invokeRestart("muffleMessage")
[08:27:42.684]                     }
[08:27:42.684]                     else if (inherits(cond, "warning")) {
[08:27:42.684]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:42.684]                       if (muffled) 
[08:27:42.684]                         invokeRestart("muffleWarning")
[08:27:42.684]                     }
[08:27:42.684]                     else if (inherits(cond, "condition")) {
[08:27:42.684]                       if (!is.null(pattern)) {
[08:27:42.684]                         computeRestarts <- base::computeRestarts
[08:27:42.684]                         grepl <- base::grepl
[08:27:42.684]                         restarts <- computeRestarts(cond)
[08:27:42.684]                         for (restart in restarts) {
[08:27:42.684]                           name <- restart$name
[08:27:42.684]                           if (is.null(name)) 
[08:27:42.684]                             next
[08:27:42.684]                           if (!grepl(pattern, name)) 
[08:27:42.684]                             next
[08:27:42.684]                           invokeRestart(restart)
[08:27:42.684]                           muffled <- TRUE
[08:27:42.684]                           break
[08:27:42.684]                         }
[08:27:42.684]                       }
[08:27:42.684]                     }
[08:27:42.684]                     invisible(muffled)
[08:27:42.684]                   }
[08:27:42.684]                   muffleCondition(cond)
[08:27:42.684]                 })
[08:27:42.684]             }))
[08:27:42.684]             future::FutureResult(value = ...future.value$value, 
[08:27:42.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:42.684]                   ...future.rng), globalenv = if (FALSE) 
[08:27:42.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:42.684]                     ...future.globalenv.names))
[08:27:42.684]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:42.684]         }, condition = base::local({
[08:27:42.684]             c <- base::c
[08:27:42.684]             inherits <- base::inherits
[08:27:42.684]             invokeRestart <- base::invokeRestart
[08:27:42.684]             length <- base::length
[08:27:42.684]             list <- base::list
[08:27:42.684]             seq.int <- base::seq.int
[08:27:42.684]             signalCondition <- base::signalCondition
[08:27:42.684]             sys.calls <- base::sys.calls
[08:27:42.684]             `[[` <- base::`[[`
[08:27:42.684]             `+` <- base::`+`
[08:27:42.684]             `<<-` <- base::`<<-`
[08:27:42.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:42.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:42.684]                   3L)]
[08:27:42.684]             }
[08:27:42.684]             function(cond) {
[08:27:42.684]                 is_error <- inherits(cond, "error")
[08:27:42.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:42.684]                   NULL)
[08:27:42.684]                 if (is_error) {
[08:27:42.684]                   sessionInformation <- function() {
[08:27:42.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:42.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:42.684]                       search = base::search(), system = base::Sys.info())
[08:27:42.684]                   }
[08:27:42.684]                   ...future.conditions[[length(...future.conditions) + 
[08:27:42.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:42.684]                     cond$call), session = sessionInformation(), 
[08:27:42.684]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:42.684]                   signalCondition(cond)
[08:27:42.684]                 }
[08:27:42.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:42.684]                 "immediateCondition"))) {
[08:27:42.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:42.684]                   ...future.conditions[[length(...future.conditions) + 
[08:27:42.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:42.684]                   if (TRUE && !signal) {
[08:27:42.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.684]                     {
[08:27:42.684]                       inherits <- base::inherits
[08:27:42.684]                       invokeRestart <- base::invokeRestart
[08:27:42.684]                       is.null <- base::is.null
[08:27:42.684]                       muffled <- FALSE
[08:27:42.684]                       if (inherits(cond, "message")) {
[08:27:42.684]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:42.684]                         if (muffled) 
[08:27:42.684]                           invokeRestart("muffleMessage")
[08:27:42.684]                       }
[08:27:42.684]                       else if (inherits(cond, "warning")) {
[08:27:42.684]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:42.684]                         if (muffled) 
[08:27:42.684]                           invokeRestart("muffleWarning")
[08:27:42.684]                       }
[08:27:42.684]                       else if (inherits(cond, "condition")) {
[08:27:42.684]                         if (!is.null(pattern)) {
[08:27:42.684]                           computeRestarts <- base::computeRestarts
[08:27:42.684]                           grepl <- base::grepl
[08:27:42.684]                           restarts <- computeRestarts(cond)
[08:27:42.684]                           for (restart in restarts) {
[08:27:42.684]                             name <- restart$name
[08:27:42.684]                             if (is.null(name)) 
[08:27:42.684]                               next
[08:27:42.684]                             if (!grepl(pattern, name)) 
[08:27:42.684]                               next
[08:27:42.684]                             invokeRestart(restart)
[08:27:42.684]                             muffled <- TRUE
[08:27:42.684]                             break
[08:27:42.684]                           }
[08:27:42.684]                         }
[08:27:42.684]                       }
[08:27:42.684]                       invisible(muffled)
[08:27:42.684]                     }
[08:27:42.684]                     muffleCondition(cond, pattern = "^muffle")
[08:27:42.684]                   }
[08:27:42.684]                 }
[08:27:42.684]                 else {
[08:27:42.684]                   if (TRUE) {
[08:27:42.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.684]                     {
[08:27:42.684]                       inherits <- base::inherits
[08:27:42.684]                       invokeRestart <- base::invokeRestart
[08:27:42.684]                       is.null <- base::is.null
[08:27:42.684]                       muffled <- FALSE
[08:27:42.684]                       if (inherits(cond, "message")) {
[08:27:42.684]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:42.684]                         if (muffled) 
[08:27:42.684]                           invokeRestart("muffleMessage")
[08:27:42.684]                       }
[08:27:42.684]                       else if (inherits(cond, "warning")) {
[08:27:42.684]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:42.684]                         if (muffled) 
[08:27:42.684]                           invokeRestart("muffleWarning")
[08:27:42.684]                       }
[08:27:42.684]                       else if (inherits(cond, "condition")) {
[08:27:42.684]                         if (!is.null(pattern)) {
[08:27:42.684]                           computeRestarts <- base::computeRestarts
[08:27:42.684]                           grepl <- base::grepl
[08:27:42.684]                           restarts <- computeRestarts(cond)
[08:27:42.684]                           for (restart in restarts) {
[08:27:42.684]                             name <- restart$name
[08:27:42.684]                             if (is.null(name)) 
[08:27:42.684]                               next
[08:27:42.684]                             if (!grepl(pattern, name)) 
[08:27:42.684]                               next
[08:27:42.684]                             invokeRestart(restart)
[08:27:42.684]                             muffled <- TRUE
[08:27:42.684]                             break
[08:27:42.684]                           }
[08:27:42.684]                         }
[08:27:42.684]                       }
[08:27:42.684]                       invisible(muffled)
[08:27:42.684]                     }
[08:27:42.684]                     muffleCondition(cond, pattern = "^muffle")
[08:27:42.684]                   }
[08:27:42.684]                 }
[08:27:42.684]             }
[08:27:42.684]         }))
[08:27:42.684]     }, error = function(ex) {
[08:27:42.684]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:42.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:42.684]                 ...future.rng), started = ...future.startTime, 
[08:27:42.684]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:42.684]             version = "1.8"), class = "FutureResult")
[08:27:42.684]     }, finally = {
[08:27:42.684]         if (!identical(...future.workdir, getwd())) 
[08:27:42.684]             setwd(...future.workdir)
[08:27:42.684]         {
[08:27:42.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:42.684]                 ...future.oldOptions$nwarnings <- NULL
[08:27:42.684]             }
[08:27:42.684]             base::options(...future.oldOptions)
[08:27:42.684]             if (.Platform$OS.type == "windows") {
[08:27:42.684]                 old_names <- names(...future.oldEnvVars)
[08:27:42.684]                 envs <- base::Sys.getenv()
[08:27:42.684]                 names <- names(envs)
[08:27:42.684]                 common <- intersect(names, old_names)
[08:27:42.684]                 added <- setdiff(names, old_names)
[08:27:42.684]                 removed <- setdiff(old_names, names)
[08:27:42.684]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:42.684]                   envs[common]]
[08:27:42.684]                 NAMES <- toupper(changed)
[08:27:42.684]                 args <- list()
[08:27:42.684]                 for (kk in seq_along(NAMES)) {
[08:27:42.684]                   name <- changed[[kk]]
[08:27:42.684]                   NAME <- NAMES[[kk]]
[08:27:42.684]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.684]                     next
[08:27:42.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:42.684]                 }
[08:27:42.684]                 NAMES <- toupper(added)
[08:27:42.684]                 for (kk in seq_along(NAMES)) {
[08:27:42.684]                   name <- added[[kk]]
[08:27:42.684]                   NAME <- NAMES[[kk]]
[08:27:42.684]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.684]                     next
[08:27:42.684]                   args[[name]] <- ""
[08:27:42.684]                 }
[08:27:42.684]                 NAMES <- toupper(removed)
[08:27:42.684]                 for (kk in seq_along(NAMES)) {
[08:27:42.684]                   name <- removed[[kk]]
[08:27:42.684]                   NAME <- NAMES[[kk]]
[08:27:42.684]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.684]                     next
[08:27:42.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:42.684]                 }
[08:27:42.684]                 if (length(args) > 0) 
[08:27:42.684]                   base::do.call(base::Sys.setenv, args = args)
[08:27:42.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:42.684]             }
[08:27:42.684]             else {
[08:27:42.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:42.684]             }
[08:27:42.684]             {
[08:27:42.684]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:42.684]                   0L) {
[08:27:42.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:42.684]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:42.684]                   base::options(opts)
[08:27:42.684]                 }
[08:27:42.684]                 {
[08:27:42.684]                   {
[08:27:42.684]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:42.684]                     NULL
[08:27:42.684]                   }
[08:27:42.684]                   options(future.plan = NULL)
[08:27:42.684]                   if (is.na(NA_character_)) 
[08:27:42.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:42.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:42.684]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:42.684]                     .init = FALSE)
[08:27:42.684]                 }
[08:27:42.684]             }
[08:27:42.684]         }
[08:27:42.684]     })
[08:27:42.684]     if (TRUE) {
[08:27:42.684]         base::sink(type = "output", split = FALSE)
[08:27:42.684]         if (TRUE) {
[08:27:42.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:42.684]         }
[08:27:42.684]         else {
[08:27:42.684]             ...future.result["stdout"] <- base::list(NULL)
[08:27:42.684]         }
[08:27:42.684]         base::close(...future.stdout)
[08:27:42.684]         ...future.stdout <- NULL
[08:27:42.684]     }
[08:27:42.684]     ...future.result$conditions <- ...future.conditions
[08:27:42.684]     ...future.result$finished <- base::Sys.time()
[08:27:42.684]     ...future.result
[08:27:42.684] }
[08:27:42.686] Poll #1 (0): usedNodes() = 2, workers = 2
[08:27:42.706] receiveMessageFromWorker() for ClusterFuture ...
[08:27:42.706] - Validating connection of MultisessionFuture
[08:27:42.706] - received message: FutureResult
[08:27:42.706] - Received FutureResult
[08:27:42.707] - Erased future from FutureRegistry
[08:27:42.707] result() for ClusterFuture ...
[08:27:42.707] - result already collected: FutureResult
[08:27:42.707] result() for ClusterFuture ... done
[08:27:42.707] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:42.707] result() for ClusterFuture ...
[08:27:42.707] - result already collected: FutureResult
[08:27:42.707] result() for ClusterFuture ... done
[08:27:42.707] result() for ClusterFuture ...
[08:27:42.707] - result already collected: FutureResult
[08:27:42.707] result() for ClusterFuture ... done
[08:27:42.708] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[08:27:42.708] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[08:27:42.709] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[08:27:42.709] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[08:27:42.709] MultisessionFuture started
[08:27:42.710] - Launch lazy future ... done
[08:27:42.710] run() for ‘MultisessionFuture’ ... done
[08:27:42.710] result() for ClusterFuture ...
[08:27:42.710] - result already collected: FutureResult
[08:27:42.710] result() for ClusterFuture ... done
[08:27:42.710] result() for ClusterFuture ...
[08:27:42.710] - result already collected: FutureResult
[08:27:42.710] result() for ClusterFuture ... done
[08:27:42.710] result() for ClusterFuture ...
[08:27:42.711] receiveMessageFromWorker() for ClusterFuture ...
[08:27:42.711] - Validating connection of MultisessionFuture
[08:27:42.731] - received message: FutureResult
[08:27:42.731] - Received FutureResult
[08:27:42.732] - Erased future from FutureRegistry
[08:27:42.732] result() for ClusterFuture ...
[08:27:42.732] - result already collected: FutureResult
[08:27:42.732] result() for ClusterFuture ... done
[08:27:42.732] signalConditions() ...
[08:27:42.732]  - include = ‘immediateCondition’
[08:27:42.732]  - exclude = 
[08:27:42.732]  - resignal = FALSE
[08:27:42.732]  - Number of conditions: 1
[08:27:42.732] signalConditions() ... done
[08:27:42.732] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:42.732] result() for ClusterFuture ... done
[08:27:42.733] result() for ClusterFuture ...
[08:27:42.733] - result already collected: FutureResult
[08:27:42.733] result() for ClusterFuture ... done
[08:27:42.733] signalConditions() ...
[08:27:42.733]  - include = ‘immediateCondition’
[08:27:42.733]  - exclude = 
[08:27:42.733]  - resignal = FALSE
[08:27:42.733]  - Number of conditions: 1
[08:27:42.733] signalConditions() ... done
[08:27:42.733] Future state: ‘finished’
[08:27:42.733] result() for ClusterFuture ...
[08:27:42.734] - result already collected: FutureResult
[08:27:42.734] result() for ClusterFuture ... done
[08:27:42.734] signalConditions() ...
[08:27:42.734]  - include = ‘condition’
[08:27:42.734]  - exclude = ‘immediateCondition’
[08:27:42.734]  - resignal = TRUE
[08:27:42.734]  - Number of conditions: 1
[08:27:42.734]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:27:42.734] signalConditions() ... done
[08:27:42.735] result() for ClusterFuture ...
[08:27:42.735] receiveMessageFromWorker() for ClusterFuture ...
[08:27:42.735] - Validating connection of MultisessionFuture
[08:27:42.751] - received message: FutureResult
[08:27:42.751] - Received FutureResult
[08:27:42.752] - Erased future from FutureRegistry
[08:27:42.752] result() for ClusterFuture ...
[08:27:42.752] - result already collected: FutureResult
[08:27:42.752] result() for ClusterFuture ... done
[08:27:42.752] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:42.752] result() for ClusterFuture ... done
[08:27:42.752] result() for ClusterFuture ...
[08:27:42.752] - result already collected: FutureResult
[08:27:42.752] result() for ClusterFuture ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[08:27:42.753] result() for ClusterFuture ...
[08:27:42.753] - result already collected: FutureResult
[08:27:42.753] result() for ClusterFuture ... done
[08:27:42.753] result() for ClusterFuture ...
[08:27:42.753] - result already collected: FutureResult
[08:27:42.753] result() for ClusterFuture ... done
[08:27:42.753] signalConditions() ...
[08:27:42.753]  - include = ‘immediateCondition’
[08:27:42.753]  - exclude = 
[08:27:42.753]  - resignal = FALSE
[08:27:42.754]  - Number of conditions: 1
[08:27:42.754] signalConditions() ... done
[08:27:42.754] Future state: ‘finished’
[08:27:42.754] result() for ClusterFuture ...
[08:27:42.754] - result already collected: FutureResult
[08:27:42.754] result() for ClusterFuture ... done
[08:27:42.754] signalConditions() ...
[08:27:42.754]  - include = ‘condition’
[08:27:42.754]  - exclude = ‘immediateCondition’
[08:27:42.754]  - resignal = TRUE
[08:27:42.754]  - Number of conditions: 1
[08:27:42.755]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:27:42.755] signalConditions() ... done
Warning in get(var, envir = x, inherits = FALSE) :
  restarting interrupted promise evaluation
[08:27:42.755] result() for ClusterFuture ...
[08:27:42.755] - result already collected: FutureResult
[08:27:42.755] result() for ClusterFuture ... done
[08:27:42.755] result() for ClusterFuture ...
[08:27:42.755] - result already collected: FutureResult
[08:27:42.755] result() for ClusterFuture ... done
[08:27:42.756] signalConditions() ...
[08:27:42.756]  - include = ‘immediateCondition’
[08:27:42.756]  - exclude = 
[08:27:42.756]  - resignal = FALSE
[08:27:42.756]  - Number of conditions: 1
[08:27:42.756] signalConditions() ... done
[08:27:42.756] Future state: ‘finished’
[08:27:42.756] result() for ClusterFuture ...
[08:27:42.756] - result already collected: FutureResult
[08:27:42.756] result() for ClusterFuture ... done
[08:27:42.756] signalConditions() ...
[08:27:42.756]  - include = ‘condition’
[08:27:42.757]  - exclude = ‘immediateCondition’
[08:27:42.757]  - resignal = TRUE
[08:27:42.757]  - Number of conditions: 1
[08:27:42.757]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:27:42.757] signalConditions() ... done
** Future evaluation with a poor-man's "progress bar"
[08:27:42.757] getGlobalsAndPackages() ...
[08:27:42.757] Searching for globals...
[08:27:42.759] - globals found: [4] ‘{’, ‘cat’, ‘for’, ‘:’
[08:27:42.759] Searching for globals ... DONE
[08:27:42.760] Resolving globals: FALSE
[08:27:42.760] 
[08:27:42.760] 
[08:27:42.760] getGlobalsAndPackages() ... DONE
[08:27:42.760] run() for ‘Future’ ...
[08:27:42.760] - state: ‘created’
[08:27:42.761] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:42.775] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:42.775] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:42.775]   - Field: ‘node’
[08:27:42.775]   - Field: ‘label’
[08:27:42.775]   - Field: ‘local’
[08:27:42.775]   - Field: ‘owner’
[08:27:42.775]   - Field: ‘envir’
[08:27:42.776]   - Field: ‘workers’
[08:27:42.776]   - Field: ‘packages’
[08:27:42.776]   - Field: ‘gc’
[08:27:42.776]   - Field: ‘conditions’
[08:27:42.776]   - Field: ‘persistent’
[08:27:42.776]   - Field: ‘expr’
[08:27:42.776]   - Field: ‘uuid’
[08:27:42.776]   - Field: ‘seed’
[08:27:42.776]   - Field: ‘version’
[08:27:42.776]   - Field: ‘result’
[08:27:42.776]   - Field: ‘asynchronous’
[08:27:42.776]   - Field: ‘calls’
[08:27:42.777]   - Field: ‘globals’
[08:27:42.777]   - Field: ‘stdout’
[08:27:42.777]   - Field: ‘earlySignal’
[08:27:42.777]   - Field: ‘lazy’
[08:27:42.777]   - Field: ‘state’
[08:27:42.777] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:42.777] - Launch lazy future ...
[08:27:42.777] Packages needed by the future expression (n = 0): <none>
[08:27:42.778] Packages needed by future strategies (n = 0): <none>
[08:27:42.778] {
[08:27:42.778]     {
[08:27:42.778]         {
[08:27:42.778]             ...future.startTime <- base::Sys.time()
[08:27:42.778]             {
[08:27:42.778]                 {
[08:27:42.778]                   {
[08:27:42.778]                     {
[08:27:42.778]                       base::local({
[08:27:42.778]                         has_future <- base::requireNamespace("future", 
[08:27:42.778]                           quietly = TRUE)
[08:27:42.778]                         if (has_future) {
[08:27:42.778]                           ns <- base::getNamespace("future")
[08:27:42.778]                           version <- ns[[".package"]][["version"]]
[08:27:42.778]                           if (is.null(version)) 
[08:27:42.778]                             version <- utils::packageVersion("future")
[08:27:42.778]                         }
[08:27:42.778]                         else {
[08:27:42.778]                           version <- NULL
[08:27:42.778]                         }
[08:27:42.778]                         if (!has_future || version < "1.8.0") {
[08:27:42.778]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:42.778]                             "", base::R.version$version.string), 
[08:27:42.778]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:42.778]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:42.778]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:42.778]                               "release", "version")], collapse = " "), 
[08:27:42.778]                             hostname = base::Sys.info()[["nodename"]])
[08:27:42.778]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:42.778]                             info)
[08:27:42.778]                           info <- base::paste(info, collapse = "; ")
[08:27:42.778]                           if (!has_future) {
[08:27:42.778]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:42.778]                               info)
[08:27:42.778]                           }
[08:27:42.778]                           else {
[08:27:42.778]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:42.778]                               info, version)
[08:27:42.778]                           }
[08:27:42.778]                           base::stop(msg)
[08:27:42.778]                         }
[08:27:42.778]                       })
[08:27:42.778]                     }
[08:27:42.778]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:42.778]                     base::options(mc.cores = 1L)
[08:27:42.778]                   }
[08:27:42.778]                   ...future.strategy.old <- future::plan("list")
[08:27:42.778]                   options(future.plan = NULL)
[08:27:42.778]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:42.778]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:42.778]                 }
[08:27:42.778]                 ...future.workdir <- getwd()
[08:27:42.778]             }
[08:27:42.778]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:42.778]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:42.778]         }
[08:27:42.778]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:42.778]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:42.778]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:42.778]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:42.778]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:42.778]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:42.778]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:42.778]             base::names(...future.oldOptions))
[08:27:42.778]     }
[08:27:42.778]     if (FALSE) {
[08:27:42.778]     }
[08:27:42.778]     else {
[08:27:42.778]         if (TRUE) {
[08:27:42.778]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:42.778]                 open = "w")
[08:27:42.778]         }
[08:27:42.778]         else {
[08:27:42.778]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:42.778]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:42.778]         }
[08:27:42.778]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:42.778]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:42.778]             base::sink(type = "output", split = FALSE)
[08:27:42.778]             base::close(...future.stdout)
[08:27:42.778]         }, add = TRUE)
[08:27:42.778]     }
[08:27:42.778]     ...future.frame <- base::sys.nframe()
[08:27:42.778]     ...future.conditions <- base::list()
[08:27:42.778]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:42.778]     if (FALSE) {
[08:27:42.778]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:42.778]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:42.778]     }
[08:27:42.778]     ...future.result <- base::tryCatch({
[08:27:42.778]         base::withCallingHandlers({
[08:27:42.778]             ...future.value <- base::withVisible(base::local({
[08:27:42.778]                 ...future.makeSendCondition <- base::local({
[08:27:42.778]                   sendCondition <- NULL
[08:27:42.778]                   function(frame = 1L) {
[08:27:42.778]                     if (is.function(sendCondition)) 
[08:27:42.778]                       return(sendCondition)
[08:27:42.778]                     ns <- getNamespace("parallel")
[08:27:42.778]                     if (exists("sendData", mode = "function", 
[08:27:42.778]                       envir = ns)) {
[08:27:42.778]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:42.778]                         envir = ns)
[08:27:42.778]                       envir <- sys.frame(frame)
[08:27:42.778]                       master <- NULL
[08:27:42.778]                       while (!identical(envir, .GlobalEnv) && 
[08:27:42.778]                         !identical(envir, emptyenv())) {
[08:27:42.778]                         if (exists("master", mode = "list", envir = envir, 
[08:27:42.778]                           inherits = FALSE)) {
[08:27:42.778]                           master <- get("master", mode = "list", 
[08:27:42.778]                             envir = envir, inherits = FALSE)
[08:27:42.778]                           if (inherits(master, c("SOCKnode", 
[08:27:42.778]                             "SOCK0node"))) {
[08:27:42.778]                             sendCondition <<- function(cond) {
[08:27:42.778]                               data <- list(type = "VALUE", value = cond, 
[08:27:42.778]                                 success = TRUE)
[08:27:42.778]                               parallel_sendData(master, data)
[08:27:42.778]                             }
[08:27:42.778]                             return(sendCondition)
[08:27:42.778]                           }
[08:27:42.778]                         }
[08:27:42.778]                         frame <- frame + 1L
[08:27:42.778]                         envir <- sys.frame(frame)
[08:27:42.778]                       }
[08:27:42.778]                     }
[08:27:42.778]                     sendCondition <<- function(cond) NULL
[08:27:42.778]                   }
[08:27:42.778]                 })
[08:27:42.778]                 withCallingHandlers({
[08:27:42.778]                   {
[08:27:42.778]                     cat("Processing: ")
[08:27:42.778]                     for (ii in 1:10) {
[08:27:42.778]                       cat(".")
[08:27:42.778]                     }
[08:27:42.778]                     cat(" [100%]\n")
[08:27:42.778]                     4
[08:27:42.778]                   }
[08:27:42.778]                 }, immediateCondition = function(cond) {
[08:27:42.778]                   sendCondition <- ...future.makeSendCondition()
[08:27:42.778]                   sendCondition(cond)
[08:27:42.778]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.778]                   {
[08:27:42.778]                     inherits <- base::inherits
[08:27:42.778]                     invokeRestart <- base::invokeRestart
[08:27:42.778]                     is.null <- base::is.null
[08:27:42.778]                     muffled <- FALSE
[08:27:42.778]                     if (inherits(cond, "message")) {
[08:27:42.778]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:42.778]                       if (muffled) 
[08:27:42.778]                         invokeRestart("muffleMessage")
[08:27:42.778]                     }
[08:27:42.778]                     else if (inherits(cond, "warning")) {
[08:27:42.778]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:42.778]                       if (muffled) 
[08:27:42.778]                         invokeRestart("muffleWarning")
[08:27:42.778]                     }
[08:27:42.778]                     else if (inherits(cond, "condition")) {
[08:27:42.778]                       if (!is.null(pattern)) {
[08:27:42.778]                         computeRestarts <- base::computeRestarts
[08:27:42.778]                         grepl <- base::grepl
[08:27:42.778]                         restarts <- computeRestarts(cond)
[08:27:42.778]                         for (restart in restarts) {
[08:27:42.778]                           name <- restart$name
[08:27:42.778]                           if (is.null(name)) 
[08:27:42.778]                             next
[08:27:42.778]                           if (!grepl(pattern, name)) 
[08:27:42.778]                             next
[08:27:42.778]                           invokeRestart(restart)
[08:27:42.778]                           muffled <- TRUE
[08:27:42.778]                           break
[08:27:42.778]                         }
[08:27:42.778]                       }
[08:27:42.778]                     }
[08:27:42.778]                     invisible(muffled)
[08:27:42.778]                   }
[08:27:42.778]                   muffleCondition(cond)
[08:27:42.778]                 })
[08:27:42.778]             }))
[08:27:42.778]             future::FutureResult(value = ...future.value$value, 
[08:27:42.778]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:42.778]                   ...future.rng), globalenv = if (FALSE) 
[08:27:42.778]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:42.778]                     ...future.globalenv.names))
[08:27:42.778]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:42.778]         }, condition = base::local({
[08:27:42.778]             c <- base::c
[08:27:42.778]             inherits <- base::inherits
[08:27:42.778]             invokeRestart <- base::invokeRestart
[08:27:42.778]             length <- base::length
[08:27:42.778]             list <- base::list
[08:27:42.778]             seq.int <- base::seq.int
[08:27:42.778]             signalCondition <- base::signalCondition
[08:27:42.778]             sys.calls <- base::sys.calls
[08:27:42.778]             `[[` <- base::`[[`
[08:27:42.778]             `+` <- base::`+`
[08:27:42.778]             `<<-` <- base::`<<-`
[08:27:42.778]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:42.778]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:42.778]                   3L)]
[08:27:42.778]             }
[08:27:42.778]             function(cond) {
[08:27:42.778]                 is_error <- inherits(cond, "error")
[08:27:42.778]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:42.778]                   NULL)
[08:27:42.778]                 if (is_error) {
[08:27:42.778]                   sessionInformation <- function() {
[08:27:42.778]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:42.778]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:42.778]                       search = base::search(), system = base::Sys.info())
[08:27:42.778]                   }
[08:27:42.778]                   ...future.conditions[[length(...future.conditions) + 
[08:27:42.778]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:42.778]                     cond$call), session = sessionInformation(), 
[08:27:42.778]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:42.778]                   signalCondition(cond)
[08:27:42.778]                 }
[08:27:42.778]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:42.778]                 "immediateCondition"))) {
[08:27:42.778]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:42.778]                   ...future.conditions[[length(...future.conditions) + 
[08:27:42.778]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:42.778]                   if (TRUE && !signal) {
[08:27:42.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.778]                     {
[08:27:42.778]                       inherits <- base::inherits
[08:27:42.778]                       invokeRestart <- base::invokeRestart
[08:27:42.778]                       is.null <- base::is.null
[08:27:42.778]                       muffled <- FALSE
[08:27:42.778]                       if (inherits(cond, "message")) {
[08:27:42.778]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:42.778]                         if (muffled) 
[08:27:42.778]                           invokeRestart("muffleMessage")
[08:27:42.778]                       }
[08:27:42.778]                       else if (inherits(cond, "warning")) {
[08:27:42.778]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:42.778]                         if (muffled) 
[08:27:42.778]                           invokeRestart("muffleWarning")
[08:27:42.778]                       }
[08:27:42.778]                       else if (inherits(cond, "condition")) {
[08:27:42.778]                         if (!is.null(pattern)) {
[08:27:42.778]                           computeRestarts <- base::computeRestarts
[08:27:42.778]                           grepl <- base::grepl
[08:27:42.778]                           restarts <- computeRestarts(cond)
[08:27:42.778]                           for (restart in restarts) {
[08:27:42.778]                             name <- restart$name
[08:27:42.778]                             if (is.null(name)) 
[08:27:42.778]                               next
[08:27:42.778]                             if (!grepl(pattern, name)) 
[08:27:42.778]                               next
[08:27:42.778]                             invokeRestart(restart)
[08:27:42.778]                             muffled <- TRUE
[08:27:42.778]                             break
[08:27:42.778]                           }
[08:27:42.778]                         }
[08:27:42.778]                       }
[08:27:42.778]                       invisible(muffled)
[08:27:42.778]                     }
[08:27:42.778]                     muffleCondition(cond, pattern = "^muffle")
[08:27:42.778]                   }
[08:27:42.778]                 }
[08:27:42.778]                 else {
[08:27:42.778]                   if (TRUE) {
[08:27:42.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.778]                     {
[08:27:42.778]                       inherits <- base::inherits
[08:27:42.778]                       invokeRestart <- base::invokeRestart
[08:27:42.778]                       is.null <- base::is.null
[08:27:42.778]                       muffled <- FALSE
[08:27:42.778]                       if (inherits(cond, "message")) {
[08:27:42.778]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:42.778]                         if (muffled) 
[08:27:42.778]                           invokeRestart("muffleMessage")
[08:27:42.778]                       }
[08:27:42.778]                       else if (inherits(cond, "warning")) {
[08:27:42.778]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:42.778]                         if (muffled) 
[08:27:42.778]                           invokeRestart("muffleWarning")
[08:27:42.778]                       }
[08:27:42.778]                       else if (inherits(cond, "condition")) {
[08:27:42.778]                         if (!is.null(pattern)) {
[08:27:42.778]                           computeRestarts <- base::computeRestarts
[08:27:42.778]                           grepl <- base::grepl
[08:27:42.778]                           restarts <- computeRestarts(cond)
[08:27:42.778]                           for (restart in restarts) {
[08:27:42.778]                             name <- restart$name
[08:27:42.778]                             if (is.null(name)) 
[08:27:42.778]                               next
[08:27:42.778]                             if (!grepl(pattern, name)) 
[08:27:42.778]                               next
[08:27:42.778]                             invokeRestart(restart)
[08:27:42.778]                             muffled <- TRUE
[08:27:42.778]                             break
[08:27:42.778]                           }
[08:27:42.778]                         }
[08:27:42.778]                       }
[08:27:42.778]                       invisible(muffled)
[08:27:42.778]                     }
[08:27:42.778]                     muffleCondition(cond, pattern = "^muffle")
[08:27:42.778]                   }
[08:27:42.778]                 }
[08:27:42.778]             }
[08:27:42.778]         }))
[08:27:42.778]     }, error = function(ex) {
[08:27:42.778]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:42.778]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:42.778]                 ...future.rng), started = ...future.startTime, 
[08:27:42.778]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:42.778]             version = "1.8"), class = "FutureResult")
[08:27:42.778]     }, finally = {
[08:27:42.778]         if (!identical(...future.workdir, getwd())) 
[08:27:42.778]             setwd(...future.workdir)
[08:27:42.778]         {
[08:27:42.778]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:42.778]                 ...future.oldOptions$nwarnings <- NULL
[08:27:42.778]             }
[08:27:42.778]             base::options(...future.oldOptions)
[08:27:42.778]             if (.Platform$OS.type == "windows") {
[08:27:42.778]                 old_names <- names(...future.oldEnvVars)
[08:27:42.778]                 envs <- base::Sys.getenv()
[08:27:42.778]                 names <- names(envs)
[08:27:42.778]                 common <- intersect(names, old_names)
[08:27:42.778]                 added <- setdiff(names, old_names)
[08:27:42.778]                 removed <- setdiff(old_names, names)
[08:27:42.778]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:42.778]                   envs[common]]
[08:27:42.778]                 NAMES <- toupper(changed)
[08:27:42.778]                 args <- list()
[08:27:42.778]                 for (kk in seq_along(NAMES)) {
[08:27:42.778]                   name <- changed[[kk]]
[08:27:42.778]                   NAME <- NAMES[[kk]]
[08:27:42.778]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.778]                     next
[08:27:42.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:42.778]                 }
[08:27:42.778]                 NAMES <- toupper(added)
[08:27:42.778]                 for (kk in seq_along(NAMES)) {
[08:27:42.778]                   name <- added[[kk]]
[08:27:42.778]                   NAME <- NAMES[[kk]]
[08:27:42.778]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.778]                     next
[08:27:42.778]                   args[[name]] <- ""
[08:27:42.778]                 }
[08:27:42.778]                 NAMES <- toupper(removed)
[08:27:42.778]                 for (kk in seq_along(NAMES)) {
[08:27:42.778]                   name <- removed[[kk]]
[08:27:42.778]                   NAME <- NAMES[[kk]]
[08:27:42.778]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.778]                     next
[08:27:42.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:42.778]                 }
[08:27:42.778]                 if (length(args) > 0) 
[08:27:42.778]                   base::do.call(base::Sys.setenv, args = args)
[08:27:42.778]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:42.778]             }
[08:27:42.778]             else {
[08:27:42.778]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:42.778]             }
[08:27:42.778]             {
[08:27:42.778]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:42.778]                   0L) {
[08:27:42.778]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:42.778]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:42.778]                   base::options(opts)
[08:27:42.778]                 }
[08:27:42.778]                 {
[08:27:42.778]                   {
[08:27:42.778]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:42.778]                     NULL
[08:27:42.778]                   }
[08:27:42.778]                   options(future.plan = NULL)
[08:27:42.778]                   if (is.na(NA_character_)) 
[08:27:42.778]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:42.778]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:42.778]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:42.778]                     .init = FALSE)
[08:27:42.778]                 }
[08:27:42.778]             }
[08:27:42.778]         }
[08:27:42.778]     })
[08:27:42.778]     if (TRUE) {
[08:27:42.778]         base::sink(type = "output", split = FALSE)
[08:27:42.778]         if (TRUE) {
[08:27:42.778]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:42.778]         }
[08:27:42.778]         else {
[08:27:42.778]             ...future.result["stdout"] <- base::list(NULL)
[08:27:42.778]         }
[08:27:42.778]         base::close(...future.stdout)
[08:27:42.778]         ...future.stdout <- NULL
[08:27:42.778]     }
[08:27:42.778]     ...future.result$conditions <- ...future.conditions
[08:27:42.778]     ...future.result$finished <- base::Sys.time()
[08:27:42.778]     ...future.result
[08:27:42.778] }
[08:27:42.781] MultisessionFuture started
[08:27:42.781] - Launch lazy future ... done
[08:27:42.781] run() for ‘MultisessionFuture’ ... done
** Collecting results
v1 = 1
v2 = 2
Warning in sprintf(...) : restarting interrupted promise evaluation
[08:27:42.782] result() for ClusterFuture ...
[08:27:42.782] - result already collected: FutureResult
[08:27:42.782] result() for ClusterFuture ... done
[08:27:42.782] result() for ClusterFuture ...
[08:27:42.782] - result already collected: FutureResult
[08:27:42.782] result() for ClusterFuture ... done
[08:27:42.782] signalConditions() ...
[08:27:42.782]  - include = ‘immediateCondition’
[08:27:42.782]  - exclude = 
[08:27:42.782]  - resignal = FALSE
[08:27:42.783]  - Number of conditions: 1
[08:27:42.783] signalConditions() ... done
[08:27:42.783] Future state: ‘finished’
[08:27:42.783] result() for ClusterFuture ...
[08:27:42.783] - result already collected: FutureResult
[08:27:42.783] result() for ClusterFuture ... done
[08:27:42.783] signalConditions() ...
[08:27:42.783]  - include = ‘condition’
[08:27:42.783]  - exclude = ‘immediateCondition’
[08:27:42.783]  - resignal = TRUE
[08:27:42.783]  - Number of conditions: 1
[08:27:42.783]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:27:42.784] signalConditions() ... done
v3: <simpleError> (as expect)
[08:27:42.784] result() for ClusterFuture ...
[08:27:42.784] receiveMessageFromWorker() for ClusterFuture ...
[08:27:42.784] - Validating connection of MultisessionFuture
[08:27:42.823] - received message: FutureResult
[08:27:42.823] - Received FutureResult
[08:27:42.824] - Erased future from FutureRegistry
[08:27:42.824] result() for ClusterFuture ...
[08:27:42.824] - result already collected: FutureResult
[08:27:42.824] result() for ClusterFuture ... done
[08:27:42.824] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:42.824] result() for ClusterFuture ... done
[08:27:42.824] result() for ClusterFuture ...
[08:27:42.824] - result already collected: FutureResult
[08:27:42.824] result() for ClusterFuture ... done
Processing: .......... [100%]
v4 = 4
** Left-to-right and right-to-left future assignments
[08:27:42.825] getGlobalsAndPackages() ...
[08:27:42.825] Searching for globals...
[08:27:42.825] 
[08:27:42.825] Searching for globals ... DONE
[08:27:42.825] - globals: [0] <none>
[08:27:42.826] getGlobalsAndPackages() ... DONE
[08:27:42.826] run() for ‘Future’ ...
[08:27:42.826] - state: ‘created’
[08:27:42.826] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:42.840] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:42.840] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:42.841]   - Field: ‘node’
[08:27:42.841]   - Field: ‘label’
[08:27:42.841]   - Field: ‘local’
[08:27:42.841]   - Field: ‘owner’
[08:27:42.841]   - Field: ‘envir’
[08:27:42.841]   - Field: ‘workers’
[08:27:42.841]   - Field: ‘packages’
[08:27:42.841]   - Field: ‘gc’
[08:27:42.841]   - Field: ‘conditions’
[08:27:42.841]   - Field: ‘persistent’
[08:27:42.841]   - Field: ‘expr’
[08:27:42.842]   - Field: ‘uuid’
[08:27:42.842]   - Field: ‘seed’
[08:27:42.842]   - Field: ‘version’
[08:27:42.842]   - Field: ‘result’
[08:27:42.842]   - Field: ‘asynchronous’
[08:27:42.842]   - Field: ‘calls’
[08:27:42.842]   - Field: ‘globals’
[08:27:42.842]   - Field: ‘stdout’
[08:27:42.842]   - Field: ‘earlySignal’
[08:27:42.842]   - Field: ‘lazy’
[08:27:42.842]   - Field: ‘state’
[08:27:42.842] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:42.843] - Launch lazy future ...
[08:27:42.843] Packages needed by the future expression (n = 0): <none>
[08:27:42.843] Packages needed by future strategies (n = 0): <none>
[08:27:42.843] {
[08:27:42.843]     {
[08:27:42.843]         {
[08:27:42.843]             ...future.startTime <- base::Sys.time()
[08:27:42.843]             {
[08:27:42.843]                 {
[08:27:42.843]                   {
[08:27:42.843]                     {
[08:27:42.843]                       base::local({
[08:27:42.843]                         has_future <- base::requireNamespace("future", 
[08:27:42.843]                           quietly = TRUE)
[08:27:42.843]                         if (has_future) {
[08:27:42.843]                           ns <- base::getNamespace("future")
[08:27:42.843]                           version <- ns[[".package"]][["version"]]
[08:27:42.843]                           if (is.null(version)) 
[08:27:42.843]                             version <- utils::packageVersion("future")
[08:27:42.843]                         }
[08:27:42.843]                         else {
[08:27:42.843]                           version <- NULL
[08:27:42.843]                         }
[08:27:42.843]                         if (!has_future || version < "1.8.0") {
[08:27:42.843]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:42.843]                             "", base::R.version$version.string), 
[08:27:42.843]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:42.843]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:42.843]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:42.843]                               "release", "version")], collapse = " "), 
[08:27:42.843]                             hostname = base::Sys.info()[["nodename"]])
[08:27:42.843]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:42.843]                             info)
[08:27:42.843]                           info <- base::paste(info, collapse = "; ")
[08:27:42.843]                           if (!has_future) {
[08:27:42.843]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:42.843]                               info)
[08:27:42.843]                           }
[08:27:42.843]                           else {
[08:27:42.843]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:42.843]                               info, version)
[08:27:42.843]                           }
[08:27:42.843]                           base::stop(msg)
[08:27:42.843]                         }
[08:27:42.843]                       })
[08:27:42.843]                     }
[08:27:42.843]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:42.843]                     base::options(mc.cores = 1L)
[08:27:42.843]                   }
[08:27:42.843]                   ...future.strategy.old <- future::plan("list")
[08:27:42.843]                   options(future.plan = NULL)
[08:27:42.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:42.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:42.843]                 }
[08:27:42.843]                 ...future.workdir <- getwd()
[08:27:42.843]             }
[08:27:42.843]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:42.843]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:42.843]         }
[08:27:42.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:42.843]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:42.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:42.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:42.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:42.843]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:42.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:42.843]             base::names(...future.oldOptions))
[08:27:42.843]     }
[08:27:42.843]     if (FALSE) {
[08:27:42.843]     }
[08:27:42.843]     else {
[08:27:42.843]         if (TRUE) {
[08:27:42.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:42.843]                 open = "w")
[08:27:42.843]         }
[08:27:42.843]         else {
[08:27:42.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:42.843]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:42.843]         }
[08:27:42.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:42.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:42.843]             base::sink(type = "output", split = FALSE)
[08:27:42.843]             base::close(...future.stdout)
[08:27:42.843]         }, add = TRUE)
[08:27:42.843]     }
[08:27:42.843]     ...future.frame <- base::sys.nframe()
[08:27:42.843]     ...future.conditions <- base::list()
[08:27:42.843]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:42.843]     if (FALSE) {
[08:27:42.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:42.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:42.843]     }
[08:27:42.843]     ...future.result <- base::tryCatch({
[08:27:42.843]         base::withCallingHandlers({
[08:27:42.843]             ...future.value <- base::withVisible(base::local({
[08:27:42.843]                 ...future.makeSendCondition <- base::local({
[08:27:42.843]                   sendCondition <- NULL
[08:27:42.843]                   function(frame = 1L) {
[08:27:42.843]                     if (is.function(sendCondition)) 
[08:27:42.843]                       return(sendCondition)
[08:27:42.843]                     ns <- getNamespace("parallel")
[08:27:42.843]                     if (exists("sendData", mode = "function", 
[08:27:42.843]                       envir = ns)) {
[08:27:42.843]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:42.843]                         envir = ns)
[08:27:42.843]                       envir <- sys.frame(frame)
[08:27:42.843]                       master <- NULL
[08:27:42.843]                       while (!identical(envir, .GlobalEnv) && 
[08:27:42.843]                         !identical(envir, emptyenv())) {
[08:27:42.843]                         if (exists("master", mode = "list", envir = envir, 
[08:27:42.843]                           inherits = FALSE)) {
[08:27:42.843]                           master <- get("master", mode = "list", 
[08:27:42.843]                             envir = envir, inherits = FALSE)
[08:27:42.843]                           if (inherits(master, c("SOCKnode", 
[08:27:42.843]                             "SOCK0node"))) {
[08:27:42.843]                             sendCondition <<- function(cond) {
[08:27:42.843]                               data <- list(type = "VALUE", value = cond, 
[08:27:42.843]                                 success = TRUE)
[08:27:42.843]                               parallel_sendData(master, data)
[08:27:42.843]                             }
[08:27:42.843]                             return(sendCondition)
[08:27:42.843]                           }
[08:27:42.843]                         }
[08:27:42.843]                         frame <- frame + 1L
[08:27:42.843]                         envir <- sys.frame(frame)
[08:27:42.843]                       }
[08:27:42.843]                     }
[08:27:42.843]                     sendCondition <<- function(cond) NULL
[08:27:42.843]                   }
[08:27:42.843]                 })
[08:27:42.843]                 withCallingHandlers({
[08:27:42.843]                   1
[08:27:42.843]                 }, immediateCondition = function(cond) {
[08:27:42.843]                   sendCondition <- ...future.makeSendCondition()
[08:27:42.843]                   sendCondition(cond)
[08:27:42.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.843]                   {
[08:27:42.843]                     inherits <- base::inherits
[08:27:42.843]                     invokeRestart <- base::invokeRestart
[08:27:42.843]                     is.null <- base::is.null
[08:27:42.843]                     muffled <- FALSE
[08:27:42.843]                     if (inherits(cond, "message")) {
[08:27:42.843]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:42.843]                       if (muffled) 
[08:27:42.843]                         invokeRestart("muffleMessage")
[08:27:42.843]                     }
[08:27:42.843]                     else if (inherits(cond, "warning")) {
[08:27:42.843]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:42.843]                       if (muffled) 
[08:27:42.843]                         invokeRestart("muffleWarning")
[08:27:42.843]                     }
[08:27:42.843]                     else if (inherits(cond, "condition")) {
[08:27:42.843]                       if (!is.null(pattern)) {
[08:27:42.843]                         computeRestarts <- base::computeRestarts
[08:27:42.843]                         grepl <- base::grepl
[08:27:42.843]                         restarts <- computeRestarts(cond)
[08:27:42.843]                         for (restart in restarts) {
[08:27:42.843]                           name <- restart$name
[08:27:42.843]                           if (is.null(name)) 
[08:27:42.843]                             next
[08:27:42.843]                           if (!grepl(pattern, name)) 
[08:27:42.843]                             next
[08:27:42.843]                           invokeRestart(restart)
[08:27:42.843]                           muffled <- TRUE
[08:27:42.843]                           break
[08:27:42.843]                         }
[08:27:42.843]                       }
[08:27:42.843]                     }
[08:27:42.843]                     invisible(muffled)
[08:27:42.843]                   }
[08:27:42.843]                   muffleCondition(cond)
[08:27:42.843]                 })
[08:27:42.843]             }))
[08:27:42.843]             future::FutureResult(value = ...future.value$value, 
[08:27:42.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:42.843]                   ...future.rng), globalenv = if (FALSE) 
[08:27:42.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:42.843]                     ...future.globalenv.names))
[08:27:42.843]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:42.843]         }, condition = base::local({
[08:27:42.843]             c <- base::c
[08:27:42.843]             inherits <- base::inherits
[08:27:42.843]             invokeRestart <- base::invokeRestart
[08:27:42.843]             length <- base::length
[08:27:42.843]             list <- base::list
[08:27:42.843]             seq.int <- base::seq.int
[08:27:42.843]             signalCondition <- base::signalCondition
[08:27:42.843]             sys.calls <- base::sys.calls
[08:27:42.843]             `[[` <- base::`[[`
[08:27:42.843]             `+` <- base::`+`
[08:27:42.843]             `<<-` <- base::`<<-`
[08:27:42.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:42.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:42.843]                   3L)]
[08:27:42.843]             }
[08:27:42.843]             function(cond) {
[08:27:42.843]                 is_error <- inherits(cond, "error")
[08:27:42.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:42.843]                   NULL)
[08:27:42.843]                 if (is_error) {
[08:27:42.843]                   sessionInformation <- function() {
[08:27:42.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:42.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:42.843]                       search = base::search(), system = base::Sys.info())
[08:27:42.843]                   }
[08:27:42.843]                   ...future.conditions[[length(...future.conditions) + 
[08:27:42.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:42.843]                     cond$call), session = sessionInformation(), 
[08:27:42.843]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:42.843]                   signalCondition(cond)
[08:27:42.843]                 }
[08:27:42.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:42.843]                 "immediateCondition"))) {
[08:27:42.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:42.843]                   ...future.conditions[[length(...future.conditions) + 
[08:27:42.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:42.843]                   if (TRUE && !signal) {
[08:27:42.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.843]                     {
[08:27:42.843]                       inherits <- base::inherits
[08:27:42.843]                       invokeRestart <- base::invokeRestart
[08:27:42.843]                       is.null <- base::is.null
[08:27:42.843]                       muffled <- FALSE
[08:27:42.843]                       if (inherits(cond, "message")) {
[08:27:42.843]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:42.843]                         if (muffled) 
[08:27:42.843]                           invokeRestart("muffleMessage")
[08:27:42.843]                       }
[08:27:42.843]                       else if (inherits(cond, "warning")) {
[08:27:42.843]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:42.843]                         if (muffled) 
[08:27:42.843]                           invokeRestart("muffleWarning")
[08:27:42.843]                       }
[08:27:42.843]                       else if (inherits(cond, "condition")) {
[08:27:42.843]                         if (!is.null(pattern)) {
[08:27:42.843]                           computeRestarts <- base::computeRestarts
[08:27:42.843]                           grepl <- base::grepl
[08:27:42.843]                           restarts <- computeRestarts(cond)
[08:27:42.843]                           for (restart in restarts) {
[08:27:42.843]                             name <- restart$name
[08:27:42.843]                             if (is.null(name)) 
[08:27:42.843]                               next
[08:27:42.843]                             if (!grepl(pattern, name)) 
[08:27:42.843]                               next
[08:27:42.843]                             invokeRestart(restart)
[08:27:42.843]                             muffled <- TRUE
[08:27:42.843]                             break
[08:27:42.843]                           }
[08:27:42.843]                         }
[08:27:42.843]                       }
[08:27:42.843]                       invisible(muffled)
[08:27:42.843]                     }
[08:27:42.843]                     muffleCondition(cond, pattern = "^muffle")
[08:27:42.843]                   }
[08:27:42.843]                 }
[08:27:42.843]                 else {
[08:27:42.843]                   if (TRUE) {
[08:27:42.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.843]                     {
[08:27:42.843]                       inherits <- base::inherits
[08:27:42.843]                       invokeRestart <- base::invokeRestart
[08:27:42.843]                       is.null <- base::is.null
[08:27:42.843]                       muffled <- FALSE
[08:27:42.843]                       if (inherits(cond, "message")) {
[08:27:42.843]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:42.843]                         if (muffled) 
[08:27:42.843]                           invokeRestart("muffleMessage")
[08:27:42.843]                       }
[08:27:42.843]                       else if (inherits(cond, "warning")) {
[08:27:42.843]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:42.843]                         if (muffled) 
[08:27:42.843]                           invokeRestart("muffleWarning")
[08:27:42.843]                       }
[08:27:42.843]                       else if (inherits(cond, "condition")) {
[08:27:42.843]                         if (!is.null(pattern)) {
[08:27:42.843]                           computeRestarts <- base::computeRestarts
[08:27:42.843]                           grepl <- base::grepl
[08:27:42.843]                           restarts <- computeRestarts(cond)
[08:27:42.843]                           for (restart in restarts) {
[08:27:42.843]                             name <- restart$name
[08:27:42.843]                             if (is.null(name)) 
[08:27:42.843]                               next
[08:27:42.843]                             if (!grepl(pattern, name)) 
[08:27:42.843]                               next
[08:27:42.843]                             invokeRestart(restart)
[08:27:42.843]                             muffled <- TRUE
[08:27:42.843]                             break
[08:27:42.843]                           }
[08:27:42.843]                         }
[08:27:42.843]                       }
[08:27:42.843]                       invisible(muffled)
[08:27:42.843]                     }
[08:27:42.843]                     muffleCondition(cond, pattern = "^muffle")
[08:27:42.843]                   }
[08:27:42.843]                 }
[08:27:42.843]             }
[08:27:42.843]         }))
[08:27:42.843]     }, error = function(ex) {
[08:27:42.843]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:42.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:42.843]                 ...future.rng), started = ...future.startTime, 
[08:27:42.843]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:42.843]             version = "1.8"), class = "FutureResult")
[08:27:42.843]     }, finally = {
[08:27:42.843]         if (!identical(...future.workdir, getwd())) 
[08:27:42.843]             setwd(...future.workdir)
[08:27:42.843]         {
[08:27:42.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:42.843]                 ...future.oldOptions$nwarnings <- NULL
[08:27:42.843]             }
[08:27:42.843]             base::options(...future.oldOptions)
[08:27:42.843]             if (.Platform$OS.type == "windows") {
[08:27:42.843]                 old_names <- names(...future.oldEnvVars)
[08:27:42.843]                 envs <- base::Sys.getenv()
[08:27:42.843]                 names <- names(envs)
[08:27:42.843]                 common <- intersect(names, old_names)
[08:27:42.843]                 added <- setdiff(names, old_names)
[08:27:42.843]                 removed <- setdiff(old_names, names)
[08:27:42.843]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:42.843]                   envs[common]]
[08:27:42.843]                 NAMES <- toupper(changed)
[08:27:42.843]                 args <- list()
[08:27:42.843]                 for (kk in seq_along(NAMES)) {
[08:27:42.843]                   name <- changed[[kk]]
[08:27:42.843]                   NAME <- NAMES[[kk]]
[08:27:42.843]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.843]                     next
[08:27:42.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:42.843]                 }
[08:27:42.843]                 NAMES <- toupper(added)
[08:27:42.843]                 for (kk in seq_along(NAMES)) {
[08:27:42.843]                   name <- added[[kk]]
[08:27:42.843]                   NAME <- NAMES[[kk]]
[08:27:42.843]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.843]                     next
[08:27:42.843]                   args[[name]] <- ""
[08:27:42.843]                 }
[08:27:42.843]                 NAMES <- toupper(removed)
[08:27:42.843]                 for (kk in seq_along(NAMES)) {
[08:27:42.843]                   name <- removed[[kk]]
[08:27:42.843]                   NAME <- NAMES[[kk]]
[08:27:42.843]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.843]                     next
[08:27:42.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:42.843]                 }
[08:27:42.843]                 if (length(args) > 0) 
[08:27:42.843]                   base::do.call(base::Sys.setenv, args = args)
[08:27:42.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:42.843]             }
[08:27:42.843]             else {
[08:27:42.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:42.843]             }
[08:27:42.843]             {
[08:27:42.843]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:42.843]                   0L) {
[08:27:42.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:42.843]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:42.843]                   base::options(opts)
[08:27:42.843]                 }
[08:27:42.843]                 {
[08:27:42.843]                   {
[08:27:42.843]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:42.843]                     NULL
[08:27:42.843]                   }
[08:27:42.843]                   options(future.plan = NULL)
[08:27:42.843]                   if (is.na(NA_character_)) 
[08:27:42.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:42.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:42.843]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:42.843]                     .init = FALSE)
[08:27:42.843]                 }
[08:27:42.843]             }
[08:27:42.843]         }
[08:27:42.843]     })
[08:27:42.843]     if (TRUE) {
[08:27:42.843]         base::sink(type = "output", split = FALSE)
[08:27:42.843]         if (TRUE) {
[08:27:42.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:42.843]         }
[08:27:42.843]         else {
[08:27:42.843]             ...future.result["stdout"] <- base::list(NULL)
[08:27:42.843]         }
[08:27:42.843]         base::close(...future.stdout)
[08:27:42.843]         ...future.stdout <- NULL
[08:27:42.843]     }
[08:27:42.843]     ...future.result$conditions <- ...future.conditions
[08:27:42.843]     ...future.result$finished <- base::Sys.time()
[08:27:42.843]     ...future.result
[08:27:42.843] }
[08:27:42.847] MultisessionFuture started
[08:27:42.847] - Launch lazy future ... done
[08:27:42.847] run() for ‘MultisessionFuture’ ... done
[08:27:42.847] result() for ClusterFuture ...
[08:27:42.847] receiveMessageFromWorker() for ClusterFuture ...
[08:27:42.847] - Validating connection of MultisessionFuture
[08:27:42.889] - received message: FutureResult
[08:27:42.889] - Received FutureResult
[08:27:42.890] - Erased future from FutureRegistry
[08:27:42.890] result() for ClusterFuture ...
[08:27:42.890] - result already collected: FutureResult
[08:27:42.890] result() for ClusterFuture ... done
[08:27:42.890] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:42.890] result() for ClusterFuture ... done
[08:27:42.890] result() for ClusterFuture ...
[08:27:42.890] - result already collected: FutureResult
[08:27:42.890] result() for ClusterFuture ... done
c = 1
[08:27:42.891] getGlobalsAndPackages() ...
[08:27:42.891] Searching for globals...
[08:27:42.891] 
[08:27:42.891] Searching for globals ... DONE
[08:27:42.891] - globals: [0] <none>
[08:27:42.891] getGlobalsAndPackages() ... DONE
[08:27:42.892] run() for ‘Future’ ...
[08:27:42.892] - state: ‘created’
[08:27:42.892] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:42.906] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:42.907] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:42.907]   - Field: ‘node’
[08:27:42.907]   - Field: ‘label’
[08:27:42.907]   - Field: ‘local’
[08:27:42.907]   - Field: ‘owner’
[08:27:42.907]   - Field: ‘envir’
[08:27:42.907]   - Field: ‘workers’
[08:27:42.907]   - Field: ‘packages’
[08:27:42.907]   - Field: ‘gc’
[08:27:42.907]   - Field: ‘conditions’
[08:27:42.907]   - Field: ‘persistent’
[08:27:42.908]   - Field: ‘expr’
[08:27:42.908]   - Field: ‘uuid’
[08:27:42.908]   - Field: ‘seed’
[08:27:42.908]   - Field: ‘version’
[08:27:42.908]   - Field: ‘result’
[08:27:42.908]   - Field: ‘asynchronous’
[08:27:42.908]   - Field: ‘calls’
[08:27:42.908]   - Field: ‘globals’
[08:27:42.908]   - Field: ‘stdout’
[08:27:42.908]   - Field: ‘earlySignal’
[08:27:42.908]   - Field: ‘lazy’
[08:27:42.908]   - Field: ‘state’
[08:27:42.909] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:42.909] - Launch lazy future ...
[08:27:42.909] Packages needed by the future expression (n = 0): <none>
[08:27:42.909] Packages needed by future strategies (n = 0): <none>
[08:27:42.910] {
[08:27:42.910]     {
[08:27:42.910]         {
[08:27:42.910]             ...future.startTime <- base::Sys.time()
[08:27:42.910]             {
[08:27:42.910]                 {
[08:27:42.910]                   {
[08:27:42.910]                     {
[08:27:42.910]                       base::local({
[08:27:42.910]                         has_future <- base::requireNamespace("future", 
[08:27:42.910]                           quietly = TRUE)
[08:27:42.910]                         if (has_future) {
[08:27:42.910]                           ns <- base::getNamespace("future")
[08:27:42.910]                           version <- ns[[".package"]][["version"]]
[08:27:42.910]                           if (is.null(version)) 
[08:27:42.910]                             version <- utils::packageVersion("future")
[08:27:42.910]                         }
[08:27:42.910]                         else {
[08:27:42.910]                           version <- NULL
[08:27:42.910]                         }
[08:27:42.910]                         if (!has_future || version < "1.8.0") {
[08:27:42.910]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:42.910]                             "", base::R.version$version.string), 
[08:27:42.910]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:42.910]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:42.910]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:42.910]                               "release", "version")], collapse = " "), 
[08:27:42.910]                             hostname = base::Sys.info()[["nodename"]])
[08:27:42.910]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:42.910]                             info)
[08:27:42.910]                           info <- base::paste(info, collapse = "; ")
[08:27:42.910]                           if (!has_future) {
[08:27:42.910]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:42.910]                               info)
[08:27:42.910]                           }
[08:27:42.910]                           else {
[08:27:42.910]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:42.910]                               info, version)
[08:27:42.910]                           }
[08:27:42.910]                           base::stop(msg)
[08:27:42.910]                         }
[08:27:42.910]                       })
[08:27:42.910]                     }
[08:27:42.910]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:42.910]                     base::options(mc.cores = 1L)
[08:27:42.910]                   }
[08:27:42.910]                   ...future.strategy.old <- future::plan("list")
[08:27:42.910]                   options(future.plan = NULL)
[08:27:42.910]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:42.910]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:42.910]                 }
[08:27:42.910]                 ...future.workdir <- getwd()
[08:27:42.910]             }
[08:27:42.910]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:42.910]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:42.910]         }
[08:27:42.910]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:42.910]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:42.910]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:42.910]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:42.910]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:42.910]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:42.910]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:42.910]             base::names(...future.oldOptions))
[08:27:42.910]     }
[08:27:42.910]     if (FALSE) {
[08:27:42.910]     }
[08:27:42.910]     else {
[08:27:42.910]         if (TRUE) {
[08:27:42.910]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:42.910]                 open = "w")
[08:27:42.910]         }
[08:27:42.910]         else {
[08:27:42.910]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:42.910]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:42.910]         }
[08:27:42.910]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:42.910]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:42.910]             base::sink(type = "output", split = FALSE)
[08:27:42.910]             base::close(...future.stdout)
[08:27:42.910]         }, add = TRUE)
[08:27:42.910]     }
[08:27:42.910]     ...future.frame <- base::sys.nframe()
[08:27:42.910]     ...future.conditions <- base::list()
[08:27:42.910]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:42.910]     if (FALSE) {
[08:27:42.910]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:42.910]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:42.910]     }
[08:27:42.910]     ...future.result <- base::tryCatch({
[08:27:42.910]         base::withCallingHandlers({
[08:27:42.910]             ...future.value <- base::withVisible(base::local({
[08:27:42.910]                 ...future.makeSendCondition <- base::local({
[08:27:42.910]                   sendCondition <- NULL
[08:27:42.910]                   function(frame = 1L) {
[08:27:42.910]                     if (is.function(sendCondition)) 
[08:27:42.910]                       return(sendCondition)
[08:27:42.910]                     ns <- getNamespace("parallel")
[08:27:42.910]                     if (exists("sendData", mode = "function", 
[08:27:42.910]                       envir = ns)) {
[08:27:42.910]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:42.910]                         envir = ns)
[08:27:42.910]                       envir <- sys.frame(frame)
[08:27:42.910]                       master <- NULL
[08:27:42.910]                       while (!identical(envir, .GlobalEnv) && 
[08:27:42.910]                         !identical(envir, emptyenv())) {
[08:27:42.910]                         if (exists("master", mode = "list", envir = envir, 
[08:27:42.910]                           inherits = FALSE)) {
[08:27:42.910]                           master <- get("master", mode = "list", 
[08:27:42.910]                             envir = envir, inherits = FALSE)
[08:27:42.910]                           if (inherits(master, c("SOCKnode", 
[08:27:42.910]                             "SOCK0node"))) {
[08:27:42.910]                             sendCondition <<- function(cond) {
[08:27:42.910]                               data <- list(type = "VALUE", value = cond, 
[08:27:42.910]                                 success = TRUE)
[08:27:42.910]                               parallel_sendData(master, data)
[08:27:42.910]                             }
[08:27:42.910]                             return(sendCondition)
[08:27:42.910]                           }
[08:27:42.910]                         }
[08:27:42.910]                         frame <- frame + 1L
[08:27:42.910]                         envir <- sys.frame(frame)
[08:27:42.910]                       }
[08:27:42.910]                     }
[08:27:42.910]                     sendCondition <<- function(cond) NULL
[08:27:42.910]                   }
[08:27:42.910]                 })
[08:27:42.910]                 withCallingHandlers({
[08:27:42.910]                   1
[08:27:42.910]                 }, immediateCondition = function(cond) {
[08:27:42.910]                   sendCondition <- ...future.makeSendCondition()
[08:27:42.910]                   sendCondition(cond)
[08:27:42.910]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.910]                   {
[08:27:42.910]                     inherits <- base::inherits
[08:27:42.910]                     invokeRestart <- base::invokeRestart
[08:27:42.910]                     is.null <- base::is.null
[08:27:42.910]                     muffled <- FALSE
[08:27:42.910]                     if (inherits(cond, "message")) {
[08:27:42.910]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:42.910]                       if (muffled) 
[08:27:42.910]                         invokeRestart("muffleMessage")
[08:27:42.910]                     }
[08:27:42.910]                     else if (inherits(cond, "warning")) {
[08:27:42.910]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:42.910]                       if (muffled) 
[08:27:42.910]                         invokeRestart("muffleWarning")
[08:27:42.910]                     }
[08:27:42.910]                     else if (inherits(cond, "condition")) {
[08:27:42.910]                       if (!is.null(pattern)) {
[08:27:42.910]                         computeRestarts <- base::computeRestarts
[08:27:42.910]                         grepl <- base::grepl
[08:27:42.910]                         restarts <- computeRestarts(cond)
[08:27:42.910]                         for (restart in restarts) {
[08:27:42.910]                           name <- restart$name
[08:27:42.910]                           if (is.null(name)) 
[08:27:42.910]                             next
[08:27:42.910]                           if (!grepl(pattern, name)) 
[08:27:42.910]                             next
[08:27:42.910]                           invokeRestart(restart)
[08:27:42.910]                           muffled <- TRUE
[08:27:42.910]                           break
[08:27:42.910]                         }
[08:27:42.910]                       }
[08:27:42.910]                     }
[08:27:42.910]                     invisible(muffled)
[08:27:42.910]                   }
[08:27:42.910]                   muffleCondition(cond)
[08:27:42.910]                 })
[08:27:42.910]             }))
[08:27:42.910]             future::FutureResult(value = ...future.value$value, 
[08:27:42.910]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:42.910]                   ...future.rng), globalenv = if (FALSE) 
[08:27:42.910]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:42.910]                     ...future.globalenv.names))
[08:27:42.910]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:42.910]         }, condition = base::local({
[08:27:42.910]             c <- base::c
[08:27:42.910]             inherits <- base::inherits
[08:27:42.910]             invokeRestart <- base::invokeRestart
[08:27:42.910]             length <- base::length
[08:27:42.910]             list <- base::list
[08:27:42.910]             seq.int <- base::seq.int
[08:27:42.910]             signalCondition <- base::signalCondition
[08:27:42.910]             sys.calls <- base::sys.calls
[08:27:42.910]             `[[` <- base::`[[`
[08:27:42.910]             `+` <- base::`+`
[08:27:42.910]             `<<-` <- base::`<<-`
[08:27:42.910]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:42.910]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:42.910]                   3L)]
[08:27:42.910]             }
[08:27:42.910]             function(cond) {
[08:27:42.910]                 is_error <- inherits(cond, "error")
[08:27:42.910]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:42.910]                   NULL)
[08:27:42.910]                 if (is_error) {
[08:27:42.910]                   sessionInformation <- function() {
[08:27:42.910]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:42.910]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:42.910]                       search = base::search(), system = base::Sys.info())
[08:27:42.910]                   }
[08:27:42.910]                   ...future.conditions[[length(...future.conditions) + 
[08:27:42.910]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:42.910]                     cond$call), session = sessionInformation(), 
[08:27:42.910]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:42.910]                   signalCondition(cond)
[08:27:42.910]                 }
[08:27:42.910]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:42.910]                 "immediateCondition"))) {
[08:27:42.910]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:42.910]                   ...future.conditions[[length(...future.conditions) + 
[08:27:42.910]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:42.910]                   if (TRUE && !signal) {
[08:27:42.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.910]                     {
[08:27:42.910]                       inherits <- base::inherits
[08:27:42.910]                       invokeRestart <- base::invokeRestart
[08:27:42.910]                       is.null <- base::is.null
[08:27:42.910]                       muffled <- FALSE
[08:27:42.910]                       if (inherits(cond, "message")) {
[08:27:42.910]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:42.910]                         if (muffled) 
[08:27:42.910]                           invokeRestart("muffleMessage")
[08:27:42.910]                       }
[08:27:42.910]                       else if (inherits(cond, "warning")) {
[08:27:42.910]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:42.910]                         if (muffled) 
[08:27:42.910]                           invokeRestart("muffleWarning")
[08:27:42.910]                       }
[08:27:42.910]                       else if (inherits(cond, "condition")) {
[08:27:42.910]                         if (!is.null(pattern)) {
[08:27:42.910]                           computeRestarts <- base::computeRestarts
[08:27:42.910]                           grepl <- base::grepl
[08:27:42.910]                           restarts <- computeRestarts(cond)
[08:27:42.910]                           for (restart in restarts) {
[08:27:42.910]                             name <- restart$name
[08:27:42.910]                             if (is.null(name)) 
[08:27:42.910]                               next
[08:27:42.910]                             if (!grepl(pattern, name)) 
[08:27:42.910]                               next
[08:27:42.910]                             invokeRestart(restart)
[08:27:42.910]                             muffled <- TRUE
[08:27:42.910]                             break
[08:27:42.910]                           }
[08:27:42.910]                         }
[08:27:42.910]                       }
[08:27:42.910]                       invisible(muffled)
[08:27:42.910]                     }
[08:27:42.910]                     muffleCondition(cond, pattern = "^muffle")
[08:27:42.910]                   }
[08:27:42.910]                 }
[08:27:42.910]                 else {
[08:27:42.910]                   if (TRUE) {
[08:27:42.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.910]                     {
[08:27:42.910]                       inherits <- base::inherits
[08:27:42.910]                       invokeRestart <- base::invokeRestart
[08:27:42.910]                       is.null <- base::is.null
[08:27:42.910]                       muffled <- FALSE
[08:27:42.910]                       if (inherits(cond, "message")) {
[08:27:42.910]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:42.910]                         if (muffled) 
[08:27:42.910]                           invokeRestart("muffleMessage")
[08:27:42.910]                       }
[08:27:42.910]                       else if (inherits(cond, "warning")) {
[08:27:42.910]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:42.910]                         if (muffled) 
[08:27:42.910]                           invokeRestart("muffleWarning")
[08:27:42.910]                       }
[08:27:42.910]                       else if (inherits(cond, "condition")) {
[08:27:42.910]                         if (!is.null(pattern)) {
[08:27:42.910]                           computeRestarts <- base::computeRestarts
[08:27:42.910]                           grepl <- base::grepl
[08:27:42.910]                           restarts <- computeRestarts(cond)
[08:27:42.910]                           for (restart in restarts) {
[08:27:42.910]                             name <- restart$name
[08:27:42.910]                             if (is.null(name)) 
[08:27:42.910]                               next
[08:27:42.910]                             if (!grepl(pattern, name)) 
[08:27:42.910]                               next
[08:27:42.910]                             invokeRestart(restart)
[08:27:42.910]                             muffled <- TRUE
[08:27:42.910]                             break
[08:27:42.910]                           }
[08:27:42.910]                         }
[08:27:42.910]                       }
[08:27:42.910]                       invisible(muffled)
[08:27:42.910]                     }
[08:27:42.910]                     muffleCondition(cond, pattern = "^muffle")
[08:27:42.910]                   }
[08:27:42.910]                 }
[08:27:42.910]             }
[08:27:42.910]         }))
[08:27:42.910]     }, error = function(ex) {
[08:27:42.910]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:42.910]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:42.910]                 ...future.rng), started = ...future.startTime, 
[08:27:42.910]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:42.910]             version = "1.8"), class = "FutureResult")
[08:27:42.910]     }, finally = {
[08:27:42.910]         if (!identical(...future.workdir, getwd())) 
[08:27:42.910]             setwd(...future.workdir)
[08:27:42.910]         {
[08:27:42.910]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:42.910]                 ...future.oldOptions$nwarnings <- NULL
[08:27:42.910]             }
[08:27:42.910]             base::options(...future.oldOptions)
[08:27:42.910]             if (.Platform$OS.type == "windows") {
[08:27:42.910]                 old_names <- names(...future.oldEnvVars)
[08:27:42.910]                 envs <- base::Sys.getenv()
[08:27:42.910]                 names <- names(envs)
[08:27:42.910]                 common <- intersect(names, old_names)
[08:27:42.910]                 added <- setdiff(names, old_names)
[08:27:42.910]                 removed <- setdiff(old_names, names)
[08:27:42.910]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:42.910]                   envs[common]]
[08:27:42.910]                 NAMES <- toupper(changed)
[08:27:42.910]                 args <- list()
[08:27:42.910]                 for (kk in seq_along(NAMES)) {
[08:27:42.910]                   name <- changed[[kk]]
[08:27:42.910]                   NAME <- NAMES[[kk]]
[08:27:42.910]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.910]                     next
[08:27:42.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:42.910]                 }
[08:27:42.910]                 NAMES <- toupper(added)
[08:27:42.910]                 for (kk in seq_along(NAMES)) {
[08:27:42.910]                   name <- added[[kk]]
[08:27:42.910]                   NAME <- NAMES[[kk]]
[08:27:42.910]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.910]                     next
[08:27:42.910]                   args[[name]] <- ""
[08:27:42.910]                 }
[08:27:42.910]                 NAMES <- toupper(removed)
[08:27:42.910]                 for (kk in seq_along(NAMES)) {
[08:27:42.910]                   name <- removed[[kk]]
[08:27:42.910]                   NAME <- NAMES[[kk]]
[08:27:42.910]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.910]                     next
[08:27:42.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:42.910]                 }
[08:27:42.910]                 if (length(args) > 0) 
[08:27:42.910]                   base::do.call(base::Sys.setenv, args = args)
[08:27:42.910]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:42.910]             }
[08:27:42.910]             else {
[08:27:42.910]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:42.910]             }
[08:27:42.910]             {
[08:27:42.910]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:42.910]                   0L) {
[08:27:42.910]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:42.910]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:42.910]                   base::options(opts)
[08:27:42.910]                 }
[08:27:42.910]                 {
[08:27:42.910]                   {
[08:27:42.910]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:42.910]                     NULL
[08:27:42.910]                   }
[08:27:42.910]                   options(future.plan = NULL)
[08:27:42.910]                   if (is.na(NA_character_)) 
[08:27:42.910]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:42.910]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:42.910]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:42.910]                     .init = FALSE)
[08:27:42.910]                 }
[08:27:42.910]             }
[08:27:42.910]         }
[08:27:42.910]     })
[08:27:42.910]     if (TRUE) {
[08:27:42.910]         base::sink(type = "output", split = FALSE)
[08:27:42.910]         if (TRUE) {
[08:27:42.910]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:42.910]         }
[08:27:42.910]         else {
[08:27:42.910]             ...future.result["stdout"] <- base::list(NULL)
[08:27:42.910]         }
[08:27:42.910]         base::close(...future.stdout)
[08:27:42.910]         ...future.stdout <- NULL
[08:27:42.910]     }
[08:27:42.910]     ...future.result$conditions <- ...future.conditions
[08:27:42.910]     ...future.result$finished <- base::Sys.time()
[08:27:42.910]     ...future.result
[08:27:42.910] }
[08:27:42.913] MultisessionFuture started
[08:27:42.913] - Launch lazy future ... done
[08:27:42.913] run() for ‘MultisessionFuture’ ... done
[08:27:42.913] result() for ClusterFuture ...
[08:27:42.913] receiveMessageFromWorker() for ClusterFuture ...
[08:27:42.913] - Validating connection of MultisessionFuture
[08:27:42.955] - received message: FutureResult
[08:27:42.955] - Received FutureResult
[08:27:42.956] - Erased future from FutureRegistry
[08:27:42.956] result() for ClusterFuture ...
[08:27:42.956] - result already collected: FutureResult
[08:27:42.956] result() for ClusterFuture ... done
[08:27:42.956] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:42.956] result() for ClusterFuture ... done
[08:27:42.956] result() for ClusterFuture ...
[08:27:42.956] - result already collected: FutureResult
[08:27:42.956] result() for ClusterFuture ... done
d = 1
** Nested future assignments
[08:27:42.957] getGlobalsAndPackages() ...
[08:27:42.957] Searching for globals...
[08:27:42.960] - globals found: [5] ‘{’, ‘<-’, ‘%<-%’, ‘%->%’, ‘+’
[08:27:42.961] Searching for globals ... DONE
[08:27:42.961] Resolving globals: FALSE
[08:27:42.961] 
[08:27:42.961] - packages: [1] ‘future’
[08:27:42.961] getGlobalsAndPackages() ... DONE
[08:27:42.962] run() for ‘Future’ ...
[08:27:42.962] - state: ‘created’
[08:27:42.962] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:42.976] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:42.976] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:42.976]   - Field: ‘node’
[08:27:42.976]   - Field: ‘label’
[08:27:42.977]   - Field: ‘local’
[08:27:42.977]   - Field: ‘owner’
[08:27:42.977]   - Field: ‘envir’
[08:27:42.977]   - Field: ‘workers’
[08:27:42.977]   - Field: ‘packages’
[08:27:42.977]   - Field: ‘gc’
[08:27:42.977]   - Field: ‘conditions’
[08:27:42.977]   - Field: ‘persistent’
[08:27:42.977]   - Field: ‘expr’
[08:27:42.977]   - Field: ‘uuid’
[08:27:42.977]   - Field: ‘seed’
[08:27:42.978]   - Field: ‘version’
[08:27:42.978]   - Field: ‘result’
[08:27:42.978]   - Field: ‘asynchronous’
[08:27:42.978]   - Field: ‘calls’
[08:27:42.978]   - Field: ‘globals’
[08:27:42.978]   - Field: ‘stdout’
[08:27:42.978]   - Field: ‘earlySignal’
[08:27:42.978]   - Field: ‘lazy’
[08:27:42.978]   - Field: ‘state’
[08:27:42.978] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:42.978] - Launch lazy future ...
[08:27:42.979] Packages needed by the future expression (n = 1): ‘future’
[08:27:42.979] Packages needed by future strategies (n = 0): <none>
[08:27:42.979] {
[08:27:42.979]     {
[08:27:42.979]         {
[08:27:42.979]             ...future.startTime <- base::Sys.time()
[08:27:42.979]             {
[08:27:42.979]                 {
[08:27:42.979]                   {
[08:27:42.979]                     {
[08:27:42.979]                       {
[08:27:42.979]                         base::local({
[08:27:42.979]                           has_future <- base::requireNamespace("future", 
[08:27:42.979]                             quietly = TRUE)
[08:27:42.979]                           if (has_future) {
[08:27:42.979]                             ns <- base::getNamespace("future")
[08:27:42.979]                             version <- ns[[".package"]][["version"]]
[08:27:42.979]                             if (is.null(version)) 
[08:27:42.979]                               version <- utils::packageVersion("future")
[08:27:42.979]                           }
[08:27:42.979]                           else {
[08:27:42.979]                             version <- NULL
[08:27:42.979]                           }
[08:27:42.979]                           if (!has_future || version < "1.8.0") {
[08:27:42.979]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:42.979]                               "", base::R.version$version.string), 
[08:27:42.979]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:42.979]                                 base::R.version$platform, 8 * 
[08:27:42.979]                                   base::.Machine$sizeof.pointer), 
[08:27:42.979]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:42.979]                                 "release", "version")], collapse = " "), 
[08:27:42.979]                               hostname = base::Sys.info()[["nodename"]])
[08:27:42.979]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:42.979]                               info)
[08:27:42.979]                             info <- base::paste(info, collapse = "; ")
[08:27:42.979]                             if (!has_future) {
[08:27:42.979]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:42.979]                                 info)
[08:27:42.979]                             }
[08:27:42.979]                             else {
[08:27:42.979]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:42.979]                                 info, version)
[08:27:42.979]                             }
[08:27:42.979]                             base::stop(msg)
[08:27:42.979]                           }
[08:27:42.979]                         })
[08:27:42.979]                       }
[08:27:42.979]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:42.979]                       base::options(mc.cores = 1L)
[08:27:42.979]                     }
[08:27:42.979]                     base::local({
[08:27:42.979]                       for (pkg in "future") {
[08:27:42.979]                         base::loadNamespace(pkg)
[08:27:42.979]                         base::library(pkg, character.only = TRUE)
[08:27:42.979]                       }
[08:27:42.979]                     })
[08:27:42.979]                   }
[08:27:42.979]                   ...future.strategy.old <- future::plan("list")
[08:27:42.979]                   options(future.plan = NULL)
[08:27:42.979]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:42.979]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:42.979]                 }
[08:27:42.979]                 ...future.workdir <- getwd()
[08:27:42.979]             }
[08:27:42.979]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:42.979]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:42.979]         }
[08:27:42.979]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:42.979]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:42.979]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:42.979]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:42.979]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:42.979]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:42.979]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:42.979]             base::names(...future.oldOptions))
[08:27:42.979]     }
[08:27:42.979]     if (FALSE) {
[08:27:42.979]     }
[08:27:42.979]     else {
[08:27:42.979]         if (TRUE) {
[08:27:42.979]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:42.979]                 open = "w")
[08:27:42.979]         }
[08:27:42.979]         else {
[08:27:42.979]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:42.979]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:42.979]         }
[08:27:42.979]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:42.979]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:42.979]             base::sink(type = "output", split = FALSE)
[08:27:42.979]             base::close(...future.stdout)
[08:27:42.979]         }, add = TRUE)
[08:27:42.979]     }
[08:27:42.979]     ...future.frame <- base::sys.nframe()
[08:27:42.979]     ...future.conditions <- base::list()
[08:27:42.979]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:42.979]     if (FALSE) {
[08:27:42.979]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:42.979]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:42.979]     }
[08:27:42.979]     ...future.result <- base::tryCatch({
[08:27:42.979]         base::withCallingHandlers({
[08:27:42.979]             ...future.value <- base::withVisible(base::local({
[08:27:42.979]                 ...future.makeSendCondition <- base::local({
[08:27:42.979]                   sendCondition <- NULL
[08:27:42.979]                   function(frame = 1L) {
[08:27:42.979]                     if (is.function(sendCondition)) 
[08:27:42.979]                       return(sendCondition)
[08:27:42.979]                     ns <- getNamespace("parallel")
[08:27:42.979]                     if (exists("sendData", mode = "function", 
[08:27:42.979]                       envir = ns)) {
[08:27:42.979]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:42.979]                         envir = ns)
[08:27:42.979]                       envir <- sys.frame(frame)
[08:27:42.979]                       master <- NULL
[08:27:42.979]                       while (!identical(envir, .GlobalEnv) && 
[08:27:42.979]                         !identical(envir, emptyenv())) {
[08:27:42.979]                         if (exists("master", mode = "list", envir = envir, 
[08:27:42.979]                           inherits = FALSE)) {
[08:27:42.979]                           master <- get("master", mode = "list", 
[08:27:42.979]                             envir = envir, inherits = FALSE)
[08:27:42.979]                           if (inherits(master, c("SOCKnode", 
[08:27:42.979]                             "SOCK0node"))) {
[08:27:42.979]                             sendCondition <<- function(cond) {
[08:27:42.979]                               data <- list(type = "VALUE", value = cond, 
[08:27:42.979]                                 success = TRUE)
[08:27:42.979]                               parallel_sendData(master, data)
[08:27:42.979]                             }
[08:27:42.979]                             return(sendCondition)
[08:27:42.979]                           }
[08:27:42.979]                         }
[08:27:42.979]                         frame <- frame + 1L
[08:27:42.979]                         envir <- sys.frame(frame)
[08:27:42.979]                       }
[08:27:42.979]                     }
[08:27:42.979]                     sendCondition <<- function(cond) NULL
[08:27:42.979]                   }
[08:27:42.979]                 })
[08:27:42.979]                 withCallingHandlers({
[08:27:42.979]                   {
[08:27:42.979]                     b <- 1
[08:27:42.979]                     c %<-% 2
[08:27:42.979]                     d <- 3
[08:27:42.979]                     4 %->% e
[08:27:42.979]                     b + c + d + e
[08:27:42.979]                   }
[08:27:42.979]                 }, immediateCondition = function(cond) {
[08:27:42.979]                   sendCondition <- ...future.makeSendCondition()
[08:27:42.979]                   sendCondition(cond)
[08:27:42.979]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.979]                   {
[08:27:42.979]                     inherits <- base::inherits
[08:27:42.979]                     invokeRestart <- base::invokeRestart
[08:27:42.979]                     is.null <- base::is.null
[08:27:42.979]                     muffled <- FALSE
[08:27:42.979]                     if (inherits(cond, "message")) {
[08:27:42.979]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:42.979]                       if (muffled) 
[08:27:42.979]                         invokeRestart("muffleMessage")
[08:27:42.979]                     }
[08:27:42.979]                     else if (inherits(cond, "warning")) {
[08:27:42.979]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:42.979]                       if (muffled) 
[08:27:42.979]                         invokeRestart("muffleWarning")
[08:27:42.979]                     }
[08:27:42.979]                     else if (inherits(cond, "condition")) {
[08:27:42.979]                       if (!is.null(pattern)) {
[08:27:42.979]                         computeRestarts <- base::computeRestarts
[08:27:42.979]                         grepl <- base::grepl
[08:27:42.979]                         restarts <- computeRestarts(cond)
[08:27:42.979]                         for (restart in restarts) {
[08:27:42.979]                           name <- restart$name
[08:27:42.979]                           if (is.null(name)) 
[08:27:42.979]                             next
[08:27:42.979]                           if (!grepl(pattern, name)) 
[08:27:42.979]                             next
[08:27:42.979]                           invokeRestart(restart)
[08:27:42.979]                           muffled <- TRUE
[08:27:42.979]                           break
[08:27:42.979]                         }
[08:27:42.979]                       }
[08:27:42.979]                     }
[08:27:42.979]                     invisible(muffled)
[08:27:42.979]                   }
[08:27:42.979]                   muffleCondition(cond)
[08:27:42.979]                 })
[08:27:42.979]             }))
[08:27:42.979]             future::FutureResult(value = ...future.value$value, 
[08:27:42.979]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:42.979]                   ...future.rng), globalenv = if (FALSE) 
[08:27:42.979]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:42.979]                     ...future.globalenv.names))
[08:27:42.979]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:42.979]         }, condition = base::local({
[08:27:42.979]             c <- base::c
[08:27:42.979]             inherits <- base::inherits
[08:27:42.979]             invokeRestart <- base::invokeRestart
[08:27:42.979]             length <- base::length
[08:27:42.979]             list <- base::list
[08:27:42.979]             seq.int <- base::seq.int
[08:27:42.979]             signalCondition <- base::signalCondition
[08:27:42.979]             sys.calls <- base::sys.calls
[08:27:42.979]             `[[` <- base::`[[`
[08:27:42.979]             `+` <- base::`+`
[08:27:42.979]             `<<-` <- base::`<<-`
[08:27:42.979]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:42.979]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:42.979]                   3L)]
[08:27:42.979]             }
[08:27:42.979]             function(cond) {
[08:27:42.979]                 is_error <- inherits(cond, "error")
[08:27:42.979]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:42.979]                   NULL)
[08:27:42.979]                 if (is_error) {
[08:27:42.979]                   sessionInformation <- function() {
[08:27:42.979]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:42.979]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:42.979]                       search = base::search(), system = base::Sys.info())
[08:27:42.979]                   }
[08:27:42.979]                   ...future.conditions[[length(...future.conditions) + 
[08:27:42.979]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:42.979]                     cond$call), session = sessionInformation(), 
[08:27:42.979]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:42.979]                   signalCondition(cond)
[08:27:42.979]                 }
[08:27:42.979]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:42.979]                 "immediateCondition"))) {
[08:27:42.979]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:42.979]                   ...future.conditions[[length(...future.conditions) + 
[08:27:42.979]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:42.979]                   if (TRUE && !signal) {
[08:27:42.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.979]                     {
[08:27:42.979]                       inherits <- base::inherits
[08:27:42.979]                       invokeRestart <- base::invokeRestart
[08:27:42.979]                       is.null <- base::is.null
[08:27:42.979]                       muffled <- FALSE
[08:27:42.979]                       if (inherits(cond, "message")) {
[08:27:42.979]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:42.979]                         if (muffled) 
[08:27:42.979]                           invokeRestart("muffleMessage")
[08:27:42.979]                       }
[08:27:42.979]                       else if (inherits(cond, "warning")) {
[08:27:42.979]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:42.979]                         if (muffled) 
[08:27:42.979]                           invokeRestart("muffleWarning")
[08:27:42.979]                       }
[08:27:42.979]                       else if (inherits(cond, "condition")) {
[08:27:42.979]                         if (!is.null(pattern)) {
[08:27:42.979]                           computeRestarts <- base::computeRestarts
[08:27:42.979]                           grepl <- base::grepl
[08:27:42.979]                           restarts <- computeRestarts(cond)
[08:27:42.979]                           for (restart in restarts) {
[08:27:42.979]                             name <- restart$name
[08:27:42.979]                             if (is.null(name)) 
[08:27:42.979]                               next
[08:27:42.979]                             if (!grepl(pattern, name)) 
[08:27:42.979]                               next
[08:27:42.979]                             invokeRestart(restart)
[08:27:42.979]                             muffled <- TRUE
[08:27:42.979]                             break
[08:27:42.979]                           }
[08:27:42.979]                         }
[08:27:42.979]                       }
[08:27:42.979]                       invisible(muffled)
[08:27:42.979]                     }
[08:27:42.979]                     muffleCondition(cond, pattern = "^muffle")
[08:27:42.979]                   }
[08:27:42.979]                 }
[08:27:42.979]                 else {
[08:27:42.979]                   if (TRUE) {
[08:27:42.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:42.979]                     {
[08:27:42.979]                       inherits <- base::inherits
[08:27:42.979]                       invokeRestart <- base::invokeRestart
[08:27:42.979]                       is.null <- base::is.null
[08:27:42.979]                       muffled <- FALSE
[08:27:42.979]                       if (inherits(cond, "message")) {
[08:27:42.979]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:42.979]                         if (muffled) 
[08:27:42.979]                           invokeRestart("muffleMessage")
[08:27:42.979]                       }
[08:27:42.979]                       else if (inherits(cond, "warning")) {
[08:27:42.979]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:42.979]                         if (muffled) 
[08:27:42.979]                           invokeRestart("muffleWarning")
[08:27:42.979]                       }
[08:27:42.979]                       else if (inherits(cond, "condition")) {
[08:27:42.979]                         if (!is.null(pattern)) {
[08:27:42.979]                           computeRestarts <- base::computeRestarts
[08:27:42.979]                           grepl <- base::grepl
[08:27:42.979]                           restarts <- computeRestarts(cond)
[08:27:42.979]                           for (restart in restarts) {
[08:27:42.979]                             name <- restart$name
[08:27:42.979]                             if (is.null(name)) 
[08:27:42.979]                               next
[08:27:42.979]                             if (!grepl(pattern, name)) 
[08:27:42.979]                               next
[08:27:42.979]                             invokeRestart(restart)
[08:27:42.979]                             muffled <- TRUE
[08:27:42.979]                             break
[08:27:42.979]                           }
[08:27:42.979]                         }
[08:27:42.979]                       }
[08:27:42.979]                       invisible(muffled)
[08:27:42.979]                     }
[08:27:42.979]                     muffleCondition(cond, pattern = "^muffle")
[08:27:42.979]                   }
[08:27:42.979]                 }
[08:27:42.979]             }
[08:27:42.979]         }))
[08:27:42.979]     }, error = function(ex) {
[08:27:42.979]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:42.979]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:42.979]                 ...future.rng), started = ...future.startTime, 
[08:27:42.979]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:42.979]             version = "1.8"), class = "FutureResult")
[08:27:42.979]     }, finally = {
[08:27:42.979]         if (!identical(...future.workdir, getwd())) 
[08:27:42.979]             setwd(...future.workdir)
[08:27:42.979]         {
[08:27:42.979]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:42.979]                 ...future.oldOptions$nwarnings <- NULL
[08:27:42.979]             }
[08:27:42.979]             base::options(...future.oldOptions)
[08:27:42.979]             if (.Platform$OS.type == "windows") {
[08:27:42.979]                 old_names <- names(...future.oldEnvVars)
[08:27:42.979]                 envs <- base::Sys.getenv()
[08:27:42.979]                 names <- names(envs)
[08:27:42.979]                 common <- intersect(names, old_names)
[08:27:42.979]                 added <- setdiff(names, old_names)
[08:27:42.979]                 removed <- setdiff(old_names, names)
[08:27:42.979]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:42.979]                   envs[common]]
[08:27:42.979]                 NAMES <- toupper(changed)
[08:27:42.979]                 args <- list()
[08:27:42.979]                 for (kk in seq_along(NAMES)) {
[08:27:42.979]                   name <- changed[[kk]]
[08:27:42.979]                   NAME <- NAMES[[kk]]
[08:27:42.979]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.979]                     next
[08:27:42.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:42.979]                 }
[08:27:42.979]                 NAMES <- toupper(added)
[08:27:42.979]                 for (kk in seq_along(NAMES)) {
[08:27:42.979]                   name <- added[[kk]]
[08:27:42.979]                   NAME <- NAMES[[kk]]
[08:27:42.979]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.979]                     next
[08:27:42.979]                   args[[name]] <- ""
[08:27:42.979]                 }
[08:27:42.979]                 NAMES <- toupper(removed)
[08:27:42.979]                 for (kk in seq_along(NAMES)) {
[08:27:42.979]                   name <- removed[[kk]]
[08:27:42.979]                   NAME <- NAMES[[kk]]
[08:27:42.979]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:42.979]                     next
[08:27:42.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:42.979]                 }
[08:27:42.979]                 if (length(args) > 0) 
[08:27:42.979]                   base::do.call(base::Sys.setenv, args = args)
[08:27:42.979]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:42.979]             }
[08:27:42.979]             else {
[08:27:42.979]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:42.979]             }
[08:27:42.979]             {
[08:27:42.979]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:42.979]                   0L) {
[08:27:42.979]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:42.979]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:42.979]                   base::options(opts)
[08:27:42.979]                 }
[08:27:42.979]                 {
[08:27:42.979]                   {
[08:27:42.979]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:42.979]                     NULL
[08:27:42.979]                   }
[08:27:42.979]                   options(future.plan = NULL)
[08:27:42.979]                   if (is.na(NA_character_)) 
[08:27:42.979]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:42.979]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:42.979]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:42.979]                     .init = FALSE)
[08:27:42.979]                 }
[08:27:42.979]             }
[08:27:42.979]         }
[08:27:42.979]     })
[08:27:42.979]     if (TRUE) {
[08:27:42.979]         base::sink(type = "output", split = FALSE)
[08:27:42.979]         if (TRUE) {
[08:27:42.979]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:42.979]         }
[08:27:42.979]         else {
[08:27:42.979]             ...future.result["stdout"] <- base::list(NULL)
[08:27:42.979]         }
[08:27:42.979]         base::close(...future.stdout)
[08:27:42.979]         ...future.stdout <- NULL
[08:27:42.979]     }
[08:27:42.979]     ...future.result$conditions <- ...future.conditions
[08:27:42.979]     ...future.result$finished <- base::Sys.time()
[08:27:42.979]     ...future.result
[08:27:42.979] }
[08:27:42.983] MultisessionFuture started
[08:27:42.983] - Launch lazy future ... done
[08:27:42.983] run() for ‘MultisessionFuture’ ... done
[08:27:42.983] result() for ClusterFuture ...
[08:27:42.983] receiveMessageFromWorker() for ClusterFuture ...
[08:27:42.983] - Validating connection of MultisessionFuture
[08:27:43.037] - received message: FutureResult
[08:27:43.038] - Received FutureResult
[08:27:43.038] - Erased future from FutureRegistry
[08:27:43.038] result() for ClusterFuture ...
[08:27:43.038] - result already collected: FutureResult
[08:27:43.038] result() for ClusterFuture ... done
[08:27:43.038] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:43.038] result() for ClusterFuture ... done
[08:27:43.038] result() for ClusterFuture ...
[08:27:43.038] - result already collected: FutureResult
[08:27:43.039] result() for ClusterFuture ... done
a = 10
[08:27:43.039] getGlobalsAndPackages() ...
[08:27:43.039] Searching for globals...
[08:27:43.046] - globals found: [3] ‘{’, ‘+’, ‘a’
[08:27:43.046] Searching for globals ... DONE
[08:27:43.046] Resolving globals: FALSE
[08:27:43.046] The total size of the 1 globals is 39 bytes (39 bytes)
[08:27:43.047] The total size of the 1 globals exported for future expression (‘{; a + 1; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[08:27:43.047] - globals: [1] ‘a’
[08:27:43.047] 
[08:27:43.047] getGlobalsAndPackages() ... DONE
[08:27:43.047] run() for ‘Future’ ...
[08:27:43.047] - state: ‘created’
[08:27:43.047] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:43.062] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:43.062] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:43.062]   - Field: ‘node’
[08:27:43.062]   - Field: ‘label’
[08:27:43.062]   - Field: ‘local’
[08:27:43.062]   - Field: ‘owner’
[08:27:43.062]   - Field: ‘envir’
[08:27:43.063]   - Field: ‘workers’
[08:27:43.063]   - Field: ‘packages’
[08:27:43.063]   - Field: ‘gc’
[08:27:43.063]   - Field: ‘conditions’
[08:27:43.063]   - Field: ‘persistent’
[08:27:43.063]   - Field: ‘expr’
[08:27:43.063]   - Field: ‘uuid’
[08:27:43.063]   - Field: ‘seed’
[08:27:43.063]   - Field: ‘version’
[08:27:43.063]   - Field: ‘result’
[08:27:43.063]   - Field: ‘asynchronous’
[08:27:43.063]   - Field: ‘calls’
[08:27:43.064]   - Field: ‘globals’
[08:27:43.064]   - Field: ‘stdout’
[08:27:43.064]   - Field: ‘earlySignal’
[08:27:43.064]   - Field: ‘lazy’
[08:27:43.064]   - Field: ‘state’
[08:27:43.064] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:43.064] - Launch lazy future ...
[08:27:43.064] Packages needed by the future expression (n = 0): <none>
[08:27:43.064] Packages needed by future strategies (n = 0): <none>
[08:27:43.065] {
[08:27:43.065]     {
[08:27:43.065]         {
[08:27:43.065]             ...future.startTime <- base::Sys.time()
[08:27:43.065]             {
[08:27:43.065]                 {
[08:27:43.065]                   {
[08:27:43.065]                     {
[08:27:43.065]                       base::local({
[08:27:43.065]                         has_future <- base::requireNamespace("future", 
[08:27:43.065]                           quietly = TRUE)
[08:27:43.065]                         if (has_future) {
[08:27:43.065]                           ns <- base::getNamespace("future")
[08:27:43.065]                           version <- ns[[".package"]][["version"]]
[08:27:43.065]                           if (is.null(version)) 
[08:27:43.065]                             version <- utils::packageVersion("future")
[08:27:43.065]                         }
[08:27:43.065]                         else {
[08:27:43.065]                           version <- NULL
[08:27:43.065]                         }
[08:27:43.065]                         if (!has_future || version < "1.8.0") {
[08:27:43.065]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:43.065]                             "", base::R.version$version.string), 
[08:27:43.065]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:43.065]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:43.065]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:43.065]                               "release", "version")], collapse = " "), 
[08:27:43.065]                             hostname = base::Sys.info()[["nodename"]])
[08:27:43.065]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:43.065]                             info)
[08:27:43.065]                           info <- base::paste(info, collapse = "; ")
[08:27:43.065]                           if (!has_future) {
[08:27:43.065]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:43.065]                               info)
[08:27:43.065]                           }
[08:27:43.065]                           else {
[08:27:43.065]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:43.065]                               info, version)
[08:27:43.065]                           }
[08:27:43.065]                           base::stop(msg)
[08:27:43.065]                         }
[08:27:43.065]                       })
[08:27:43.065]                     }
[08:27:43.065]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:43.065]                     base::options(mc.cores = 1L)
[08:27:43.065]                   }
[08:27:43.065]                   ...future.strategy.old <- future::plan("list")
[08:27:43.065]                   options(future.plan = NULL)
[08:27:43.065]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:43.065]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:43.065]                 }
[08:27:43.065]                 ...future.workdir <- getwd()
[08:27:43.065]             }
[08:27:43.065]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:43.065]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:43.065]         }
[08:27:43.065]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:43.065]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:43.065]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:43.065]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:43.065]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:43.065]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:43.065]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:43.065]             base::names(...future.oldOptions))
[08:27:43.065]     }
[08:27:43.065]     if (FALSE) {
[08:27:43.065]     }
[08:27:43.065]     else {
[08:27:43.065]         if (TRUE) {
[08:27:43.065]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:43.065]                 open = "w")
[08:27:43.065]         }
[08:27:43.065]         else {
[08:27:43.065]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:43.065]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:43.065]         }
[08:27:43.065]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:43.065]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:43.065]             base::sink(type = "output", split = FALSE)
[08:27:43.065]             base::close(...future.stdout)
[08:27:43.065]         }, add = TRUE)
[08:27:43.065]     }
[08:27:43.065]     ...future.frame <- base::sys.nframe()
[08:27:43.065]     ...future.conditions <- base::list()
[08:27:43.065]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:43.065]     if (FALSE) {
[08:27:43.065]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:43.065]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:43.065]     }
[08:27:43.065]     ...future.result <- base::tryCatch({
[08:27:43.065]         base::withCallingHandlers({
[08:27:43.065]             ...future.value <- base::withVisible(base::local({
[08:27:43.065]                 ...future.makeSendCondition <- base::local({
[08:27:43.065]                   sendCondition <- NULL
[08:27:43.065]                   function(frame = 1L) {
[08:27:43.065]                     if (is.function(sendCondition)) 
[08:27:43.065]                       return(sendCondition)
[08:27:43.065]                     ns <- getNamespace("parallel")
[08:27:43.065]                     if (exists("sendData", mode = "function", 
[08:27:43.065]                       envir = ns)) {
[08:27:43.065]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:43.065]                         envir = ns)
[08:27:43.065]                       envir <- sys.frame(frame)
[08:27:43.065]                       master <- NULL
[08:27:43.065]                       while (!identical(envir, .GlobalEnv) && 
[08:27:43.065]                         !identical(envir, emptyenv())) {
[08:27:43.065]                         if (exists("master", mode = "list", envir = envir, 
[08:27:43.065]                           inherits = FALSE)) {
[08:27:43.065]                           master <- get("master", mode = "list", 
[08:27:43.065]                             envir = envir, inherits = FALSE)
[08:27:43.065]                           if (inherits(master, c("SOCKnode", 
[08:27:43.065]                             "SOCK0node"))) {
[08:27:43.065]                             sendCondition <<- function(cond) {
[08:27:43.065]                               data <- list(type = "VALUE", value = cond, 
[08:27:43.065]                                 success = TRUE)
[08:27:43.065]                               parallel_sendData(master, data)
[08:27:43.065]                             }
[08:27:43.065]                             return(sendCondition)
[08:27:43.065]                           }
[08:27:43.065]                         }
[08:27:43.065]                         frame <- frame + 1L
[08:27:43.065]                         envir <- sys.frame(frame)
[08:27:43.065]                       }
[08:27:43.065]                     }
[08:27:43.065]                     sendCondition <<- function(cond) NULL
[08:27:43.065]                   }
[08:27:43.065]                 })
[08:27:43.065]                 withCallingHandlers({
[08:27:43.065]                   {
[08:27:43.065]                     a + 1
[08:27:43.065]                   }
[08:27:43.065]                 }, immediateCondition = function(cond) {
[08:27:43.065]                   sendCondition <- ...future.makeSendCondition()
[08:27:43.065]                   sendCondition(cond)
[08:27:43.065]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:43.065]                   {
[08:27:43.065]                     inherits <- base::inherits
[08:27:43.065]                     invokeRestart <- base::invokeRestart
[08:27:43.065]                     is.null <- base::is.null
[08:27:43.065]                     muffled <- FALSE
[08:27:43.065]                     if (inherits(cond, "message")) {
[08:27:43.065]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:43.065]                       if (muffled) 
[08:27:43.065]                         invokeRestart("muffleMessage")
[08:27:43.065]                     }
[08:27:43.065]                     else if (inherits(cond, "warning")) {
[08:27:43.065]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:43.065]                       if (muffled) 
[08:27:43.065]                         invokeRestart("muffleWarning")
[08:27:43.065]                     }
[08:27:43.065]                     else if (inherits(cond, "condition")) {
[08:27:43.065]                       if (!is.null(pattern)) {
[08:27:43.065]                         computeRestarts <- base::computeRestarts
[08:27:43.065]                         grepl <- base::grepl
[08:27:43.065]                         restarts <- computeRestarts(cond)
[08:27:43.065]                         for (restart in restarts) {
[08:27:43.065]                           name <- restart$name
[08:27:43.065]                           if (is.null(name)) 
[08:27:43.065]                             next
[08:27:43.065]                           if (!grepl(pattern, name)) 
[08:27:43.065]                             next
[08:27:43.065]                           invokeRestart(restart)
[08:27:43.065]                           muffled <- TRUE
[08:27:43.065]                           break
[08:27:43.065]                         }
[08:27:43.065]                       }
[08:27:43.065]                     }
[08:27:43.065]                     invisible(muffled)
[08:27:43.065]                   }
[08:27:43.065]                   muffleCondition(cond)
[08:27:43.065]                 })
[08:27:43.065]             }))
[08:27:43.065]             future::FutureResult(value = ...future.value$value, 
[08:27:43.065]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:43.065]                   ...future.rng), globalenv = if (FALSE) 
[08:27:43.065]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:43.065]                     ...future.globalenv.names))
[08:27:43.065]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:43.065]         }, condition = base::local({
[08:27:43.065]             c <- base::c
[08:27:43.065]             inherits <- base::inherits
[08:27:43.065]             invokeRestart <- base::invokeRestart
[08:27:43.065]             length <- base::length
[08:27:43.065]             list <- base::list
[08:27:43.065]             seq.int <- base::seq.int
[08:27:43.065]             signalCondition <- base::signalCondition
[08:27:43.065]             sys.calls <- base::sys.calls
[08:27:43.065]             `[[` <- base::`[[`
[08:27:43.065]             `+` <- base::`+`
[08:27:43.065]             `<<-` <- base::`<<-`
[08:27:43.065]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:43.065]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:43.065]                   3L)]
[08:27:43.065]             }
[08:27:43.065]             function(cond) {
[08:27:43.065]                 is_error <- inherits(cond, "error")
[08:27:43.065]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:43.065]                   NULL)
[08:27:43.065]                 if (is_error) {
[08:27:43.065]                   sessionInformation <- function() {
[08:27:43.065]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:43.065]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:43.065]                       search = base::search(), system = base::Sys.info())
[08:27:43.065]                   }
[08:27:43.065]                   ...future.conditions[[length(...future.conditions) + 
[08:27:43.065]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:43.065]                     cond$call), session = sessionInformation(), 
[08:27:43.065]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:43.065]                   signalCondition(cond)
[08:27:43.065]                 }
[08:27:43.065]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:43.065]                 "immediateCondition"))) {
[08:27:43.065]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:43.065]                   ...future.conditions[[length(...future.conditions) + 
[08:27:43.065]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:43.065]                   if (TRUE && !signal) {
[08:27:43.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:43.065]                     {
[08:27:43.065]                       inherits <- base::inherits
[08:27:43.065]                       invokeRestart <- base::invokeRestart
[08:27:43.065]                       is.null <- base::is.null
[08:27:43.065]                       muffled <- FALSE
[08:27:43.065]                       if (inherits(cond, "message")) {
[08:27:43.065]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:43.065]                         if (muffled) 
[08:27:43.065]                           invokeRestart("muffleMessage")
[08:27:43.065]                       }
[08:27:43.065]                       else if (inherits(cond, "warning")) {
[08:27:43.065]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:43.065]                         if (muffled) 
[08:27:43.065]                           invokeRestart("muffleWarning")
[08:27:43.065]                       }
[08:27:43.065]                       else if (inherits(cond, "condition")) {
[08:27:43.065]                         if (!is.null(pattern)) {
[08:27:43.065]                           computeRestarts <- base::computeRestarts
[08:27:43.065]                           grepl <- base::grepl
[08:27:43.065]                           restarts <- computeRestarts(cond)
[08:27:43.065]                           for (restart in restarts) {
[08:27:43.065]                             name <- restart$name
[08:27:43.065]                             if (is.null(name)) 
[08:27:43.065]                               next
[08:27:43.065]                             if (!grepl(pattern, name)) 
[08:27:43.065]                               next
[08:27:43.065]                             invokeRestart(restart)
[08:27:43.065]                             muffled <- TRUE
[08:27:43.065]                             break
[08:27:43.065]                           }
[08:27:43.065]                         }
[08:27:43.065]                       }
[08:27:43.065]                       invisible(muffled)
[08:27:43.065]                     }
[08:27:43.065]                     muffleCondition(cond, pattern = "^muffle")
[08:27:43.065]                   }
[08:27:43.065]                 }
[08:27:43.065]                 else {
[08:27:43.065]                   if (TRUE) {
[08:27:43.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:43.065]                     {
[08:27:43.065]                       inherits <- base::inherits
[08:27:43.065]                       invokeRestart <- base::invokeRestart
[08:27:43.065]                       is.null <- base::is.null
[08:27:43.065]                       muffled <- FALSE
[08:27:43.065]                       if (inherits(cond, "message")) {
[08:27:43.065]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:43.065]                         if (muffled) 
[08:27:43.065]                           invokeRestart("muffleMessage")
[08:27:43.065]                       }
[08:27:43.065]                       else if (inherits(cond, "warning")) {
[08:27:43.065]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:43.065]                         if (muffled) 
[08:27:43.065]                           invokeRestart("muffleWarning")
[08:27:43.065]                       }
[08:27:43.065]                       else if (inherits(cond, "condition")) {
[08:27:43.065]                         if (!is.null(pattern)) {
[08:27:43.065]                           computeRestarts <- base::computeRestarts
[08:27:43.065]                           grepl <- base::grepl
[08:27:43.065]                           restarts <- computeRestarts(cond)
[08:27:43.065]                           for (restart in restarts) {
[08:27:43.065]                             name <- restart$name
[08:27:43.065]                             if (is.null(name)) 
[08:27:43.065]                               next
[08:27:43.065]                             if (!grepl(pattern, name)) 
[08:27:43.065]                               next
[08:27:43.065]                             invokeRestart(restart)
[08:27:43.065]                             muffled <- TRUE
[08:27:43.065]                             break
[08:27:43.065]                           }
[08:27:43.065]                         }
[08:27:43.065]                       }
[08:27:43.065]                       invisible(muffled)
[08:27:43.065]                     }
[08:27:43.065]                     muffleCondition(cond, pattern = "^muffle")
[08:27:43.065]                   }
[08:27:43.065]                 }
[08:27:43.065]             }
[08:27:43.065]         }))
[08:27:43.065]     }, error = function(ex) {
[08:27:43.065]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:43.065]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:43.065]                 ...future.rng), started = ...future.startTime, 
[08:27:43.065]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:43.065]             version = "1.8"), class = "FutureResult")
[08:27:43.065]     }, finally = {
[08:27:43.065]         if (!identical(...future.workdir, getwd())) 
[08:27:43.065]             setwd(...future.workdir)
[08:27:43.065]         {
[08:27:43.065]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:43.065]                 ...future.oldOptions$nwarnings <- NULL
[08:27:43.065]             }
[08:27:43.065]             base::options(...future.oldOptions)
[08:27:43.065]             if (.Platform$OS.type == "windows") {
[08:27:43.065]                 old_names <- names(...future.oldEnvVars)
[08:27:43.065]                 envs <- base::Sys.getenv()
[08:27:43.065]                 names <- names(envs)
[08:27:43.065]                 common <- intersect(names, old_names)
[08:27:43.065]                 added <- setdiff(names, old_names)
[08:27:43.065]                 removed <- setdiff(old_names, names)
[08:27:43.065]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:43.065]                   envs[common]]
[08:27:43.065]                 NAMES <- toupper(changed)
[08:27:43.065]                 args <- list()
[08:27:43.065]                 for (kk in seq_along(NAMES)) {
[08:27:43.065]                   name <- changed[[kk]]
[08:27:43.065]                   NAME <- NAMES[[kk]]
[08:27:43.065]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:43.065]                     next
[08:27:43.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:43.065]                 }
[08:27:43.065]                 NAMES <- toupper(added)
[08:27:43.065]                 for (kk in seq_along(NAMES)) {
[08:27:43.065]                   name <- added[[kk]]
[08:27:43.065]                   NAME <- NAMES[[kk]]
[08:27:43.065]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:43.065]                     next
[08:27:43.065]                   args[[name]] <- ""
[08:27:43.065]                 }
[08:27:43.065]                 NAMES <- toupper(removed)
[08:27:43.065]                 for (kk in seq_along(NAMES)) {
[08:27:43.065]                   name <- removed[[kk]]
[08:27:43.065]                   NAME <- NAMES[[kk]]
[08:27:43.065]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:43.065]                     next
[08:27:43.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:43.065]                 }
[08:27:43.065]                 if (length(args) > 0) 
[08:27:43.065]                   base::do.call(base::Sys.setenv, args = args)
[08:27:43.065]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:43.065]             }
[08:27:43.065]             else {
[08:27:43.065]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:43.065]             }
[08:27:43.065]             {
[08:27:43.065]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:43.065]                   0L) {
[08:27:43.065]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:43.065]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:43.065]                   base::options(opts)
[08:27:43.065]                 }
[08:27:43.065]                 {
[08:27:43.065]                   {
[08:27:43.065]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:43.065]                     NULL
[08:27:43.065]                   }
[08:27:43.065]                   options(future.plan = NULL)
[08:27:43.065]                   if (is.na(NA_character_)) 
[08:27:43.065]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:43.065]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:43.065]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:43.065]                     .init = FALSE)
[08:27:43.065]                 }
[08:27:43.065]             }
[08:27:43.065]         }
[08:27:43.065]     })
[08:27:43.065]     if (TRUE) {
[08:27:43.065]         base::sink(type = "output", split = FALSE)
[08:27:43.065]         if (TRUE) {
[08:27:43.065]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:43.065]         }
[08:27:43.065]         else {
[08:27:43.065]             ...future.result["stdout"] <- base::list(NULL)
[08:27:43.065]         }
[08:27:43.065]         base::close(...future.stdout)
[08:27:43.065]         ...future.stdout <- NULL
[08:27:43.065]     }
[08:27:43.065]     ...future.result$conditions <- ...future.conditions
[08:27:43.065]     ...future.result$finished <- base::Sys.time()
[08:27:43.065]     ...future.result
[08:27:43.065] }
[08:27:43.068] Exporting 1 global objects (346 bytes) to cluster node #1 ...
[08:27:43.068] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[08:27:43.068] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[08:27:43.068] Exporting 1 global objects (346 bytes) to cluster node #1 ... DONE
[08:27:43.069] MultisessionFuture started
[08:27:43.069] - Launch lazy future ... done
[08:27:43.069] run() for ‘MultisessionFuture’ ... done
[08:27:43.069] result() for ClusterFuture ...
[08:27:43.069] receiveMessageFromWorker() for ClusterFuture ...
[08:27:43.069] - Validating connection of MultisessionFuture
[08:27:43.111] - received message: FutureResult
[08:27:43.111] - Received FutureResult
[08:27:43.112] - Erased future from FutureRegistry
[08:27:43.112] result() for ClusterFuture ...
[08:27:43.112] - result already collected: FutureResult
[08:27:43.112] result() for ClusterFuture ... done
[08:27:43.112] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:43.112] result() for ClusterFuture ... done
[08:27:43.112] result() for ClusterFuture ...
[08:27:43.112] - result already collected: FutureResult
[08:27:43.112] result() for ClusterFuture ... done
b = 11
*** %<-% with ‘multisession’ futures ... DONE
Testing with 2 cores ... DONE
> 
> message("*** %<-% ... DONE")
*** %<-% ... DONE
> 
> source("incl/end.R")
[08:27:43.113] plan(): Setting new future strategy stack:
[08:27:43.113] List of future strategies:
[08:27:43.113] 1. FutureStrategy:
[08:27:43.113]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:43.113]    - tweaked: FALSE
[08:27:43.113]    - call: future::plan(oplan)
[08:27:43.114] plan(): nbrOfWorkers() = 1
> 
