
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[08:27:25.280] plan(): Setting new future strategy stack:
[08:27:25.281] List of future strategies:
[08:27:25.281] 1. sequential:
[08:27:25.281]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:25.281]    - tweaked: FALSE
[08:27:25.281]    - call: future::plan("sequential")
[08:27:25.296] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("*** Global argument '...' ...")
+ 
+   sum_fcns <- list()
+ 
+   sum_fcns$A <- function(x, ...) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+     y %<-% { sum(x, ...) }
+     y
+   }
+ 
+ 
+   sum_fcns$B <- function(x, ...) {
+     sumt <- function(x) {
+       message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+       y %<-% { sum(x, ...) }
+       y
+     }
+     sumt(x)
+   }
+ 
+   sum_fcns$C <- function(x, y) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+     y %<-% { sum(x, y) }
+     y
+   }
+ 
+   sum_fcns$D <- function(x, y) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+     y %<-% { sum(x, y, ...) }
+     y
+   }
+ 
+   ## Issue/PR #400: Emulate how '...' may be used by the 'rlang' package
+   sum_fcns$E <- function(...) {
+     message("Arguments '...' exists: ", exists("...", inherits = TRUE))
+ 
+     ## Grab '...' into a Globals object
+     globals <- globals::globalsByName("...", envir=environment())
+ 
+     ## Evaluate an expression with '...' in an environment that does not
+     ## have an '...' object - hence the parent.frame().  This will produce
+     ## an error unless we pass 'globals' which contains '...'
+     f <- future({
+       fcn <- function() sum(...)
+       fcn()
+     }, envir = parent.frame(), globals = globals)
+     y <- value(f)
+     y
+   }
+ 
+   ## Issue: https://github.com/HenrikBengtsson/globals/issues/72
+   sum_fcns$F <- function(x, y) {
+     message("Using '...' in a formula")
+ 
+     fcn <- function(x, y) {
+       z = ~ list(...)
+       sum(x, y)
+     }
+     
+     f <- future(fcn(x, y))
+     y <- value(f)
+     y
+   }
+ 
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy, substitute = FALSE)
+ 
+     for (name in names(sum_fcns)) {
+       message(sprintf("** Sum function '%s' with plan('%s') ...", name, strategy))
+       sum_fcn <- sum_fcns[[name]]
+       print(sum_fcn)
+       y <- try(sum_fcn(1:2, 3))
+       print(y)
+       if (name %in% c("D")) {
+         stopifnot(inherits(y, "try-error"))
+       } else {
+         stopifnot(y == 6)
+       }
+     }
+   }
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** Global argument '...' ...
- plan('sequential') ...
[08:27:25.352] plan(): Setting new future strategy stack:
[08:27:25.352] List of future strategies:
[08:27:25.352] 1. sequential:
[08:27:25.352]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:25.352]    - tweaked: FALSE
[08:27:25.352]    - call: plan(strategy, substitute = FALSE)
[08:27:25.363] plan(): nbrOfWorkers() = 1
** Sum function 'A' with plan('sequential') ...
function (x, ...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, ...)
    }
    y
}
<bytecode: 0x5594014489c0>
Arguments '...' exists: TRUE
[08:27:25.365] getGlobalsAndPackages() ...
[08:27:25.365] Searching for globals...
[08:27:25.373] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[08:27:25.374] Searching for globals ... DONE
[08:27:25.374] Resolving globals: FALSE
[08:27:25.374] Tweak future expression to call with '...' arguments ...
[08:27:25.374] {
[08:27:25.374]     do.call(function(...) {
[08:27:25.374]         sum(x, ...)
[08:27:25.374]     }, args = future.call.arguments)
[08:27:25.374] }
[08:27:25.374] Tweak future expression to call with '...' arguments ... DONE
[08:27:25.375] The total size of the 2 globals is 246 bytes (246 bytes)
[08:27:25.376] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 246 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (133 bytes of class ‘numeric’) and ‘future.call.arguments’ (113 bytes of class ‘list’)
[08:27:25.376] - globals: [2] ‘x’, ‘future.call.arguments’
[08:27:25.376] 
[08:27:25.376] getGlobalsAndPackages() ... DONE
[08:27:25.376] run() for ‘Future’ ...
[08:27:25.377] - state: ‘created’
[08:27:25.377] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:25.377] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:25.377] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:25.377]   - Field: ‘label’
[08:27:25.377]   - Field: ‘local’
[08:27:25.378]   - Field: ‘owner’
[08:27:25.378]   - Field: ‘envir’
[08:27:25.378]   - Field: ‘packages’
[08:27:25.378]   - Field: ‘gc’
[08:27:25.378]   - Field: ‘conditions’
[08:27:25.378]   - Field: ‘expr’
[08:27:25.378]   - Field: ‘uuid’
[08:27:25.378]   - Field: ‘seed’
[08:27:25.378]   - Field: ‘version’
[08:27:25.378]   - Field: ‘result’
[08:27:25.378]   - Field: ‘asynchronous’
[08:27:25.378]   - Field: ‘calls’
[08:27:25.379]   - Field: ‘globals’
[08:27:25.379]   - Field: ‘stdout’
[08:27:25.379]   - Field: ‘earlySignal’
[08:27:25.379]   - Field: ‘lazy’
[08:27:25.379]   - Field: ‘state’
[08:27:25.379] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:25.379] - Launch lazy future ...
[08:27:25.380] Packages needed by the future expression (n = 0): <none>
[08:27:25.380] Packages needed by future strategies (n = 0): <none>
[08:27:25.381] {
[08:27:25.381]     {
[08:27:25.381]         {
[08:27:25.381]             ...future.startTime <- base::Sys.time()
[08:27:25.381]             {
[08:27:25.381]                 {
[08:27:25.381]                   {
[08:27:25.381]                     base::local({
[08:27:25.381]                       has_future <- base::requireNamespace("future", 
[08:27:25.381]                         quietly = TRUE)
[08:27:25.381]                       if (has_future) {
[08:27:25.381]                         ns <- base::getNamespace("future")
[08:27:25.381]                         version <- ns[[".package"]][["version"]]
[08:27:25.381]                         if (is.null(version)) 
[08:27:25.381]                           version <- utils::packageVersion("future")
[08:27:25.381]                       }
[08:27:25.381]                       else {
[08:27:25.381]                         version <- NULL
[08:27:25.381]                       }
[08:27:25.381]                       if (!has_future || version < "1.8.0") {
[08:27:25.381]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:25.381]                           "", base::R.version$version.string), 
[08:27:25.381]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:25.381]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:25.381]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:25.381]                             "release", "version")], collapse = " "), 
[08:27:25.381]                           hostname = base::Sys.info()[["nodename"]])
[08:27:25.381]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:25.381]                           info)
[08:27:25.381]                         info <- base::paste(info, collapse = "; ")
[08:27:25.381]                         if (!has_future) {
[08:27:25.381]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:25.381]                             info)
[08:27:25.381]                         }
[08:27:25.381]                         else {
[08:27:25.381]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:25.381]                             info, version)
[08:27:25.381]                         }
[08:27:25.381]                         base::stop(msg)
[08:27:25.381]                       }
[08:27:25.381]                     })
[08:27:25.381]                   }
[08:27:25.381]                   ...future.strategy.old <- future::plan("list")
[08:27:25.381]                   options(future.plan = NULL)
[08:27:25.381]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.381]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:25.381]                 }
[08:27:25.381]                 ...future.workdir <- getwd()
[08:27:25.381]             }
[08:27:25.381]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:25.381]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:25.381]         }
[08:27:25.381]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:25.381]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:25.381]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:25.381]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:25.381]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:25.381]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:25.381]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:25.381]             base::names(...future.oldOptions))
[08:27:25.381]     }
[08:27:25.381]     if (FALSE) {
[08:27:25.381]     }
[08:27:25.381]     else {
[08:27:25.381]         if (TRUE) {
[08:27:25.381]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:25.381]                 open = "w")
[08:27:25.381]         }
[08:27:25.381]         else {
[08:27:25.381]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:25.381]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:25.381]         }
[08:27:25.381]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:25.381]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:25.381]             base::sink(type = "output", split = FALSE)
[08:27:25.381]             base::close(...future.stdout)
[08:27:25.381]         }, add = TRUE)
[08:27:25.381]     }
[08:27:25.381]     ...future.frame <- base::sys.nframe()
[08:27:25.381]     ...future.conditions <- base::list()
[08:27:25.381]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:25.381]     if (FALSE) {
[08:27:25.381]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:25.381]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:25.381]     }
[08:27:25.381]     ...future.result <- base::tryCatch({
[08:27:25.381]         base::withCallingHandlers({
[08:27:25.381]             ...future.value <- base::withVisible(base::local({
[08:27:25.381]                 do.call(function(...) {
[08:27:25.381]                   sum(x, ...)
[08:27:25.381]                 }, args = future.call.arguments)
[08:27:25.381]             }))
[08:27:25.381]             future::FutureResult(value = ...future.value$value, 
[08:27:25.381]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.381]                   ...future.rng), globalenv = if (FALSE) 
[08:27:25.381]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:25.381]                     ...future.globalenv.names))
[08:27:25.381]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:25.381]         }, condition = base::local({
[08:27:25.381]             c <- base::c
[08:27:25.381]             inherits <- base::inherits
[08:27:25.381]             invokeRestart <- base::invokeRestart
[08:27:25.381]             length <- base::length
[08:27:25.381]             list <- base::list
[08:27:25.381]             seq.int <- base::seq.int
[08:27:25.381]             signalCondition <- base::signalCondition
[08:27:25.381]             sys.calls <- base::sys.calls
[08:27:25.381]             `[[` <- base::`[[`
[08:27:25.381]             `+` <- base::`+`
[08:27:25.381]             `<<-` <- base::`<<-`
[08:27:25.381]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:25.381]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:25.381]                   3L)]
[08:27:25.381]             }
[08:27:25.381]             function(cond) {
[08:27:25.381]                 is_error <- inherits(cond, "error")
[08:27:25.381]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:25.381]                   NULL)
[08:27:25.381]                 if (is_error) {
[08:27:25.381]                   sessionInformation <- function() {
[08:27:25.381]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:25.381]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:25.381]                       search = base::search(), system = base::Sys.info())
[08:27:25.381]                   }
[08:27:25.381]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.381]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:25.381]                     cond$call), session = sessionInformation(), 
[08:27:25.381]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:25.381]                   signalCondition(cond)
[08:27:25.381]                 }
[08:27:25.381]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:25.381]                 "immediateCondition"))) {
[08:27:25.381]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:25.381]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.381]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:25.381]                   if (TRUE && !signal) {
[08:27:25.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.381]                     {
[08:27:25.381]                       inherits <- base::inherits
[08:27:25.381]                       invokeRestart <- base::invokeRestart
[08:27:25.381]                       is.null <- base::is.null
[08:27:25.381]                       muffled <- FALSE
[08:27:25.381]                       if (inherits(cond, "message")) {
[08:27:25.381]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.381]                         if (muffled) 
[08:27:25.381]                           invokeRestart("muffleMessage")
[08:27:25.381]                       }
[08:27:25.381]                       else if (inherits(cond, "warning")) {
[08:27:25.381]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.381]                         if (muffled) 
[08:27:25.381]                           invokeRestart("muffleWarning")
[08:27:25.381]                       }
[08:27:25.381]                       else if (inherits(cond, "condition")) {
[08:27:25.381]                         if (!is.null(pattern)) {
[08:27:25.381]                           computeRestarts <- base::computeRestarts
[08:27:25.381]                           grepl <- base::grepl
[08:27:25.381]                           restarts <- computeRestarts(cond)
[08:27:25.381]                           for (restart in restarts) {
[08:27:25.381]                             name <- restart$name
[08:27:25.381]                             if (is.null(name)) 
[08:27:25.381]                               next
[08:27:25.381]                             if (!grepl(pattern, name)) 
[08:27:25.381]                               next
[08:27:25.381]                             invokeRestart(restart)
[08:27:25.381]                             muffled <- TRUE
[08:27:25.381]                             break
[08:27:25.381]                           }
[08:27:25.381]                         }
[08:27:25.381]                       }
[08:27:25.381]                       invisible(muffled)
[08:27:25.381]                     }
[08:27:25.381]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.381]                   }
[08:27:25.381]                 }
[08:27:25.381]                 else {
[08:27:25.381]                   if (TRUE) {
[08:27:25.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.381]                     {
[08:27:25.381]                       inherits <- base::inherits
[08:27:25.381]                       invokeRestart <- base::invokeRestart
[08:27:25.381]                       is.null <- base::is.null
[08:27:25.381]                       muffled <- FALSE
[08:27:25.381]                       if (inherits(cond, "message")) {
[08:27:25.381]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.381]                         if (muffled) 
[08:27:25.381]                           invokeRestart("muffleMessage")
[08:27:25.381]                       }
[08:27:25.381]                       else if (inherits(cond, "warning")) {
[08:27:25.381]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.381]                         if (muffled) 
[08:27:25.381]                           invokeRestart("muffleWarning")
[08:27:25.381]                       }
[08:27:25.381]                       else if (inherits(cond, "condition")) {
[08:27:25.381]                         if (!is.null(pattern)) {
[08:27:25.381]                           computeRestarts <- base::computeRestarts
[08:27:25.381]                           grepl <- base::grepl
[08:27:25.381]                           restarts <- computeRestarts(cond)
[08:27:25.381]                           for (restart in restarts) {
[08:27:25.381]                             name <- restart$name
[08:27:25.381]                             if (is.null(name)) 
[08:27:25.381]                               next
[08:27:25.381]                             if (!grepl(pattern, name)) 
[08:27:25.381]                               next
[08:27:25.381]                             invokeRestart(restart)
[08:27:25.381]                             muffled <- TRUE
[08:27:25.381]                             break
[08:27:25.381]                           }
[08:27:25.381]                         }
[08:27:25.381]                       }
[08:27:25.381]                       invisible(muffled)
[08:27:25.381]                     }
[08:27:25.381]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.381]                   }
[08:27:25.381]                 }
[08:27:25.381]             }
[08:27:25.381]         }))
[08:27:25.381]     }, error = function(ex) {
[08:27:25.381]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:25.381]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.381]                 ...future.rng), started = ...future.startTime, 
[08:27:25.381]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:25.381]             version = "1.8"), class = "FutureResult")
[08:27:25.381]     }, finally = {
[08:27:25.381]         if (!identical(...future.workdir, getwd())) 
[08:27:25.381]             setwd(...future.workdir)
[08:27:25.381]         {
[08:27:25.381]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:25.381]                 ...future.oldOptions$nwarnings <- NULL
[08:27:25.381]             }
[08:27:25.381]             base::options(...future.oldOptions)
[08:27:25.381]             if (.Platform$OS.type == "windows") {
[08:27:25.381]                 old_names <- names(...future.oldEnvVars)
[08:27:25.381]                 envs <- base::Sys.getenv()
[08:27:25.381]                 names <- names(envs)
[08:27:25.381]                 common <- intersect(names, old_names)
[08:27:25.381]                 added <- setdiff(names, old_names)
[08:27:25.381]                 removed <- setdiff(old_names, names)
[08:27:25.381]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:25.381]                   envs[common]]
[08:27:25.381]                 NAMES <- toupper(changed)
[08:27:25.381]                 args <- list()
[08:27:25.381]                 for (kk in seq_along(NAMES)) {
[08:27:25.381]                   name <- changed[[kk]]
[08:27:25.381]                   NAME <- NAMES[[kk]]
[08:27:25.381]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.381]                     next
[08:27:25.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.381]                 }
[08:27:25.381]                 NAMES <- toupper(added)
[08:27:25.381]                 for (kk in seq_along(NAMES)) {
[08:27:25.381]                   name <- added[[kk]]
[08:27:25.381]                   NAME <- NAMES[[kk]]
[08:27:25.381]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.381]                     next
[08:27:25.381]                   args[[name]] <- ""
[08:27:25.381]                 }
[08:27:25.381]                 NAMES <- toupper(removed)
[08:27:25.381]                 for (kk in seq_along(NAMES)) {
[08:27:25.381]                   name <- removed[[kk]]
[08:27:25.381]                   NAME <- NAMES[[kk]]
[08:27:25.381]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.381]                     next
[08:27:25.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.381]                 }
[08:27:25.381]                 if (length(args) > 0) 
[08:27:25.381]                   base::do.call(base::Sys.setenv, args = args)
[08:27:25.381]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:25.381]             }
[08:27:25.381]             else {
[08:27:25.381]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:25.381]             }
[08:27:25.381]             {
[08:27:25.381]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:25.381]                   0L) {
[08:27:25.381]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:25.381]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:25.381]                   base::options(opts)
[08:27:25.381]                 }
[08:27:25.381]                 {
[08:27:25.381]                   {
[08:27:25.381]                     NULL
[08:27:25.381]                     RNGkind("Mersenne-Twister")
[08:27:25.381]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:25.381]                       inherits = FALSE)
[08:27:25.381]                   }
[08:27:25.381]                   options(future.plan = NULL)
[08:27:25.381]                   if (is.na(NA_character_)) 
[08:27:25.381]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.381]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:25.381]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:25.381]                     .init = FALSE)
[08:27:25.381]                 }
[08:27:25.381]             }
[08:27:25.381]         }
[08:27:25.381]     })
[08:27:25.381]     if (TRUE) {
[08:27:25.381]         base::sink(type = "output", split = FALSE)
[08:27:25.381]         if (TRUE) {
[08:27:25.381]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:25.381]         }
[08:27:25.381]         else {
[08:27:25.381]             ...future.result["stdout"] <- base::list(NULL)
[08:27:25.381]         }
[08:27:25.381]         base::close(...future.stdout)
[08:27:25.381]         ...future.stdout <- NULL
[08:27:25.381]     }
[08:27:25.381]     ...future.result$conditions <- ...future.conditions
[08:27:25.381]     ...future.result$finished <- base::Sys.time()
[08:27:25.381]     ...future.result
[08:27:25.381] }
[08:27:25.382] assign_globals() ...
[08:27:25.382] List of 2
[08:27:25.382]  $ x                    : int [1:2] 1 2
[08:27:25.382]  $ future.call.arguments:List of 1
[08:27:25.382]   ..$ : num 3
[08:27:25.382]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:27:25.382]  - attr(*, "where")=List of 2
[08:27:25.382]   ..$ x                    :<environment: R_EmptyEnv> 
[08:27:25.382]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[08:27:25.382]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:25.382]  - attr(*, "resolved")= logi FALSE
[08:27:25.382]  - attr(*, "total_size")= num 246
[08:27:25.382]  - attr(*, "already-done")= logi TRUE
[08:27:25.388] - copied ‘x’ to environment
[08:27:25.388] - copied ‘future.call.arguments’ to environment
[08:27:25.388] assign_globals() ... done
[08:27:25.388] plan(): Setting new future strategy stack:
[08:27:25.388] List of future strategies:
[08:27:25.388] 1. sequential:
[08:27:25.388]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:25.388]    - tweaked: FALSE
[08:27:25.388]    - call: NULL
[08:27:25.389] plan(): nbrOfWorkers() = 1
[08:27:25.390] plan(): Setting new future strategy stack:
[08:27:25.390] List of future strategies:
[08:27:25.390] 1. sequential:
[08:27:25.390]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:25.390]    - tweaked: FALSE
[08:27:25.390]    - call: plan(strategy, substitute = FALSE)
[08:27:25.391] plan(): nbrOfWorkers() = 1
[08:27:25.391] SequentialFuture started (and completed)
[08:27:25.391] - Launch lazy future ... done
[08:27:25.391] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'B' with plan('sequential') ...
function (x, ...) 
{
    sumt <- function(x) {
        message("Arguments '...' exists: ", exists("...", inherits = TRUE))
        y %<-% {
            sum(x, ...)
        }
        y
    }
    sumt(x)
}
<bytecode: 0x5594016d6998>
Arguments '...' exists: TRUE
[08:27:25.392] getGlobalsAndPackages() ...
[08:27:25.392] Searching for globals...
[08:27:25.394] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[08:27:25.394] Searching for globals ... DONE
[08:27:25.394] Resolving globals: FALSE
[08:27:25.394] Tweak future expression to call with '...' arguments ...
[08:27:25.394] {
[08:27:25.394]     do.call(function(...) {
[08:27:25.394]         sum(x, ...)
[08:27:25.394]     }, args = future.call.arguments)
[08:27:25.394] }
[08:27:25.394] Tweak future expression to call with '...' arguments ... DONE
[08:27:25.395] The total size of the 2 globals is 246 bytes (246 bytes)
[08:27:25.395] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 246 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (133 bytes of class ‘numeric’) and ‘future.call.arguments’ (113 bytes of class ‘list’)
[08:27:25.395] - globals: [2] ‘x’, ‘future.call.arguments’
[08:27:25.395] 
[08:27:25.395] getGlobalsAndPackages() ... DONE
[08:27:25.396] run() for ‘Future’ ...
[08:27:25.396] - state: ‘created’
[08:27:25.396] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:25.396] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:25.396] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:25.396]   - Field: ‘label’
[08:27:25.396]   - Field: ‘local’
[08:27:25.396]   - Field: ‘owner’
[08:27:25.397]   - Field: ‘envir’
[08:27:25.397]   - Field: ‘packages’
[08:27:25.397]   - Field: ‘gc’
[08:27:25.397]   - Field: ‘conditions’
[08:27:25.397]   - Field: ‘expr’
[08:27:25.397]   - Field: ‘uuid’
[08:27:25.397]   - Field: ‘seed’
[08:27:25.397]   - Field: ‘version’
[08:27:25.397]   - Field: ‘result’
[08:27:25.397]   - Field: ‘asynchronous’
[08:27:25.397]   - Field: ‘calls’
[08:27:25.398]   - Field: ‘globals’
[08:27:25.398]   - Field: ‘stdout’
[08:27:25.398]   - Field: ‘earlySignal’
[08:27:25.398]   - Field: ‘lazy’
[08:27:25.398]   - Field: ‘state’
[08:27:25.398] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:25.398] - Launch lazy future ...
[08:27:25.398] Packages needed by the future expression (n = 0): <none>
[08:27:25.398] Packages needed by future strategies (n = 0): <none>
[08:27:25.399] {
[08:27:25.399]     {
[08:27:25.399]         {
[08:27:25.399]             ...future.startTime <- base::Sys.time()
[08:27:25.399]             {
[08:27:25.399]                 {
[08:27:25.399]                   {
[08:27:25.399]                     base::local({
[08:27:25.399]                       has_future <- base::requireNamespace("future", 
[08:27:25.399]                         quietly = TRUE)
[08:27:25.399]                       if (has_future) {
[08:27:25.399]                         ns <- base::getNamespace("future")
[08:27:25.399]                         version <- ns[[".package"]][["version"]]
[08:27:25.399]                         if (is.null(version)) 
[08:27:25.399]                           version <- utils::packageVersion("future")
[08:27:25.399]                       }
[08:27:25.399]                       else {
[08:27:25.399]                         version <- NULL
[08:27:25.399]                       }
[08:27:25.399]                       if (!has_future || version < "1.8.0") {
[08:27:25.399]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:25.399]                           "", base::R.version$version.string), 
[08:27:25.399]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:25.399]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:25.399]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:25.399]                             "release", "version")], collapse = " "), 
[08:27:25.399]                           hostname = base::Sys.info()[["nodename"]])
[08:27:25.399]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:25.399]                           info)
[08:27:25.399]                         info <- base::paste(info, collapse = "; ")
[08:27:25.399]                         if (!has_future) {
[08:27:25.399]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:25.399]                             info)
[08:27:25.399]                         }
[08:27:25.399]                         else {
[08:27:25.399]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:25.399]                             info, version)
[08:27:25.399]                         }
[08:27:25.399]                         base::stop(msg)
[08:27:25.399]                       }
[08:27:25.399]                     })
[08:27:25.399]                   }
[08:27:25.399]                   ...future.strategy.old <- future::plan("list")
[08:27:25.399]                   options(future.plan = NULL)
[08:27:25.399]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.399]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:25.399]                 }
[08:27:25.399]                 ...future.workdir <- getwd()
[08:27:25.399]             }
[08:27:25.399]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:25.399]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:25.399]         }
[08:27:25.399]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:25.399]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:25.399]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:25.399]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:25.399]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:25.399]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:25.399]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:25.399]             base::names(...future.oldOptions))
[08:27:25.399]     }
[08:27:25.399]     if (FALSE) {
[08:27:25.399]     }
[08:27:25.399]     else {
[08:27:25.399]         if (TRUE) {
[08:27:25.399]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:25.399]                 open = "w")
[08:27:25.399]         }
[08:27:25.399]         else {
[08:27:25.399]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:25.399]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:25.399]         }
[08:27:25.399]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:25.399]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:25.399]             base::sink(type = "output", split = FALSE)
[08:27:25.399]             base::close(...future.stdout)
[08:27:25.399]         }, add = TRUE)
[08:27:25.399]     }
[08:27:25.399]     ...future.frame <- base::sys.nframe()
[08:27:25.399]     ...future.conditions <- base::list()
[08:27:25.399]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:25.399]     if (FALSE) {
[08:27:25.399]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:25.399]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:25.399]     }
[08:27:25.399]     ...future.result <- base::tryCatch({
[08:27:25.399]         base::withCallingHandlers({
[08:27:25.399]             ...future.value <- base::withVisible(base::local({
[08:27:25.399]                 do.call(function(...) {
[08:27:25.399]                   sum(x, ...)
[08:27:25.399]                 }, args = future.call.arguments)
[08:27:25.399]             }))
[08:27:25.399]             future::FutureResult(value = ...future.value$value, 
[08:27:25.399]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.399]                   ...future.rng), globalenv = if (FALSE) 
[08:27:25.399]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:25.399]                     ...future.globalenv.names))
[08:27:25.399]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:25.399]         }, condition = base::local({
[08:27:25.399]             c <- base::c
[08:27:25.399]             inherits <- base::inherits
[08:27:25.399]             invokeRestart <- base::invokeRestart
[08:27:25.399]             length <- base::length
[08:27:25.399]             list <- base::list
[08:27:25.399]             seq.int <- base::seq.int
[08:27:25.399]             signalCondition <- base::signalCondition
[08:27:25.399]             sys.calls <- base::sys.calls
[08:27:25.399]             `[[` <- base::`[[`
[08:27:25.399]             `+` <- base::`+`
[08:27:25.399]             `<<-` <- base::`<<-`
[08:27:25.399]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:25.399]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:25.399]                   3L)]
[08:27:25.399]             }
[08:27:25.399]             function(cond) {
[08:27:25.399]                 is_error <- inherits(cond, "error")
[08:27:25.399]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:25.399]                   NULL)
[08:27:25.399]                 if (is_error) {
[08:27:25.399]                   sessionInformation <- function() {
[08:27:25.399]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:25.399]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:25.399]                       search = base::search(), system = base::Sys.info())
[08:27:25.399]                   }
[08:27:25.399]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.399]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:25.399]                     cond$call), session = sessionInformation(), 
[08:27:25.399]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:25.399]                   signalCondition(cond)
[08:27:25.399]                 }
[08:27:25.399]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:25.399]                 "immediateCondition"))) {
[08:27:25.399]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:25.399]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.399]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:25.399]                   if (TRUE && !signal) {
[08:27:25.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.399]                     {
[08:27:25.399]                       inherits <- base::inherits
[08:27:25.399]                       invokeRestart <- base::invokeRestart
[08:27:25.399]                       is.null <- base::is.null
[08:27:25.399]                       muffled <- FALSE
[08:27:25.399]                       if (inherits(cond, "message")) {
[08:27:25.399]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.399]                         if (muffled) 
[08:27:25.399]                           invokeRestart("muffleMessage")
[08:27:25.399]                       }
[08:27:25.399]                       else if (inherits(cond, "warning")) {
[08:27:25.399]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.399]                         if (muffled) 
[08:27:25.399]                           invokeRestart("muffleWarning")
[08:27:25.399]                       }
[08:27:25.399]                       else if (inherits(cond, "condition")) {
[08:27:25.399]                         if (!is.null(pattern)) {
[08:27:25.399]                           computeRestarts <- base::computeRestarts
[08:27:25.399]                           grepl <- base::grepl
[08:27:25.399]                           restarts <- computeRestarts(cond)
[08:27:25.399]                           for (restart in restarts) {
[08:27:25.399]                             name <- restart$name
[08:27:25.399]                             if (is.null(name)) 
[08:27:25.399]                               next
[08:27:25.399]                             if (!grepl(pattern, name)) 
[08:27:25.399]                               next
[08:27:25.399]                             invokeRestart(restart)
[08:27:25.399]                             muffled <- TRUE
[08:27:25.399]                             break
[08:27:25.399]                           }
[08:27:25.399]                         }
[08:27:25.399]                       }
[08:27:25.399]                       invisible(muffled)
[08:27:25.399]                     }
[08:27:25.399]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.399]                   }
[08:27:25.399]                 }
[08:27:25.399]                 else {
[08:27:25.399]                   if (TRUE) {
[08:27:25.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.399]                     {
[08:27:25.399]                       inherits <- base::inherits
[08:27:25.399]                       invokeRestart <- base::invokeRestart
[08:27:25.399]                       is.null <- base::is.null
[08:27:25.399]                       muffled <- FALSE
[08:27:25.399]                       if (inherits(cond, "message")) {
[08:27:25.399]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.399]                         if (muffled) 
[08:27:25.399]                           invokeRestart("muffleMessage")
[08:27:25.399]                       }
[08:27:25.399]                       else if (inherits(cond, "warning")) {
[08:27:25.399]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.399]                         if (muffled) 
[08:27:25.399]                           invokeRestart("muffleWarning")
[08:27:25.399]                       }
[08:27:25.399]                       else if (inherits(cond, "condition")) {
[08:27:25.399]                         if (!is.null(pattern)) {
[08:27:25.399]                           computeRestarts <- base::computeRestarts
[08:27:25.399]                           grepl <- base::grepl
[08:27:25.399]                           restarts <- computeRestarts(cond)
[08:27:25.399]                           for (restart in restarts) {
[08:27:25.399]                             name <- restart$name
[08:27:25.399]                             if (is.null(name)) 
[08:27:25.399]                               next
[08:27:25.399]                             if (!grepl(pattern, name)) 
[08:27:25.399]                               next
[08:27:25.399]                             invokeRestart(restart)
[08:27:25.399]                             muffled <- TRUE
[08:27:25.399]                             break
[08:27:25.399]                           }
[08:27:25.399]                         }
[08:27:25.399]                       }
[08:27:25.399]                       invisible(muffled)
[08:27:25.399]                     }
[08:27:25.399]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.399]                   }
[08:27:25.399]                 }
[08:27:25.399]             }
[08:27:25.399]         }))
[08:27:25.399]     }, error = function(ex) {
[08:27:25.399]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:25.399]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.399]                 ...future.rng), started = ...future.startTime, 
[08:27:25.399]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:25.399]             version = "1.8"), class = "FutureResult")
[08:27:25.399]     }, finally = {
[08:27:25.399]         if (!identical(...future.workdir, getwd())) 
[08:27:25.399]             setwd(...future.workdir)
[08:27:25.399]         {
[08:27:25.399]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:25.399]                 ...future.oldOptions$nwarnings <- NULL
[08:27:25.399]             }
[08:27:25.399]             base::options(...future.oldOptions)
[08:27:25.399]             if (.Platform$OS.type == "windows") {
[08:27:25.399]                 old_names <- names(...future.oldEnvVars)
[08:27:25.399]                 envs <- base::Sys.getenv()
[08:27:25.399]                 names <- names(envs)
[08:27:25.399]                 common <- intersect(names, old_names)
[08:27:25.399]                 added <- setdiff(names, old_names)
[08:27:25.399]                 removed <- setdiff(old_names, names)
[08:27:25.399]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:25.399]                   envs[common]]
[08:27:25.399]                 NAMES <- toupper(changed)
[08:27:25.399]                 args <- list()
[08:27:25.399]                 for (kk in seq_along(NAMES)) {
[08:27:25.399]                   name <- changed[[kk]]
[08:27:25.399]                   NAME <- NAMES[[kk]]
[08:27:25.399]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.399]                     next
[08:27:25.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.399]                 }
[08:27:25.399]                 NAMES <- toupper(added)
[08:27:25.399]                 for (kk in seq_along(NAMES)) {
[08:27:25.399]                   name <- added[[kk]]
[08:27:25.399]                   NAME <- NAMES[[kk]]
[08:27:25.399]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.399]                     next
[08:27:25.399]                   args[[name]] <- ""
[08:27:25.399]                 }
[08:27:25.399]                 NAMES <- toupper(removed)
[08:27:25.399]                 for (kk in seq_along(NAMES)) {
[08:27:25.399]                   name <- removed[[kk]]
[08:27:25.399]                   NAME <- NAMES[[kk]]
[08:27:25.399]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.399]                     next
[08:27:25.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.399]                 }
[08:27:25.399]                 if (length(args) > 0) 
[08:27:25.399]                   base::do.call(base::Sys.setenv, args = args)
[08:27:25.399]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:25.399]             }
[08:27:25.399]             else {
[08:27:25.399]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:25.399]             }
[08:27:25.399]             {
[08:27:25.399]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:25.399]                   0L) {
[08:27:25.399]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:25.399]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:25.399]                   base::options(opts)
[08:27:25.399]                 }
[08:27:25.399]                 {
[08:27:25.399]                   {
[08:27:25.399]                     NULL
[08:27:25.399]                     RNGkind("Mersenne-Twister")
[08:27:25.399]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:25.399]                       inherits = FALSE)
[08:27:25.399]                   }
[08:27:25.399]                   options(future.plan = NULL)
[08:27:25.399]                   if (is.na(NA_character_)) 
[08:27:25.399]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.399]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:25.399]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:25.399]                     .init = FALSE)
[08:27:25.399]                 }
[08:27:25.399]             }
[08:27:25.399]         }
[08:27:25.399]     })
[08:27:25.399]     if (TRUE) {
[08:27:25.399]         base::sink(type = "output", split = FALSE)
[08:27:25.399]         if (TRUE) {
[08:27:25.399]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:25.399]         }
[08:27:25.399]         else {
[08:27:25.399]             ...future.result["stdout"] <- base::list(NULL)
[08:27:25.399]         }
[08:27:25.399]         base::close(...future.stdout)
[08:27:25.399]         ...future.stdout <- NULL
[08:27:25.399]     }
[08:27:25.399]     ...future.result$conditions <- ...future.conditions
[08:27:25.399]     ...future.result$finished <- base::Sys.time()
[08:27:25.399]     ...future.result
[08:27:25.399] }
[08:27:25.400] assign_globals() ...
[08:27:25.400] List of 2
[08:27:25.400]  $ x                    : int [1:2] 1 2
[08:27:25.400]  $ future.call.arguments:List of 1
[08:27:25.400]   ..$ : num 3
[08:27:25.400]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:27:25.400]  - attr(*, "where")=List of 2
[08:27:25.400]   ..$ x                    :<environment: R_EmptyEnv> 
[08:27:25.400]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[08:27:25.400]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:25.400]  - attr(*, "resolved")= logi FALSE
[08:27:25.400]  - attr(*, "total_size")= num 246
[08:27:25.400]  - attr(*, "already-done")= logi TRUE
[08:27:25.407] - copied ‘x’ to environment
[08:27:25.407] - copied ‘future.call.arguments’ to environment
[08:27:25.407] assign_globals() ... done
[08:27:25.407] plan(): Setting new future strategy stack:
[08:27:25.408] List of future strategies:
[08:27:25.408] 1. sequential:
[08:27:25.408]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:25.408]    - tweaked: FALSE
[08:27:25.408]    - call: NULL
[08:27:25.408] plan(): nbrOfWorkers() = 1
[08:27:25.409] plan(): Setting new future strategy stack:
[08:27:25.409] List of future strategies:
[08:27:25.409] 1. sequential:
[08:27:25.409]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:25.409]    - tweaked: FALSE
[08:27:25.409]    - call: plan(strategy, substitute = FALSE)
[08:27:25.409] plan(): nbrOfWorkers() = 1
[08:27:25.409] SequentialFuture started (and completed)
[08:27:25.410] - Launch lazy future ... done
[08:27:25.410] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'C' with plan('sequential') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y)
    }
    y
}
<bytecode: 0x55940187c6a8>
Arguments '...' exists: FALSE
[08:27:25.410] getGlobalsAndPackages() ...
[08:27:25.410] Searching for globals...
[08:27:25.411] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘y’
[08:27:25.411] Searching for globals ... DONE
[08:27:25.412] Resolving globals: FALSE
[08:27:25.412] The total size of the 2 globals is 172 bytes (172 bytes)
[08:27:25.412] The total size of the 2 globals exported for future expression (‘{; sum(x, y); }’) is 172 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (133 bytes of class ‘numeric’) and ‘y’ (39 bytes of class ‘numeric’)
[08:27:25.412] - globals: [2] ‘x’, ‘y’
[08:27:25.413] 
[08:27:25.413] getGlobalsAndPackages() ... DONE
[08:27:25.413] run() for ‘Future’ ...
[08:27:25.413] - state: ‘created’
[08:27:25.413] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:25.413] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:25.413] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:25.414]   - Field: ‘label’
[08:27:25.414]   - Field: ‘local’
[08:27:25.414]   - Field: ‘owner’
[08:27:25.414]   - Field: ‘envir’
[08:27:25.414]   - Field: ‘packages’
[08:27:25.414]   - Field: ‘gc’
[08:27:25.414]   - Field: ‘conditions’
[08:27:25.414]   - Field: ‘expr’
[08:27:25.414]   - Field: ‘uuid’
[08:27:25.414]   - Field: ‘seed’
[08:27:25.414]   - Field: ‘version’
[08:27:25.415]   - Field: ‘result’
[08:27:25.415]   - Field: ‘asynchronous’
[08:27:25.415]   - Field: ‘calls’
[08:27:25.415]   - Field: ‘globals’
[08:27:25.415]   - Field: ‘stdout’
[08:27:25.415]   - Field: ‘earlySignal’
[08:27:25.415]   - Field: ‘lazy’
[08:27:25.415]   - Field: ‘state’
[08:27:25.415] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:25.415] - Launch lazy future ...
[08:27:25.415] Packages needed by the future expression (n = 0): <none>
[08:27:25.416] Packages needed by future strategies (n = 0): <none>
[08:27:25.416] {
[08:27:25.416]     {
[08:27:25.416]         {
[08:27:25.416]             ...future.startTime <- base::Sys.time()
[08:27:25.416]             {
[08:27:25.416]                 {
[08:27:25.416]                   {
[08:27:25.416]                     base::local({
[08:27:25.416]                       has_future <- base::requireNamespace("future", 
[08:27:25.416]                         quietly = TRUE)
[08:27:25.416]                       if (has_future) {
[08:27:25.416]                         ns <- base::getNamespace("future")
[08:27:25.416]                         version <- ns[[".package"]][["version"]]
[08:27:25.416]                         if (is.null(version)) 
[08:27:25.416]                           version <- utils::packageVersion("future")
[08:27:25.416]                       }
[08:27:25.416]                       else {
[08:27:25.416]                         version <- NULL
[08:27:25.416]                       }
[08:27:25.416]                       if (!has_future || version < "1.8.0") {
[08:27:25.416]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:25.416]                           "", base::R.version$version.string), 
[08:27:25.416]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:25.416]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:25.416]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:25.416]                             "release", "version")], collapse = " "), 
[08:27:25.416]                           hostname = base::Sys.info()[["nodename"]])
[08:27:25.416]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:25.416]                           info)
[08:27:25.416]                         info <- base::paste(info, collapse = "; ")
[08:27:25.416]                         if (!has_future) {
[08:27:25.416]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:25.416]                             info)
[08:27:25.416]                         }
[08:27:25.416]                         else {
[08:27:25.416]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:25.416]                             info, version)
[08:27:25.416]                         }
[08:27:25.416]                         base::stop(msg)
[08:27:25.416]                       }
[08:27:25.416]                     })
[08:27:25.416]                   }
[08:27:25.416]                   ...future.strategy.old <- future::plan("list")
[08:27:25.416]                   options(future.plan = NULL)
[08:27:25.416]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.416]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:25.416]                 }
[08:27:25.416]                 ...future.workdir <- getwd()
[08:27:25.416]             }
[08:27:25.416]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:25.416]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:25.416]         }
[08:27:25.416]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:25.416]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:25.416]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:25.416]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:25.416]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:25.416]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:25.416]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:25.416]             base::names(...future.oldOptions))
[08:27:25.416]     }
[08:27:25.416]     if (FALSE) {
[08:27:25.416]     }
[08:27:25.416]     else {
[08:27:25.416]         if (TRUE) {
[08:27:25.416]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:25.416]                 open = "w")
[08:27:25.416]         }
[08:27:25.416]         else {
[08:27:25.416]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:25.416]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:25.416]         }
[08:27:25.416]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:25.416]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:25.416]             base::sink(type = "output", split = FALSE)
[08:27:25.416]             base::close(...future.stdout)
[08:27:25.416]         }, add = TRUE)
[08:27:25.416]     }
[08:27:25.416]     ...future.frame <- base::sys.nframe()
[08:27:25.416]     ...future.conditions <- base::list()
[08:27:25.416]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:25.416]     if (FALSE) {
[08:27:25.416]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:25.416]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:25.416]     }
[08:27:25.416]     ...future.result <- base::tryCatch({
[08:27:25.416]         base::withCallingHandlers({
[08:27:25.416]             ...future.value <- base::withVisible(base::local({
[08:27:25.416]                 sum(x, y)
[08:27:25.416]             }))
[08:27:25.416]             future::FutureResult(value = ...future.value$value, 
[08:27:25.416]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.416]                   ...future.rng), globalenv = if (FALSE) 
[08:27:25.416]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:25.416]                     ...future.globalenv.names))
[08:27:25.416]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:25.416]         }, condition = base::local({
[08:27:25.416]             c <- base::c
[08:27:25.416]             inherits <- base::inherits
[08:27:25.416]             invokeRestart <- base::invokeRestart
[08:27:25.416]             length <- base::length
[08:27:25.416]             list <- base::list
[08:27:25.416]             seq.int <- base::seq.int
[08:27:25.416]             signalCondition <- base::signalCondition
[08:27:25.416]             sys.calls <- base::sys.calls
[08:27:25.416]             `[[` <- base::`[[`
[08:27:25.416]             `+` <- base::`+`
[08:27:25.416]             `<<-` <- base::`<<-`
[08:27:25.416]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:25.416]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:25.416]                   3L)]
[08:27:25.416]             }
[08:27:25.416]             function(cond) {
[08:27:25.416]                 is_error <- inherits(cond, "error")
[08:27:25.416]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:25.416]                   NULL)
[08:27:25.416]                 if (is_error) {
[08:27:25.416]                   sessionInformation <- function() {
[08:27:25.416]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:25.416]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:25.416]                       search = base::search(), system = base::Sys.info())
[08:27:25.416]                   }
[08:27:25.416]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.416]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:25.416]                     cond$call), session = sessionInformation(), 
[08:27:25.416]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:25.416]                   signalCondition(cond)
[08:27:25.416]                 }
[08:27:25.416]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:25.416]                 "immediateCondition"))) {
[08:27:25.416]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:25.416]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.416]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:25.416]                   if (TRUE && !signal) {
[08:27:25.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.416]                     {
[08:27:25.416]                       inherits <- base::inherits
[08:27:25.416]                       invokeRestart <- base::invokeRestart
[08:27:25.416]                       is.null <- base::is.null
[08:27:25.416]                       muffled <- FALSE
[08:27:25.416]                       if (inherits(cond, "message")) {
[08:27:25.416]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.416]                         if (muffled) 
[08:27:25.416]                           invokeRestart("muffleMessage")
[08:27:25.416]                       }
[08:27:25.416]                       else if (inherits(cond, "warning")) {
[08:27:25.416]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.416]                         if (muffled) 
[08:27:25.416]                           invokeRestart("muffleWarning")
[08:27:25.416]                       }
[08:27:25.416]                       else if (inherits(cond, "condition")) {
[08:27:25.416]                         if (!is.null(pattern)) {
[08:27:25.416]                           computeRestarts <- base::computeRestarts
[08:27:25.416]                           grepl <- base::grepl
[08:27:25.416]                           restarts <- computeRestarts(cond)
[08:27:25.416]                           for (restart in restarts) {
[08:27:25.416]                             name <- restart$name
[08:27:25.416]                             if (is.null(name)) 
[08:27:25.416]                               next
[08:27:25.416]                             if (!grepl(pattern, name)) 
[08:27:25.416]                               next
[08:27:25.416]                             invokeRestart(restart)
[08:27:25.416]                             muffled <- TRUE
[08:27:25.416]                             break
[08:27:25.416]                           }
[08:27:25.416]                         }
[08:27:25.416]                       }
[08:27:25.416]                       invisible(muffled)
[08:27:25.416]                     }
[08:27:25.416]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.416]                   }
[08:27:25.416]                 }
[08:27:25.416]                 else {
[08:27:25.416]                   if (TRUE) {
[08:27:25.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.416]                     {
[08:27:25.416]                       inherits <- base::inherits
[08:27:25.416]                       invokeRestart <- base::invokeRestart
[08:27:25.416]                       is.null <- base::is.null
[08:27:25.416]                       muffled <- FALSE
[08:27:25.416]                       if (inherits(cond, "message")) {
[08:27:25.416]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.416]                         if (muffled) 
[08:27:25.416]                           invokeRestart("muffleMessage")
[08:27:25.416]                       }
[08:27:25.416]                       else if (inherits(cond, "warning")) {
[08:27:25.416]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.416]                         if (muffled) 
[08:27:25.416]                           invokeRestart("muffleWarning")
[08:27:25.416]                       }
[08:27:25.416]                       else if (inherits(cond, "condition")) {
[08:27:25.416]                         if (!is.null(pattern)) {
[08:27:25.416]                           computeRestarts <- base::computeRestarts
[08:27:25.416]                           grepl <- base::grepl
[08:27:25.416]                           restarts <- computeRestarts(cond)
[08:27:25.416]                           for (restart in restarts) {
[08:27:25.416]                             name <- restart$name
[08:27:25.416]                             if (is.null(name)) 
[08:27:25.416]                               next
[08:27:25.416]                             if (!grepl(pattern, name)) 
[08:27:25.416]                               next
[08:27:25.416]                             invokeRestart(restart)
[08:27:25.416]                             muffled <- TRUE
[08:27:25.416]                             break
[08:27:25.416]                           }
[08:27:25.416]                         }
[08:27:25.416]                       }
[08:27:25.416]                       invisible(muffled)
[08:27:25.416]                     }
[08:27:25.416]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.416]                   }
[08:27:25.416]                 }
[08:27:25.416]             }
[08:27:25.416]         }))
[08:27:25.416]     }, error = function(ex) {
[08:27:25.416]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:25.416]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.416]                 ...future.rng), started = ...future.startTime, 
[08:27:25.416]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:25.416]             version = "1.8"), class = "FutureResult")
[08:27:25.416]     }, finally = {
[08:27:25.416]         if (!identical(...future.workdir, getwd())) 
[08:27:25.416]             setwd(...future.workdir)
[08:27:25.416]         {
[08:27:25.416]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:25.416]                 ...future.oldOptions$nwarnings <- NULL
[08:27:25.416]             }
[08:27:25.416]             base::options(...future.oldOptions)
[08:27:25.416]             if (.Platform$OS.type == "windows") {
[08:27:25.416]                 old_names <- names(...future.oldEnvVars)
[08:27:25.416]                 envs <- base::Sys.getenv()
[08:27:25.416]                 names <- names(envs)
[08:27:25.416]                 common <- intersect(names, old_names)
[08:27:25.416]                 added <- setdiff(names, old_names)
[08:27:25.416]                 removed <- setdiff(old_names, names)
[08:27:25.416]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:25.416]                   envs[common]]
[08:27:25.416]                 NAMES <- toupper(changed)
[08:27:25.416]                 args <- list()
[08:27:25.416]                 for (kk in seq_along(NAMES)) {
[08:27:25.416]                   name <- changed[[kk]]
[08:27:25.416]                   NAME <- NAMES[[kk]]
[08:27:25.416]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.416]                     next
[08:27:25.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.416]                 }
[08:27:25.416]                 NAMES <- toupper(added)
[08:27:25.416]                 for (kk in seq_along(NAMES)) {
[08:27:25.416]                   name <- added[[kk]]
[08:27:25.416]                   NAME <- NAMES[[kk]]
[08:27:25.416]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.416]                     next
[08:27:25.416]                   args[[name]] <- ""
[08:27:25.416]                 }
[08:27:25.416]                 NAMES <- toupper(removed)
[08:27:25.416]                 for (kk in seq_along(NAMES)) {
[08:27:25.416]                   name <- removed[[kk]]
[08:27:25.416]                   NAME <- NAMES[[kk]]
[08:27:25.416]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.416]                     next
[08:27:25.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.416]                 }
[08:27:25.416]                 if (length(args) > 0) 
[08:27:25.416]                   base::do.call(base::Sys.setenv, args = args)
[08:27:25.416]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:25.416]             }
[08:27:25.416]             else {
[08:27:25.416]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:25.416]             }
[08:27:25.416]             {
[08:27:25.416]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:25.416]                   0L) {
[08:27:25.416]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:25.416]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:25.416]                   base::options(opts)
[08:27:25.416]                 }
[08:27:25.416]                 {
[08:27:25.416]                   {
[08:27:25.416]                     NULL
[08:27:25.416]                     RNGkind("Mersenne-Twister")
[08:27:25.416]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:25.416]                       inherits = FALSE)
[08:27:25.416]                   }
[08:27:25.416]                   options(future.plan = NULL)
[08:27:25.416]                   if (is.na(NA_character_)) 
[08:27:25.416]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.416]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:25.416]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:25.416]                     .init = FALSE)
[08:27:25.416]                 }
[08:27:25.416]             }
[08:27:25.416]         }
[08:27:25.416]     })
[08:27:25.416]     if (TRUE) {
[08:27:25.416]         base::sink(type = "output", split = FALSE)
[08:27:25.416]         if (TRUE) {
[08:27:25.416]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:25.416]         }
[08:27:25.416]         else {
[08:27:25.416]             ...future.result["stdout"] <- base::list(NULL)
[08:27:25.416]         }
[08:27:25.416]         base::close(...future.stdout)
[08:27:25.416]         ...future.stdout <- NULL
[08:27:25.416]     }
[08:27:25.416]     ...future.result$conditions <- ...future.conditions
[08:27:25.416]     ...future.result$finished <- base::Sys.time()
[08:27:25.416]     ...future.result
[08:27:25.416] }
[08:27:25.418] assign_globals() ...
[08:27:25.418] List of 2
[08:27:25.418]  $ x: int [1:2] 1 2
[08:27:25.418]  $ y: num 3
[08:27:25.418]  - attr(*, "where")=List of 2
[08:27:25.418]   ..$ x:<environment: R_EmptyEnv> 
[08:27:25.418]   ..$ y:<environment: R_EmptyEnv> 
[08:27:25.418]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:25.418]  - attr(*, "resolved")= logi FALSE
[08:27:25.418]  - attr(*, "total_size")= num 172
[08:27:25.418]  - attr(*, "already-done")= logi TRUE
[08:27:25.421] - copied ‘x’ to environment
[08:27:25.421] - copied ‘y’ to environment
[08:27:25.421] assign_globals() ... done
[08:27:25.421] plan(): Setting new future strategy stack:
[08:27:25.421] List of future strategies:
[08:27:25.421] 1. sequential:
[08:27:25.421]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:25.421]    - tweaked: FALSE
[08:27:25.421]    - call: NULL
[08:27:25.421] plan(): nbrOfWorkers() = 1
[08:27:25.422] plan(): Setting new future strategy stack:
[08:27:25.422] List of future strategies:
[08:27:25.422] 1. sequential:
[08:27:25.422]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:25.422]    - tweaked: FALSE
[08:27:25.422]    - call: plan(strategy, substitute = FALSE)
[08:27:25.423] plan(): nbrOfWorkers() = 1
[08:27:25.423] SequentialFuture started (and completed)
[08:27:25.423] - Launch lazy future ... done
[08:27:25.423] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'D' with plan('sequential') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y, ...)
    }
    y
}
<bytecode: 0x559401ce4780>
Arguments '...' exists: FALSE
[08:27:25.424] getGlobalsAndPackages() ...
[08:27:25.424] Searching for globals...
[08:27:25.425] - globals found: [5] ‘{’, ‘sum’, ‘x’, ‘y’, ‘...’
[08:27:25.425] Searching for globals ... DONE
[08:27:25.425] Resolving globals: FALSE
[08:27:25.425] Tweak future expression to call with '...' arguments ...
[08:27:25.426] The total size of the 2 globals is 172 bytes (172 bytes)
[08:27:25.426] The total size of the 2 globals exported for future expression (‘{; sum(x, y, ...); }’) is 172 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (133 bytes of class ‘numeric’) and ‘y’ (39 bytes of class ‘numeric’)
[08:27:25.426] - globals: [2] ‘x’, ‘y’
[08:27:25.426] 
[08:27:25.427] getGlobalsAndPackages() ... DONE
[08:27:25.427] run() for ‘Future’ ...
[08:27:25.427] - state: ‘created’
[08:27:25.427] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:25.427] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:25.427] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:25.427]   - Field: ‘label’
[08:27:25.428]   - Field: ‘local’
[08:27:25.428]   - Field: ‘owner’
[08:27:25.428]   - Field: ‘envir’
[08:27:25.428]   - Field: ‘packages’
[08:27:25.428]   - Field: ‘gc’
[08:27:25.428]   - Field: ‘conditions’
[08:27:25.428]   - Field: ‘expr’
[08:27:25.428]   - Field: ‘uuid’
[08:27:25.428]   - Field: ‘seed’
[08:27:25.428]   - Field: ‘version’
[08:27:25.428]   - Field: ‘result’
[08:27:25.428]   - Field: ‘asynchronous’
[08:27:25.429]   - Field: ‘calls’
[08:27:25.429]   - Field: ‘globals’
[08:27:25.429]   - Field: ‘stdout’
[08:27:25.429]   - Field: ‘earlySignal’
[08:27:25.429]   - Field: ‘lazy’
[08:27:25.429]   - Field: ‘state’
[08:27:25.429] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:25.429] - Launch lazy future ...
[08:27:25.429] Packages needed by the future expression (n = 0): <none>
[08:27:25.429] Packages needed by future strategies (n = 0): <none>
[08:27:25.430] {
[08:27:25.430]     {
[08:27:25.430]         {
[08:27:25.430]             ...future.startTime <- base::Sys.time()
[08:27:25.430]             {
[08:27:25.430]                 {
[08:27:25.430]                   {
[08:27:25.430]                     base::local({
[08:27:25.430]                       has_future <- base::requireNamespace("future", 
[08:27:25.430]                         quietly = TRUE)
[08:27:25.430]                       if (has_future) {
[08:27:25.430]                         ns <- base::getNamespace("future")
[08:27:25.430]                         version <- ns[[".package"]][["version"]]
[08:27:25.430]                         if (is.null(version)) 
[08:27:25.430]                           version <- utils::packageVersion("future")
[08:27:25.430]                       }
[08:27:25.430]                       else {
[08:27:25.430]                         version <- NULL
[08:27:25.430]                       }
[08:27:25.430]                       if (!has_future || version < "1.8.0") {
[08:27:25.430]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:25.430]                           "", base::R.version$version.string), 
[08:27:25.430]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:25.430]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:25.430]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:25.430]                             "release", "version")], collapse = " "), 
[08:27:25.430]                           hostname = base::Sys.info()[["nodename"]])
[08:27:25.430]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:25.430]                           info)
[08:27:25.430]                         info <- base::paste(info, collapse = "; ")
[08:27:25.430]                         if (!has_future) {
[08:27:25.430]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:25.430]                             info)
[08:27:25.430]                         }
[08:27:25.430]                         else {
[08:27:25.430]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:25.430]                             info, version)
[08:27:25.430]                         }
[08:27:25.430]                         base::stop(msg)
[08:27:25.430]                       }
[08:27:25.430]                     })
[08:27:25.430]                   }
[08:27:25.430]                   ...future.strategy.old <- future::plan("list")
[08:27:25.430]                   options(future.plan = NULL)
[08:27:25.430]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.430]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:25.430]                 }
[08:27:25.430]                 ...future.workdir <- getwd()
[08:27:25.430]             }
[08:27:25.430]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:25.430]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:25.430]         }
[08:27:25.430]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:25.430]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:25.430]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:25.430]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:25.430]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:25.430]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:25.430]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:25.430]             base::names(...future.oldOptions))
[08:27:25.430]     }
[08:27:25.430]     if (FALSE) {
[08:27:25.430]     }
[08:27:25.430]     else {
[08:27:25.430]         if (TRUE) {
[08:27:25.430]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:25.430]                 open = "w")
[08:27:25.430]         }
[08:27:25.430]         else {
[08:27:25.430]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:25.430]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:25.430]         }
[08:27:25.430]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:25.430]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:25.430]             base::sink(type = "output", split = FALSE)
[08:27:25.430]             base::close(...future.stdout)
[08:27:25.430]         }, add = TRUE)
[08:27:25.430]     }
[08:27:25.430]     ...future.frame <- base::sys.nframe()
[08:27:25.430]     ...future.conditions <- base::list()
[08:27:25.430]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:25.430]     if (FALSE) {
[08:27:25.430]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:25.430]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:25.430]     }
[08:27:25.430]     ...future.result <- base::tryCatch({
[08:27:25.430]         base::withCallingHandlers({
[08:27:25.430]             ...future.value <- base::withVisible(base::local({
[08:27:25.430]                 sum(x, y, ...)
[08:27:25.430]             }))
[08:27:25.430]             future::FutureResult(value = ...future.value$value, 
[08:27:25.430]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.430]                   ...future.rng), globalenv = if (FALSE) 
[08:27:25.430]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:25.430]                     ...future.globalenv.names))
[08:27:25.430]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:25.430]         }, condition = base::local({
[08:27:25.430]             c <- base::c
[08:27:25.430]             inherits <- base::inherits
[08:27:25.430]             invokeRestart <- base::invokeRestart
[08:27:25.430]             length <- base::length
[08:27:25.430]             list <- base::list
[08:27:25.430]             seq.int <- base::seq.int
[08:27:25.430]             signalCondition <- base::signalCondition
[08:27:25.430]             sys.calls <- base::sys.calls
[08:27:25.430]             `[[` <- base::`[[`
[08:27:25.430]             `+` <- base::`+`
[08:27:25.430]             `<<-` <- base::`<<-`
[08:27:25.430]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:25.430]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:25.430]                   3L)]
[08:27:25.430]             }
[08:27:25.430]             function(cond) {
[08:27:25.430]                 is_error <- inherits(cond, "error")
[08:27:25.430]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:25.430]                   NULL)
[08:27:25.430]                 if (is_error) {
[08:27:25.430]                   sessionInformation <- function() {
[08:27:25.430]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:25.430]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:25.430]                       search = base::search(), system = base::Sys.info())
[08:27:25.430]                   }
[08:27:25.430]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.430]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:25.430]                     cond$call), session = sessionInformation(), 
[08:27:25.430]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:25.430]                   signalCondition(cond)
[08:27:25.430]                 }
[08:27:25.430]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:25.430]                 "immediateCondition"))) {
[08:27:25.430]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:25.430]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.430]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:25.430]                   if (TRUE && !signal) {
[08:27:25.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.430]                     {
[08:27:25.430]                       inherits <- base::inherits
[08:27:25.430]                       invokeRestart <- base::invokeRestart
[08:27:25.430]                       is.null <- base::is.null
[08:27:25.430]                       muffled <- FALSE
[08:27:25.430]                       if (inherits(cond, "message")) {
[08:27:25.430]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.430]                         if (muffled) 
[08:27:25.430]                           invokeRestart("muffleMessage")
[08:27:25.430]                       }
[08:27:25.430]                       else if (inherits(cond, "warning")) {
[08:27:25.430]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.430]                         if (muffled) 
[08:27:25.430]                           invokeRestart("muffleWarning")
[08:27:25.430]                       }
[08:27:25.430]                       else if (inherits(cond, "condition")) {
[08:27:25.430]                         if (!is.null(pattern)) {
[08:27:25.430]                           computeRestarts <- base::computeRestarts
[08:27:25.430]                           grepl <- base::grepl
[08:27:25.430]                           restarts <- computeRestarts(cond)
[08:27:25.430]                           for (restart in restarts) {
[08:27:25.430]                             name <- restart$name
[08:27:25.430]                             if (is.null(name)) 
[08:27:25.430]                               next
[08:27:25.430]                             if (!grepl(pattern, name)) 
[08:27:25.430]                               next
[08:27:25.430]                             invokeRestart(restart)
[08:27:25.430]                             muffled <- TRUE
[08:27:25.430]                             break
[08:27:25.430]                           }
[08:27:25.430]                         }
[08:27:25.430]                       }
[08:27:25.430]                       invisible(muffled)
[08:27:25.430]                     }
[08:27:25.430]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.430]                   }
[08:27:25.430]                 }
[08:27:25.430]                 else {
[08:27:25.430]                   if (TRUE) {
[08:27:25.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.430]                     {
[08:27:25.430]                       inherits <- base::inherits
[08:27:25.430]                       invokeRestart <- base::invokeRestart
[08:27:25.430]                       is.null <- base::is.null
[08:27:25.430]                       muffled <- FALSE
[08:27:25.430]                       if (inherits(cond, "message")) {
[08:27:25.430]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.430]                         if (muffled) 
[08:27:25.430]                           invokeRestart("muffleMessage")
[08:27:25.430]                       }
[08:27:25.430]                       else if (inherits(cond, "warning")) {
[08:27:25.430]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.430]                         if (muffled) 
[08:27:25.430]                           invokeRestart("muffleWarning")
[08:27:25.430]                       }
[08:27:25.430]                       else if (inherits(cond, "condition")) {
[08:27:25.430]                         if (!is.null(pattern)) {
[08:27:25.430]                           computeRestarts <- base::computeRestarts
[08:27:25.430]                           grepl <- base::grepl
[08:27:25.430]                           restarts <- computeRestarts(cond)
[08:27:25.430]                           for (restart in restarts) {
[08:27:25.430]                             name <- restart$name
[08:27:25.430]                             if (is.null(name)) 
[08:27:25.430]                               next
[08:27:25.430]                             if (!grepl(pattern, name)) 
[08:27:25.430]                               next
[08:27:25.430]                             invokeRestart(restart)
[08:27:25.430]                             muffled <- TRUE
[08:27:25.430]                             break
[08:27:25.430]                           }
[08:27:25.430]                         }
[08:27:25.430]                       }
[08:27:25.430]                       invisible(muffled)
[08:27:25.430]                     }
[08:27:25.430]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.430]                   }
[08:27:25.430]                 }
[08:27:25.430]             }
[08:27:25.430]         }))
[08:27:25.430]     }, error = function(ex) {
[08:27:25.430]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:25.430]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.430]                 ...future.rng), started = ...future.startTime, 
[08:27:25.430]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:25.430]             version = "1.8"), class = "FutureResult")
[08:27:25.430]     }, finally = {
[08:27:25.430]         if (!identical(...future.workdir, getwd())) 
[08:27:25.430]             setwd(...future.workdir)
[08:27:25.430]         {
[08:27:25.430]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:25.430]                 ...future.oldOptions$nwarnings <- NULL
[08:27:25.430]             }
[08:27:25.430]             base::options(...future.oldOptions)
[08:27:25.430]             if (.Platform$OS.type == "windows") {
[08:27:25.430]                 old_names <- names(...future.oldEnvVars)
[08:27:25.430]                 envs <- base::Sys.getenv()
[08:27:25.430]                 names <- names(envs)
[08:27:25.430]                 common <- intersect(names, old_names)
[08:27:25.430]                 added <- setdiff(names, old_names)
[08:27:25.430]                 removed <- setdiff(old_names, names)
[08:27:25.430]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:25.430]                   envs[common]]
[08:27:25.430]                 NAMES <- toupper(changed)
[08:27:25.430]                 args <- list()
[08:27:25.430]                 for (kk in seq_along(NAMES)) {
[08:27:25.430]                   name <- changed[[kk]]
[08:27:25.430]                   NAME <- NAMES[[kk]]
[08:27:25.430]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.430]                     next
[08:27:25.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.430]                 }
[08:27:25.430]                 NAMES <- toupper(added)
[08:27:25.430]                 for (kk in seq_along(NAMES)) {
[08:27:25.430]                   name <- added[[kk]]
[08:27:25.430]                   NAME <- NAMES[[kk]]
[08:27:25.430]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.430]                     next
[08:27:25.430]                   args[[name]] <- ""
[08:27:25.430]                 }
[08:27:25.430]                 NAMES <- toupper(removed)
[08:27:25.430]                 for (kk in seq_along(NAMES)) {
[08:27:25.430]                   name <- removed[[kk]]
[08:27:25.430]                   NAME <- NAMES[[kk]]
[08:27:25.430]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.430]                     next
[08:27:25.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.430]                 }
[08:27:25.430]                 if (length(args) > 0) 
[08:27:25.430]                   base::do.call(base::Sys.setenv, args = args)
[08:27:25.430]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:25.430]             }
[08:27:25.430]             else {
[08:27:25.430]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:25.430]             }
[08:27:25.430]             {
[08:27:25.430]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:25.430]                   0L) {
[08:27:25.430]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:25.430]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:25.430]                   base::options(opts)
[08:27:25.430]                 }
[08:27:25.430]                 {
[08:27:25.430]                   {
[08:27:25.430]                     NULL
[08:27:25.430]                     RNGkind("Mersenne-Twister")
[08:27:25.430]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:25.430]                       inherits = FALSE)
[08:27:25.430]                   }
[08:27:25.430]                   options(future.plan = NULL)
[08:27:25.430]                   if (is.na(NA_character_)) 
[08:27:25.430]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.430]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:25.430]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:25.430]                     .init = FALSE)
[08:27:25.430]                 }
[08:27:25.430]             }
[08:27:25.430]         }
[08:27:25.430]     })
[08:27:25.430]     if (TRUE) {
[08:27:25.430]         base::sink(type = "output", split = FALSE)
[08:27:25.430]         if (TRUE) {
[08:27:25.430]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:25.430]         }
[08:27:25.430]         else {
[08:27:25.430]             ...future.result["stdout"] <- base::list(NULL)
[08:27:25.430]         }
[08:27:25.430]         base::close(...future.stdout)
[08:27:25.430]         ...future.stdout <- NULL
[08:27:25.430]     }
[08:27:25.430]     ...future.result$conditions <- ...future.conditions
[08:27:25.430]     ...future.result$finished <- base::Sys.time()
[08:27:25.430]     ...future.result
[08:27:25.430] }
[08:27:25.431] assign_globals() ...
[08:27:25.432] List of 2
[08:27:25.432]  $ x: int [1:2] 1 2
[08:27:25.432]  $ y: num 3
[08:27:25.432]  - attr(*, "where")=List of 2
[08:27:25.432]   ..$ x:<environment: R_EmptyEnv> 
[08:27:25.432]   ..$ y:<environment: R_EmptyEnv> 
[08:27:25.432]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:25.432]  - attr(*, "resolved")= logi FALSE
[08:27:25.432]  - attr(*, "total_size")= num 172
[08:27:25.432]  - attr(*, "already-done")= logi TRUE
[08:27:25.436] - copied ‘x’ to environment
[08:27:25.436] - copied ‘y’ to environment
[08:27:25.436] assign_globals() ... done
[08:27:25.437] plan(): Setting new future strategy stack:
[08:27:25.437] List of future strategies:
[08:27:25.437] 1. sequential:
[08:27:25.437]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:25.437]    - tweaked: FALSE
[08:27:25.437]    - call: NULL
[08:27:25.437] plan(): nbrOfWorkers() = 1
[08:27:25.438] plan(): Setting new future strategy stack:
[08:27:25.438] List of future strategies:
[08:27:25.438] 1. sequential:
[08:27:25.438]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:25.438]    - tweaked: FALSE
[08:27:25.438]    - call: plan(strategy, substitute = FALSE)
[08:27:25.439] plan(): nbrOfWorkers() = 1
[08:27:25.439] SequentialFuture started (and completed)
[08:27:25.439] signalConditions() ...
[08:27:25.439]  - include = ‘immediateCondition’
[08:27:25.439]  - exclude = 
[08:27:25.439]  - resignal = FALSE
[08:27:25.439]  - Number of conditions: 1
[08:27:25.439] signalConditions() ... done
[08:27:25.439] - Launch lazy future ... done
[08:27:25.439] run() for ‘SequentialFuture’ ... done
[08:27:25.440] signalConditions() ...
[08:27:25.440]  - include = ‘immediateCondition’
[08:27:25.440]  - exclude = 
[08:27:25.440]  - resignal = FALSE
[08:27:25.440]  - Number of conditions: 1
[08:27:25.440] signalConditions() ... done
[08:27:25.440] Future state: ‘finished’
[08:27:25.440] signalConditions() ...
[08:27:25.440]  - include = ‘condition’
[08:27:25.440]  - exclude = ‘immediateCondition’
[08:27:25.441]  - resignal = TRUE
[08:27:25.441]  - Number of conditions: 1
[08:27:25.441]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:27:25.441] signalConditions() ... done
Error in eval(quote({ : '...' used in an incorrect context
[1] "Error in eval(quote({ : '...' used in an incorrect context\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in eval(quote({    sum(x, y, ...)}), new.env()): '...' used in an incorrect context>
** Sum function 'E' with plan('sequential') ...
function (...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    globals <- globals::globalsByName("...", envir = environment())
    f <- future({
        fcn <- function() sum(...)
        fcn()
    }, envir = parent.frame(), globals = globals)
    y <- value(f)
    y
}
<bytecode: 0x5593ffd5df30>
Arguments '...' exists: TRUE
[08:27:25.441] getGlobalsAndPackages() ...
[08:27:25.442] - globals passed as-is: [1] ‘...’
[08:27:25.442] Resolving globals: FALSE
[08:27:25.442] Tweak future expression to call with '...' arguments ...
[08:27:25.442] {
[08:27:25.442]     do.call(function(...) {
[08:27:25.442]         fcn <- function() sum(...)
[08:27:25.442]         fcn()
[08:27:25.442]     }, args = future.call.arguments)
[08:27:25.442] }
[08:27:25.442] Tweak future expression to call with '...' arguments ... DONE
[08:27:25.442] The total size of the 1 globals is 223 bytes (223 bytes)
[08:27:25.443] The total size of the 1 globals exported for future expression (‘{; fcn <- function() sum(...); fcn(); }’) is 223 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘future.call.arguments’ (223 bytes of class ‘list’)
[08:27:25.443] - globals: [1] ‘future.call.arguments’
[08:27:25.443] 
[08:27:25.443] getGlobalsAndPackages() ... DONE
[08:27:25.443] run() for ‘Future’ ...
[08:27:25.443] - state: ‘created’
[08:27:25.443] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:25.444] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:25.444] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:25.444]   - Field: ‘label’
[08:27:25.444]   - Field: ‘local’
[08:27:25.444]   - Field: ‘owner’
[08:27:25.444]   - Field: ‘envir’
[08:27:25.444]   - Field: ‘packages’
[08:27:25.444]   - Field: ‘gc’
[08:27:25.444]   - Field: ‘conditions’
[08:27:25.444]   - Field: ‘expr’
[08:27:25.445]   - Field: ‘uuid’
[08:27:25.445]   - Field: ‘seed’
[08:27:25.445]   - Field: ‘version’
[08:27:25.445]   - Field: ‘result’
[08:27:25.445]   - Field: ‘asynchronous’
[08:27:25.445]   - Field: ‘calls’
[08:27:25.445]   - Field: ‘globals’
[08:27:25.445]   - Field: ‘stdout’
[08:27:25.445]   - Field: ‘earlySignal’
[08:27:25.445]   - Field: ‘lazy’
[08:27:25.445]   - Field: ‘state’
[08:27:25.446] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:25.446] - Launch lazy future ...
[08:27:25.446] Packages needed by the future expression (n = 0): <none>
[08:27:25.446] Packages needed by future strategies (n = 0): <none>
[08:27:25.446] {
[08:27:25.446]     {
[08:27:25.446]         {
[08:27:25.446]             ...future.startTime <- base::Sys.time()
[08:27:25.446]             {
[08:27:25.446]                 {
[08:27:25.446]                   {
[08:27:25.446]                     base::local({
[08:27:25.446]                       has_future <- base::requireNamespace("future", 
[08:27:25.446]                         quietly = TRUE)
[08:27:25.446]                       if (has_future) {
[08:27:25.446]                         ns <- base::getNamespace("future")
[08:27:25.446]                         version <- ns[[".package"]][["version"]]
[08:27:25.446]                         if (is.null(version)) 
[08:27:25.446]                           version <- utils::packageVersion("future")
[08:27:25.446]                       }
[08:27:25.446]                       else {
[08:27:25.446]                         version <- NULL
[08:27:25.446]                       }
[08:27:25.446]                       if (!has_future || version < "1.8.0") {
[08:27:25.446]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:25.446]                           "", base::R.version$version.string), 
[08:27:25.446]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:25.446]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:25.446]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:25.446]                             "release", "version")], collapse = " "), 
[08:27:25.446]                           hostname = base::Sys.info()[["nodename"]])
[08:27:25.446]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:25.446]                           info)
[08:27:25.446]                         info <- base::paste(info, collapse = "; ")
[08:27:25.446]                         if (!has_future) {
[08:27:25.446]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:25.446]                             info)
[08:27:25.446]                         }
[08:27:25.446]                         else {
[08:27:25.446]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:25.446]                             info, version)
[08:27:25.446]                         }
[08:27:25.446]                         base::stop(msg)
[08:27:25.446]                       }
[08:27:25.446]                     })
[08:27:25.446]                   }
[08:27:25.446]                   ...future.strategy.old <- future::plan("list")
[08:27:25.446]                   options(future.plan = NULL)
[08:27:25.446]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.446]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:25.446]                 }
[08:27:25.446]                 ...future.workdir <- getwd()
[08:27:25.446]             }
[08:27:25.446]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:25.446]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:25.446]         }
[08:27:25.446]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:25.446]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:25.446]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:25.446]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:25.446]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:25.446]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:25.446]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:25.446]             base::names(...future.oldOptions))
[08:27:25.446]     }
[08:27:25.446]     if (FALSE) {
[08:27:25.446]     }
[08:27:25.446]     else {
[08:27:25.446]         if (TRUE) {
[08:27:25.446]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:25.446]                 open = "w")
[08:27:25.446]         }
[08:27:25.446]         else {
[08:27:25.446]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:25.446]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:25.446]         }
[08:27:25.446]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:25.446]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:25.446]             base::sink(type = "output", split = FALSE)
[08:27:25.446]             base::close(...future.stdout)
[08:27:25.446]         }, add = TRUE)
[08:27:25.446]     }
[08:27:25.446]     ...future.frame <- base::sys.nframe()
[08:27:25.446]     ...future.conditions <- base::list()
[08:27:25.446]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:25.446]     if (FALSE) {
[08:27:25.446]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:25.446]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:25.446]     }
[08:27:25.446]     ...future.result <- base::tryCatch({
[08:27:25.446]         base::withCallingHandlers({
[08:27:25.446]             ...future.value <- base::withVisible(base::local({
[08:27:25.446]                 do.call(function(...) {
[08:27:25.446]                   fcn <- function() sum(...)
[08:27:25.446]                   fcn()
[08:27:25.446]                 }, args = future.call.arguments)
[08:27:25.446]             }))
[08:27:25.446]             future::FutureResult(value = ...future.value$value, 
[08:27:25.446]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.446]                   ...future.rng), globalenv = if (FALSE) 
[08:27:25.446]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:25.446]                     ...future.globalenv.names))
[08:27:25.446]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:25.446]         }, condition = base::local({
[08:27:25.446]             c <- base::c
[08:27:25.446]             inherits <- base::inherits
[08:27:25.446]             invokeRestart <- base::invokeRestart
[08:27:25.446]             length <- base::length
[08:27:25.446]             list <- base::list
[08:27:25.446]             seq.int <- base::seq.int
[08:27:25.446]             signalCondition <- base::signalCondition
[08:27:25.446]             sys.calls <- base::sys.calls
[08:27:25.446]             `[[` <- base::`[[`
[08:27:25.446]             `+` <- base::`+`
[08:27:25.446]             `<<-` <- base::`<<-`
[08:27:25.446]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:25.446]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:25.446]                   3L)]
[08:27:25.446]             }
[08:27:25.446]             function(cond) {
[08:27:25.446]                 is_error <- inherits(cond, "error")
[08:27:25.446]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:25.446]                   NULL)
[08:27:25.446]                 if (is_error) {
[08:27:25.446]                   sessionInformation <- function() {
[08:27:25.446]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:25.446]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:25.446]                       search = base::search(), system = base::Sys.info())
[08:27:25.446]                   }
[08:27:25.446]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.446]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:25.446]                     cond$call), session = sessionInformation(), 
[08:27:25.446]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:25.446]                   signalCondition(cond)
[08:27:25.446]                 }
[08:27:25.446]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:25.446]                 "immediateCondition"))) {
[08:27:25.446]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:25.446]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.446]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:25.446]                   if (TRUE && !signal) {
[08:27:25.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.446]                     {
[08:27:25.446]                       inherits <- base::inherits
[08:27:25.446]                       invokeRestart <- base::invokeRestart
[08:27:25.446]                       is.null <- base::is.null
[08:27:25.446]                       muffled <- FALSE
[08:27:25.446]                       if (inherits(cond, "message")) {
[08:27:25.446]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.446]                         if (muffled) 
[08:27:25.446]                           invokeRestart("muffleMessage")
[08:27:25.446]                       }
[08:27:25.446]                       else if (inherits(cond, "warning")) {
[08:27:25.446]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.446]                         if (muffled) 
[08:27:25.446]                           invokeRestart("muffleWarning")
[08:27:25.446]                       }
[08:27:25.446]                       else if (inherits(cond, "condition")) {
[08:27:25.446]                         if (!is.null(pattern)) {
[08:27:25.446]                           computeRestarts <- base::computeRestarts
[08:27:25.446]                           grepl <- base::grepl
[08:27:25.446]                           restarts <- computeRestarts(cond)
[08:27:25.446]                           for (restart in restarts) {
[08:27:25.446]                             name <- restart$name
[08:27:25.446]                             if (is.null(name)) 
[08:27:25.446]                               next
[08:27:25.446]                             if (!grepl(pattern, name)) 
[08:27:25.446]                               next
[08:27:25.446]                             invokeRestart(restart)
[08:27:25.446]                             muffled <- TRUE
[08:27:25.446]                             break
[08:27:25.446]                           }
[08:27:25.446]                         }
[08:27:25.446]                       }
[08:27:25.446]                       invisible(muffled)
[08:27:25.446]                     }
[08:27:25.446]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.446]                   }
[08:27:25.446]                 }
[08:27:25.446]                 else {
[08:27:25.446]                   if (TRUE) {
[08:27:25.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.446]                     {
[08:27:25.446]                       inherits <- base::inherits
[08:27:25.446]                       invokeRestart <- base::invokeRestart
[08:27:25.446]                       is.null <- base::is.null
[08:27:25.446]                       muffled <- FALSE
[08:27:25.446]                       if (inherits(cond, "message")) {
[08:27:25.446]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.446]                         if (muffled) 
[08:27:25.446]                           invokeRestart("muffleMessage")
[08:27:25.446]                       }
[08:27:25.446]                       else if (inherits(cond, "warning")) {
[08:27:25.446]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.446]                         if (muffled) 
[08:27:25.446]                           invokeRestart("muffleWarning")
[08:27:25.446]                       }
[08:27:25.446]                       else if (inherits(cond, "condition")) {
[08:27:25.446]                         if (!is.null(pattern)) {
[08:27:25.446]                           computeRestarts <- base::computeRestarts
[08:27:25.446]                           grepl <- base::grepl
[08:27:25.446]                           restarts <- computeRestarts(cond)
[08:27:25.446]                           for (restart in restarts) {
[08:27:25.446]                             name <- restart$name
[08:27:25.446]                             if (is.null(name)) 
[08:27:25.446]                               next
[08:27:25.446]                             if (!grepl(pattern, name)) 
[08:27:25.446]                               next
[08:27:25.446]                             invokeRestart(restart)
[08:27:25.446]                             muffled <- TRUE
[08:27:25.446]                             break
[08:27:25.446]                           }
[08:27:25.446]                         }
[08:27:25.446]                       }
[08:27:25.446]                       invisible(muffled)
[08:27:25.446]                     }
[08:27:25.446]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.446]                   }
[08:27:25.446]                 }
[08:27:25.446]             }
[08:27:25.446]         }))
[08:27:25.446]     }, error = function(ex) {
[08:27:25.446]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:25.446]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.446]                 ...future.rng), started = ...future.startTime, 
[08:27:25.446]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:25.446]             version = "1.8"), class = "FutureResult")
[08:27:25.446]     }, finally = {
[08:27:25.446]         if (!identical(...future.workdir, getwd())) 
[08:27:25.446]             setwd(...future.workdir)
[08:27:25.446]         {
[08:27:25.446]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:25.446]                 ...future.oldOptions$nwarnings <- NULL
[08:27:25.446]             }
[08:27:25.446]             base::options(...future.oldOptions)
[08:27:25.446]             if (.Platform$OS.type == "windows") {
[08:27:25.446]                 old_names <- names(...future.oldEnvVars)
[08:27:25.446]                 envs <- base::Sys.getenv()
[08:27:25.446]                 names <- names(envs)
[08:27:25.446]                 common <- intersect(names, old_names)
[08:27:25.446]                 added <- setdiff(names, old_names)
[08:27:25.446]                 removed <- setdiff(old_names, names)
[08:27:25.446]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:25.446]                   envs[common]]
[08:27:25.446]                 NAMES <- toupper(changed)
[08:27:25.446]                 args <- list()
[08:27:25.446]                 for (kk in seq_along(NAMES)) {
[08:27:25.446]                   name <- changed[[kk]]
[08:27:25.446]                   NAME <- NAMES[[kk]]
[08:27:25.446]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.446]                     next
[08:27:25.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.446]                 }
[08:27:25.446]                 NAMES <- toupper(added)
[08:27:25.446]                 for (kk in seq_along(NAMES)) {
[08:27:25.446]                   name <- added[[kk]]
[08:27:25.446]                   NAME <- NAMES[[kk]]
[08:27:25.446]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.446]                     next
[08:27:25.446]                   args[[name]] <- ""
[08:27:25.446]                 }
[08:27:25.446]                 NAMES <- toupper(removed)
[08:27:25.446]                 for (kk in seq_along(NAMES)) {
[08:27:25.446]                   name <- removed[[kk]]
[08:27:25.446]                   NAME <- NAMES[[kk]]
[08:27:25.446]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.446]                     next
[08:27:25.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.446]                 }
[08:27:25.446]                 if (length(args) > 0) 
[08:27:25.446]                   base::do.call(base::Sys.setenv, args = args)
[08:27:25.446]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:25.446]             }
[08:27:25.446]             else {
[08:27:25.446]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:25.446]             }
[08:27:25.446]             {
[08:27:25.446]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:25.446]                   0L) {
[08:27:25.446]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:25.446]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:25.446]                   base::options(opts)
[08:27:25.446]                 }
[08:27:25.446]                 {
[08:27:25.446]                   {
[08:27:25.446]                     NULL
[08:27:25.446]                     RNGkind("Mersenne-Twister")
[08:27:25.446]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:25.446]                       inherits = FALSE)
[08:27:25.446]                   }
[08:27:25.446]                   options(future.plan = NULL)
[08:27:25.446]                   if (is.na(NA_character_)) 
[08:27:25.446]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.446]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:25.446]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:25.446]                     .init = FALSE)
[08:27:25.446]                 }
[08:27:25.446]             }
[08:27:25.446]         }
[08:27:25.446]     })
[08:27:25.446]     if (TRUE) {
[08:27:25.446]         base::sink(type = "output", split = FALSE)
[08:27:25.446]         if (TRUE) {
[08:27:25.446]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:25.446]         }
[08:27:25.446]         else {
[08:27:25.446]             ...future.result["stdout"] <- base::list(NULL)
[08:27:25.446]         }
[08:27:25.446]         base::close(...future.stdout)
[08:27:25.446]         ...future.stdout <- NULL
[08:27:25.446]     }
[08:27:25.446]     ...future.result$conditions <- ...future.conditions
[08:27:25.446]     ...future.result$finished <- base::Sys.time()
[08:27:25.446]     ...future.result
[08:27:25.446] }
[08:27:25.448] assign_globals() ...
[08:27:25.448] List of 1
[08:27:25.448]  $ future.call.arguments:List of 2
[08:27:25.448]   ..$ : int [1:2] 1 2
[08:27:25.448]   ..$ : num 3
[08:27:25.448]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:27:25.448]  - attr(*, "where")=List of 1
[08:27:25.448]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[08:27:25.448]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:25.448]  - attr(*, "resolved")= logi FALSE
[08:27:25.448]  - attr(*, "total_size")= num 223
[08:27:25.448]  - attr(*, "already-done")= logi TRUE
[08:27:25.451] - copied ‘future.call.arguments’ to environment
[08:27:25.451] assign_globals() ... done
[08:27:25.452] plan(): Setting new future strategy stack:
[08:27:25.452] List of future strategies:
[08:27:25.452] 1. sequential:
[08:27:25.452]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:25.452]    - tweaked: FALSE
[08:27:25.452]    - call: NULL
[08:27:25.452] plan(): nbrOfWorkers() = 1
[08:27:25.453] plan(): Setting new future strategy stack:
[08:27:25.453] List of future strategies:
[08:27:25.453] 1. sequential:
[08:27:25.453]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:25.453]    - tweaked: FALSE
[08:27:25.453]    - call: plan(strategy, substitute = FALSE)
[08:27:25.453] plan(): nbrOfWorkers() = 1
[08:27:25.454] SequentialFuture started (and completed)
[08:27:25.454] - Launch lazy future ... done
[08:27:25.454] run() for ‘SequentialFuture’ ... done
[1] 6
** Sum function 'F' with plan('sequential') ...
function (x, y) 
{
    message("Using '...' in a formula")
    fcn <- function(x, y) {
        z = ~list(...)
        sum(x, y)
    }
    f <- future(fcn(x, y))
    y <- value(f)
    y
}
<bytecode: 0x5593ff4673f0>
Using '...' in a formula
[08:27:25.454] getGlobalsAndPackages() ...
[08:27:25.454] Searching for globals...
[08:27:25.457] - globals found: [9] ‘fcn’, ‘x’, ‘y’, ‘{’, ‘=’, ‘~’, ‘list’, ‘...’, ‘sum’
[08:27:25.457] Searching for globals ... DONE
[08:27:25.457] Resolving globals: FALSE
[08:27:25.457] Tweak future expression to call with '...' arguments ...
[08:27:25.458] The total size of the 3 globals is 1.94 KiB (1985 bytes)
[08:27:25.458] The total size of the 3 globals exported for future expression (‘fcn(x, y)’) is 1.94 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘fcn’ (1.77 KiB of class ‘function’), ‘x’ (133 bytes of class ‘numeric’) and ‘y’ (39 bytes of class ‘numeric’)
[08:27:25.458] - globals: [3] ‘fcn’, ‘x’, ‘y’
[08:27:25.459] 
[08:27:25.459] getGlobalsAndPackages() ... DONE
[08:27:25.459] run() for ‘Future’ ...
[08:27:25.459] - state: ‘created’
[08:27:25.459] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:25.459] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:25.459] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:25.460]   - Field: ‘label’
[08:27:25.460]   - Field: ‘local’
[08:27:25.460]   - Field: ‘owner’
[08:27:25.460]   - Field: ‘envir’
[08:27:25.460]   - Field: ‘packages’
[08:27:25.460]   - Field: ‘gc’
[08:27:25.460]   - Field: ‘conditions’
[08:27:25.460]   - Field: ‘expr’
[08:27:25.460]   - Field: ‘uuid’
[08:27:25.460]   - Field: ‘seed’
[08:27:25.460]   - Field: ‘version’
[08:27:25.460]   - Field: ‘result’
[08:27:25.461]   - Field: ‘asynchronous’
[08:27:25.461]   - Field: ‘calls’
[08:27:25.461]   - Field: ‘globals’
[08:27:25.462]   - Field: ‘stdout’
[08:27:25.463]   - Field: ‘earlySignal’
[08:27:25.463]   - Field: ‘lazy’
[08:27:25.463]   - Field: ‘state’
[08:27:25.463] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:25.463] - Launch lazy future ...
[08:27:25.463] Packages needed by the future expression (n = 0): <none>
[08:27:25.463] Packages needed by future strategies (n = 0): <none>
[08:27:25.464] {
[08:27:25.464]     {
[08:27:25.464]         {
[08:27:25.464]             ...future.startTime <- base::Sys.time()
[08:27:25.464]             {
[08:27:25.464]                 {
[08:27:25.464]                   {
[08:27:25.464]                     base::local({
[08:27:25.464]                       has_future <- base::requireNamespace("future", 
[08:27:25.464]                         quietly = TRUE)
[08:27:25.464]                       if (has_future) {
[08:27:25.464]                         ns <- base::getNamespace("future")
[08:27:25.464]                         version <- ns[[".package"]][["version"]]
[08:27:25.464]                         if (is.null(version)) 
[08:27:25.464]                           version <- utils::packageVersion("future")
[08:27:25.464]                       }
[08:27:25.464]                       else {
[08:27:25.464]                         version <- NULL
[08:27:25.464]                       }
[08:27:25.464]                       if (!has_future || version < "1.8.0") {
[08:27:25.464]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:25.464]                           "", base::R.version$version.string), 
[08:27:25.464]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:25.464]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:25.464]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:25.464]                             "release", "version")], collapse = " "), 
[08:27:25.464]                           hostname = base::Sys.info()[["nodename"]])
[08:27:25.464]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:25.464]                           info)
[08:27:25.464]                         info <- base::paste(info, collapse = "; ")
[08:27:25.464]                         if (!has_future) {
[08:27:25.464]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:25.464]                             info)
[08:27:25.464]                         }
[08:27:25.464]                         else {
[08:27:25.464]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:25.464]                             info, version)
[08:27:25.464]                         }
[08:27:25.464]                         base::stop(msg)
[08:27:25.464]                       }
[08:27:25.464]                     })
[08:27:25.464]                   }
[08:27:25.464]                   ...future.strategy.old <- future::plan("list")
[08:27:25.464]                   options(future.plan = NULL)
[08:27:25.464]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.464]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:25.464]                 }
[08:27:25.464]                 ...future.workdir <- getwd()
[08:27:25.464]             }
[08:27:25.464]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:25.464]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:25.464]         }
[08:27:25.464]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:25.464]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:25.464]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:25.464]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:25.464]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:25.464]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:25.464]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:25.464]             base::names(...future.oldOptions))
[08:27:25.464]     }
[08:27:25.464]     if (FALSE) {
[08:27:25.464]     }
[08:27:25.464]     else {
[08:27:25.464]         if (TRUE) {
[08:27:25.464]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:25.464]                 open = "w")
[08:27:25.464]         }
[08:27:25.464]         else {
[08:27:25.464]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:25.464]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:25.464]         }
[08:27:25.464]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:25.464]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:25.464]             base::sink(type = "output", split = FALSE)
[08:27:25.464]             base::close(...future.stdout)
[08:27:25.464]         }, add = TRUE)
[08:27:25.464]     }
[08:27:25.464]     ...future.frame <- base::sys.nframe()
[08:27:25.464]     ...future.conditions <- base::list()
[08:27:25.464]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:25.464]     if (FALSE) {
[08:27:25.464]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:25.464]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:25.464]     }
[08:27:25.464]     ...future.result <- base::tryCatch({
[08:27:25.464]         base::withCallingHandlers({
[08:27:25.464]             ...future.value <- base::withVisible(base::local(fcn(x, 
[08:27:25.464]                 y)))
[08:27:25.464]             future::FutureResult(value = ...future.value$value, 
[08:27:25.464]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.464]                   ...future.rng), globalenv = if (FALSE) 
[08:27:25.464]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:25.464]                     ...future.globalenv.names))
[08:27:25.464]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:25.464]         }, condition = base::local({
[08:27:25.464]             c <- base::c
[08:27:25.464]             inherits <- base::inherits
[08:27:25.464]             invokeRestart <- base::invokeRestart
[08:27:25.464]             length <- base::length
[08:27:25.464]             list <- base::list
[08:27:25.464]             seq.int <- base::seq.int
[08:27:25.464]             signalCondition <- base::signalCondition
[08:27:25.464]             sys.calls <- base::sys.calls
[08:27:25.464]             `[[` <- base::`[[`
[08:27:25.464]             `+` <- base::`+`
[08:27:25.464]             `<<-` <- base::`<<-`
[08:27:25.464]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:25.464]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:25.464]                   3L)]
[08:27:25.464]             }
[08:27:25.464]             function(cond) {
[08:27:25.464]                 is_error <- inherits(cond, "error")
[08:27:25.464]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:25.464]                   NULL)
[08:27:25.464]                 if (is_error) {
[08:27:25.464]                   sessionInformation <- function() {
[08:27:25.464]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:25.464]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:25.464]                       search = base::search(), system = base::Sys.info())
[08:27:25.464]                   }
[08:27:25.464]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.464]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:25.464]                     cond$call), session = sessionInformation(), 
[08:27:25.464]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:25.464]                   signalCondition(cond)
[08:27:25.464]                 }
[08:27:25.464]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:25.464]                 "immediateCondition"))) {
[08:27:25.464]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:25.464]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.464]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:25.464]                   if (TRUE && !signal) {
[08:27:25.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.464]                     {
[08:27:25.464]                       inherits <- base::inherits
[08:27:25.464]                       invokeRestart <- base::invokeRestart
[08:27:25.464]                       is.null <- base::is.null
[08:27:25.464]                       muffled <- FALSE
[08:27:25.464]                       if (inherits(cond, "message")) {
[08:27:25.464]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.464]                         if (muffled) 
[08:27:25.464]                           invokeRestart("muffleMessage")
[08:27:25.464]                       }
[08:27:25.464]                       else if (inherits(cond, "warning")) {
[08:27:25.464]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.464]                         if (muffled) 
[08:27:25.464]                           invokeRestart("muffleWarning")
[08:27:25.464]                       }
[08:27:25.464]                       else if (inherits(cond, "condition")) {
[08:27:25.464]                         if (!is.null(pattern)) {
[08:27:25.464]                           computeRestarts <- base::computeRestarts
[08:27:25.464]                           grepl <- base::grepl
[08:27:25.464]                           restarts <- computeRestarts(cond)
[08:27:25.464]                           for (restart in restarts) {
[08:27:25.464]                             name <- restart$name
[08:27:25.464]                             if (is.null(name)) 
[08:27:25.464]                               next
[08:27:25.464]                             if (!grepl(pattern, name)) 
[08:27:25.464]                               next
[08:27:25.464]                             invokeRestart(restart)
[08:27:25.464]                             muffled <- TRUE
[08:27:25.464]                             break
[08:27:25.464]                           }
[08:27:25.464]                         }
[08:27:25.464]                       }
[08:27:25.464]                       invisible(muffled)
[08:27:25.464]                     }
[08:27:25.464]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.464]                   }
[08:27:25.464]                 }
[08:27:25.464]                 else {
[08:27:25.464]                   if (TRUE) {
[08:27:25.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.464]                     {
[08:27:25.464]                       inherits <- base::inherits
[08:27:25.464]                       invokeRestart <- base::invokeRestart
[08:27:25.464]                       is.null <- base::is.null
[08:27:25.464]                       muffled <- FALSE
[08:27:25.464]                       if (inherits(cond, "message")) {
[08:27:25.464]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.464]                         if (muffled) 
[08:27:25.464]                           invokeRestart("muffleMessage")
[08:27:25.464]                       }
[08:27:25.464]                       else if (inherits(cond, "warning")) {
[08:27:25.464]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.464]                         if (muffled) 
[08:27:25.464]                           invokeRestart("muffleWarning")
[08:27:25.464]                       }
[08:27:25.464]                       else if (inherits(cond, "condition")) {
[08:27:25.464]                         if (!is.null(pattern)) {
[08:27:25.464]                           computeRestarts <- base::computeRestarts
[08:27:25.464]                           grepl <- base::grepl
[08:27:25.464]                           restarts <- computeRestarts(cond)
[08:27:25.464]                           for (restart in restarts) {
[08:27:25.464]                             name <- restart$name
[08:27:25.464]                             if (is.null(name)) 
[08:27:25.464]                               next
[08:27:25.464]                             if (!grepl(pattern, name)) 
[08:27:25.464]                               next
[08:27:25.464]                             invokeRestart(restart)
[08:27:25.464]                             muffled <- TRUE
[08:27:25.464]                             break
[08:27:25.464]                           }
[08:27:25.464]                         }
[08:27:25.464]                       }
[08:27:25.464]                       invisible(muffled)
[08:27:25.464]                     }
[08:27:25.464]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.464]                   }
[08:27:25.464]                 }
[08:27:25.464]             }
[08:27:25.464]         }))
[08:27:25.464]     }, error = function(ex) {
[08:27:25.464]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:25.464]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.464]                 ...future.rng), started = ...future.startTime, 
[08:27:25.464]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:25.464]             version = "1.8"), class = "FutureResult")
[08:27:25.464]     }, finally = {
[08:27:25.464]         if (!identical(...future.workdir, getwd())) 
[08:27:25.464]             setwd(...future.workdir)
[08:27:25.464]         {
[08:27:25.464]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:25.464]                 ...future.oldOptions$nwarnings <- NULL
[08:27:25.464]             }
[08:27:25.464]             base::options(...future.oldOptions)
[08:27:25.464]             if (.Platform$OS.type == "windows") {
[08:27:25.464]                 old_names <- names(...future.oldEnvVars)
[08:27:25.464]                 envs <- base::Sys.getenv()
[08:27:25.464]                 names <- names(envs)
[08:27:25.464]                 common <- intersect(names, old_names)
[08:27:25.464]                 added <- setdiff(names, old_names)
[08:27:25.464]                 removed <- setdiff(old_names, names)
[08:27:25.464]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:25.464]                   envs[common]]
[08:27:25.464]                 NAMES <- toupper(changed)
[08:27:25.464]                 args <- list()
[08:27:25.464]                 for (kk in seq_along(NAMES)) {
[08:27:25.464]                   name <- changed[[kk]]
[08:27:25.464]                   NAME <- NAMES[[kk]]
[08:27:25.464]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.464]                     next
[08:27:25.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.464]                 }
[08:27:25.464]                 NAMES <- toupper(added)
[08:27:25.464]                 for (kk in seq_along(NAMES)) {
[08:27:25.464]                   name <- added[[kk]]
[08:27:25.464]                   NAME <- NAMES[[kk]]
[08:27:25.464]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.464]                     next
[08:27:25.464]                   args[[name]] <- ""
[08:27:25.464]                 }
[08:27:25.464]                 NAMES <- toupper(removed)
[08:27:25.464]                 for (kk in seq_along(NAMES)) {
[08:27:25.464]                   name <- removed[[kk]]
[08:27:25.464]                   NAME <- NAMES[[kk]]
[08:27:25.464]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.464]                     next
[08:27:25.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.464]                 }
[08:27:25.464]                 if (length(args) > 0) 
[08:27:25.464]                   base::do.call(base::Sys.setenv, args = args)
[08:27:25.464]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:25.464]             }
[08:27:25.464]             else {
[08:27:25.464]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:25.464]             }
[08:27:25.464]             {
[08:27:25.464]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:25.464]                   0L) {
[08:27:25.464]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:25.464]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:25.464]                   base::options(opts)
[08:27:25.464]                 }
[08:27:25.464]                 {
[08:27:25.464]                   {
[08:27:25.464]                     NULL
[08:27:25.464]                     RNGkind("Mersenne-Twister")
[08:27:25.464]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:25.464]                       inherits = FALSE)
[08:27:25.464]                   }
[08:27:25.464]                   options(future.plan = NULL)
[08:27:25.464]                   if (is.na(NA_character_)) 
[08:27:25.464]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.464]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:25.464]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:25.464]                     .init = FALSE)
[08:27:25.464]                 }
[08:27:25.464]             }
[08:27:25.464]         }
[08:27:25.464]     })
[08:27:25.464]     if (TRUE) {
[08:27:25.464]         base::sink(type = "output", split = FALSE)
[08:27:25.464]         if (TRUE) {
[08:27:25.464]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:25.464]         }
[08:27:25.464]         else {
[08:27:25.464]             ...future.result["stdout"] <- base::list(NULL)
[08:27:25.464]         }
[08:27:25.464]         base::close(...future.stdout)
[08:27:25.464]         ...future.stdout <- NULL
[08:27:25.464]     }
[08:27:25.464]     ...future.result$conditions <- ...future.conditions
[08:27:25.464]     ...future.result$finished <- base::Sys.time()
[08:27:25.464]     ...future.result
[08:27:25.464] }
[08:27:25.465] assign_globals() ...
[08:27:25.465] List of 3
[08:27:25.465]  $ fcn:function (x, y)  
[08:27:25.465]  $ x  : int [1:2] 1 2
[08:27:25.465]  $ y  : num 3
[08:27:25.465]  - attr(*, "where")=List of 3
[08:27:25.465]   ..$ fcn:<environment: R_EmptyEnv> 
[08:27:25.465]   ..$ x  :<environment: R_EmptyEnv> 
[08:27:25.465]   ..$ y  :<environment: R_EmptyEnv> 
[08:27:25.465]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:25.465]  - attr(*, "resolved")= logi FALSE
[08:27:25.465]  - attr(*, "total_size")= num 1985
[08:27:25.465]  - attr(*, "already-done")= logi TRUE
[08:27:25.469] - reassign environment for ‘fcn’
[08:27:25.469] - copied ‘fcn’ to environment
[08:27:25.469] - copied ‘x’ to environment
[08:27:25.469] - copied ‘y’ to environment
[08:27:25.469] assign_globals() ... done
[08:27:25.470] plan(): Setting new future strategy stack:
[08:27:25.470] List of future strategies:
[08:27:25.470] 1. sequential:
[08:27:25.470]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:25.470]    - tweaked: FALSE
[08:27:25.470]    - call: NULL
[08:27:25.470] plan(): nbrOfWorkers() = 1
[08:27:25.471] plan(): Setting new future strategy stack:
[08:27:25.471] List of future strategies:
[08:27:25.471] 1. sequential:
[08:27:25.471]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:25.471]    - tweaked: FALSE
[08:27:25.471]    - call: plan(strategy, substitute = FALSE)
[08:27:25.471] plan(): nbrOfWorkers() = 1
[08:27:25.472] SequentialFuture started (and completed)
[08:27:25.472] - Launch lazy future ... done
[08:27:25.472] run() for ‘SequentialFuture’ ... done
[1] 6
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** Global argument '...' ...
- plan('multicore') ...
[08:27:25.478] plan(): Setting new future strategy stack:
[08:27:25.478] List of future strategies:
[08:27:25.478] 1. multicore:
[08:27:25.478]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:25.478]    - tweaked: FALSE
[08:27:25.478]    - call: plan(strategy, substitute = FALSE)
[08:27:25.479] plan(): nbrOfWorkers() = 2
** Sum function 'A' with plan('multicore') ...
function (x, ...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, ...)
    }
    y
}
<bytecode: 0x5594014489c0>
Arguments '...' exists: TRUE
[08:27:25.480] getGlobalsAndPackages() ...
[08:27:25.480] Searching for globals...
[08:27:25.481] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[08:27:25.481] Searching for globals ... DONE
[08:27:25.482] Resolving globals: FALSE
[08:27:25.482] Tweak future expression to call with '...' arguments ...
[08:27:25.482] {
[08:27:25.482]     do.call(function(...) {
[08:27:25.482]         sum(x, ...)
[08:27:25.482]     }, args = future.call.arguments)
[08:27:25.482] }
[08:27:25.482] Tweak future expression to call with '...' arguments ... DONE
[08:27:25.482] The total size of the 2 globals is 246 bytes (246 bytes)
[08:27:25.483] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 246 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (133 bytes of class ‘numeric’) and ‘future.call.arguments’ (113 bytes of class ‘list’)
[08:27:25.483] - globals: [2] ‘x’, ‘future.call.arguments’
[08:27:25.483] 
[08:27:25.483] getGlobalsAndPackages() ... DONE
[08:27:25.483] run() for ‘Future’ ...
[08:27:25.483] - state: ‘created’
[08:27:25.483] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:25.485] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:25.485] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:25.485]   - Field: ‘label’
[08:27:25.485]   - Field: ‘local’
[08:27:25.486]   - Field: ‘owner’
[08:27:25.486]   - Field: ‘envir’
[08:27:25.486]   - Field: ‘workers’
[08:27:25.486]   - Field: ‘packages’
[08:27:25.486]   - Field: ‘gc’
[08:27:25.486]   - Field: ‘job’
[08:27:25.486]   - Field: ‘conditions’
[08:27:25.486]   - Field: ‘expr’
[08:27:25.486]   - Field: ‘uuid’
[08:27:25.486]   - Field: ‘seed’
[08:27:25.486]   - Field: ‘version’
[08:27:25.487]   - Field: ‘result’
[08:27:25.487]   - Field: ‘asynchronous’
[08:27:25.487]   - Field: ‘calls’
[08:27:25.487]   - Field: ‘globals’
[08:27:25.487]   - Field: ‘stdout’
[08:27:25.487]   - Field: ‘earlySignal’
[08:27:25.487]   - Field: ‘lazy’
[08:27:25.487]   - Field: ‘state’
[08:27:25.487] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:25.487] - Launch lazy future ...
[08:27:25.488] Packages needed by the future expression (n = 0): <none>
[08:27:25.488] Packages needed by future strategies (n = 0): <none>
[08:27:25.489] {
[08:27:25.489]     {
[08:27:25.489]         {
[08:27:25.489]             ...future.startTime <- base::Sys.time()
[08:27:25.489]             {
[08:27:25.489]                 {
[08:27:25.489]                   {
[08:27:25.489]                     {
[08:27:25.489]                       base::local({
[08:27:25.489]                         has_future <- base::requireNamespace("future", 
[08:27:25.489]                           quietly = TRUE)
[08:27:25.489]                         if (has_future) {
[08:27:25.489]                           ns <- base::getNamespace("future")
[08:27:25.489]                           version <- ns[[".package"]][["version"]]
[08:27:25.489]                           if (is.null(version)) 
[08:27:25.489]                             version <- utils::packageVersion("future")
[08:27:25.489]                         }
[08:27:25.489]                         else {
[08:27:25.489]                           version <- NULL
[08:27:25.489]                         }
[08:27:25.489]                         if (!has_future || version < "1.8.0") {
[08:27:25.489]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:25.489]                             "", base::R.version$version.string), 
[08:27:25.489]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:25.489]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:25.489]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:25.489]                               "release", "version")], collapse = " "), 
[08:27:25.489]                             hostname = base::Sys.info()[["nodename"]])
[08:27:25.489]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:25.489]                             info)
[08:27:25.489]                           info <- base::paste(info, collapse = "; ")
[08:27:25.489]                           if (!has_future) {
[08:27:25.489]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:25.489]                               info)
[08:27:25.489]                           }
[08:27:25.489]                           else {
[08:27:25.489]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:25.489]                               info, version)
[08:27:25.489]                           }
[08:27:25.489]                           base::stop(msg)
[08:27:25.489]                         }
[08:27:25.489]                       })
[08:27:25.489]                     }
[08:27:25.489]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:25.489]                     base::options(mc.cores = 1L)
[08:27:25.489]                   }
[08:27:25.489]                   ...future.strategy.old <- future::plan("list")
[08:27:25.489]                   options(future.plan = NULL)
[08:27:25.489]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.489]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:25.489]                 }
[08:27:25.489]                 ...future.workdir <- getwd()
[08:27:25.489]             }
[08:27:25.489]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:25.489]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:25.489]         }
[08:27:25.489]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:25.489]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:25.489]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:25.489]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:25.489]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:25.489]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:25.489]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:25.489]             base::names(...future.oldOptions))
[08:27:25.489]     }
[08:27:25.489]     if (FALSE) {
[08:27:25.489]     }
[08:27:25.489]     else {
[08:27:25.489]         if (TRUE) {
[08:27:25.489]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:25.489]                 open = "w")
[08:27:25.489]         }
[08:27:25.489]         else {
[08:27:25.489]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:25.489]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:25.489]         }
[08:27:25.489]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:25.489]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:25.489]             base::sink(type = "output", split = FALSE)
[08:27:25.489]             base::close(...future.stdout)
[08:27:25.489]         }, add = TRUE)
[08:27:25.489]     }
[08:27:25.489]     ...future.frame <- base::sys.nframe()
[08:27:25.489]     ...future.conditions <- base::list()
[08:27:25.489]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:25.489]     if (FALSE) {
[08:27:25.489]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:25.489]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:25.489]     }
[08:27:25.489]     ...future.result <- base::tryCatch({
[08:27:25.489]         base::withCallingHandlers({
[08:27:25.489]             ...future.value <- base::withVisible(base::local({
[08:27:25.489]                 withCallingHandlers({
[08:27:25.489]                   {
[08:27:25.489]                     do.call(function(...) {
[08:27:25.489]                       sum(x, ...)
[08:27:25.489]                     }, args = future.call.arguments)
[08:27:25.489]                   }
[08:27:25.489]                 }, immediateCondition = function(cond) {
[08:27:25.489]                   save_rds <- function (object, pathname, ...) 
[08:27:25.489]                   {
[08:27:25.489]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:25.489]                     if (file_test("-f", pathname_tmp)) {
[08:27:25.489]                       fi_tmp <- file.info(pathname_tmp)
[08:27:25.489]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:25.489]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:25.489]                         fi_tmp[["mtime"]])
[08:27:25.489]                     }
[08:27:25.489]                     tryCatch({
[08:27:25.489]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:25.489]                     }, error = function(ex) {
[08:27:25.489]                       msg <- conditionMessage(ex)
[08:27:25.489]                       fi_tmp <- file.info(pathname_tmp)
[08:27:25.489]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:25.489]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:25.489]                         fi_tmp[["mtime"]], msg)
[08:27:25.489]                       ex$message <- msg
[08:27:25.489]                       stop(ex)
[08:27:25.489]                     })
[08:27:25.489]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:25.489]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:25.489]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:25.489]                       fi_tmp <- file.info(pathname_tmp)
[08:27:25.489]                       fi <- file.info(pathname)
[08:27:25.489]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:25.489]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:25.489]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:25.489]                         fi[["size"]], fi[["mtime"]])
[08:27:25.489]                       stop(msg)
[08:27:25.489]                     }
[08:27:25.489]                     invisible(pathname)
[08:27:25.489]                   }
[08:27:25.489]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:25.489]                     rootPath = tempdir()) 
[08:27:25.489]                   {
[08:27:25.489]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:25.489]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:25.489]                       tmpdir = path, fileext = ".rds")
[08:27:25.489]                     save_rds(obj, file)
[08:27:25.489]                   }
[08:27:25.489]                   saveImmediateCondition(cond, path = "/tmp/RtmpdixJ0p/.future/immediateConditions")
[08:27:25.489]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.489]                   {
[08:27:25.489]                     inherits <- base::inherits
[08:27:25.489]                     invokeRestart <- base::invokeRestart
[08:27:25.489]                     is.null <- base::is.null
[08:27:25.489]                     muffled <- FALSE
[08:27:25.489]                     if (inherits(cond, "message")) {
[08:27:25.489]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:25.489]                       if (muffled) 
[08:27:25.489]                         invokeRestart("muffleMessage")
[08:27:25.489]                     }
[08:27:25.489]                     else if (inherits(cond, "warning")) {
[08:27:25.489]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:25.489]                       if (muffled) 
[08:27:25.489]                         invokeRestart("muffleWarning")
[08:27:25.489]                     }
[08:27:25.489]                     else if (inherits(cond, "condition")) {
[08:27:25.489]                       if (!is.null(pattern)) {
[08:27:25.489]                         computeRestarts <- base::computeRestarts
[08:27:25.489]                         grepl <- base::grepl
[08:27:25.489]                         restarts <- computeRestarts(cond)
[08:27:25.489]                         for (restart in restarts) {
[08:27:25.489]                           name <- restart$name
[08:27:25.489]                           if (is.null(name)) 
[08:27:25.489]                             next
[08:27:25.489]                           if (!grepl(pattern, name)) 
[08:27:25.489]                             next
[08:27:25.489]                           invokeRestart(restart)
[08:27:25.489]                           muffled <- TRUE
[08:27:25.489]                           break
[08:27:25.489]                         }
[08:27:25.489]                       }
[08:27:25.489]                     }
[08:27:25.489]                     invisible(muffled)
[08:27:25.489]                   }
[08:27:25.489]                   muffleCondition(cond)
[08:27:25.489]                 })
[08:27:25.489]             }))
[08:27:25.489]             future::FutureResult(value = ...future.value$value, 
[08:27:25.489]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.489]                   ...future.rng), globalenv = if (FALSE) 
[08:27:25.489]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:25.489]                     ...future.globalenv.names))
[08:27:25.489]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:25.489]         }, condition = base::local({
[08:27:25.489]             c <- base::c
[08:27:25.489]             inherits <- base::inherits
[08:27:25.489]             invokeRestart <- base::invokeRestart
[08:27:25.489]             length <- base::length
[08:27:25.489]             list <- base::list
[08:27:25.489]             seq.int <- base::seq.int
[08:27:25.489]             signalCondition <- base::signalCondition
[08:27:25.489]             sys.calls <- base::sys.calls
[08:27:25.489]             `[[` <- base::`[[`
[08:27:25.489]             `+` <- base::`+`
[08:27:25.489]             `<<-` <- base::`<<-`
[08:27:25.489]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:25.489]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:25.489]                   3L)]
[08:27:25.489]             }
[08:27:25.489]             function(cond) {
[08:27:25.489]                 is_error <- inherits(cond, "error")
[08:27:25.489]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:25.489]                   NULL)
[08:27:25.489]                 if (is_error) {
[08:27:25.489]                   sessionInformation <- function() {
[08:27:25.489]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:25.489]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:25.489]                       search = base::search(), system = base::Sys.info())
[08:27:25.489]                   }
[08:27:25.489]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.489]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:25.489]                     cond$call), session = sessionInformation(), 
[08:27:25.489]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:25.489]                   signalCondition(cond)
[08:27:25.489]                 }
[08:27:25.489]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:25.489]                 "immediateCondition"))) {
[08:27:25.489]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:25.489]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.489]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:25.489]                   if (TRUE && !signal) {
[08:27:25.489]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.489]                     {
[08:27:25.489]                       inherits <- base::inherits
[08:27:25.489]                       invokeRestart <- base::invokeRestart
[08:27:25.489]                       is.null <- base::is.null
[08:27:25.489]                       muffled <- FALSE
[08:27:25.489]                       if (inherits(cond, "message")) {
[08:27:25.489]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.489]                         if (muffled) 
[08:27:25.489]                           invokeRestart("muffleMessage")
[08:27:25.489]                       }
[08:27:25.489]                       else if (inherits(cond, "warning")) {
[08:27:25.489]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.489]                         if (muffled) 
[08:27:25.489]                           invokeRestart("muffleWarning")
[08:27:25.489]                       }
[08:27:25.489]                       else if (inherits(cond, "condition")) {
[08:27:25.489]                         if (!is.null(pattern)) {
[08:27:25.489]                           computeRestarts <- base::computeRestarts
[08:27:25.489]                           grepl <- base::grepl
[08:27:25.489]                           restarts <- computeRestarts(cond)
[08:27:25.489]                           for (restart in restarts) {
[08:27:25.489]                             name <- restart$name
[08:27:25.489]                             if (is.null(name)) 
[08:27:25.489]                               next
[08:27:25.489]                             if (!grepl(pattern, name)) 
[08:27:25.489]                               next
[08:27:25.489]                             invokeRestart(restart)
[08:27:25.489]                             muffled <- TRUE
[08:27:25.489]                             break
[08:27:25.489]                           }
[08:27:25.489]                         }
[08:27:25.489]                       }
[08:27:25.489]                       invisible(muffled)
[08:27:25.489]                     }
[08:27:25.489]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.489]                   }
[08:27:25.489]                 }
[08:27:25.489]                 else {
[08:27:25.489]                   if (TRUE) {
[08:27:25.489]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.489]                     {
[08:27:25.489]                       inherits <- base::inherits
[08:27:25.489]                       invokeRestart <- base::invokeRestart
[08:27:25.489]                       is.null <- base::is.null
[08:27:25.489]                       muffled <- FALSE
[08:27:25.489]                       if (inherits(cond, "message")) {
[08:27:25.489]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.489]                         if (muffled) 
[08:27:25.489]                           invokeRestart("muffleMessage")
[08:27:25.489]                       }
[08:27:25.489]                       else if (inherits(cond, "warning")) {
[08:27:25.489]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.489]                         if (muffled) 
[08:27:25.489]                           invokeRestart("muffleWarning")
[08:27:25.489]                       }
[08:27:25.489]                       else if (inherits(cond, "condition")) {
[08:27:25.489]                         if (!is.null(pattern)) {
[08:27:25.489]                           computeRestarts <- base::computeRestarts
[08:27:25.489]                           grepl <- base::grepl
[08:27:25.489]                           restarts <- computeRestarts(cond)
[08:27:25.489]                           for (restart in restarts) {
[08:27:25.489]                             name <- restart$name
[08:27:25.489]                             if (is.null(name)) 
[08:27:25.489]                               next
[08:27:25.489]                             if (!grepl(pattern, name)) 
[08:27:25.489]                               next
[08:27:25.489]                             invokeRestart(restart)
[08:27:25.489]                             muffled <- TRUE
[08:27:25.489]                             break
[08:27:25.489]                           }
[08:27:25.489]                         }
[08:27:25.489]                       }
[08:27:25.489]                       invisible(muffled)
[08:27:25.489]                     }
[08:27:25.489]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.489]                   }
[08:27:25.489]                 }
[08:27:25.489]             }
[08:27:25.489]         }))
[08:27:25.489]     }, error = function(ex) {
[08:27:25.489]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:25.489]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.489]                 ...future.rng), started = ...future.startTime, 
[08:27:25.489]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:25.489]             version = "1.8"), class = "FutureResult")
[08:27:25.489]     }, finally = {
[08:27:25.489]         if (!identical(...future.workdir, getwd())) 
[08:27:25.489]             setwd(...future.workdir)
[08:27:25.489]         {
[08:27:25.489]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:25.489]                 ...future.oldOptions$nwarnings <- NULL
[08:27:25.489]             }
[08:27:25.489]             base::options(...future.oldOptions)
[08:27:25.489]             if (.Platform$OS.type == "windows") {
[08:27:25.489]                 old_names <- names(...future.oldEnvVars)
[08:27:25.489]                 envs <- base::Sys.getenv()
[08:27:25.489]                 names <- names(envs)
[08:27:25.489]                 common <- intersect(names, old_names)
[08:27:25.489]                 added <- setdiff(names, old_names)
[08:27:25.489]                 removed <- setdiff(old_names, names)
[08:27:25.489]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:25.489]                   envs[common]]
[08:27:25.489]                 NAMES <- toupper(changed)
[08:27:25.489]                 args <- list()
[08:27:25.489]                 for (kk in seq_along(NAMES)) {
[08:27:25.489]                   name <- changed[[kk]]
[08:27:25.489]                   NAME <- NAMES[[kk]]
[08:27:25.489]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.489]                     next
[08:27:25.489]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.489]                 }
[08:27:25.489]                 NAMES <- toupper(added)
[08:27:25.489]                 for (kk in seq_along(NAMES)) {
[08:27:25.489]                   name <- added[[kk]]
[08:27:25.489]                   NAME <- NAMES[[kk]]
[08:27:25.489]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.489]                     next
[08:27:25.489]                   args[[name]] <- ""
[08:27:25.489]                 }
[08:27:25.489]                 NAMES <- toupper(removed)
[08:27:25.489]                 for (kk in seq_along(NAMES)) {
[08:27:25.489]                   name <- removed[[kk]]
[08:27:25.489]                   NAME <- NAMES[[kk]]
[08:27:25.489]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.489]                     next
[08:27:25.489]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.489]                 }
[08:27:25.489]                 if (length(args) > 0) 
[08:27:25.489]                   base::do.call(base::Sys.setenv, args = args)
[08:27:25.489]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:25.489]             }
[08:27:25.489]             else {
[08:27:25.489]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:25.489]             }
[08:27:25.489]             {
[08:27:25.489]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:25.489]                   0L) {
[08:27:25.489]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:25.489]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:25.489]                   base::options(opts)
[08:27:25.489]                 }
[08:27:25.489]                 {
[08:27:25.489]                   {
[08:27:25.489]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:25.489]                     NULL
[08:27:25.489]                   }
[08:27:25.489]                   options(future.plan = NULL)
[08:27:25.489]                   if (is.na(NA_character_)) 
[08:27:25.489]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.489]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:25.489]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:25.489]                     .init = FALSE)
[08:27:25.489]                 }
[08:27:25.489]             }
[08:27:25.489]         }
[08:27:25.489]     })
[08:27:25.489]     if (TRUE) {
[08:27:25.489]         base::sink(type = "output", split = FALSE)
[08:27:25.489]         if (TRUE) {
[08:27:25.489]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:25.489]         }
[08:27:25.489]         else {
[08:27:25.489]             ...future.result["stdout"] <- base::list(NULL)
[08:27:25.489]         }
[08:27:25.489]         base::close(...future.stdout)
[08:27:25.489]         ...future.stdout <- NULL
[08:27:25.489]     }
[08:27:25.489]     ...future.result$conditions <- ...future.conditions
[08:27:25.489]     ...future.result$finished <- base::Sys.time()
[08:27:25.489]     ...future.result
[08:27:25.489] }
[08:27:25.493] assign_globals() ...
[08:27:25.493] List of 2
[08:27:25.493]  $ x                    : int [1:2] 1 2
[08:27:25.493]  $ future.call.arguments:List of 1
[08:27:25.493]   ..$ : num 3
[08:27:25.493]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:27:25.493]  - attr(*, "where")=List of 2
[08:27:25.493]   ..$ x                    :<environment: R_EmptyEnv> 
[08:27:25.493]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[08:27:25.493]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:25.493]  - attr(*, "resolved")= logi FALSE
[08:27:25.493]  - attr(*, "total_size")= num 246
[08:27:25.493]  - attr(*, "already-done")= logi TRUE
[08:27:25.496] - copied ‘x’ to environment
[08:27:25.497] - copied ‘future.call.arguments’ to environment
[08:27:25.497] assign_globals() ... done
[08:27:25.497] requestCore(): workers = 2
[08:27:25.500] MulticoreFuture started
[08:27:25.500] - Launch lazy future ... done
[08:27:25.500] plan(): Setting new future strategy stack:
[08:27:25.501] run() for ‘MulticoreFuture’ ... done
[08:27:25.501] List of future strategies:
[08:27:25.501] 1. sequential:
[08:27:25.501]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:25.501]    - tweaked: FALSE
[08:27:25.501]    - call: NULL
[08:27:25.502] plan(): nbrOfWorkers() = 1
[08:27:25.502] result() for MulticoreFuture ...
[08:27:25.504] plan(): Setting new future strategy stack:
[08:27:25.504] List of future strategies:
[08:27:25.504] 1. multicore:
[08:27:25.504]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:25.504]    - tweaked: FALSE
[08:27:25.504]    - call: plan(strategy, substitute = FALSE)
[08:27:25.507] plan(): nbrOfWorkers() = 2
[08:27:25.512] result() for MulticoreFuture ...
[08:27:25.512] result() for MulticoreFuture ... done
[08:27:25.512] result() for MulticoreFuture ... done
[08:27:25.513] result() for MulticoreFuture ...
[08:27:25.513] result() for MulticoreFuture ... done
[1] 6
** Sum function 'B' with plan('multicore') ...
function (x, ...) 
{
    sumt <- function(x) {
        message("Arguments '...' exists: ", exists("...", inherits = TRUE))
        y %<-% {
            sum(x, ...)
        }
        y
    }
    sumt(x)
}
<bytecode: 0x5594016d6998>
Arguments '...' exists: TRUE
[08:27:25.513] getGlobalsAndPackages() ...
[08:27:25.514] Searching for globals...
[08:27:25.516] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[08:27:25.516] Searching for globals ... DONE
[08:27:25.516] Resolving globals: FALSE
[08:27:25.516] Tweak future expression to call with '...' arguments ...
[08:27:25.516] {
[08:27:25.516]     do.call(function(...) {
[08:27:25.516]         sum(x, ...)
[08:27:25.516]     }, args = future.call.arguments)
[08:27:25.516] }
[08:27:25.516] Tweak future expression to call with '...' arguments ... DONE
[08:27:25.517] The total size of the 2 globals is 246 bytes (246 bytes)
[08:27:25.517] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 246 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (133 bytes of class ‘numeric’) and ‘future.call.arguments’ (113 bytes of class ‘list’)
[08:27:25.518] - globals: [2] ‘x’, ‘future.call.arguments’
[08:27:25.518] 
[08:27:25.518] getGlobalsAndPackages() ... DONE
[08:27:25.518] run() for ‘Future’ ...
[08:27:25.518] - state: ‘created’
[08:27:25.518] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:25.520] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:25.521] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:25.521]   - Field: ‘label’
[08:27:25.521]   - Field: ‘local’
[08:27:25.521]   - Field: ‘owner’
[08:27:25.521]   - Field: ‘envir’
[08:27:25.521]   - Field: ‘workers’
[08:27:25.521]   - Field: ‘packages’
[08:27:25.521]   - Field: ‘gc’
[08:27:25.522]   - Field: ‘job’
[08:27:25.522]   - Field: ‘conditions’
[08:27:25.522]   - Field: ‘expr’
[08:27:25.522]   - Field: ‘uuid’
[08:27:25.522]   - Field: ‘seed’
[08:27:25.522]   - Field: ‘version’
[08:27:25.522]   - Field: ‘result’
[08:27:25.522]   - Field: ‘asynchronous’
[08:27:25.522]   - Field: ‘calls’
[08:27:25.523]   - Field: ‘globals’
[08:27:25.523]   - Field: ‘stdout’
[08:27:25.523]   - Field: ‘earlySignal’
[08:27:25.523]   - Field: ‘lazy’
[08:27:25.523]   - Field: ‘state’
[08:27:25.523] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:25.523] - Launch lazy future ...
[08:27:25.524] Packages needed by the future expression (n = 0): <none>
[08:27:25.524] Packages needed by future strategies (n = 0): <none>
[08:27:25.524] {
[08:27:25.524]     {
[08:27:25.524]         {
[08:27:25.524]             ...future.startTime <- base::Sys.time()
[08:27:25.524]             {
[08:27:25.524]                 {
[08:27:25.524]                   {
[08:27:25.524]                     {
[08:27:25.524]                       base::local({
[08:27:25.524]                         has_future <- base::requireNamespace("future", 
[08:27:25.524]                           quietly = TRUE)
[08:27:25.524]                         if (has_future) {
[08:27:25.524]                           ns <- base::getNamespace("future")
[08:27:25.524]                           version <- ns[[".package"]][["version"]]
[08:27:25.524]                           if (is.null(version)) 
[08:27:25.524]                             version <- utils::packageVersion("future")
[08:27:25.524]                         }
[08:27:25.524]                         else {
[08:27:25.524]                           version <- NULL
[08:27:25.524]                         }
[08:27:25.524]                         if (!has_future || version < "1.8.0") {
[08:27:25.524]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:25.524]                             "", base::R.version$version.string), 
[08:27:25.524]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:25.524]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:25.524]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:25.524]                               "release", "version")], collapse = " "), 
[08:27:25.524]                             hostname = base::Sys.info()[["nodename"]])
[08:27:25.524]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:25.524]                             info)
[08:27:25.524]                           info <- base::paste(info, collapse = "; ")
[08:27:25.524]                           if (!has_future) {
[08:27:25.524]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:25.524]                               info)
[08:27:25.524]                           }
[08:27:25.524]                           else {
[08:27:25.524]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:25.524]                               info, version)
[08:27:25.524]                           }
[08:27:25.524]                           base::stop(msg)
[08:27:25.524]                         }
[08:27:25.524]                       })
[08:27:25.524]                     }
[08:27:25.524]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:25.524]                     base::options(mc.cores = 1L)
[08:27:25.524]                   }
[08:27:25.524]                   ...future.strategy.old <- future::plan("list")
[08:27:25.524]                   options(future.plan = NULL)
[08:27:25.524]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.524]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:25.524]                 }
[08:27:25.524]                 ...future.workdir <- getwd()
[08:27:25.524]             }
[08:27:25.524]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:25.524]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:25.524]         }
[08:27:25.524]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:25.524]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:25.524]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:25.524]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:25.524]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:25.524]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:25.524]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:25.524]             base::names(...future.oldOptions))
[08:27:25.524]     }
[08:27:25.524]     if (FALSE) {
[08:27:25.524]     }
[08:27:25.524]     else {
[08:27:25.524]         if (TRUE) {
[08:27:25.524]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:25.524]                 open = "w")
[08:27:25.524]         }
[08:27:25.524]         else {
[08:27:25.524]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:25.524]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:25.524]         }
[08:27:25.524]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:25.524]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:25.524]             base::sink(type = "output", split = FALSE)
[08:27:25.524]             base::close(...future.stdout)
[08:27:25.524]         }, add = TRUE)
[08:27:25.524]     }
[08:27:25.524]     ...future.frame <- base::sys.nframe()
[08:27:25.524]     ...future.conditions <- base::list()
[08:27:25.524]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:25.524]     if (FALSE) {
[08:27:25.524]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:25.524]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:25.524]     }
[08:27:25.524]     ...future.result <- base::tryCatch({
[08:27:25.524]         base::withCallingHandlers({
[08:27:25.524]             ...future.value <- base::withVisible(base::local({
[08:27:25.524]                 withCallingHandlers({
[08:27:25.524]                   {
[08:27:25.524]                     do.call(function(...) {
[08:27:25.524]                       sum(x, ...)
[08:27:25.524]                     }, args = future.call.arguments)
[08:27:25.524]                   }
[08:27:25.524]                 }, immediateCondition = function(cond) {
[08:27:25.524]                   save_rds <- function (object, pathname, ...) 
[08:27:25.524]                   {
[08:27:25.524]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:25.524]                     if (file_test("-f", pathname_tmp)) {
[08:27:25.524]                       fi_tmp <- file.info(pathname_tmp)
[08:27:25.524]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:25.524]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:25.524]                         fi_tmp[["mtime"]])
[08:27:25.524]                     }
[08:27:25.524]                     tryCatch({
[08:27:25.524]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:25.524]                     }, error = function(ex) {
[08:27:25.524]                       msg <- conditionMessage(ex)
[08:27:25.524]                       fi_tmp <- file.info(pathname_tmp)
[08:27:25.524]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:25.524]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:25.524]                         fi_tmp[["mtime"]], msg)
[08:27:25.524]                       ex$message <- msg
[08:27:25.524]                       stop(ex)
[08:27:25.524]                     })
[08:27:25.524]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:25.524]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:25.524]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:25.524]                       fi_tmp <- file.info(pathname_tmp)
[08:27:25.524]                       fi <- file.info(pathname)
[08:27:25.524]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:25.524]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:25.524]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:25.524]                         fi[["size"]], fi[["mtime"]])
[08:27:25.524]                       stop(msg)
[08:27:25.524]                     }
[08:27:25.524]                     invisible(pathname)
[08:27:25.524]                   }
[08:27:25.524]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:25.524]                     rootPath = tempdir()) 
[08:27:25.524]                   {
[08:27:25.524]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:25.524]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:25.524]                       tmpdir = path, fileext = ".rds")
[08:27:25.524]                     save_rds(obj, file)
[08:27:25.524]                   }
[08:27:25.524]                   saveImmediateCondition(cond, path = "/tmp/RtmpdixJ0p/.future/immediateConditions")
[08:27:25.524]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.524]                   {
[08:27:25.524]                     inherits <- base::inherits
[08:27:25.524]                     invokeRestart <- base::invokeRestart
[08:27:25.524]                     is.null <- base::is.null
[08:27:25.524]                     muffled <- FALSE
[08:27:25.524]                     if (inherits(cond, "message")) {
[08:27:25.524]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:25.524]                       if (muffled) 
[08:27:25.524]                         invokeRestart("muffleMessage")
[08:27:25.524]                     }
[08:27:25.524]                     else if (inherits(cond, "warning")) {
[08:27:25.524]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:25.524]                       if (muffled) 
[08:27:25.524]                         invokeRestart("muffleWarning")
[08:27:25.524]                     }
[08:27:25.524]                     else if (inherits(cond, "condition")) {
[08:27:25.524]                       if (!is.null(pattern)) {
[08:27:25.524]                         computeRestarts <- base::computeRestarts
[08:27:25.524]                         grepl <- base::grepl
[08:27:25.524]                         restarts <- computeRestarts(cond)
[08:27:25.524]                         for (restart in restarts) {
[08:27:25.524]                           name <- restart$name
[08:27:25.524]                           if (is.null(name)) 
[08:27:25.524]                             next
[08:27:25.524]                           if (!grepl(pattern, name)) 
[08:27:25.524]                             next
[08:27:25.524]                           invokeRestart(restart)
[08:27:25.524]                           muffled <- TRUE
[08:27:25.524]                           break
[08:27:25.524]                         }
[08:27:25.524]                       }
[08:27:25.524]                     }
[08:27:25.524]                     invisible(muffled)
[08:27:25.524]                   }
[08:27:25.524]                   muffleCondition(cond)
[08:27:25.524]                 })
[08:27:25.524]             }))
[08:27:25.524]             future::FutureResult(value = ...future.value$value, 
[08:27:25.524]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.524]                   ...future.rng), globalenv = if (FALSE) 
[08:27:25.524]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:25.524]                     ...future.globalenv.names))
[08:27:25.524]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:25.524]         }, condition = base::local({
[08:27:25.524]             c <- base::c
[08:27:25.524]             inherits <- base::inherits
[08:27:25.524]             invokeRestart <- base::invokeRestart
[08:27:25.524]             length <- base::length
[08:27:25.524]             list <- base::list
[08:27:25.524]             seq.int <- base::seq.int
[08:27:25.524]             signalCondition <- base::signalCondition
[08:27:25.524]             sys.calls <- base::sys.calls
[08:27:25.524]             `[[` <- base::`[[`
[08:27:25.524]             `+` <- base::`+`
[08:27:25.524]             `<<-` <- base::`<<-`
[08:27:25.524]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:25.524]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:25.524]                   3L)]
[08:27:25.524]             }
[08:27:25.524]             function(cond) {
[08:27:25.524]                 is_error <- inherits(cond, "error")
[08:27:25.524]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:25.524]                   NULL)
[08:27:25.524]                 if (is_error) {
[08:27:25.524]                   sessionInformation <- function() {
[08:27:25.524]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:25.524]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:25.524]                       search = base::search(), system = base::Sys.info())
[08:27:25.524]                   }
[08:27:25.524]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.524]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:25.524]                     cond$call), session = sessionInformation(), 
[08:27:25.524]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:25.524]                   signalCondition(cond)
[08:27:25.524]                 }
[08:27:25.524]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:25.524]                 "immediateCondition"))) {
[08:27:25.524]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:25.524]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.524]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:25.524]                   if (TRUE && !signal) {
[08:27:25.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.524]                     {
[08:27:25.524]                       inherits <- base::inherits
[08:27:25.524]                       invokeRestart <- base::invokeRestart
[08:27:25.524]                       is.null <- base::is.null
[08:27:25.524]                       muffled <- FALSE
[08:27:25.524]                       if (inherits(cond, "message")) {
[08:27:25.524]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.524]                         if (muffled) 
[08:27:25.524]                           invokeRestart("muffleMessage")
[08:27:25.524]                       }
[08:27:25.524]                       else if (inherits(cond, "warning")) {
[08:27:25.524]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.524]                         if (muffled) 
[08:27:25.524]                           invokeRestart("muffleWarning")
[08:27:25.524]                       }
[08:27:25.524]                       else if (inherits(cond, "condition")) {
[08:27:25.524]                         if (!is.null(pattern)) {
[08:27:25.524]                           computeRestarts <- base::computeRestarts
[08:27:25.524]                           grepl <- base::grepl
[08:27:25.524]                           restarts <- computeRestarts(cond)
[08:27:25.524]                           for (restart in restarts) {
[08:27:25.524]                             name <- restart$name
[08:27:25.524]                             if (is.null(name)) 
[08:27:25.524]                               next
[08:27:25.524]                             if (!grepl(pattern, name)) 
[08:27:25.524]                               next
[08:27:25.524]                             invokeRestart(restart)
[08:27:25.524]                             muffled <- TRUE
[08:27:25.524]                             break
[08:27:25.524]                           }
[08:27:25.524]                         }
[08:27:25.524]                       }
[08:27:25.524]                       invisible(muffled)
[08:27:25.524]                     }
[08:27:25.524]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.524]                   }
[08:27:25.524]                 }
[08:27:25.524]                 else {
[08:27:25.524]                   if (TRUE) {
[08:27:25.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.524]                     {
[08:27:25.524]                       inherits <- base::inherits
[08:27:25.524]                       invokeRestart <- base::invokeRestart
[08:27:25.524]                       is.null <- base::is.null
[08:27:25.524]                       muffled <- FALSE
[08:27:25.524]                       if (inherits(cond, "message")) {
[08:27:25.524]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.524]                         if (muffled) 
[08:27:25.524]                           invokeRestart("muffleMessage")
[08:27:25.524]                       }
[08:27:25.524]                       else if (inherits(cond, "warning")) {
[08:27:25.524]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.524]                         if (muffled) 
[08:27:25.524]                           invokeRestart("muffleWarning")
[08:27:25.524]                       }
[08:27:25.524]                       else if (inherits(cond, "condition")) {
[08:27:25.524]                         if (!is.null(pattern)) {
[08:27:25.524]                           computeRestarts <- base::computeRestarts
[08:27:25.524]                           grepl <- base::grepl
[08:27:25.524]                           restarts <- computeRestarts(cond)
[08:27:25.524]                           for (restart in restarts) {
[08:27:25.524]                             name <- restart$name
[08:27:25.524]                             if (is.null(name)) 
[08:27:25.524]                               next
[08:27:25.524]                             if (!grepl(pattern, name)) 
[08:27:25.524]                               next
[08:27:25.524]                             invokeRestart(restart)
[08:27:25.524]                             muffled <- TRUE
[08:27:25.524]                             break
[08:27:25.524]                           }
[08:27:25.524]                         }
[08:27:25.524]                       }
[08:27:25.524]                       invisible(muffled)
[08:27:25.524]                     }
[08:27:25.524]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.524]                   }
[08:27:25.524]                 }
[08:27:25.524]             }
[08:27:25.524]         }))
[08:27:25.524]     }, error = function(ex) {
[08:27:25.524]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:25.524]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.524]                 ...future.rng), started = ...future.startTime, 
[08:27:25.524]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:25.524]             version = "1.8"), class = "FutureResult")
[08:27:25.524]     }, finally = {
[08:27:25.524]         if (!identical(...future.workdir, getwd())) 
[08:27:25.524]             setwd(...future.workdir)
[08:27:25.524]         {
[08:27:25.524]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:25.524]                 ...future.oldOptions$nwarnings <- NULL
[08:27:25.524]             }
[08:27:25.524]             base::options(...future.oldOptions)
[08:27:25.524]             if (.Platform$OS.type == "windows") {
[08:27:25.524]                 old_names <- names(...future.oldEnvVars)
[08:27:25.524]                 envs <- base::Sys.getenv()
[08:27:25.524]                 names <- names(envs)
[08:27:25.524]                 common <- intersect(names, old_names)
[08:27:25.524]                 added <- setdiff(names, old_names)
[08:27:25.524]                 removed <- setdiff(old_names, names)
[08:27:25.524]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:25.524]                   envs[common]]
[08:27:25.524]                 NAMES <- toupper(changed)
[08:27:25.524]                 args <- list()
[08:27:25.524]                 for (kk in seq_along(NAMES)) {
[08:27:25.524]                   name <- changed[[kk]]
[08:27:25.524]                   NAME <- NAMES[[kk]]
[08:27:25.524]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.524]                     next
[08:27:25.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.524]                 }
[08:27:25.524]                 NAMES <- toupper(added)
[08:27:25.524]                 for (kk in seq_along(NAMES)) {
[08:27:25.524]                   name <- added[[kk]]
[08:27:25.524]                   NAME <- NAMES[[kk]]
[08:27:25.524]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.524]                     next
[08:27:25.524]                   args[[name]] <- ""
[08:27:25.524]                 }
[08:27:25.524]                 NAMES <- toupper(removed)
[08:27:25.524]                 for (kk in seq_along(NAMES)) {
[08:27:25.524]                   name <- removed[[kk]]
[08:27:25.524]                   NAME <- NAMES[[kk]]
[08:27:25.524]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.524]                     next
[08:27:25.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.524]                 }
[08:27:25.524]                 if (length(args) > 0) 
[08:27:25.524]                   base::do.call(base::Sys.setenv, args = args)
[08:27:25.524]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:25.524]             }
[08:27:25.524]             else {
[08:27:25.524]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:25.524]             }
[08:27:25.524]             {
[08:27:25.524]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:25.524]                   0L) {
[08:27:25.524]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:25.524]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:25.524]                   base::options(opts)
[08:27:25.524]                 }
[08:27:25.524]                 {
[08:27:25.524]                   {
[08:27:25.524]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:25.524]                     NULL
[08:27:25.524]                   }
[08:27:25.524]                   options(future.plan = NULL)
[08:27:25.524]                   if (is.na(NA_character_)) 
[08:27:25.524]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.524]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:25.524]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:25.524]                     .init = FALSE)
[08:27:25.524]                 }
[08:27:25.524]             }
[08:27:25.524]         }
[08:27:25.524]     })
[08:27:25.524]     if (TRUE) {
[08:27:25.524]         base::sink(type = "output", split = FALSE)
[08:27:25.524]         if (TRUE) {
[08:27:25.524]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:25.524]         }
[08:27:25.524]         else {
[08:27:25.524]             ...future.result["stdout"] <- base::list(NULL)
[08:27:25.524]         }
[08:27:25.524]         base::close(...future.stdout)
[08:27:25.524]         ...future.stdout <- NULL
[08:27:25.524]     }
[08:27:25.524]     ...future.result$conditions <- ...future.conditions
[08:27:25.524]     ...future.result$finished <- base::Sys.time()
[08:27:25.524]     ...future.result
[08:27:25.524] }
[08:27:25.527] assign_globals() ...
[08:27:25.527] List of 2
[08:27:25.527]  $ x                    : int [1:2] 1 2
[08:27:25.527]  $ future.call.arguments:List of 1
[08:27:25.527]   ..$ : num 3
[08:27:25.527]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:27:25.527]  - attr(*, "where")=List of 2
[08:27:25.527]   ..$ x                    :<environment: R_EmptyEnv> 
[08:27:25.527]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[08:27:25.527]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:25.527]  - attr(*, "resolved")= logi FALSE
[08:27:25.527]  - attr(*, "total_size")= num 246
[08:27:25.527]  - attr(*, "already-done")= logi TRUE
[08:27:25.531] - copied ‘x’ to environment
[08:27:25.531] - copied ‘future.call.arguments’ to environment
[08:27:25.531] assign_globals() ... done
[08:27:25.532] requestCore(): workers = 2
[08:27:25.534] MulticoreFuture started
[08:27:25.534] - Launch lazy future ... done
[08:27:25.535] run() for ‘MulticoreFuture’ ... done
[08:27:25.535] result() for MulticoreFuture ...
[08:27:25.535] plan(): Setting new future strategy stack:
[08:27:25.535] List of future strategies:
[08:27:25.535] 1. sequential:
[08:27:25.535]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:25.535]    - tweaked: FALSE
[08:27:25.535]    - call: NULL
[08:27:25.536] plan(): nbrOfWorkers() = 1
[08:27:25.538] plan(): Setting new future strategy stack:
[08:27:25.538] List of future strategies:
[08:27:25.538] 1. multicore:
[08:27:25.538]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:25.538]    - tweaked: FALSE
[08:27:25.538]    - call: plan(strategy, substitute = FALSE)
[08:27:25.546] plan(): nbrOfWorkers() = 2
[08:27:25.547] result() for MulticoreFuture ...
[08:27:25.548] result() for MulticoreFuture ... done
[08:27:25.548] result() for MulticoreFuture ... done
[08:27:25.548] result() for MulticoreFuture ...
[08:27:25.548] result() for MulticoreFuture ... done
[1] 6
** Sum function 'C' with plan('multicore') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y)
    }
    y
}
<bytecode: 0x55940187c6a8>
Arguments '...' exists: FALSE
[08:27:25.549] getGlobalsAndPackages() ...
[08:27:25.549] Searching for globals...
[08:27:25.554] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘y’
[08:27:25.554] Searching for globals ... DONE
[08:27:25.554] Resolving globals: FALSE
[08:27:25.555] The total size of the 2 globals is 172 bytes (172 bytes)
[08:27:25.555] The total size of the 2 globals exported for future expression (‘{; sum(x, y); }’) is 172 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (133 bytes of class ‘numeric’) and ‘y’ (39 bytes of class ‘numeric’)
[08:27:25.555] - globals: [2] ‘x’, ‘y’
[08:27:25.556] 
[08:27:25.556] getGlobalsAndPackages() ... DONE
[08:27:25.556] run() for ‘Future’ ...
[08:27:25.556] - state: ‘created’
[08:27:25.556] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:25.558] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:25.559] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:25.559]   - Field: ‘label’
[08:27:25.559]   - Field: ‘local’
[08:27:25.559]   - Field: ‘owner’
[08:27:25.559]   - Field: ‘envir’
[08:27:25.559]   - Field: ‘workers’
[08:27:25.559]   - Field: ‘packages’
[08:27:25.559]   - Field: ‘gc’
[08:27:25.560]   - Field: ‘job’
[08:27:25.560]   - Field: ‘conditions’
[08:27:25.560]   - Field: ‘expr’
[08:27:25.560]   - Field: ‘uuid’
[08:27:25.560]   - Field: ‘seed’
[08:27:25.560]   - Field: ‘version’
[08:27:25.560]   - Field: ‘result’
[08:27:25.560]   - Field: ‘asynchronous’
[08:27:25.560]   - Field: ‘calls’
[08:27:25.561]   - Field: ‘globals’
[08:27:25.561]   - Field: ‘stdout’
[08:27:25.561]   - Field: ‘earlySignal’
[08:27:25.561]   - Field: ‘lazy’
[08:27:25.561]   - Field: ‘state’
[08:27:25.561] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:25.561] - Launch lazy future ...
[08:27:25.562] Packages needed by the future expression (n = 0): <none>
[08:27:25.562] Packages needed by future strategies (n = 0): <none>
[08:27:25.562] {
[08:27:25.562]     {
[08:27:25.562]         {
[08:27:25.562]             ...future.startTime <- base::Sys.time()
[08:27:25.562]             {
[08:27:25.562]                 {
[08:27:25.562]                   {
[08:27:25.562]                     {
[08:27:25.562]                       base::local({
[08:27:25.562]                         has_future <- base::requireNamespace("future", 
[08:27:25.562]                           quietly = TRUE)
[08:27:25.562]                         if (has_future) {
[08:27:25.562]                           ns <- base::getNamespace("future")
[08:27:25.562]                           version <- ns[[".package"]][["version"]]
[08:27:25.562]                           if (is.null(version)) 
[08:27:25.562]                             version <- utils::packageVersion("future")
[08:27:25.562]                         }
[08:27:25.562]                         else {
[08:27:25.562]                           version <- NULL
[08:27:25.562]                         }
[08:27:25.562]                         if (!has_future || version < "1.8.0") {
[08:27:25.562]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:25.562]                             "", base::R.version$version.string), 
[08:27:25.562]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:25.562]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:25.562]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:25.562]                               "release", "version")], collapse = " "), 
[08:27:25.562]                             hostname = base::Sys.info()[["nodename"]])
[08:27:25.562]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:25.562]                             info)
[08:27:25.562]                           info <- base::paste(info, collapse = "; ")
[08:27:25.562]                           if (!has_future) {
[08:27:25.562]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:25.562]                               info)
[08:27:25.562]                           }
[08:27:25.562]                           else {
[08:27:25.562]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:25.562]                               info, version)
[08:27:25.562]                           }
[08:27:25.562]                           base::stop(msg)
[08:27:25.562]                         }
[08:27:25.562]                       })
[08:27:25.562]                     }
[08:27:25.562]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:25.562]                     base::options(mc.cores = 1L)
[08:27:25.562]                   }
[08:27:25.562]                   ...future.strategy.old <- future::plan("list")
[08:27:25.562]                   options(future.plan = NULL)
[08:27:25.562]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.562]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:25.562]                 }
[08:27:25.562]                 ...future.workdir <- getwd()
[08:27:25.562]             }
[08:27:25.562]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:25.562]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:25.562]         }
[08:27:25.562]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:25.562]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:25.562]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:25.562]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:25.562]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:25.562]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:25.562]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:25.562]             base::names(...future.oldOptions))
[08:27:25.562]     }
[08:27:25.562]     if (FALSE) {
[08:27:25.562]     }
[08:27:25.562]     else {
[08:27:25.562]         if (TRUE) {
[08:27:25.562]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:25.562]                 open = "w")
[08:27:25.562]         }
[08:27:25.562]         else {
[08:27:25.562]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:25.562]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:25.562]         }
[08:27:25.562]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:25.562]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:25.562]             base::sink(type = "output", split = FALSE)
[08:27:25.562]             base::close(...future.stdout)
[08:27:25.562]         }, add = TRUE)
[08:27:25.562]     }
[08:27:25.562]     ...future.frame <- base::sys.nframe()
[08:27:25.562]     ...future.conditions <- base::list()
[08:27:25.562]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:25.562]     if (FALSE) {
[08:27:25.562]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:25.562]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:25.562]     }
[08:27:25.562]     ...future.result <- base::tryCatch({
[08:27:25.562]         base::withCallingHandlers({
[08:27:25.562]             ...future.value <- base::withVisible(base::local({
[08:27:25.562]                 withCallingHandlers({
[08:27:25.562]                   {
[08:27:25.562]                     sum(x, y)
[08:27:25.562]                   }
[08:27:25.562]                 }, immediateCondition = function(cond) {
[08:27:25.562]                   save_rds <- function (object, pathname, ...) 
[08:27:25.562]                   {
[08:27:25.562]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:25.562]                     if (file_test("-f", pathname_tmp)) {
[08:27:25.562]                       fi_tmp <- file.info(pathname_tmp)
[08:27:25.562]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:25.562]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:25.562]                         fi_tmp[["mtime"]])
[08:27:25.562]                     }
[08:27:25.562]                     tryCatch({
[08:27:25.562]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:25.562]                     }, error = function(ex) {
[08:27:25.562]                       msg <- conditionMessage(ex)
[08:27:25.562]                       fi_tmp <- file.info(pathname_tmp)
[08:27:25.562]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:25.562]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:25.562]                         fi_tmp[["mtime"]], msg)
[08:27:25.562]                       ex$message <- msg
[08:27:25.562]                       stop(ex)
[08:27:25.562]                     })
[08:27:25.562]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:25.562]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:25.562]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:25.562]                       fi_tmp <- file.info(pathname_tmp)
[08:27:25.562]                       fi <- file.info(pathname)
[08:27:25.562]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:25.562]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:25.562]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:25.562]                         fi[["size"]], fi[["mtime"]])
[08:27:25.562]                       stop(msg)
[08:27:25.562]                     }
[08:27:25.562]                     invisible(pathname)
[08:27:25.562]                   }
[08:27:25.562]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:25.562]                     rootPath = tempdir()) 
[08:27:25.562]                   {
[08:27:25.562]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:25.562]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:25.562]                       tmpdir = path, fileext = ".rds")
[08:27:25.562]                     save_rds(obj, file)
[08:27:25.562]                   }
[08:27:25.562]                   saveImmediateCondition(cond, path = "/tmp/RtmpdixJ0p/.future/immediateConditions")
[08:27:25.562]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.562]                   {
[08:27:25.562]                     inherits <- base::inherits
[08:27:25.562]                     invokeRestart <- base::invokeRestart
[08:27:25.562]                     is.null <- base::is.null
[08:27:25.562]                     muffled <- FALSE
[08:27:25.562]                     if (inherits(cond, "message")) {
[08:27:25.562]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:25.562]                       if (muffled) 
[08:27:25.562]                         invokeRestart("muffleMessage")
[08:27:25.562]                     }
[08:27:25.562]                     else if (inherits(cond, "warning")) {
[08:27:25.562]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:25.562]                       if (muffled) 
[08:27:25.562]                         invokeRestart("muffleWarning")
[08:27:25.562]                     }
[08:27:25.562]                     else if (inherits(cond, "condition")) {
[08:27:25.562]                       if (!is.null(pattern)) {
[08:27:25.562]                         computeRestarts <- base::computeRestarts
[08:27:25.562]                         grepl <- base::grepl
[08:27:25.562]                         restarts <- computeRestarts(cond)
[08:27:25.562]                         for (restart in restarts) {
[08:27:25.562]                           name <- restart$name
[08:27:25.562]                           if (is.null(name)) 
[08:27:25.562]                             next
[08:27:25.562]                           if (!grepl(pattern, name)) 
[08:27:25.562]                             next
[08:27:25.562]                           invokeRestart(restart)
[08:27:25.562]                           muffled <- TRUE
[08:27:25.562]                           break
[08:27:25.562]                         }
[08:27:25.562]                       }
[08:27:25.562]                     }
[08:27:25.562]                     invisible(muffled)
[08:27:25.562]                   }
[08:27:25.562]                   muffleCondition(cond)
[08:27:25.562]                 })
[08:27:25.562]             }))
[08:27:25.562]             future::FutureResult(value = ...future.value$value, 
[08:27:25.562]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.562]                   ...future.rng), globalenv = if (FALSE) 
[08:27:25.562]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:25.562]                     ...future.globalenv.names))
[08:27:25.562]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:25.562]         }, condition = base::local({
[08:27:25.562]             c <- base::c
[08:27:25.562]             inherits <- base::inherits
[08:27:25.562]             invokeRestart <- base::invokeRestart
[08:27:25.562]             length <- base::length
[08:27:25.562]             list <- base::list
[08:27:25.562]             seq.int <- base::seq.int
[08:27:25.562]             signalCondition <- base::signalCondition
[08:27:25.562]             sys.calls <- base::sys.calls
[08:27:25.562]             `[[` <- base::`[[`
[08:27:25.562]             `+` <- base::`+`
[08:27:25.562]             `<<-` <- base::`<<-`
[08:27:25.562]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:25.562]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:25.562]                   3L)]
[08:27:25.562]             }
[08:27:25.562]             function(cond) {
[08:27:25.562]                 is_error <- inherits(cond, "error")
[08:27:25.562]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:25.562]                   NULL)
[08:27:25.562]                 if (is_error) {
[08:27:25.562]                   sessionInformation <- function() {
[08:27:25.562]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:25.562]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:25.562]                       search = base::search(), system = base::Sys.info())
[08:27:25.562]                   }
[08:27:25.562]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.562]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:25.562]                     cond$call), session = sessionInformation(), 
[08:27:25.562]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:25.562]                   signalCondition(cond)
[08:27:25.562]                 }
[08:27:25.562]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:25.562]                 "immediateCondition"))) {
[08:27:25.562]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:25.562]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.562]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:25.562]                   if (TRUE && !signal) {
[08:27:25.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.562]                     {
[08:27:25.562]                       inherits <- base::inherits
[08:27:25.562]                       invokeRestart <- base::invokeRestart
[08:27:25.562]                       is.null <- base::is.null
[08:27:25.562]                       muffled <- FALSE
[08:27:25.562]                       if (inherits(cond, "message")) {
[08:27:25.562]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.562]                         if (muffled) 
[08:27:25.562]                           invokeRestart("muffleMessage")
[08:27:25.562]                       }
[08:27:25.562]                       else if (inherits(cond, "warning")) {
[08:27:25.562]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.562]                         if (muffled) 
[08:27:25.562]                           invokeRestart("muffleWarning")
[08:27:25.562]                       }
[08:27:25.562]                       else if (inherits(cond, "condition")) {
[08:27:25.562]                         if (!is.null(pattern)) {
[08:27:25.562]                           computeRestarts <- base::computeRestarts
[08:27:25.562]                           grepl <- base::grepl
[08:27:25.562]                           restarts <- computeRestarts(cond)
[08:27:25.562]                           for (restart in restarts) {
[08:27:25.562]                             name <- restart$name
[08:27:25.562]                             if (is.null(name)) 
[08:27:25.562]                               next
[08:27:25.562]                             if (!grepl(pattern, name)) 
[08:27:25.562]                               next
[08:27:25.562]                             invokeRestart(restart)
[08:27:25.562]                             muffled <- TRUE
[08:27:25.562]                             break
[08:27:25.562]                           }
[08:27:25.562]                         }
[08:27:25.562]                       }
[08:27:25.562]                       invisible(muffled)
[08:27:25.562]                     }
[08:27:25.562]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.562]                   }
[08:27:25.562]                 }
[08:27:25.562]                 else {
[08:27:25.562]                   if (TRUE) {
[08:27:25.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.562]                     {
[08:27:25.562]                       inherits <- base::inherits
[08:27:25.562]                       invokeRestart <- base::invokeRestart
[08:27:25.562]                       is.null <- base::is.null
[08:27:25.562]                       muffled <- FALSE
[08:27:25.562]                       if (inherits(cond, "message")) {
[08:27:25.562]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.562]                         if (muffled) 
[08:27:25.562]                           invokeRestart("muffleMessage")
[08:27:25.562]                       }
[08:27:25.562]                       else if (inherits(cond, "warning")) {
[08:27:25.562]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.562]                         if (muffled) 
[08:27:25.562]                           invokeRestart("muffleWarning")
[08:27:25.562]                       }
[08:27:25.562]                       else if (inherits(cond, "condition")) {
[08:27:25.562]                         if (!is.null(pattern)) {
[08:27:25.562]                           computeRestarts <- base::computeRestarts
[08:27:25.562]                           grepl <- base::grepl
[08:27:25.562]                           restarts <- computeRestarts(cond)
[08:27:25.562]                           for (restart in restarts) {
[08:27:25.562]                             name <- restart$name
[08:27:25.562]                             if (is.null(name)) 
[08:27:25.562]                               next
[08:27:25.562]                             if (!grepl(pattern, name)) 
[08:27:25.562]                               next
[08:27:25.562]                             invokeRestart(restart)
[08:27:25.562]                             muffled <- TRUE
[08:27:25.562]                             break
[08:27:25.562]                           }
[08:27:25.562]                         }
[08:27:25.562]                       }
[08:27:25.562]                       invisible(muffled)
[08:27:25.562]                     }
[08:27:25.562]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.562]                   }
[08:27:25.562]                 }
[08:27:25.562]             }
[08:27:25.562]         }))
[08:27:25.562]     }, error = function(ex) {
[08:27:25.562]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:25.562]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.562]                 ...future.rng), started = ...future.startTime, 
[08:27:25.562]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:25.562]             version = "1.8"), class = "FutureResult")
[08:27:25.562]     }, finally = {
[08:27:25.562]         if (!identical(...future.workdir, getwd())) 
[08:27:25.562]             setwd(...future.workdir)
[08:27:25.562]         {
[08:27:25.562]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:25.562]                 ...future.oldOptions$nwarnings <- NULL
[08:27:25.562]             }
[08:27:25.562]             base::options(...future.oldOptions)
[08:27:25.562]             if (.Platform$OS.type == "windows") {
[08:27:25.562]                 old_names <- names(...future.oldEnvVars)
[08:27:25.562]                 envs <- base::Sys.getenv()
[08:27:25.562]                 names <- names(envs)
[08:27:25.562]                 common <- intersect(names, old_names)
[08:27:25.562]                 added <- setdiff(names, old_names)
[08:27:25.562]                 removed <- setdiff(old_names, names)
[08:27:25.562]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:25.562]                   envs[common]]
[08:27:25.562]                 NAMES <- toupper(changed)
[08:27:25.562]                 args <- list()
[08:27:25.562]                 for (kk in seq_along(NAMES)) {
[08:27:25.562]                   name <- changed[[kk]]
[08:27:25.562]                   NAME <- NAMES[[kk]]
[08:27:25.562]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.562]                     next
[08:27:25.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.562]                 }
[08:27:25.562]                 NAMES <- toupper(added)
[08:27:25.562]                 for (kk in seq_along(NAMES)) {
[08:27:25.562]                   name <- added[[kk]]
[08:27:25.562]                   NAME <- NAMES[[kk]]
[08:27:25.562]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.562]                     next
[08:27:25.562]                   args[[name]] <- ""
[08:27:25.562]                 }
[08:27:25.562]                 NAMES <- toupper(removed)
[08:27:25.562]                 for (kk in seq_along(NAMES)) {
[08:27:25.562]                   name <- removed[[kk]]
[08:27:25.562]                   NAME <- NAMES[[kk]]
[08:27:25.562]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.562]                     next
[08:27:25.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.562]                 }
[08:27:25.562]                 if (length(args) > 0) 
[08:27:25.562]                   base::do.call(base::Sys.setenv, args = args)
[08:27:25.562]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:25.562]             }
[08:27:25.562]             else {
[08:27:25.562]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:25.562]             }
[08:27:25.562]             {
[08:27:25.562]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:25.562]                   0L) {
[08:27:25.562]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:25.562]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:25.562]                   base::options(opts)
[08:27:25.562]                 }
[08:27:25.562]                 {
[08:27:25.562]                   {
[08:27:25.562]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:25.562]                     NULL
[08:27:25.562]                   }
[08:27:25.562]                   options(future.plan = NULL)
[08:27:25.562]                   if (is.na(NA_character_)) 
[08:27:25.562]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.562]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:25.562]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:25.562]                     .init = FALSE)
[08:27:25.562]                 }
[08:27:25.562]             }
[08:27:25.562]         }
[08:27:25.562]     })
[08:27:25.562]     if (TRUE) {
[08:27:25.562]         base::sink(type = "output", split = FALSE)
[08:27:25.562]         if (TRUE) {
[08:27:25.562]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:25.562]         }
[08:27:25.562]         else {
[08:27:25.562]             ...future.result["stdout"] <- base::list(NULL)
[08:27:25.562]         }
[08:27:25.562]         base::close(...future.stdout)
[08:27:25.562]         ...future.stdout <- NULL
[08:27:25.562]     }
[08:27:25.562]     ...future.result$conditions <- ...future.conditions
[08:27:25.562]     ...future.result$finished <- base::Sys.time()
[08:27:25.562]     ...future.result
[08:27:25.562] }
[08:27:25.565] assign_globals() ...
[08:27:25.565] List of 2
[08:27:25.565]  $ x: int [1:2] 1 2
[08:27:25.565]  $ y: num 3
[08:27:25.565]  - attr(*, "where")=List of 2
[08:27:25.565]   ..$ x:<environment: R_EmptyEnv> 
[08:27:25.565]   ..$ y:<environment: R_EmptyEnv> 
[08:27:25.565]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:25.565]  - attr(*, "resolved")= logi FALSE
[08:27:25.565]  - attr(*, "total_size")= num 172
[08:27:25.565]  - attr(*, "already-done")= logi TRUE
[08:27:25.568] - copied ‘x’ to environment
[08:27:25.569] - copied ‘y’ to environment
[08:27:25.569] assign_globals() ... done
[08:27:25.569] requestCore(): workers = 2
[08:27:25.571] MulticoreFuture started
[08:27:25.571] - Launch lazy future ... done
[08:27:25.572] run() for ‘MulticoreFuture’ ... done
[08:27:25.572] result() for MulticoreFuture ...
[08:27:25.572] plan(): Setting new future strategy stack:
[08:27:25.572] List of future strategies:
[08:27:25.572] 1. sequential:
[08:27:25.572]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:25.572]    - tweaked: FALSE
[08:27:25.572]    - call: NULL
[08:27:25.573] plan(): nbrOfWorkers() = 1
[08:27:25.575] plan(): Setting new future strategy stack:
[08:27:25.575] List of future strategies:
[08:27:25.575] 1. multicore:
[08:27:25.575]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:25.575]    - tweaked: FALSE
[08:27:25.575]    - call: plan(strategy, substitute = FALSE)
[08:27:25.579] plan(): nbrOfWorkers() = 2
[08:27:25.579] result() for MulticoreFuture ...
[08:27:25.580] result() for MulticoreFuture ... done
[08:27:25.580] result() for MulticoreFuture ... done
[08:27:25.580] result() for MulticoreFuture ...
[08:27:25.580] result() for MulticoreFuture ... done
[1] 6
** Sum function 'D' with plan('multicore') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y, ...)
    }
    y
}
<bytecode: 0x559401ce4780>
Arguments '...' exists: FALSE
[08:27:25.581] getGlobalsAndPackages() ...
[08:27:25.581] Searching for globals...
[08:27:25.583] - globals found: [5] ‘{’, ‘sum’, ‘x’, ‘y’, ‘...’
[08:27:25.583] Searching for globals ... DONE
[08:27:25.583] Resolving globals: FALSE
[08:27:25.584] Tweak future expression to call with '...' arguments ...
[08:27:25.584] The total size of the 2 globals is 172 bytes (172 bytes)
[08:27:25.585] The total size of the 2 globals exported for future expression (‘{; sum(x, y, ...); }’) is 172 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (133 bytes of class ‘numeric’) and ‘y’ (39 bytes of class ‘numeric’)
[08:27:25.585] - globals: [2] ‘x’, ‘y’
[08:27:25.585] 
[08:27:25.585] getGlobalsAndPackages() ... DONE
[08:27:25.585] run() for ‘Future’ ...
[08:27:25.585] - state: ‘created’
[08:27:25.586] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:25.588] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:25.588] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:25.588]   - Field: ‘label’
[08:27:25.588]   - Field: ‘local’
[08:27:25.588]   - Field: ‘owner’
[08:27:25.588]   - Field: ‘envir’
[08:27:25.588]   - Field: ‘workers’
[08:27:25.589]   - Field: ‘packages’
[08:27:25.589]   - Field: ‘gc’
[08:27:25.589]   - Field: ‘job’
[08:27:25.589]   - Field: ‘conditions’
[08:27:25.589]   - Field: ‘expr’
[08:27:25.589]   - Field: ‘uuid’
[08:27:25.589]   - Field: ‘seed’
[08:27:25.589]   - Field: ‘version’
[08:27:25.589]   - Field: ‘result’
[08:27:25.590]   - Field: ‘asynchronous’
[08:27:25.590]   - Field: ‘calls’
[08:27:25.590]   - Field: ‘globals’
[08:27:25.590]   - Field: ‘stdout’
[08:27:25.590]   - Field: ‘earlySignal’
[08:27:25.590]   - Field: ‘lazy’
[08:27:25.590]   - Field: ‘state’
[08:27:25.590] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:25.590] - Launch lazy future ...
[08:27:25.591] Packages needed by the future expression (n = 0): <none>
[08:27:25.591] Packages needed by future strategies (n = 0): <none>
[08:27:25.592] {
[08:27:25.592]     {
[08:27:25.592]         {
[08:27:25.592]             ...future.startTime <- base::Sys.time()
[08:27:25.592]             {
[08:27:25.592]                 {
[08:27:25.592]                   {
[08:27:25.592]                     {
[08:27:25.592]                       base::local({
[08:27:25.592]                         has_future <- base::requireNamespace("future", 
[08:27:25.592]                           quietly = TRUE)
[08:27:25.592]                         if (has_future) {
[08:27:25.592]                           ns <- base::getNamespace("future")
[08:27:25.592]                           version <- ns[[".package"]][["version"]]
[08:27:25.592]                           if (is.null(version)) 
[08:27:25.592]                             version <- utils::packageVersion("future")
[08:27:25.592]                         }
[08:27:25.592]                         else {
[08:27:25.592]                           version <- NULL
[08:27:25.592]                         }
[08:27:25.592]                         if (!has_future || version < "1.8.0") {
[08:27:25.592]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:25.592]                             "", base::R.version$version.string), 
[08:27:25.592]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:25.592]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:25.592]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:25.592]                               "release", "version")], collapse = " "), 
[08:27:25.592]                             hostname = base::Sys.info()[["nodename"]])
[08:27:25.592]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:25.592]                             info)
[08:27:25.592]                           info <- base::paste(info, collapse = "; ")
[08:27:25.592]                           if (!has_future) {
[08:27:25.592]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:25.592]                               info)
[08:27:25.592]                           }
[08:27:25.592]                           else {
[08:27:25.592]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:25.592]                               info, version)
[08:27:25.592]                           }
[08:27:25.592]                           base::stop(msg)
[08:27:25.592]                         }
[08:27:25.592]                       })
[08:27:25.592]                     }
[08:27:25.592]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:25.592]                     base::options(mc.cores = 1L)
[08:27:25.592]                   }
[08:27:25.592]                   ...future.strategy.old <- future::plan("list")
[08:27:25.592]                   options(future.plan = NULL)
[08:27:25.592]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.592]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:25.592]                 }
[08:27:25.592]                 ...future.workdir <- getwd()
[08:27:25.592]             }
[08:27:25.592]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:25.592]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:25.592]         }
[08:27:25.592]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:25.592]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:25.592]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:25.592]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:25.592]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:25.592]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:25.592]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:25.592]             base::names(...future.oldOptions))
[08:27:25.592]     }
[08:27:25.592]     if (FALSE) {
[08:27:25.592]     }
[08:27:25.592]     else {
[08:27:25.592]         if (TRUE) {
[08:27:25.592]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:25.592]                 open = "w")
[08:27:25.592]         }
[08:27:25.592]         else {
[08:27:25.592]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:25.592]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:25.592]         }
[08:27:25.592]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:25.592]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:25.592]             base::sink(type = "output", split = FALSE)
[08:27:25.592]             base::close(...future.stdout)
[08:27:25.592]         }, add = TRUE)
[08:27:25.592]     }
[08:27:25.592]     ...future.frame <- base::sys.nframe()
[08:27:25.592]     ...future.conditions <- base::list()
[08:27:25.592]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:25.592]     if (FALSE) {
[08:27:25.592]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:25.592]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:25.592]     }
[08:27:25.592]     ...future.result <- base::tryCatch({
[08:27:25.592]         base::withCallingHandlers({
[08:27:25.592]             ...future.value <- base::withVisible(base::local({
[08:27:25.592]                 withCallingHandlers({
[08:27:25.592]                   {
[08:27:25.592]                     sum(x, y, ...)
[08:27:25.592]                   }
[08:27:25.592]                 }, immediateCondition = function(cond) {
[08:27:25.592]                   save_rds <- function (object, pathname, ...) 
[08:27:25.592]                   {
[08:27:25.592]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:25.592]                     if (file_test("-f", pathname_tmp)) {
[08:27:25.592]                       fi_tmp <- file.info(pathname_tmp)
[08:27:25.592]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:25.592]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:25.592]                         fi_tmp[["mtime"]])
[08:27:25.592]                     }
[08:27:25.592]                     tryCatch({
[08:27:25.592]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:25.592]                     }, error = function(ex) {
[08:27:25.592]                       msg <- conditionMessage(ex)
[08:27:25.592]                       fi_tmp <- file.info(pathname_tmp)
[08:27:25.592]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:25.592]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:25.592]                         fi_tmp[["mtime"]], msg)
[08:27:25.592]                       ex$message <- msg
[08:27:25.592]                       stop(ex)
[08:27:25.592]                     })
[08:27:25.592]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:25.592]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:25.592]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:25.592]                       fi_tmp <- file.info(pathname_tmp)
[08:27:25.592]                       fi <- file.info(pathname)
[08:27:25.592]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:25.592]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:25.592]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:25.592]                         fi[["size"]], fi[["mtime"]])
[08:27:25.592]                       stop(msg)
[08:27:25.592]                     }
[08:27:25.592]                     invisible(pathname)
[08:27:25.592]                   }
[08:27:25.592]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:25.592]                     rootPath = tempdir()) 
[08:27:25.592]                   {
[08:27:25.592]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:25.592]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:25.592]                       tmpdir = path, fileext = ".rds")
[08:27:25.592]                     save_rds(obj, file)
[08:27:25.592]                   }
[08:27:25.592]                   saveImmediateCondition(cond, path = "/tmp/RtmpdixJ0p/.future/immediateConditions")
[08:27:25.592]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.592]                   {
[08:27:25.592]                     inherits <- base::inherits
[08:27:25.592]                     invokeRestart <- base::invokeRestart
[08:27:25.592]                     is.null <- base::is.null
[08:27:25.592]                     muffled <- FALSE
[08:27:25.592]                     if (inherits(cond, "message")) {
[08:27:25.592]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:25.592]                       if (muffled) 
[08:27:25.592]                         invokeRestart("muffleMessage")
[08:27:25.592]                     }
[08:27:25.592]                     else if (inherits(cond, "warning")) {
[08:27:25.592]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:25.592]                       if (muffled) 
[08:27:25.592]                         invokeRestart("muffleWarning")
[08:27:25.592]                     }
[08:27:25.592]                     else if (inherits(cond, "condition")) {
[08:27:25.592]                       if (!is.null(pattern)) {
[08:27:25.592]                         computeRestarts <- base::computeRestarts
[08:27:25.592]                         grepl <- base::grepl
[08:27:25.592]                         restarts <- computeRestarts(cond)
[08:27:25.592]                         for (restart in restarts) {
[08:27:25.592]                           name <- restart$name
[08:27:25.592]                           if (is.null(name)) 
[08:27:25.592]                             next
[08:27:25.592]                           if (!grepl(pattern, name)) 
[08:27:25.592]                             next
[08:27:25.592]                           invokeRestart(restart)
[08:27:25.592]                           muffled <- TRUE
[08:27:25.592]                           break
[08:27:25.592]                         }
[08:27:25.592]                       }
[08:27:25.592]                     }
[08:27:25.592]                     invisible(muffled)
[08:27:25.592]                   }
[08:27:25.592]                   muffleCondition(cond)
[08:27:25.592]                 })
[08:27:25.592]             }))
[08:27:25.592]             future::FutureResult(value = ...future.value$value, 
[08:27:25.592]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.592]                   ...future.rng), globalenv = if (FALSE) 
[08:27:25.592]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:25.592]                     ...future.globalenv.names))
[08:27:25.592]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:25.592]         }, condition = base::local({
[08:27:25.592]             c <- base::c
[08:27:25.592]             inherits <- base::inherits
[08:27:25.592]             invokeRestart <- base::invokeRestart
[08:27:25.592]             length <- base::length
[08:27:25.592]             list <- base::list
[08:27:25.592]             seq.int <- base::seq.int
[08:27:25.592]             signalCondition <- base::signalCondition
[08:27:25.592]             sys.calls <- base::sys.calls
[08:27:25.592]             `[[` <- base::`[[`
[08:27:25.592]             `+` <- base::`+`
[08:27:25.592]             `<<-` <- base::`<<-`
[08:27:25.592]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:25.592]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:25.592]                   3L)]
[08:27:25.592]             }
[08:27:25.592]             function(cond) {
[08:27:25.592]                 is_error <- inherits(cond, "error")
[08:27:25.592]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:25.592]                   NULL)
[08:27:25.592]                 if (is_error) {
[08:27:25.592]                   sessionInformation <- function() {
[08:27:25.592]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:25.592]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:25.592]                       search = base::search(), system = base::Sys.info())
[08:27:25.592]                   }
[08:27:25.592]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.592]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:25.592]                     cond$call), session = sessionInformation(), 
[08:27:25.592]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:25.592]                   signalCondition(cond)
[08:27:25.592]                 }
[08:27:25.592]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:25.592]                 "immediateCondition"))) {
[08:27:25.592]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:25.592]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.592]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:25.592]                   if (TRUE && !signal) {
[08:27:25.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.592]                     {
[08:27:25.592]                       inherits <- base::inherits
[08:27:25.592]                       invokeRestart <- base::invokeRestart
[08:27:25.592]                       is.null <- base::is.null
[08:27:25.592]                       muffled <- FALSE
[08:27:25.592]                       if (inherits(cond, "message")) {
[08:27:25.592]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.592]                         if (muffled) 
[08:27:25.592]                           invokeRestart("muffleMessage")
[08:27:25.592]                       }
[08:27:25.592]                       else if (inherits(cond, "warning")) {
[08:27:25.592]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.592]                         if (muffled) 
[08:27:25.592]                           invokeRestart("muffleWarning")
[08:27:25.592]                       }
[08:27:25.592]                       else if (inherits(cond, "condition")) {
[08:27:25.592]                         if (!is.null(pattern)) {
[08:27:25.592]                           computeRestarts <- base::computeRestarts
[08:27:25.592]                           grepl <- base::grepl
[08:27:25.592]                           restarts <- computeRestarts(cond)
[08:27:25.592]                           for (restart in restarts) {
[08:27:25.592]                             name <- restart$name
[08:27:25.592]                             if (is.null(name)) 
[08:27:25.592]                               next
[08:27:25.592]                             if (!grepl(pattern, name)) 
[08:27:25.592]                               next
[08:27:25.592]                             invokeRestart(restart)
[08:27:25.592]                             muffled <- TRUE
[08:27:25.592]                             break
[08:27:25.592]                           }
[08:27:25.592]                         }
[08:27:25.592]                       }
[08:27:25.592]                       invisible(muffled)
[08:27:25.592]                     }
[08:27:25.592]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.592]                   }
[08:27:25.592]                 }
[08:27:25.592]                 else {
[08:27:25.592]                   if (TRUE) {
[08:27:25.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.592]                     {
[08:27:25.592]                       inherits <- base::inherits
[08:27:25.592]                       invokeRestart <- base::invokeRestart
[08:27:25.592]                       is.null <- base::is.null
[08:27:25.592]                       muffled <- FALSE
[08:27:25.592]                       if (inherits(cond, "message")) {
[08:27:25.592]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.592]                         if (muffled) 
[08:27:25.592]                           invokeRestart("muffleMessage")
[08:27:25.592]                       }
[08:27:25.592]                       else if (inherits(cond, "warning")) {
[08:27:25.592]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.592]                         if (muffled) 
[08:27:25.592]                           invokeRestart("muffleWarning")
[08:27:25.592]                       }
[08:27:25.592]                       else if (inherits(cond, "condition")) {
[08:27:25.592]                         if (!is.null(pattern)) {
[08:27:25.592]                           computeRestarts <- base::computeRestarts
[08:27:25.592]                           grepl <- base::grepl
[08:27:25.592]                           restarts <- computeRestarts(cond)
[08:27:25.592]                           for (restart in restarts) {
[08:27:25.592]                             name <- restart$name
[08:27:25.592]                             if (is.null(name)) 
[08:27:25.592]                               next
[08:27:25.592]                             if (!grepl(pattern, name)) 
[08:27:25.592]                               next
[08:27:25.592]                             invokeRestart(restart)
[08:27:25.592]                             muffled <- TRUE
[08:27:25.592]                             break
[08:27:25.592]                           }
[08:27:25.592]                         }
[08:27:25.592]                       }
[08:27:25.592]                       invisible(muffled)
[08:27:25.592]                     }
[08:27:25.592]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.592]                   }
[08:27:25.592]                 }
[08:27:25.592]             }
[08:27:25.592]         }))
[08:27:25.592]     }, error = function(ex) {
[08:27:25.592]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:25.592]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.592]                 ...future.rng), started = ...future.startTime, 
[08:27:25.592]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:25.592]             version = "1.8"), class = "FutureResult")
[08:27:25.592]     }, finally = {
[08:27:25.592]         if (!identical(...future.workdir, getwd())) 
[08:27:25.592]             setwd(...future.workdir)
[08:27:25.592]         {
[08:27:25.592]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:25.592]                 ...future.oldOptions$nwarnings <- NULL
[08:27:25.592]             }
[08:27:25.592]             base::options(...future.oldOptions)
[08:27:25.592]             if (.Platform$OS.type == "windows") {
[08:27:25.592]                 old_names <- names(...future.oldEnvVars)
[08:27:25.592]                 envs <- base::Sys.getenv()
[08:27:25.592]                 names <- names(envs)
[08:27:25.592]                 common <- intersect(names, old_names)
[08:27:25.592]                 added <- setdiff(names, old_names)
[08:27:25.592]                 removed <- setdiff(old_names, names)
[08:27:25.592]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:25.592]                   envs[common]]
[08:27:25.592]                 NAMES <- toupper(changed)
[08:27:25.592]                 args <- list()
[08:27:25.592]                 for (kk in seq_along(NAMES)) {
[08:27:25.592]                   name <- changed[[kk]]
[08:27:25.592]                   NAME <- NAMES[[kk]]
[08:27:25.592]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.592]                     next
[08:27:25.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.592]                 }
[08:27:25.592]                 NAMES <- toupper(added)
[08:27:25.592]                 for (kk in seq_along(NAMES)) {
[08:27:25.592]                   name <- added[[kk]]
[08:27:25.592]                   NAME <- NAMES[[kk]]
[08:27:25.592]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.592]                     next
[08:27:25.592]                   args[[name]] <- ""
[08:27:25.592]                 }
[08:27:25.592]                 NAMES <- toupper(removed)
[08:27:25.592]                 for (kk in seq_along(NAMES)) {
[08:27:25.592]                   name <- removed[[kk]]
[08:27:25.592]                   NAME <- NAMES[[kk]]
[08:27:25.592]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.592]                     next
[08:27:25.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.592]                 }
[08:27:25.592]                 if (length(args) > 0) 
[08:27:25.592]                   base::do.call(base::Sys.setenv, args = args)
[08:27:25.592]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:25.592]             }
[08:27:25.592]             else {
[08:27:25.592]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:25.592]             }
[08:27:25.592]             {
[08:27:25.592]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:25.592]                   0L) {
[08:27:25.592]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:25.592]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:25.592]                   base::options(opts)
[08:27:25.592]                 }
[08:27:25.592]                 {
[08:27:25.592]                   {
[08:27:25.592]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:25.592]                     NULL
[08:27:25.592]                   }
[08:27:25.592]                   options(future.plan = NULL)
[08:27:25.592]                   if (is.na(NA_character_)) 
[08:27:25.592]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.592]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:25.592]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:25.592]                     .init = FALSE)
[08:27:25.592]                 }
[08:27:25.592]             }
[08:27:25.592]         }
[08:27:25.592]     })
[08:27:25.592]     if (TRUE) {
[08:27:25.592]         base::sink(type = "output", split = FALSE)
[08:27:25.592]         if (TRUE) {
[08:27:25.592]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:25.592]         }
[08:27:25.592]         else {
[08:27:25.592]             ...future.result["stdout"] <- base::list(NULL)
[08:27:25.592]         }
[08:27:25.592]         base::close(...future.stdout)
[08:27:25.592]         ...future.stdout <- NULL
[08:27:25.592]     }
[08:27:25.592]     ...future.result$conditions <- ...future.conditions
[08:27:25.592]     ...future.result$finished <- base::Sys.time()
[08:27:25.592]     ...future.result
[08:27:25.592] }
[08:27:25.594] assign_globals() ...
[08:27:25.594] List of 2
[08:27:25.594]  $ x: int [1:2] 1 2
[08:27:25.594]  $ y: num 3
[08:27:25.594]  - attr(*, "where")=List of 2
[08:27:25.594]   ..$ x:<environment: R_EmptyEnv> 
[08:27:25.594]   ..$ y:<environment: R_EmptyEnv> 
[08:27:25.594]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:25.594]  - attr(*, "resolved")= logi FALSE
[08:27:25.594]  - attr(*, "total_size")= num 172
[08:27:25.594]  - attr(*, "already-done")= logi TRUE
[08:27:25.598] - copied ‘x’ to environment
[08:27:25.598] - copied ‘y’ to environment
[08:27:25.598] assign_globals() ... done
[08:27:25.598] requestCore(): workers = 2
[08:27:25.603] MulticoreFuture started
[08:27:25.603] - Launch lazy future ... done
[08:27:25.603] run() for ‘MulticoreFuture’ ... done
[08:27:25.604] plan(): Setting new future strategy stack:
[08:27:25.604] result() for MulticoreFuture ...
[08:27:25.604] List of future strategies:
[08:27:25.604] 1. sequential:
[08:27:25.604]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:25.604]    - tweaked: FALSE
[08:27:25.604]    - call: NULL
[08:27:25.605] plan(): nbrOfWorkers() = 1
[08:27:25.607] plan(): Setting new future strategy stack:
[08:27:25.608] List of future strategies:
[08:27:25.608] 1. multicore:
[08:27:25.608]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:25.608]    - tweaked: FALSE
[08:27:25.608]    - call: plan(strategy, substitute = FALSE)
[08:27:25.611] plan(): nbrOfWorkers() = 2
[08:27:25.617] result() for MulticoreFuture ...
[08:27:25.617] result() for MulticoreFuture ... done
[08:27:25.618] signalConditions() ...
[08:27:25.618]  - include = ‘immediateCondition’
[08:27:25.618]  - exclude = 
[08:27:25.618]  - resignal = FALSE
[08:27:25.618]  - Number of conditions: 1
[08:27:25.618] signalConditions() ... done
[08:27:25.618] result() for MulticoreFuture ... done
[08:27:25.619] result() for MulticoreFuture ...
[08:27:25.619] result() for MulticoreFuture ... done
[08:27:25.619] signalConditions() ...
[08:27:25.619]  - include = ‘immediateCondition’
[08:27:25.619]  - exclude = 
[08:27:25.619]  - resignal = FALSE
[08:27:25.619]  - Number of conditions: 1
[08:27:25.619] signalConditions() ... done
[08:27:25.620] Future state: ‘finished’
[08:27:25.620] result() for MulticoreFuture ...
[08:27:25.620] result() for MulticoreFuture ... done
[08:27:25.620] signalConditions() ...
[08:27:25.620]  - include = ‘condition’
[08:27:25.620]  - exclude = ‘immediateCondition’
[08:27:25.620]  - resignal = TRUE
[08:27:25.620]  - Number of conditions: 1
[08:27:25.620]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:27:25.621] signalConditions() ... done
Error in withCallingHandlers({ : '...' used in an incorrect context
[1] "Error in withCallingHandlers({ : '...' used in an incorrect context\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        sum(x, y, ...)    }}, immediateCondition = function(cond) {    save_rds <- function (object, pathname, ...)     {        pathname_tmp <- sprintf("%s.tmp", pathname)        if (file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]])        }        tryCatch({            saveRDS(object, file = pathname_tmp, ...)        }, error = function(ex) {            msg <- conditionMessage(ex)            fi_tmp <- file.info(pathname_tmp)            msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 msg)            ex$message <- msg            stop(ex)        })        stopifnot(file_test("-f", pathname_tmp))        res <- file.rename(from = pathname_tmp, to = pathname)        if (!res || file_test("-f", pathname_tmp)) {            fi_tmp <- file.info(pathname_tmp)            fi <- file.info(pathname)            msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)",                 sQuote(pathname_tmp), fi_tmp[["size"]], fi_tmp[["mtime"]],                 sQuote(pathname), fi[["size"]], fi[["mtime"]])            stop(msg)        }        invisible(pathname)    }    saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath),         rootPath = tempdir())     {        obj <- list(time = Sys.time(), condition = cond)        file <- tempfile(pattern = class(cond)[1], tmpdir = path,             fileext = ".rds")        save_rds(obj, file)    }    saveImmediateCondition(cond, path = "/tmp/RtmpdixJ0p/.future/immediateConditions")    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): '...' used in an incorrect context>
** Sum function 'E' with plan('multicore') ...
function (...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    globals <- globals::globalsByName("...", envir = environment())
    f <- future({
        fcn <- function() sum(...)
        fcn()
    }, envir = parent.frame(), globals = globals)
    y <- value(f)
    y
}
<bytecode: 0x5593ffd5df30>
Arguments '...' exists: TRUE
[08:27:25.622] getGlobalsAndPackages() ...
[08:27:25.622] - globals passed as-is: [1] ‘...’
[08:27:25.622] Resolving globals: FALSE
[08:27:25.622] Tweak future expression to call with '...' arguments ...
[08:27:25.623] {
[08:27:25.623]     do.call(function(...) {
[08:27:25.623]         fcn <- function() sum(...)
[08:27:25.623]         fcn()
[08:27:25.623]     }, args = future.call.arguments)
[08:27:25.623] }
[08:27:25.623] Tweak future expression to call with '...' arguments ... DONE
[08:27:25.623] The total size of the 1 globals is 223 bytes (223 bytes)
[08:27:25.624] The total size of the 1 globals exported for future expression (‘{; fcn <- function() sum(...); fcn(); }’) is 223 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘future.call.arguments’ (223 bytes of class ‘list’)
[08:27:25.624] - globals: [1] ‘future.call.arguments’
[08:27:25.624] 
[08:27:25.624] getGlobalsAndPackages() ... DONE
[08:27:25.624] run() for ‘Future’ ...
[08:27:25.624] - state: ‘created’
[08:27:25.625] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:25.627] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:25.627] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:25.627]   - Field: ‘label’
[08:27:25.627]   - Field: ‘local’
[08:27:25.627]   - Field: ‘owner’
[08:27:25.627]   - Field: ‘envir’
[08:27:25.628]   - Field: ‘workers’
[08:27:25.628]   - Field: ‘packages’
[08:27:25.628]   - Field: ‘gc’
[08:27:25.628]   - Field: ‘job’
[08:27:25.628]   - Field: ‘conditions’
[08:27:25.628]   - Field: ‘expr’
[08:27:25.628]   - Field: ‘uuid’
[08:27:25.628]   - Field: ‘seed’
[08:27:25.628]   - Field: ‘version’
[08:27:25.629]   - Field: ‘result’
[08:27:25.629]   - Field: ‘asynchronous’
[08:27:25.629]   - Field: ‘calls’
[08:27:25.629]   - Field: ‘globals’
[08:27:25.629]   - Field: ‘stdout’
[08:27:25.629]   - Field: ‘earlySignal’
[08:27:25.629]   - Field: ‘lazy’
[08:27:25.629]   - Field: ‘state’
[08:27:25.629] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:25.629] - Launch lazy future ...
[08:27:25.630] Packages needed by the future expression (n = 0): <none>
[08:27:25.630] Packages needed by future strategies (n = 0): <none>
[08:27:25.630] {
[08:27:25.630]     {
[08:27:25.630]         {
[08:27:25.630]             ...future.startTime <- base::Sys.time()
[08:27:25.630]             {
[08:27:25.630]                 {
[08:27:25.630]                   {
[08:27:25.630]                     {
[08:27:25.630]                       base::local({
[08:27:25.630]                         has_future <- base::requireNamespace("future", 
[08:27:25.630]                           quietly = TRUE)
[08:27:25.630]                         if (has_future) {
[08:27:25.630]                           ns <- base::getNamespace("future")
[08:27:25.630]                           version <- ns[[".package"]][["version"]]
[08:27:25.630]                           if (is.null(version)) 
[08:27:25.630]                             version <- utils::packageVersion("future")
[08:27:25.630]                         }
[08:27:25.630]                         else {
[08:27:25.630]                           version <- NULL
[08:27:25.630]                         }
[08:27:25.630]                         if (!has_future || version < "1.8.0") {
[08:27:25.630]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:25.630]                             "", base::R.version$version.string), 
[08:27:25.630]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:25.630]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:25.630]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:25.630]                               "release", "version")], collapse = " "), 
[08:27:25.630]                             hostname = base::Sys.info()[["nodename"]])
[08:27:25.630]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:25.630]                             info)
[08:27:25.630]                           info <- base::paste(info, collapse = "; ")
[08:27:25.630]                           if (!has_future) {
[08:27:25.630]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:25.630]                               info)
[08:27:25.630]                           }
[08:27:25.630]                           else {
[08:27:25.630]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:25.630]                               info, version)
[08:27:25.630]                           }
[08:27:25.630]                           base::stop(msg)
[08:27:25.630]                         }
[08:27:25.630]                       })
[08:27:25.630]                     }
[08:27:25.630]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:25.630]                     base::options(mc.cores = 1L)
[08:27:25.630]                   }
[08:27:25.630]                   ...future.strategy.old <- future::plan("list")
[08:27:25.630]                   options(future.plan = NULL)
[08:27:25.630]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.630]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:25.630]                 }
[08:27:25.630]                 ...future.workdir <- getwd()
[08:27:25.630]             }
[08:27:25.630]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:25.630]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:25.630]         }
[08:27:25.630]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:25.630]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:25.630]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:25.630]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:25.630]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:25.630]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:25.630]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:25.630]             base::names(...future.oldOptions))
[08:27:25.630]     }
[08:27:25.630]     if (FALSE) {
[08:27:25.630]     }
[08:27:25.630]     else {
[08:27:25.630]         if (TRUE) {
[08:27:25.630]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:25.630]                 open = "w")
[08:27:25.630]         }
[08:27:25.630]         else {
[08:27:25.630]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:25.630]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:25.630]         }
[08:27:25.630]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:25.630]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:25.630]             base::sink(type = "output", split = FALSE)
[08:27:25.630]             base::close(...future.stdout)
[08:27:25.630]         }, add = TRUE)
[08:27:25.630]     }
[08:27:25.630]     ...future.frame <- base::sys.nframe()
[08:27:25.630]     ...future.conditions <- base::list()
[08:27:25.630]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:25.630]     if (FALSE) {
[08:27:25.630]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:25.630]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:25.630]     }
[08:27:25.630]     ...future.result <- base::tryCatch({
[08:27:25.630]         base::withCallingHandlers({
[08:27:25.630]             ...future.value <- base::withVisible(base::local({
[08:27:25.630]                 withCallingHandlers({
[08:27:25.630]                   {
[08:27:25.630]                     do.call(function(...) {
[08:27:25.630]                       fcn <- function() sum(...)
[08:27:25.630]                       fcn()
[08:27:25.630]                     }, args = future.call.arguments)
[08:27:25.630]                   }
[08:27:25.630]                 }, immediateCondition = function(cond) {
[08:27:25.630]                   save_rds <- function (object, pathname, ...) 
[08:27:25.630]                   {
[08:27:25.630]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:25.630]                     if (file_test("-f", pathname_tmp)) {
[08:27:25.630]                       fi_tmp <- file.info(pathname_tmp)
[08:27:25.630]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:25.630]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:25.630]                         fi_tmp[["mtime"]])
[08:27:25.630]                     }
[08:27:25.630]                     tryCatch({
[08:27:25.630]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:25.630]                     }, error = function(ex) {
[08:27:25.630]                       msg <- conditionMessage(ex)
[08:27:25.630]                       fi_tmp <- file.info(pathname_tmp)
[08:27:25.630]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:25.630]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:25.630]                         fi_tmp[["mtime"]], msg)
[08:27:25.630]                       ex$message <- msg
[08:27:25.630]                       stop(ex)
[08:27:25.630]                     })
[08:27:25.630]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:25.630]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:25.630]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:25.630]                       fi_tmp <- file.info(pathname_tmp)
[08:27:25.630]                       fi <- file.info(pathname)
[08:27:25.630]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:25.630]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:25.630]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:25.630]                         fi[["size"]], fi[["mtime"]])
[08:27:25.630]                       stop(msg)
[08:27:25.630]                     }
[08:27:25.630]                     invisible(pathname)
[08:27:25.630]                   }
[08:27:25.630]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:25.630]                     rootPath = tempdir()) 
[08:27:25.630]                   {
[08:27:25.630]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:25.630]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:25.630]                       tmpdir = path, fileext = ".rds")
[08:27:25.630]                     save_rds(obj, file)
[08:27:25.630]                   }
[08:27:25.630]                   saveImmediateCondition(cond, path = "/tmp/RtmpdixJ0p/.future/immediateConditions")
[08:27:25.630]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.630]                   {
[08:27:25.630]                     inherits <- base::inherits
[08:27:25.630]                     invokeRestart <- base::invokeRestart
[08:27:25.630]                     is.null <- base::is.null
[08:27:25.630]                     muffled <- FALSE
[08:27:25.630]                     if (inherits(cond, "message")) {
[08:27:25.630]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:25.630]                       if (muffled) 
[08:27:25.630]                         invokeRestart("muffleMessage")
[08:27:25.630]                     }
[08:27:25.630]                     else if (inherits(cond, "warning")) {
[08:27:25.630]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:25.630]                       if (muffled) 
[08:27:25.630]                         invokeRestart("muffleWarning")
[08:27:25.630]                     }
[08:27:25.630]                     else if (inherits(cond, "condition")) {
[08:27:25.630]                       if (!is.null(pattern)) {
[08:27:25.630]                         computeRestarts <- base::computeRestarts
[08:27:25.630]                         grepl <- base::grepl
[08:27:25.630]                         restarts <- computeRestarts(cond)
[08:27:25.630]                         for (restart in restarts) {
[08:27:25.630]                           name <- restart$name
[08:27:25.630]                           if (is.null(name)) 
[08:27:25.630]                             next
[08:27:25.630]                           if (!grepl(pattern, name)) 
[08:27:25.630]                             next
[08:27:25.630]                           invokeRestart(restart)
[08:27:25.630]                           muffled <- TRUE
[08:27:25.630]                           break
[08:27:25.630]                         }
[08:27:25.630]                       }
[08:27:25.630]                     }
[08:27:25.630]                     invisible(muffled)
[08:27:25.630]                   }
[08:27:25.630]                   muffleCondition(cond)
[08:27:25.630]                 })
[08:27:25.630]             }))
[08:27:25.630]             future::FutureResult(value = ...future.value$value, 
[08:27:25.630]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.630]                   ...future.rng), globalenv = if (FALSE) 
[08:27:25.630]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:25.630]                     ...future.globalenv.names))
[08:27:25.630]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:25.630]         }, condition = base::local({
[08:27:25.630]             c <- base::c
[08:27:25.630]             inherits <- base::inherits
[08:27:25.630]             invokeRestart <- base::invokeRestart
[08:27:25.630]             length <- base::length
[08:27:25.630]             list <- base::list
[08:27:25.630]             seq.int <- base::seq.int
[08:27:25.630]             signalCondition <- base::signalCondition
[08:27:25.630]             sys.calls <- base::sys.calls
[08:27:25.630]             `[[` <- base::`[[`
[08:27:25.630]             `+` <- base::`+`
[08:27:25.630]             `<<-` <- base::`<<-`
[08:27:25.630]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:25.630]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:25.630]                   3L)]
[08:27:25.630]             }
[08:27:25.630]             function(cond) {
[08:27:25.630]                 is_error <- inherits(cond, "error")
[08:27:25.630]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:25.630]                   NULL)
[08:27:25.630]                 if (is_error) {
[08:27:25.630]                   sessionInformation <- function() {
[08:27:25.630]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:25.630]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:25.630]                       search = base::search(), system = base::Sys.info())
[08:27:25.630]                   }
[08:27:25.630]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.630]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:25.630]                     cond$call), session = sessionInformation(), 
[08:27:25.630]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:25.630]                   signalCondition(cond)
[08:27:25.630]                 }
[08:27:25.630]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:25.630]                 "immediateCondition"))) {
[08:27:25.630]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:25.630]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.630]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:25.630]                   if (TRUE && !signal) {
[08:27:25.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.630]                     {
[08:27:25.630]                       inherits <- base::inherits
[08:27:25.630]                       invokeRestart <- base::invokeRestart
[08:27:25.630]                       is.null <- base::is.null
[08:27:25.630]                       muffled <- FALSE
[08:27:25.630]                       if (inherits(cond, "message")) {
[08:27:25.630]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.630]                         if (muffled) 
[08:27:25.630]                           invokeRestart("muffleMessage")
[08:27:25.630]                       }
[08:27:25.630]                       else if (inherits(cond, "warning")) {
[08:27:25.630]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.630]                         if (muffled) 
[08:27:25.630]                           invokeRestart("muffleWarning")
[08:27:25.630]                       }
[08:27:25.630]                       else if (inherits(cond, "condition")) {
[08:27:25.630]                         if (!is.null(pattern)) {
[08:27:25.630]                           computeRestarts <- base::computeRestarts
[08:27:25.630]                           grepl <- base::grepl
[08:27:25.630]                           restarts <- computeRestarts(cond)
[08:27:25.630]                           for (restart in restarts) {
[08:27:25.630]                             name <- restart$name
[08:27:25.630]                             if (is.null(name)) 
[08:27:25.630]                               next
[08:27:25.630]                             if (!grepl(pattern, name)) 
[08:27:25.630]                               next
[08:27:25.630]                             invokeRestart(restart)
[08:27:25.630]                             muffled <- TRUE
[08:27:25.630]                             break
[08:27:25.630]                           }
[08:27:25.630]                         }
[08:27:25.630]                       }
[08:27:25.630]                       invisible(muffled)
[08:27:25.630]                     }
[08:27:25.630]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.630]                   }
[08:27:25.630]                 }
[08:27:25.630]                 else {
[08:27:25.630]                   if (TRUE) {
[08:27:25.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.630]                     {
[08:27:25.630]                       inherits <- base::inherits
[08:27:25.630]                       invokeRestart <- base::invokeRestart
[08:27:25.630]                       is.null <- base::is.null
[08:27:25.630]                       muffled <- FALSE
[08:27:25.630]                       if (inherits(cond, "message")) {
[08:27:25.630]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.630]                         if (muffled) 
[08:27:25.630]                           invokeRestart("muffleMessage")
[08:27:25.630]                       }
[08:27:25.630]                       else if (inherits(cond, "warning")) {
[08:27:25.630]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.630]                         if (muffled) 
[08:27:25.630]                           invokeRestart("muffleWarning")
[08:27:25.630]                       }
[08:27:25.630]                       else if (inherits(cond, "condition")) {
[08:27:25.630]                         if (!is.null(pattern)) {
[08:27:25.630]                           computeRestarts <- base::computeRestarts
[08:27:25.630]                           grepl <- base::grepl
[08:27:25.630]                           restarts <- computeRestarts(cond)
[08:27:25.630]                           for (restart in restarts) {
[08:27:25.630]                             name <- restart$name
[08:27:25.630]                             if (is.null(name)) 
[08:27:25.630]                               next
[08:27:25.630]                             if (!grepl(pattern, name)) 
[08:27:25.630]                               next
[08:27:25.630]                             invokeRestart(restart)
[08:27:25.630]                             muffled <- TRUE
[08:27:25.630]                             break
[08:27:25.630]                           }
[08:27:25.630]                         }
[08:27:25.630]                       }
[08:27:25.630]                       invisible(muffled)
[08:27:25.630]                     }
[08:27:25.630]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.630]                   }
[08:27:25.630]                 }
[08:27:25.630]             }
[08:27:25.630]         }))
[08:27:25.630]     }, error = function(ex) {
[08:27:25.630]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:25.630]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.630]                 ...future.rng), started = ...future.startTime, 
[08:27:25.630]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:25.630]             version = "1.8"), class = "FutureResult")
[08:27:25.630]     }, finally = {
[08:27:25.630]         if (!identical(...future.workdir, getwd())) 
[08:27:25.630]             setwd(...future.workdir)
[08:27:25.630]         {
[08:27:25.630]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:25.630]                 ...future.oldOptions$nwarnings <- NULL
[08:27:25.630]             }
[08:27:25.630]             base::options(...future.oldOptions)
[08:27:25.630]             if (.Platform$OS.type == "windows") {
[08:27:25.630]                 old_names <- names(...future.oldEnvVars)
[08:27:25.630]                 envs <- base::Sys.getenv()
[08:27:25.630]                 names <- names(envs)
[08:27:25.630]                 common <- intersect(names, old_names)
[08:27:25.630]                 added <- setdiff(names, old_names)
[08:27:25.630]                 removed <- setdiff(old_names, names)
[08:27:25.630]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:25.630]                   envs[common]]
[08:27:25.630]                 NAMES <- toupper(changed)
[08:27:25.630]                 args <- list()
[08:27:25.630]                 for (kk in seq_along(NAMES)) {
[08:27:25.630]                   name <- changed[[kk]]
[08:27:25.630]                   NAME <- NAMES[[kk]]
[08:27:25.630]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.630]                     next
[08:27:25.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.630]                 }
[08:27:25.630]                 NAMES <- toupper(added)
[08:27:25.630]                 for (kk in seq_along(NAMES)) {
[08:27:25.630]                   name <- added[[kk]]
[08:27:25.630]                   NAME <- NAMES[[kk]]
[08:27:25.630]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.630]                     next
[08:27:25.630]                   args[[name]] <- ""
[08:27:25.630]                 }
[08:27:25.630]                 NAMES <- toupper(removed)
[08:27:25.630]                 for (kk in seq_along(NAMES)) {
[08:27:25.630]                   name <- removed[[kk]]
[08:27:25.630]                   NAME <- NAMES[[kk]]
[08:27:25.630]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.630]                     next
[08:27:25.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.630]                 }
[08:27:25.630]                 if (length(args) > 0) 
[08:27:25.630]                   base::do.call(base::Sys.setenv, args = args)
[08:27:25.630]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:25.630]             }
[08:27:25.630]             else {
[08:27:25.630]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:25.630]             }
[08:27:25.630]             {
[08:27:25.630]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:25.630]                   0L) {
[08:27:25.630]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:25.630]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:25.630]                   base::options(opts)
[08:27:25.630]                 }
[08:27:25.630]                 {
[08:27:25.630]                   {
[08:27:25.630]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:25.630]                     NULL
[08:27:25.630]                   }
[08:27:25.630]                   options(future.plan = NULL)
[08:27:25.630]                   if (is.na(NA_character_)) 
[08:27:25.630]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.630]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:25.630]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:25.630]                     .init = FALSE)
[08:27:25.630]                 }
[08:27:25.630]             }
[08:27:25.630]         }
[08:27:25.630]     })
[08:27:25.630]     if (TRUE) {
[08:27:25.630]         base::sink(type = "output", split = FALSE)
[08:27:25.630]         if (TRUE) {
[08:27:25.630]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:25.630]         }
[08:27:25.630]         else {
[08:27:25.630]             ...future.result["stdout"] <- base::list(NULL)
[08:27:25.630]         }
[08:27:25.630]         base::close(...future.stdout)
[08:27:25.630]         ...future.stdout <- NULL
[08:27:25.630]     }
[08:27:25.630]     ...future.result$conditions <- ...future.conditions
[08:27:25.630]     ...future.result$finished <- base::Sys.time()
[08:27:25.630]     ...future.result
[08:27:25.630] }
[08:27:25.633] assign_globals() ...
[08:27:25.633] List of 1
[08:27:25.633]  $ future.call.arguments:List of 2
[08:27:25.633]   ..$ : int [1:2] 1 2
[08:27:25.633]   ..$ : num 3
[08:27:25.633]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:27:25.633]  - attr(*, "where")=List of 1
[08:27:25.633]   ..$ future.call.arguments:<environment: R_EmptyEnv> 
[08:27:25.633]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:25.633]  - attr(*, "resolved")= logi FALSE
[08:27:25.633]  - attr(*, "total_size")= num 223
[08:27:25.633]  - attr(*, "already-done")= logi TRUE
[08:27:25.637] - copied ‘future.call.arguments’ to environment
[08:27:25.638] assign_globals() ... done
[08:27:25.638] requestCore(): workers = 2
[08:27:25.640] MulticoreFuture started
[08:27:25.640] - Launch lazy future ... done
[08:27:25.640] run() for ‘MulticoreFuture’ ... done
[08:27:25.641] result() for MulticoreFuture ...
[08:27:25.641] plan(): Setting new future strategy stack:
[08:27:25.641] List of future strategies:
[08:27:25.641] 1. sequential:
[08:27:25.641]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:25.641]    - tweaked: FALSE
[08:27:25.641]    - call: NULL
[08:27:25.642] plan(): nbrOfWorkers() = 1
[08:27:25.644] plan(): Setting new future strategy stack:
[08:27:25.644] List of future strategies:
[08:27:25.644] 1. multicore:
[08:27:25.644]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:25.644]    - tweaked: FALSE
[08:27:25.644]    - call: plan(strategy, substitute = FALSE)
[08:27:25.647] plan(): nbrOfWorkers() = 2
[08:27:25.648] result() for MulticoreFuture ...
[08:27:25.648] result() for MulticoreFuture ... done
[08:27:25.649] result() for MulticoreFuture ... done
[08:27:25.649] result() for MulticoreFuture ...
[08:27:25.649] result() for MulticoreFuture ... done
[1] 6
** Sum function 'F' with plan('multicore') ...
function (x, y) 
{
    message("Using '...' in a formula")
    fcn <- function(x, y) {
        z = ~list(...)
        sum(x, y)
    }
    f <- future(fcn(x, y))
    y <- value(f)
    y
}
<bytecode: 0x5593ff4673f0>
Using '...' in a formula
[08:27:25.649] getGlobalsAndPackages() ...
[08:27:25.650] Searching for globals...
[08:27:25.653] - globals found: [9] ‘fcn’, ‘x’, ‘y’, ‘{’, ‘=’, ‘~’, ‘list’, ‘...’, ‘sum’
[08:27:25.653] Searching for globals ... DONE
[08:27:25.654] Resolving globals: FALSE
[08:27:25.654] Tweak future expression to call with '...' arguments ...
[08:27:25.654] The total size of the 3 globals is 1.94 KiB (1985 bytes)
[08:27:25.655] The total size of the 3 globals exported for future expression (‘fcn(x, y)’) is 1.94 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘fcn’ (1.77 KiB of class ‘function’), ‘x’ (133 bytes of class ‘numeric’) and ‘y’ (39 bytes of class ‘numeric’)
[08:27:25.655] - globals: [3] ‘fcn’, ‘x’, ‘y’
[08:27:25.655] 
[08:27:25.655] getGlobalsAndPackages() ... DONE
[08:27:25.656] run() for ‘Future’ ...
[08:27:25.656] - state: ‘created’
[08:27:25.656] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:25.658] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:25.661] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:25.662]   - Field: ‘label’
[08:27:25.662]   - Field: ‘local’
[08:27:25.662]   - Field: ‘owner’
[08:27:25.662]   - Field: ‘envir’
[08:27:25.662]   - Field: ‘workers’
[08:27:25.662]   - Field: ‘packages’
[08:27:25.662]   - Field: ‘gc’
[08:27:25.662]   - Field: ‘job’
[08:27:25.663]   - Field: ‘conditions’
[08:27:25.663]   - Field: ‘expr’
[08:27:25.663]   - Field: ‘uuid’
[08:27:25.663]   - Field: ‘seed’
[08:27:25.663]   - Field: ‘version’
[08:27:25.663]   - Field: ‘result’
[08:27:25.663]   - Field: ‘asynchronous’
[08:27:25.663]   - Field: ‘calls’
[08:27:25.663]   - Field: ‘globals’
[08:27:25.664]   - Field: ‘stdout’
[08:27:25.664]   - Field: ‘earlySignal’
[08:27:25.664]   - Field: ‘lazy’
[08:27:25.664]   - Field: ‘state’
[08:27:25.664] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:25.664] - Launch lazy future ...
[08:27:25.664] Packages needed by the future expression (n = 0): <none>
[08:27:25.665] Packages needed by future strategies (n = 0): <none>
[08:27:25.665] {
[08:27:25.665]     {
[08:27:25.665]         {
[08:27:25.665]             ...future.startTime <- base::Sys.time()
[08:27:25.665]             {
[08:27:25.665]                 {
[08:27:25.665]                   {
[08:27:25.665]                     {
[08:27:25.665]                       base::local({
[08:27:25.665]                         has_future <- base::requireNamespace("future", 
[08:27:25.665]                           quietly = TRUE)
[08:27:25.665]                         if (has_future) {
[08:27:25.665]                           ns <- base::getNamespace("future")
[08:27:25.665]                           version <- ns[[".package"]][["version"]]
[08:27:25.665]                           if (is.null(version)) 
[08:27:25.665]                             version <- utils::packageVersion("future")
[08:27:25.665]                         }
[08:27:25.665]                         else {
[08:27:25.665]                           version <- NULL
[08:27:25.665]                         }
[08:27:25.665]                         if (!has_future || version < "1.8.0") {
[08:27:25.665]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:25.665]                             "", base::R.version$version.string), 
[08:27:25.665]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:25.665]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:25.665]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:25.665]                               "release", "version")], collapse = " "), 
[08:27:25.665]                             hostname = base::Sys.info()[["nodename"]])
[08:27:25.665]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:25.665]                             info)
[08:27:25.665]                           info <- base::paste(info, collapse = "; ")
[08:27:25.665]                           if (!has_future) {
[08:27:25.665]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:25.665]                               info)
[08:27:25.665]                           }
[08:27:25.665]                           else {
[08:27:25.665]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:25.665]                               info, version)
[08:27:25.665]                           }
[08:27:25.665]                           base::stop(msg)
[08:27:25.665]                         }
[08:27:25.665]                       })
[08:27:25.665]                     }
[08:27:25.665]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:25.665]                     base::options(mc.cores = 1L)
[08:27:25.665]                   }
[08:27:25.665]                   ...future.strategy.old <- future::plan("list")
[08:27:25.665]                   options(future.plan = NULL)
[08:27:25.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:25.665]                 }
[08:27:25.665]                 ...future.workdir <- getwd()
[08:27:25.665]             }
[08:27:25.665]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:25.665]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:25.665]         }
[08:27:25.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:25.665]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:25.665]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:25.665]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:25.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:25.665]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:25.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:25.665]             base::names(...future.oldOptions))
[08:27:25.665]     }
[08:27:25.665]     if (FALSE) {
[08:27:25.665]     }
[08:27:25.665]     else {
[08:27:25.665]         if (TRUE) {
[08:27:25.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:25.665]                 open = "w")
[08:27:25.665]         }
[08:27:25.665]         else {
[08:27:25.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:25.665]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:25.665]         }
[08:27:25.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:25.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:25.665]             base::sink(type = "output", split = FALSE)
[08:27:25.665]             base::close(...future.stdout)
[08:27:25.665]         }, add = TRUE)
[08:27:25.665]     }
[08:27:25.665]     ...future.frame <- base::sys.nframe()
[08:27:25.665]     ...future.conditions <- base::list()
[08:27:25.665]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:25.665]     if (FALSE) {
[08:27:25.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:25.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:25.665]     }
[08:27:25.665]     ...future.result <- base::tryCatch({
[08:27:25.665]         base::withCallingHandlers({
[08:27:25.665]             ...future.value <- base::withVisible(base::local({
[08:27:25.665]                 withCallingHandlers({
[08:27:25.665]                   fcn(x, y)
[08:27:25.665]                 }, immediateCondition = function(cond) {
[08:27:25.665]                   save_rds <- function (object, pathname, ...) 
[08:27:25.665]                   {
[08:27:25.665]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:25.665]                     if (file_test("-f", pathname_tmp)) {
[08:27:25.665]                       fi_tmp <- file.info(pathname_tmp)
[08:27:25.665]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:25.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:25.665]                         fi_tmp[["mtime"]])
[08:27:25.665]                     }
[08:27:25.665]                     tryCatch({
[08:27:25.665]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:25.665]                     }, error = function(ex) {
[08:27:25.665]                       msg <- conditionMessage(ex)
[08:27:25.665]                       fi_tmp <- file.info(pathname_tmp)
[08:27:25.665]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:25.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:25.665]                         fi_tmp[["mtime"]], msg)
[08:27:25.665]                       ex$message <- msg
[08:27:25.665]                       stop(ex)
[08:27:25.665]                     })
[08:27:25.665]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:25.665]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:25.665]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:25.665]                       fi_tmp <- file.info(pathname_tmp)
[08:27:25.665]                       fi <- file.info(pathname)
[08:27:25.665]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:25.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:25.665]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:25.665]                         fi[["size"]], fi[["mtime"]])
[08:27:25.665]                       stop(msg)
[08:27:25.665]                     }
[08:27:25.665]                     invisible(pathname)
[08:27:25.665]                   }
[08:27:25.665]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:25.665]                     rootPath = tempdir()) 
[08:27:25.665]                   {
[08:27:25.665]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:25.665]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:25.665]                       tmpdir = path, fileext = ".rds")
[08:27:25.665]                     save_rds(obj, file)
[08:27:25.665]                   }
[08:27:25.665]                   saveImmediateCondition(cond, path = "/tmp/RtmpdixJ0p/.future/immediateConditions")
[08:27:25.665]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.665]                   {
[08:27:25.665]                     inherits <- base::inherits
[08:27:25.665]                     invokeRestart <- base::invokeRestart
[08:27:25.665]                     is.null <- base::is.null
[08:27:25.665]                     muffled <- FALSE
[08:27:25.665]                     if (inherits(cond, "message")) {
[08:27:25.665]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:25.665]                       if (muffled) 
[08:27:25.665]                         invokeRestart("muffleMessage")
[08:27:25.665]                     }
[08:27:25.665]                     else if (inherits(cond, "warning")) {
[08:27:25.665]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:25.665]                       if (muffled) 
[08:27:25.665]                         invokeRestart("muffleWarning")
[08:27:25.665]                     }
[08:27:25.665]                     else if (inherits(cond, "condition")) {
[08:27:25.665]                       if (!is.null(pattern)) {
[08:27:25.665]                         computeRestarts <- base::computeRestarts
[08:27:25.665]                         grepl <- base::grepl
[08:27:25.665]                         restarts <- computeRestarts(cond)
[08:27:25.665]                         for (restart in restarts) {
[08:27:25.665]                           name <- restart$name
[08:27:25.665]                           if (is.null(name)) 
[08:27:25.665]                             next
[08:27:25.665]                           if (!grepl(pattern, name)) 
[08:27:25.665]                             next
[08:27:25.665]                           invokeRestart(restart)
[08:27:25.665]                           muffled <- TRUE
[08:27:25.665]                           break
[08:27:25.665]                         }
[08:27:25.665]                       }
[08:27:25.665]                     }
[08:27:25.665]                     invisible(muffled)
[08:27:25.665]                   }
[08:27:25.665]                   muffleCondition(cond)
[08:27:25.665]                 })
[08:27:25.665]             }))
[08:27:25.665]             future::FutureResult(value = ...future.value$value, 
[08:27:25.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.665]                   ...future.rng), globalenv = if (FALSE) 
[08:27:25.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:25.665]                     ...future.globalenv.names))
[08:27:25.665]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:25.665]         }, condition = base::local({
[08:27:25.665]             c <- base::c
[08:27:25.665]             inherits <- base::inherits
[08:27:25.665]             invokeRestart <- base::invokeRestart
[08:27:25.665]             length <- base::length
[08:27:25.665]             list <- base::list
[08:27:25.665]             seq.int <- base::seq.int
[08:27:25.665]             signalCondition <- base::signalCondition
[08:27:25.665]             sys.calls <- base::sys.calls
[08:27:25.665]             `[[` <- base::`[[`
[08:27:25.665]             `+` <- base::`+`
[08:27:25.665]             `<<-` <- base::`<<-`
[08:27:25.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:25.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:25.665]                   3L)]
[08:27:25.665]             }
[08:27:25.665]             function(cond) {
[08:27:25.665]                 is_error <- inherits(cond, "error")
[08:27:25.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:25.665]                   NULL)
[08:27:25.665]                 if (is_error) {
[08:27:25.665]                   sessionInformation <- function() {
[08:27:25.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:25.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:25.665]                       search = base::search(), system = base::Sys.info())
[08:27:25.665]                   }
[08:27:25.665]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:25.665]                     cond$call), session = sessionInformation(), 
[08:27:25.665]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:25.665]                   signalCondition(cond)
[08:27:25.665]                 }
[08:27:25.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:25.665]                 "immediateCondition"))) {
[08:27:25.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:25.665]                   ...future.conditions[[length(...future.conditions) + 
[08:27:25.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:25.665]                   if (TRUE && !signal) {
[08:27:25.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.665]                     {
[08:27:25.665]                       inherits <- base::inherits
[08:27:25.665]                       invokeRestart <- base::invokeRestart
[08:27:25.665]                       is.null <- base::is.null
[08:27:25.665]                       muffled <- FALSE
[08:27:25.665]                       if (inherits(cond, "message")) {
[08:27:25.665]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.665]                         if (muffled) 
[08:27:25.665]                           invokeRestart("muffleMessage")
[08:27:25.665]                       }
[08:27:25.665]                       else if (inherits(cond, "warning")) {
[08:27:25.665]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.665]                         if (muffled) 
[08:27:25.665]                           invokeRestart("muffleWarning")
[08:27:25.665]                       }
[08:27:25.665]                       else if (inherits(cond, "condition")) {
[08:27:25.665]                         if (!is.null(pattern)) {
[08:27:25.665]                           computeRestarts <- base::computeRestarts
[08:27:25.665]                           grepl <- base::grepl
[08:27:25.665]                           restarts <- computeRestarts(cond)
[08:27:25.665]                           for (restart in restarts) {
[08:27:25.665]                             name <- restart$name
[08:27:25.665]                             if (is.null(name)) 
[08:27:25.665]                               next
[08:27:25.665]                             if (!grepl(pattern, name)) 
[08:27:25.665]                               next
[08:27:25.665]                             invokeRestart(restart)
[08:27:25.665]                             muffled <- TRUE
[08:27:25.665]                             break
[08:27:25.665]                           }
[08:27:25.665]                         }
[08:27:25.665]                       }
[08:27:25.665]                       invisible(muffled)
[08:27:25.665]                     }
[08:27:25.665]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.665]                   }
[08:27:25.665]                 }
[08:27:25.665]                 else {
[08:27:25.665]                   if (TRUE) {
[08:27:25.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:25.665]                     {
[08:27:25.665]                       inherits <- base::inherits
[08:27:25.665]                       invokeRestart <- base::invokeRestart
[08:27:25.665]                       is.null <- base::is.null
[08:27:25.665]                       muffled <- FALSE
[08:27:25.665]                       if (inherits(cond, "message")) {
[08:27:25.665]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:25.665]                         if (muffled) 
[08:27:25.665]                           invokeRestart("muffleMessage")
[08:27:25.665]                       }
[08:27:25.665]                       else if (inherits(cond, "warning")) {
[08:27:25.665]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:25.665]                         if (muffled) 
[08:27:25.665]                           invokeRestart("muffleWarning")
[08:27:25.665]                       }
[08:27:25.665]                       else if (inherits(cond, "condition")) {
[08:27:25.665]                         if (!is.null(pattern)) {
[08:27:25.665]                           computeRestarts <- base::computeRestarts
[08:27:25.665]                           grepl <- base::grepl
[08:27:25.665]                           restarts <- computeRestarts(cond)
[08:27:25.665]                           for (restart in restarts) {
[08:27:25.665]                             name <- restart$name
[08:27:25.665]                             if (is.null(name)) 
[08:27:25.665]                               next
[08:27:25.665]                             if (!grepl(pattern, name)) 
[08:27:25.665]                               next
[08:27:25.665]                             invokeRestart(restart)
[08:27:25.665]                             muffled <- TRUE
[08:27:25.665]                             break
[08:27:25.665]                           }
[08:27:25.665]                         }
[08:27:25.665]                       }
[08:27:25.665]                       invisible(muffled)
[08:27:25.665]                     }
[08:27:25.665]                     muffleCondition(cond, pattern = "^muffle")
[08:27:25.665]                   }
[08:27:25.665]                 }
[08:27:25.665]             }
[08:27:25.665]         }))
[08:27:25.665]     }, error = function(ex) {
[08:27:25.665]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:25.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:25.665]                 ...future.rng), started = ...future.startTime, 
[08:27:25.665]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:25.665]             version = "1.8"), class = "FutureResult")
[08:27:25.665]     }, finally = {
[08:27:25.665]         if (!identical(...future.workdir, getwd())) 
[08:27:25.665]             setwd(...future.workdir)
[08:27:25.665]         {
[08:27:25.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:25.665]                 ...future.oldOptions$nwarnings <- NULL
[08:27:25.665]             }
[08:27:25.665]             base::options(...future.oldOptions)
[08:27:25.665]             if (.Platform$OS.type == "windows") {
[08:27:25.665]                 old_names <- names(...future.oldEnvVars)
[08:27:25.665]                 envs <- base::Sys.getenv()
[08:27:25.665]                 names <- names(envs)
[08:27:25.665]                 common <- intersect(names, old_names)
[08:27:25.665]                 added <- setdiff(names, old_names)
[08:27:25.665]                 removed <- setdiff(old_names, names)
[08:27:25.665]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:25.665]                   envs[common]]
[08:27:25.665]                 NAMES <- toupper(changed)
[08:27:25.665]                 args <- list()
[08:27:25.665]                 for (kk in seq_along(NAMES)) {
[08:27:25.665]                   name <- changed[[kk]]
[08:27:25.665]                   NAME <- NAMES[[kk]]
[08:27:25.665]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.665]                     next
[08:27:25.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.665]                 }
[08:27:25.665]                 NAMES <- toupper(added)
[08:27:25.665]                 for (kk in seq_along(NAMES)) {
[08:27:25.665]                   name <- added[[kk]]
[08:27:25.665]                   NAME <- NAMES[[kk]]
[08:27:25.665]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.665]                     next
[08:27:25.665]                   args[[name]] <- ""
[08:27:25.665]                 }
[08:27:25.665]                 NAMES <- toupper(removed)
[08:27:25.665]                 for (kk in seq_along(NAMES)) {
[08:27:25.665]                   name <- removed[[kk]]
[08:27:25.665]                   NAME <- NAMES[[kk]]
[08:27:25.665]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:25.665]                     next
[08:27:25.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:25.665]                 }
[08:27:25.665]                 if (length(args) > 0) 
[08:27:25.665]                   base::do.call(base::Sys.setenv, args = args)
[08:27:25.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:25.665]             }
[08:27:25.665]             else {
[08:27:25.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:25.665]             }
[08:27:25.665]             {
[08:27:25.665]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:25.665]                   0L) {
[08:27:25.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:25.665]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:25.665]                   base::options(opts)
[08:27:25.665]                 }
[08:27:25.665]                 {
[08:27:25.665]                   {
[08:27:25.665]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:25.665]                     NULL
[08:27:25.665]                   }
[08:27:25.665]                   options(future.plan = NULL)
[08:27:25.665]                   if (is.na(NA_character_)) 
[08:27:25.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:25.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:25.665]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:25.665]                     .init = FALSE)
[08:27:25.665]                 }
[08:27:25.665]             }
[08:27:25.665]         }
[08:27:25.665]     })
[08:27:25.665]     if (TRUE) {
[08:27:25.665]         base::sink(type = "output", split = FALSE)
[08:27:25.665]         if (TRUE) {
[08:27:25.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:25.665]         }
[08:27:25.665]         else {
[08:27:25.665]             ...future.result["stdout"] <- base::list(NULL)
[08:27:25.665]         }
[08:27:25.665]         base::close(...future.stdout)
[08:27:25.665]         ...future.stdout <- NULL
[08:27:25.665]     }
[08:27:25.665]     ...future.result$conditions <- ...future.conditions
[08:27:25.665]     ...future.result$finished <- base::Sys.time()
[08:27:25.665]     ...future.result
[08:27:25.665] }
[08:27:25.668] assign_globals() ...
[08:27:25.668] List of 3
[08:27:25.668]  $ fcn:function (x, y)  
[08:27:25.668]  $ x  : int [1:2] 1 2
[08:27:25.668]  $ y  : num 3
[08:27:25.668]  - attr(*, "where")=List of 3
[08:27:25.668]   ..$ fcn:<environment: R_EmptyEnv> 
[08:27:25.668]   ..$ x  :<environment: R_EmptyEnv> 
[08:27:25.668]   ..$ y  :<environment: R_EmptyEnv> 
[08:27:25.668]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:25.668]  - attr(*, "resolved")= logi FALSE
[08:27:25.668]  - attr(*, "total_size")= num 1985
[08:27:25.668]  - attr(*, "already-done")= logi TRUE
[08:27:25.672] - reassign environment for ‘fcn’
[08:27:25.672] - copied ‘fcn’ to environment
[08:27:25.672] - copied ‘x’ to environment
[08:27:25.672] - copied ‘y’ to environment
[08:27:25.672] assign_globals() ... done
[08:27:25.672] requestCore(): workers = 2
[08:27:25.675] MulticoreFuture started
[08:27:25.675] - Launch lazy future ... done
[08:27:25.675] run() for ‘MulticoreFuture’ ... done
[08:27:25.676] result() for MulticoreFuture ...
[08:27:25.676] plan(): Setting new future strategy stack:
[08:27:25.676] List of future strategies:
[08:27:25.676] 1. sequential:
[08:27:25.676]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:25.676]    - tweaked: FALSE
[08:27:25.676]    - call: NULL
[08:27:25.677] plan(): nbrOfWorkers() = 1
[08:27:25.679] plan(): Setting new future strategy stack:
[08:27:25.679] List of future strategies:
[08:27:25.679] 1. multicore:
[08:27:25.679]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:25.679]    - tweaked: FALSE
[08:27:25.679]    - call: plan(strategy, substitute = FALSE)
[08:27:25.682] plan(): nbrOfWorkers() = 2
[08:27:25.683] result() for MulticoreFuture ...
[08:27:25.683] result() for MulticoreFuture ... done
[08:27:25.684] result() for MulticoreFuture ... done
[08:27:25.684] result() for MulticoreFuture ...
[08:27:25.684] result() for MulticoreFuture ... done
[1] 6
- plan('multisession') ...
[08:27:25.684] plan(): Setting new future strategy stack:
[08:27:25.685] List of future strategies:
[08:27:25.685] 1. multisession:
[08:27:25.685]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:27:25.685]    - tweaked: FALSE
[08:27:25.685]    - call: plan(strategy, substitute = FALSE)
[08:27:25.685] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:27:25.685] multisession:
[08:27:25.685] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:27:25.685] - tweaked: FALSE
[08:27:25.685] - call: plan(strategy, substitute = FALSE)
[08:27:25.690] getGlobalsAndPackages() ...
[08:27:25.690] Not searching for globals
[08:27:25.690] - globals: [0] <none>
[08:27:25.691] getGlobalsAndPackages() ... DONE
[08:27:26.186] Packages needed by the future expression (n = 0): <none>
[08:27:26.186] Packages needed by future strategies (n = 0): <none>
[08:27:26.187] {
[08:27:26.187]     {
[08:27:26.187]         {
[08:27:26.187]             ...future.startTime <- base::Sys.time()
[08:27:26.187]             {
[08:27:26.187]                 {
[08:27:26.187]                   {
[08:27:26.187]                     {
[08:27:26.187]                       base::local({
[08:27:26.187]                         has_future <- base::requireNamespace("future", 
[08:27:26.187]                           quietly = TRUE)
[08:27:26.187]                         if (has_future) {
[08:27:26.187]                           ns <- base::getNamespace("future")
[08:27:26.187]                           version <- ns[[".package"]][["version"]]
[08:27:26.187]                           if (is.null(version)) 
[08:27:26.187]                             version <- utils::packageVersion("future")
[08:27:26.187]                         }
[08:27:26.187]                         else {
[08:27:26.187]                           version <- NULL
[08:27:26.187]                         }
[08:27:26.187]                         if (!has_future || version < "1.8.0") {
[08:27:26.187]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:26.187]                             "", base::R.version$version.string), 
[08:27:26.187]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:26.187]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:26.187]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:26.187]                               "release", "version")], collapse = " "), 
[08:27:26.187]                             hostname = base::Sys.info()[["nodename"]])
[08:27:26.187]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:26.187]                             info)
[08:27:26.187]                           info <- base::paste(info, collapse = "; ")
[08:27:26.187]                           if (!has_future) {
[08:27:26.187]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:26.187]                               info)
[08:27:26.187]                           }
[08:27:26.187]                           else {
[08:27:26.187]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:26.187]                               info, version)
[08:27:26.187]                           }
[08:27:26.187]                           base::stop(msg)
[08:27:26.187]                         }
[08:27:26.187]                       })
[08:27:26.187]                     }
[08:27:26.187]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:26.187]                     base::options(mc.cores = 1L)
[08:27:26.187]                   }
[08:27:26.187]                   ...future.strategy.old <- future::plan("list")
[08:27:26.187]                   options(future.plan = NULL)
[08:27:26.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:26.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:26.187]                 }
[08:27:26.187]                 ...future.workdir <- getwd()
[08:27:26.187]             }
[08:27:26.187]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:26.187]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:26.187]         }
[08:27:26.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:26.187]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:26.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:26.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:26.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:26.187]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:26.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:26.187]             base::names(...future.oldOptions))
[08:27:26.187]     }
[08:27:26.187]     if (FALSE) {
[08:27:26.187]     }
[08:27:26.187]     else {
[08:27:26.187]         if (TRUE) {
[08:27:26.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:26.187]                 open = "w")
[08:27:26.187]         }
[08:27:26.187]         else {
[08:27:26.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:26.187]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:26.187]         }
[08:27:26.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:26.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:26.187]             base::sink(type = "output", split = FALSE)
[08:27:26.187]             base::close(...future.stdout)
[08:27:26.187]         }, add = TRUE)
[08:27:26.187]     }
[08:27:26.187]     ...future.frame <- base::sys.nframe()
[08:27:26.187]     ...future.conditions <- base::list()
[08:27:26.187]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:26.187]     if (FALSE) {
[08:27:26.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:26.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:26.187]     }
[08:27:26.187]     ...future.result <- base::tryCatch({
[08:27:26.187]         base::withCallingHandlers({
[08:27:26.187]             ...future.value <- base::withVisible(base::local({
[08:27:26.187]                 ...future.makeSendCondition <- base::local({
[08:27:26.187]                   sendCondition <- NULL
[08:27:26.187]                   function(frame = 1L) {
[08:27:26.187]                     if (is.function(sendCondition)) 
[08:27:26.187]                       return(sendCondition)
[08:27:26.187]                     ns <- getNamespace("parallel")
[08:27:26.187]                     if (exists("sendData", mode = "function", 
[08:27:26.187]                       envir = ns)) {
[08:27:26.187]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:26.187]                         envir = ns)
[08:27:26.187]                       envir <- sys.frame(frame)
[08:27:26.187]                       master <- NULL
[08:27:26.187]                       while (!identical(envir, .GlobalEnv) && 
[08:27:26.187]                         !identical(envir, emptyenv())) {
[08:27:26.187]                         if (exists("master", mode = "list", envir = envir, 
[08:27:26.187]                           inherits = FALSE)) {
[08:27:26.187]                           master <- get("master", mode = "list", 
[08:27:26.187]                             envir = envir, inherits = FALSE)
[08:27:26.187]                           if (inherits(master, c("SOCKnode", 
[08:27:26.187]                             "SOCK0node"))) {
[08:27:26.187]                             sendCondition <<- function(cond) {
[08:27:26.187]                               data <- list(type = "VALUE", value = cond, 
[08:27:26.187]                                 success = TRUE)
[08:27:26.187]                               parallel_sendData(master, data)
[08:27:26.187]                             }
[08:27:26.187]                             return(sendCondition)
[08:27:26.187]                           }
[08:27:26.187]                         }
[08:27:26.187]                         frame <- frame + 1L
[08:27:26.187]                         envir <- sys.frame(frame)
[08:27:26.187]                       }
[08:27:26.187]                     }
[08:27:26.187]                     sendCondition <<- function(cond) NULL
[08:27:26.187]                   }
[08:27:26.187]                 })
[08:27:26.187]                 withCallingHandlers({
[08:27:26.187]                   NA
[08:27:26.187]                 }, immediateCondition = function(cond) {
[08:27:26.187]                   sendCondition <- ...future.makeSendCondition()
[08:27:26.187]                   sendCondition(cond)
[08:27:26.187]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:26.187]                   {
[08:27:26.187]                     inherits <- base::inherits
[08:27:26.187]                     invokeRestart <- base::invokeRestart
[08:27:26.187]                     is.null <- base::is.null
[08:27:26.187]                     muffled <- FALSE
[08:27:26.187]                     if (inherits(cond, "message")) {
[08:27:26.187]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:26.187]                       if (muffled) 
[08:27:26.187]                         invokeRestart("muffleMessage")
[08:27:26.187]                     }
[08:27:26.187]                     else if (inherits(cond, "warning")) {
[08:27:26.187]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:26.187]                       if (muffled) 
[08:27:26.187]                         invokeRestart("muffleWarning")
[08:27:26.187]                     }
[08:27:26.187]                     else if (inherits(cond, "condition")) {
[08:27:26.187]                       if (!is.null(pattern)) {
[08:27:26.187]                         computeRestarts <- base::computeRestarts
[08:27:26.187]                         grepl <- base::grepl
[08:27:26.187]                         restarts <- computeRestarts(cond)
[08:27:26.187]                         for (restart in restarts) {
[08:27:26.187]                           name <- restart$name
[08:27:26.187]                           if (is.null(name)) 
[08:27:26.187]                             next
[08:27:26.187]                           if (!grepl(pattern, name)) 
[08:27:26.187]                             next
[08:27:26.187]                           invokeRestart(restart)
[08:27:26.187]                           muffled <- TRUE
[08:27:26.187]                           break
[08:27:26.187]                         }
[08:27:26.187]                       }
[08:27:26.187]                     }
[08:27:26.187]                     invisible(muffled)
[08:27:26.187]                   }
[08:27:26.187]                   muffleCondition(cond)
[08:27:26.187]                 })
[08:27:26.187]             }))
[08:27:26.187]             future::FutureResult(value = ...future.value$value, 
[08:27:26.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:26.187]                   ...future.rng), globalenv = if (FALSE) 
[08:27:26.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:26.187]                     ...future.globalenv.names))
[08:27:26.187]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:26.187]         }, condition = base::local({
[08:27:26.187]             c <- base::c
[08:27:26.187]             inherits <- base::inherits
[08:27:26.187]             invokeRestart <- base::invokeRestart
[08:27:26.187]             length <- base::length
[08:27:26.187]             list <- base::list
[08:27:26.187]             seq.int <- base::seq.int
[08:27:26.187]             signalCondition <- base::signalCondition
[08:27:26.187]             sys.calls <- base::sys.calls
[08:27:26.187]             `[[` <- base::`[[`
[08:27:26.187]             `+` <- base::`+`
[08:27:26.187]             `<<-` <- base::`<<-`
[08:27:26.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:26.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:26.187]                   3L)]
[08:27:26.187]             }
[08:27:26.187]             function(cond) {
[08:27:26.187]                 is_error <- inherits(cond, "error")
[08:27:26.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:26.187]                   NULL)
[08:27:26.187]                 if (is_error) {
[08:27:26.187]                   sessionInformation <- function() {
[08:27:26.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:26.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:26.187]                       search = base::search(), system = base::Sys.info())
[08:27:26.187]                   }
[08:27:26.187]                   ...future.conditions[[length(...future.conditions) + 
[08:27:26.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:26.187]                     cond$call), session = sessionInformation(), 
[08:27:26.187]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:26.187]                   signalCondition(cond)
[08:27:26.187]                 }
[08:27:26.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:26.187]                 "immediateCondition"))) {
[08:27:26.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:26.187]                   ...future.conditions[[length(...future.conditions) + 
[08:27:26.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:26.187]                   if (TRUE && !signal) {
[08:27:26.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:26.187]                     {
[08:27:26.187]                       inherits <- base::inherits
[08:27:26.187]                       invokeRestart <- base::invokeRestart
[08:27:26.187]                       is.null <- base::is.null
[08:27:26.187]                       muffled <- FALSE
[08:27:26.187]                       if (inherits(cond, "message")) {
[08:27:26.187]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:26.187]                         if (muffled) 
[08:27:26.187]                           invokeRestart("muffleMessage")
[08:27:26.187]                       }
[08:27:26.187]                       else if (inherits(cond, "warning")) {
[08:27:26.187]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:26.187]                         if (muffled) 
[08:27:26.187]                           invokeRestart("muffleWarning")
[08:27:26.187]                       }
[08:27:26.187]                       else if (inherits(cond, "condition")) {
[08:27:26.187]                         if (!is.null(pattern)) {
[08:27:26.187]                           computeRestarts <- base::computeRestarts
[08:27:26.187]                           grepl <- base::grepl
[08:27:26.187]                           restarts <- computeRestarts(cond)
[08:27:26.187]                           for (restart in restarts) {
[08:27:26.187]                             name <- restart$name
[08:27:26.187]                             if (is.null(name)) 
[08:27:26.187]                               next
[08:27:26.187]                             if (!grepl(pattern, name)) 
[08:27:26.187]                               next
[08:27:26.187]                             invokeRestart(restart)
[08:27:26.187]                             muffled <- TRUE
[08:27:26.187]                             break
[08:27:26.187]                           }
[08:27:26.187]                         }
[08:27:26.187]                       }
[08:27:26.187]                       invisible(muffled)
[08:27:26.187]                     }
[08:27:26.187]                     muffleCondition(cond, pattern = "^muffle")
[08:27:26.187]                   }
[08:27:26.187]                 }
[08:27:26.187]                 else {
[08:27:26.187]                   if (TRUE) {
[08:27:26.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:26.187]                     {
[08:27:26.187]                       inherits <- base::inherits
[08:27:26.187]                       invokeRestart <- base::invokeRestart
[08:27:26.187]                       is.null <- base::is.null
[08:27:26.187]                       muffled <- FALSE
[08:27:26.187]                       if (inherits(cond, "message")) {
[08:27:26.187]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:26.187]                         if (muffled) 
[08:27:26.187]                           invokeRestart("muffleMessage")
[08:27:26.187]                       }
[08:27:26.187]                       else if (inherits(cond, "warning")) {
[08:27:26.187]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:26.187]                         if (muffled) 
[08:27:26.187]                           invokeRestart("muffleWarning")
[08:27:26.187]                       }
[08:27:26.187]                       else if (inherits(cond, "condition")) {
[08:27:26.187]                         if (!is.null(pattern)) {
[08:27:26.187]                           computeRestarts <- base::computeRestarts
[08:27:26.187]                           grepl <- base::grepl
[08:27:26.187]                           restarts <- computeRestarts(cond)
[08:27:26.187]                           for (restart in restarts) {
[08:27:26.187]                             name <- restart$name
[08:27:26.187]                             if (is.null(name)) 
[08:27:26.187]                               next
[08:27:26.187]                             if (!grepl(pattern, name)) 
[08:27:26.187]                               next
[08:27:26.187]                             invokeRestart(restart)
[08:27:26.187]                             muffled <- TRUE
[08:27:26.187]                             break
[08:27:26.187]                           }
[08:27:26.187]                         }
[08:27:26.187]                       }
[08:27:26.187]                       invisible(muffled)
[08:27:26.187]                     }
[08:27:26.187]                     muffleCondition(cond, pattern = "^muffle")
[08:27:26.187]                   }
[08:27:26.187]                 }
[08:27:26.187]             }
[08:27:26.187]         }))
[08:27:26.187]     }, error = function(ex) {
[08:27:26.187]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:26.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:26.187]                 ...future.rng), started = ...future.startTime, 
[08:27:26.187]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:26.187]             version = "1.8"), class = "FutureResult")
[08:27:26.187]     }, finally = {
[08:27:26.187]         if (!identical(...future.workdir, getwd())) 
[08:27:26.187]             setwd(...future.workdir)
[08:27:26.187]         {
[08:27:26.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:26.187]                 ...future.oldOptions$nwarnings <- NULL
[08:27:26.187]             }
[08:27:26.187]             base::options(...future.oldOptions)
[08:27:26.187]             if (.Platform$OS.type == "windows") {
[08:27:26.187]                 old_names <- names(...future.oldEnvVars)
[08:27:26.187]                 envs <- base::Sys.getenv()
[08:27:26.187]                 names <- names(envs)
[08:27:26.187]                 common <- intersect(names, old_names)
[08:27:26.187]                 added <- setdiff(names, old_names)
[08:27:26.187]                 removed <- setdiff(old_names, names)
[08:27:26.187]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:26.187]                   envs[common]]
[08:27:26.187]                 NAMES <- toupper(changed)
[08:27:26.187]                 args <- list()
[08:27:26.187]                 for (kk in seq_along(NAMES)) {
[08:27:26.187]                   name <- changed[[kk]]
[08:27:26.187]                   NAME <- NAMES[[kk]]
[08:27:26.187]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:26.187]                     next
[08:27:26.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:26.187]                 }
[08:27:26.187]                 NAMES <- toupper(added)
[08:27:26.187]                 for (kk in seq_along(NAMES)) {
[08:27:26.187]                   name <- added[[kk]]
[08:27:26.187]                   NAME <- NAMES[[kk]]
[08:27:26.187]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:26.187]                     next
[08:27:26.187]                   args[[name]] <- ""
[08:27:26.187]                 }
[08:27:26.187]                 NAMES <- toupper(removed)
[08:27:26.187]                 for (kk in seq_along(NAMES)) {
[08:27:26.187]                   name <- removed[[kk]]
[08:27:26.187]                   NAME <- NAMES[[kk]]
[08:27:26.187]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:26.187]                     next
[08:27:26.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:26.187]                 }
[08:27:26.187]                 if (length(args) > 0) 
[08:27:26.187]                   base::do.call(base::Sys.setenv, args = args)
[08:27:26.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:26.187]             }
[08:27:26.187]             else {
[08:27:26.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:26.187]             }
[08:27:26.187]             {
[08:27:26.187]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:26.187]                   0L) {
[08:27:26.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:26.187]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:26.187]                   base::options(opts)
[08:27:26.187]                 }
[08:27:26.187]                 {
[08:27:26.187]                   {
[08:27:26.187]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:26.187]                     NULL
[08:27:26.187]                   }
[08:27:26.187]                   options(future.plan = NULL)
[08:27:26.187]                   if (is.na(NA_character_)) 
[08:27:26.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:26.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:26.187]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:26.187]                     .init = FALSE)
[08:27:26.187]                 }
[08:27:26.187]             }
[08:27:26.187]         }
[08:27:26.187]     })
[08:27:26.187]     if (TRUE) {
[08:27:26.187]         base::sink(type = "output", split = FALSE)
[08:27:26.187]         if (TRUE) {
[08:27:26.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:26.187]         }
[08:27:26.187]         else {
[08:27:26.187]             ...future.result["stdout"] <- base::list(NULL)
[08:27:26.187]         }
[08:27:26.187]         base::close(...future.stdout)
[08:27:26.187]         ...future.stdout <- NULL
[08:27:26.187]     }
[08:27:26.187]     ...future.result$conditions <- ...future.conditions
[08:27:26.187]     ...future.result$finished <- base::Sys.time()
[08:27:26.187]     ...future.result
[08:27:26.187] }
[08:27:26.240] MultisessionFuture started
[08:27:26.241] result() for ClusterFuture ...
[08:27:26.241] receiveMessageFromWorker() for ClusterFuture ...
[08:27:26.241] - Validating connection of MultisessionFuture
[08:27:26.272] - received message: FutureResult
[08:27:26.273] - Received FutureResult
[08:27:26.273] - Erased future from FutureRegistry
[08:27:26.273] result() for ClusterFuture ...
[08:27:26.273] - result already collected: FutureResult
[08:27:26.273] result() for ClusterFuture ... done
[08:27:26.273] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:26.273] result() for ClusterFuture ... done
[08:27:26.273] result() for ClusterFuture ...
[08:27:26.273] - result already collected: FutureResult
[08:27:26.273] result() for ClusterFuture ... done
[08:27:26.273] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:27:26.275] plan(): nbrOfWorkers() = 2
** Sum function 'A' with plan('multisession') ...
function (x, ...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, ...)
    }
    y
}
<bytecode: 0x5594014489c0>
Arguments '...' exists: TRUE
[08:27:26.276] getGlobalsAndPackages() ...
[08:27:26.276] Searching for globals...
[08:27:26.277] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[08:27:26.277] Searching for globals ... DONE
[08:27:26.277] Resolving globals: FALSE
[08:27:26.277] Tweak future expression to call with '...' arguments ...
[08:27:26.277] {
[08:27:26.277]     do.call(function(...) {
[08:27:26.277]         sum(x, ...)
[08:27:26.277]     }, args = future.call.arguments)
[08:27:26.277] }
[08:27:26.278] Tweak future expression to call with '...' arguments ... DONE
[08:27:26.278] The total size of the 2 globals is 246 bytes (246 bytes)
[08:27:26.278] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 246 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (133 bytes of class ‘numeric’) and ‘future.call.arguments’ (113 bytes of class ‘list’)
[08:27:26.279] - globals: [2] ‘x’, ‘future.call.arguments’
[08:27:26.279] 
[08:27:26.279] getGlobalsAndPackages() ... DONE
[08:27:26.279] run() for ‘Future’ ...
[08:27:26.279] - state: ‘created’
[08:27:26.279] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:26.293] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:26.293] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:26.293]   - Field: ‘node’
[08:27:26.293]   - Field: ‘label’
[08:27:26.293]   - Field: ‘local’
[08:27:26.293]   - Field: ‘owner’
[08:27:26.293]   - Field: ‘envir’
[08:27:26.293]   - Field: ‘workers’
[08:27:26.293]   - Field: ‘packages’
[08:27:26.294]   - Field: ‘gc’
[08:27:26.294]   - Field: ‘conditions’
[08:27:26.294]   - Field: ‘persistent’
[08:27:26.294]   - Field: ‘expr’
[08:27:26.294]   - Field: ‘uuid’
[08:27:26.294]   - Field: ‘seed’
[08:27:26.294]   - Field: ‘version’
[08:27:26.294]   - Field: ‘result’
[08:27:26.294]   - Field: ‘asynchronous’
[08:27:26.294]   - Field: ‘calls’
[08:27:26.294]   - Field: ‘globals’
[08:27:26.294]   - Field: ‘stdout’
[08:27:26.295]   - Field: ‘earlySignal’
[08:27:26.295]   - Field: ‘lazy’
[08:27:26.295]   - Field: ‘state’
[08:27:26.295] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:26.295] - Launch lazy future ...
[08:27:26.295] Packages needed by the future expression (n = 0): <none>
[08:27:26.295] Packages needed by future strategies (n = 0): <none>
[08:27:26.296] {
[08:27:26.296]     {
[08:27:26.296]         {
[08:27:26.296]             ...future.startTime <- base::Sys.time()
[08:27:26.296]             {
[08:27:26.296]                 {
[08:27:26.296]                   {
[08:27:26.296]                     {
[08:27:26.296]                       base::local({
[08:27:26.296]                         has_future <- base::requireNamespace("future", 
[08:27:26.296]                           quietly = TRUE)
[08:27:26.296]                         if (has_future) {
[08:27:26.296]                           ns <- base::getNamespace("future")
[08:27:26.296]                           version <- ns[[".package"]][["version"]]
[08:27:26.296]                           if (is.null(version)) 
[08:27:26.296]                             version <- utils::packageVersion("future")
[08:27:26.296]                         }
[08:27:26.296]                         else {
[08:27:26.296]                           version <- NULL
[08:27:26.296]                         }
[08:27:26.296]                         if (!has_future || version < "1.8.0") {
[08:27:26.296]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:26.296]                             "", base::R.version$version.string), 
[08:27:26.296]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:26.296]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:26.296]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:26.296]                               "release", "version")], collapse = " "), 
[08:27:26.296]                             hostname = base::Sys.info()[["nodename"]])
[08:27:26.296]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:26.296]                             info)
[08:27:26.296]                           info <- base::paste(info, collapse = "; ")
[08:27:26.296]                           if (!has_future) {
[08:27:26.296]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:26.296]                               info)
[08:27:26.296]                           }
[08:27:26.296]                           else {
[08:27:26.296]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:26.296]                               info, version)
[08:27:26.296]                           }
[08:27:26.296]                           base::stop(msg)
[08:27:26.296]                         }
[08:27:26.296]                       })
[08:27:26.296]                     }
[08:27:26.296]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:26.296]                     base::options(mc.cores = 1L)
[08:27:26.296]                   }
[08:27:26.296]                   ...future.strategy.old <- future::plan("list")
[08:27:26.296]                   options(future.plan = NULL)
[08:27:26.296]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:26.296]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:26.296]                 }
[08:27:26.296]                 ...future.workdir <- getwd()
[08:27:26.296]             }
[08:27:26.296]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:26.296]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:26.296]         }
[08:27:26.296]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:26.296]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:26.296]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:26.296]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:26.296]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:26.296]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:26.296]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:26.296]             base::names(...future.oldOptions))
[08:27:26.296]     }
[08:27:26.296]     if (FALSE) {
[08:27:26.296]     }
[08:27:26.296]     else {
[08:27:26.296]         if (TRUE) {
[08:27:26.296]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:26.296]                 open = "w")
[08:27:26.296]         }
[08:27:26.296]         else {
[08:27:26.296]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:26.296]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:26.296]         }
[08:27:26.296]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:26.296]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:26.296]             base::sink(type = "output", split = FALSE)
[08:27:26.296]             base::close(...future.stdout)
[08:27:26.296]         }, add = TRUE)
[08:27:26.296]     }
[08:27:26.296]     ...future.frame <- base::sys.nframe()
[08:27:26.296]     ...future.conditions <- base::list()
[08:27:26.296]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:26.296]     if (FALSE) {
[08:27:26.296]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:26.296]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:26.296]     }
[08:27:26.296]     ...future.result <- base::tryCatch({
[08:27:26.296]         base::withCallingHandlers({
[08:27:26.296]             ...future.value <- base::withVisible(base::local({
[08:27:26.296]                 ...future.makeSendCondition <- base::local({
[08:27:26.296]                   sendCondition <- NULL
[08:27:26.296]                   function(frame = 1L) {
[08:27:26.296]                     if (is.function(sendCondition)) 
[08:27:26.296]                       return(sendCondition)
[08:27:26.296]                     ns <- getNamespace("parallel")
[08:27:26.296]                     if (exists("sendData", mode = "function", 
[08:27:26.296]                       envir = ns)) {
[08:27:26.296]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:26.296]                         envir = ns)
[08:27:26.296]                       envir <- sys.frame(frame)
[08:27:26.296]                       master <- NULL
[08:27:26.296]                       while (!identical(envir, .GlobalEnv) && 
[08:27:26.296]                         !identical(envir, emptyenv())) {
[08:27:26.296]                         if (exists("master", mode = "list", envir = envir, 
[08:27:26.296]                           inherits = FALSE)) {
[08:27:26.296]                           master <- get("master", mode = "list", 
[08:27:26.296]                             envir = envir, inherits = FALSE)
[08:27:26.296]                           if (inherits(master, c("SOCKnode", 
[08:27:26.296]                             "SOCK0node"))) {
[08:27:26.296]                             sendCondition <<- function(cond) {
[08:27:26.296]                               data <- list(type = "VALUE", value = cond, 
[08:27:26.296]                                 success = TRUE)
[08:27:26.296]                               parallel_sendData(master, data)
[08:27:26.296]                             }
[08:27:26.296]                             return(sendCondition)
[08:27:26.296]                           }
[08:27:26.296]                         }
[08:27:26.296]                         frame <- frame + 1L
[08:27:26.296]                         envir <- sys.frame(frame)
[08:27:26.296]                       }
[08:27:26.296]                     }
[08:27:26.296]                     sendCondition <<- function(cond) NULL
[08:27:26.296]                   }
[08:27:26.296]                 })
[08:27:26.296]                 withCallingHandlers({
[08:27:26.296]                   {
[08:27:26.296]                     do.call(function(...) {
[08:27:26.296]                       sum(x, ...)
[08:27:26.296]                     }, args = future.call.arguments)
[08:27:26.296]                   }
[08:27:26.296]                 }, immediateCondition = function(cond) {
[08:27:26.296]                   sendCondition <- ...future.makeSendCondition()
[08:27:26.296]                   sendCondition(cond)
[08:27:26.296]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:26.296]                   {
[08:27:26.296]                     inherits <- base::inherits
[08:27:26.296]                     invokeRestart <- base::invokeRestart
[08:27:26.296]                     is.null <- base::is.null
[08:27:26.296]                     muffled <- FALSE
[08:27:26.296]                     if (inherits(cond, "message")) {
[08:27:26.296]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:26.296]                       if (muffled) 
[08:27:26.296]                         invokeRestart("muffleMessage")
[08:27:26.296]                     }
[08:27:26.296]                     else if (inherits(cond, "warning")) {
[08:27:26.296]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:26.296]                       if (muffled) 
[08:27:26.296]                         invokeRestart("muffleWarning")
[08:27:26.296]                     }
[08:27:26.296]                     else if (inherits(cond, "condition")) {
[08:27:26.296]                       if (!is.null(pattern)) {
[08:27:26.296]                         computeRestarts <- base::computeRestarts
[08:27:26.296]                         grepl <- base::grepl
[08:27:26.296]                         restarts <- computeRestarts(cond)
[08:27:26.296]                         for (restart in restarts) {
[08:27:26.296]                           name <- restart$name
[08:27:26.296]                           if (is.null(name)) 
[08:27:26.296]                             next
[08:27:26.296]                           if (!grepl(pattern, name)) 
[08:27:26.296]                             next
[08:27:26.296]                           invokeRestart(restart)
[08:27:26.296]                           muffled <- TRUE
[08:27:26.296]                           break
[08:27:26.296]                         }
[08:27:26.296]                       }
[08:27:26.296]                     }
[08:27:26.296]                     invisible(muffled)
[08:27:26.296]                   }
[08:27:26.296]                   muffleCondition(cond)
[08:27:26.296]                 })
[08:27:26.296]             }))
[08:27:26.296]             future::FutureResult(value = ...future.value$value, 
[08:27:26.296]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:26.296]                   ...future.rng), globalenv = if (FALSE) 
[08:27:26.296]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:26.296]                     ...future.globalenv.names))
[08:27:26.296]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:26.296]         }, condition = base::local({
[08:27:26.296]             c <- base::c
[08:27:26.296]             inherits <- base::inherits
[08:27:26.296]             invokeRestart <- base::invokeRestart
[08:27:26.296]             length <- base::length
[08:27:26.296]             list <- base::list
[08:27:26.296]             seq.int <- base::seq.int
[08:27:26.296]             signalCondition <- base::signalCondition
[08:27:26.296]             sys.calls <- base::sys.calls
[08:27:26.296]             `[[` <- base::`[[`
[08:27:26.296]             `+` <- base::`+`
[08:27:26.296]             `<<-` <- base::`<<-`
[08:27:26.296]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:26.296]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:26.296]                   3L)]
[08:27:26.296]             }
[08:27:26.296]             function(cond) {
[08:27:26.296]                 is_error <- inherits(cond, "error")
[08:27:26.296]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:26.296]                   NULL)
[08:27:26.296]                 if (is_error) {
[08:27:26.296]                   sessionInformation <- function() {
[08:27:26.296]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:26.296]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:26.296]                       search = base::search(), system = base::Sys.info())
[08:27:26.296]                   }
[08:27:26.296]                   ...future.conditions[[length(...future.conditions) + 
[08:27:26.296]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:26.296]                     cond$call), session = sessionInformation(), 
[08:27:26.296]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:26.296]                   signalCondition(cond)
[08:27:26.296]                 }
[08:27:26.296]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:26.296]                 "immediateCondition"))) {
[08:27:26.296]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:26.296]                   ...future.conditions[[length(...future.conditions) + 
[08:27:26.296]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:26.296]                   if (TRUE && !signal) {
[08:27:26.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:26.296]                     {
[08:27:26.296]                       inherits <- base::inherits
[08:27:26.296]                       invokeRestart <- base::invokeRestart
[08:27:26.296]                       is.null <- base::is.null
[08:27:26.296]                       muffled <- FALSE
[08:27:26.296]                       if (inherits(cond, "message")) {
[08:27:26.296]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:26.296]                         if (muffled) 
[08:27:26.296]                           invokeRestart("muffleMessage")
[08:27:26.296]                       }
[08:27:26.296]                       else if (inherits(cond, "warning")) {
[08:27:26.296]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:26.296]                         if (muffled) 
[08:27:26.296]                           invokeRestart("muffleWarning")
[08:27:26.296]                       }
[08:27:26.296]                       else if (inherits(cond, "condition")) {
[08:27:26.296]                         if (!is.null(pattern)) {
[08:27:26.296]                           computeRestarts <- base::computeRestarts
[08:27:26.296]                           grepl <- base::grepl
[08:27:26.296]                           restarts <- computeRestarts(cond)
[08:27:26.296]                           for (restart in restarts) {
[08:27:26.296]                             name <- restart$name
[08:27:26.296]                             if (is.null(name)) 
[08:27:26.296]                               next
[08:27:26.296]                             if (!grepl(pattern, name)) 
[08:27:26.296]                               next
[08:27:26.296]                             invokeRestart(restart)
[08:27:26.296]                             muffled <- TRUE
[08:27:26.296]                             break
[08:27:26.296]                           }
[08:27:26.296]                         }
[08:27:26.296]                       }
[08:27:26.296]                       invisible(muffled)
[08:27:26.296]                     }
[08:27:26.296]                     muffleCondition(cond, pattern = "^muffle")
[08:27:26.296]                   }
[08:27:26.296]                 }
[08:27:26.296]                 else {
[08:27:26.296]                   if (TRUE) {
[08:27:26.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:26.296]                     {
[08:27:26.296]                       inherits <- base::inherits
[08:27:26.296]                       invokeRestart <- base::invokeRestart
[08:27:26.296]                       is.null <- base::is.null
[08:27:26.296]                       muffled <- FALSE
[08:27:26.296]                       if (inherits(cond, "message")) {
[08:27:26.296]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:26.296]                         if (muffled) 
[08:27:26.296]                           invokeRestart("muffleMessage")
[08:27:26.296]                       }
[08:27:26.296]                       else if (inherits(cond, "warning")) {
[08:27:26.296]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:26.296]                         if (muffled) 
[08:27:26.296]                           invokeRestart("muffleWarning")
[08:27:26.296]                       }
[08:27:26.296]                       else if (inherits(cond, "condition")) {
[08:27:26.296]                         if (!is.null(pattern)) {
[08:27:26.296]                           computeRestarts <- base::computeRestarts
[08:27:26.296]                           grepl <- base::grepl
[08:27:26.296]                           restarts <- computeRestarts(cond)
[08:27:26.296]                           for (restart in restarts) {
[08:27:26.296]                             name <- restart$name
[08:27:26.296]                             if (is.null(name)) 
[08:27:26.296]                               next
[08:27:26.296]                             if (!grepl(pattern, name)) 
[08:27:26.296]                               next
[08:27:26.296]                             invokeRestart(restart)
[08:27:26.296]                             muffled <- TRUE
[08:27:26.296]                             break
[08:27:26.296]                           }
[08:27:26.296]                         }
[08:27:26.296]                       }
[08:27:26.296]                       invisible(muffled)
[08:27:26.296]                     }
[08:27:26.296]                     muffleCondition(cond, pattern = "^muffle")
[08:27:26.296]                   }
[08:27:26.296]                 }
[08:27:26.296]             }
[08:27:26.296]         }))
[08:27:26.296]     }, error = function(ex) {
[08:27:26.296]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:26.296]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:26.296]                 ...future.rng), started = ...future.startTime, 
[08:27:26.296]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:26.296]             version = "1.8"), class = "FutureResult")
[08:27:26.296]     }, finally = {
[08:27:26.296]         if (!identical(...future.workdir, getwd())) 
[08:27:26.296]             setwd(...future.workdir)
[08:27:26.296]         {
[08:27:26.296]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:26.296]                 ...future.oldOptions$nwarnings <- NULL
[08:27:26.296]             }
[08:27:26.296]             base::options(...future.oldOptions)
[08:27:26.296]             if (.Platform$OS.type == "windows") {
[08:27:26.296]                 old_names <- names(...future.oldEnvVars)
[08:27:26.296]                 envs <- base::Sys.getenv()
[08:27:26.296]                 names <- names(envs)
[08:27:26.296]                 common <- intersect(names, old_names)
[08:27:26.296]                 added <- setdiff(names, old_names)
[08:27:26.296]                 removed <- setdiff(old_names, names)
[08:27:26.296]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:26.296]                   envs[common]]
[08:27:26.296]                 NAMES <- toupper(changed)
[08:27:26.296]                 args <- list()
[08:27:26.296]                 for (kk in seq_along(NAMES)) {
[08:27:26.296]                   name <- changed[[kk]]
[08:27:26.296]                   NAME <- NAMES[[kk]]
[08:27:26.296]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:26.296]                     next
[08:27:26.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:26.296]                 }
[08:27:26.296]                 NAMES <- toupper(added)
[08:27:26.296]                 for (kk in seq_along(NAMES)) {
[08:27:26.296]                   name <- added[[kk]]
[08:27:26.296]                   NAME <- NAMES[[kk]]
[08:27:26.296]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:26.296]                     next
[08:27:26.296]                   args[[name]] <- ""
[08:27:26.296]                 }
[08:27:26.296]                 NAMES <- toupper(removed)
[08:27:26.296]                 for (kk in seq_along(NAMES)) {
[08:27:26.296]                   name <- removed[[kk]]
[08:27:26.296]                   NAME <- NAMES[[kk]]
[08:27:26.296]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:26.296]                     next
[08:27:26.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:26.296]                 }
[08:27:26.296]                 if (length(args) > 0) 
[08:27:26.296]                   base::do.call(base::Sys.setenv, args = args)
[08:27:26.296]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:26.296]             }
[08:27:26.296]             else {
[08:27:26.296]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:26.296]             }
[08:27:26.296]             {
[08:27:26.296]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:26.296]                   0L) {
[08:27:26.296]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:26.296]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:26.296]                   base::options(opts)
[08:27:26.296]                 }
[08:27:26.296]                 {
[08:27:26.296]                   {
[08:27:26.296]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:26.296]                     NULL
[08:27:26.296]                   }
[08:27:26.296]                   options(future.plan = NULL)
[08:27:26.296]                   if (is.na(NA_character_)) 
[08:27:26.296]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:26.296]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:26.296]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:26.296]                     .init = FALSE)
[08:27:26.296]                 }
[08:27:26.296]             }
[08:27:26.296]         }
[08:27:26.296]     })
[08:27:26.296]     if (TRUE) {
[08:27:26.296]         base::sink(type = "output", split = FALSE)
[08:27:26.296]         if (TRUE) {
[08:27:26.296]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:26.296]         }
[08:27:26.296]         else {
[08:27:26.296]             ...future.result["stdout"] <- base::list(NULL)
[08:27:26.296]         }
[08:27:26.296]         base::close(...future.stdout)
[08:27:26.296]         ...future.stdout <- NULL
[08:27:26.296]     }
[08:27:26.296]     ...future.result$conditions <- ...future.conditions
[08:27:26.296]     ...future.result$finished <- base::Sys.time()
[08:27:26.296]     ...future.result
[08:27:26.296] }
[08:27:26.298] Exporting 2 global objects (579 bytes) to cluster node #1 ...
[08:27:26.299] Exporting ‘x’ (133 bytes) to cluster node #1 ...
[08:27:26.299] Exporting ‘x’ (133 bytes) to cluster node #1 ... DONE
[08:27:26.299] Exporting ‘future.call.arguments’ (113 bytes) to cluster node #1 ...
[08:27:26.300] Exporting ‘future.call.arguments’ (113 bytes) to cluster node #1 ... DONE
[08:27:26.300] Exporting 2 global objects (579 bytes) to cluster node #1 ... DONE
[08:27:26.300] MultisessionFuture started
[08:27:26.300] - Launch lazy future ... done
[08:27:26.300] run() for ‘MultisessionFuture’ ... done
[08:27:26.301] result() for ClusterFuture ...
[08:27:26.301] receiveMessageFromWorker() for ClusterFuture ...
[08:27:26.301] - Validating connection of MultisessionFuture
[08:27:26.346] - received message: FutureResult
[08:27:26.346] - Received FutureResult
[08:27:26.346] - Erased future from FutureRegistry
[08:27:26.346] result() for ClusterFuture ...
[08:27:26.346] - result already collected: FutureResult
[08:27:26.347] result() for ClusterFuture ... done
[08:27:26.347] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:26.347] result() for ClusterFuture ... done
[08:27:26.347] result() for ClusterFuture ...
[08:27:26.347] - result already collected: FutureResult
[08:27:26.347] result() for ClusterFuture ... done
[1] 6
** Sum function 'B' with plan('multisession') ...
function (x, ...) 
{
    sumt <- function(x) {
        message("Arguments '...' exists: ", exists("...", inherits = TRUE))
        y %<-% {
            sum(x, ...)
        }
        y
    }
    sumt(x)
}
<bytecode: 0x5594016d6998>
Arguments '...' exists: TRUE
[08:27:26.348] getGlobalsAndPackages() ...
[08:27:26.348] Searching for globals...
[08:27:26.349] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘...’
[08:27:26.349] Searching for globals ... DONE
[08:27:26.349] Resolving globals: FALSE
[08:27:26.350] Tweak future expression to call with '...' arguments ...
[08:27:26.350] {
[08:27:26.350]     do.call(function(...) {
[08:27:26.350]         sum(x, ...)
[08:27:26.350]     }, args = future.call.arguments)
[08:27:26.350] }
[08:27:26.350] Tweak future expression to call with '...' arguments ... DONE
[08:27:26.350] The total size of the 2 globals is 246 bytes (246 bytes)
[08:27:26.351] The total size of the 2 globals exported for future expression (‘{; sum(x, ...); }’) is 246 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (133 bytes of class ‘numeric’) and ‘future.call.arguments’ (113 bytes of class ‘list’)
[08:27:26.351] - globals: [2] ‘x’, ‘future.call.arguments’
[08:27:26.351] 
[08:27:26.351] getGlobalsAndPackages() ... DONE
[08:27:26.351] run() for ‘Future’ ...
[08:27:26.351] - state: ‘created’
[08:27:26.352] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:26.366] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:26.366] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:26.366]   - Field: ‘node’
[08:27:26.366]   - Field: ‘label’
[08:27:26.366]   - Field: ‘local’
[08:27:26.366]   - Field: ‘owner’
[08:27:26.367]   - Field: ‘envir’
[08:27:26.367]   - Field: ‘workers’
[08:27:26.367]   - Field: ‘packages’
[08:27:26.367]   - Field: ‘gc’
[08:27:26.367]   - Field: ‘conditions’
[08:27:26.367]   - Field: ‘persistent’
[08:27:26.367]   - Field: ‘expr’
[08:27:26.367]   - Field: ‘uuid’
[08:27:26.367]   - Field: ‘seed’
[08:27:26.367]   - Field: ‘version’
[08:27:26.368]   - Field: ‘result’
[08:27:26.368]   - Field: ‘asynchronous’
[08:27:26.368]   - Field: ‘calls’
[08:27:26.368]   - Field: ‘globals’
[08:27:26.368]   - Field: ‘stdout’
[08:27:26.368]   - Field: ‘earlySignal’
[08:27:26.368]   - Field: ‘lazy’
[08:27:26.368]   - Field: ‘state’
[08:27:26.368] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:26.369] - Launch lazy future ...
[08:27:26.369] Packages needed by the future expression (n = 0): <none>
[08:27:26.369] Packages needed by future strategies (n = 0): <none>
[08:27:26.369] {
[08:27:26.369]     {
[08:27:26.369]         {
[08:27:26.369]             ...future.startTime <- base::Sys.time()
[08:27:26.369]             {
[08:27:26.369]                 {
[08:27:26.369]                   {
[08:27:26.369]                     {
[08:27:26.369]                       base::local({
[08:27:26.369]                         has_future <- base::requireNamespace("future", 
[08:27:26.369]                           quietly = TRUE)
[08:27:26.369]                         if (has_future) {
[08:27:26.369]                           ns <- base::getNamespace("future")
[08:27:26.369]                           version <- ns[[".package"]][["version"]]
[08:27:26.369]                           if (is.null(version)) 
[08:27:26.369]                             version <- utils::packageVersion("future")
[08:27:26.369]                         }
[08:27:26.369]                         else {
[08:27:26.369]                           version <- NULL
[08:27:26.369]                         }
[08:27:26.369]                         if (!has_future || version < "1.8.0") {
[08:27:26.369]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:26.369]                             "", base::R.version$version.string), 
[08:27:26.369]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:26.369]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:26.369]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:26.369]                               "release", "version")], collapse = " "), 
[08:27:26.369]                             hostname = base::Sys.info()[["nodename"]])
[08:27:26.369]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:26.369]                             info)
[08:27:26.369]                           info <- base::paste(info, collapse = "; ")
[08:27:26.369]                           if (!has_future) {
[08:27:26.369]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:26.369]                               info)
[08:27:26.369]                           }
[08:27:26.369]                           else {
[08:27:26.369]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:26.369]                               info, version)
[08:27:26.369]                           }
[08:27:26.369]                           base::stop(msg)
[08:27:26.369]                         }
[08:27:26.369]                       })
[08:27:26.369]                     }
[08:27:26.369]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:26.369]                     base::options(mc.cores = 1L)
[08:27:26.369]                   }
[08:27:26.369]                   ...future.strategy.old <- future::plan("list")
[08:27:26.369]                   options(future.plan = NULL)
[08:27:26.369]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:26.369]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:26.369]                 }
[08:27:26.369]                 ...future.workdir <- getwd()
[08:27:26.369]             }
[08:27:26.369]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:26.369]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:26.369]         }
[08:27:26.369]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:26.369]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:26.369]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:26.369]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:26.369]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:26.369]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:26.369]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:26.369]             base::names(...future.oldOptions))
[08:27:26.369]     }
[08:27:26.369]     if (FALSE) {
[08:27:26.369]     }
[08:27:26.369]     else {
[08:27:26.369]         if (TRUE) {
[08:27:26.369]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:26.369]                 open = "w")
[08:27:26.369]         }
[08:27:26.369]         else {
[08:27:26.369]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:26.369]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:26.369]         }
[08:27:26.369]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:26.369]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:26.369]             base::sink(type = "output", split = FALSE)
[08:27:26.369]             base::close(...future.stdout)
[08:27:26.369]         }, add = TRUE)
[08:27:26.369]     }
[08:27:26.369]     ...future.frame <- base::sys.nframe()
[08:27:26.369]     ...future.conditions <- base::list()
[08:27:26.369]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:26.369]     if (FALSE) {
[08:27:26.369]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:26.369]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:26.369]     }
[08:27:26.369]     ...future.result <- base::tryCatch({
[08:27:26.369]         base::withCallingHandlers({
[08:27:26.369]             ...future.value <- base::withVisible(base::local({
[08:27:26.369]                 ...future.makeSendCondition <- base::local({
[08:27:26.369]                   sendCondition <- NULL
[08:27:26.369]                   function(frame = 1L) {
[08:27:26.369]                     if (is.function(sendCondition)) 
[08:27:26.369]                       return(sendCondition)
[08:27:26.369]                     ns <- getNamespace("parallel")
[08:27:26.369]                     if (exists("sendData", mode = "function", 
[08:27:26.369]                       envir = ns)) {
[08:27:26.369]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:26.369]                         envir = ns)
[08:27:26.369]                       envir <- sys.frame(frame)
[08:27:26.369]                       master <- NULL
[08:27:26.369]                       while (!identical(envir, .GlobalEnv) && 
[08:27:26.369]                         !identical(envir, emptyenv())) {
[08:27:26.369]                         if (exists("master", mode = "list", envir = envir, 
[08:27:26.369]                           inherits = FALSE)) {
[08:27:26.369]                           master <- get("master", mode = "list", 
[08:27:26.369]                             envir = envir, inherits = FALSE)
[08:27:26.369]                           if (inherits(master, c("SOCKnode", 
[08:27:26.369]                             "SOCK0node"))) {
[08:27:26.369]                             sendCondition <<- function(cond) {
[08:27:26.369]                               data <- list(type = "VALUE", value = cond, 
[08:27:26.369]                                 success = TRUE)
[08:27:26.369]                               parallel_sendData(master, data)
[08:27:26.369]                             }
[08:27:26.369]                             return(sendCondition)
[08:27:26.369]                           }
[08:27:26.369]                         }
[08:27:26.369]                         frame <- frame + 1L
[08:27:26.369]                         envir <- sys.frame(frame)
[08:27:26.369]                       }
[08:27:26.369]                     }
[08:27:26.369]                     sendCondition <<- function(cond) NULL
[08:27:26.369]                   }
[08:27:26.369]                 })
[08:27:26.369]                 withCallingHandlers({
[08:27:26.369]                   {
[08:27:26.369]                     do.call(function(...) {
[08:27:26.369]                       sum(x, ...)
[08:27:26.369]                     }, args = future.call.arguments)
[08:27:26.369]                   }
[08:27:26.369]                 }, immediateCondition = function(cond) {
[08:27:26.369]                   sendCondition <- ...future.makeSendCondition()
[08:27:26.369]                   sendCondition(cond)
[08:27:26.369]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:26.369]                   {
[08:27:26.369]                     inherits <- base::inherits
[08:27:26.369]                     invokeRestart <- base::invokeRestart
[08:27:26.369]                     is.null <- base::is.null
[08:27:26.369]                     muffled <- FALSE
[08:27:26.369]                     if (inherits(cond, "message")) {
[08:27:26.369]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:26.369]                       if (muffled) 
[08:27:26.369]                         invokeRestart("muffleMessage")
[08:27:26.369]                     }
[08:27:26.369]                     else if (inherits(cond, "warning")) {
[08:27:26.369]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:26.369]                       if (muffled) 
[08:27:26.369]                         invokeRestart("muffleWarning")
[08:27:26.369]                     }
[08:27:26.369]                     else if (inherits(cond, "condition")) {
[08:27:26.369]                       if (!is.null(pattern)) {
[08:27:26.369]                         computeRestarts <- base::computeRestarts
[08:27:26.369]                         grepl <- base::grepl
[08:27:26.369]                         restarts <- computeRestarts(cond)
[08:27:26.369]                         for (restart in restarts) {
[08:27:26.369]                           name <- restart$name
[08:27:26.369]                           if (is.null(name)) 
[08:27:26.369]                             next
[08:27:26.369]                           if (!grepl(pattern, name)) 
[08:27:26.369]                             next
[08:27:26.369]                           invokeRestart(restart)
[08:27:26.369]                           muffled <- TRUE
[08:27:26.369]                           break
[08:27:26.369]                         }
[08:27:26.369]                       }
[08:27:26.369]                     }
[08:27:26.369]                     invisible(muffled)
[08:27:26.369]                   }
[08:27:26.369]                   muffleCondition(cond)
[08:27:26.369]                 })
[08:27:26.369]             }))
[08:27:26.369]             future::FutureResult(value = ...future.value$value, 
[08:27:26.369]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:26.369]                   ...future.rng), globalenv = if (FALSE) 
[08:27:26.369]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:26.369]                     ...future.globalenv.names))
[08:27:26.369]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:26.369]         }, condition = base::local({
[08:27:26.369]             c <- base::c
[08:27:26.369]             inherits <- base::inherits
[08:27:26.369]             invokeRestart <- base::invokeRestart
[08:27:26.369]             length <- base::length
[08:27:26.369]             list <- base::list
[08:27:26.369]             seq.int <- base::seq.int
[08:27:26.369]             signalCondition <- base::signalCondition
[08:27:26.369]             sys.calls <- base::sys.calls
[08:27:26.369]             `[[` <- base::`[[`
[08:27:26.369]             `+` <- base::`+`
[08:27:26.369]             `<<-` <- base::`<<-`
[08:27:26.369]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:26.369]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:26.369]                   3L)]
[08:27:26.369]             }
[08:27:26.369]             function(cond) {
[08:27:26.369]                 is_error <- inherits(cond, "error")
[08:27:26.369]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:26.369]                   NULL)
[08:27:26.369]                 if (is_error) {
[08:27:26.369]                   sessionInformation <- function() {
[08:27:26.369]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:26.369]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:26.369]                       search = base::search(), system = base::Sys.info())
[08:27:26.369]                   }
[08:27:26.369]                   ...future.conditions[[length(...future.conditions) + 
[08:27:26.369]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:26.369]                     cond$call), session = sessionInformation(), 
[08:27:26.369]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:26.369]                   signalCondition(cond)
[08:27:26.369]                 }
[08:27:26.369]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:26.369]                 "immediateCondition"))) {
[08:27:26.369]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:26.369]                   ...future.conditions[[length(...future.conditions) + 
[08:27:26.369]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:26.369]                   if (TRUE && !signal) {
[08:27:26.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:26.369]                     {
[08:27:26.369]                       inherits <- base::inherits
[08:27:26.369]                       invokeRestart <- base::invokeRestart
[08:27:26.369]                       is.null <- base::is.null
[08:27:26.369]                       muffled <- FALSE
[08:27:26.369]                       if (inherits(cond, "message")) {
[08:27:26.369]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:26.369]                         if (muffled) 
[08:27:26.369]                           invokeRestart("muffleMessage")
[08:27:26.369]                       }
[08:27:26.369]                       else if (inherits(cond, "warning")) {
[08:27:26.369]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:26.369]                         if (muffled) 
[08:27:26.369]                           invokeRestart("muffleWarning")
[08:27:26.369]                       }
[08:27:26.369]                       else if (inherits(cond, "condition")) {
[08:27:26.369]                         if (!is.null(pattern)) {
[08:27:26.369]                           computeRestarts <- base::computeRestarts
[08:27:26.369]                           grepl <- base::grepl
[08:27:26.369]                           restarts <- computeRestarts(cond)
[08:27:26.369]                           for (restart in restarts) {
[08:27:26.369]                             name <- restart$name
[08:27:26.369]                             if (is.null(name)) 
[08:27:26.369]                               next
[08:27:26.369]                             if (!grepl(pattern, name)) 
[08:27:26.369]                               next
[08:27:26.369]                             invokeRestart(restart)
[08:27:26.369]                             muffled <- TRUE
[08:27:26.369]                             break
[08:27:26.369]                           }
[08:27:26.369]                         }
[08:27:26.369]                       }
[08:27:26.369]                       invisible(muffled)
[08:27:26.369]                     }
[08:27:26.369]                     muffleCondition(cond, pattern = "^muffle")
[08:27:26.369]                   }
[08:27:26.369]                 }
[08:27:26.369]                 else {
[08:27:26.369]                   if (TRUE) {
[08:27:26.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:26.369]                     {
[08:27:26.369]                       inherits <- base::inherits
[08:27:26.369]                       invokeRestart <- base::invokeRestart
[08:27:26.369]                       is.null <- base::is.null
[08:27:26.369]                       muffled <- FALSE
[08:27:26.369]                       if (inherits(cond, "message")) {
[08:27:26.369]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:26.369]                         if (muffled) 
[08:27:26.369]                           invokeRestart("muffleMessage")
[08:27:26.369]                       }
[08:27:26.369]                       else if (inherits(cond, "warning")) {
[08:27:26.369]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:26.369]                         if (muffled) 
[08:27:26.369]                           invokeRestart("muffleWarning")
[08:27:26.369]                       }
[08:27:26.369]                       else if (inherits(cond, "condition")) {
[08:27:26.369]                         if (!is.null(pattern)) {
[08:27:26.369]                           computeRestarts <- base::computeRestarts
[08:27:26.369]                           grepl <- base::grepl
[08:27:26.369]                           restarts <- computeRestarts(cond)
[08:27:26.369]                           for (restart in restarts) {
[08:27:26.369]                             name <- restart$name
[08:27:26.369]                             if (is.null(name)) 
[08:27:26.369]                               next
[08:27:26.369]                             if (!grepl(pattern, name)) 
[08:27:26.369]                               next
[08:27:26.369]                             invokeRestart(restart)
[08:27:26.369]                             muffled <- TRUE
[08:27:26.369]                             break
[08:27:26.369]                           }
[08:27:26.369]                         }
[08:27:26.369]                       }
[08:27:26.369]                       invisible(muffled)
[08:27:26.369]                     }
[08:27:26.369]                     muffleCondition(cond, pattern = "^muffle")
[08:27:26.369]                   }
[08:27:26.369]                 }
[08:27:26.369]             }
[08:27:26.369]         }))
[08:27:26.369]     }, error = function(ex) {
[08:27:26.369]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:26.369]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:26.369]                 ...future.rng), started = ...future.startTime, 
[08:27:26.369]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:26.369]             version = "1.8"), class = "FutureResult")
[08:27:26.369]     }, finally = {
[08:27:26.369]         if (!identical(...future.workdir, getwd())) 
[08:27:26.369]             setwd(...future.workdir)
[08:27:26.369]         {
[08:27:26.369]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:26.369]                 ...future.oldOptions$nwarnings <- NULL
[08:27:26.369]             }
[08:27:26.369]             base::options(...future.oldOptions)
[08:27:26.369]             if (.Platform$OS.type == "windows") {
[08:27:26.369]                 old_names <- names(...future.oldEnvVars)
[08:27:26.369]                 envs <- base::Sys.getenv()
[08:27:26.369]                 names <- names(envs)
[08:27:26.369]                 common <- intersect(names, old_names)
[08:27:26.369]                 added <- setdiff(names, old_names)
[08:27:26.369]                 removed <- setdiff(old_names, names)
[08:27:26.369]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:26.369]                   envs[common]]
[08:27:26.369]                 NAMES <- toupper(changed)
[08:27:26.369]                 args <- list()
[08:27:26.369]                 for (kk in seq_along(NAMES)) {
[08:27:26.369]                   name <- changed[[kk]]
[08:27:26.369]                   NAME <- NAMES[[kk]]
[08:27:26.369]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:26.369]                     next
[08:27:26.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:26.369]                 }
[08:27:26.369]                 NAMES <- toupper(added)
[08:27:26.369]                 for (kk in seq_along(NAMES)) {
[08:27:26.369]                   name <- added[[kk]]
[08:27:26.369]                   NAME <- NAMES[[kk]]
[08:27:26.369]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:26.369]                     next
[08:27:26.369]                   args[[name]] <- ""
[08:27:26.369]                 }
[08:27:26.369]                 NAMES <- toupper(removed)
[08:27:26.369]                 for (kk in seq_along(NAMES)) {
[08:27:26.369]                   name <- removed[[kk]]
[08:27:26.369]                   NAME <- NAMES[[kk]]
[08:27:26.369]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:26.369]                     next
[08:27:26.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:26.369]                 }
[08:27:26.369]                 if (length(args) > 0) 
[08:27:26.369]                   base::do.call(base::Sys.setenv, args = args)
[08:27:26.369]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:26.369]             }
[08:27:26.369]             else {
[08:27:26.369]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:26.369]             }
[08:27:26.369]             {
[08:27:26.369]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:26.369]                   0L) {
[08:27:26.369]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:26.369]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:26.369]                   base::options(opts)
[08:27:26.369]                 }
[08:27:26.369]                 {
[08:27:26.369]                   {
[08:27:26.369]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:26.369]                     NULL
[08:27:26.369]                   }
[08:27:26.369]                   options(future.plan = NULL)
[08:27:26.369]                   if (is.na(NA_character_)) 
[08:27:26.369]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:26.369]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:26.369]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:26.369]                     .init = FALSE)
[08:27:26.369]                 }
[08:27:26.369]             }
[08:27:26.369]         }
[08:27:26.369]     })
[08:27:26.369]     if (TRUE) {
[08:27:26.369]         base::sink(type = "output", split = FALSE)
[08:27:26.369]         if (TRUE) {
[08:27:26.369]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:26.369]         }
[08:27:26.369]         else {
[08:27:26.369]             ...future.result["stdout"] <- base::list(NULL)
[08:27:26.369]         }
[08:27:26.369]         base::close(...future.stdout)
[08:27:26.369]         ...future.stdout <- NULL
[08:27:26.369]     }
[08:27:26.369]     ...future.result$conditions <- ...future.conditions
[08:27:26.369]     ...future.result$finished <- base::Sys.time()
[08:27:26.369]     ...future.result
[08:27:26.369] }
[08:27:26.373] Exporting 2 global objects (579 bytes) to cluster node #1 ...
[08:27:26.373] Exporting ‘x’ (133 bytes) to cluster node #1 ...
[08:27:26.373] Exporting ‘x’ (133 bytes) to cluster node #1 ... DONE
[08:27:26.373] Exporting ‘future.call.arguments’ (113 bytes) to cluster node #1 ...
[08:27:26.374] Exporting ‘future.call.arguments’ (113 bytes) to cluster node #1 ... DONE
[08:27:26.374] Exporting 2 global objects (579 bytes) to cluster node #1 ... DONE
[08:27:26.375] MultisessionFuture started
[08:27:26.375] - Launch lazy future ... done
[08:27:26.375] run() for ‘MultisessionFuture’ ... done
[08:27:26.375] result() for ClusterFuture ...
[08:27:26.375] receiveMessageFromWorker() for ClusterFuture ...
[08:27:26.375] - Validating connection of MultisessionFuture
[08:27:26.417] - received message: FutureResult
[08:27:26.418] - Received FutureResult
[08:27:26.418] - Erased future from FutureRegistry
[08:27:26.418] result() for ClusterFuture ...
[08:27:26.418] - result already collected: FutureResult
[08:27:26.418] result() for ClusterFuture ... done
[08:27:26.418] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:26.418] result() for ClusterFuture ... done
[08:27:26.418] result() for ClusterFuture ...
[08:27:26.419] - result already collected: FutureResult
[08:27:26.419] result() for ClusterFuture ... done
[1] 6
** Sum function 'C' with plan('multisession') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y)
    }
    y
}
<bytecode: 0x55940187c6a8>
Arguments '...' exists: FALSE
[08:27:26.419] getGlobalsAndPackages() ...
[08:27:26.419] Searching for globals...
[08:27:26.421] - globals found: [4] ‘{’, ‘sum’, ‘x’, ‘y’
[08:27:26.421] Searching for globals ... DONE
[08:27:26.421] Resolving globals: FALSE
[08:27:26.422] The total size of the 2 globals is 172 bytes (172 bytes)
[08:27:26.422] The total size of the 2 globals exported for future expression (‘{; sum(x, y); }’) is 172 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (133 bytes of class ‘numeric’) and ‘y’ (39 bytes of class ‘numeric’)
[08:27:26.422] - globals: [2] ‘x’, ‘y’
[08:27:26.422] 
[08:27:26.423] getGlobalsAndPackages() ... DONE
[08:27:26.423] run() for ‘Future’ ...
[08:27:26.423] - state: ‘created’
[08:27:26.423] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:26.438] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:26.438] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:26.438]   - Field: ‘node’
[08:27:26.438]   - Field: ‘label’
[08:27:26.438]   - Field: ‘local’
[08:27:26.438]   - Field: ‘owner’
[08:27:26.438]   - Field: ‘envir’
[08:27:26.439]   - Field: ‘workers’
[08:27:26.439]   - Field: ‘packages’
[08:27:26.439]   - Field: ‘gc’
[08:27:26.439]   - Field: ‘conditions’
[08:27:26.439]   - Field: ‘persistent’
[08:27:26.439]   - Field: ‘expr’
[08:27:26.439]   - Field: ‘uuid’
[08:27:26.439]   - Field: ‘seed’
[08:27:26.439]   - Field: ‘version’
[08:27:26.439]   - Field: ‘result’
[08:27:26.440]   - Field: ‘asynchronous’
[08:27:26.440]   - Field: ‘calls’
[08:27:26.440]   - Field: ‘globals’
[08:27:26.440]   - Field: ‘stdout’
[08:27:26.440]   - Field: ‘earlySignal’
[08:27:26.440]   - Field: ‘lazy’
[08:27:26.440]   - Field: ‘state’
[08:27:26.440] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:26.440] - Launch lazy future ...
[08:27:26.441] Packages needed by the future expression (n = 0): <none>
[08:27:26.441] Packages needed by future strategies (n = 0): <none>
[08:27:26.441] {
[08:27:26.441]     {
[08:27:26.441]         {
[08:27:26.441]             ...future.startTime <- base::Sys.time()
[08:27:26.441]             {
[08:27:26.441]                 {
[08:27:26.441]                   {
[08:27:26.441]                     {
[08:27:26.441]                       base::local({
[08:27:26.441]                         has_future <- base::requireNamespace("future", 
[08:27:26.441]                           quietly = TRUE)
[08:27:26.441]                         if (has_future) {
[08:27:26.441]                           ns <- base::getNamespace("future")
[08:27:26.441]                           version <- ns[[".package"]][["version"]]
[08:27:26.441]                           if (is.null(version)) 
[08:27:26.441]                             version <- utils::packageVersion("future")
[08:27:26.441]                         }
[08:27:26.441]                         else {
[08:27:26.441]                           version <- NULL
[08:27:26.441]                         }
[08:27:26.441]                         if (!has_future || version < "1.8.0") {
[08:27:26.441]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:26.441]                             "", base::R.version$version.string), 
[08:27:26.441]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:26.441]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:26.441]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:26.441]                               "release", "version")], collapse = " "), 
[08:27:26.441]                             hostname = base::Sys.info()[["nodename"]])
[08:27:26.441]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:26.441]                             info)
[08:27:26.441]                           info <- base::paste(info, collapse = "; ")
[08:27:26.441]                           if (!has_future) {
[08:27:26.441]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:26.441]                               info)
[08:27:26.441]                           }
[08:27:26.441]                           else {
[08:27:26.441]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:26.441]                               info, version)
[08:27:26.441]                           }
[08:27:26.441]                           base::stop(msg)
[08:27:26.441]                         }
[08:27:26.441]                       })
[08:27:26.441]                     }
[08:27:26.441]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:26.441]                     base::options(mc.cores = 1L)
[08:27:26.441]                   }
[08:27:26.441]                   ...future.strategy.old <- future::plan("list")
[08:27:26.441]                   options(future.plan = NULL)
[08:27:26.441]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:26.441]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:26.441]                 }
[08:27:26.441]                 ...future.workdir <- getwd()
[08:27:26.441]             }
[08:27:26.441]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:26.441]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:26.441]         }
[08:27:26.441]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:26.441]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:26.441]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:26.441]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:26.441]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:26.441]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:26.441]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:26.441]             base::names(...future.oldOptions))
[08:27:26.441]     }
[08:27:26.441]     if (FALSE) {
[08:27:26.441]     }
[08:27:26.441]     else {
[08:27:26.441]         if (TRUE) {
[08:27:26.441]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:26.441]                 open = "w")
[08:27:26.441]         }
[08:27:26.441]         else {
[08:27:26.441]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:26.441]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:26.441]         }
[08:27:26.441]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:26.441]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:26.441]             base::sink(type = "output", split = FALSE)
[08:27:26.441]             base::close(...future.stdout)
[08:27:26.441]         }, add = TRUE)
[08:27:26.441]     }
[08:27:26.441]     ...future.frame <- base::sys.nframe()
[08:27:26.441]     ...future.conditions <- base::list()
[08:27:26.441]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:26.441]     if (FALSE) {
[08:27:26.441]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:26.441]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:26.441]     }
[08:27:26.441]     ...future.result <- base::tryCatch({
[08:27:26.441]         base::withCallingHandlers({
[08:27:26.441]             ...future.value <- base::withVisible(base::local({
[08:27:26.441]                 ...future.makeSendCondition <- base::local({
[08:27:26.441]                   sendCondition <- NULL
[08:27:26.441]                   function(frame = 1L) {
[08:27:26.441]                     if (is.function(sendCondition)) 
[08:27:26.441]                       return(sendCondition)
[08:27:26.441]                     ns <- getNamespace("parallel")
[08:27:26.441]                     if (exists("sendData", mode = "function", 
[08:27:26.441]                       envir = ns)) {
[08:27:26.441]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:26.441]                         envir = ns)
[08:27:26.441]                       envir <- sys.frame(frame)
[08:27:26.441]                       master <- NULL
[08:27:26.441]                       while (!identical(envir, .GlobalEnv) && 
[08:27:26.441]                         !identical(envir, emptyenv())) {
[08:27:26.441]                         if (exists("master", mode = "list", envir = envir, 
[08:27:26.441]                           inherits = FALSE)) {
[08:27:26.441]                           master <- get("master", mode = "list", 
[08:27:26.441]                             envir = envir, inherits = FALSE)
[08:27:26.441]                           if (inherits(master, c("SOCKnode", 
[08:27:26.441]                             "SOCK0node"))) {
[08:27:26.441]                             sendCondition <<- function(cond) {
[08:27:26.441]                               data <- list(type = "VALUE", value = cond, 
[08:27:26.441]                                 success = TRUE)
[08:27:26.441]                               parallel_sendData(master, data)
[08:27:26.441]                             }
[08:27:26.441]                             return(sendCondition)
[08:27:26.441]                           }
[08:27:26.441]                         }
[08:27:26.441]                         frame <- frame + 1L
[08:27:26.441]                         envir <- sys.frame(frame)
[08:27:26.441]                       }
[08:27:26.441]                     }
[08:27:26.441]                     sendCondition <<- function(cond) NULL
[08:27:26.441]                   }
[08:27:26.441]                 })
[08:27:26.441]                 withCallingHandlers({
[08:27:26.441]                   {
[08:27:26.441]                     sum(x, y)
[08:27:26.441]                   }
[08:27:26.441]                 }, immediateCondition = function(cond) {
[08:27:26.441]                   sendCondition <- ...future.makeSendCondition()
[08:27:26.441]                   sendCondition(cond)
[08:27:26.441]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:26.441]                   {
[08:27:26.441]                     inherits <- base::inherits
[08:27:26.441]                     invokeRestart <- base::invokeRestart
[08:27:26.441]                     is.null <- base::is.null
[08:27:26.441]                     muffled <- FALSE
[08:27:26.441]                     if (inherits(cond, "message")) {
[08:27:26.441]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:26.441]                       if (muffled) 
[08:27:26.441]                         invokeRestart("muffleMessage")
[08:27:26.441]                     }
[08:27:26.441]                     else if (inherits(cond, "warning")) {
[08:27:26.441]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:26.441]                       if (muffled) 
[08:27:26.441]                         invokeRestart("muffleWarning")
[08:27:26.441]                     }
[08:27:26.441]                     else if (inherits(cond, "condition")) {
[08:27:26.441]                       if (!is.null(pattern)) {
[08:27:26.441]                         computeRestarts <- base::computeRestarts
[08:27:26.441]                         grepl <- base::grepl
[08:27:26.441]                         restarts <- computeRestarts(cond)
[08:27:26.441]                         for (restart in restarts) {
[08:27:26.441]                           name <- restart$name
[08:27:26.441]                           if (is.null(name)) 
[08:27:26.441]                             next
[08:27:26.441]                           if (!grepl(pattern, name)) 
[08:27:26.441]                             next
[08:27:26.441]                           invokeRestart(restart)
[08:27:26.441]                           muffled <- TRUE
[08:27:26.441]                           break
[08:27:26.441]                         }
[08:27:26.441]                       }
[08:27:26.441]                     }
[08:27:26.441]                     invisible(muffled)
[08:27:26.441]                   }
[08:27:26.441]                   muffleCondition(cond)
[08:27:26.441]                 })
[08:27:26.441]             }))
[08:27:26.441]             future::FutureResult(value = ...future.value$value, 
[08:27:26.441]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:26.441]                   ...future.rng), globalenv = if (FALSE) 
[08:27:26.441]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:26.441]                     ...future.globalenv.names))
[08:27:26.441]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:26.441]         }, condition = base::local({
[08:27:26.441]             c <- base::c
[08:27:26.441]             inherits <- base::inherits
[08:27:26.441]             invokeRestart <- base::invokeRestart
[08:27:26.441]             length <- base::length
[08:27:26.441]             list <- base::list
[08:27:26.441]             seq.int <- base::seq.int
[08:27:26.441]             signalCondition <- base::signalCondition
[08:27:26.441]             sys.calls <- base::sys.calls
[08:27:26.441]             `[[` <- base::`[[`
[08:27:26.441]             `+` <- base::`+`
[08:27:26.441]             `<<-` <- base::`<<-`
[08:27:26.441]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:26.441]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:26.441]                   3L)]
[08:27:26.441]             }
[08:27:26.441]             function(cond) {
[08:27:26.441]                 is_error <- inherits(cond, "error")
[08:27:26.441]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:26.441]                   NULL)
[08:27:26.441]                 if (is_error) {
[08:27:26.441]                   sessionInformation <- function() {
[08:27:26.441]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:26.441]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:26.441]                       search = base::search(), system = base::Sys.info())
[08:27:26.441]                   }
[08:27:26.441]                   ...future.conditions[[length(...future.conditions) + 
[08:27:26.441]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:26.441]                     cond$call), session = sessionInformation(), 
[08:27:26.441]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:26.441]                   signalCondition(cond)
[08:27:26.441]                 }
[08:27:26.441]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:26.441]                 "immediateCondition"))) {
[08:27:26.441]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:26.441]                   ...future.conditions[[length(...future.conditions) + 
[08:27:26.441]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:26.441]                   if (TRUE && !signal) {
[08:27:26.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:26.441]                     {
[08:27:26.441]                       inherits <- base::inherits
[08:27:26.441]                       invokeRestart <- base::invokeRestart
[08:27:26.441]                       is.null <- base::is.null
[08:27:26.441]                       muffled <- FALSE
[08:27:26.441]                       if (inherits(cond, "message")) {
[08:27:26.441]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:26.441]                         if (muffled) 
[08:27:26.441]                           invokeRestart("muffleMessage")
[08:27:26.441]                       }
[08:27:26.441]                       else if (inherits(cond, "warning")) {
[08:27:26.441]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:26.441]                         if (muffled) 
[08:27:26.441]                           invokeRestart("muffleWarning")
[08:27:26.441]                       }
[08:27:26.441]                       else if (inherits(cond, "condition")) {
[08:27:26.441]                         if (!is.null(pattern)) {
[08:27:26.441]                           computeRestarts <- base::computeRestarts
[08:27:26.441]                           grepl <- base::grepl
[08:27:26.441]                           restarts <- computeRestarts(cond)
[08:27:26.441]                           for (restart in restarts) {
[08:27:26.441]                             name <- restart$name
[08:27:26.441]                             if (is.null(name)) 
[08:27:26.441]                               next
[08:27:26.441]                             if (!grepl(pattern, name)) 
[08:27:26.441]                               next
[08:27:26.441]                             invokeRestart(restart)
[08:27:26.441]                             muffled <- TRUE
[08:27:26.441]                             break
[08:27:26.441]                           }
[08:27:26.441]                         }
[08:27:26.441]                       }
[08:27:26.441]                       invisible(muffled)
[08:27:26.441]                     }
[08:27:26.441]                     muffleCondition(cond, pattern = "^muffle")
[08:27:26.441]                   }
[08:27:26.441]                 }
[08:27:26.441]                 else {
[08:27:26.441]                   if (TRUE) {
[08:27:26.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:26.441]                     {
[08:27:26.441]                       inherits <- base::inherits
[08:27:26.441]                       invokeRestart <- base::invokeRestart
[08:27:26.441]                       is.null <- base::is.null
[08:27:26.441]                       muffled <- FALSE
[08:27:26.441]                       if (inherits(cond, "message")) {
[08:27:26.441]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:26.441]                         if (muffled) 
[08:27:26.441]                           invokeRestart("muffleMessage")
[08:27:26.441]                       }
[08:27:26.441]                       else if (inherits(cond, "warning")) {
[08:27:26.441]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:26.441]                         if (muffled) 
[08:27:26.441]                           invokeRestart("muffleWarning")
[08:27:26.441]                       }
[08:27:26.441]                       else if (inherits(cond, "condition")) {
[08:27:26.441]                         if (!is.null(pattern)) {
[08:27:26.441]                           computeRestarts <- base::computeRestarts
[08:27:26.441]                           grepl <- base::grepl
[08:27:26.441]                           restarts <- computeRestarts(cond)
[08:27:26.441]                           for (restart in restarts) {
[08:27:26.441]                             name <- restart$name
[08:27:26.441]                             if (is.null(name)) 
[08:27:26.441]                               next
[08:27:26.441]                             if (!grepl(pattern, name)) 
[08:27:26.441]                               next
[08:27:26.441]                             invokeRestart(restart)
[08:27:26.441]                             muffled <- TRUE
[08:27:26.441]                             break
[08:27:26.441]                           }
[08:27:26.441]                         }
[08:27:26.441]                       }
[08:27:26.441]                       invisible(muffled)
[08:27:26.441]                     }
[08:27:26.441]                     muffleCondition(cond, pattern = "^muffle")
[08:27:26.441]                   }
[08:27:26.441]                 }
[08:27:26.441]             }
[08:27:26.441]         }))
[08:27:26.441]     }, error = function(ex) {
[08:27:26.441]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:26.441]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:26.441]                 ...future.rng), started = ...future.startTime, 
[08:27:26.441]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:26.441]             version = "1.8"), class = "FutureResult")
[08:27:26.441]     }, finally = {
[08:27:26.441]         if (!identical(...future.workdir, getwd())) 
[08:27:26.441]             setwd(...future.workdir)
[08:27:26.441]         {
[08:27:26.441]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:26.441]                 ...future.oldOptions$nwarnings <- NULL
[08:27:26.441]             }
[08:27:26.441]             base::options(...future.oldOptions)
[08:27:26.441]             if (.Platform$OS.type == "windows") {
[08:27:26.441]                 old_names <- names(...future.oldEnvVars)
[08:27:26.441]                 envs <- base::Sys.getenv()
[08:27:26.441]                 names <- names(envs)
[08:27:26.441]                 common <- intersect(names, old_names)
[08:27:26.441]                 added <- setdiff(names, old_names)
[08:27:26.441]                 removed <- setdiff(old_names, names)
[08:27:26.441]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:26.441]                   envs[common]]
[08:27:26.441]                 NAMES <- toupper(changed)
[08:27:26.441]                 args <- list()
[08:27:26.441]                 for (kk in seq_along(NAMES)) {
[08:27:26.441]                   name <- changed[[kk]]
[08:27:26.441]                   NAME <- NAMES[[kk]]
[08:27:26.441]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:26.441]                     next
[08:27:26.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:26.441]                 }
[08:27:26.441]                 NAMES <- toupper(added)
[08:27:26.441]                 for (kk in seq_along(NAMES)) {
[08:27:26.441]                   name <- added[[kk]]
[08:27:26.441]                   NAME <- NAMES[[kk]]
[08:27:26.441]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:26.441]                     next
[08:27:26.441]                   args[[name]] <- ""
[08:27:26.441]                 }
[08:27:26.441]                 NAMES <- toupper(removed)
[08:27:26.441]                 for (kk in seq_along(NAMES)) {
[08:27:26.441]                   name <- removed[[kk]]
[08:27:26.441]                   NAME <- NAMES[[kk]]
[08:27:26.441]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:26.441]                     next
[08:27:26.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:26.441]                 }
[08:27:26.441]                 if (length(args) > 0) 
[08:27:26.441]                   base::do.call(base::Sys.setenv, args = args)
[08:27:26.441]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:26.441]             }
[08:27:26.441]             else {
[08:27:26.441]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:26.441]             }
[08:27:26.441]             {
[08:27:26.441]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:26.441]                   0L) {
[08:27:26.441]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:26.441]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:26.441]                   base::options(opts)
[08:27:26.441]                 }
[08:27:26.441]                 {
[08:27:26.441]                   {
[08:27:26.441]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:26.441]                     NULL
[08:27:26.441]                   }
[08:27:26.441]                   options(future.plan = NULL)
[08:27:26.441]                   if (is.na(NA_character_)) 
[08:27:26.441]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:26.441]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:26.441]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:26.441]                     .init = FALSE)
[08:27:26.441]                 }
[08:27:26.441]             }
[08:27:26.441]         }
[08:27:26.441]     })
[08:27:26.441]     if (TRUE) {
[08:27:26.441]         base::sink(type = "output", split = FALSE)
[08:27:26.441]         if (TRUE) {
[08:27:26.441]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:26.441]         }
[08:27:26.441]         else {
[08:27:26.441]             ...future.result["stdout"] <- base::list(NULL)
[08:27:26.441]         }
[08:27:26.441]         base::close(...future.stdout)
[08:27:26.441]         ...future.stdout <- NULL
[08:27:26.441]     }
[08:27:26.441]     ...future.result$conditions <- ...future.conditions
[08:27:26.441]     ...future.result$finished <- base::Sys.time()
[08:27:26.441]     ...future.result
[08:27:26.441] }
[08:27:26.445] Exporting 2 global objects (478 bytes) to cluster node #1 ...
[08:27:26.445] Exporting ‘x’ (133 bytes) to cluster node #1 ...
[08:27:26.445] Exporting ‘x’ (133 bytes) to cluster node #1 ... DONE
[08:27:26.445] Exporting ‘y’ (39 bytes) to cluster node #1 ...
[08:27:26.446] Exporting ‘y’ (39 bytes) to cluster node #1 ... DONE
[08:27:26.446] Exporting 2 global objects (478 bytes) to cluster node #1 ... DONE
[08:27:26.446] MultisessionFuture started
[08:27:26.447] - Launch lazy future ... done
[08:27:26.447] run() for ‘MultisessionFuture’ ... done
[08:27:26.447] result() for ClusterFuture ...
[08:27:26.447] receiveMessageFromWorker() for ClusterFuture ...
[08:27:26.447] - Validating connection of MultisessionFuture
[08:27:26.489] - received message: FutureResult
[08:27:26.489] - Received FutureResult
[08:27:26.489] - Erased future from FutureRegistry
[08:27:26.489] result() for ClusterFuture ...
[08:27:26.489] - result already collected: FutureResult
[08:27:26.489] result() for ClusterFuture ... done
[08:27:26.490] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:26.490] result() for ClusterFuture ... done
[08:27:26.490] result() for ClusterFuture ...
[08:27:26.490] - result already collected: FutureResult
[08:27:26.490] result() for ClusterFuture ... done
[1] 6
** Sum function 'D' with plan('multisession') ...
function (x, y) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    y %<-% {
        sum(x, y, ...)
    }
    y
}
<bytecode: 0x559401ce4780>
Arguments '...' exists: FALSE
[08:27:26.491] getGlobalsAndPackages() ...
[08:27:26.491] Searching for globals...
[08:27:26.493] - globals found: [5] ‘{’, ‘sum’, ‘x’, ‘y’, ‘...’
[08:27:26.493] Searching for globals ... DONE
[08:27:26.493] Resolving globals: FALSE
[08:27:26.493] Tweak future expression to call with '...' arguments ...
[08:27:26.494] The total size of the 2 globals is 172 bytes (172 bytes)
[08:27:26.494] The total size of the 2 globals exported for future expression (‘{; sum(x, y, ...); }’) is 172 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (133 bytes of class ‘numeric’) and ‘y’ (39 bytes of class ‘numeric’)
[08:27:26.494] - globals: [2] ‘x’, ‘y’
[08:27:26.494] 
[08:27:26.494] getGlobalsAndPackages() ... DONE
[08:27:26.495] run() for ‘Future’ ...
[08:27:26.495] - state: ‘created’
[08:27:26.495] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:26.510] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:26.510] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:26.510]   - Field: ‘node’
[08:27:26.510]   - Field: ‘label’
[08:27:26.510]   - Field: ‘local’
[08:27:26.510]   - Field: ‘owner’
[08:27:26.510]   - Field: ‘envir’
[08:27:26.510]   - Field: ‘workers’
[08:27:26.511]   - Field: ‘packages’
[08:27:26.511]   - Field: ‘gc’
[08:27:26.511]   - Field: ‘conditions’
[08:27:26.511]   - Field: ‘persistent’
[08:27:26.511]   - Field: ‘expr’
[08:27:26.511]   - Field: ‘uuid’
[08:27:26.511]   - Field: ‘seed’
[08:27:26.511]   - Field: ‘version’
[08:27:26.511]   - Field: ‘result’
[08:27:26.512]   - Field: ‘asynchronous’
[08:27:26.512]   - Field: ‘calls’
[08:27:26.512]   - Field: ‘globals’
[08:27:26.512]   - Field: ‘stdout’
[08:27:26.512]   - Field: ‘earlySignal’
[08:27:26.512]   - Field: ‘lazy’
[08:27:26.512]   - Field: ‘state’
[08:27:26.512] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:26.512] - Launch lazy future ...
[08:27:26.513] Packages needed by the future expression (n = 0): <none>
[08:27:26.513] Packages needed by future strategies (n = 0): <none>
[08:27:26.513] {
[08:27:26.513]     {
[08:27:26.513]         {
[08:27:26.513]             ...future.startTime <- base::Sys.time()
[08:27:26.513]             {
[08:27:26.513]                 {
[08:27:26.513]                   {
[08:27:26.513]                     {
[08:27:26.513]                       base::local({
[08:27:26.513]                         has_future <- base::requireNamespace("future", 
[08:27:26.513]                           quietly = TRUE)
[08:27:26.513]                         if (has_future) {
[08:27:26.513]                           ns <- base::getNamespace("future")
[08:27:26.513]                           version <- ns[[".package"]][["version"]]
[08:27:26.513]                           if (is.null(version)) 
[08:27:26.513]                             version <- utils::packageVersion("future")
[08:27:26.513]                         }
[08:27:26.513]                         else {
[08:27:26.513]                           version <- NULL
[08:27:26.513]                         }
[08:27:26.513]                         if (!has_future || version < "1.8.0") {
[08:27:26.513]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:26.513]                             "", base::R.version$version.string), 
[08:27:26.513]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:26.513]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:26.513]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:26.513]                               "release", "version")], collapse = " "), 
[08:27:26.513]                             hostname = base::Sys.info()[["nodename"]])
[08:27:26.513]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:26.513]                             info)
[08:27:26.513]                           info <- base::paste(info, collapse = "; ")
[08:27:26.513]                           if (!has_future) {
[08:27:26.513]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:26.513]                               info)
[08:27:26.513]                           }
[08:27:26.513]                           else {
[08:27:26.513]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:26.513]                               info, version)
[08:27:26.513]                           }
[08:27:26.513]                           base::stop(msg)
[08:27:26.513]                         }
[08:27:26.513]                       })
[08:27:26.513]                     }
[08:27:26.513]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:26.513]                     base::options(mc.cores = 1L)
[08:27:26.513]                   }
[08:27:26.513]                   ...future.strategy.old <- future::plan("list")
[08:27:26.513]                   options(future.plan = NULL)
[08:27:26.513]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:26.513]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:26.513]                 }
[08:27:26.513]                 ...future.workdir <- getwd()
[08:27:26.513]             }
[08:27:26.513]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:26.513]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:26.513]         }
[08:27:26.513]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:26.513]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:26.513]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:26.513]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:26.513]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:26.513]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:26.513]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:26.513]             base::names(...future.oldOptions))
[08:27:26.513]     }
[08:27:26.513]     if (FALSE) {
[08:27:26.513]     }
[08:27:26.513]     else {
[08:27:26.513]         if (TRUE) {
[08:27:26.513]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:26.513]                 open = "w")
[08:27:26.513]         }
[08:27:26.513]         else {
[08:27:26.513]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:26.513]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:26.513]         }
[08:27:26.513]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:26.513]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:26.513]             base::sink(type = "output", split = FALSE)
[08:27:26.513]             base::close(...future.stdout)
[08:27:26.513]         }, add = TRUE)
[08:27:26.513]     }
[08:27:26.513]     ...future.frame <- base::sys.nframe()
[08:27:26.513]     ...future.conditions <- base::list()
[08:27:26.513]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:26.513]     if (FALSE) {
[08:27:26.513]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:26.513]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:26.513]     }
[08:27:26.513]     ...future.result <- base::tryCatch({
[08:27:26.513]         base::withCallingHandlers({
[08:27:26.513]             ...future.value <- base::withVisible(base::local({
[08:27:26.513]                 ...future.makeSendCondition <- base::local({
[08:27:26.513]                   sendCondition <- NULL
[08:27:26.513]                   function(frame = 1L) {
[08:27:26.513]                     if (is.function(sendCondition)) 
[08:27:26.513]                       return(sendCondition)
[08:27:26.513]                     ns <- getNamespace("parallel")
[08:27:26.513]                     if (exists("sendData", mode = "function", 
[08:27:26.513]                       envir = ns)) {
[08:27:26.513]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:26.513]                         envir = ns)
[08:27:26.513]                       envir <- sys.frame(frame)
[08:27:26.513]                       master <- NULL
[08:27:26.513]                       while (!identical(envir, .GlobalEnv) && 
[08:27:26.513]                         !identical(envir, emptyenv())) {
[08:27:26.513]                         if (exists("master", mode = "list", envir = envir, 
[08:27:26.513]                           inherits = FALSE)) {
[08:27:26.513]                           master <- get("master", mode = "list", 
[08:27:26.513]                             envir = envir, inherits = FALSE)
[08:27:26.513]                           if (inherits(master, c("SOCKnode", 
[08:27:26.513]                             "SOCK0node"))) {
[08:27:26.513]                             sendCondition <<- function(cond) {
[08:27:26.513]                               data <- list(type = "VALUE", value = cond, 
[08:27:26.513]                                 success = TRUE)
[08:27:26.513]                               parallel_sendData(master, data)
[08:27:26.513]                             }
[08:27:26.513]                             return(sendCondition)
[08:27:26.513]                           }
[08:27:26.513]                         }
[08:27:26.513]                         frame <- frame + 1L
[08:27:26.513]                         envir <- sys.frame(frame)
[08:27:26.513]                       }
[08:27:26.513]                     }
[08:27:26.513]                     sendCondition <<- function(cond) NULL
[08:27:26.513]                   }
[08:27:26.513]                 })
[08:27:26.513]                 withCallingHandlers({
[08:27:26.513]                   {
[08:27:26.513]                     sum(x, y, ...)
[08:27:26.513]                   }
[08:27:26.513]                 }, immediateCondition = function(cond) {
[08:27:26.513]                   sendCondition <- ...future.makeSendCondition()
[08:27:26.513]                   sendCondition(cond)
[08:27:26.513]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:26.513]                   {
[08:27:26.513]                     inherits <- base::inherits
[08:27:26.513]                     invokeRestart <- base::invokeRestart
[08:27:26.513]                     is.null <- base::is.null
[08:27:26.513]                     muffled <- FALSE
[08:27:26.513]                     if (inherits(cond, "message")) {
[08:27:26.513]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:26.513]                       if (muffled) 
[08:27:26.513]                         invokeRestart("muffleMessage")
[08:27:26.513]                     }
[08:27:26.513]                     else if (inherits(cond, "warning")) {
[08:27:26.513]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:26.513]                       if (muffled) 
[08:27:26.513]                         invokeRestart("muffleWarning")
[08:27:26.513]                     }
[08:27:26.513]                     else if (inherits(cond, "condition")) {
[08:27:26.513]                       if (!is.null(pattern)) {
[08:27:26.513]                         computeRestarts <- base::computeRestarts
[08:27:26.513]                         grepl <- base::grepl
[08:27:26.513]                         restarts <- computeRestarts(cond)
[08:27:26.513]                         for (restart in restarts) {
[08:27:26.513]                           name <- restart$name
[08:27:26.513]                           if (is.null(name)) 
[08:27:26.513]                             next
[08:27:26.513]                           if (!grepl(pattern, name)) 
[08:27:26.513]                             next
[08:27:26.513]                           invokeRestart(restart)
[08:27:26.513]                           muffled <- TRUE
[08:27:26.513]                           break
[08:27:26.513]                         }
[08:27:26.513]                       }
[08:27:26.513]                     }
[08:27:26.513]                     invisible(muffled)
[08:27:26.513]                   }
[08:27:26.513]                   muffleCondition(cond)
[08:27:26.513]                 })
[08:27:26.513]             }))
[08:27:26.513]             future::FutureResult(value = ...future.value$value, 
[08:27:26.513]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:26.513]                   ...future.rng), globalenv = if (FALSE) 
[08:27:26.513]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:26.513]                     ...future.globalenv.names))
[08:27:26.513]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:26.513]         }, condition = base::local({
[08:27:26.513]             c <- base::c
[08:27:26.513]             inherits <- base::inherits
[08:27:26.513]             invokeRestart <- base::invokeRestart
[08:27:26.513]             length <- base::length
[08:27:26.513]             list <- base::list
[08:27:26.513]             seq.int <- base::seq.int
[08:27:26.513]             signalCondition <- base::signalCondition
[08:27:26.513]             sys.calls <- base::sys.calls
[08:27:26.513]             `[[` <- base::`[[`
[08:27:26.513]             `+` <- base::`+`
[08:27:26.513]             `<<-` <- base::`<<-`
[08:27:26.513]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:26.513]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:26.513]                   3L)]
[08:27:26.513]             }
[08:27:26.513]             function(cond) {
[08:27:26.513]                 is_error <- inherits(cond, "error")
[08:27:26.513]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:26.513]                   NULL)
[08:27:26.513]                 if (is_error) {
[08:27:26.513]                   sessionInformation <- function() {
[08:27:26.513]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:26.513]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:26.513]                       search = base::search(), system = base::Sys.info())
[08:27:26.513]                   }
[08:27:26.513]                   ...future.conditions[[length(...future.conditions) + 
[08:27:26.513]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:26.513]                     cond$call), session = sessionInformation(), 
[08:27:26.513]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:26.513]                   signalCondition(cond)
[08:27:26.513]                 }
[08:27:26.513]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:26.513]                 "immediateCondition"))) {
[08:27:26.513]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:26.513]                   ...future.conditions[[length(...future.conditions) + 
[08:27:26.513]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:26.513]                   if (TRUE && !signal) {
[08:27:26.513]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:26.513]                     {
[08:27:26.513]                       inherits <- base::inherits
[08:27:26.513]                       invokeRestart <- base::invokeRestart
[08:27:26.513]                       is.null <- base::is.null
[08:27:26.513]                       muffled <- FALSE
[08:27:26.513]                       if (inherits(cond, "message")) {
[08:27:26.513]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:26.513]                         if (muffled) 
[08:27:26.513]                           invokeRestart("muffleMessage")
[08:27:26.513]                       }
[08:27:26.513]                       else if (inherits(cond, "warning")) {
[08:27:26.513]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:26.513]                         if (muffled) 
[08:27:26.513]                           invokeRestart("muffleWarning")
[08:27:26.513]                       }
[08:27:26.513]                       else if (inherits(cond, "condition")) {
[08:27:26.513]                         if (!is.null(pattern)) {
[08:27:26.513]                           computeRestarts <- base::computeRestarts
[08:27:26.513]                           grepl <- base::grepl
[08:27:26.513]                           restarts <- computeRestarts(cond)
[08:27:26.513]                           for (restart in restarts) {
[08:27:26.513]                             name <- restart$name
[08:27:26.513]                             if (is.null(name)) 
[08:27:26.513]                               next
[08:27:26.513]                             if (!grepl(pattern, name)) 
[08:27:26.513]                               next
[08:27:26.513]                             invokeRestart(restart)
[08:27:26.513]                             muffled <- TRUE
[08:27:26.513]                             break
[08:27:26.513]                           }
[08:27:26.513]                         }
[08:27:26.513]                       }
[08:27:26.513]                       invisible(muffled)
[08:27:26.513]                     }
[08:27:26.513]                     muffleCondition(cond, pattern = "^muffle")
[08:27:26.513]                   }
[08:27:26.513]                 }
[08:27:26.513]                 else {
[08:27:26.513]                   if (TRUE) {
[08:27:26.513]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:26.513]                     {
[08:27:26.513]                       inherits <- base::inherits
[08:27:26.513]                       invokeRestart <- base::invokeRestart
[08:27:26.513]                       is.null <- base::is.null
[08:27:26.513]                       muffled <- FALSE
[08:27:26.513]                       if (inherits(cond, "message")) {
[08:27:26.513]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:26.513]                         if (muffled) 
[08:27:26.513]                           invokeRestart("muffleMessage")
[08:27:26.513]                       }
[08:27:26.513]                       else if (inherits(cond, "warning")) {
[08:27:26.513]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:26.513]                         if (muffled) 
[08:27:26.513]                           invokeRestart("muffleWarning")
[08:27:26.513]                       }
[08:27:26.513]                       else if (inherits(cond, "condition")) {
[08:27:26.513]                         if (!is.null(pattern)) {
[08:27:26.513]                           computeRestarts <- base::computeRestarts
[08:27:26.513]                           grepl <- base::grepl
[08:27:26.513]                           restarts <- computeRestarts(cond)
[08:27:26.513]                           for (restart in restarts) {
[08:27:26.513]                             name <- restart$name
[08:27:26.513]                             if (is.null(name)) 
[08:27:26.513]                               next
[08:27:26.513]                             if (!grepl(pattern, name)) 
[08:27:26.513]                               next
[08:27:26.513]                             invokeRestart(restart)
[08:27:26.513]                             muffled <- TRUE
[08:27:26.513]                             break
[08:27:26.513]                           }
[08:27:26.513]                         }
[08:27:26.513]                       }
[08:27:26.513]                       invisible(muffled)
[08:27:26.513]                     }
[08:27:26.513]                     muffleCondition(cond, pattern = "^muffle")
[08:27:26.513]                   }
[08:27:26.513]                 }
[08:27:26.513]             }
[08:27:26.513]         }))
[08:27:26.513]     }, error = function(ex) {
[08:27:26.513]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:26.513]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:26.513]                 ...future.rng), started = ...future.startTime, 
[08:27:26.513]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:26.513]             version = "1.8"), class = "FutureResult")
[08:27:26.513]     }, finally = {
[08:27:26.513]         if (!identical(...future.workdir, getwd())) 
[08:27:26.513]             setwd(...future.workdir)
[08:27:26.513]         {
[08:27:26.513]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:26.513]                 ...future.oldOptions$nwarnings <- NULL
[08:27:26.513]             }
[08:27:26.513]             base::options(...future.oldOptions)
[08:27:26.513]             if (.Platform$OS.type == "windows") {
[08:27:26.513]                 old_names <- names(...future.oldEnvVars)
[08:27:26.513]                 envs <- base::Sys.getenv()
[08:27:26.513]                 names <- names(envs)
[08:27:26.513]                 common <- intersect(names, old_names)
[08:27:26.513]                 added <- setdiff(names, old_names)
[08:27:26.513]                 removed <- setdiff(old_names, names)
[08:27:26.513]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:26.513]                   envs[common]]
[08:27:26.513]                 NAMES <- toupper(changed)
[08:27:26.513]                 args <- list()
[08:27:26.513]                 for (kk in seq_along(NAMES)) {
[08:27:26.513]                   name <- changed[[kk]]
[08:27:26.513]                   NAME <- NAMES[[kk]]
[08:27:26.513]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:26.513]                     next
[08:27:26.513]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:26.513]                 }
[08:27:26.513]                 NAMES <- toupper(added)
[08:27:26.513]                 for (kk in seq_along(NAMES)) {
[08:27:26.513]                   name <- added[[kk]]
[08:27:26.513]                   NAME <- NAMES[[kk]]
[08:27:26.513]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:26.513]                     next
[08:27:26.513]                   args[[name]] <- ""
[08:27:26.513]                 }
[08:27:26.513]                 NAMES <- toupper(removed)
[08:27:26.513]                 for (kk in seq_along(NAMES)) {
[08:27:26.513]                   name <- removed[[kk]]
[08:27:26.513]                   NAME <- NAMES[[kk]]
[08:27:26.513]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:26.513]                     next
[08:27:26.513]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:26.513]                 }
[08:27:26.513]                 if (length(args) > 0) 
[08:27:26.513]                   base::do.call(base::Sys.setenv, args = args)
[08:27:26.513]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:26.513]             }
[08:27:26.513]             else {
[08:27:26.513]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:26.513]             }
[08:27:26.513]             {
[08:27:26.513]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:26.513]                   0L) {
[08:27:26.513]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:26.513]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:26.513]                   base::options(opts)
[08:27:26.513]                 }
[08:27:26.513]                 {
[08:27:26.513]                   {
[08:27:26.513]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:26.513]                     NULL
[08:27:26.513]                   }
[08:27:26.513]                   options(future.plan = NULL)
[08:27:26.513]                   if (is.na(NA_character_)) 
[08:27:26.513]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:26.513]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:26.513]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:26.513]                     .init = FALSE)
[08:27:26.513]                 }
[08:27:26.513]             }
[08:27:26.513]         }
[08:27:26.513]     })
[08:27:26.513]     if (TRUE) {
[08:27:26.513]         base::sink(type = "output", split = FALSE)
[08:27:26.513]         if (TRUE) {
[08:27:26.513]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:26.513]         }
[08:27:26.513]         else {
[08:27:26.513]             ...future.result["stdout"] <- base::list(NULL)
[08:27:26.513]         }
[08:27:26.513]         base::close(...future.stdout)
[08:27:26.513]         ...future.stdout <- NULL
[08:27:26.513]     }
[08:27:26.513]     ...future.result$conditions <- ...future.conditions
[08:27:26.513]     ...future.result$finished <- base::Sys.time()
[08:27:26.513]     ...future.result
[08:27:26.513] }
[08:27:26.517] Exporting 2 global objects (478 bytes) to cluster node #1 ...
[08:27:26.517] Exporting ‘x’ (133 bytes) to cluster node #1 ...
[08:27:26.517] Exporting ‘x’ (133 bytes) to cluster node #1 ... DONE
[08:27:26.517] Exporting ‘y’ (39 bytes) to cluster node #1 ...
[08:27:26.518] Exporting ‘y’ (39 bytes) to cluster node #1 ... DONE
[08:27:26.518] Exporting 2 global objects (478 bytes) to cluster node #1 ... DONE
[08:27:26.518] MultisessionFuture started
[08:27:26.519] - Launch lazy future ... done
[08:27:26.519] run() for ‘MultisessionFuture’ ... done
[08:27:26.519] result() for ClusterFuture ...
[08:27:26.519] receiveMessageFromWorker() for ClusterFuture ...
[08:27:26.519] - Validating connection of MultisessionFuture
[08:27:26.561] - received message: FutureResult
[08:27:26.561] - Received FutureResult
[08:27:26.562] - Erased future from FutureRegistry
[08:27:26.562] result() for ClusterFuture ...
[08:27:26.562] - result already collected: FutureResult
[08:27:26.562] result() for ClusterFuture ... done
[08:27:26.562] signalConditions() ...
[08:27:26.562]  - include = ‘immediateCondition’
[08:27:26.562]  - exclude = 
[08:27:26.562]  - resignal = FALSE
[08:27:26.563]  - Number of conditions: 1
[08:27:26.563] signalConditions() ... done
[08:27:26.563] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:26.563] result() for ClusterFuture ... done
[08:27:26.563] result() for ClusterFuture ...
[08:27:26.563] - result already collected: FutureResult
[08:27:26.563] result() for ClusterFuture ... done
[08:27:26.563] signalConditions() ...
[08:27:26.563]  - include = ‘immediateCondition’
[08:27:26.563]  - exclude = 
[08:27:26.564]  - resignal = FALSE
[08:27:26.564]  - Number of conditions: 1
[08:27:26.564] signalConditions() ... done
[08:27:26.564] Future state: ‘finished’
[08:27:26.564] result() for ClusterFuture ...
[08:27:26.564] - result already collected: FutureResult
[08:27:26.564] result() for ClusterFuture ... done
[08:27:26.564] signalConditions() ...
[08:27:26.564]  - include = ‘condition’
[08:27:26.565]  - exclude = ‘immediateCondition’
[08:27:26.565]  - resignal = TRUE
[08:27:26.565]  - Number of conditions: 1
[08:27:26.565]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:27:26.565] signalConditions() ... done
Error in withCallingHandlers({ : '...' used in an incorrect context
[1] "Error in withCallingHandlers({ : '...' used in an incorrect context\n"
attr(,"class")
[1] "try-error"
attr(,"condition")
<simpleError in withCallingHandlers({    {        sum(x, y, ...)    }}, immediateCondition = function(cond) {    sendCondition <- ...future.makeSendCondition()    sendCondition(cond)    muffleCondition <- function (cond, pattern = "^muffle")     {        inherits <- base::inherits        invokeRestart <- base::invokeRestart        is.null <- base::is.null        muffled <- FALSE        if (inherits(cond, "message")) {            muffled <- grepl(pattern, "muffleMessage")            if (muffled)                 invokeRestart("muffleMessage")        }        else if (inherits(cond, "warning")) {            muffled <- grepl(pattern, "muffleWarning")            if (muffled)                 invokeRestart("muffleWarning")        }        else if (inherits(cond, "condition")) {            if (!is.null(pattern)) {                computeRestarts <- base::computeRestarts                grepl <- base::grepl                restarts <- computeRestarts(cond)                for (restart in restarts) {                  name <- restart$name                  if (is.null(name))                     next                  if (!grepl(pattern, name))                     next                  invokeRestart(restart)                  muffled <- TRUE                  break                }            }        }        invisible(muffled)    }    muffleCondition(cond)}): '...' used in an incorrect context>
** Sum function 'E' with plan('multisession') ...
function (...) 
{
    message("Arguments '...' exists: ", exists("...", inherits = TRUE))
    globals <- globals::globalsByName("...", envir = environment())
    f <- future({
        fcn <- function() sum(...)
        fcn()
    }, envir = parent.frame(), globals = globals)
    y <- value(f)
    y
}
<bytecode: 0x5593ffd5df30>
Arguments '...' exists: TRUE
[08:27:26.566] getGlobalsAndPackages() ...
[08:27:26.566] - globals passed as-is: [1] ‘...’
[08:27:26.566] Resolving globals: FALSE
[08:27:26.566] Tweak future expression to call with '...' arguments ...
[08:27:26.566] {
[08:27:26.566]     do.call(function(...) {
[08:27:26.566]         fcn <- function() sum(...)
[08:27:26.566]         fcn()
[08:27:26.566]     }, args = future.call.arguments)
[08:27:26.566] }
[08:27:26.567] Tweak future expression to call with '...' arguments ... DONE
[08:27:26.567] The total size of the 1 globals is 223 bytes (223 bytes)
[08:27:26.568] The total size of the 1 globals exported for future expression (‘{; fcn <- function() sum(...); fcn(); }’) is 223 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘future.call.arguments’ (223 bytes of class ‘list’)
[08:27:26.568] - globals: [1] ‘future.call.arguments’
[08:27:26.568] 
[08:27:26.568] getGlobalsAndPackages() ... DONE
[08:27:26.568] run() for ‘Future’ ...
[08:27:26.568] - state: ‘created’
[08:27:26.568] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:26.583] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:26.583] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:26.584]   - Field: ‘node’
[08:27:26.584]   - Field: ‘label’
[08:27:26.584]   - Field: ‘local’
[08:27:26.584]   - Field: ‘owner’
[08:27:26.584]   - Field: ‘envir’
[08:27:26.584]   - Field: ‘workers’
[08:27:26.584]   - Field: ‘packages’
[08:27:26.584]   - Field: ‘gc’
[08:27:26.584]   - Field: ‘conditions’
[08:27:26.584]   - Field: ‘persistent’
[08:27:26.585]   - Field: ‘expr’
[08:27:26.585]   - Field: ‘uuid’
[08:27:26.585]   - Field: ‘seed’
[08:27:26.585]   - Field: ‘version’
[08:27:26.585]   - Field: ‘result’
[08:27:26.585]   - Field: ‘asynchronous’
[08:27:26.585]   - Field: ‘calls’
[08:27:26.585]   - Field: ‘globals’
[08:27:26.585]   - Field: ‘stdout’
[08:27:26.585]   - Field: ‘earlySignal’
[08:27:26.586]   - Field: ‘lazy’
[08:27:26.586]   - Field: ‘state’
[08:27:26.586] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:26.586] - Launch lazy future ...
[08:27:26.586] Packages needed by the future expression (n = 0): <none>
[08:27:26.586] Packages needed by future strategies (n = 0): <none>
[08:27:26.589] {
[08:27:26.589]     {
[08:27:26.589]         {
[08:27:26.589]             ...future.startTime <- base::Sys.time()
[08:27:26.589]             {
[08:27:26.589]                 {
[08:27:26.589]                   {
[08:27:26.589]                     {
[08:27:26.589]                       base::local({
[08:27:26.589]                         has_future <- base::requireNamespace("future", 
[08:27:26.589]                           quietly = TRUE)
[08:27:26.589]                         if (has_future) {
[08:27:26.589]                           ns <- base::getNamespace("future")
[08:27:26.589]                           version <- ns[[".package"]][["version"]]
[08:27:26.589]                           if (is.null(version)) 
[08:27:26.589]                             version <- utils::packageVersion("future")
[08:27:26.589]                         }
[08:27:26.589]                         else {
[08:27:26.589]                           version <- NULL
[08:27:26.589]                         }
[08:27:26.589]                         if (!has_future || version < "1.8.0") {
[08:27:26.589]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:26.589]                             "", base::R.version$version.string), 
[08:27:26.589]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:26.589]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:26.589]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:26.589]                               "release", "version")], collapse = " "), 
[08:27:26.589]                             hostname = base::Sys.info()[["nodename"]])
[08:27:26.589]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:26.589]                             info)
[08:27:26.589]                           info <- base::paste(info, collapse = "; ")
[08:27:26.589]                           if (!has_future) {
[08:27:26.589]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:26.589]                               info)
[08:27:26.589]                           }
[08:27:26.589]                           else {
[08:27:26.589]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:26.589]                               info, version)
[08:27:26.589]                           }
[08:27:26.589]                           base::stop(msg)
[08:27:26.589]                         }
[08:27:26.589]                       })
[08:27:26.589]                     }
[08:27:26.589]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:26.589]                     base::options(mc.cores = 1L)
[08:27:26.589]                   }
[08:27:26.589]                   ...future.strategy.old <- future::plan("list")
[08:27:26.589]                   options(future.plan = NULL)
[08:27:26.589]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:26.589]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:26.589]                 }
[08:27:26.589]                 ...future.workdir <- getwd()
[08:27:26.589]             }
[08:27:26.589]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:26.589]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:26.589]         }
[08:27:26.589]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:26.589]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:26.589]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:26.589]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:26.589]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:26.589]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:26.589]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:26.589]             base::names(...future.oldOptions))
[08:27:26.589]     }
[08:27:26.589]     if (FALSE) {
[08:27:26.589]     }
[08:27:26.589]     else {
[08:27:26.589]         if (TRUE) {
[08:27:26.589]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:26.589]                 open = "w")
[08:27:26.589]         }
[08:27:26.589]         else {
[08:27:26.589]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:26.589]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:26.589]         }
[08:27:26.589]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:26.589]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:26.589]             base::sink(type = "output", split = FALSE)
[08:27:26.589]             base::close(...future.stdout)
[08:27:26.589]         }, add = TRUE)
[08:27:26.589]     }
[08:27:26.589]     ...future.frame <- base::sys.nframe()
[08:27:26.589]     ...future.conditions <- base::list()
[08:27:26.589]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:26.589]     if (FALSE) {
[08:27:26.589]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:26.589]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:26.589]     }
[08:27:26.589]     ...future.result <- base::tryCatch({
[08:27:26.589]         base::withCallingHandlers({
[08:27:26.589]             ...future.value <- base::withVisible(base::local({
[08:27:26.589]                 ...future.makeSendCondition <- base::local({
[08:27:26.589]                   sendCondition <- NULL
[08:27:26.589]                   function(frame = 1L) {
[08:27:26.589]                     if (is.function(sendCondition)) 
[08:27:26.589]                       return(sendCondition)
[08:27:26.589]                     ns <- getNamespace("parallel")
[08:27:26.589]                     if (exists("sendData", mode = "function", 
[08:27:26.589]                       envir = ns)) {
[08:27:26.589]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:26.589]                         envir = ns)
[08:27:26.589]                       envir <- sys.frame(frame)
[08:27:26.589]                       master <- NULL
[08:27:26.589]                       while (!identical(envir, .GlobalEnv) && 
[08:27:26.589]                         !identical(envir, emptyenv())) {
[08:27:26.589]                         if (exists("master", mode = "list", envir = envir, 
[08:27:26.589]                           inherits = FALSE)) {
[08:27:26.589]                           master <- get("master", mode = "list", 
[08:27:26.589]                             envir = envir, inherits = FALSE)
[08:27:26.589]                           if (inherits(master, c("SOCKnode", 
[08:27:26.589]                             "SOCK0node"))) {
[08:27:26.589]                             sendCondition <<- function(cond) {
[08:27:26.589]                               data <- list(type = "VALUE", value = cond, 
[08:27:26.589]                                 success = TRUE)
[08:27:26.589]                               parallel_sendData(master, data)
[08:27:26.589]                             }
[08:27:26.589]                             return(sendCondition)
[08:27:26.589]                           }
[08:27:26.589]                         }
[08:27:26.589]                         frame <- frame + 1L
[08:27:26.589]                         envir <- sys.frame(frame)
[08:27:26.589]                       }
[08:27:26.589]                     }
[08:27:26.589]                     sendCondition <<- function(cond) NULL
[08:27:26.589]                   }
[08:27:26.589]                 })
[08:27:26.589]                 withCallingHandlers({
[08:27:26.589]                   {
[08:27:26.589]                     do.call(function(...) {
[08:27:26.589]                       fcn <- function() sum(...)
[08:27:26.589]                       fcn()
[08:27:26.589]                     }, args = future.call.arguments)
[08:27:26.589]                   }
[08:27:26.589]                 }, immediateCondition = function(cond) {
[08:27:26.589]                   sendCondition <- ...future.makeSendCondition()
[08:27:26.589]                   sendCondition(cond)
[08:27:26.589]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:26.589]                   {
[08:27:26.589]                     inherits <- base::inherits
[08:27:26.589]                     invokeRestart <- base::invokeRestart
[08:27:26.589]                     is.null <- base::is.null
[08:27:26.589]                     muffled <- FALSE
[08:27:26.589]                     if (inherits(cond, "message")) {
[08:27:26.589]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:26.589]                       if (muffled) 
[08:27:26.589]                         invokeRestart("muffleMessage")
[08:27:26.589]                     }
[08:27:26.589]                     else if (inherits(cond, "warning")) {
[08:27:26.589]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:26.589]                       if (muffled) 
[08:27:26.589]                         invokeRestart("muffleWarning")
[08:27:26.589]                     }
[08:27:26.589]                     else if (inherits(cond, "condition")) {
[08:27:26.589]                       if (!is.null(pattern)) {
[08:27:26.589]                         computeRestarts <- base::computeRestarts
[08:27:26.589]                         grepl <- base::grepl
[08:27:26.589]                         restarts <- computeRestarts(cond)
[08:27:26.589]                         for (restart in restarts) {
[08:27:26.589]                           name <- restart$name
[08:27:26.589]                           if (is.null(name)) 
[08:27:26.589]                             next
[08:27:26.589]                           if (!grepl(pattern, name)) 
[08:27:26.589]                             next
[08:27:26.589]                           invokeRestart(restart)
[08:27:26.589]                           muffled <- TRUE
[08:27:26.589]                           break
[08:27:26.589]                         }
[08:27:26.589]                       }
[08:27:26.589]                     }
[08:27:26.589]                     invisible(muffled)
[08:27:26.589]                   }
[08:27:26.589]                   muffleCondition(cond)
[08:27:26.589]                 })
[08:27:26.589]             }))
[08:27:26.589]             future::FutureResult(value = ...future.value$value, 
[08:27:26.589]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:26.589]                   ...future.rng), globalenv = if (FALSE) 
[08:27:26.589]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:26.589]                     ...future.globalenv.names))
[08:27:26.589]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:26.589]         }, condition = base::local({
[08:27:26.589]             c <- base::c
[08:27:26.589]             inherits <- base::inherits
[08:27:26.589]             invokeRestart <- base::invokeRestart
[08:27:26.589]             length <- base::length
[08:27:26.589]             list <- base::list
[08:27:26.589]             seq.int <- base::seq.int
[08:27:26.589]             signalCondition <- base::signalCondition
[08:27:26.589]             sys.calls <- base::sys.calls
[08:27:26.589]             `[[` <- base::`[[`
[08:27:26.589]             `+` <- base::`+`
[08:27:26.589]             `<<-` <- base::`<<-`
[08:27:26.589]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:26.589]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:26.589]                   3L)]
[08:27:26.589]             }
[08:27:26.589]             function(cond) {
[08:27:26.589]                 is_error <- inherits(cond, "error")
[08:27:26.589]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:26.589]                   NULL)
[08:27:26.589]                 if (is_error) {
[08:27:26.589]                   sessionInformation <- function() {
[08:27:26.589]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:26.589]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:26.589]                       search = base::search(), system = base::Sys.info())
[08:27:26.589]                   }
[08:27:26.589]                   ...future.conditions[[length(...future.conditions) + 
[08:27:26.589]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:26.589]                     cond$call), session = sessionInformation(), 
[08:27:26.589]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:26.589]                   signalCondition(cond)
[08:27:26.589]                 }
[08:27:26.589]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:26.589]                 "immediateCondition"))) {
[08:27:26.589]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:26.589]                   ...future.conditions[[length(...future.conditions) + 
[08:27:26.589]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:26.589]                   if (TRUE && !signal) {
[08:27:26.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:26.589]                     {
[08:27:26.589]                       inherits <- base::inherits
[08:27:26.589]                       invokeRestart <- base::invokeRestart
[08:27:26.589]                       is.null <- base::is.null
[08:27:26.589]                       muffled <- FALSE
[08:27:26.589]                       if (inherits(cond, "message")) {
[08:27:26.589]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:26.589]                         if (muffled) 
[08:27:26.589]                           invokeRestart("muffleMessage")
[08:27:26.589]                       }
[08:27:26.589]                       else if (inherits(cond, "warning")) {
[08:27:26.589]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:26.589]                         if (muffled) 
[08:27:26.589]                           invokeRestart("muffleWarning")
[08:27:26.589]                       }
[08:27:26.589]                       else if (inherits(cond, "condition")) {
[08:27:26.589]                         if (!is.null(pattern)) {
[08:27:26.589]                           computeRestarts <- base::computeRestarts
[08:27:26.589]                           grepl <- base::grepl
[08:27:26.589]                           restarts <- computeRestarts(cond)
[08:27:26.589]                           for (restart in restarts) {
[08:27:26.589]                             name <- restart$name
[08:27:26.589]                             if (is.null(name)) 
[08:27:26.589]                               next
[08:27:26.589]                             if (!grepl(pattern, name)) 
[08:27:26.589]                               next
[08:27:26.589]                             invokeRestart(restart)
[08:27:26.589]                             muffled <- TRUE
[08:27:26.589]                             break
[08:27:26.589]                           }
[08:27:26.589]                         }
[08:27:26.589]                       }
[08:27:26.589]                       invisible(muffled)
[08:27:26.589]                     }
[08:27:26.589]                     muffleCondition(cond, pattern = "^muffle")
[08:27:26.589]                   }
[08:27:26.589]                 }
[08:27:26.589]                 else {
[08:27:26.589]                   if (TRUE) {
[08:27:26.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:26.589]                     {
[08:27:26.589]                       inherits <- base::inherits
[08:27:26.589]                       invokeRestart <- base::invokeRestart
[08:27:26.589]                       is.null <- base::is.null
[08:27:26.589]                       muffled <- FALSE
[08:27:26.589]                       if (inherits(cond, "message")) {
[08:27:26.589]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:26.589]                         if (muffled) 
[08:27:26.589]                           invokeRestart("muffleMessage")
[08:27:26.589]                       }
[08:27:26.589]                       else if (inherits(cond, "warning")) {
[08:27:26.589]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:26.589]                         if (muffled) 
[08:27:26.589]                           invokeRestart("muffleWarning")
[08:27:26.589]                       }
[08:27:26.589]                       else if (inherits(cond, "condition")) {
[08:27:26.589]                         if (!is.null(pattern)) {
[08:27:26.589]                           computeRestarts <- base::computeRestarts
[08:27:26.589]                           grepl <- base::grepl
[08:27:26.589]                           restarts <- computeRestarts(cond)
[08:27:26.589]                           for (restart in restarts) {
[08:27:26.589]                             name <- restart$name
[08:27:26.589]                             if (is.null(name)) 
[08:27:26.589]                               next
[08:27:26.589]                             if (!grepl(pattern, name)) 
[08:27:26.589]                               next
[08:27:26.589]                             invokeRestart(restart)
[08:27:26.589]                             muffled <- TRUE
[08:27:26.589]                             break
[08:27:26.589]                           }
[08:27:26.589]                         }
[08:27:26.589]                       }
[08:27:26.589]                       invisible(muffled)
[08:27:26.589]                     }
[08:27:26.589]                     muffleCondition(cond, pattern = "^muffle")
[08:27:26.589]                   }
[08:27:26.589]                 }
[08:27:26.589]             }
[08:27:26.589]         }))
[08:27:26.589]     }, error = function(ex) {
[08:27:26.589]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:26.589]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:26.589]                 ...future.rng), started = ...future.startTime, 
[08:27:26.589]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:26.589]             version = "1.8"), class = "FutureResult")
[08:27:26.589]     }, finally = {
[08:27:26.589]         if (!identical(...future.workdir, getwd())) 
[08:27:26.589]             setwd(...future.workdir)
[08:27:26.589]         {
[08:27:26.589]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:26.589]                 ...future.oldOptions$nwarnings <- NULL
[08:27:26.589]             }
[08:27:26.589]             base::options(...future.oldOptions)
[08:27:26.589]             if (.Platform$OS.type == "windows") {
[08:27:26.589]                 old_names <- names(...future.oldEnvVars)
[08:27:26.589]                 envs <- base::Sys.getenv()
[08:27:26.589]                 names <- names(envs)
[08:27:26.589]                 common <- intersect(names, old_names)
[08:27:26.589]                 added <- setdiff(names, old_names)
[08:27:26.589]                 removed <- setdiff(old_names, names)
[08:27:26.589]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:26.589]                   envs[common]]
[08:27:26.589]                 NAMES <- toupper(changed)
[08:27:26.589]                 args <- list()
[08:27:26.589]                 for (kk in seq_along(NAMES)) {
[08:27:26.589]                   name <- changed[[kk]]
[08:27:26.589]                   NAME <- NAMES[[kk]]
[08:27:26.589]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:26.589]                     next
[08:27:26.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:26.589]                 }
[08:27:26.589]                 NAMES <- toupper(added)
[08:27:26.589]                 for (kk in seq_along(NAMES)) {
[08:27:26.589]                   name <- added[[kk]]
[08:27:26.589]                   NAME <- NAMES[[kk]]
[08:27:26.589]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:26.589]                     next
[08:27:26.589]                   args[[name]] <- ""
[08:27:26.589]                 }
[08:27:26.589]                 NAMES <- toupper(removed)
[08:27:26.589]                 for (kk in seq_along(NAMES)) {
[08:27:26.589]                   name <- removed[[kk]]
[08:27:26.589]                   NAME <- NAMES[[kk]]
[08:27:26.589]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:26.589]                     next
[08:27:26.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:26.589]                 }
[08:27:26.589]                 if (length(args) > 0) 
[08:27:26.589]                   base::do.call(base::Sys.setenv, args = args)
[08:27:26.589]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:26.589]             }
[08:27:26.589]             else {
[08:27:26.589]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:26.589]             }
[08:27:26.589]             {
[08:27:26.589]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:26.589]                   0L) {
[08:27:26.589]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:26.589]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:26.589]                   base::options(opts)
[08:27:26.589]                 }
[08:27:26.589]                 {
[08:27:26.589]                   {
[08:27:26.589]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:26.589]                     NULL
[08:27:26.589]                   }
[08:27:26.589]                   options(future.plan = NULL)
[08:27:26.589]                   if (is.na(NA_character_)) 
[08:27:26.589]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:26.589]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:26.589]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:26.589]                     .init = FALSE)
[08:27:26.589]                 }
[08:27:26.589]             }
[08:27:26.589]         }
[08:27:26.589]     })
[08:27:26.589]     if (TRUE) {
[08:27:26.589]         base::sink(type = "output", split = FALSE)
[08:27:26.589]         if (TRUE) {
[08:27:26.589]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:26.589]         }
[08:27:26.589]         else {
[08:27:26.589]             ...future.result["stdout"] <- base::list(NULL)
[08:27:26.589]         }
[08:27:26.589]         base::close(...future.stdout)
[08:27:26.589]         ...future.stdout <- NULL
[08:27:26.589]     }
[08:27:26.589]     ...future.result$conditions <- ...future.conditions
[08:27:26.589]     ...future.result$finished <- base::Sys.time()
[08:27:26.589]     ...future.result
[08:27:26.589] }
[08:27:26.592] Exporting 1 global objects (557 bytes) to cluster node #1 ...
[08:27:26.592] Exporting ‘future.call.arguments’ (223 bytes) to cluster node #1 ...
[08:27:26.593] Exporting ‘future.call.arguments’ (223 bytes) to cluster node #1 ... DONE
[08:27:26.593] Exporting 1 global objects (557 bytes) to cluster node #1 ... DONE
[08:27:26.593] MultisessionFuture started
[08:27:26.593] - Launch lazy future ... done
[08:27:26.593] run() for ‘MultisessionFuture’ ... done
[08:27:26.594] result() for ClusterFuture ...
[08:27:26.594] receiveMessageFromWorker() for ClusterFuture ...
[08:27:26.594] - Validating connection of MultisessionFuture
[08:27:26.635] - received message: FutureResult
[08:27:26.635] - Received FutureResult
[08:27:26.636] - Erased future from FutureRegistry
[08:27:26.636] result() for ClusterFuture ...
[08:27:26.636] - result already collected: FutureResult
[08:27:26.636] result() for ClusterFuture ... done
[08:27:26.636] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:26.636] result() for ClusterFuture ... done
[08:27:26.636] result() for ClusterFuture ...
[08:27:26.636] - result already collected: FutureResult
[08:27:26.636] result() for ClusterFuture ... done
[1] 6
** Sum function 'F' with plan('multisession') ...
function (x, y) 
{
    message("Using '...' in a formula")
    fcn <- function(x, y) {
        z = ~list(...)
        sum(x, y)
    }
    f <- future(fcn(x, y))
    y <- value(f)
    y
}
<bytecode: 0x5593ff4673f0>
Using '...' in a formula
[08:27:26.637] getGlobalsAndPackages() ...
[08:27:26.637] Searching for globals...
[08:27:26.639] - globals found: [9] ‘fcn’, ‘x’, ‘y’, ‘{’, ‘=’, ‘~’, ‘list’, ‘...’, ‘sum’
[08:27:26.640] Searching for globals ... DONE
[08:27:26.640] Resolving globals: FALSE
[08:27:26.640] Tweak future expression to call with '...' arguments ...
[08:27:26.640] The total size of the 3 globals is 1.94 KiB (1985 bytes)
[08:27:26.641] The total size of the 3 globals exported for future expression (‘fcn(x, y)’) is 1.94 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘fcn’ (1.77 KiB of class ‘function’), ‘x’ (133 bytes of class ‘numeric’) and ‘y’ (39 bytes of class ‘numeric’)
[08:27:26.641] - globals: [3] ‘fcn’, ‘x’, ‘y’
[08:27:26.641] 
[08:27:26.641] getGlobalsAndPackages() ... DONE
[08:27:26.641] run() for ‘Future’ ...
[08:27:26.641] - state: ‘created’
[08:27:26.642] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:26.655] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:26.655] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:26.655]   - Field: ‘node’
[08:27:26.656]   - Field: ‘label’
[08:27:26.656]   - Field: ‘local’
[08:27:26.656]   - Field: ‘owner’
[08:27:26.656]   - Field: ‘envir’
[08:27:26.656]   - Field: ‘workers’
[08:27:26.656]   - Field: ‘packages’
[08:27:26.656]   - Field: ‘gc’
[08:27:26.656]   - Field: ‘conditions’
[08:27:26.656]   - Field: ‘persistent’
[08:27:26.656]   - Field: ‘expr’
[08:27:26.656]   - Field: ‘uuid’
[08:27:26.656]   - Field: ‘seed’
[08:27:26.657]   - Field: ‘version’
[08:27:26.657]   - Field: ‘result’
[08:27:26.657]   - Field: ‘asynchronous’
[08:27:26.657]   - Field: ‘calls’
[08:27:26.657]   - Field: ‘globals’
[08:27:26.657]   - Field: ‘stdout’
[08:27:26.657]   - Field: ‘earlySignal’
[08:27:26.657]   - Field: ‘lazy’
[08:27:26.657]   - Field: ‘state’
[08:27:26.657] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:26.657] - Launch lazy future ...
[08:27:26.658] Packages needed by the future expression (n = 0): <none>
[08:27:26.658] Packages needed by future strategies (n = 0): <none>
[08:27:26.658] {
[08:27:26.658]     {
[08:27:26.658]         {
[08:27:26.658]             ...future.startTime <- base::Sys.time()
[08:27:26.658]             {
[08:27:26.658]                 {
[08:27:26.658]                   {
[08:27:26.658]                     {
[08:27:26.658]                       base::local({
[08:27:26.658]                         has_future <- base::requireNamespace("future", 
[08:27:26.658]                           quietly = TRUE)
[08:27:26.658]                         if (has_future) {
[08:27:26.658]                           ns <- base::getNamespace("future")
[08:27:26.658]                           version <- ns[[".package"]][["version"]]
[08:27:26.658]                           if (is.null(version)) 
[08:27:26.658]                             version <- utils::packageVersion("future")
[08:27:26.658]                         }
[08:27:26.658]                         else {
[08:27:26.658]                           version <- NULL
[08:27:26.658]                         }
[08:27:26.658]                         if (!has_future || version < "1.8.0") {
[08:27:26.658]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:26.658]                             "", base::R.version$version.string), 
[08:27:26.658]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:26.658]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:26.658]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:26.658]                               "release", "version")], collapse = " "), 
[08:27:26.658]                             hostname = base::Sys.info()[["nodename"]])
[08:27:26.658]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:26.658]                             info)
[08:27:26.658]                           info <- base::paste(info, collapse = "; ")
[08:27:26.658]                           if (!has_future) {
[08:27:26.658]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:26.658]                               info)
[08:27:26.658]                           }
[08:27:26.658]                           else {
[08:27:26.658]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:26.658]                               info, version)
[08:27:26.658]                           }
[08:27:26.658]                           base::stop(msg)
[08:27:26.658]                         }
[08:27:26.658]                       })
[08:27:26.658]                     }
[08:27:26.658]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:26.658]                     base::options(mc.cores = 1L)
[08:27:26.658]                   }
[08:27:26.658]                   ...future.strategy.old <- future::plan("list")
[08:27:26.658]                   options(future.plan = NULL)
[08:27:26.658]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:26.658]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:26.658]                 }
[08:27:26.658]                 ...future.workdir <- getwd()
[08:27:26.658]             }
[08:27:26.658]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:26.658]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:26.658]         }
[08:27:26.658]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:26.658]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:26.658]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:26.658]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:26.658]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:26.658]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:26.658]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:26.658]             base::names(...future.oldOptions))
[08:27:26.658]     }
[08:27:26.658]     if (FALSE) {
[08:27:26.658]     }
[08:27:26.658]     else {
[08:27:26.658]         if (TRUE) {
[08:27:26.658]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:26.658]                 open = "w")
[08:27:26.658]         }
[08:27:26.658]         else {
[08:27:26.658]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:26.658]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:26.658]         }
[08:27:26.658]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:26.658]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:26.658]             base::sink(type = "output", split = FALSE)
[08:27:26.658]             base::close(...future.stdout)
[08:27:26.658]         }, add = TRUE)
[08:27:26.658]     }
[08:27:26.658]     ...future.frame <- base::sys.nframe()
[08:27:26.658]     ...future.conditions <- base::list()
[08:27:26.658]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:26.658]     if (FALSE) {
[08:27:26.658]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:26.658]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:26.658]     }
[08:27:26.658]     ...future.result <- base::tryCatch({
[08:27:26.658]         base::withCallingHandlers({
[08:27:26.658]             ...future.value <- base::withVisible(base::local({
[08:27:26.658]                 ...future.makeSendCondition <- base::local({
[08:27:26.658]                   sendCondition <- NULL
[08:27:26.658]                   function(frame = 1L) {
[08:27:26.658]                     if (is.function(sendCondition)) 
[08:27:26.658]                       return(sendCondition)
[08:27:26.658]                     ns <- getNamespace("parallel")
[08:27:26.658]                     if (exists("sendData", mode = "function", 
[08:27:26.658]                       envir = ns)) {
[08:27:26.658]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:26.658]                         envir = ns)
[08:27:26.658]                       envir <- sys.frame(frame)
[08:27:26.658]                       master <- NULL
[08:27:26.658]                       while (!identical(envir, .GlobalEnv) && 
[08:27:26.658]                         !identical(envir, emptyenv())) {
[08:27:26.658]                         if (exists("master", mode = "list", envir = envir, 
[08:27:26.658]                           inherits = FALSE)) {
[08:27:26.658]                           master <- get("master", mode = "list", 
[08:27:26.658]                             envir = envir, inherits = FALSE)
[08:27:26.658]                           if (inherits(master, c("SOCKnode", 
[08:27:26.658]                             "SOCK0node"))) {
[08:27:26.658]                             sendCondition <<- function(cond) {
[08:27:26.658]                               data <- list(type = "VALUE", value = cond, 
[08:27:26.658]                                 success = TRUE)
[08:27:26.658]                               parallel_sendData(master, data)
[08:27:26.658]                             }
[08:27:26.658]                             return(sendCondition)
[08:27:26.658]                           }
[08:27:26.658]                         }
[08:27:26.658]                         frame <- frame + 1L
[08:27:26.658]                         envir <- sys.frame(frame)
[08:27:26.658]                       }
[08:27:26.658]                     }
[08:27:26.658]                     sendCondition <<- function(cond) NULL
[08:27:26.658]                   }
[08:27:26.658]                 })
[08:27:26.658]                 withCallingHandlers({
[08:27:26.658]                   fcn(x, y)
[08:27:26.658]                 }, immediateCondition = function(cond) {
[08:27:26.658]                   sendCondition <- ...future.makeSendCondition()
[08:27:26.658]                   sendCondition(cond)
[08:27:26.658]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:26.658]                   {
[08:27:26.658]                     inherits <- base::inherits
[08:27:26.658]                     invokeRestart <- base::invokeRestart
[08:27:26.658]                     is.null <- base::is.null
[08:27:26.658]                     muffled <- FALSE
[08:27:26.658]                     if (inherits(cond, "message")) {
[08:27:26.658]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:26.658]                       if (muffled) 
[08:27:26.658]                         invokeRestart("muffleMessage")
[08:27:26.658]                     }
[08:27:26.658]                     else if (inherits(cond, "warning")) {
[08:27:26.658]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:26.658]                       if (muffled) 
[08:27:26.658]                         invokeRestart("muffleWarning")
[08:27:26.658]                     }
[08:27:26.658]                     else if (inherits(cond, "condition")) {
[08:27:26.658]                       if (!is.null(pattern)) {
[08:27:26.658]                         computeRestarts <- base::computeRestarts
[08:27:26.658]                         grepl <- base::grepl
[08:27:26.658]                         restarts <- computeRestarts(cond)
[08:27:26.658]                         for (restart in restarts) {
[08:27:26.658]                           name <- restart$name
[08:27:26.658]                           if (is.null(name)) 
[08:27:26.658]                             next
[08:27:26.658]                           if (!grepl(pattern, name)) 
[08:27:26.658]                             next
[08:27:26.658]                           invokeRestart(restart)
[08:27:26.658]                           muffled <- TRUE
[08:27:26.658]                           break
[08:27:26.658]                         }
[08:27:26.658]                       }
[08:27:26.658]                     }
[08:27:26.658]                     invisible(muffled)
[08:27:26.658]                   }
[08:27:26.658]                   muffleCondition(cond)
[08:27:26.658]                 })
[08:27:26.658]             }))
[08:27:26.658]             future::FutureResult(value = ...future.value$value, 
[08:27:26.658]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:26.658]                   ...future.rng), globalenv = if (FALSE) 
[08:27:26.658]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:26.658]                     ...future.globalenv.names))
[08:27:26.658]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:26.658]         }, condition = base::local({
[08:27:26.658]             c <- base::c
[08:27:26.658]             inherits <- base::inherits
[08:27:26.658]             invokeRestart <- base::invokeRestart
[08:27:26.658]             length <- base::length
[08:27:26.658]             list <- base::list
[08:27:26.658]             seq.int <- base::seq.int
[08:27:26.658]             signalCondition <- base::signalCondition
[08:27:26.658]             sys.calls <- base::sys.calls
[08:27:26.658]             `[[` <- base::`[[`
[08:27:26.658]             `+` <- base::`+`
[08:27:26.658]             `<<-` <- base::`<<-`
[08:27:26.658]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:26.658]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:26.658]                   3L)]
[08:27:26.658]             }
[08:27:26.658]             function(cond) {
[08:27:26.658]                 is_error <- inherits(cond, "error")
[08:27:26.658]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:26.658]                   NULL)
[08:27:26.658]                 if (is_error) {
[08:27:26.658]                   sessionInformation <- function() {
[08:27:26.658]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:26.658]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:26.658]                       search = base::search(), system = base::Sys.info())
[08:27:26.658]                   }
[08:27:26.658]                   ...future.conditions[[length(...future.conditions) + 
[08:27:26.658]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:26.658]                     cond$call), session = sessionInformation(), 
[08:27:26.658]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:26.658]                   signalCondition(cond)
[08:27:26.658]                 }
[08:27:26.658]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:26.658]                 "immediateCondition"))) {
[08:27:26.658]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:26.658]                   ...future.conditions[[length(...future.conditions) + 
[08:27:26.658]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:26.658]                   if (TRUE && !signal) {
[08:27:26.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:26.658]                     {
[08:27:26.658]                       inherits <- base::inherits
[08:27:26.658]                       invokeRestart <- base::invokeRestart
[08:27:26.658]                       is.null <- base::is.null
[08:27:26.658]                       muffled <- FALSE
[08:27:26.658]                       if (inherits(cond, "message")) {
[08:27:26.658]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:26.658]                         if (muffled) 
[08:27:26.658]                           invokeRestart("muffleMessage")
[08:27:26.658]                       }
[08:27:26.658]                       else if (inherits(cond, "warning")) {
[08:27:26.658]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:26.658]                         if (muffled) 
[08:27:26.658]                           invokeRestart("muffleWarning")
[08:27:26.658]                       }
[08:27:26.658]                       else if (inherits(cond, "condition")) {
[08:27:26.658]                         if (!is.null(pattern)) {
[08:27:26.658]                           computeRestarts <- base::computeRestarts
[08:27:26.658]                           grepl <- base::grepl
[08:27:26.658]                           restarts <- computeRestarts(cond)
[08:27:26.658]                           for (restart in restarts) {
[08:27:26.658]                             name <- restart$name
[08:27:26.658]                             if (is.null(name)) 
[08:27:26.658]                               next
[08:27:26.658]                             if (!grepl(pattern, name)) 
[08:27:26.658]                               next
[08:27:26.658]                             invokeRestart(restart)
[08:27:26.658]                             muffled <- TRUE
[08:27:26.658]                             break
[08:27:26.658]                           }
[08:27:26.658]                         }
[08:27:26.658]                       }
[08:27:26.658]                       invisible(muffled)
[08:27:26.658]                     }
[08:27:26.658]                     muffleCondition(cond, pattern = "^muffle")
[08:27:26.658]                   }
[08:27:26.658]                 }
[08:27:26.658]                 else {
[08:27:26.658]                   if (TRUE) {
[08:27:26.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:26.658]                     {
[08:27:26.658]                       inherits <- base::inherits
[08:27:26.658]                       invokeRestart <- base::invokeRestart
[08:27:26.658]                       is.null <- base::is.null
[08:27:26.658]                       muffled <- FALSE
[08:27:26.658]                       if (inherits(cond, "message")) {
[08:27:26.658]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:26.658]                         if (muffled) 
[08:27:26.658]                           invokeRestart("muffleMessage")
[08:27:26.658]                       }
[08:27:26.658]                       else if (inherits(cond, "warning")) {
[08:27:26.658]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:26.658]                         if (muffled) 
[08:27:26.658]                           invokeRestart("muffleWarning")
[08:27:26.658]                       }
[08:27:26.658]                       else if (inherits(cond, "condition")) {
[08:27:26.658]                         if (!is.null(pattern)) {
[08:27:26.658]                           computeRestarts <- base::computeRestarts
[08:27:26.658]                           grepl <- base::grepl
[08:27:26.658]                           restarts <- computeRestarts(cond)
[08:27:26.658]                           for (restart in restarts) {
[08:27:26.658]                             name <- restart$name
[08:27:26.658]                             if (is.null(name)) 
[08:27:26.658]                               next
[08:27:26.658]                             if (!grepl(pattern, name)) 
[08:27:26.658]                               next
[08:27:26.658]                             invokeRestart(restart)
[08:27:26.658]                             muffled <- TRUE
[08:27:26.658]                             break
[08:27:26.658]                           }
[08:27:26.658]                         }
[08:27:26.658]                       }
[08:27:26.658]                       invisible(muffled)
[08:27:26.658]                     }
[08:27:26.658]                     muffleCondition(cond, pattern = "^muffle")
[08:27:26.658]                   }
[08:27:26.658]                 }
[08:27:26.658]             }
[08:27:26.658]         }))
[08:27:26.658]     }, error = function(ex) {
[08:27:26.658]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:26.658]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:26.658]                 ...future.rng), started = ...future.startTime, 
[08:27:26.658]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:26.658]             version = "1.8"), class = "FutureResult")
[08:27:26.658]     }, finally = {
[08:27:26.658]         if (!identical(...future.workdir, getwd())) 
[08:27:26.658]             setwd(...future.workdir)
[08:27:26.658]         {
[08:27:26.658]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:26.658]                 ...future.oldOptions$nwarnings <- NULL
[08:27:26.658]             }
[08:27:26.658]             base::options(...future.oldOptions)
[08:27:26.658]             if (.Platform$OS.type == "windows") {
[08:27:26.658]                 old_names <- names(...future.oldEnvVars)
[08:27:26.658]                 envs <- base::Sys.getenv()
[08:27:26.658]                 names <- names(envs)
[08:27:26.658]                 common <- intersect(names, old_names)
[08:27:26.658]                 added <- setdiff(names, old_names)
[08:27:26.658]                 removed <- setdiff(old_names, names)
[08:27:26.658]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:26.658]                   envs[common]]
[08:27:26.658]                 NAMES <- toupper(changed)
[08:27:26.658]                 args <- list()
[08:27:26.658]                 for (kk in seq_along(NAMES)) {
[08:27:26.658]                   name <- changed[[kk]]
[08:27:26.658]                   NAME <- NAMES[[kk]]
[08:27:26.658]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:26.658]                     next
[08:27:26.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:26.658]                 }
[08:27:26.658]                 NAMES <- toupper(added)
[08:27:26.658]                 for (kk in seq_along(NAMES)) {
[08:27:26.658]                   name <- added[[kk]]
[08:27:26.658]                   NAME <- NAMES[[kk]]
[08:27:26.658]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:26.658]                     next
[08:27:26.658]                   args[[name]] <- ""
[08:27:26.658]                 }
[08:27:26.658]                 NAMES <- toupper(removed)
[08:27:26.658]                 for (kk in seq_along(NAMES)) {
[08:27:26.658]                   name <- removed[[kk]]
[08:27:26.658]                   NAME <- NAMES[[kk]]
[08:27:26.658]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:26.658]                     next
[08:27:26.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:26.658]                 }
[08:27:26.658]                 if (length(args) > 0) 
[08:27:26.658]                   base::do.call(base::Sys.setenv, args = args)
[08:27:26.658]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:26.658]             }
[08:27:26.658]             else {
[08:27:26.658]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:26.658]             }
[08:27:26.658]             {
[08:27:26.658]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:26.658]                   0L) {
[08:27:26.658]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:26.658]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:26.658]                   base::options(opts)
[08:27:26.658]                 }
[08:27:26.658]                 {
[08:27:26.658]                   {
[08:27:26.658]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:26.658]                     NULL
[08:27:26.658]                   }
[08:27:26.658]                   options(future.plan = NULL)
[08:27:26.658]                   if (is.na(NA_character_)) 
[08:27:26.658]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:26.658]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:26.658]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:26.658]                     .init = FALSE)
[08:27:26.658]                 }
[08:27:26.658]             }
[08:27:26.658]         }
[08:27:26.658]     })
[08:27:26.658]     if (TRUE) {
[08:27:26.658]         base::sink(type = "output", split = FALSE)
[08:27:26.658]         if (TRUE) {
[08:27:26.658]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:26.658]         }
[08:27:26.658]         else {
[08:27:26.658]             ...future.result["stdout"] <- base::list(NULL)
[08:27:26.658]         }
[08:27:26.658]         base::close(...future.stdout)
[08:27:26.658]         ...future.stdout <- NULL
[08:27:26.658]     }
[08:27:26.658]     ...future.result$conditions <- ...future.conditions
[08:27:26.658]     ...future.result$finished <- base::Sys.time()
[08:27:26.658]     ...future.result
[08:27:26.658] }
[08:27:26.661] Exporting 3 global objects (2.19 KiB) to cluster node #1 ...
[08:27:26.661] Exporting ‘fcn’ (1.77 KiB) to cluster node #1 ...
[08:27:26.661] Exporting ‘fcn’ (1.77 KiB) to cluster node #1 ... DONE
[08:27:26.662] Exporting ‘x’ (133 bytes) to cluster node #1 ...
[08:27:26.662] Exporting ‘x’ (133 bytes) to cluster node #1 ... DONE
[08:27:26.662] Exporting ‘y’ (39 bytes) to cluster node #1 ...
[08:27:26.663] Exporting ‘y’ (39 bytes) to cluster node #1 ... DONE
[08:27:26.663] Exporting 3 global objects (2.19 KiB) to cluster node #1 ... DONE
[08:27:26.663] MultisessionFuture started
[08:27:26.663] - Launch lazy future ... done
[08:27:26.663] run() for ‘MultisessionFuture’ ... done
[08:27:26.663] result() for ClusterFuture ...
[08:27:26.664] receiveMessageFromWorker() for ClusterFuture ...
[08:27:26.664] - Validating connection of MultisessionFuture
[08:27:26.705] - received message: FutureResult
[08:27:26.706] - Received FutureResult
[08:27:26.706] - Erased future from FutureRegistry
[08:27:26.706] result() for ClusterFuture ...
[08:27:26.706] - result already collected: FutureResult
[08:27:26.706] result() for ClusterFuture ... done
[08:27:26.706] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:26.706] result() for ClusterFuture ... done
[08:27:26.706] result() for ClusterFuture ...
[08:27:26.706] - result already collected: FutureResult
[08:27:26.706] result() for ClusterFuture ... done
[1] 6
Testing with 2 cores ... DONE
> 
> message("*** Global argument '...' ... DONE")
*** Global argument '...' ... DONE
> 
> source("incl/end.R")
[08:27:26.707] plan(): Setting new future strategy stack:
[08:27:26.707] List of future strategies:
[08:27:26.707] 1. FutureStrategy:
[08:27:26.707]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:26.707]    - tweaked: FALSE
[08:27:26.707]    - call: future::plan(oplan)
[08:27:26.708] plan(): nbrOfWorkers() = 1
> 
