
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:21:38.306] plan(): Setting new future strategy stack:
[10:21:38.307] List of future strategies:
[10:21:38.307] 1. sequential:
[10:21:38.307]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.307]    - tweaked: FALSE
[10:21:38.307]    - call: future::plan("sequential")
[10:21:38.321] plan(): nbrOfWorkers() = 1
> 
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Globals - subassignments ...")
*** Globals - subassignments ...
> 
> message("*** Globals - subassignments w/ x$a <- value ...")
*** Globals - subassignments w/ x$a <- value ...
> 
> ## Truth:
> x <- x0 <- list()
> y0 <- list(a = 1)
> str(list(x = x, y0 = y0))
List of 2
 $ x : list()
 $ y0:List of 1
  ..$ a: num 1
> 
> y <- local({
+   x$a <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x[["a"]] <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x["a"] <- list(1)
+   x
+ })
> stopifnot(identical(y, y0))
> 
> stopifnot(identical(x, list()))
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Same with forced lazy evaluation
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     } %lazy% TRUE
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## 'x' is _not_ a global variable here
+     x <- list()
+     y %<-% {
+       x <- list(b = 2)
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, list(b = 2, a = 1)))
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x[["a"]] <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+     
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x["a"] <- list(1)
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     name <- "a"
+     y %<-% {
+       x[name] <- list(1)
+       x
+     }
+     rm(list = c("x", "name"))
+     print(y)
+     stopifnot(identical(y, y0))
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[10:21:38.391] plan(): Setting new future strategy stack:
[10:21:38.391] List of future strategies:
[10:21:38.391] 1. sequential:
[10:21:38.391]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.391]    - tweaked: FALSE
[10:21:38.391]    - call: plan(strategy)
[10:21:38.403] plan(): nbrOfWorkers() = 1
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.404] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.404] Searching for globals...
[10:21:38.411] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:38.411] Searching for globals ... DONE
[10:21:38.411] Resolving globals: TRUE
[10:21:38.412] Resolving any globals that are futures ...
[10:21:38.412] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:38.412] Resolving any globals that are futures ... DONE
[10:21:38.412] Resolving futures part of globals (recursively) ...
[10:21:38.413] resolve() on list ...
[10:21:38.413]  recursive: 99
[10:21:38.413]  length: 1
[10:21:38.413]  elements: ‘x’
[10:21:38.413]  length: 0 (resolved future 1)
[10:21:38.414] resolve() on list ... DONE
[10:21:38.414] - globals: [1] ‘x’
[10:21:38.414] Resolving futures part of globals (recursively) ... DONE
[10:21:38.414] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:38.415] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:38.415] - globals: [1] ‘x’
[10:21:38.415] 
[10:21:38.415] getGlobalsAndPackages() ... DONE
[10:21:38.415] run() for ‘Future’ ...
[10:21:38.416] - state: ‘created’
[10:21:38.416] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:38.416] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:38.416] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:38.416]   - Field: ‘label’
[10:21:38.416]   - Field: ‘local’
[10:21:38.416]   - Field: ‘owner’
[10:21:38.417]   - Field: ‘envir’
[10:21:38.417]   - Field: ‘packages’
[10:21:38.417]   - Field: ‘gc’
[10:21:38.417]   - Field: ‘conditions’
[10:21:38.417]   - Field: ‘expr’
[10:21:38.417]   - Field: ‘uuid’
[10:21:38.417]   - Field: ‘seed’
[10:21:38.417]   - Field: ‘version’
[10:21:38.417]   - Field: ‘result’
[10:21:38.417]   - Field: ‘asynchronous’
[10:21:38.417]   - Field: ‘calls’
[10:21:38.417]   - Field: ‘globals’
[10:21:38.418]   - Field: ‘stdout’
[10:21:38.418]   - Field: ‘earlySignal’
[10:21:38.418]   - Field: ‘lazy’
[10:21:38.418]   - Field: ‘state’
[10:21:38.418] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:38.420] - Launch lazy future ...
[10:21:38.421] Packages needed by the future expression (n = 0): <none>
[10:21:38.421] Packages needed by future strategies (n = 0): <none>
[10:21:38.421] {
[10:21:38.421]     {
[10:21:38.421]         {
[10:21:38.421]             ...future.startTime <- base::Sys.time()
[10:21:38.421]             {
[10:21:38.421]                 {
[10:21:38.421]                   {
[10:21:38.421]                     base::local({
[10:21:38.421]                       has_future <- base::requireNamespace("future", 
[10:21:38.421]                         quietly = TRUE)
[10:21:38.421]                       if (has_future) {
[10:21:38.421]                         ns <- base::getNamespace("future")
[10:21:38.421]                         version <- ns[[".package"]][["version"]]
[10:21:38.421]                         if (is.null(version)) 
[10:21:38.421]                           version <- utils::packageVersion("future")
[10:21:38.421]                       }
[10:21:38.421]                       else {
[10:21:38.421]                         version <- NULL
[10:21:38.421]                       }
[10:21:38.421]                       if (!has_future || version < "1.8.0") {
[10:21:38.421]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.421]                           "", base::R.version$version.string), 
[10:21:38.421]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:38.421]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.421]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.421]                             "release", "version")], collapse = " "), 
[10:21:38.421]                           hostname = base::Sys.info()[["nodename"]])
[10:21:38.421]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.421]                           info)
[10:21:38.421]                         info <- base::paste(info, collapse = "; ")
[10:21:38.421]                         if (!has_future) {
[10:21:38.421]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.421]                             info)
[10:21:38.421]                         }
[10:21:38.421]                         else {
[10:21:38.421]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.421]                             info, version)
[10:21:38.421]                         }
[10:21:38.421]                         base::stop(msg)
[10:21:38.421]                       }
[10:21:38.421]                     })
[10:21:38.421]                   }
[10:21:38.421]                   ...future.strategy.old <- future::plan("list")
[10:21:38.421]                   options(future.plan = NULL)
[10:21:38.421]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.421]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.421]                 }
[10:21:38.421]                 ...future.workdir <- getwd()
[10:21:38.421]             }
[10:21:38.421]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.421]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.421]         }
[10:21:38.421]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.421]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.421]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.421]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.421]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.421]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.421]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.421]             base::names(...future.oldOptions))
[10:21:38.421]     }
[10:21:38.421]     if (FALSE) {
[10:21:38.421]     }
[10:21:38.421]     else {
[10:21:38.421]         if (TRUE) {
[10:21:38.421]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.421]                 open = "w")
[10:21:38.421]         }
[10:21:38.421]         else {
[10:21:38.421]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.421]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.421]         }
[10:21:38.421]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.421]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.421]             base::sink(type = "output", split = FALSE)
[10:21:38.421]             base::close(...future.stdout)
[10:21:38.421]         }, add = TRUE)
[10:21:38.421]     }
[10:21:38.421]     ...future.frame <- base::sys.nframe()
[10:21:38.421]     ...future.conditions <- base::list()
[10:21:38.421]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.421]     if (FALSE) {
[10:21:38.421]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.421]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.421]     }
[10:21:38.421]     ...future.result <- base::tryCatch({
[10:21:38.421]         base::withCallingHandlers({
[10:21:38.421]             ...future.value <- base::withVisible(base::local({
[10:21:38.421]                 x$a <- 1
[10:21:38.421]                 x
[10:21:38.421]             }))
[10:21:38.421]             future::FutureResult(value = ...future.value$value, 
[10:21:38.421]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.421]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.421]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.421]                     ...future.globalenv.names))
[10:21:38.421]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.421]         }, condition = base::local({
[10:21:38.421]             c <- base::c
[10:21:38.421]             inherits <- base::inherits
[10:21:38.421]             invokeRestart <- base::invokeRestart
[10:21:38.421]             length <- base::length
[10:21:38.421]             list <- base::list
[10:21:38.421]             seq.int <- base::seq.int
[10:21:38.421]             signalCondition <- base::signalCondition
[10:21:38.421]             sys.calls <- base::sys.calls
[10:21:38.421]             `[[` <- base::`[[`
[10:21:38.421]             `+` <- base::`+`
[10:21:38.421]             `<<-` <- base::`<<-`
[10:21:38.421]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.421]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.421]                   3L)]
[10:21:38.421]             }
[10:21:38.421]             function(cond) {
[10:21:38.421]                 is_error <- inherits(cond, "error")
[10:21:38.421]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.421]                   NULL)
[10:21:38.421]                 if (is_error) {
[10:21:38.421]                   sessionInformation <- function() {
[10:21:38.421]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.421]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.421]                       search = base::search(), system = base::Sys.info())
[10:21:38.421]                   }
[10:21:38.421]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.421]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.421]                     cond$call), session = sessionInformation(), 
[10:21:38.421]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.421]                   signalCondition(cond)
[10:21:38.421]                 }
[10:21:38.421]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.421]                 "immediateCondition"))) {
[10:21:38.421]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.421]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.421]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.421]                   if (TRUE && !signal) {
[10:21:38.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.421]                     {
[10:21:38.421]                       inherits <- base::inherits
[10:21:38.421]                       invokeRestart <- base::invokeRestart
[10:21:38.421]                       is.null <- base::is.null
[10:21:38.421]                       muffled <- FALSE
[10:21:38.421]                       if (inherits(cond, "message")) {
[10:21:38.421]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.421]                         if (muffled) 
[10:21:38.421]                           invokeRestart("muffleMessage")
[10:21:38.421]                       }
[10:21:38.421]                       else if (inherits(cond, "warning")) {
[10:21:38.421]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.421]                         if (muffled) 
[10:21:38.421]                           invokeRestart("muffleWarning")
[10:21:38.421]                       }
[10:21:38.421]                       else if (inherits(cond, "condition")) {
[10:21:38.421]                         if (!is.null(pattern)) {
[10:21:38.421]                           computeRestarts <- base::computeRestarts
[10:21:38.421]                           grepl <- base::grepl
[10:21:38.421]                           restarts <- computeRestarts(cond)
[10:21:38.421]                           for (restart in restarts) {
[10:21:38.421]                             name <- restart$name
[10:21:38.421]                             if (is.null(name)) 
[10:21:38.421]                               next
[10:21:38.421]                             if (!grepl(pattern, name)) 
[10:21:38.421]                               next
[10:21:38.421]                             invokeRestart(restart)
[10:21:38.421]                             muffled <- TRUE
[10:21:38.421]                             break
[10:21:38.421]                           }
[10:21:38.421]                         }
[10:21:38.421]                       }
[10:21:38.421]                       invisible(muffled)
[10:21:38.421]                     }
[10:21:38.421]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.421]                   }
[10:21:38.421]                 }
[10:21:38.421]                 else {
[10:21:38.421]                   if (TRUE) {
[10:21:38.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.421]                     {
[10:21:38.421]                       inherits <- base::inherits
[10:21:38.421]                       invokeRestart <- base::invokeRestart
[10:21:38.421]                       is.null <- base::is.null
[10:21:38.421]                       muffled <- FALSE
[10:21:38.421]                       if (inherits(cond, "message")) {
[10:21:38.421]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.421]                         if (muffled) 
[10:21:38.421]                           invokeRestart("muffleMessage")
[10:21:38.421]                       }
[10:21:38.421]                       else if (inherits(cond, "warning")) {
[10:21:38.421]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.421]                         if (muffled) 
[10:21:38.421]                           invokeRestart("muffleWarning")
[10:21:38.421]                       }
[10:21:38.421]                       else if (inherits(cond, "condition")) {
[10:21:38.421]                         if (!is.null(pattern)) {
[10:21:38.421]                           computeRestarts <- base::computeRestarts
[10:21:38.421]                           grepl <- base::grepl
[10:21:38.421]                           restarts <- computeRestarts(cond)
[10:21:38.421]                           for (restart in restarts) {
[10:21:38.421]                             name <- restart$name
[10:21:38.421]                             if (is.null(name)) 
[10:21:38.421]                               next
[10:21:38.421]                             if (!grepl(pattern, name)) 
[10:21:38.421]                               next
[10:21:38.421]                             invokeRestart(restart)
[10:21:38.421]                             muffled <- TRUE
[10:21:38.421]                             break
[10:21:38.421]                           }
[10:21:38.421]                         }
[10:21:38.421]                       }
[10:21:38.421]                       invisible(muffled)
[10:21:38.421]                     }
[10:21:38.421]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.421]                   }
[10:21:38.421]                 }
[10:21:38.421]             }
[10:21:38.421]         }))
[10:21:38.421]     }, error = function(ex) {
[10:21:38.421]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.421]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.421]                 ...future.rng), started = ...future.startTime, 
[10:21:38.421]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.421]             version = "1.8"), class = "FutureResult")
[10:21:38.421]     }, finally = {
[10:21:38.421]         if (!identical(...future.workdir, getwd())) 
[10:21:38.421]             setwd(...future.workdir)
[10:21:38.421]         {
[10:21:38.421]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.421]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.421]             }
[10:21:38.421]             base::options(...future.oldOptions)
[10:21:38.421]             if (.Platform$OS.type == "windows") {
[10:21:38.421]                 old_names <- names(...future.oldEnvVars)
[10:21:38.421]                 envs <- base::Sys.getenv()
[10:21:38.421]                 names <- names(envs)
[10:21:38.421]                 common <- intersect(names, old_names)
[10:21:38.421]                 added <- setdiff(names, old_names)
[10:21:38.421]                 removed <- setdiff(old_names, names)
[10:21:38.421]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.421]                   envs[common]]
[10:21:38.421]                 NAMES <- toupper(changed)
[10:21:38.421]                 args <- list()
[10:21:38.421]                 for (kk in seq_along(NAMES)) {
[10:21:38.421]                   name <- changed[[kk]]
[10:21:38.421]                   NAME <- NAMES[[kk]]
[10:21:38.421]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.421]                     next
[10:21:38.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.421]                 }
[10:21:38.421]                 NAMES <- toupper(added)
[10:21:38.421]                 for (kk in seq_along(NAMES)) {
[10:21:38.421]                   name <- added[[kk]]
[10:21:38.421]                   NAME <- NAMES[[kk]]
[10:21:38.421]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.421]                     next
[10:21:38.421]                   args[[name]] <- ""
[10:21:38.421]                 }
[10:21:38.421]                 NAMES <- toupper(removed)
[10:21:38.421]                 for (kk in seq_along(NAMES)) {
[10:21:38.421]                   name <- removed[[kk]]
[10:21:38.421]                   NAME <- NAMES[[kk]]
[10:21:38.421]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.421]                     next
[10:21:38.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.421]                 }
[10:21:38.421]                 if (length(args) > 0) 
[10:21:38.421]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.421]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.421]             }
[10:21:38.421]             else {
[10:21:38.421]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.421]             }
[10:21:38.421]             {
[10:21:38.421]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.421]                   0L) {
[10:21:38.421]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.421]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.421]                   base::options(opts)
[10:21:38.421]                 }
[10:21:38.421]                 {
[10:21:38.421]                   {
[10:21:38.421]                     NULL
[10:21:38.421]                     RNGkind("Mersenne-Twister")
[10:21:38.421]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:38.421]                       inherits = FALSE)
[10:21:38.421]                   }
[10:21:38.421]                   options(future.plan = NULL)
[10:21:38.421]                   if (is.na(NA_character_)) 
[10:21:38.421]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.421]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.421]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.421]                     .init = FALSE)
[10:21:38.421]                 }
[10:21:38.421]             }
[10:21:38.421]         }
[10:21:38.421]     })
[10:21:38.421]     if (TRUE) {
[10:21:38.421]         base::sink(type = "output", split = FALSE)
[10:21:38.421]         if (TRUE) {
[10:21:38.421]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.421]         }
[10:21:38.421]         else {
[10:21:38.421]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.421]         }
[10:21:38.421]         base::close(...future.stdout)
[10:21:38.421]         ...future.stdout <- NULL
[10:21:38.421]     }
[10:21:38.421]     ...future.result$conditions <- ...future.conditions
[10:21:38.421]     ...future.result$finished <- base::Sys.time()
[10:21:38.421]     ...future.result
[10:21:38.421] }
[10:21:38.423] assign_globals() ...
[10:21:38.423] List of 1
[10:21:38.423]  $ x: list()
[10:21:38.423]  - attr(*, "where")=List of 1
[10:21:38.423]   ..$ x:<environment: R_EmptyEnv> 
[10:21:38.423]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:38.423]  - attr(*, "resolved")= logi TRUE
[10:21:38.423]  - attr(*, "total_size")= num 31
[10:21:38.423]  - attr(*, "already-done")= logi TRUE
[10:21:38.426] - copied ‘x’ to environment
[10:21:38.426] assign_globals() ... done
[10:21:38.426] plan(): Setting new future strategy stack:
[10:21:38.426] List of future strategies:
[10:21:38.426] 1. sequential:
[10:21:38.426]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.426]    - tweaked: FALSE
[10:21:38.426]    - call: NULL
[10:21:38.427] plan(): nbrOfWorkers() = 1
[10:21:38.428] plan(): Setting new future strategy stack:
[10:21:38.428] List of future strategies:
[10:21:38.428] 1. sequential:
[10:21:38.428]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.428]    - tweaked: FALSE
[10:21:38.428]    - call: plan(strategy)
[10:21:38.428] plan(): nbrOfWorkers() = 1
[10:21:38.429] SequentialFuture started (and completed)
[10:21:38.429] - Launch lazy future ... done
[10:21:38.429] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.430] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.430] Searching for globals...
[10:21:38.432] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:38.432] Searching for globals ... DONE
[10:21:38.432] Resolving globals: TRUE
[10:21:38.432] Resolving any globals that are futures ...
[10:21:38.432] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:38.432] Resolving any globals that are futures ... DONE
[10:21:38.432] Resolving futures part of globals (recursively) ...
[10:21:38.433] resolve() on list ...
[10:21:38.433]  recursive: 99
[10:21:38.433]  length: 1
[10:21:38.433]  elements: ‘x’
[10:21:38.433]  length: 0 (resolved future 1)
[10:21:38.433] resolve() on list ... DONE
[10:21:38.433] - globals: [1] ‘x’
[10:21:38.433] Resolving futures part of globals (recursively) ... DONE
[10:21:38.433] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:38.434] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:38.434] - globals: [1] ‘x’
[10:21:38.434] 
[10:21:38.434] getGlobalsAndPackages() ... DONE
[10:21:38.434] run() for ‘Future’ ...
[10:21:38.434] - state: ‘created’
[10:21:38.434] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:38.435] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:38.435] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:38.435]   - Field: ‘label’
[10:21:38.435]   - Field: ‘local’
[10:21:38.435]   - Field: ‘owner’
[10:21:38.435]   - Field: ‘envir’
[10:21:38.435]   - Field: ‘packages’
[10:21:38.435]   - Field: ‘gc’
[10:21:38.435]   - Field: ‘conditions’
[10:21:38.436]   - Field: ‘expr’
[10:21:38.436]   - Field: ‘uuid’
[10:21:38.436]   - Field: ‘seed’
[10:21:38.436]   - Field: ‘version’
[10:21:38.436]   - Field: ‘result’
[10:21:38.436]   - Field: ‘asynchronous’
[10:21:38.436]   - Field: ‘calls’
[10:21:38.436]   - Field: ‘globals’
[10:21:38.436]   - Field: ‘stdout’
[10:21:38.436]   - Field: ‘earlySignal’
[10:21:38.436]   - Field: ‘lazy’
[10:21:38.437]   - Field: ‘state’
[10:21:38.437] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:38.437] - Launch lazy future ...
[10:21:38.437] Packages needed by the future expression (n = 0): <none>
[10:21:38.437] Packages needed by future strategies (n = 0): <none>
[10:21:38.437] {
[10:21:38.437]     {
[10:21:38.437]         {
[10:21:38.437]             ...future.startTime <- base::Sys.time()
[10:21:38.437]             {
[10:21:38.437]                 {
[10:21:38.437]                   {
[10:21:38.437]                     base::local({
[10:21:38.437]                       has_future <- base::requireNamespace("future", 
[10:21:38.437]                         quietly = TRUE)
[10:21:38.437]                       if (has_future) {
[10:21:38.437]                         ns <- base::getNamespace("future")
[10:21:38.437]                         version <- ns[[".package"]][["version"]]
[10:21:38.437]                         if (is.null(version)) 
[10:21:38.437]                           version <- utils::packageVersion("future")
[10:21:38.437]                       }
[10:21:38.437]                       else {
[10:21:38.437]                         version <- NULL
[10:21:38.437]                       }
[10:21:38.437]                       if (!has_future || version < "1.8.0") {
[10:21:38.437]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.437]                           "", base::R.version$version.string), 
[10:21:38.437]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:38.437]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.437]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.437]                             "release", "version")], collapse = " "), 
[10:21:38.437]                           hostname = base::Sys.info()[["nodename"]])
[10:21:38.437]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.437]                           info)
[10:21:38.437]                         info <- base::paste(info, collapse = "; ")
[10:21:38.437]                         if (!has_future) {
[10:21:38.437]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.437]                             info)
[10:21:38.437]                         }
[10:21:38.437]                         else {
[10:21:38.437]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.437]                             info, version)
[10:21:38.437]                         }
[10:21:38.437]                         base::stop(msg)
[10:21:38.437]                       }
[10:21:38.437]                     })
[10:21:38.437]                   }
[10:21:38.437]                   ...future.strategy.old <- future::plan("list")
[10:21:38.437]                   options(future.plan = NULL)
[10:21:38.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.437]                 }
[10:21:38.437]                 ...future.workdir <- getwd()
[10:21:38.437]             }
[10:21:38.437]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.437]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.437]         }
[10:21:38.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.437]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.437]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.437]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.437]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.437]             base::names(...future.oldOptions))
[10:21:38.437]     }
[10:21:38.437]     if (FALSE) {
[10:21:38.437]     }
[10:21:38.437]     else {
[10:21:38.437]         if (TRUE) {
[10:21:38.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.437]                 open = "w")
[10:21:38.437]         }
[10:21:38.437]         else {
[10:21:38.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.437]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.437]         }
[10:21:38.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.437]             base::sink(type = "output", split = FALSE)
[10:21:38.437]             base::close(...future.stdout)
[10:21:38.437]         }, add = TRUE)
[10:21:38.437]     }
[10:21:38.437]     ...future.frame <- base::sys.nframe()
[10:21:38.437]     ...future.conditions <- base::list()
[10:21:38.437]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.437]     if (FALSE) {
[10:21:38.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.437]     }
[10:21:38.437]     ...future.result <- base::tryCatch({
[10:21:38.437]         base::withCallingHandlers({
[10:21:38.437]             ...future.value <- base::withVisible(base::local({
[10:21:38.437]                 x$a <- 1
[10:21:38.437]                 x
[10:21:38.437]             }))
[10:21:38.437]             future::FutureResult(value = ...future.value$value, 
[10:21:38.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.437]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.437]                     ...future.globalenv.names))
[10:21:38.437]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.437]         }, condition = base::local({
[10:21:38.437]             c <- base::c
[10:21:38.437]             inherits <- base::inherits
[10:21:38.437]             invokeRestart <- base::invokeRestart
[10:21:38.437]             length <- base::length
[10:21:38.437]             list <- base::list
[10:21:38.437]             seq.int <- base::seq.int
[10:21:38.437]             signalCondition <- base::signalCondition
[10:21:38.437]             sys.calls <- base::sys.calls
[10:21:38.437]             `[[` <- base::`[[`
[10:21:38.437]             `+` <- base::`+`
[10:21:38.437]             `<<-` <- base::`<<-`
[10:21:38.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.437]                   3L)]
[10:21:38.437]             }
[10:21:38.437]             function(cond) {
[10:21:38.437]                 is_error <- inherits(cond, "error")
[10:21:38.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.437]                   NULL)
[10:21:38.437]                 if (is_error) {
[10:21:38.437]                   sessionInformation <- function() {
[10:21:38.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.437]                       search = base::search(), system = base::Sys.info())
[10:21:38.437]                   }
[10:21:38.437]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.437]                     cond$call), session = sessionInformation(), 
[10:21:38.437]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.437]                   signalCondition(cond)
[10:21:38.437]                 }
[10:21:38.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.437]                 "immediateCondition"))) {
[10:21:38.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.437]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.437]                   if (TRUE && !signal) {
[10:21:38.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.437]                     {
[10:21:38.437]                       inherits <- base::inherits
[10:21:38.437]                       invokeRestart <- base::invokeRestart
[10:21:38.437]                       is.null <- base::is.null
[10:21:38.437]                       muffled <- FALSE
[10:21:38.437]                       if (inherits(cond, "message")) {
[10:21:38.437]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.437]                         if (muffled) 
[10:21:38.437]                           invokeRestart("muffleMessage")
[10:21:38.437]                       }
[10:21:38.437]                       else if (inherits(cond, "warning")) {
[10:21:38.437]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.437]                         if (muffled) 
[10:21:38.437]                           invokeRestart("muffleWarning")
[10:21:38.437]                       }
[10:21:38.437]                       else if (inherits(cond, "condition")) {
[10:21:38.437]                         if (!is.null(pattern)) {
[10:21:38.437]                           computeRestarts <- base::computeRestarts
[10:21:38.437]                           grepl <- base::grepl
[10:21:38.437]                           restarts <- computeRestarts(cond)
[10:21:38.437]                           for (restart in restarts) {
[10:21:38.437]                             name <- restart$name
[10:21:38.437]                             if (is.null(name)) 
[10:21:38.437]                               next
[10:21:38.437]                             if (!grepl(pattern, name)) 
[10:21:38.437]                               next
[10:21:38.437]                             invokeRestart(restart)
[10:21:38.437]                             muffled <- TRUE
[10:21:38.437]                             break
[10:21:38.437]                           }
[10:21:38.437]                         }
[10:21:38.437]                       }
[10:21:38.437]                       invisible(muffled)
[10:21:38.437]                     }
[10:21:38.437]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.437]                   }
[10:21:38.437]                 }
[10:21:38.437]                 else {
[10:21:38.437]                   if (TRUE) {
[10:21:38.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.437]                     {
[10:21:38.437]                       inherits <- base::inherits
[10:21:38.437]                       invokeRestart <- base::invokeRestart
[10:21:38.437]                       is.null <- base::is.null
[10:21:38.437]                       muffled <- FALSE
[10:21:38.437]                       if (inherits(cond, "message")) {
[10:21:38.437]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.437]                         if (muffled) 
[10:21:38.437]                           invokeRestart("muffleMessage")
[10:21:38.437]                       }
[10:21:38.437]                       else if (inherits(cond, "warning")) {
[10:21:38.437]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.437]                         if (muffled) 
[10:21:38.437]                           invokeRestart("muffleWarning")
[10:21:38.437]                       }
[10:21:38.437]                       else if (inherits(cond, "condition")) {
[10:21:38.437]                         if (!is.null(pattern)) {
[10:21:38.437]                           computeRestarts <- base::computeRestarts
[10:21:38.437]                           grepl <- base::grepl
[10:21:38.437]                           restarts <- computeRestarts(cond)
[10:21:38.437]                           for (restart in restarts) {
[10:21:38.437]                             name <- restart$name
[10:21:38.437]                             if (is.null(name)) 
[10:21:38.437]                               next
[10:21:38.437]                             if (!grepl(pattern, name)) 
[10:21:38.437]                               next
[10:21:38.437]                             invokeRestart(restart)
[10:21:38.437]                             muffled <- TRUE
[10:21:38.437]                             break
[10:21:38.437]                           }
[10:21:38.437]                         }
[10:21:38.437]                       }
[10:21:38.437]                       invisible(muffled)
[10:21:38.437]                     }
[10:21:38.437]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.437]                   }
[10:21:38.437]                 }
[10:21:38.437]             }
[10:21:38.437]         }))
[10:21:38.437]     }, error = function(ex) {
[10:21:38.437]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.437]                 ...future.rng), started = ...future.startTime, 
[10:21:38.437]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.437]             version = "1.8"), class = "FutureResult")
[10:21:38.437]     }, finally = {
[10:21:38.437]         if (!identical(...future.workdir, getwd())) 
[10:21:38.437]             setwd(...future.workdir)
[10:21:38.437]         {
[10:21:38.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.437]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.437]             }
[10:21:38.437]             base::options(...future.oldOptions)
[10:21:38.437]             if (.Platform$OS.type == "windows") {
[10:21:38.437]                 old_names <- names(...future.oldEnvVars)
[10:21:38.437]                 envs <- base::Sys.getenv()
[10:21:38.437]                 names <- names(envs)
[10:21:38.437]                 common <- intersect(names, old_names)
[10:21:38.437]                 added <- setdiff(names, old_names)
[10:21:38.437]                 removed <- setdiff(old_names, names)
[10:21:38.437]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.437]                   envs[common]]
[10:21:38.437]                 NAMES <- toupper(changed)
[10:21:38.437]                 args <- list()
[10:21:38.437]                 for (kk in seq_along(NAMES)) {
[10:21:38.437]                   name <- changed[[kk]]
[10:21:38.437]                   NAME <- NAMES[[kk]]
[10:21:38.437]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.437]                     next
[10:21:38.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.437]                 }
[10:21:38.437]                 NAMES <- toupper(added)
[10:21:38.437]                 for (kk in seq_along(NAMES)) {
[10:21:38.437]                   name <- added[[kk]]
[10:21:38.437]                   NAME <- NAMES[[kk]]
[10:21:38.437]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.437]                     next
[10:21:38.437]                   args[[name]] <- ""
[10:21:38.437]                 }
[10:21:38.437]                 NAMES <- toupper(removed)
[10:21:38.437]                 for (kk in seq_along(NAMES)) {
[10:21:38.437]                   name <- removed[[kk]]
[10:21:38.437]                   NAME <- NAMES[[kk]]
[10:21:38.437]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.437]                     next
[10:21:38.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.437]                 }
[10:21:38.437]                 if (length(args) > 0) 
[10:21:38.437]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.437]             }
[10:21:38.437]             else {
[10:21:38.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.437]             }
[10:21:38.437]             {
[10:21:38.437]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.437]                   0L) {
[10:21:38.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.437]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.437]                   base::options(opts)
[10:21:38.437]                 }
[10:21:38.437]                 {
[10:21:38.437]                   {
[10:21:38.437]                     NULL
[10:21:38.437]                     RNGkind("Mersenne-Twister")
[10:21:38.437]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:38.437]                       inherits = FALSE)
[10:21:38.437]                   }
[10:21:38.437]                   options(future.plan = NULL)
[10:21:38.437]                   if (is.na(NA_character_)) 
[10:21:38.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.437]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.437]                     .init = FALSE)
[10:21:38.437]                 }
[10:21:38.437]             }
[10:21:38.437]         }
[10:21:38.437]     })
[10:21:38.437]     if (TRUE) {
[10:21:38.437]         base::sink(type = "output", split = FALSE)
[10:21:38.437]         if (TRUE) {
[10:21:38.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.437]         }
[10:21:38.437]         else {
[10:21:38.437]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.437]         }
[10:21:38.437]         base::close(...future.stdout)
[10:21:38.437]         ...future.stdout <- NULL
[10:21:38.437]     }
[10:21:38.437]     ...future.result$conditions <- ...future.conditions
[10:21:38.437]     ...future.result$finished <- base::Sys.time()
[10:21:38.437]     ...future.result
[10:21:38.437] }
[10:21:38.439] assign_globals() ...
[10:21:38.439] List of 1
[10:21:38.439]  $ x: list()
[10:21:38.439]  - attr(*, "where")=List of 1
[10:21:38.439]   ..$ x:<environment: R_EmptyEnv> 
[10:21:38.439]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:38.439]  - attr(*, "resolved")= logi TRUE
[10:21:38.439]  - attr(*, "total_size")= num 31
[10:21:38.439]  - attr(*, "already-done")= logi TRUE
[10:21:38.441] - copied ‘x’ to environment
[10:21:38.442] assign_globals() ... done
[10:21:38.442] plan(): Setting new future strategy stack:
[10:21:38.442] List of future strategies:
[10:21:38.442] 1. sequential:
[10:21:38.442]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.442]    - tweaked: FALSE
[10:21:38.442]    - call: NULL
[10:21:38.442] plan(): nbrOfWorkers() = 1
[10:21:38.443] plan(): Setting new future strategy stack:
[10:21:38.443] List of future strategies:
[10:21:38.443] 1. sequential:
[10:21:38.443]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.443]    - tweaked: FALSE
[10:21:38.443]    - call: plan(strategy)
[10:21:38.443] plan(): nbrOfWorkers() = 1
[10:21:38.444] SequentialFuture started (and completed)
[10:21:38.444] - Launch lazy future ... done
[10:21:38.444] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.445] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.445] Searching for globals...
[10:21:38.447] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:38.447] Searching for globals ... DONE
[10:21:38.447] Resolving globals: TRUE
[10:21:38.447] Resolving any globals that are futures ...
[10:21:38.447] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:38.447] Resolving any globals that are futures ... DONE
[10:21:38.448] Resolving futures part of globals (recursively) ...
[10:21:38.448] resolve() on list ...
[10:21:38.448]  recursive: 99
[10:21:38.448]  length: 1
[10:21:38.448]  elements: ‘x’
[10:21:38.448]  length: 0 (resolved future 1)
[10:21:38.448] resolve() on list ... DONE
[10:21:38.448] - globals: [1] ‘x’
[10:21:38.448] Resolving futures part of globals (recursively) ... DONE
[10:21:38.449] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:38.449] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:38.451] - globals: [1] ‘x’
[10:21:38.451] 
[10:21:38.451] getGlobalsAndPackages() ... DONE
[10:21:38.451] run() for ‘Future’ ...
[10:21:38.451] - state: ‘created’
[10:21:38.452] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:38.452] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:38.452] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:38.452]   - Field: ‘label’
[10:21:38.452]   - Field: ‘local’
[10:21:38.452]   - Field: ‘owner’
[10:21:38.452]   - Field: ‘envir’
[10:21:38.452]   - Field: ‘packages’
[10:21:38.453]   - Field: ‘gc’
[10:21:38.453]   - Field: ‘conditions’
[10:21:38.453]   - Field: ‘expr’
[10:21:38.453]   - Field: ‘uuid’
[10:21:38.453]   - Field: ‘seed’
[10:21:38.453]   - Field: ‘version’
[10:21:38.453]   - Field: ‘result’
[10:21:38.453]   - Field: ‘asynchronous’
[10:21:38.453]   - Field: ‘calls’
[10:21:38.453]   - Field: ‘globals’
[10:21:38.453]   - Field: ‘stdout’
[10:21:38.454]   - Field: ‘earlySignal’
[10:21:38.454]   - Field: ‘lazy’
[10:21:38.454]   - Field: ‘state’
[10:21:38.454] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:38.454] - Launch lazy future ...
[10:21:38.454] Packages needed by the future expression (n = 0): <none>
[10:21:38.454] Packages needed by future strategies (n = 0): <none>
[10:21:38.455] {
[10:21:38.455]     {
[10:21:38.455]         {
[10:21:38.455]             ...future.startTime <- base::Sys.time()
[10:21:38.455]             {
[10:21:38.455]                 {
[10:21:38.455]                   {
[10:21:38.455]                     base::local({
[10:21:38.455]                       has_future <- base::requireNamespace("future", 
[10:21:38.455]                         quietly = TRUE)
[10:21:38.455]                       if (has_future) {
[10:21:38.455]                         ns <- base::getNamespace("future")
[10:21:38.455]                         version <- ns[[".package"]][["version"]]
[10:21:38.455]                         if (is.null(version)) 
[10:21:38.455]                           version <- utils::packageVersion("future")
[10:21:38.455]                       }
[10:21:38.455]                       else {
[10:21:38.455]                         version <- NULL
[10:21:38.455]                       }
[10:21:38.455]                       if (!has_future || version < "1.8.0") {
[10:21:38.455]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.455]                           "", base::R.version$version.string), 
[10:21:38.455]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:38.455]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.455]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.455]                             "release", "version")], collapse = " "), 
[10:21:38.455]                           hostname = base::Sys.info()[["nodename"]])
[10:21:38.455]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.455]                           info)
[10:21:38.455]                         info <- base::paste(info, collapse = "; ")
[10:21:38.455]                         if (!has_future) {
[10:21:38.455]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.455]                             info)
[10:21:38.455]                         }
[10:21:38.455]                         else {
[10:21:38.455]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.455]                             info, version)
[10:21:38.455]                         }
[10:21:38.455]                         base::stop(msg)
[10:21:38.455]                       }
[10:21:38.455]                     })
[10:21:38.455]                   }
[10:21:38.455]                   ...future.strategy.old <- future::plan("list")
[10:21:38.455]                   options(future.plan = NULL)
[10:21:38.455]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.455]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.455]                 }
[10:21:38.455]                 ...future.workdir <- getwd()
[10:21:38.455]             }
[10:21:38.455]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.455]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.455]         }
[10:21:38.455]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.455]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.455]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.455]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.455]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.455]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.455]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.455]             base::names(...future.oldOptions))
[10:21:38.455]     }
[10:21:38.455]     if (FALSE) {
[10:21:38.455]     }
[10:21:38.455]     else {
[10:21:38.455]         if (TRUE) {
[10:21:38.455]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.455]                 open = "w")
[10:21:38.455]         }
[10:21:38.455]         else {
[10:21:38.455]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.455]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.455]         }
[10:21:38.455]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.455]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.455]             base::sink(type = "output", split = FALSE)
[10:21:38.455]             base::close(...future.stdout)
[10:21:38.455]         }, add = TRUE)
[10:21:38.455]     }
[10:21:38.455]     ...future.frame <- base::sys.nframe()
[10:21:38.455]     ...future.conditions <- base::list()
[10:21:38.455]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.455]     if (FALSE) {
[10:21:38.455]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.455]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.455]     }
[10:21:38.455]     ...future.result <- base::tryCatch({
[10:21:38.455]         base::withCallingHandlers({
[10:21:38.455]             ...future.value <- base::withVisible(base::local({
[10:21:38.455]                 x$a <- 1
[10:21:38.455]                 x
[10:21:38.455]             }))
[10:21:38.455]             future::FutureResult(value = ...future.value$value, 
[10:21:38.455]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.455]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.455]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.455]                     ...future.globalenv.names))
[10:21:38.455]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.455]         }, condition = base::local({
[10:21:38.455]             c <- base::c
[10:21:38.455]             inherits <- base::inherits
[10:21:38.455]             invokeRestart <- base::invokeRestart
[10:21:38.455]             length <- base::length
[10:21:38.455]             list <- base::list
[10:21:38.455]             seq.int <- base::seq.int
[10:21:38.455]             signalCondition <- base::signalCondition
[10:21:38.455]             sys.calls <- base::sys.calls
[10:21:38.455]             `[[` <- base::`[[`
[10:21:38.455]             `+` <- base::`+`
[10:21:38.455]             `<<-` <- base::`<<-`
[10:21:38.455]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.455]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.455]                   3L)]
[10:21:38.455]             }
[10:21:38.455]             function(cond) {
[10:21:38.455]                 is_error <- inherits(cond, "error")
[10:21:38.455]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.455]                   NULL)
[10:21:38.455]                 if (is_error) {
[10:21:38.455]                   sessionInformation <- function() {
[10:21:38.455]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.455]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.455]                       search = base::search(), system = base::Sys.info())
[10:21:38.455]                   }
[10:21:38.455]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.455]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.455]                     cond$call), session = sessionInformation(), 
[10:21:38.455]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.455]                   signalCondition(cond)
[10:21:38.455]                 }
[10:21:38.455]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.455]                 "immediateCondition"))) {
[10:21:38.455]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.455]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.455]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.455]                   if (TRUE && !signal) {
[10:21:38.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.455]                     {
[10:21:38.455]                       inherits <- base::inherits
[10:21:38.455]                       invokeRestart <- base::invokeRestart
[10:21:38.455]                       is.null <- base::is.null
[10:21:38.455]                       muffled <- FALSE
[10:21:38.455]                       if (inherits(cond, "message")) {
[10:21:38.455]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.455]                         if (muffled) 
[10:21:38.455]                           invokeRestart("muffleMessage")
[10:21:38.455]                       }
[10:21:38.455]                       else if (inherits(cond, "warning")) {
[10:21:38.455]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.455]                         if (muffled) 
[10:21:38.455]                           invokeRestart("muffleWarning")
[10:21:38.455]                       }
[10:21:38.455]                       else if (inherits(cond, "condition")) {
[10:21:38.455]                         if (!is.null(pattern)) {
[10:21:38.455]                           computeRestarts <- base::computeRestarts
[10:21:38.455]                           grepl <- base::grepl
[10:21:38.455]                           restarts <- computeRestarts(cond)
[10:21:38.455]                           for (restart in restarts) {
[10:21:38.455]                             name <- restart$name
[10:21:38.455]                             if (is.null(name)) 
[10:21:38.455]                               next
[10:21:38.455]                             if (!grepl(pattern, name)) 
[10:21:38.455]                               next
[10:21:38.455]                             invokeRestart(restart)
[10:21:38.455]                             muffled <- TRUE
[10:21:38.455]                             break
[10:21:38.455]                           }
[10:21:38.455]                         }
[10:21:38.455]                       }
[10:21:38.455]                       invisible(muffled)
[10:21:38.455]                     }
[10:21:38.455]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.455]                   }
[10:21:38.455]                 }
[10:21:38.455]                 else {
[10:21:38.455]                   if (TRUE) {
[10:21:38.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.455]                     {
[10:21:38.455]                       inherits <- base::inherits
[10:21:38.455]                       invokeRestart <- base::invokeRestart
[10:21:38.455]                       is.null <- base::is.null
[10:21:38.455]                       muffled <- FALSE
[10:21:38.455]                       if (inherits(cond, "message")) {
[10:21:38.455]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.455]                         if (muffled) 
[10:21:38.455]                           invokeRestart("muffleMessage")
[10:21:38.455]                       }
[10:21:38.455]                       else if (inherits(cond, "warning")) {
[10:21:38.455]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.455]                         if (muffled) 
[10:21:38.455]                           invokeRestart("muffleWarning")
[10:21:38.455]                       }
[10:21:38.455]                       else if (inherits(cond, "condition")) {
[10:21:38.455]                         if (!is.null(pattern)) {
[10:21:38.455]                           computeRestarts <- base::computeRestarts
[10:21:38.455]                           grepl <- base::grepl
[10:21:38.455]                           restarts <- computeRestarts(cond)
[10:21:38.455]                           for (restart in restarts) {
[10:21:38.455]                             name <- restart$name
[10:21:38.455]                             if (is.null(name)) 
[10:21:38.455]                               next
[10:21:38.455]                             if (!grepl(pattern, name)) 
[10:21:38.455]                               next
[10:21:38.455]                             invokeRestart(restart)
[10:21:38.455]                             muffled <- TRUE
[10:21:38.455]                             break
[10:21:38.455]                           }
[10:21:38.455]                         }
[10:21:38.455]                       }
[10:21:38.455]                       invisible(muffled)
[10:21:38.455]                     }
[10:21:38.455]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.455]                   }
[10:21:38.455]                 }
[10:21:38.455]             }
[10:21:38.455]         }))
[10:21:38.455]     }, error = function(ex) {
[10:21:38.455]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.455]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.455]                 ...future.rng), started = ...future.startTime, 
[10:21:38.455]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.455]             version = "1.8"), class = "FutureResult")
[10:21:38.455]     }, finally = {
[10:21:38.455]         if (!identical(...future.workdir, getwd())) 
[10:21:38.455]             setwd(...future.workdir)
[10:21:38.455]         {
[10:21:38.455]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.455]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.455]             }
[10:21:38.455]             base::options(...future.oldOptions)
[10:21:38.455]             if (.Platform$OS.type == "windows") {
[10:21:38.455]                 old_names <- names(...future.oldEnvVars)
[10:21:38.455]                 envs <- base::Sys.getenv()
[10:21:38.455]                 names <- names(envs)
[10:21:38.455]                 common <- intersect(names, old_names)
[10:21:38.455]                 added <- setdiff(names, old_names)
[10:21:38.455]                 removed <- setdiff(old_names, names)
[10:21:38.455]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.455]                   envs[common]]
[10:21:38.455]                 NAMES <- toupper(changed)
[10:21:38.455]                 args <- list()
[10:21:38.455]                 for (kk in seq_along(NAMES)) {
[10:21:38.455]                   name <- changed[[kk]]
[10:21:38.455]                   NAME <- NAMES[[kk]]
[10:21:38.455]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.455]                     next
[10:21:38.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.455]                 }
[10:21:38.455]                 NAMES <- toupper(added)
[10:21:38.455]                 for (kk in seq_along(NAMES)) {
[10:21:38.455]                   name <- added[[kk]]
[10:21:38.455]                   NAME <- NAMES[[kk]]
[10:21:38.455]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.455]                     next
[10:21:38.455]                   args[[name]] <- ""
[10:21:38.455]                 }
[10:21:38.455]                 NAMES <- toupper(removed)
[10:21:38.455]                 for (kk in seq_along(NAMES)) {
[10:21:38.455]                   name <- removed[[kk]]
[10:21:38.455]                   NAME <- NAMES[[kk]]
[10:21:38.455]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.455]                     next
[10:21:38.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.455]                 }
[10:21:38.455]                 if (length(args) > 0) 
[10:21:38.455]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.455]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.455]             }
[10:21:38.455]             else {
[10:21:38.455]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.455]             }
[10:21:38.455]             {
[10:21:38.455]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.455]                   0L) {
[10:21:38.455]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.455]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.455]                   base::options(opts)
[10:21:38.455]                 }
[10:21:38.455]                 {
[10:21:38.455]                   {
[10:21:38.455]                     NULL
[10:21:38.455]                     RNGkind("Mersenne-Twister")
[10:21:38.455]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:38.455]                       inherits = FALSE)
[10:21:38.455]                   }
[10:21:38.455]                   options(future.plan = NULL)
[10:21:38.455]                   if (is.na(NA_character_)) 
[10:21:38.455]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.455]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.455]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.455]                     .init = FALSE)
[10:21:38.455]                 }
[10:21:38.455]             }
[10:21:38.455]         }
[10:21:38.455]     })
[10:21:38.455]     if (TRUE) {
[10:21:38.455]         base::sink(type = "output", split = FALSE)
[10:21:38.455]         if (TRUE) {
[10:21:38.455]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.455]         }
[10:21:38.455]         else {
[10:21:38.455]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.455]         }
[10:21:38.455]         base::close(...future.stdout)
[10:21:38.455]         ...future.stdout <- NULL
[10:21:38.455]     }
[10:21:38.455]     ...future.result$conditions <- ...future.conditions
[10:21:38.455]     ...future.result$finished <- base::Sys.time()
[10:21:38.455]     ...future.result
[10:21:38.455] }
[10:21:38.456] assign_globals() ...
[10:21:38.456] List of 1
[10:21:38.456]  $ x: list()
[10:21:38.456]  - attr(*, "where")=List of 1
[10:21:38.456]   ..$ x:<environment: R_EmptyEnv> 
[10:21:38.456]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:38.456]  - attr(*, "resolved")= logi TRUE
[10:21:38.456]  - attr(*, "total_size")= num 31
[10:21:38.456]  - attr(*, "already-done")= logi TRUE
[10:21:38.459] - copied ‘x’ to environment
[10:21:38.459] assign_globals() ... done
[10:21:38.459] plan(): Setting new future strategy stack:
[10:21:38.459] List of future strategies:
[10:21:38.459] 1. sequential:
[10:21:38.459]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.459]    - tweaked: FALSE
[10:21:38.459]    - call: NULL
[10:21:38.459] plan(): nbrOfWorkers() = 1
[10:21:38.460] plan(): Setting new future strategy stack:
[10:21:38.460] List of future strategies:
[10:21:38.460] 1. sequential:
[10:21:38.460]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.460]    - tweaked: FALSE
[10:21:38.460]    - call: plan(strategy)
[10:21:38.461] plan(): nbrOfWorkers() = 1
[10:21:38.461] SequentialFuture started (and completed)
[10:21:38.461] - Launch lazy future ... done
[10:21:38.461] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.462] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.462] Searching for globals...
[10:21:38.463] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:38.464] Searching for globals ... DONE
[10:21:38.464] Resolving globals: TRUE
[10:21:38.464] Resolving any globals that are futures ...
[10:21:38.464] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:38.464] Resolving any globals that are futures ... DONE
[10:21:38.464] Resolving futures part of globals (recursively) ...
[10:21:38.464] resolve() on list ...
[10:21:38.465]  recursive: 99
[10:21:38.465]  length: 1
[10:21:38.465]  elements: ‘x’
[10:21:38.465]  length: 0 (resolved future 1)
[10:21:38.465] resolve() on list ... DONE
[10:21:38.465] - globals: [1] ‘x’
[10:21:38.465] Resolving futures part of globals (recursively) ... DONE
[10:21:38.465] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:38.466] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:38.466] - globals: [1] ‘x’
[10:21:38.466] 
[10:21:38.466] getGlobalsAndPackages() ... DONE
[10:21:38.466] run() for ‘Future’ ...
[10:21:38.466] - state: ‘created’
[10:21:38.466] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:38.467] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:38.467] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:38.467]   - Field: ‘label’
[10:21:38.467]   - Field: ‘local’
[10:21:38.467]   - Field: ‘owner’
[10:21:38.467]   - Field: ‘envir’
[10:21:38.467]   - Field: ‘packages’
[10:21:38.467]   - Field: ‘gc’
[10:21:38.467]   - Field: ‘conditions’
[10:21:38.467]   - Field: ‘expr’
[10:21:38.467]   - Field: ‘uuid’
[10:21:38.468]   - Field: ‘seed’
[10:21:38.468]   - Field: ‘version’
[10:21:38.468]   - Field: ‘result’
[10:21:38.468]   - Field: ‘asynchronous’
[10:21:38.468]   - Field: ‘calls’
[10:21:38.468]   - Field: ‘globals’
[10:21:38.468]   - Field: ‘stdout’
[10:21:38.468]   - Field: ‘earlySignal’
[10:21:38.468]   - Field: ‘lazy’
[10:21:38.468]   - Field: ‘state’
[10:21:38.468] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:38.469] - Launch lazy future ...
[10:21:38.469] Packages needed by the future expression (n = 0): <none>
[10:21:38.469] Packages needed by future strategies (n = 0): <none>
[10:21:38.469] {
[10:21:38.469]     {
[10:21:38.469]         {
[10:21:38.469]             ...future.startTime <- base::Sys.time()
[10:21:38.469]             {
[10:21:38.469]                 {
[10:21:38.469]                   {
[10:21:38.469]                     base::local({
[10:21:38.469]                       has_future <- base::requireNamespace("future", 
[10:21:38.469]                         quietly = TRUE)
[10:21:38.469]                       if (has_future) {
[10:21:38.469]                         ns <- base::getNamespace("future")
[10:21:38.469]                         version <- ns[[".package"]][["version"]]
[10:21:38.469]                         if (is.null(version)) 
[10:21:38.469]                           version <- utils::packageVersion("future")
[10:21:38.469]                       }
[10:21:38.469]                       else {
[10:21:38.469]                         version <- NULL
[10:21:38.469]                       }
[10:21:38.469]                       if (!has_future || version < "1.8.0") {
[10:21:38.469]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.469]                           "", base::R.version$version.string), 
[10:21:38.469]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:38.469]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.469]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.469]                             "release", "version")], collapse = " "), 
[10:21:38.469]                           hostname = base::Sys.info()[["nodename"]])
[10:21:38.469]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.469]                           info)
[10:21:38.469]                         info <- base::paste(info, collapse = "; ")
[10:21:38.469]                         if (!has_future) {
[10:21:38.469]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.469]                             info)
[10:21:38.469]                         }
[10:21:38.469]                         else {
[10:21:38.469]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.469]                             info, version)
[10:21:38.469]                         }
[10:21:38.469]                         base::stop(msg)
[10:21:38.469]                       }
[10:21:38.469]                     })
[10:21:38.469]                   }
[10:21:38.469]                   ...future.strategy.old <- future::plan("list")
[10:21:38.469]                   options(future.plan = NULL)
[10:21:38.469]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.469]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.469]                 }
[10:21:38.469]                 ...future.workdir <- getwd()
[10:21:38.469]             }
[10:21:38.469]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.469]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.469]         }
[10:21:38.469]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.469]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.469]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.469]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.469]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.469]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.469]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.469]             base::names(...future.oldOptions))
[10:21:38.469]     }
[10:21:38.469]     if (FALSE) {
[10:21:38.469]     }
[10:21:38.469]     else {
[10:21:38.469]         if (TRUE) {
[10:21:38.469]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.469]                 open = "w")
[10:21:38.469]         }
[10:21:38.469]         else {
[10:21:38.469]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.469]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.469]         }
[10:21:38.469]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.469]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.469]             base::sink(type = "output", split = FALSE)
[10:21:38.469]             base::close(...future.stdout)
[10:21:38.469]         }, add = TRUE)
[10:21:38.469]     }
[10:21:38.469]     ...future.frame <- base::sys.nframe()
[10:21:38.469]     ...future.conditions <- base::list()
[10:21:38.469]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.469]     if (FALSE) {
[10:21:38.469]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.469]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.469]     }
[10:21:38.469]     ...future.result <- base::tryCatch({
[10:21:38.469]         base::withCallingHandlers({
[10:21:38.469]             ...future.value <- base::withVisible(base::local({
[10:21:38.469]                 x$a <- 1
[10:21:38.469]                 x
[10:21:38.469]             }))
[10:21:38.469]             future::FutureResult(value = ...future.value$value, 
[10:21:38.469]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.469]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.469]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.469]                     ...future.globalenv.names))
[10:21:38.469]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.469]         }, condition = base::local({
[10:21:38.469]             c <- base::c
[10:21:38.469]             inherits <- base::inherits
[10:21:38.469]             invokeRestart <- base::invokeRestart
[10:21:38.469]             length <- base::length
[10:21:38.469]             list <- base::list
[10:21:38.469]             seq.int <- base::seq.int
[10:21:38.469]             signalCondition <- base::signalCondition
[10:21:38.469]             sys.calls <- base::sys.calls
[10:21:38.469]             `[[` <- base::`[[`
[10:21:38.469]             `+` <- base::`+`
[10:21:38.469]             `<<-` <- base::`<<-`
[10:21:38.469]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.469]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.469]                   3L)]
[10:21:38.469]             }
[10:21:38.469]             function(cond) {
[10:21:38.469]                 is_error <- inherits(cond, "error")
[10:21:38.469]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.469]                   NULL)
[10:21:38.469]                 if (is_error) {
[10:21:38.469]                   sessionInformation <- function() {
[10:21:38.469]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.469]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.469]                       search = base::search(), system = base::Sys.info())
[10:21:38.469]                   }
[10:21:38.469]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.469]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.469]                     cond$call), session = sessionInformation(), 
[10:21:38.469]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.469]                   signalCondition(cond)
[10:21:38.469]                 }
[10:21:38.469]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.469]                 "immediateCondition"))) {
[10:21:38.469]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.469]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.469]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.469]                   if (TRUE && !signal) {
[10:21:38.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.469]                     {
[10:21:38.469]                       inherits <- base::inherits
[10:21:38.469]                       invokeRestart <- base::invokeRestart
[10:21:38.469]                       is.null <- base::is.null
[10:21:38.469]                       muffled <- FALSE
[10:21:38.469]                       if (inherits(cond, "message")) {
[10:21:38.469]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.469]                         if (muffled) 
[10:21:38.469]                           invokeRestart("muffleMessage")
[10:21:38.469]                       }
[10:21:38.469]                       else if (inherits(cond, "warning")) {
[10:21:38.469]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.469]                         if (muffled) 
[10:21:38.469]                           invokeRestart("muffleWarning")
[10:21:38.469]                       }
[10:21:38.469]                       else if (inherits(cond, "condition")) {
[10:21:38.469]                         if (!is.null(pattern)) {
[10:21:38.469]                           computeRestarts <- base::computeRestarts
[10:21:38.469]                           grepl <- base::grepl
[10:21:38.469]                           restarts <- computeRestarts(cond)
[10:21:38.469]                           for (restart in restarts) {
[10:21:38.469]                             name <- restart$name
[10:21:38.469]                             if (is.null(name)) 
[10:21:38.469]                               next
[10:21:38.469]                             if (!grepl(pattern, name)) 
[10:21:38.469]                               next
[10:21:38.469]                             invokeRestart(restart)
[10:21:38.469]                             muffled <- TRUE
[10:21:38.469]                             break
[10:21:38.469]                           }
[10:21:38.469]                         }
[10:21:38.469]                       }
[10:21:38.469]                       invisible(muffled)
[10:21:38.469]                     }
[10:21:38.469]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.469]                   }
[10:21:38.469]                 }
[10:21:38.469]                 else {
[10:21:38.469]                   if (TRUE) {
[10:21:38.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.469]                     {
[10:21:38.469]                       inherits <- base::inherits
[10:21:38.469]                       invokeRestart <- base::invokeRestart
[10:21:38.469]                       is.null <- base::is.null
[10:21:38.469]                       muffled <- FALSE
[10:21:38.469]                       if (inherits(cond, "message")) {
[10:21:38.469]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.469]                         if (muffled) 
[10:21:38.469]                           invokeRestart("muffleMessage")
[10:21:38.469]                       }
[10:21:38.469]                       else if (inherits(cond, "warning")) {
[10:21:38.469]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.469]                         if (muffled) 
[10:21:38.469]                           invokeRestart("muffleWarning")
[10:21:38.469]                       }
[10:21:38.469]                       else if (inherits(cond, "condition")) {
[10:21:38.469]                         if (!is.null(pattern)) {
[10:21:38.469]                           computeRestarts <- base::computeRestarts
[10:21:38.469]                           grepl <- base::grepl
[10:21:38.469]                           restarts <- computeRestarts(cond)
[10:21:38.469]                           for (restart in restarts) {
[10:21:38.469]                             name <- restart$name
[10:21:38.469]                             if (is.null(name)) 
[10:21:38.469]                               next
[10:21:38.469]                             if (!grepl(pattern, name)) 
[10:21:38.469]                               next
[10:21:38.469]                             invokeRestart(restart)
[10:21:38.469]                             muffled <- TRUE
[10:21:38.469]                             break
[10:21:38.469]                           }
[10:21:38.469]                         }
[10:21:38.469]                       }
[10:21:38.469]                       invisible(muffled)
[10:21:38.469]                     }
[10:21:38.469]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.469]                   }
[10:21:38.469]                 }
[10:21:38.469]             }
[10:21:38.469]         }))
[10:21:38.469]     }, error = function(ex) {
[10:21:38.469]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.469]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.469]                 ...future.rng), started = ...future.startTime, 
[10:21:38.469]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.469]             version = "1.8"), class = "FutureResult")
[10:21:38.469]     }, finally = {
[10:21:38.469]         if (!identical(...future.workdir, getwd())) 
[10:21:38.469]             setwd(...future.workdir)
[10:21:38.469]         {
[10:21:38.469]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.469]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.469]             }
[10:21:38.469]             base::options(...future.oldOptions)
[10:21:38.469]             if (.Platform$OS.type == "windows") {
[10:21:38.469]                 old_names <- names(...future.oldEnvVars)
[10:21:38.469]                 envs <- base::Sys.getenv()
[10:21:38.469]                 names <- names(envs)
[10:21:38.469]                 common <- intersect(names, old_names)
[10:21:38.469]                 added <- setdiff(names, old_names)
[10:21:38.469]                 removed <- setdiff(old_names, names)
[10:21:38.469]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.469]                   envs[common]]
[10:21:38.469]                 NAMES <- toupper(changed)
[10:21:38.469]                 args <- list()
[10:21:38.469]                 for (kk in seq_along(NAMES)) {
[10:21:38.469]                   name <- changed[[kk]]
[10:21:38.469]                   NAME <- NAMES[[kk]]
[10:21:38.469]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.469]                     next
[10:21:38.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.469]                 }
[10:21:38.469]                 NAMES <- toupper(added)
[10:21:38.469]                 for (kk in seq_along(NAMES)) {
[10:21:38.469]                   name <- added[[kk]]
[10:21:38.469]                   NAME <- NAMES[[kk]]
[10:21:38.469]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.469]                     next
[10:21:38.469]                   args[[name]] <- ""
[10:21:38.469]                 }
[10:21:38.469]                 NAMES <- toupper(removed)
[10:21:38.469]                 for (kk in seq_along(NAMES)) {
[10:21:38.469]                   name <- removed[[kk]]
[10:21:38.469]                   NAME <- NAMES[[kk]]
[10:21:38.469]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.469]                     next
[10:21:38.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.469]                 }
[10:21:38.469]                 if (length(args) > 0) 
[10:21:38.469]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.469]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.469]             }
[10:21:38.469]             else {
[10:21:38.469]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.469]             }
[10:21:38.469]             {
[10:21:38.469]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.469]                   0L) {
[10:21:38.469]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.469]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.469]                   base::options(opts)
[10:21:38.469]                 }
[10:21:38.469]                 {
[10:21:38.469]                   {
[10:21:38.469]                     NULL
[10:21:38.469]                     RNGkind("Mersenne-Twister")
[10:21:38.469]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:38.469]                       inherits = FALSE)
[10:21:38.469]                   }
[10:21:38.469]                   options(future.plan = NULL)
[10:21:38.469]                   if (is.na(NA_character_)) 
[10:21:38.469]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.469]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.469]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.469]                     .init = FALSE)
[10:21:38.469]                 }
[10:21:38.469]             }
[10:21:38.469]         }
[10:21:38.469]     })
[10:21:38.469]     if (TRUE) {
[10:21:38.469]         base::sink(type = "output", split = FALSE)
[10:21:38.469]         if (TRUE) {
[10:21:38.469]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.469]         }
[10:21:38.469]         else {
[10:21:38.469]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.469]         }
[10:21:38.469]         base::close(...future.stdout)
[10:21:38.469]         ...future.stdout <- NULL
[10:21:38.469]     }
[10:21:38.469]     ...future.result$conditions <- ...future.conditions
[10:21:38.469]     ...future.result$finished <- base::Sys.time()
[10:21:38.469]     ...future.result
[10:21:38.469] }
[10:21:38.471] assign_globals() ...
[10:21:38.471] List of 1
[10:21:38.471]  $ x: list()
[10:21:38.471]  - attr(*, "where")=List of 1
[10:21:38.471]   ..$ x:<environment: R_EmptyEnv> 
[10:21:38.471]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:38.471]  - attr(*, "resolved")= logi TRUE
[10:21:38.471]  - attr(*, "total_size")= num 31
[10:21:38.471]  - attr(*, "already-done")= logi TRUE
[10:21:38.473] - copied ‘x’ to environment
[10:21:38.473] assign_globals() ... done
[10:21:38.474] plan(): Setting new future strategy stack:
[10:21:38.474] List of future strategies:
[10:21:38.474] 1. sequential:
[10:21:38.474]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.474]    - tweaked: FALSE
[10:21:38.474]    - call: NULL
[10:21:38.474] plan(): nbrOfWorkers() = 1
[10:21:38.475] plan(): Setting new future strategy stack:
[10:21:38.475] List of future strategies:
[10:21:38.475] 1. sequential:
[10:21:38.475]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.475]    - tweaked: FALSE
[10:21:38.475]    - call: plan(strategy)
[10:21:38.475] plan(): nbrOfWorkers() = 1
[10:21:38.475] SequentialFuture started (and completed)
[10:21:38.476] - Launch lazy future ... done
[10:21:38.476] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.476] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.476] Searching for globals...
[10:21:38.480] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[10:21:38.480] Searching for globals ... DONE
[10:21:38.481] Resolving globals: TRUE
[10:21:38.481] Resolving any globals that are futures ...
[10:21:38.481] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[10:21:38.481] Resolving any globals that are futures ... DONE
[10:21:38.481] 
[10:21:38.481] 
[10:21:38.481] getGlobalsAndPackages() ... DONE
[10:21:38.482] run() for ‘Future’ ...
[10:21:38.482] - state: ‘created’
[10:21:38.482] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:38.482] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:38.482] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:38.482]   - Field: ‘label’
[10:21:38.482]   - Field: ‘local’
[10:21:38.482]   - Field: ‘owner’
[10:21:38.483]   - Field: ‘envir’
[10:21:38.483]   - Field: ‘packages’
[10:21:38.483]   - Field: ‘gc’
[10:21:38.483]   - Field: ‘conditions’
[10:21:38.483]   - Field: ‘expr’
[10:21:38.483]   - Field: ‘uuid’
[10:21:38.483]   - Field: ‘seed’
[10:21:38.483]   - Field: ‘version’
[10:21:38.483]   - Field: ‘result’
[10:21:38.483]   - Field: ‘asynchronous’
[10:21:38.483]   - Field: ‘calls’
[10:21:38.483]   - Field: ‘globals’
[10:21:38.484]   - Field: ‘stdout’
[10:21:38.484]   - Field: ‘earlySignal’
[10:21:38.484]   - Field: ‘lazy’
[10:21:38.484]   - Field: ‘state’
[10:21:38.484] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:38.484] - Launch lazy future ...
[10:21:38.484] Packages needed by the future expression (n = 0): <none>
[10:21:38.484] Packages needed by future strategies (n = 0): <none>
[10:21:38.485] {
[10:21:38.485]     {
[10:21:38.485]         {
[10:21:38.485]             ...future.startTime <- base::Sys.time()
[10:21:38.485]             {
[10:21:38.485]                 {
[10:21:38.485]                   {
[10:21:38.485]                     base::local({
[10:21:38.485]                       has_future <- base::requireNamespace("future", 
[10:21:38.485]                         quietly = TRUE)
[10:21:38.485]                       if (has_future) {
[10:21:38.485]                         ns <- base::getNamespace("future")
[10:21:38.485]                         version <- ns[[".package"]][["version"]]
[10:21:38.485]                         if (is.null(version)) 
[10:21:38.485]                           version <- utils::packageVersion("future")
[10:21:38.485]                       }
[10:21:38.485]                       else {
[10:21:38.485]                         version <- NULL
[10:21:38.485]                       }
[10:21:38.485]                       if (!has_future || version < "1.8.0") {
[10:21:38.485]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.485]                           "", base::R.version$version.string), 
[10:21:38.485]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:38.485]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.485]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.485]                             "release", "version")], collapse = " "), 
[10:21:38.485]                           hostname = base::Sys.info()[["nodename"]])
[10:21:38.485]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.485]                           info)
[10:21:38.485]                         info <- base::paste(info, collapse = "; ")
[10:21:38.485]                         if (!has_future) {
[10:21:38.485]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.485]                             info)
[10:21:38.485]                         }
[10:21:38.485]                         else {
[10:21:38.485]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.485]                             info, version)
[10:21:38.485]                         }
[10:21:38.485]                         base::stop(msg)
[10:21:38.485]                       }
[10:21:38.485]                     })
[10:21:38.485]                   }
[10:21:38.485]                   ...future.strategy.old <- future::plan("list")
[10:21:38.485]                   options(future.plan = NULL)
[10:21:38.485]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.485]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.485]                 }
[10:21:38.485]                 ...future.workdir <- getwd()
[10:21:38.485]             }
[10:21:38.485]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.485]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.485]         }
[10:21:38.485]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.485]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.485]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.485]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.485]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.485]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.485]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.485]             base::names(...future.oldOptions))
[10:21:38.485]     }
[10:21:38.485]     if (FALSE) {
[10:21:38.485]     }
[10:21:38.485]     else {
[10:21:38.485]         if (TRUE) {
[10:21:38.485]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.485]                 open = "w")
[10:21:38.485]         }
[10:21:38.485]         else {
[10:21:38.485]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.485]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.485]         }
[10:21:38.485]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.485]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.485]             base::sink(type = "output", split = FALSE)
[10:21:38.485]             base::close(...future.stdout)
[10:21:38.485]         }, add = TRUE)
[10:21:38.485]     }
[10:21:38.485]     ...future.frame <- base::sys.nframe()
[10:21:38.485]     ...future.conditions <- base::list()
[10:21:38.485]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.485]     if (FALSE) {
[10:21:38.485]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.485]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.485]     }
[10:21:38.485]     ...future.result <- base::tryCatch({
[10:21:38.485]         base::withCallingHandlers({
[10:21:38.485]             ...future.value <- base::withVisible(base::local({
[10:21:38.485]                 x <- list(b = 2)
[10:21:38.485]                 x$a <- 1
[10:21:38.485]                 x
[10:21:38.485]             }))
[10:21:38.485]             future::FutureResult(value = ...future.value$value, 
[10:21:38.485]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.485]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.485]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.485]                     ...future.globalenv.names))
[10:21:38.485]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.485]         }, condition = base::local({
[10:21:38.485]             c <- base::c
[10:21:38.485]             inherits <- base::inherits
[10:21:38.485]             invokeRestart <- base::invokeRestart
[10:21:38.485]             length <- base::length
[10:21:38.485]             list <- base::list
[10:21:38.485]             seq.int <- base::seq.int
[10:21:38.485]             signalCondition <- base::signalCondition
[10:21:38.485]             sys.calls <- base::sys.calls
[10:21:38.485]             `[[` <- base::`[[`
[10:21:38.485]             `+` <- base::`+`
[10:21:38.485]             `<<-` <- base::`<<-`
[10:21:38.485]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.485]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.485]                   3L)]
[10:21:38.485]             }
[10:21:38.485]             function(cond) {
[10:21:38.485]                 is_error <- inherits(cond, "error")
[10:21:38.485]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.485]                   NULL)
[10:21:38.485]                 if (is_error) {
[10:21:38.485]                   sessionInformation <- function() {
[10:21:38.485]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.485]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.485]                       search = base::search(), system = base::Sys.info())
[10:21:38.485]                   }
[10:21:38.485]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.485]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.485]                     cond$call), session = sessionInformation(), 
[10:21:38.485]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.485]                   signalCondition(cond)
[10:21:38.485]                 }
[10:21:38.485]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.485]                 "immediateCondition"))) {
[10:21:38.485]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.485]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.485]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.485]                   if (TRUE && !signal) {
[10:21:38.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.485]                     {
[10:21:38.485]                       inherits <- base::inherits
[10:21:38.485]                       invokeRestart <- base::invokeRestart
[10:21:38.485]                       is.null <- base::is.null
[10:21:38.485]                       muffled <- FALSE
[10:21:38.485]                       if (inherits(cond, "message")) {
[10:21:38.485]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.485]                         if (muffled) 
[10:21:38.485]                           invokeRestart("muffleMessage")
[10:21:38.485]                       }
[10:21:38.485]                       else if (inherits(cond, "warning")) {
[10:21:38.485]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.485]                         if (muffled) 
[10:21:38.485]                           invokeRestart("muffleWarning")
[10:21:38.485]                       }
[10:21:38.485]                       else if (inherits(cond, "condition")) {
[10:21:38.485]                         if (!is.null(pattern)) {
[10:21:38.485]                           computeRestarts <- base::computeRestarts
[10:21:38.485]                           grepl <- base::grepl
[10:21:38.485]                           restarts <- computeRestarts(cond)
[10:21:38.485]                           for (restart in restarts) {
[10:21:38.485]                             name <- restart$name
[10:21:38.485]                             if (is.null(name)) 
[10:21:38.485]                               next
[10:21:38.485]                             if (!grepl(pattern, name)) 
[10:21:38.485]                               next
[10:21:38.485]                             invokeRestart(restart)
[10:21:38.485]                             muffled <- TRUE
[10:21:38.485]                             break
[10:21:38.485]                           }
[10:21:38.485]                         }
[10:21:38.485]                       }
[10:21:38.485]                       invisible(muffled)
[10:21:38.485]                     }
[10:21:38.485]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.485]                   }
[10:21:38.485]                 }
[10:21:38.485]                 else {
[10:21:38.485]                   if (TRUE) {
[10:21:38.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.485]                     {
[10:21:38.485]                       inherits <- base::inherits
[10:21:38.485]                       invokeRestart <- base::invokeRestart
[10:21:38.485]                       is.null <- base::is.null
[10:21:38.485]                       muffled <- FALSE
[10:21:38.485]                       if (inherits(cond, "message")) {
[10:21:38.485]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.485]                         if (muffled) 
[10:21:38.485]                           invokeRestart("muffleMessage")
[10:21:38.485]                       }
[10:21:38.485]                       else if (inherits(cond, "warning")) {
[10:21:38.485]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.485]                         if (muffled) 
[10:21:38.485]                           invokeRestart("muffleWarning")
[10:21:38.485]                       }
[10:21:38.485]                       else if (inherits(cond, "condition")) {
[10:21:38.485]                         if (!is.null(pattern)) {
[10:21:38.485]                           computeRestarts <- base::computeRestarts
[10:21:38.485]                           grepl <- base::grepl
[10:21:38.485]                           restarts <- computeRestarts(cond)
[10:21:38.485]                           for (restart in restarts) {
[10:21:38.485]                             name <- restart$name
[10:21:38.485]                             if (is.null(name)) 
[10:21:38.485]                               next
[10:21:38.485]                             if (!grepl(pattern, name)) 
[10:21:38.485]                               next
[10:21:38.485]                             invokeRestart(restart)
[10:21:38.485]                             muffled <- TRUE
[10:21:38.485]                             break
[10:21:38.485]                           }
[10:21:38.485]                         }
[10:21:38.485]                       }
[10:21:38.485]                       invisible(muffled)
[10:21:38.485]                     }
[10:21:38.485]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.485]                   }
[10:21:38.485]                 }
[10:21:38.485]             }
[10:21:38.485]         }))
[10:21:38.485]     }, error = function(ex) {
[10:21:38.485]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.485]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.485]                 ...future.rng), started = ...future.startTime, 
[10:21:38.485]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.485]             version = "1.8"), class = "FutureResult")
[10:21:38.485]     }, finally = {
[10:21:38.485]         if (!identical(...future.workdir, getwd())) 
[10:21:38.485]             setwd(...future.workdir)
[10:21:38.485]         {
[10:21:38.485]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.485]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.485]             }
[10:21:38.485]             base::options(...future.oldOptions)
[10:21:38.485]             if (.Platform$OS.type == "windows") {
[10:21:38.485]                 old_names <- names(...future.oldEnvVars)
[10:21:38.485]                 envs <- base::Sys.getenv()
[10:21:38.485]                 names <- names(envs)
[10:21:38.485]                 common <- intersect(names, old_names)
[10:21:38.485]                 added <- setdiff(names, old_names)
[10:21:38.485]                 removed <- setdiff(old_names, names)
[10:21:38.485]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.485]                   envs[common]]
[10:21:38.485]                 NAMES <- toupper(changed)
[10:21:38.485]                 args <- list()
[10:21:38.485]                 for (kk in seq_along(NAMES)) {
[10:21:38.485]                   name <- changed[[kk]]
[10:21:38.485]                   NAME <- NAMES[[kk]]
[10:21:38.485]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.485]                     next
[10:21:38.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.485]                 }
[10:21:38.485]                 NAMES <- toupper(added)
[10:21:38.485]                 for (kk in seq_along(NAMES)) {
[10:21:38.485]                   name <- added[[kk]]
[10:21:38.485]                   NAME <- NAMES[[kk]]
[10:21:38.485]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.485]                     next
[10:21:38.485]                   args[[name]] <- ""
[10:21:38.485]                 }
[10:21:38.485]                 NAMES <- toupper(removed)
[10:21:38.485]                 for (kk in seq_along(NAMES)) {
[10:21:38.485]                   name <- removed[[kk]]
[10:21:38.485]                   NAME <- NAMES[[kk]]
[10:21:38.485]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.485]                     next
[10:21:38.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.485]                 }
[10:21:38.485]                 if (length(args) > 0) 
[10:21:38.485]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.485]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.485]             }
[10:21:38.485]             else {
[10:21:38.485]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.485]             }
[10:21:38.485]             {
[10:21:38.485]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.485]                   0L) {
[10:21:38.485]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.485]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.485]                   base::options(opts)
[10:21:38.485]                 }
[10:21:38.485]                 {
[10:21:38.485]                   {
[10:21:38.485]                     NULL
[10:21:38.485]                     RNGkind("Mersenne-Twister")
[10:21:38.485]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:38.485]                       inherits = FALSE)
[10:21:38.485]                   }
[10:21:38.485]                   options(future.plan = NULL)
[10:21:38.485]                   if (is.na(NA_character_)) 
[10:21:38.485]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.485]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.485]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.485]                     .init = FALSE)
[10:21:38.485]                 }
[10:21:38.485]             }
[10:21:38.485]         }
[10:21:38.485]     })
[10:21:38.485]     if (TRUE) {
[10:21:38.485]         base::sink(type = "output", split = FALSE)
[10:21:38.485]         if (TRUE) {
[10:21:38.485]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.485]         }
[10:21:38.485]         else {
[10:21:38.485]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.485]         }
[10:21:38.485]         base::close(...future.stdout)
[10:21:38.485]         ...future.stdout <- NULL
[10:21:38.485]     }
[10:21:38.485]     ...future.result$conditions <- ...future.conditions
[10:21:38.485]     ...future.result$finished <- base::Sys.time()
[10:21:38.485]     ...future.result
[10:21:38.485] }
[10:21:38.486] plan(): Setting new future strategy stack:
[10:21:38.487] List of future strategies:
[10:21:38.487] 1. sequential:
[10:21:38.487]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.487]    - tweaked: FALSE
[10:21:38.487]    - call: NULL
[10:21:38.487] plan(): nbrOfWorkers() = 1
[10:21:38.488] plan(): Setting new future strategy stack:
[10:21:38.488] List of future strategies:
[10:21:38.488] 1. sequential:
[10:21:38.488]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.488]    - tweaked: FALSE
[10:21:38.488]    - call: plan(strategy)
[10:21:38.488] plan(): nbrOfWorkers() = 1
[10:21:38.488] SequentialFuture started (and completed)
[10:21:38.488] - Launch lazy future ... done
[10:21:38.489] run() for ‘SequentialFuture’ ... done
$b
[1] 2

$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.489] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.489] Searching for globals...
[10:21:38.491] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:21:38.491] Searching for globals ... DONE
[10:21:38.491] Resolving globals: TRUE
[10:21:38.491] Resolving any globals that are futures ...
[10:21:38.491] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:21:38.491] Resolving any globals that are futures ... DONE
[10:21:38.492] Resolving futures part of globals (recursively) ...
[10:21:38.492] resolve() on list ...
[10:21:38.492]  recursive: 99
[10:21:38.492]  length: 1
[10:21:38.492]  elements: ‘x’
[10:21:38.492]  length: 0 (resolved future 1)
[10:21:38.492] resolve() on list ... DONE
[10:21:38.492] - globals: [1] ‘x’
[10:21:38.492] Resolving futures part of globals (recursively) ... DONE
[10:21:38.493] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:38.493] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:38.493] - globals: [1] ‘x’
[10:21:38.493] 
[10:21:38.493] getGlobalsAndPackages() ... DONE
[10:21:38.493] run() for ‘Future’ ...
[10:21:38.493] - state: ‘created’
[10:21:38.494] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:38.494] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:38.494] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:38.494]   - Field: ‘label’
[10:21:38.494]   - Field: ‘local’
[10:21:38.494]   - Field: ‘owner’
[10:21:38.494]   - Field: ‘envir’
[10:21:38.494]   - Field: ‘packages’
[10:21:38.494]   - Field: ‘gc’
[10:21:38.495]   - Field: ‘conditions’
[10:21:38.495]   - Field: ‘expr’
[10:21:38.495]   - Field: ‘uuid’
[10:21:38.495]   - Field: ‘seed’
[10:21:38.495]   - Field: ‘version’
[10:21:38.495]   - Field: ‘result’
[10:21:38.495]   - Field: ‘asynchronous’
[10:21:38.495]   - Field: ‘calls’
[10:21:38.495]   - Field: ‘globals’
[10:21:38.495]   - Field: ‘stdout’
[10:21:38.495]   - Field: ‘earlySignal’
[10:21:38.495]   - Field: ‘lazy’
[10:21:38.496]   - Field: ‘state’
[10:21:38.496] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:38.496] - Launch lazy future ...
[10:21:38.496] Packages needed by the future expression (n = 0): <none>
[10:21:38.496] Packages needed by future strategies (n = 0): <none>
[10:21:38.496] {
[10:21:38.496]     {
[10:21:38.496]         {
[10:21:38.496]             ...future.startTime <- base::Sys.time()
[10:21:38.496]             {
[10:21:38.496]                 {
[10:21:38.496]                   {
[10:21:38.496]                     base::local({
[10:21:38.496]                       has_future <- base::requireNamespace("future", 
[10:21:38.496]                         quietly = TRUE)
[10:21:38.496]                       if (has_future) {
[10:21:38.496]                         ns <- base::getNamespace("future")
[10:21:38.496]                         version <- ns[[".package"]][["version"]]
[10:21:38.496]                         if (is.null(version)) 
[10:21:38.496]                           version <- utils::packageVersion("future")
[10:21:38.496]                       }
[10:21:38.496]                       else {
[10:21:38.496]                         version <- NULL
[10:21:38.496]                       }
[10:21:38.496]                       if (!has_future || version < "1.8.0") {
[10:21:38.496]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.496]                           "", base::R.version$version.string), 
[10:21:38.496]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:38.496]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.496]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.496]                             "release", "version")], collapse = " "), 
[10:21:38.496]                           hostname = base::Sys.info()[["nodename"]])
[10:21:38.496]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.496]                           info)
[10:21:38.496]                         info <- base::paste(info, collapse = "; ")
[10:21:38.496]                         if (!has_future) {
[10:21:38.496]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.496]                             info)
[10:21:38.496]                         }
[10:21:38.496]                         else {
[10:21:38.496]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.496]                             info, version)
[10:21:38.496]                         }
[10:21:38.496]                         base::stop(msg)
[10:21:38.496]                       }
[10:21:38.496]                     })
[10:21:38.496]                   }
[10:21:38.496]                   ...future.strategy.old <- future::plan("list")
[10:21:38.496]                   options(future.plan = NULL)
[10:21:38.496]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.496]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.496]                 }
[10:21:38.496]                 ...future.workdir <- getwd()
[10:21:38.496]             }
[10:21:38.496]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.496]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.496]         }
[10:21:38.496]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.496]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.496]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.496]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.496]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.496]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.496]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.496]             base::names(...future.oldOptions))
[10:21:38.496]     }
[10:21:38.496]     if (FALSE) {
[10:21:38.496]     }
[10:21:38.496]     else {
[10:21:38.496]         if (TRUE) {
[10:21:38.496]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.496]                 open = "w")
[10:21:38.496]         }
[10:21:38.496]         else {
[10:21:38.496]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.496]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.496]         }
[10:21:38.496]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.496]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.496]             base::sink(type = "output", split = FALSE)
[10:21:38.496]             base::close(...future.stdout)
[10:21:38.496]         }, add = TRUE)
[10:21:38.496]     }
[10:21:38.496]     ...future.frame <- base::sys.nframe()
[10:21:38.496]     ...future.conditions <- base::list()
[10:21:38.496]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.496]     if (FALSE) {
[10:21:38.496]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.496]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.496]     }
[10:21:38.496]     ...future.result <- base::tryCatch({
[10:21:38.496]         base::withCallingHandlers({
[10:21:38.496]             ...future.value <- base::withVisible(base::local({
[10:21:38.496]                 x[["a"]] <- 1
[10:21:38.496]                 x
[10:21:38.496]             }))
[10:21:38.496]             future::FutureResult(value = ...future.value$value, 
[10:21:38.496]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.496]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.496]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.496]                     ...future.globalenv.names))
[10:21:38.496]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.496]         }, condition = base::local({
[10:21:38.496]             c <- base::c
[10:21:38.496]             inherits <- base::inherits
[10:21:38.496]             invokeRestart <- base::invokeRestart
[10:21:38.496]             length <- base::length
[10:21:38.496]             list <- base::list
[10:21:38.496]             seq.int <- base::seq.int
[10:21:38.496]             signalCondition <- base::signalCondition
[10:21:38.496]             sys.calls <- base::sys.calls
[10:21:38.496]             `[[` <- base::`[[`
[10:21:38.496]             `+` <- base::`+`
[10:21:38.496]             `<<-` <- base::`<<-`
[10:21:38.496]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.496]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.496]                   3L)]
[10:21:38.496]             }
[10:21:38.496]             function(cond) {
[10:21:38.496]                 is_error <- inherits(cond, "error")
[10:21:38.496]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.496]                   NULL)
[10:21:38.496]                 if (is_error) {
[10:21:38.496]                   sessionInformation <- function() {
[10:21:38.496]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.496]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.496]                       search = base::search(), system = base::Sys.info())
[10:21:38.496]                   }
[10:21:38.496]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.496]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.496]                     cond$call), session = sessionInformation(), 
[10:21:38.496]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.496]                   signalCondition(cond)
[10:21:38.496]                 }
[10:21:38.496]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.496]                 "immediateCondition"))) {
[10:21:38.496]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.496]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.496]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.496]                   if (TRUE && !signal) {
[10:21:38.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.496]                     {
[10:21:38.496]                       inherits <- base::inherits
[10:21:38.496]                       invokeRestart <- base::invokeRestart
[10:21:38.496]                       is.null <- base::is.null
[10:21:38.496]                       muffled <- FALSE
[10:21:38.496]                       if (inherits(cond, "message")) {
[10:21:38.496]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.496]                         if (muffled) 
[10:21:38.496]                           invokeRestart("muffleMessage")
[10:21:38.496]                       }
[10:21:38.496]                       else if (inherits(cond, "warning")) {
[10:21:38.496]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.496]                         if (muffled) 
[10:21:38.496]                           invokeRestart("muffleWarning")
[10:21:38.496]                       }
[10:21:38.496]                       else if (inherits(cond, "condition")) {
[10:21:38.496]                         if (!is.null(pattern)) {
[10:21:38.496]                           computeRestarts <- base::computeRestarts
[10:21:38.496]                           grepl <- base::grepl
[10:21:38.496]                           restarts <- computeRestarts(cond)
[10:21:38.496]                           for (restart in restarts) {
[10:21:38.496]                             name <- restart$name
[10:21:38.496]                             if (is.null(name)) 
[10:21:38.496]                               next
[10:21:38.496]                             if (!grepl(pattern, name)) 
[10:21:38.496]                               next
[10:21:38.496]                             invokeRestart(restart)
[10:21:38.496]                             muffled <- TRUE
[10:21:38.496]                             break
[10:21:38.496]                           }
[10:21:38.496]                         }
[10:21:38.496]                       }
[10:21:38.496]                       invisible(muffled)
[10:21:38.496]                     }
[10:21:38.496]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.496]                   }
[10:21:38.496]                 }
[10:21:38.496]                 else {
[10:21:38.496]                   if (TRUE) {
[10:21:38.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.496]                     {
[10:21:38.496]                       inherits <- base::inherits
[10:21:38.496]                       invokeRestart <- base::invokeRestart
[10:21:38.496]                       is.null <- base::is.null
[10:21:38.496]                       muffled <- FALSE
[10:21:38.496]                       if (inherits(cond, "message")) {
[10:21:38.496]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.496]                         if (muffled) 
[10:21:38.496]                           invokeRestart("muffleMessage")
[10:21:38.496]                       }
[10:21:38.496]                       else if (inherits(cond, "warning")) {
[10:21:38.496]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.496]                         if (muffled) 
[10:21:38.496]                           invokeRestart("muffleWarning")
[10:21:38.496]                       }
[10:21:38.496]                       else if (inherits(cond, "condition")) {
[10:21:38.496]                         if (!is.null(pattern)) {
[10:21:38.496]                           computeRestarts <- base::computeRestarts
[10:21:38.496]                           grepl <- base::grepl
[10:21:38.496]                           restarts <- computeRestarts(cond)
[10:21:38.496]                           for (restart in restarts) {
[10:21:38.496]                             name <- restart$name
[10:21:38.496]                             if (is.null(name)) 
[10:21:38.496]                               next
[10:21:38.496]                             if (!grepl(pattern, name)) 
[10:21:38.496]                               next
[10:21:38.496]                             invokeRestart(restart)
[10:21:38.496]                             muffled <- TRUE
[10:21:38.496]                             break
[10:21:38.496]                           }
[10:21:38.496]                         }
[10:21:38.496]                       }
[10:21:38.496]                       invisible(muffled)
[10:21:38.496]                     }
[10:21:38.496]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.496]                   }
[10:21:38.496]                 }
[10:21:38.496]             }
[10:21:38.496]         }))
[10:21:38.496]     }, error = function(ex) {
[10:21:38.496]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.496]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.496]                 ...future.rng), started = ...future.startTime, 
[10:21:38.496]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.496]             version = "1.8"), class = "FutureResult")
[10:21:38.496]     }, finally = {
[10:21:38.496]         if (!identical(...future.workdir, getwd())) 
[10:21:38.496]             setwd(...future.workdir)
[10:21:38.496]         {
[10:21:38.496]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.496]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.496]             }
[10:21:38.496]             base::options(...future.oldOptions)
[10:21:38.496]             if (.Platform$OS.type == "windows") {
[10:21:38.496]                 old_names <- names(...future.oldEnvVars)
[10:21:38.496]                 envs <- base::Sys.getenv()
[10:21:38.496]                 names <- names(envs)
[10:21:38.496]                 common <- intersect(names, old_names)
[10:21:38.496]                 added <- setdiff(names, old_names)
[10:21:38.496]                 removed <- setdiff(old_names, names)
[10:21:38.496]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.496]                   envs[common]]
[10:21:38.496]                 NAMES <- toupper(changed)
[10:21:38.496]                 args <- list()
[10:21:38.496]                 for (kk in seq_along(NAMES)) {
[10:21:38.496]                   name <- changed[[kk]]
[10:21:38.496]                   NAME <- NAMES[[kk]]
[10:21:38.496]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.496]                     next
[10:21:38.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.496]                 }
[10:21:38.496]                 NAMES <- toupper(added)
[10:21:38.496]                 for (kk in seq_along(NAMES)) {
[10:21:38.496]                   name <- added[[kk]]
[10:21:38.496]                   NAME <- NAMES[[kk]]
[10:21:38.496]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.496]                     next
[10:21:38.496]                   args[[name]] <- ""
[10:21:38.496]                 }
[10:21:38.496]                 NAMES <- toupper(removed)
[10:21:38.496]                 for (kk in seq_along(NAMES)) {
[10:21:38.496]                   name <- removed[[kk]]
[10:21:38.496]                   NAME <- NAMES[[kk]]
[10:21:38.496]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.496]                     next
[10:21:38.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.496]                 }
[10:21:38.496]                 if (length(args) > 0) 
[10:21:38.496]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.496]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.496]             }
[10:21:38.496]             else {
[10:21:38.496]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.496]             }
[10:21:38.496]             {
[10:21:38.496]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.496]                   0L) {
[10:21:38.496]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.496]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.496]                   base::options(opts)
[10:21:38.496]                 }
[10:21:38.496]                 {
[10:21:38.496]                   {
[10:21:38.496]                     NULL
[10:21:38.496]                     RNGkind("Mersenne-Twister")
[10:21:38.496]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:38.496]                       inherits = FALSE)
[10:21:38.496]                   }
[10:21:38.496]                   options(future.plan = NULL)
[10:21:38.496]                   if (is.na(NA_character_)) 
[10:21:38.496]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.496]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.496]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.496]                     .init = FALSE)
[10:21:38.496]                 }
[10:21:38.496]             }
[10:21:38.496]         }
[10:21:38.496]     })
[10:21:38.496]     if (TRUE) {
[10:21:38.496]         base::sink(type = "output", split = FALSE)
[10:21:38.496]         if (TRUE) {
[10:21:38.496]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.496]         }
[10:21:38.496]         else {
[10:21:38.496]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.496]         }
[10:21:38.496]         base::close(...future.stdout)
[10:21:38.496]         ...future.stdout <- NULL
[10:21:38.496]     }
[10:21:38.496]     ...future.result$conditions <- ...future.conditions
[10:21:38.496]     ...future.result$finished <- base::Sys.time()
[10:21:38.496]     ...future.result
[10:21:38.496] }
[10:21:38.498] assign_globals() ...
[10:21:38.498] List of 1
[10:21:38.498]  $ x: list()
[10:21:38.498]  - attr(*, "where")=List of 1
[10:21:38.498]   ..$ x:<environment: R_EmptyEnv> 
[10:21:38.498]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:38.498]  - attr(*, "resolved")= logi TRUE
[10:21:38.498]  - attr(*, "total_size")= num 31
[10:21:38.498]  - attr(*, "already-done")= logi TRUE
[10:21:38.500] - copied ‘x’ to environment
[10:21:38.500] assign_globals() ... done
[10:21:38.501] plan(): Setting new future strategy stack:
[10:21:38.501] List of future strategies:
[10:21:38.501] 1. sequential:
[10:21:38.501]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.501]    - tweaked: FALSE
[10:21:38.501]    - call: NULL
[10:21:38.501] plan(): nbrOfWorkers() = 1
[10:21:38.502] plan(): Setting new future strategy stack:
[10:21:38.502] List of future strategies:
[10:21:38.502] 1. sequential:
[10:21:38.502]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.502]    - tweaked: FALSE
[10:21:38.502]    - call: plan(strategy)
[10:21:38.502] plan(): nbrOfWorkers() = 1
[10:21:38.503] SequentialFuture started (and completed)
[10:21:38.503] - Launch lazy future ... done
[10:21:38.503] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.503] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.503] Searching for globals...
[10:21:38.507] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:21:38.507] Searching for globals ... DONE
[10:21:38.507] Resolving globals: TRUE
[10:21:38.507] Resolving any globals that are futures ...
[10:21:38.507] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:21:38.507] Resolving any globals that are futures ... DONE
[10:21:38.508] Resolving futures part of globals (recursively) ...
[10:21:38.508] resolve() on list ...
[10:21:38.508]  recursive: 99
[10:21:38.508]  length: 1
[10:21:38.508]  elements: ‘x’
[10:21:38.508]  length: 0 (resolved future 1)
[10:21:38.508] resolve() on list ... DONE
[10:21:38.508] - globals: [1] ‘x’
[10:21:38.508] Resolving futures part of globals (recursively) ... DONE
[10:21:38.509] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:38.509] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:38.509] - globals: [1] ‘x’
[10:21:38.509] 
[10:21:38.509] getGlobalsAndPackages() ... DONE
[10:21:38.509] run() for ‘Future’ ...
[10:21:38.510] - state: ‘created’
[10:21:38.510] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:38.510] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:38.510] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:38.510]   - Field: ‘label’
[10:21:38.510]   - Field: ‘local’
[10:21:38.510]   - Field: ‘owner’
[10:21:38.510]   - Field: ‘envir’
[10:21:38.510]   - Field: ‘packages’
[10:21:38.511]   - Field: ‘gc’
[10:21:38.511]   - Field: ‘conditions’
[10:21:38.511]   - Field: ‘expr’
[10:21:38.511]   - Field: ‘uuid’
[10:21:38.511]   - Field: ‘seed’
[10:21:38.511]   - Field: ‘version’
[10:21:38.511]   - Field: ‘result’
[10:21:38.511]   - Field: ‘asynchronous’
[10:21:38.511]   - Field: ‘calls’
[10:21:38.511]   - Field: ‘globals’
[10:21:38.511]   - Field: ‘stdout’
[10:21:38.512]   - Field: ‘earlySignal’
[10:21:38.512]   - Field: ‘lazy’
[10:21:38.512]   - Field: ‘state’
[10:21:38.512] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:38.512] - Launch lazy future ...
[10:21:38.512] Packages needed by the future expression (n = 0): <none>
[10:21:38.512] Packages needed by future strategies (n = 0): <none>
[10:21:38.513] {
[10:21:38.513]     {
[10:21:38.513]         {
[10:21:38.513]             ...future.startTime <- base::Sys.time()
[10:21:38.513]             {
[10:21:38.513]                 {
[10:21:38.513]                   {
[10:21:38.513]                     base::local({
[10:21:38.513]                       has_future <- base::requireNamespace("future", 
[10:21:38.513]                         quietly = TRUE)
[10:21:38.513]                       if (has_future) {
[10:21:38.513]                         ns <- base::getNamespace("future")
[10:21:38.513]                         version <- ns[[".package"]][["version"]]
[10:21:38.513]                         if (is.null(version)) 
[10:21:38.513]                           version <- utils::packageVersion("future")
[10:21:38.513]                       }
[10:21:38.513]                       else {
[10:21:38.513]                         version <- NULL
[10:21:38.513]                       }
[10:21:38.513]                       if (!has_future || version < "1.8.0") {
[10:21:38.513]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.513]                           "", base::R.version$version.string), 
[10:21:38.513]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:38.513]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.513]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.513]                             "release", "version")], collapse = " "), 
[10:21:38.513]                           hostname = base::Sys.info()[["nodename"]])
[10:21:38.513]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.513]                           info)
[10:21:38.513]                         info <- base::paste(info, collapse = "; ")
[10:21:38.513]                         if (!has_future) {
[10:21:38.513]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.513]                             info)
[10:21:38.513]                         }
[10:21:38.513]                         else {
[10:21:38.513]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.513]                             info, version)
[10:21:38.513]                         }
[10:21:38.513]                         base::stop(msg)
[10:21:38.513]                       }
[10:21:38.513]                     })
[10:21:38.513]                   }
[10:21:38.513]                   ...future.strategy.old <- future::plan("list")
[10:21:38.513]                   options(future.plan = NULL)
[10:21:38.513]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.513]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.513]                 }
[10:21:38.513]                 ...future.workdir <- getwd()
[10:21:38.513]             }
[10:21:38.513]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.513]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.513]         }
[10:21:38.513]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.513]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.513]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.513]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.513]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.513]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.513]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.513]             base::names(...future.oldOptions))
[10:21:38.513]     }
[10:21:38.513]     if (FALSE) {
[10:21:38.513]     }
[10:21:38.513]     else {
[10:21:38.513]         if (TRUE) {
[10:21:38.513]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.513]                 open = "w")
[10:21:38.513]         }
[10:21:38.513]         else {
[10:21:38.513]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.513]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.513]         }
[10:21:38.513]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.513]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.513]             base::sink(type = "output", split = FALSE)
[10:21:38.513]             base::close(...future.stdout)
[10:21:38.513]         }, add = TRUE)
[10:21:38.513]     }
[10:21:38.513]     ...future.frame <- base::sys.nframe()
[10:21:38.513]     ...future.conditions <- base::list()
[10:21:38.513]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.513]     if (FALSE) {
[10:21:38.513]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.513]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.513]     }
[10:21:38.513]     ...future.result <- base::tryCatch({
[10:21:38.513]         base::withCallingHandlers({
[10:21:38.513]             ...future.value <- base::withVisible(base::local({
[10:21:38.513]                 x[["a"]] <- 1
[10:21:38.513]                 x
[10:21:38.513]             }))
[10:21:38.513]             future::FutureResult(value = ...future.value$value, 
[10:21:38.513]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.513]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.513]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.513]                     ...future.globalenv.names))
[10:21:38.513]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.513]         }, condition = base::local({
[10:21:38.513]             c <- base::c
[10:21:38.513]             inherits <- base::inherits
[10:21:38.513]             invokeRestart <- base::invokeRestart
[10:21:38.513]             length <- base::length
[10:21:38.513]             list <- base::list
[10:21:38.513]             seq.int <- base::seq.int
[10:21:38.513]             signalCondition <- base::signalCondition
[10:21:38.513]             sys.calls <- base::sys.calls
[10:21:38.513]             `[[` <- base::`[[`
[10:21:38.513]             `+` <- base::`+`
[10:21:38.513]             `<<-` <- base::`<<-`
[10:21:38.513]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.513]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.513]                   3L)]
[10:21:38.513]             }
[10:21:38.513]             function(cond) {
[10:21:38.513]                 is_error <- inherits(cond, "error")
[10:21:38.513]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.513]                   NULL)
[10:21:38.513]                 if (is_error) {
[10:21:38.513]                   sessionInformation <- function() {
[10:21:38.513]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.513]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.513]                       search = base::search(), system = base::Sys.info())
[10:21:38.513]                   }
[10:21:38.513]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.513]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.513]                     cond$call), session = sessionInformation(), 
[10:21:38.513]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.513]                   signalCondition(cond)
[10:21:38.513]                 }
[10:21:38.513]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.513]                 "immediateCondition"))) {
[10:21:38.513]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.513]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.513]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.513]                   if (TRUE && !signal) {
[10:21:38.513]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.513]                     {
[10:21:38.513]                       inherits <- base::inherits
[10:21:38.513]                       invokeRestart <- base::invokeRestart
[10:21:38.513]                       is.null <- base::is.null
[10:21:38.513]                       muffled <- FALSE
[10:21:38.513]                       if (inherits(cond, "message")) {
[10:21:38.513]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.513]                         if (muffled) 
[10:21:38.513]                           invokeRestart("muffleMessage")
[10:21:38.513]                       }
[10:21:38.513]                       else if (inherits(cond, "warning")) {
[10:21:38.513]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.513]                         if (muffled) 
[10:21:38.513]                           invokeRestart("muffleWarning")
[10:21:38.513]                       }
[10:21:38.513]                       else if (inherits(cond, "condition")) {
[10:21:38.513]                         if (!is.null(pattern)) {
[10:21:38.513]                           computeRestarts <- base::computeRestarts
[10:21:38.513]                           grepl <- base::grepl
[10:21:38.513]                           restarts <- computeRestarts(cond)
[10:21:38.513]                           for (restart in restarts) {
[10:21:38.513]                             name <- restart$name
[10:21:38.513]                             if (is.null(name)) 
[10:21:38.513]                               next
[10:21:38.513]                             if (!grepl(pattern, name)) 
[10:21:38.513]                               next
[10:21:38.513]                             invokeRestart(restart)
[10:21:38.513]                             muffled <- TRUE
[10:21:38.513]                             break
[10:21:38.513]                           }
[10:21:38.513]                         }
[10:21:38.513]                       }
[10:21:38.513]                       invisible(muffled)
[10:21:38.513]                     }
[10:21:38.513]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.513]                   }
[10:21:38.513]                 }
[10:21:38.513]                 else {
[10:21:38.513]                   if (TRUE) {
[10:21:38.513]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.513]                     {
[10:21:38.513]                       inherits <- base::inherits
[10:21:38.513]                       invokeRestart <- base::invokeRestart
[10:21:38.513]                       is.null <- base::is.null
[10:21:38.513]                       muffled <- FALSE
[10:21:38.513]                       if (inherits(cond, "message")) {
[10:21:38.513]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.513]                         if (muffled) 
[10:21:38.513]                           invokeRestart("muffleMessage")
[10:21:38.513]                       }
[10:21:38.513]                       else if (inherits(cond, "warning")) {
[10:21:38.513]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.513]                         if (muffled) 
[10:21:38.513]                           invokeRestart("muffleWarning")
[10:21:38.513]                       }
[10:21:38.513]                       else if (inherits(cond, "condition")) {
[10:21:38.513]                         if (!is.null(pattern)) {
[10:21:38.513]                           computeRestarts <- base::computeRestarts
[10:21:38.513]                           grepl <- base::grepl
[10:21:38.513]                           restarts <- computeRestarts(cond)
[10:21:38.513]                           for (restart in restarts) {
[10:21:38.513]                             name <- restart$name
[10:21:38.513]                             if (is.null(name)) 
[10:21:38.513]                               next
[10:21:38.513]                             if (!grepl(pattern, name)) 
[10:21:38.513]                               next
[10:21:38.513]                             invokeRestart(restart)
[10:21:38.513]                             muffled <- TRUE
[10:21:38.513]                             break
[10:21:38.513]                           }
[10:21:38.513]                         }
[10:21:38.513]                       }
[10:21:38.513]                       invisible(muffled)
[10:21:38.513]                     }
[10:21:38.513]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.513]                   }
[10:21:38.513]                 }
[10:21:38.513]             }
[10:21:38.513]         }))
[10:21:38.513]     }, error = function(ex) {
[10:21:38.513]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.513]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.513]                 ...future.rng), started = ...future.startTime, 
[10:21:38.513]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.513]             version = "1.8"), class = "FutureResult")
[10:21:38.513]     }, finally = {
[10:21:38.513]         if (!identical(...future.workdir, getwd())) 
[10:21:38.513]             setwd(...future.workdir)
[10:21:38.513]         {
[10:21:38.513]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.513]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.513]             }
[10:21:38.513]             base::options(...future.oldOptions)
[10:21:38.513]             if (.Platform$OS.type == "windows") {
[10:21:38.513]                 old_names <- names(...future.oldEnvVars)
[10:21:38.513]                 envs <- base::Sys.getenv()
[10:21:38.513]                 names <- names(envs)
[10:21:38.513]                 common <- intersect(names, old_names)
[10:21:38.513]                 added <- setdiff(names, old_names)
[10:21:38.513]                 removed <- setdiff(old_names, names)
[10:21:38.513]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.513]                   envs[common]]
[10:21:38.513]                 NAMES <- toupper(changed)
[10:21:38.513]                 args <- list()
[10:21:38.513]                 for (kk in seq_along(NAMES)) {
[10:21:38.513]                   name <- changed[[kk]]
[10:21:38.513]                   NAME <- NAMES[[kk]]
[10:21:38.513]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.513]                     next
[10:21:38.513]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.513]                 }
[10:21:38.513]                 NAMES <- toupper(added)
[10:21:38.513]                 for (kk in seq_along(NAMES)) {
[10:21:38.513]                   name <- added[[kk]]
[10:21:38.513]                   NAME <- NAMES[[kk]]
[10:21:38.513]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.513]                     next
[10:21:38.513]                   args[[name]] <- ""
[10:21:38.513]                 }
[10:21:38.513]                 NAMES <- toupper(removed)
[10:21:38.513]                 for (kk in seq_along(NAMES)) {
[10:21:38.513]                   name <- removed[[kk]]
[10:21:38.513]                   NAME <- NAMES[[kk]]
[10:21:38.513]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.513]                     next
[10:21:38.513]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.513]                 }
[10:21:38.513]                 if (length(args) > 0) 
[10:21:38.513]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.513]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.513]             }
[10:21:38.513]             else {
[10:21:38.513]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.513]             }
[10:21:38.513]             {
[10:21:38.513]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.513]                   0L) {
[10:21:38.513]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.513]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.513]                   base::options(opts)
[10:21:38.513]                 }
[10:21:38.513]                 {
[10:21:38.513]                   {
[10:21:38.513]                     NULL
[10:21:38.513]                     RNGkind("Mersenne-Twister")
[10:21:38.513]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:38.513]                       inherits = FALSE)
[10:21:38.513]                   }
[10:21:38.513]                   options(future.plan = NULL)
[10:21:38.513]                   if (is.na(NA_character_)) 
[10:21:38.513]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.513]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.513]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.513]                     .init = FALSE)
[10:21:38.513]                 }
[10:21:38.513]             }
[10:21:38.513]         }
[10:21:38.513]     })
[10:21:38.513]     if (TRUE) {
[10:21:38.513]         base::sink(type = "output", split = FALSE)
[10:21:38.513]         if (TRUE) {
[10:21:38.513]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.513]         }
[10:21:38.513]         else {
[10:21:38.513]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.513]         }
[10:21:38.513]         base::close(...future.stdout)
[10:21:38.513]         ...future.stdout <- NULL
[10:21:38.513]     }
[10:21:38.513]     ...future.result$conditions <- ...future.conditions
[10:21:38.513]     ...future.result$finished <- base::Sys.time()
[10:21:38.513]     ...future.result
[10:21:38.513] }
[10:21:38.514] assign_globals() ...
[10:21:38.514] List of 1
[10:21:38.514]  $ x: list()
[10:21:38.514]  - attr(*, "where")=List of 1
[10:21:38.514]   ..$ x:<environment: R_EmptyEnv> 
[10:21:38.514]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:38.514]  - attr(*, "resolved")= logi TRUE
[10:21:38.514]  - attr(*, "total_size")= num 31
[10:21:38.514]  - attr(*, "already-done")= logi TRUE
[10:21:38.516] - copied ‘x’ to environment
[10:21:38.517] assign_globals() ... done
[10:21:38.517] plan(): Setting new future strategy stack:
[10:21:38.517] List of future strategies:
[10:21:38.517] 1. sequential:
[10:21:38.517]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.517]    - tweaked: FALSE
[10:21:38.517]    - call: NULL
[10:21:38.517] plan(): nbrOfWorkers() = 1
[10:21:38.518] plan(): Setting new future strategy stack:
[10:21:38.518] List of future strategies:
[10:21:38.518] 1. sequential:
[10:21:38.518]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.518]    - tweaked: FALSE
[10:21:38.518]    - call: plan(strategy)
[10:21:38.519] plan(): nbrOfWorkers() = 1
[10:21:38.519] SequentialFuture started (and completed)
[10:21:38.519] - Launch lazy future ... done
[10:21:38.519] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.519] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.520] Searching for globals...
[10:21:38.521] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:21:38.521] Searching for globals ... DONE
[10:21:38.522] Resolving globals: TRUE
[10:21:38.522] Resolving any globals that are futures ...
[10:21:38.522] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:21:38.522] Resolving any globals that are futures ... DONE
[10:21:38.522] Resolving futures part of globals (recursively) ...
[10:21:38.522] resolve() on list ...
[10:21:38.522]  recursive: 99
[10:21:38.523]  length: 1
[10:21:38.523]  elements: ‘x’
[10:21:38.523]  length: 0 (resolved future 1)
[10:21:38.523] resolve() on list ... DONE
[10:21:38.523] - globals: [1] ‘x’
[10:21:38.523] Resolving futures part of globals (recursively) ... DONE
[10:21:38.523] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:38.523] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:38.524] - globals: [1] ‘x’
[10:21:38.524] 
[10:21:38.524] getGlobalsAndPackages() ... DONE
[10:21:38.524] run() for ‘Future’ ...
[10:21:38.524] - state: ‘created’
[10:21:38.524] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:38.524] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:38.525] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:38.525]   - Field: ‘label’
[10:21:38.525]   - Field: ‘local’
[10:21:38.525]   - Field: ‘owner’
[10:21:38.525]   - Field: ‘envir’
[10:21:38.525]   - Field: ‘packages’
[10:21:38.525]   - Field: ‘gc’
[10:21:38.525]   - Field: ‘conditions’
[10:21:38.525]   - Field: ‘expr’
[10:21:38.525]   - Field: ‘uuid’
[10:21:38.525]   - Field: ‘seed’
[10:21:38.526]   - Field: ‘version’
[10:21:38.526]   - Field: ‘result’
[10:21:38.526]   - Field: ‘asynchronous’
[10:21:38.526]   - Field: ‘calls’
[10:21:38.526]   - Field: ‘globals’
[10:21:38.526]   - Field: ‘stdout’
[10:21:38.526]   - Field: ‘earlySignal’
[10:21:38.526]   - Field: ‘lazy’
[10:21:38.526]   - Field: ‘state’
[10:21:38.526] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:38.526] - Launch lazy future ...
[10:21:38.527] Packages needed by the future expression (n = 0): <none>
[10:21:38.527] Packages needed by future strategies (n = 0): <none>
[10:21:38.527] {
[10:21:38.527]     {
[10:21:38.527]         {
[10:21:38.527]             ...future.startTime <- base::Sys.time()
[10:21:38.527]             {
[10:21:38.527]                 {
[10:21:38.527]                   {
[10:21:38.527]                     base::local({
[10:21:38.527]                       has_future <- base::requireNamespace("future", 
[10:21:38.527]                         quietly = TRUE)
[10:21:38.527]                       if (has_future) {
[10:21:38.527]                         ns <- base::getNamespace("future")
[10:21:38.527]                         version <- ns[[".package"]][["version"]]
[10:21:38.527]                         if (is.null(version)) 
[10:21:38.527]                           version <- utils::packageVersion("future")
[10:21:38.527]                       }
[10:21:38.527]                       else {
[10:21:38.527]                         version <- NULL
[10:21:38.527]                       }
[10:21:38.527]                       if (!has_future || version < "1.8.0") {
[10:21:38.527]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.527]                           "", base::R.version$version.string), 
[10:21:38.527]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:38.527]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.527]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.527]                             "release", "version")], collapse = " "), 
[10:21:38.527]                           hostname = base::Sys.info()[["nodename"]])
[10:21:38.527]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.527]                           info)
[10:21:38.527]                         info <- base::paste(info, collapse = "; ")
[10:21:38.527]                         if (!has_future) {
[10:21:38.527]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.527]                             info)
[10:21:38.527]                         }
[10:21:38.527]                         else {
[10:21:38.527]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.527]                             info, version)
[10:21:38.527]                         }
[10:21:38.527]                         base::stop(msg)
[10:21:38.527]                       }
[10:21:38.527]                     })
[10:21:38.527]                   }
[10:21:38.527]                   ...future.strategy.old <- future::plan("list")
[10:21:38.527]                   options(future.plan = NULL)
[10:21:38.527]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.527]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.527]                 }
[10:21:38.527]                 ...future.workdir <- getwd()
[10:21:38.527]             }
[10:21:38.527]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.527]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.527]         }
[10:21:38.527]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.527]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.527]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.527]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.527]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.527]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.527]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.527]             base::names(...future.oldOptions))
[10:21:38.527]     }
[10:21:38.527]     if (FALSE) {
[10:21:38.527]     }
[10:21:38.527]     else {
[10:21:38.527]         if (TRUE) {
[10:21:38.527]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.527]                 open = "w")
[10:21:38.527]         }
[10:21:38.527]         else {
[10:21:38.527]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.527]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.527]         }
[10:21:38.527]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.527]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.527]             base::sink(type = "output", split = FALSE)
[10:21:38.527]             base::close(...future.stdout)
[10:21:38.527]         }, add = TRUE)
[10:21:38.527]     }
[10:21:38.527]     ...future.frame <- base::sys.nframe()
[10:21:38.527]     ...future.conditions <- base::list()
[10:21:38.527]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.527]     if (FALSE) {
[10:21:38.527]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.527]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.527]     }
[10:21:38.527]     ...future.result <- base::tryCatch({
[10:21:38.527]         base::withCallingHandlers({
[10:21:38.527]             ...future.value <- base::withVisible(base::local({
[10:21:38.527]                 x[["a"]] <- 1
[10:21:38.527]                 x
[10:21:38.527]             }))
[10:21:38.527]             future::FutureResult(value = ...future.value$value, 
[10:21:38.527]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.527]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.527]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.527]                     ...future.globalenv.names))
[10:21:38.527]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.527]         }, condition = base::local({
[10:21:38.527]             c <- base::c
[10:21:38.527]             inherits <- base::inherits
[10:21:38.527]             invokeRestart <- base::invokeRestart
[10:21:38.527]             length <- base::length
[10:21:38.527]             list <- base::list
[10:21:38.527]             seq.int <- base::seq.int
[10:21:38.527]             signalCondition <- base::signalCondition
[10:21:38.527]             sys.calls <- base::sys.calls
[10:21:38.527]             `[[` <- base::`[[`
[10:21:38.527]             `+` <- base::`+`
[10:21:38.527]             `<<-` <- base::`<<-`
[10:21:38.527]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.527]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.527]                   3L)]
[10:21:38.527]             }
[10:21:38.527]             function(cond) {
[10:21:38.527]                 is_error <- inherits(cond, "error")
[10:21:38.527]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.527]                   NULL)
[10:21:38.527]                 if (is_error) {
[10:21:38.527]                   sessionInformation <- function() {
[10:21:38.527]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.527]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.527]                       search = base::search(), system = base::Sys.info())
[10:21:38.527]                   }
[10:21:38.527]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.527]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.527]                     cond$call), session = sessionInformation(), 
[10:21:38.527]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.527]                   signalCondition(cond)
[10:21:38.527]                 }
[10:21:38.527]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.527]                 "immediateCondition"))) {
[10:21:38.527]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.527]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.527]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.527]                   if (TRUE && !signal) {
[10:21:38.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.527]                     {
[10:21:38.527]                       inherits <- base::inherits
[10:21:38.527]                       invokeRestart <- base::invokeRestart
[10:21:38.527]                       is.null <- base::is.null
[10:21:38.527]                       muffled <- FALSE
[10:21:38.527]                       if (inherits(cond, "message")) {
[10:21:38.527]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.527]                         if (muffled) 
[10:21:38.527]                           invokeRestart("muffleMessage")
[10:21:38.527]                       }
[10:21:38.527]                       else if (inherits(cond, "warning")) {
[10:21:38.527]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.527]                         if (muffled) 
[10:21:38.527]                           invokeRestart("muffleWarning")
[10:21:38.527]                       }
[10:21:38.527]                       else if (inherits(cond, "condition")) {
[10:21:38.527]                         if (!is.null(pattern)) {
[10:21:38.527]                           computeRestarts <- base::computeRestarts
[10:21:38.527]                           grepl <- base::grepl
[10:21:38.527]                           restarts <- computeRestarts(cond)
[10:21:38.527]                           for (restart in restarts) {
[10:21:38.527]                             name <- restart$name
[10:21:38.527]                             if (is.null(name)) 
[10:21:38.527]                               next
[10:21:38.527]                             if (!grepl(pattern, name)) 
[10:21:38.527]                               next
[10:21:38.527]                             invokeRestart(restart)
[10:21:38.527]                             muffled <- TRUE
[10:21:38.527]                             break
[10:21:38.527]                           }
[10:21:38.527]                         }
[10:21:38.527]                       }
[10:21:38.527]                       invisible(muffled)
[10:21:38.527]                     }
[10:21:38.527]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.527]                   }
[10:21:38.527]                 }
[10:21:38.527]                 else {
[10:21:38.527]                   if (TRUE) {
[10:21:38.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.527]                     {
[10:21:38.527]                       inherits <- base::inherits
[10:21:38.527]                       invokeRestart <- base::invokeRestart
[10:21:38.527]                       is.null <- base::is.null
[10:21:38.527]                       muffled <- FALSE
[10:21:38.527]                       if (inherits(cond, "message")) {
[10:21:38.527]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.527]                         if (muffled) 
[10:21:38.527]                           invokeRestart("muffleMessage")
[10:21:38.527]                       }
[10:21:38.527]                       else if (inherits(cond, "warning")) {
[10:21:38.527]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.527]                         if (muffled) 
[10:21:38.527]                           invokeRestart("muffleWarning")
[10:21:38.527]                       }
[10:21:38.527]                       else if (inherits(cond, "condition")) {
[10:21:38.527]                         if (!is.null(pattern)) {
[10:21:38.527]                           computeRestarts <- base::computeRestarts
[10:21:38.527]                           grepl <- base::grepl
[10:21:38.527]                           restarts <- computeRestarts(cond)
[10:21:38.527]                           for (restart in restarts) {
[10:21:38.527]                             name <- restart$name
[10:21:38.527]                             if (is.null(name)) 
[10:21:38.527]                               next
[10:21:38.527]                             if (!grepl(pattern, name)) 
[10:21:38.527]                               next
[10:21:38.527]                             invokeRestart(restart)
[10:21:38.527]                             muffled <- TRUE
[10:21:38.527]                             break
[10:21:38.527]                           }
[10:21:38.527]                         }
[10:21:38.527]                       }
[10:21:38.527]                       invisible(muffled)
[10:21:38.527]                     }
[10:21:38.527]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.527]                   }
[10:21:38.527]                 }
[10:21:38.527]             }
[10:21:38.527]         }))
[10:21:38.527]     }, error = function(ex) {
[10:21:38.527]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.527]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.527]                 ...future.rng), started = ...future.startTime, 
[10:21:38.527]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.527]             version = "1.8"), class = "FutureResult")
[10:21:38.527]     }, finally = {
[10:21:38.527]         if (!identical(...future.workdir, getwd())) 
[10:21:38.527]             setwd(...future.workdir)
[10:21:38.527]         {
[10:21:38.527]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.527]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.527]             }
[10:21:38.527]             base::options(...future.oldOptions)
[10:21:38.527]             if (.Platform$OS.type == "windows") {
[10:21:38.527]                 old_names <- names(...future.oldEnvVars)
[10:21:38.527]                 envs <- base::Sys.getenv()
[10:21:38.527]                 names <- names(envs)
[10:21:38.527]                 common <- intersect(names, old_names)
[10:21:38.527]                 added <- setdiff(names, old_names)
[10:21:38.527]                 removed <- setdiff(old_names, names)
[10:21:38.527]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.527]                   envs[common]]
[10:21:38.527]                 NAMES <- toupper(changed)
[10:21:38.527]                 args <- list()
[10:21:38.527]                 for (kk in seq_along(NAMES)) {
[10:21:38.527]                   name <- changed[[kk]]
[10:21:38.527]                   NAME <- NAMES[[kk]]
[10:21:38.527]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.527]                     next
[10:21:38.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.527]                 }
[10:21:38.527]                 NAMES <- toupper(added)
[10:21:38.527]                 for (kk in seq_along(NAMES)) {
[10:21:38.527]                   name <- added[[kk]]
[10:21:38.527]                   NAME <- NAMES[[kk]]
[10:21:38.527]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.527]                     next
[10:21:38.527]                   args[[name]] <- ""
[10:21:38.527]                 }
[10:21:38.527]                 NAMES <- toupper(removed)
[10:21:38.527]                 for (kk in seq_along(NAMES)) {
[10:21:38.527]                   name <- removed[[kk]]
[10:21:38.527]                   NAME <- NAMES[[kk]]
[10:21:38.527]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.527]                     next
[10:21:38.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.527]                 }
[10:21:38.527]                 if (length(args) > 0) 
[10:21:38.527]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.527]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.527]             }
[10:21:38.527]             else {
[10:21:38.527]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.527]             }
[10:21:38.527]             {
[10:21:38.527]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.527]                   0L) {
[10:21:38.527]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.527]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.527]                   base::options(opts)
[10:21:38.527]                 }
[10:21:38.527]                 {
[10:21:38.527]                   {
[10:21:38.527]                     NULL
[10:21:38.527]                     RNGkind("Mersenne-Twister")
[10:21:38.527]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:38.527]                       inherits = FALSE)
[10:21:38.527]                   }
[10:21:38.527]                   options(future.plan = NULL)
[10:21:38.527]                   if (is.na(NA_character_)) 
[10:21:38.527]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.527]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.527]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.527]                     .init = FALSE)
[10:21:38.527]                 }
[10:21:38.527]             }
[10:21:38.527]         }
[10:21:38.527]     })
[10:21:38.527]     if (TRUE) {
[10:21:38.527]         base::sink(type = "output", split = FALSE)
[10:21:38.527]         if (TRUE) {
[10:21:38.527]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.527]         }
[10:21:38.527]         else {
[10:21:38.527]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.527]         }
[10:21:38.527]         base::close(...future.stdout)
[10:21:38.527]         ...future.stdout <- NULL
[10:21:38.527]     }
[10:21:38.527]     ...future.result$conditions <- ...future.conditions
[10:21:38.527]     ...future.result$finished <- base::Sys.time()
[10:21:38.527]     ...future.result
[10:21:38.527] }
[10:21:38.529] assign_globals() ...
[10:21:38.529] List of 1
[10:21:38.529]  $ x: list()
[10:21:38.529]  - attr(*, "where")=List of 1
[10:21:38.529]   ..$ x:<environment: R_EmptyEnv> 
[10:21:38.529]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:38.529]  - attr(*, "resolved")= logi TRUE
[10:21:38.529]  - attr(*, "total_size")= num 31
[10:21:38.529]  - attr(*, "already-done")= logi TRUE
[10:21:38.531] - copied ‘x’ to environment
[10:21:38.531] assign_globals() ... done
[10:21:38.531] plan(): Setting new future strategy stack:
[10:21:38.531] List of future strategies:
[10:21:38.531] 1. sequential:
[10:21:38.531]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.531]    - tweaked: FALSE
[10:21:38.531]    - call: NULL
[10:21:38.532] plan(): nbrOfWorkers() = 1
[10:21:38.534] plan(): Setting new future strategy stack:
[10:21:38.534] List of future strategies:
[10:21:38.534] 1. sequential:
[10:21:38.534]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.534]    - tweaked: FALSE
[10:21:38.534]    - call: plan(strategy)
[10:21:38.535] plan(): nbrOfWorkers() = 1
[10:21:38.535] SequentialFuture started (and completed)
[10:21:38.535] - Launch lazy future ... done
[10:21:38.535] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.535] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.536] Searching for globals...
[10:21:38.538] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:21:38.538] Searching for globals ... DONE
[10:21:38.538] Resolving globals: TRUE
[10:21:38.538] Resolving any globals that are futures ...
[10:21:38.538] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:21:38.538] Resolving any globals that are futures ... DONE
[10:21:38.538] Resolving futures part of globals (recursively) ...
[10:21:38.539] resolve() on list ...
[10:21:38.539]  recursive: 99
[10:21:38.539]  length: 1
[10:21:38.539]  elements: ‘x’
[10:21:38.539]  length: 0 (resolved future 1)
[10:21:38.539] resolve() on list ... DONE
[10:21:38.539] - globals: [1] ‘x’
[10:21:38.539] Resolving futures part of globals (recursively) ... DONE
[10:21:38.539] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:38.540] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:38.540] - globals: [1] ‘x’
[10:21:38.540] 
[10:21:38.540] getGlobalsAndPackages() ... DONE
[10:21:38.540] run() for ‘Future’ ...
[10:21:38.540] - state: ‘created’
[10:21:38.541] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:38.541] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:38.541] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:38.541]   - Field: ‘label’
[10:21:38.541]   - Field: ‘local’
[10:21:38.541]   - Field: ‘owner’
[10:21:38.541]   - Field: ‘envir’
[10:21:38.541]   - Field: ‘packages’
[10:21:38.541]   - Field: ‘gc’
[10:21:38.541]   - Field: ‘conditions’
[10:21:38.542]   - Field: ‘expr’
[10:21:38.542]   - Field: ‘uuid’
[10:21:38.542]   - Field: ‘seed’
[10:21:38.542]   - Field: ‘version’
[10:21:38.542]   - Field: ‘result’
[10:21:38.542]   - Field: ‘asynchronous’
[10:21:38.542]   - Field: ‘calls’
[10:21:38.542]   - Field: ‘globals’
[10:21:38.542]   - Field: ‘stdout’
[10:21:38.542]   - Field: ‘earlySignal’
[10:21:38.542]   - Field: ‘lazy’
[10:21:38.543]   - Field: ‘state’
[10:21:38.543] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:38.543] - Launch lazy future ...
[10:21:38.543] Packages needed by the future expression (n = 0): <none>
[10:21:38.543] Packages needed by future strategies (n = 0): <none>
[10:21:38.543] {
[10:21:38.543]     {
[10:21:38.543]         {
[10:21:38.543]             ...future.startTime <- base::Sys.time()
[10:21:38.543]             {
[10:21:38.543]                 {
[10:21:38.543]                   {
[10:21:38.543]                     base::local({
[10:21:38.543]                       has_future <- base::requireNamespace("future", 
[10:21:38.543]                         quietly = TRUE)
[10:21:38.543]                       if (has_future) {
[10:21:38.543]                         ns <- base::getNamespace("future")
[10:21:38.543]                         version <- ns[[".package"]][["version"]]
[10:21:38.543]                         if (is.null(version)) 
[10:21:38.543]                           version <- utils::packageVersion("future")
[10:21:38.543]                       }
[10:21:38.543]                       else {
[10:21:38.543]                         version <- NULL
[10:21:38.543]                       }
[10:21:38.543]                       if (!has_future || version < "1.8.0") {
[10:21:38.543]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.543]                           "", base::R.version$version.string), 
[10:21:38.543]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:38.543]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.543]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.543]                             "release", "version")], collapse = " "), 
[10:21:38.543]                           hostname = base::Sys.info()[["nodename"]])
[10:21:38.543]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.543]                           info)
[10:21:38.543]                         info <- base::paste(info, collapse = "; ")
[10:21:38.543]                         if (!has_future) {
[10:21:38.543]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.543]                             info)
[10:21:38.543]                         }
[10:21:38.543]                         else {
[10:21:38.543]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.543]                             info, version)
[10:21:38.543]                         }
[10:21:38.543]                         base::stop(msg)
[10:21:38.543]                       }
[10:21:38.543]                     })
[10:21:38.543]                   }
[10:21:38.543]                   ...future.strategy.old <- future::plan("list")
[10:21:38.543]                   options(future.plan = NULL)
[10:21:38.543]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.543]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.543]                 }
[10:21:38.543]                 ...future.workdir <- getwd()
[10:21:38.543]             }
[10:21:38.543]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.543]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.543]         }
[10:21:38.543]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.543]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.543]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.543]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.543]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.543]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.543]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.543]             base::names(...future.oldOptions))
[10:21:38.543]     }
[10:21:38.543]     if (FALSE) {
[10:21:38.543]     }
[10:21:38.543]     else {
[10:21:38.543]         if (TRUE) {
[10:21:38.543]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.543]                 open = "w")
[10:21:38.543]         }
[10:21:38.543]         else {
[10:21:38.543]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.543]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.543]         }
[10:21:38.543]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.543]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.543]             base::sink(type = "output", split = FALSE)
[10:21:38.543]             base::close(...future.stdout)
[10:21:38.543]         }, add = TRUE)
[10:21:38.543]     }
[10:21:38.543]     ...future.frame <- base::sys.nframe()
[10:21:38.543]     ...future.conditions <- base::list()
[10:21:38.543]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.543]     if (FALSE) {
[10:21:38.543]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.543]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.543]     }
[10:21:38.543]     ...future.result <- base::tryCatch({
[10:21:38.543]         base::withCallingHandlers({
[10:21:38.543]             ...future.value <- base::withVisible(base::local({
[10:21:38.543]                 x["a"] <- list(1)
[10:21:38.543]                 x
[10:21:38.543]             }))
[10:21:38.543]             future::FutureResult(value = ...future.value$value, 
[10:21:38.543]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.543]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.543]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.543]                     ...future.globalenv.names))
[10:21:38.543]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.543]         }, condition = base::local({
[10:21:38.543]             c <- base::c
[10:21:38.543]             inherits <- base::inherits
[10:21:38.543]             invokeRestart <- base::invokeRestart
[10:21:38.543]             length <- base::length
[10:21:38.543]             list <- base::list
[10:21:38.543]             seq.int <- base::seq.int
[10:21:38.543]             signalCondition <- base::signalCondition
[10:21:38.543]             sys.calls <- base::sys.calls
[10:21:38.543]             `[[` <- base::`[[`
[10:21:38.543]             `+` <- base::`+`
[10:21:38.543]             `<<-` <- base::`<<-`
[10:21:38.543]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.543]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.543]                   3L)]
[10:21:38.543]             }
[10:21:38.543]             function(cond) {
[10:21:38.543]                 is_error <- inherits(cond, "error")
[10:21:38.543]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.543]                   NULL)
[10:21:38.543]                 if (is_error) {
[10:21:38.543]                   sessionInformation <- function() {
[10:21:38.543]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.543]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.543]                       search = base::search(), system = base::Sys.info())
[10:21:38.543]                   }
[10:21:38.543]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.543]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.543]                     cond$call), session = sessionInformation(), 
[10:21:38.543]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.543]                   signalCondition(cond)
[10:21:38.543]                 }
[10:21:38.543]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.543]                 "immediateCondition"))) {
[10:21:38.543]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.543]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.543]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.543]                   if (TRUE && !signal) {
[10:21:38.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.543]                     {
[10:21:38.543]                       inherits <- base::inherits
[10:21:38.543]                       invokeRestart <- base::invokeRestart
[10:21:38.543]                       is.null <- base::is.null
[10:21:38.543]                       muffled <- FALSE
[10:21:38.543]                       if (inherits(cond, "message")) {
[10:21:38.543]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.543]                         if (muffled) 
[10:21:38.543]                           invokeRestart("muffleMessage")
[10:21:38.543]                       }
[10:21:38.543]                       else if (inherits(cond, "warning")) {
[10:21:38.543]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.543]                         if (muffled) 
[10:21:38.543]                           invokeRestart("muffleWarning")
[10:21:38.543]                       }
[10:21:38.543]                       else if (inherits(cond, "condition")) {
[10:21:38.543]                         if (!is.null(pattern)) {
[10:21:38.543]                           computeRestarts <- base::computeRestarts
[10:21:38.543]                           grepl <- base::grepl
[10:21:38.543]                           restarts <- computeRestarts(cond)
[10:21:38.543]                           for (restart in restarts) {
[10:21:38.543]                             name <- restart$name
[10:21:38.543]                             if (is.null(name)) 
[10:21:38.543]                               next
[10:21:38.543]                             if (!grepl(pattern, name)) 
[10:21:38.543]                               next
[10:21:38.543]                             invokeRestart(restart)
[10:21:38.543]                             muffled <- TRUE
[10:21:38.543]                             break
[10:21:38.543]                           }
[10:21:38.543]                         }
[10:21:38.543]                       }
[10:21:38.543]                       invisible(muffled)
[10:21:38.543]                     }
[10:21:38.543]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.543]                   }
[10:21:38.543]                 }
[10:21:38.543]                 else {
[10:21:38.543]                   if (TRUE) {
[10:21:38.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.543]                     {
[10:21:38.543]                       inherits <- base::inherits
[10:21:38.543]                       invokeRestart <- base::invokeRestart
[10:21:38.543]                       is.null <- base::is.null
[10:21:38.543]                       muffled <- FALSE
[10:21:38.543]                       if (inherits(cond, "message")) {
[10:21:38.543]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.543]                         if (muffled) 
[10:21:38.543]                           invokeRestart("muffleMessage")
[10:21:38.543]                       }
[10:21:38.543]                       else if (inherits(cond, "warning")) {
[10:21:38.543]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.543]                         if (muffled) 
[10:21:38.543]                           invokeRestart("muffleWarning")
[10:21:38.543]                       }
[10:21:38.543]                       else if (inherits(cond, "condition")) {
[10:21:38.543]                         if (!is.null(pattern)) {
[10:21:38.543]                           computeRestarts <- base::computeRestarts
[10:21:38.543]                           grepl <- base::grepl
[10:21:38.543]                           restarts <- computeRestarts(cond)
[10:21:38.543]                           for (restart in restarts) {
[10:21:38.543]                             name <- restart$name
[10:21:38.543]                             if (is.null(name)) 
[10:21:38.543]                               next
[10:21:38.543]                             if (!grepl(pattern, name)) 
[10:21:38.543]                               next
[10:21:38.543]                             invokeRestart(restart)
[10:21:38.543]                             muffled <- TRUE
[10:21:38.543]                             break
[10:21:38.543]                           }
[10:21:38.543]                         }
[10:21:38.543]                       }
[10:21:38.543]                       invisible(muffled)
[10:21:38.543]                     }
[10:21:38.543]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.543]                   }
[10:21:38.543]                 }
[10:21:38.543]             }
[10:21:38.543]         }))
[10:21:38.543]     }, error = function(ex) {
[10:21:38.543]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.543]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.543]                 ...future.rng), started = ...future.startTime, 
[10:21:38.543]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.543]             version = "1.8"), class = "FutureResult")
[10:21:38.543]     }, finally = {
[10:21:38.543]         if (!identical(...future.workdir, getwd())) 
[10:21:38.543]             setwd(...future.workdir)
[10:21:38.543]         {
[10:21:38.543]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.543]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.543]             }
[10:21:38.543]             base::options(...future.oldOptions)
[10:21:38.543]             if (.Platform$OS.type == "windows") {
[10:21:38.543]                 old_names <- names(...future.oldEnvVars)
[10:21:38.543]                 envs <- base::Sys.getenv()
[10:21:38.543]                 names <- names(envs)
[10:21:38.543]                 common <- intersect(names, old_names)
[10:21:38.543]                 added <- setdiff(names, old_names)
[10:21:38.543]                 removed <- setdiff(old_names, names)
[10:21:38.543]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.543]                   envs[common]]
[10:21:38.543]                 NAMES <- toupper(changed)
[10:21:38.543]                 args <- list()
[10:21:38.543]                 for (kk in seq_along(NAMES)) {
[10:21:38.543]                   name <- changed[[kk]]
[10:21:38.543]                   NAME <- NAMES[[kk]]
[10:21:38.543]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.543]                     next
[10:21:38.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.543]                 }
[10:21:38.543]                 NAMES <- toupper(added)
[10:21:38.543]                 for (kk in seq_along(NAMES)) {
[10:21:38.543]                   name <- added[[kk]]
[10:21:38.543]                   NAME <- NAMES[[kk]]
[10:21:38.543]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.543]                     next
[10:21:38.543]                   args[[name]] <- ""
[10:21:38.543]                 }
[10:21:38.543]                 NAMES <- toupper(removed)
[10:21:38.543]                 for (kk in seq_along(NAMES)) {
[10:21:38.543]                   name <- removed[[kk]]
[10:21:38.543]                   NAME <- NAMES[[kk]]
[10:21:38.543]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.543]                     next
[10:21:38.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.543]                 }
[10:21:38.543]                 if (length(args) > 0) 
[10:21:38.543]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.543]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.543]             }
[10:21:38.543]             else {
[10:21:38.543]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.543]             }
[10:21:38.543]             {
[10:21:38.543]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.543]                   0L) {
[10:21:38.543]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.543]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.543]                   base::options(opts)
[10:21:38.543]                 }
[10:21:38.543]                 {
[10:21:38.543]                   {
[10:21:38.543]                     NULL
[10:21:38.543]                     RNGkind("Mersenne-Twister")
[10:21:38.543]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:38.543]                       inherits = FALSE)
[10:21:38.543]                   }
[10:21:38.543]                   options(future.plan = NULL)
[10:21:38.543]                   if (is.na(NA_character_)) 
[10:21:38.543]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.543]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.543]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.543]                     .init = FALSE)
[10:21:38.543]                 }
[10:21:38.543]             }
[10:21:38.543]         }
[10:21:38.543]     })
[10:21:38.543]     if (TRUE) {
[10:21:38.543]         base::sink(type = "output", split = FALSE)
[10:21:38.543]         if (TRUE) {
[10:21:38.543]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.543]         }
[10:21:38.543]         else {
[10:21:38.543]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.543]         }
[10:21:38.543]         base::close(...future.stdout)
[10:21:38.543]         ...future.stdout <- NULL
[10:21:38.543]     }
[10:21:38.543]     ...future.result$conditions <- ...future.conditions
[10:21:38.543]     ...future.result$finished <- base::Sys.time()
[10:21:38.543]     ...future.result
[10:21:38.543] }
[10:21:38.545] assign_globals() ...
[10:21:38.545] List of 1
[10:21:38.545]  $ x: list()
[10:21:38.545]  - attr(*, "where")=List of 1
[10:21:38.545]   ..$ x:<environment: R_EmptyEnv> 
[10:21:38.545]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:38.545]  - attr(*, "resolved")= logi TRUE
[10:21:38.545]  - attr(*, "total_size")= num 31
[10:21:38.545]  - attr(*, "already-done")= logi TRUE
[10:21:38.547] - copied ‘x’ to environment
[10:21:38.547] assign_globals() ... done
[10:21:38.548] plan(): Setting new future strategy stack:
[10:21:38.548] List of future strategies:
[10:21:38.548] 1. sequential:
[10:21:38.548]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.548]    - tweaked: FALSE
[10:21:38.548]    - call: NULL
[10:21:38.548] plan(): nbrOfWorkers() = 1
[10:21:38.549] plan(): Setting new future strategy stack:
[10:21:38.549] List of future strategies:
[10:21:38.549] 1. sequential:
[10:21:38.549]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.549]    - tweaked: FALSE
[10:21:38.549]    - call: plan(strategy)
[10:21:38.549] plan(): nbrOfWorkers() = 1
[10:21:38.549] SequentialFuture started (and completed)
[10:21:38.550] - Launch lazy future ... done
[10:21:38.550] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.550] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.550] Searching for globals...
[10:21:38.552] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:21:38.552] Searching for globals ... DONE
[10:21:38.552] Resolving globals: TRUE
[10:21:38.552] Resolving any globals that are futures ...
[10:21:38.553] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:21:38.553] Resolving any globals that are futures ... DONE
[10:21:38.553] Resolving futures part of globals (recursively) ...
[10:21:38.553] resolve() on list ...
[10:21:38.553]  recursive: 99
[10:21:38.553]  length: 1
[10:21:38.553]  elements: ‘x’
[10:21:38.554]  length: 0 (resolved future 1)
[10:21:38.554] resolve() on list ... DONE
[10:21:38.554] - globals: [1] ‘x’
[10:21:38.554] Resolving futures part of globals (recursively) ... DONE
[10:21:38.554] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:38.554] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:38.554] - globals: [1] ‘x’
[10:21:38.554] 
[10:21:38.555] getGlobalsAndPackages() ... DONE
[10:21:38.555] run() for ‘Future’ ...
[10:21:38.555] - state: ‘created’
[10:21:38.555] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:38.555] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:38.555] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:38.555]   - Field: ‘label’
[10:21:38.556]   - Field: ‘local’
[10:21:38.556]   - Field: ‘owner’
[10:21:38.556]   - Field: ‘envir’
[10:21:38.556]   - Field: ‘packages’
[10:21:38.556]   - Field: ‘gc’
[10:21:38.556]   - Field: ‘conditions’
[10:21:38.556]   - Field: ‘expr’
[10:21:38.556]   - Field: ‘uuid’
[10:21:38.556]   - Field: ‘seed’
[10:21:38.556]   - Field: ‘version’
[10:21:38.556]   - Field: ‘result’
[10:21:38.556]   - Field: ‘asynchronous’
[10:21:38.557]   - Field: ‘calls’
[10:21:38.557]   - Field: ‘globals’
[10:21:38.557]   - Field: ‘stdout’
[10:21:38.557]   - Field: ‘earlySignal’
[10:21:38.557]   - Field: ‘lazy’
[10:21:38.557]   - Field: ‘state’
[10:21:38.557] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:38.557] - Launch lazy future ...
[10:21:38.557] Packages needed by the future expression (n = 0): <none>
[10:21:38.559] Packages needed by future strategies (n = 0): <none>
[10:21:38.559] {
[10:21:38.559]     {
[10:21:38.559]         {
[10:21:38.559]             ...future.startTime <- base::Sys.time()
[10:21:38.559]             {
[10:21:38.559]                 {
[10:21:38.559]                   {
[10:21:38.559]                     base::local({
[10:21:38.559]                       has_future <- base::requireNamespace("future", 
[10:21:38.559]                         quietly = TRUE)
[10:21:38.559]                       if (has_future) {
[10:21:38.559]                         ns <- base::getNamespace("future")
[10:21:38.559]                         version <- ns[[".package"]][["version"]]
[10:21:38.559]                         if (is.null(version)) 
[10:21:38.559]                           version <- utils::packageVersion("future")
[10:21:38.559]                       }
[10:21:38.559]                       else {
[10:21:38.559]                         version <- NULL
[10:21:38.559]                       }
[10:21:38.559]                       if (!has_future || version < "1.8.0") {
[10:21:38.559]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.559]                           "", base::R.version$version.string), 
[10:21:38.559]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:38.559]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.559]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.559]                             "release", "version")], collapse = " "), 
[10:21:38.559]                           hostname = base::Sys.info()[["nodename"]])
[10:21:38.559]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.559]                           info)
[10:21:38.559]                         info <- base::paste(info, collapse = "; ")
[10:21:38.559]                         if (!has_future) {
[10:21:38.559]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.559]                             info)
[10:21:38.559]                         }
[10:21:38.559]                         else {
[10:21:38.559]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.559]                             info, version)
[10:21:38.559]                         }
[10:21:38.559]                         base::stop(msg)
[10:21:38.559]                       }
[10:21:38.559]                     })
[10:21:38.559]                   }
[10:21:38.559]                   ...future.strategy.old <- future::plan("list")
[10:21:38.559]                   options(future.plan = NULL)
[10:21:38.559]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.559]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.559]                 }
[10:21:38.559]                 ...future.workdir <- getwd()
[10:21:38.559]             }
[10:21:38.559]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.559]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.559]         }
[10:21:38.559]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.559]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.559]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.559]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.559]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.559]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.559]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.559]             base::names(...future.oldOptions))
[10:21:38.559]     }
[10:21:38.559]     if (FALSE) {
[10:21:38.559]     }
[10:21:38.559]     else {
[10:21:38.559]         if (TRUE) {
[10:21:38.559]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.559]                 open = "w")
[10:21:38.559]         }
[10:21:38.559]         else {
[10:21:38.559]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.559]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.559]         }
[10:21:38.559]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.559]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.559]             base::sink(type = "output", split = FALSE)
[10:21:38.559]             base::close(...future.stdout)
[10:21:38.559]         }, add = TRUE)
[10:21:38.559]     }
[10:21:38.559]     ...future.frame <- base::sys.nframe()
[10:21:38.559]     ...future.conditions <- base::list()
[10:21:38.559]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.559]     if (FALSE) {
[10:21:38.559]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.559]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.559]     }
[10:21:38.559]     ...future.result <- base::tryCatch({
[10:21:38.559]         base::withCallingHandlers({
[10:21:38.559]             ...future.value <- base::withVisible(base::local({
[10:21:38.559]                 x["a"] <- list(1)
[10:21:38.559]                 x
[10:21:38.559]             }))
[10:21:38.559]             future::FutureResult(value = ...future.value$value, 
[10:21:38.559]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.559]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.559]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.559]                     ...future.globalenv.names))
[10:21:38.559]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.559]         }, condition = base::local({
[10:21:38.559]             c <- base::c
[10:21:38.559]             inherits <- base::inherits
[10:21:38.559]             invokeRestart <- base::invokeRestart
[10:21:38.559]             length <- base::length
[10:21:38.559]             list <- base::list
[10:21:38.559]             seq.int <- base::seq.int
[10:21:38.559]             signalCondition <- base::signalCondition
[10:21:38.559]             sys.calls <- base::sys.calls
[10:21:38.559]             `[[` <- base::`[[`
[10:21:38.559]             `+` <- base::`+`
[10:21:38.559]             `<<-` <- base::`<<-`
[10:21:38.559]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.559]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.559]                   3L)]
[10:21:38.559]             }
[10:21:38.559]             function(cond) {
[10:21:38.559]                 is_error <- inherits(cond, "error")
[10:21:38.559]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.559]                   NULL)
[10:21:38.559]                 if (is_error) {
[10:21:38.559]                   sessionInformation <- function() {
[10:21:38.559]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.559]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.559]                       search = base::search(), system = base::Sys.info())
[10:21:38.559]                   }
[10:21:38.559]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.559]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.559]                     cond$call), session = sessionInformation(), 
[10:21:38.559]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.559]                   signalCondition(cond)
[10:21:38.559]                 }
[10:21:38.559]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.559]                 "immediateCondition"))) {
[10:21:38.559]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.559]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.559]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.559]                   if (TRUE && !signal) {
[10:21:38.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.559]                     {
[10:21:38.559]                       inherits <- base::inherits
[10:21:38.559]                       invokeRestart <- base::invokeRestart
[10:21:38.559]                       is.null <- base::is.null
[10:21:38.559]                       muffled <- FALSE
[10:21:38.559]                       if (inherits(cond, "message")) {
[10:21:38.559]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.559]                         if (muffled) 
[10:21:38.559]                           invokeRestart("muffleMessage")
[10:21:38.559]                       }
[10:21:38.559]                       else if (inherits(cond, "warning")) {
[10:21:38.559]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.559]                         if (muffled) 
[10:21:38.559]                           invokeRestart("muffleWarning")
[10:21:38.559]                       }
[10:21:38.559]                       else if (inherits(cond, "condition")) {
[10:21:38.559]                         if (!is.null(pattern)) {
[10:21:38.559]                           computeRestarts <- base::computeRestarts
[10:21:38.559]                           grepl <- base::grepl
[10:21:38.559]                           restarts <- computeRestarts(cond)
[10:21:38.559]                           for (restart in restarts) {
[10:21:38.559]                             name <- restart$name
[10:21:38.559]                             if (is.null(name)) 
[10:21:38.559]                               next
[10:21:38.559]                             if (!grepl(pattern, name)) 
[10:21:38.559]                               next
[10:21:38.559]                             invokeRestart(restart)
[10:21:38.559]                             muffled <- TRUE
[10:21:38.559]                             break
[10:21:38.559]                           }
[10:21:38.559]                         }
[10:21:38.559]                       }
[10:21:38.559]                       invisible(muffled)
[10:21:38.559]                     }
[10:21:38.559]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.559]                   }
[10:21:38.559]                 }
[10:21:38.559]                 else {
[10:21:38.559]                   if (TRUE) {
[10:21:38.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.559]                     {
[10:21:38.559]                       inherits <- base::inherits
[10:21:38.559]                       invokeRestart <- base::invokeRestart
[10:21:38.559]                       is.null <- base::is.null
[10:21:38.559]                       muffled <- FALSE
[10:21:38.559]                       if (inherits(cond, "message")) {
[10:21:38.559]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.559]                         if (muffled) 
[10:21:38.559]                           invokeRestart("muffleMessage")
[10:21:38.559]                       }
[10:21:38.559]                       else if (inherits(cond, "warning")) {
[10:21:38.559]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.559]                         if (muffled) 
[10:21:38.559]                           invokeRestart("muffleWarning")
[10:21:38.559]                       }
[10:21:38.559]                       else if (inherits(cond, "condition")) {
[10:21:38.559]                         if (!is.null(pattern)) {
[10:21:38.559]                           computeRestarts <- base::computeRestarts
[10:21:38.559]                           grepl <- base::grepl
[10:21:38.559]                           restarts <- computeRestarts(cond)
[10:21:38.559]                           for (restart in restarts) {
[10:21:38.559]                             name <- restart$name
[10:21:38.559]                             if (is.null(name)) 
[10:21:38.559]                               next
[10:21:38.559]                             if (!grepl(pattern, name)) 
[10:21:38.559]                               next
[10:21:38.559]                             invokeRestart(restart)
[10:21:38.559]                             muffled <- TRUE
[10:21:38.559]                             break
[10:21:38.559]                           }
[10:21:38.559]                         }
[10:21:38.559]                       }
[10:21:38.559]                       invisible(muffled)
[10:21:38.559]                     }
[10:21:38.559]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.559]                   }
[10:21:38.559]                 }
[10:21:38.559]             }
[10:21:38.559]         }))
[10:21:38.559]     }, error = function(ex) {
[10:21:38.559]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.559]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.559]                 ...future.rng), started = ...future.startTime, 
[10:21:38.559]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.559]             version = "1.8"), class = "FutureResult")
[10:21:38.559]     }, finally = {
[10:21:38.559]         if (!identical(...future.workdir, getwd())) 
[10:21:38.559]             setwd(...future.workdir)
[10:21:38.559]         {
[10:21:38.559]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.559]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.559]             }
[10:21:38.559]             base::options(...future.oldOptions)
[10:21:38.559]             if (.Platform$OS.type == "windows") {
[10:21:38.559]                 old_names <- names(...future.oldEnvVars)
[10:21:38.559]                 envs <- base::Sys.getenv()
[10:21:38.559]                 names <- names(envs)
[10:21:38.559]                 common <- intersect(names, old_names)
[10:21:38.559]                 added <- setdiff(names, old_names)
[10:21:38.559]                 removed <- setdiff(old_names, names)
[10:21:38.559]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.559]                   envs[common]]
[10:21:38.559]                 NAMES <- toupper(changed)
[10:21:38.559]                 args <- list()
[10:21:38.559]                 for (kk in seq_along(NAMES)) {
[10:21:38.559]                   name <- changed[[kk]]
[10:21:38.559]                   NAME <- NAMES[[kk]]
[10:21:38.559]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.559]                     next
[10:21:38.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.559]                 }
[10:21:38.559]                 NAMES <- toupper(added)
[10:21:38.559]                 for (kk in seq_along(NAMES)) {
[10:21:38.559]                   name <- added[[kk]]
[10:21:38.559]                   NAME <- NAMES[[kk]]
[10:21:38.559]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.559]                     next
[10:21:38.559]                   args[[name]] <- ""
[10:21:38.559]                 }
[10:21:38.559]                 NAMES <- toupper(removed)
[10:21:38.559]                 for (kk in seq_along(NAMES)) {
[10:21:38.559]                   name <- removed[[kk]]
[10:21:38.559]                   NAME <- NAMES[[kk]]
[10:21:38.559]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.559]                     next
[10:21:38.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.559]                 }
[10:21:38.559]                 if (length(args) > 0) 
[10:21:38.559]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.559]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.559]             }
[10:21:38.559]             else {
[10:21:38.559]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.559]             }
[10:21:38.559]             {
[10:21:38.559]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.559]                   0L) {
[10:21:38.559]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.559]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.559]                   base::options(opts)
[10:21:38.559]                 }
[10:21:38.559]                 {
[10:21:38.559]                   {
[10:21:38.559]                     NULL
[10:21:38.559]                     RNGkind("Mersenne-Twister")
[10:21:38.559]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:38.559]                       inherits = FALSE)
[10:21:38.559]                   }
[10:21:38.559]                   options(future.plan = NULL)
[10:21:38.559]                   if (is.na(NA_character_)) 
[10:21:38.559]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.559]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.559]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.559]                     .init = FALSE)
[10:21:38.559]                 }
[10:21:38.559]             }
[10:21:38.559]         }
[10:21:38.559]     })
[10:21:38.559]     if (TRUE) {
[10:21:38.559]         base::sink(type = "output", split = FALSE)
[10:21:38.559]         if (TRUE) {
[10:21:38.559]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.559]         }
[10:21:38.559]         else {
[10:21:38.559]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.559]         }
[10:21:38.559]         base::close(...future.stdout)
[10:21:38.559]         ...future.stdout <- NULL
[10:21:38.559]     }
[10:21:38.559]     ...future.result$conditions <- ...future.conditions
[10:21:38.559]     ...future.result$finished <- base::Sys.time()
[10:21:38.559]     ...future.result
[10:21:38.559] }
[10:21:38.561] assign_globals() ...
[10:21:38.561] List of 1
[10:21:38.561]  $ x: list()
[10:21:38.561]  - attr(*, "where")=List of 1
[10:21:38.561]   ..$ x:<environment: R_EmptyEnv> 
[10:21:38.561]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:38.561]  - attr(*, "resolved")= logi TRUE
[10:21:38.561]  - attr(*, "total_size")= num 31
[10:21:38.561]  - attr(*, "already-done")= logi TRUE
[10:21:38.563] - copied ‘x’ to environment
[10:21:38.563] assign_globals() ... done
[10:21:38.564] plan(): Setting new future strategy stack:
[10:21:38.564] List of future strategies:
[10:21:38.564] 1. sequential:
[10:21:38.564]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.564]    - tweaked: FALSE
[10:21:38.564]    - call: NULL
[10:21:38.564] plan(): nbrOfWorkers() = 1
[10:21:38.565] plan(): Setting new future strategy stack:
[10:21:38.565] List of future strategies:
[10:21:38.565] 1. sequential:
[10:21:38.565]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.565]    - tweaked: FALSE
[10:21:38.565]    - call: plan(strategy)
[10:21:38.565] plan(): nbrOfWorkers() = 1
[10:21:38.565] SequentialFuture started (and completed)
[10:21:38.566] - Launch lazy future ... done
[10:21:38.566] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.566] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.566] Searching for globals...
[10:21:38.568] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:21:38.568] Searching for globals ... DONE
[10:21:38.568] Resolving globals: TRUE
[10:21:38.568] Resolving any globals that are futures ...
[10:21:38.569] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:21:38.569] Resolving any globals that are futures ... DONE
[10:21:38.569] Resolving futures part of globals (recursively) ...
[10:21:38.569] resolve() on list ...
[10:21:38.569]  recursive: 99
[10:21:38.569]  length: 1
[10:21:38.570]  elements: ‘x’
[10:21:38.570]  length: 0 (resolved future 1)
[10:21:38.570] resolve() on list ... DONE
[10:21:38.570] - globals: [1] ‘x’
[10:21:38.570] Resolving futures part of globals (recursively) ... DONE
[10:21:38.570] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:38.570] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:38.570] - globals: [1] ‘x’
[10:21:38.571] 
[10:21:38.571] getGlobalsAndPackages() ... DONE
[10:21:38.571] run() for ‘Future’ ...
[10:21:38.571] - state: ‘created’
[10:21:38.571] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:38.571] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:38.571] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:38.572]   - Field: ‘label’
[10:21:38.572]   - Field: ‘local’
[10:21:38.572]   - Field: ‘owner’
[10:21:38.572]   - Field: ‘envir’
[10:21:38.572]   - Field: ‘packages’
[10:21:38.572]   - Field: ‘gc’
[10:21:38.572]   - Field: ‘conditions’
[10:21:38.572]   - Field: ‘expr’
[10:21:38.572]   - Field: ‘uuid’
[10:21:38.572]   - Field: ‘seed’
[10:21:38.572]   - Field: ‘version’
[10:21:38.572]   - Field: ‘result’
[10:21:38.573]   - Field: ‘asynchronous’
[10:21:38.573]   - Field: ‘calls’
[10:21:38.573]   - Field: ‘globals’
[10:21:38.573]   - Field: ‘stdout’
[10:21:38.573]   - Field: ‘earlySignal’
[10:21:38.573]   - Field: ‘lazy’
[10:21:38.573]   - Field: ‘state’
[10:21:38.573] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:38.573] - Launch lazy future ...
[10:21:38.573] Packages needed by the future expression (n = 0): <none>
[10:21:38.573] Packages needed by future strategies (n = 0): <none>
[10:21:38.574] {
[10:21:38.574]     {
[10:21:38.574]         {
[10:21:38.574]             ...future.startTime <- base::Sys.time()
[10:21:38.574]             {
[10:21:38.574]                 {
[10:21:38.574]                   {
[10:21:38.574]                     base::local({
[10:21:38.574]                       has_future <- base::requireNamespace("future", 
[10:21:38.574]                         quietly = TRUE)
[10:21:38.574]                       if (has_future) {
[10:21:38.574]                         ns <- base::getNamespace("future")
[10:21:38.574]                         version <- ns[[".package"]][["version"]]
[10:21:38.574]                         if (is.null(version)) 
[10:21:38.574]                           version <- utils::packageVersion("future")
[10:21:38.574]                       }
[10:21:38.574]                       else {
[10:21:38.574]                         version <- NULL
[10:21:38.574]                       }
[10:21:38.574]                       if (!has_future || version < "1.8.0") {
[10:21:38.574]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.574]                           "", base::R.version$version.string), 
[10:21:38.574]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:38.574]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.574]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.574]                             "release", "version")], collapse = " "), 
[10:21:38.574]                           hostname = base::Sys.info()[["nodename"]])
[10:21:38.574]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.574]                           info)
[10:21:38.574]                         info <- base::paste(info, collapse = "; ")
[10:21:38.574]                         if (!has_future) {
[10:21:38.574]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.574]                             info)
[10:21:38.574]                         }
[10:21:38.574]                         else {
[10:21:38.574]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.574]                             info, version)
[10:21:38.574]                         }
[10:21:38.574]                         base::stop(msg)
[10:21:38.574]                       }
[10:21:38.574]                     })
[10:21:38.574]                   }
[10:21:38.574]                   ...future.strategy.old <- future::plan("list")
[10:21:38.574]                   options(future.plan = NULL)
[10:21:38.574]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.574]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.574]                 }
[10:21:38.574]                 ...future.workdir <- getwd()
[10:21:38.574]             }
[10:21:38.574]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.574]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.574]         }
[10:21:38.574]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.574]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.574]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.574]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.574]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.574]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.574]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.574]             base::names(...future.oldOptions))
[10:21:38.574]     }
[10:21:38.574]     if (FALSE) {
[10:21:38.574]     }
[10:21:38.574]     else {
[10:21:38.574]         if (TRUE) {
[10:21:38.574]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.574]                 open = "w")
[10:21:38.574]         }
[10:21:38.574]         else {
[10:21:38.574]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.574]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.574]         }
[10:21:38.574]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.574]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.574]             base::sink(type = "output", split = FALSE)
[10:21:38.574]             base::close(...future.stdout)
[10:21:38.574]         }, add = TRUE)
[10:21:38.574]     }
[10:21:38.574]     ...future.frame <- base::sys.nframe()
[10:21:38.574]     ...future.conditions <- base::list()
[10:21:38.574]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.574]     if (FALSE) {
[10:21:38.574]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.574]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.574]     }
[10:21:38.574]     ...future.result <- base::tryCatch({
[10:21:38.574]         base::withCallingHandlers({
[10:21:38.574]             ...future.value <- base::withVisible(base::local({
[10:21:38.574]                 x["a"] <- list(1)
[10:21:38.574]                 x
[10:21:38.574]             }))
[10:21:38.574]             future::FutureResult(value = ...future.value$value, 
[10:21:38.574]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.574]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.574]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.574]                     ...future.globalenv.names))
[10:21:38.574]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.574]         }, condition = base::local({
[10:21:38.574]             c <- base::c
[10:21:38.574]             inherits <- base::inherits
[10:21:38.574]             invokeRestart <- base::invokeRestart
[10:21:38.574]             length <- base::length
[10:21:38.574]             list <- base::list
[10:21:38.574]             seq.int <- base::seq.int
[10:21:38.574]             signalCondition <- base::signalCondition
[10:21:38.574]             sys.calls <- base::sys.calls
[10:21:38.574]             `[[` <- base::`[[`
[10:21:38.574]             `+` <- base::`+`
[10:21:38.574]             `<<-` <- base::`<<-`
[10:21:38.574]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.574]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.574]                   3L)]
[10:21:38.574]             }
[10:21:38.574]             function(cond) {
[10:21:38.574]                 is_error <- inherits(cond, "error")
[10:21:38.574]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.574]                   NULL)
[10:21:38.574]                 if (is_error) {
[10:21:38.574]                   sessionInformation <- function() {
[10:21:38.574]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.574]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.574]                       search = base::search(), system = base::Sys.info())
[10:21:38.574]                   }
[10:21:38.574]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.574]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.574]                     cond$call), session = sessionInformation(), 
[10:21:38.574]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.574]                   signalCondition(cond)
[10:21:38.574]                 }
[10:21:38.574]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.574]                 "immediateCondition"))) {
[10:21:38.574]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.574]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.574]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.574]                   if (TRUE && !signal) {
[10:21:38.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.574]                     {
[10:21:38.574]                       inherits <- base::inherits
[10:21:38.574]                       invokeRestart <- base::invokeRestart
[10:21:38.574]                       is.null <- base::is.null
[10:21:38.574]                       muffled <- FALSE
[10:21:38.574]                       if (inherits(cond, "message")) {
[10:21:38.574]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.574]                         if (muffled) 
[10:21:38.574]                           invokeRestart("muffleMessage")
[10:21:38.574]                       }
[10:21:38.574]                       else if (inherits(cond, "warning")) {
[10:21:38.574]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.574]                         if (muffled) 
[10:21:38.574]                           invokeRestart("muffleWarning")
[10:21:38.574]                       }
[10:21:38.574]                       else if (inherits(cond, "condition")) {
[10:21:38.574]                         if (!is.null(pattern)) {
[10:21:38.574]                           computeRestarts <- base::computeRestarts
[10:21:38.574]                           grepl <- base::grepl
[10:21:38.574]                           restarts <- computeRestarts(cond)
[10:21:38.574]                           for (restart in restarts) {
[10:21:38.574]                             name <- restart$name
[10:21:38.574]                             if (is.null(name)) 
[10:21:38.574]                               next
[10:21:38.574]                             if (!grepl(pattern, name)) 
[10:21:38.574]                               next
[10:21:38.574]                             invokeRestart(restart)
[10:21:38.574]                             muffled <- TRUE
[10:21:38.574]                             break
[10:21:38.574]                           }
[10:21:38.574]                         }
[10:21:38.574]                       }
[10:21:38.574]                       invisible(muffled)
[10:21:38.574]                     }
[10:21:38.574]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.574]                   }
[10:21:38.574]                 }
[10:21:38.574]                 else {
[10:21:38.574]                   if (TRUE) {
[10:21:38.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.574]                     {
[10:21:38.574]                       inherits <- base::inherits
[10:21:38.574]                       invokeRestart <- base::invokeRestart
[10:21:38.574]                       is.null <- base::is.null
[10:21:38.574]                       muffled <- FALSE
[10:21:38.574]                       if (inherits(cond, "message")) {
[10:21:38.574]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.574]                         if (muffled) 
[10:21:38.574]                           invokeRestart("muffleMessage")
[10:21:38.574]                       }
[10:21:38.574]                       else if (inherits(cond, "warning")) {
[10:21:38.574]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.574]                         if (muffled) 
[10:21:38.574]                           invokeRestart("muffleWarning")
[10:21:38.574]                       }
[10:21:38.574]                       else if (inherits(cond, "condition")) {
[10:21:38.574]                         if (!is.null(pattern)) {
[10:21:38.574]                           computeRestarts <- base::computeRestarts
[10:21:38.574]                           grepl <- base::grepl
[10:21:38.574]                           restarts <- computeRestarts(cond)
[10:21:38.574]                           for (restart in restarts) {
[10:21:38.574]                             name <- restart$name
[10:21:38.574]                             if (is.null(name)) 
[10:21:38.574]                               next
[10:21:38.574]                             if (!grepl(pattern, name)) 
[10:21:38.574]                               next
[10:21:38.574]                             invokeRestart(restart)
[10:21:38.574]                             muffled <- TRUE
[10:21:38.574]                             break
[10:21:38.574]                           }
[10:21:38.574]                         }
[10:21:38.574]                       }
[10:21:38.574]                       invisible(muffled)
[10:21:38.574]                     }
[10:21:38.574]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.574]                   }
[10:21:38.574]                 }
[10:21:38.574]             }
[10:21:38.574]         }))
[10:21:38.574]     }, error = function(ex) {
[10:21:38.574]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.574]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.574]                 ...future.rng), started = ...future.startTime, 
[10:21:38.574]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.574]             version = "1.8"), class = "FutureResult")
[10:21:38.574]     }, finally = {
[10:21:38.574]         if (!identical(...future.workdir, getwd())) 
[10:21:38.574]             setwd(...future.workdir)
[10:21:38.574]         {
[10:21:38.574]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.574]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.574]             }
[10:21:38.574]             base::options(...future.oldOptions)
[10:21:38.574]             if (.Platform$OS.type == "windows") {
[10:21:38.574]                 old_names <- names(...future.oldEnvVars)
[10:21:38.574]                 envs <- base::Sys.getenv()
[10:21:38.574]                 names <- names(envs)
[10:21:38.574]                 common <- intersect(names, old_names)
[10:21:38.574]                 added <- setdiff(names, old_names)
[10:21:38.574]                 removed <- setdiff(old_names, names)
[10:21:38.574]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.574]                   envs[common]]
[10:21:38.574]                 NAMES <- toupper(changed)
[10:21:38.574]                 args <- list()
[10:21:38.574]                 for (kk in seq_along(NAMES)) {
[10:21:38.574]                   name <- changed[[kk]]
[10:21:38.574]                   NAME <- NAMES[[kk]]
[10:21:38.574]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.574]                     next
[10:21:38.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.574]                 }
[10:21:38.574]                 NAMES <- toupper(added)
[10:21:38.574]                 for (kk in seq_along(NAMES)) {
[10:21:38.574]                   name <- added[[kk]]
[10:21:38.574]                   NAME <- NAMES[[kk]]
[10:21:38.574]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.574]                     next
[10:21:38.574]                   args[[name]] <- ""
[10:21:38.574]                 }
[10:21:38.574]                 NAMES <- toupper(removed)
[10:21:38.574]                 for (kk in seq_along(NAMES)) {
[10:21:38.574]                   name <- removed[[kk]]
[10:21:38.574]                   NAME <- NAMES[[kk]]
[10:21:38.574]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.574]                     next
[10:21:38.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.574]                 }
[10:21:38.574]                 if (length(args) > 0) 
[10:21:38.574]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.574]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.574]             }
[10:21:38.574]             else {
[10:21:38.574]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.574]             }
[10:21:38.574]             {
[10:21:38.574]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.574]                   0L) {
[10:21:38.574]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.574]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.574]                   base::options(opts)
[10:21:38.574]                 }
[10:21:38.574]                 {
[10:21:38.574]                   {
[10:21:38.574]                     NULL
[10:21:38.574]                     RNGkind("Mersenne-Twister")
[10:21:38.574]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:38.574]                       inherits = FALSE)
[10:21:38.574]                   }
[10:21:38.574]                   options(future.plan = NULL)
[10:21:38.574]                   if (is.na(NA_character_)) 
[10:21:38.574]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.574]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.574]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.574]                     .init = FALSE)
[10:21:38.574]                 }
[10:21:38.574]             }
[10:21:38.574]         }
[10:21:38.574]     })
[10:21:38.574]     if (TRUE) {
[10:21:38.574]         base::sink(type = "output", split = FALSE)
[10:21:38.574]         if (TRUE) {
[10:21:38.574]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.574]         }
[10:21:38.574]         else {
[10:21:38.574]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.574]         }
[10:21:38.574]         base::close(...future.stdout)
[10:21:38.574]         ...future.stdout <- NULL
[10:21:38.574]     }
[10:21:38.574]     ...future.result$conditions <- ...future.conditions
[10:21:38.574]     ...future.result$finished <- base::Sys.time()
[10:21:38.574]     ...future.result
[10:21:38.574] }
[10:21:38.575] assign_globals() ...
[10:21:38.576] List of 1
[10:21:38.576]  $ x: list()
[10:21:38.576]  - attr(*, "where")=List of 1
[10:21:38.576]   ..$ x:<environment: R_EmptyEnv> 
[10:21:38.576]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:38.576]  - attr(*, "resolved")= logi TRUE
[10:21:38.576]  - attr(*, "total_size")= num 31
[10:21:38.576]  - attr(*, "already-done")= logi TRUE
[10:21:38.578] - copied ‘x’ to environment
[10:21:38.578] assign_globals() ... done
[10:21:38.578] plan(): Setting new future strategy stack:
[10:21:38.578] List of future strategies:
[10:21:38.578] 1. sequential:
[10:21:38.578]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.578]    - tweaked: FALSE
[10:21:38.578]    - call: NULL
[10:21:38.579] plan(): nbrOfWorkers() = 1
[10:21:38.579] plan(): Setting new future strategy stack:
[10:21:38.579] List of future strategies:
[10:21:38.579] 1. sequential:
[10:21:38.579]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.579]    - tweaked: FALSE
[10:21:38.579]    - call: plan(strategy)
[10:21:38.580] plan(): nbrOfWorkers() = 1
[10:21:38.580] SequentialFuture started (and completed)
[10:21:38.580] - Launch lazy future ... done
[10:21:38.580] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.581] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.581] Searching for globals...
[10:21:38.583] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[10:21:38.583] Searching for globals ... DONE
[10:21:38.583] Resolving globals: TRUE
[10:21:38.583] Resolving any globals that are futures ...
[10:21:38.583] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[10:21:38.583] Resolving any globals that are futures ... DONE
[10:21:38.584] Resolving futures part of globals (recursively) ...
[10:21:38.584] resolve() on list ...
[10:21:38.585]  recursive: 99
[10:21:38.585]  length: 2
[10:21:38.586]  elements: ‘x’, ‘name’
[10:21:38.586]  length: 1 (resolved future 1)
[10:21:38.586]  length: 0 (resolved future 2)
[10:21:38.586] resolve() on list ... DONE
[10:21:38.586] - globals: [2] ‘x’, ‘name’
[10:21:38.586] Resolving futures part of globals (recursively) ... DONE
[10:21:38.586] The total size of the 2 globals is 71 bytes (71 bytes)
[10:21:38.587] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 71 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (40 bytes of class ‘character’) and ‘x’ (31 bytes of class ‘list’)
[10:21:38.587] - globals: [2] ‘x’, ‘name’
[10:21:38.587] 
[10:21:38.587] getGlobalsAndPackages() ... DONE
[10:21:38.587] run() for ‘Future’ ...
[10:21:38.587] - state: ‘created’
[10:21:38.587] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:38.588] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:38.588] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:38.588]   - Field: ‘label’
[10:21:38.588]   - Field: ‘local’
[10:21:38.588]   - Field: ‘owner’
[10:21:38.588]   - Field: ‘envir’
[10:21:38.588]   - Field: ‘packages’
[10:21:38.588]   - Field: ‘gc’
[10:21:38.588]   - Field: ‘conditions’
[10:21:38.588]   - Field: ‘expr’
[10:21:38.589]   - Field: ‘uuid’
[10:21:38.589]   - Field: ‘seed’
[10:21:38.589]   - Field: ‘version’
[10:21:38.589]   - Field: ‘result’
[10:21:38.589]   - Field: ‘asynchronous’
[10:21:38.589]   - Field: ‘calls’
[10:21:38.589]   - Field: ‘globals’
[10:21:38.589]   - Field: ‘stdout’
[10:21:38.589]   - Field: ‘earlySignal’
[10:21:38.589]   - Field: ‘lazy’
[10:21:38.589]   - Field: ‘state’
[10:21:38.589] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:38.590] - Launch lazy future ...
[10:21:38.590] Packages needed by the future expression (n = 0): <none>
[10:21:38.590] Packages needed by future strategies (n = 0): <none>
[10:21:38.590] {
[10:21:38.590]     {
[10:21:38.590]         {
[10:21:38.590]             ...future.startTime <- base::Sys.time()
[10:21:38.590]             {
[10:21:38.590]                 {
[10:21:38.590]                   {
[10:21:38.590]                     base::local({
[10:21:38.590]                       has_future <- base::requireNamespace("future", 
[10:21:38.590]                         quietly = TRUE)
[10:21:38.590]                       if (has_future) {
[10:21:38.590]                         ns <- base::getNamespace("future")
[10:21:38.590]                         version <- ns[[".package"]][["version"]]
[10:21:38.590]                         if (is.null(version)) 
[10:21:38.590]                           version <- utils::packageVersion("future")
[10:21:38.590]                       }
[10:21:38.590]                       else {
[10:21:38.590]                         version <- NULL
[10:21:38.590]                       }
[10:21:38.590]                       if (!has_future || version < "1.8.0") {
[10:21:38.590]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.590]                           "", base::R.version$version.string), 
[10:21:38.590]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:38.590]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.590]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.590]                             "release", "version")], collapse = " "), 
[10:21:38.590]                           hostname = base::Sys.info()[["nodename"]])
[10:21:38.590]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.590]                           info)
[10:21:38.590]                         info <- base::paste(info, collapse = "; ")
[10:21:38.590]                         if (!has_future) {
[10:21:38.590]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.590]                             info)
[10:21:38.590]                         }
[10:21:38.590]                         else {
[10:21:38.590]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.590]                             info, version)
[10:21:38.590]                         }
[10:21:38.590]                         base::stop(msg)
[10:21:38.590]                       }
[10:21:38.590]                     })
[10:21:38.590]                   }
[10:21:38.590]                   ...future.strategy.old <- future::plan("list")
[10:21:38.590]                   options(future.plan = NULL)
[10:21:38.590]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.590]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.590]                 }
[10:21:38.590]                 ...future.workdir <- getwd()
[10:21:38.590]             }
[10:21:38.590]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.590]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.590]         }
[10:21:38.590]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.590]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.590]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.590]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.590]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.590]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.590]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.590]             base::names(...future.oldOptions))
[10:21:38.590]     }
[10:21:38.590]     if (FALSE) {
[10:21:38.590]     }
[10:21:38.590]     else {
[10:21:38.590]         if (TRUE) {
[10:21:38.590]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.590]                 open = "w")
[10:21:38.590]         }
[10:21:38.590]         else {
[10:21:38.590]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.590]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.590]         }
[10:21:38.590]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.590]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.590]             base::sink(type = "output", split = FALSE)
[10:21:38.590]             base::close(...future.stdout)
[10:21:38.590]         }, add = TRUE)
[10:21:38.590]     }
[10:21:38.590]     ...future.frame <- base::sys.nframe()
[10:21:38.590]     ...future.conditions <- base::list()
[10:21:38.590]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.590]     if (FALSE) {
[10:21:38.590]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.590]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.590]     }
[10:21:38.590]     ...future.result <- base::tryCatch({
[10:21:38.590]         base::withCallingHandlers({
[10:21:38.590]             ...future.value <- base::withVisible(base::local({
[10:21:38.590]                 x[name] <- list(1)
[10:21:38.590]                 x
[10:21:38.590]             }))
[10:21:38.590]             future::FutureResult(value = ...future.value$value, 
[10:21:38.590]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.590]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.590]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.590]                     ...future.globalenv.names))
[10:21:38.590]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.590]         }, condition = base::local({
[10:21:38.590]             c <- base::c
[10:21:38.590]             inherits <- base::inherits
[10:21:38.590]             invokeRestart <- base::invokeRestart
[10:21:38.590]             length <- base::length
[10:21:38.590]             list <- base::list
[10:21:38.590]             seq.int <- base::seq.int
[10:21:38.590]             signalCondition <- base::signalCondition
[10:21:38.590]             sys.calls <- base::sys.calls
[10:21:38.590]             `[[` <- base::`[[`
[10:21:38.590]             `+` <- base::`+`
[10:21:38.590]             `<<-` <- base::`<<-`
[10:21:38.590]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.590]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.590]                   3L)]
[10:21:38.590]             }
[10:21:38.590]             function(cond) {
[10:21:38.590]                 is_error <- inherits(cond, "error")
[10:21:38.590]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.590]                   NULL)
[10:21:38.590]                 if (is_error) {
[10:21:38.590]                   sessionInformation <- function() {
[10:21:38.590]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.590]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.590]                       search = base::search(), system = base::Sys.info())
[10:21:38.590]                   }
[10:21:38.590]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.590]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.590]                     cond$call), session = sessionInformation(), 
[10:21:38.590]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.590]                   signalCondition(cond)
[10:21:38.590]                 }
[10:21:38.590]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.590]                 "immediateCondition"))) {
[10:21:38.590]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.590]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.590]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.590]                   if (TRUE && !signal) {
[10:21:38.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.590]                     {
[10:21:38.590]                       inherits <- base::inherits
[10:21:38.590]                       invokeRestart <- base::invokeRestart
[10:21:38.590]                       is.null <- base::is.null
[10:21:38.590]                       muffled <- FALSE
[10:21:38.590]                       if (inherits(cond, "message")) {
[10:21:38.590]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.590]                         if (muffled) 
[10:21:38.590]                           invokeRestart("muffleMessage")
[10:21:38.590]                       }
[10:21:38.590]                       else if (inherits(cond, "warning")) {
[10:21:38.590]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.590]                         if (muffled) 
[10:21:38.590]                           invokeRestart("muffleWarning")
[10:21:38.590]                       }
[10:21:38.590]                       else if (inherits(cond, "condition")) {
[10:21:38.590]                         if (!is.null(pattern)) {
[10:21:38.590]                           computeRestarts <- base::computeRestarts
[10:21:38.590]                           grepl <- base::grepl
[10:21:38.590]                           restarts <- computeRestarts(cond)
[10:21:38.590]                           for (restart in restarts) {
[10:21:38.590]                             name <- restart$name
[10:21:38.590]                             if (is.null(name)) 
[10:21:38.590]                               next
[10:21:38.590]                             if (!grepl(pattern, name)) 
[10:21:38.590]                               next
[10:21:38.590]                             invokeRestart(restart)
[10:21:38.590]                             muffled <- TRUE
[10:21:38.590]                             break
[10:21:38.590]                           }
[10:21:38.590]                         }
[10:21:38.590]                       }
[10:21:38.590]                       invisible(muffled)
[10:21:38.590]                     }
[10:21:38.590]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.590]                   }
[10:21:38.590]                 }
[10:21:38.590]                 else {
[10:21:38.590]                   if (TRUE) {
[10:21:38.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.590]                     {
[10:21:38.590]                       inherits <- base::inherits
[10:21:38.590]                       invokeRestart <- base::invokeRestart
[10:21:38.590]                       is.null <- base::is.null
[10:21:38.590]                       muffled <- FALSE
[10:21:38.590]                       if (inherits(cond, "message")) {
[10:21:38.590]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.590]                         if (muffled) 
[10:21:38.590]                           invokeRestart("muffleMessage")
[10:21:38.590]                       }
[10:21:38.590]                       else if (inherits(cond, "warning")) {
[10:21:38.590]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.590]                         if (muffled) 
[10:21:38.590]                           invokeRestart("muffleWarning")
[10:21:38.590]                       }
[10:21:38.590]                       else if (inherits(cond, "condition")) {
[10:21:38.590]                         if (!is.null(pattern)) {
[10:21:38.590]                           computeRestarts <- base::computeRestarts
[10:21:38.590]                           grepl <- base::grepl
[10:21:38.590]                           restarts <- computeRestarts(cond)
[10:21:38.590]                           for (restart in restarts) {
[10:21:38.590]                             name <- restart$name
[10:21:38.590]                             if (is.null(name)) 
[10:21:38.590]                               next
[10:21:38.590]                             if (!grepl(pattern, name)) 
[10:21:38.590]                               next
[10:21:38.590]                             invokeRestart(restart)
[10:21:38.590]                             muffled <- TRUE
[10:21:38.590]                             break
[10:21:38.590]                           }
[10:21:38.590]                         }
[10:21:38.590]                       }
[10:21:38.590]                       invisible(muffled)
[10:21:38.590]                     }
[10:21:38.590]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.590]                   }
[10:21:38.590]                 }
[10:21:38.590]             }
[10:21:38.590]         }))
[10:21:38.590]     }, error = function(ex) {
[10:21:38.590]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.590]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.590]                 ...future.rng), started = ...future.startTime, 
[10:21:38.590]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.590]             version = "1.8"), class = "FutureResult")
[10:21:38.590]     }, finally = {
[10:21:38.590]         if (!identical(...future.workdir, getwd())) 
[10:21:38.590]             setwd(...future.workdir)
[10:21:38.590]         {
[10:21:38.590]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.590]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.590]             }
[10:21:38.590]             base::options(...future.oldOptions)
[10:21:38.590]             if (.Platform$OS.type == "windows") {
[10:21:38.590]                 old_names <- names(...future.oldEnvVars)
[10:21:38.590]                 envs <- base::Sys.getenv()
[10:21:38.590]                 names <- names(envs)
[10:21:38.590]                 common <- intersect(names, old_names)
[10:21:38.590]                 added <- setdiff(names, old_names)
[10:21:38.590]                 removed <- setdiff(old_names, names)
[10:21:38.590]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.590]                   envs[common]]
[10:21:38.590]                 NAMES <- toupper(changed)
[10:21:38.590]                 args <- list()
[10:21:38.590]                 for (kk in seq_along(NAMES)) {
[10:21:38.590]                   name <- changed[[kk]]
[10:21:38.590]                   NAME <- NAMES[[kk]]
[10:21:38.590]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.590]                     next
[10:21:38.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.590]                 }
[10:21:38.590]                 NAMES <- toupper(added)
[10:21:38.590]                 for (kk in seq_along(NAMES)) {
[10:21:38.590]                   name <- added[[kk]]
[10:21:38.590]                   NAME <- NAMES[[kk]]
[10:21:38.590]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.590]                     next
[10:21:38.590]                   args[[name]] <- ""
[10:21:38.590]                 }
[10:21:38.590]                 NAMES <- toupper(removed)
[10:21:38.590]                 for (kk in seq_along(NAMES)) {
[10:21:38.590]                   name <- removed[[kk]]
[10:21:38.590]                   NAME <- NAMES[[kk]]
[10:21:38.590]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.590]                     next
[10:21:38.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.590]                 }
[10:21:38.590]                 if (length(args) > 0) 
[10:21:38.590]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.590]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.590]             }
[10:21:38.590]             else {
[10:21:38.590]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.590]             }
[10:21:38.590]             {
[10:21:38.590]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.590]                   0L) {
[10:21:38.590]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.590]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.590]                   base::options(opts)
[10:21:38.590]                 }
[10:21:38.590]                 {
[10:21:38.590]                   {
[10:21:38.590]                     NULL
[10:21:38.590]                     RNGkind("Mersenne-Twister")
[10:21:38.590]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:38.590]                       inherits = FALSE)
[10:21:38.590]                   }
[10:21:38.590]                   options(future.plan = NULL)
[10:21:38.590]                   if (is.na(NA_character_)) 
[10:21:38.590]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.590]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.590]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.590]                     .init = FALSE)
[10:21:38.590]                 }
[10:21:38.590]             }
[10:21:38.590]         }
[10:21:38.590]     })
[10:21:38.590]     if (TRUE) {
[10:21:38.590]         base::sink(type = "output", split = FALSE)
[10:21:38.590]         if (TRUE) {
[10:21:38.590]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.590]         }
[10:21:38.590]         else {
[10:21:38.590]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.590]         }
[10:21:38.590]         base::close(...future.stdout)
[10:21:38.590]         ...future.stdout <- NULL
[10:21:38.590]     }
[10:21:38.590]     ...future.result$conditions <- ...future.conditions
[10:21:38.590]     ...future.result$finished <- base::Sys.time()
[10:21:38.590]     ...future.result
[10:21:38.590] }
[10:21:38.592] assign_globals() ...
[10:21:38.592] List of 2
[10:21:38.592]  $ x   : list()
[10:21:38.592]  $ name: chr "a"
[10:21:38.592]  - attr(*, "where")=List of 2
[10:21:38.592]   ..$ x   :<environment: R_EmptyEnv> 
[10:21:38.592]   ..$ name:<environment: R_EmptyEnv> 
[10:21:38.592]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:38.592]  - attr(*, "resolved")= logi TRUE
[10:21:38.592]  - attr(*, "total_size")= num 71
[10:21:38.592]  - attr(*, "already-done")= logi TRUE
[10:21:38.594] - copied ‘x’ to environment
[10:21:38.595] - copied ‘name’ to environment
[10:21:38.595] assign_globals() ... done
[10:21:38.595] plan(): Setting new future strategy stack:
[10:21:38.595] List of future strategies:
[10:21:38.595] 1. sequential:
[10:21:38.595]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.595]    - tweaked: FALSE
[10:21:38.595]    - call: NULL
[10:21:38.595] plan(): nbrOfWorkers() = 1
[10:21:38.596] plan(): Setting new future strategy stack:
[10:21:38.596] List of future strategies:
[10:21:38.596] 1. sequential:
[10:21:38.596]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.596]    - tweaked: FALSE
[10:21:38.596]    - call: plan(strategy)
[10:21:38.597] plan(): nbrOfWorkers() = 1
[10:21:38.597] SequentialFuture started (and completed)
[10:21:38.597] - Launch lazy future ... done
[10:21:38.597] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[10:21:38.604] plan(): Setting new future strategy stack:
[10:21:38.604] List of future strategies:
[10:21:38.604] 1. multicore:
[10:21:38.604]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:38.604]    - tweaked: FALSE
[10:21:38.604]    - call: plan(strategy)
[10:21:38.605] plan(): nbrOfWorkers() = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.606] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.606] Searching for globals...
[10:21:38.608] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:38.608] Searching for globals ... DONE
[10:21:38.608] Resolving globals: TRUE
[10:21:38.608] Resolving any globals that are futures ...
[10:21:38.608] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:38.608] Resolving any globals that are futures ... DONE
[10:21:38.608] Resolving futures part of globals (recursively) ...
[10:21:38.609] resolve() on list ...
[10:21:38.609]  recursive: 99
[10:21:38.609]  length: 1
[10:21:38.609]  elements: ‘x’
[10:21:38.609]  length: 0 (resolved future 1)
[10:21:38.609] resolve() on list ... DONE
[10:21:38.609] - globals: [1] ‘x’
[10:21:38.611] Resolving futures part of globals (recursively) ... DONE
[10:21:38.611] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:38.611] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:38.611] - globals: [1] ‘x’
[10:21:38.611] 
[10:21:38.611] getGlobalsAndPackages() ... DONE
[10:21:38.612] run() for ‘Future’ ...
[10:21:38.612] - state: ‘created’
[10:21:38.612] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:38.613] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:38.614] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:38.614]   - Field: ‘label’
[10:21:38.614]   - Field: ‘local’
[10:21:38.614]   - Field: ‘owner’
[10:21:38.614]   - Field: ‘envir’
[10:21:38.614]   - Field: ‘workers’
[10:21:38.614]   - Field: ‘packages’
[10:21:38.614]   - Field: ‘gc’
[10:21:38.614]   - Field: ‘job’
[10:21:38.614]   - Field: ‘conditions’
[10:21:38.615]   - Field: ‘expr’
[10:21:38.615]   - Field: ‘uuid’
[10:21:38.615]   - Field: ‘seed’
[10:21:38.615]   - Field: ‘version’
[10:21:38.615]   - Field: ‘result’
[10:21:38.615]   - Field: ‘asynchronous’
[10:21:38.615]   - Field: ‘calls’
[10:21:38.615]   - Field: ‘globals’
[10:21:38.615]   - Field: ‘stdout’
[10:21:38.615]   - Field: ‘earlySignal’
[10:21:38.615]   - Field: ‘lazy’
[10:21:38.615]   - Field: ‘state’
[10:21:38.616] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:38.616] - Launch lazy future ...
[10:21:38.617] Packages needed by the future expression (n = 0): <none>
[10:21:38.617] Packages needed by future strategies (n = 0): <none>
[10:21:38.617] {
[10:21:38.617]     {
[10:21:38.617]         {
[10:21:38.617]             ...future.startTime <- base::Sys.time()
[10:21:38.617]             {
[10:21:38.617]                 {
[10:21:38.617]                   {
[10:21:38.617]                     {
[10:21:38.617]                       base::local({
[10:21:38.617]                         has_future <- base::requireNamespace("future", 
[10:21:38.617]                           quietly = TRUE)
[10:21:38.617]                         if (has_future) {
[10:21:38.617]                           ns <- base::getNamespace("future")
[10:21:38.617]                           version <- ns[[".package"]][["version"]]
[10:21:38.617]                           if (is.null(version)) 
[10:21:38.617]                             version <- utils::packageVersion("future")
[10:21:38.617]                         }
[10:21:38.617]                         else {
[10:21:38.617]                           version <- NULL
[10:21:38.617]                         }
[10:21:38.617]                         if (!has_future || version < "1.8.0") {
[10:21:38.617]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.617]                             "", base::R.version$version.string), 
[10:21:38.617]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:38.617]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.617]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.617]                               "release", "version")], collapse = " "), 
[10:21:38.617]                             hostname = base::Sys.info()[["nodename"]])
[10:21:38.617]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.617]                             info)
[10:21:38.617]                           info <- base::paste(info, collapse = "; ")
[10:21:38.617]                           if (!has_future) {
[10:21:38.617]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.617]                               info)
[10:21:38.617]                           }
[10:21:38.617]                           else {
[10:21:38.617]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.617]                               info, version)
[10:21:38.617]                           }
[10:21:38.617]                           base::stop(msg)
[10:21:38.617]                         }
[10:21:38.617]                       })
[10:21:38.617]                     }
[10:21:38.617]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:38.617]                     base::options(mc.cores = 1L)
[10:21:38.617]                   }
[10:21:38.617]                   ...future.strategy.old <- future::plan("list")
[10:21:38.617]                   options(future.plan = NULL)
[10:21:38.617]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.617]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.617]                 }
[10:21:38.617]                 ...future.workdir <- getwd()
[10:21:38.617]             }
[10:21:38.617]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.617]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.617]         }
[10:21:38.617]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.617]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.617]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.617]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.617]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.617]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.617]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.617]             base::names(...future.oldOptions))
[10:21:38.617]     }
[10:21:38.617]     if (FALSE) {
[10:21:38.617]     }
[10:21:38.617]     else {
[10:21:38.617]         if (TRUE) {
[10:21:38.617]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.617]                 open = "w")
[10:21:38.617]         }
[10:21:38.617]         else {
[10:21:38.617]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.617]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.617]         }
[10:21:38.617]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.617]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.617]             base::sink(type = "output", split = FALSE)
[10:21:38.617]             base::close(...future.stdout)
[10:21:38.617]         }, add = TRUE)
[10:21:38.617]     }
[10:21:38.617]     ...future.frame <- base::sys.nframe()
[10:21:38.617]     ...future.conditions <- base::list()
[10:21:38.617]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.617]     if (FALSE) {
[10:21:38.617]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.617]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.617]     }
[10:21:38.617]     ...future.result <- base::tryCatch({
[10:21:38.617]         base::withCallingHandlers({
[10:21:38.617]             ...future.value <- base::withVisible(base::local({
[10:21:38.617]                 withCallingHandlers({
[10:21:38.617]                   {
[10:21:38.617]                     x$a <- 1
[10:21:38.617]                     x
[10:21:38.617]                   }
[10:21:38.617]                 }, immediateCondition = function(cond) {
[10:21:38.617]                   save_rds <- function (object, pathname, ...) 
[10:21:38.617]                   {
[10:21:38.617]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:38.617]                     if (file_test("-f", pathname_tmp)) {
[10:21:38.617]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.617]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:38.617]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.617]                         fi_tmp[["mtime"]])
[10:21:38.617]                     }
[10:21:38.617]                     tryCatch({
[10:21:38.617]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:38.617]                     }, error = function(ex) {
[10:21:38.617]                       msg <- conditionMessage(ex)
[10:21:38.617]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.617]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:38.617]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.617]                         fi_tmp[["mtime"]], msg)
[10:21:38.617]                       ex$message <- msg
[10:21:38.617]                       stop(ex)
[10:21:38.617]                     })
[10:21:38.617]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:38.617]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:38.617]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:38.617]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.617]                       fi <- file.info(pathname)
[10:21:38.617]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:38.617]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.617]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:38.617]                         fi[["size"]], fi[["mtime"]])
[10:21:38.617]                       stop(msg)
[10:21:38.617]                     }
[10:21:38.617]                     invisible(pathname)
[10:21:38.617]                   }
[10:21:38.617]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:38.617]                     rootPath = tempdir()) 
[10:21:38.617]                   {
[10:21:38.617]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:38.617]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:38.617]                       tmpdir = path, fileext = ".rds")
[10:21:38.617]                     save_rds(obj, file)
[10:21:38.617]                   }
[10:21:38.617]                   saveImmediateCondition(cond, path = "/tmp/Rtmpfpiz4I/.future/immediateConditions")
[10:21:38.617]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.617]                   {
[10:21:38.617]                     inherits <- base::inherits
[10:21:38.617]                     invokeRestart <- base::invokeRestart
[10:21:38.617]                     is.null <- base::is.null
[10:21:38.617]                     muffled <- FALSE
[10:21:38.617]                     if (inherits(cond, "message")) {
[10:21:38.617]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:38.617]                       if (muffled) 
[10:21:38.617]                         invokeRestart("muffleMessage")
[10:21:38.617]                     }
[10:21:38.617]                     else if (inherits(cond, "warning")) {
[10:21:38.617]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:38.617]                       if (muffled) 
[10:21:38.617]                         invokeRestart("muffleWarning")
[10:21:38.617]                     }
[10:21:38.617]                     else if (inherits(cond, "condition")) {
[10:21:38.617]                       if (!is.null(pattern)) {
[10:21:38.617]                         computeRestarts <- base::computeRestarts
[10:21:38.617]                         grepl <- base::grepl
[10:21:38.617]                         restarts <- computeRestarts(cond)
[10:21:38.617]                         for (restart in restarts) {
[10:21:38.617]                           name <- restart$name
[10:21:38.617]                           if (is.null(name)) 
[10:21:38.617]                             next
[10:21:38.617]                           if (!grepl(pattern, name)) 
[10:21:38.617]                             next
[10:21:38.617]                           invokeRestart(restart)
[10:21:38.617]                           muffled <- TRUE
[10:21:38.617]                           break
[10:21:38.617]                         }
[10:21:38.617]                       }
[10:21:38.617]                     }
[10:21:38.617]                     invisible(muffled)
[10:21:38.617]                   }
[10:21:38.617]                   muffleCondition(cond)
[10:21:38.617]                 })
[10:21:38.617]             }))
[10:21:38.617]             future::FutureResult(value = ...future.value$value, 
[10:21:38.617]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.617]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.617]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.617]                     ...future.globalenv.names))
[10:21:38.617]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.617]         }, condition = base::local({
[10:21:38.617]             c <- base::c
[10:21:38.617]             inherits <- base::inherits
[10:21:38.617]             invokeRestart <- base::invokeRestart
[10:21:38.617]             length <- base::length
[10:21:38.617]             list <- base::list
[10:21:38.617]             seq.int <- base::seq.int
[10:21:38.617]             signalCondition <- base::signalCondition
[10:21:38.617]             sys.calls <- base::sys.calls
[10:21:38.617]             `[[` <- base::`[[`
[10:21:38.617]             `+` <- base::`+`
[10:21:38.617]             `<<-` <- base::`<<-`
[10:21:38.617]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.617]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.617]                   3L)]
[10:21:38.617]             }
[10:21:38.617]             function(cond) {
[10:21:38.617]                 is_error <- inherits(cond, "error")
[10:21:38.617]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.617]                   NULL)
[10:21:38.617]                 if (is_error) {
[10:21:38.617]                   sessionInformation <- function() {
[10:21:38.617]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.617]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.617]                       search = base::search(), system = base::Sys.info())
[10:21:38.617]                   }
[10:21:38.617]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.617]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.617]                     cond$call), session = sessionInformation(), 
[10:21:38.617]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.617]                   signalCondition(cond)
[10:21:38.617]                 }
[10:21:38.617]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.617]                 "immediateCondition"))) {
[10:21:38.617]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.617]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.617]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.617]                   if (TRUE && !signal) {
[10:21:38.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.617]                     {
[10:21:38.617]                       inherits <- base::inherits
[10:21:38.617]                       invokeRestart <- base::invokeRestart
[10:21:38.617]                       is.null <- base::is.null
[10:21:38.617]                       muffled <- FALSE
[10:21:38.617]                       if (inherits(cond, "message")) {
[10:21:38.617]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.617]                         if (muffled) 
[10:21:38.617]                           invokeRestart("muffleMessage")
[10:21:38.617]                       }
[10:21:38.617]                       else if (inherits(cond, "warning")) {
[10:21:38.617]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.617]                         if (muffled) 
[10:21:38.617]                           invokeRestart("muffleWarning")
[10:21:38.617]                       }
[10:21:38.617]                       else if (inherits(cond, "condition")) {
[10:21:38.617]                         if (!is.null(pattern)) {
[10:21:38.617]                           computeRestarts <- base::computeRestarts
[10:21:38.617]                           grepl <- base::grepl
[10:21:38.617]                           restarts <- computeRestarts(cond)
[10:21:38.617]                           for (restart in restarts) {
[10:21:38.617]                             name <- restart$name
[10:21:38.617]                             if (is.null(name)) 
[10:21:38.617]                               next
[10:21:38.617]                             if (!grepl(pattern, name)) 
[10:21:38.617]                               next
[10:21:38.617]                             invokeRestart(restart)
[10:21:38.617]                             muffled <- TRUE
[10:21:38.617]                             break
[10:21:38.617]                           }
[10:21:38.617]                         }
[10:21:38.617]                       }
[10:21:38.617]                       invisible(muffled)
[10:21:38.617]                     }
[10:21:38.617]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.617]                   }
[10:21:38.617]                 }
[10:21:38.617]                 else {
[10:21:38.617]                   if (TRUE) {
[10:21:38.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.617]                     {
[10:21:38.617]                       inherits <- base::inherits
[10:21:38.617]                       invokeRestart <- base::invokeRestart
[10:21:38.617]                       is.null <- base::is.null
[10:21:38.617]                       muffled <- FALSE
[10:21:38.617]                       if (inherits(cond, "message")) {
[10:21:38.617]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.617]                         if (muffled) 
[10:21:38.617]                           invokeRestart("muffleMessage")
[10:21:38.617]                       }
[10:21:38.617]                       else if (inherits(cond, "warning")) {
[10:21:38.617]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.617]                         if (muffled) 
[10:21:38.617]                           invokeRestart("muffleWarning")
[10:21:38.617]                       }
[10:21:38.617]                       else if (inherits(cond, "condition")) {
[10:21:38.617]                         if (!is.null(pattern)) {
[10:21:38.617]                           computeRestarts <- base::computeRestarts
[10:21:38.617]                           grepl <- base::grepl
[10:21:38.617]                           restarts <- computeRestarts(cond)
[10:21:38.617]                           for (restart in restarts) {
[10:21:38.617]                             name <- restart$name
[10:21:38.617]                             if (is.null(name)) 
[10:21:38.617]                               next
[10:21:38.617]                             if (!grepl(pattern, name)) 
[10:21:38.617]                               next
[10:21:38.617]                             invokeRestart(restart)
[10:21:38.617]                             muffled <- TRUE
[10:21:38.617]                             break
[10:21:38.617]                           }
[10:21:38.617]                         }
[10:21:38.617]                       }
[10:21:38.617]                       invisible(muffled)
[10:21:38.617]                     }
[10:21:38.617]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.617]                   }
[10:21:38.617]                 }
[10:21:38.617]             }
[10:21:38.617]         }))
[10:21:38.617]     }, error = function(ex) {
[10:21:38.617]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.617]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.617]                 ...future.rng), started = ...future.startTime, 
[10:21:38.617]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.617]             version = "1.8"), class = "FutureResult")
[10:21:38.617]     }, finally = {
[10:21:38.617]         if (!identical(...future.workdir, getwd())) 
[10:21:38.617]             setwd(...future.workdir)
[10:21:38.617]         {
[10:21:38.617]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.617]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.617]             }
[10:21:38.617]             base::options(...future.oldOptions)
[10:21:38.617]             if (.Platform$OS.type == "windows") {
[10:21:38.617]                 old_names <- names(...future.oldEnvVars)
[10:21:38.617]                 envs <- base::Sys.getenv()
[10:21:38.617]                 names <- names(envs)
[10:21:38.617]                 common <- intersect(names, old_names)
[10:21:38.617]                 added <- setdiff(names, old_names)
[10:21:38.617]                 removed <- setdiff(old_names, names)
[10:21:38.617]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.617]                   envs[common]]
[10:21:38.617]                 NAMES <- toupper(changed)
[10:21:38.617]                 args <- list()
[10:21:38.617]                 for (kk in seq_along(NAMES)) {
[10:21:38.617]                   name <- changed[[kk]]
[10:21:38.617]                   NAME <- NAMES[[kk]]
[10:21:38.617]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.617]                     next
[10:21:38.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.617]                 }
[10:21:38.617]                 NAMES <- toupper(added)
[10:21:38.617]                 for (kk in seq_along(NAMES)) {
[10:21:38.617]                   name <- added[[kk]]
[10:21:38.617]                   NAME <- NAMES[[kk]]
[10:21:38.617]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.617]                     next
[10:21:38.617]                   args[[name]] <- ""
[10:21:38.617]                 }
[10:21:38.617]                 NAMES <- toupper(removed)
[10:21:38.617]                 for (kk in seq_along(NAMES)) {
[10:21:38.617]                   name <- removed[[kk]]
[10:21:38.617]                   NAME <- NAMES[[kk]]
[10:21:38.617]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.617]                     next
[10:21:38.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.617]                 }
[10:21:38.617]                 if (length(args) > 0) 
[10:21:38.617]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.617]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.617]             }
[10:21:38.617]             else {
[10:21:38.617]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.617]             }
[10:21:38.617]             {
[10:21:38.617]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.617]                   0L) {
[10:21:38.617]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.617]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.617]                   base::options(opts)
[10:21:38.617]                 }
[10:21:38.617]                 {
[10:21:38.617]                   {
[10:21:38.617]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:38.617]                     NULL
[10:21:38.617]                   }
[10:21:38.617]                   options(future.plan = NULL)
[10:21:38.617]                   if (is.na(NA_character_)) 
[10:21:38.617]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.617]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.617]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.617]                     .init = FALSE)
[10:21:38.617]                 }
[10:21:38.617]             }
[10:21:38.617]         }
[10:21:38.617]     })
[10:21:38.617]     if (TRUE) {
[10:21:38.617]         base::sink(type = "output", split = FALSE)
[10:21:38.617]         if (TRUE) {
[10:21:38.617]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.617]         }
[10:21:38.617]         else {
[10:21:38.617]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.617]         }
[10:21:38.617]         base::close(...future.stdout)
[10:21:38.617]         ...future.stdout <- NULL
[10:21:38.617]     }
[10:21:38.617]     ...future.result$conditions <- ...future.conditions
[10:21:38.617]     ...future.result$finished <- base::Sys.time()
[10:21:38.617]     ...future.result
[10:21:38.617] }
[10:21:38.619] assign_globals() ...
[10:21:38.619] List of 1
[10:21:38.619]  $ x: list()
[10:21:38.619]  - attr(*, "where")=List of 1
[10:21:38.619]   ..$ x:<environment: R_EmptyEnv> 
[10:21:38.619]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:38.619]  - attr(*, "resolved")= logi TRUE
[10:21:38.619]  - attr(*, "total_size")= num 31
[10:21:38.619]  - attr(*, "already-done")= logi TRUE
[10:21:38.622] - copied ‘x’ to environment
[10:21:38.622] assign_globals() ... done
[10:21:38.622] requestCore(): workers = 2
[10:21:38.625] MulticoreFuture started
[10:21:38.625] - Launch lazy future ... done
[10:21:38.625] plan(): Setting new future strategy stack:
[10:21:38.625] run() for ‘MulticoreFuture’ ... done
[10:21:38.626] List of future strategies:
[10:21:38.626] 1. sequential:
[10:21:38.626]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.626]    - tweaked: FALSE
[10:21:38.626]    - call: NULL
[10:21:38.627] result() for MulticoreFuture ...
[10:21:38.627] plan(): nbrOfWorkers() = 1
[10:21:38.629] plan(): Setting new future strategy stack:
[10:21:38.629] List of future strategies:
[10:21:38.629] 1. multicore:
[10:21:38.629]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:38.629]    - tweaked: FALSE
[10:21:38.629]    - call: plan(strategy)
[10:21:38.632] plan(): nbrOfWorkers() = 2
[10:21:38.637] result() for MulticoreFuture ...
[10:21:38.637] result() for MulticoreFuture ... done
[10:21:38.637] result() for MulticoreFuture ... done
[10:21:38.637] result() for MulticoreFuture ...
[10:21:38.637] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.638] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.638] Searching for globals...
[10:21:38.641] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:38.641] Searching for globals ... DONE
[10:21:38.641] Resolving globals: TRUE
[10:21:38.641] Resolving any globals that are futures ...
[10:21:38.641] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:38.641] Resolving any globals that are futures ... DONE
[10:21:38.642] Resolving futures part of globals (recursively) ...
[10:21:38.642] resolve() on list ...
[10:21:38.642]  recursive: 99
[10:21:38.642]  length: 1
[10:21:38.642]  elements: ‘x’
[10:21:38.643]  length: 0 (resolved future 1)
[10:21:38.643] resolve() on list ... DONE
[10:21:38.643] - globals: [1] ‘x’
[10:21:38.643] Resolving futures part of globals (recursively) ... DONE
[10:21:38.643] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:38.643] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:38.644] - globals: [1] ‘x’
[10:21:38.644] 
[10:21:38.644] getGlobalsAndPackages() ... DONE
[10:21:38.644] run() for ‘Future’ ...
[10:21:38.644] - state: ‘created’
[10:21:38.644] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:38.646] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:38.647] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:38.647]   - Field: ‘label’
[10:21:38.647]   - Field: ‘local’
[10:21:38.647]   - Field: ‘owner’
[10:21:38.647]   - Field: ‘envir’
[10:21:38.647]   - Field: ‘workers’
[10:21:38.647]   - Field: ‘packages’
[10:21:38.647]   - Field: ‘gc’
[10:21:38.648]   - Field: ‘job’
[10:21:38.648]   - Field: ‘conditions’
[10:21:38.648]   - Field: ‘expr’
[10:21:38.648]   - Field: ‘uuid’
[10:21:38.648]   - Field: ‘seed’
[10:21:38.648]   - Field: ‘version’
[10:21:38.648]   - Field: ‘result’
[10:21:38.648]   - Field: ‘asynchronous’
[10:21:38.648]   - Field: ‘calls’
[10:21:38.648]   - Field: ‘globals’
[10:21:38.649]   - Field: ‘stdout’
[10:21:38.649]   - Field: ‘earlySignal’
[10:21:38.649]   - Field: ‘lazy’
[10:21:38.649]   - Field: ‘state’
[10:21:38.649] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:38.649] - Launch lazy future ...
[10:21:38.649] Packages needed by the future expression (n = 0): <none>
[10:21:38.650] Packages needed by future strategies (n = 0): <none>
[10:21:38.650] {
[10:21:38.650]     {
[10:21:38.650]         {
[10:21:38.650]             ...future.startTime <- base::Sys.time()
[10:21:38.650]             {
[10:21:38.650]                 {
[10:21:38.650]                   {
[10:21:38.650]                     {
[10:21:38.650]                       base::local({
[10:21:38.650]                         has_future <- base::requireNamespace("future", 
[10:21:38.650]                           quietly = TRUE)
[10:21:38.650]                         if (has_future) {
[10:21:38.650]                           ns <- base::getNamespace("future")
[10:21:38.650]                           version <- ns[[".package"]][["version"]]
[10:21:38.650]                           if (is.null(version)) 
[10:21:38.650]                             version <- utils::packageVersion("future")
[10:21:38.650]                         }
[10:21:38.650]                         else {
[10:21:38.650]                           version <- NULL
[10:21:38.650]                         }
[10:21:38.650]                         if (!has_future || version < "1.8.0") {
[10:21:38.650]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.650]                             "", base::R.version$version.string), 
[10:21:38.650]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:38.650]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.650]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.650]                               "release", "version")], collapse = " "), 
[10:21:38.650]                             hostname = base::Sys.info()[["nodename"]])
[10:21:38.650]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.650]                             info)
[10:21:38.650]                           info <- base::paste(info, collapse = "; ")
[10:21:38.650]                           if (!has_future) {
[10:21:38.650]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.650]                               info)
[10:21:38.650]                           }
[10:21:38.650]                           else {
[10:21:38.650]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.650]                               info, version)
[10:21:38.650]                           }
[10:21:38.650]                           base::stop(msg)
[10:21:38.650]                         }
[10:21:38.650]                       })
[10:21:38.650]                     }
[10:21:38.650]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:38.650]                     base::options(mc.cores = 1L)
[10:21:38.650]                   }
[10:21:38.650]                   ...future.strategy.old <- future::plan("list")
[10:21:38.650]                   options(future.plan = NULL)
[10:21:38.650]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.650]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.650]                 }
[10:21:38.650]                 ...future.workdir <- getwd()
[10:21:38.650]             }
[10:21:38.650]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.650]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.650]         }
[10:21:38.650]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.650]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.650]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.650]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.650]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.650]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.650]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.650]             base::names(...future.oldOptions))
[10:21:38.650]     }
[10:21:38.650]     if (FALSE) {
[10:21:38.650]     }
[10:21:38.650]     else {
[10:21:38.650]         if (TRUE) {
[10:21:38.650]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.650]                 open = "w")
[10:21:38.650]         }
[10:21:38.650]         else {
[10:21:38.650]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.650]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.650]         }
[10:21:38.650]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.650]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.650]             base::sink(type = "output", split = FALSE)
[10:21:38.650]             base::close(...future.stdout)
[10:21:38.650]         }, add = TRUE)
[10:21:38.650]     }
[10:21:38.650]     ...future.frame <- base::sys.nframe()
[10:21:38.650]     ...future.conditions <- base::list()
[10:21:38.650]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.650]     if (FALSE) {
[10:21:38.650]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.650]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.650]     }
[10:21:38.650]     ...future.result <- base::tryCatch({
[10:21:38.650]         base::withCallingHandlers({
[10:21:38.650]             ...future.value <- base::withVisible(base::local({
[10:21:38.650]                 withCallingHandlers({
[10:21:38.650]                   {
[10:21:38.650]                     x$a <- 1
[10:21:38.650]                     x
[10:21:38.650]                   }
[10:21:38.650]                 }, immediateCondition = function(cond) {
[10:21:38.650]                   save_rds <- function (object, pathname, ...) 
[10:21:38.650]                   {
[10:21:38.650]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:38.650]                     if (file_test("-f", pathname_tmp)) {
[10:21:38.650]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.650]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:38.650]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.650]                         fi_tmp[["mtime"]])
[10:21:38.650]                     }
[10:21:38.650]                     tryCatch({
[10:21:38.650]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:38.650]                     }, error = function(ex) {
[10:21:38.650]                       msg <- conditionMessage(ex)
[10:21:38.650]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.650]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:38.650]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.650]                         fi_tmp[["mtime"]], msg)
[10:21:38.650]                       ex$message <- msg
[10:21:38.650]                       stop(ex)
[10:21:38.650]                     })
[10:21:38.650]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:38.650]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:38.650]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:38.650]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.650]                       fi <- file.info(pathname)
[10:21:38.650]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:38.650]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.650]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:38.650]                         fi[["size"]], fi[["mtime"]])
[10:21:38.650]                       stop(msg)
[10:21:38.650]                     }
[10:21:38.650]                     invisible(pathname)
[10:21:38.650]                   }
[10:21:38.650]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:38.650]                     rootPath = tempdir()) 
[10:21:38.650]                   {
[10:21:38.650]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:38.650]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:38.650]                       tmpdir = path, fileext = ".rds")
[10:21:38.650]                     save_rds(obj, file)
[10:21:38.650]                   }
[10:21:38.650]                   saveImmediateCondition(cond, path = "/tmp/Rtmpfpiz4I/.future/immediateConditions")
[10:21:38.650]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.650]                   {
[10:21:38.650]                     inherits <- base::inherits
[10:21:38.650]                     invokeRestart <- base::invokeRestart
[10:21:38.650]                     is.null <- base::is.null
[10:21:38.650]                     muffled <- FALSE
[10:21:38.650]                     if (inherits(cond, "message")) {
[10:21:38.650]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:38.650]                       if (muffled) 
[10:21:38.650]                         invokeRestart("muffleMessage")
[10:21:38.650]                     }
[10:21:38.650]                     else if (inherits(cond, "warning")) {
[10:21:38.650]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:38.650]                       if (muffled) 
[10:21:38.650]                         invokeRestart("muffleWarning")
[10:21:38.650]                     }
[10:21:38.650]                     else if (inherits(cond, "condition")) {
[10:21:38.650]                       if (!is.null(pattern)) {
[10:21:38.650]                         computeRestarts <- base::computeRestarts
[10:21:38.650]                         grepl <- base::grepl
[10:21:38.650]                         restarts <- computeRestarts(cond)
[10:21:38.650]                         for (restart in restarts) {
[10:21:38.650]                           name <- restart$name
[10:21:38.650]                           if (is.null(name)) 
[10:21:38.650]                             next
[10:21:38.650]                           if (!grepl(pattern, name)) 
[10:21:38.650]                             next
[10:21:38.650]                           invokeRestart(restart)
[10:21:38.650]                           muffled <- TRUE
[10:21:38.650]                           break
[10:21:38.650]                         }
[10:21:38.650]                       }
[10:21:38.650]                     }
[10:21:38.650]                     invisible(muffled)
[10:21:38.650]                   }
[10:21:38.650]                   muffleCondition(cond)
[10:21:38.650]                 })
[10:21:38.650]             }))
[10:21:38.650]             future::FutureResult(value = ...future.value$value, 
[10:21:38.650]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.650]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.650]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.650]                     ...future.globalenv.names))
[10:21:38.650]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.650]         }, condition = base::local({
[10:21:38.650]             c <- base::c
[10:21:38.650]             inherits <- base::inherits
[10:21:38.650]             invokeRestart <- base::invokeRestart
[10:21:38.650]             length <- base::length
[10:21:38.650]             list <- base::list
[10:21:38.650]             seq.int <- base::seq.int
[10:21:38.650]             signalCondition <- base::signalCondition
[10:21:38.650]             sys.calls <- base::sys.calls
[10:21:38.650]             `[[` <- base::`[[`
[10:21:38.650]             `+` <- base::`+`
[10:21:38.650]             `<<-` <- base::`<<-`
[10:21:38.650]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.650]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.650]                   3L)]
[10:21:38.650]             }
[10:21:38.650]             function(cond) {
[10:21:38.650]                 is_error <- inherits(cond, "error")
[10:21:38.650]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.650]                   NULL)
[10:21:38.650]                 if (is_error) {
[10:21:38.650]                   sessionInformation <- function() {
[10:21:38.650]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.650]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.650]                       search = base::search(), system = base::Sys.info())
[10:21:38.650]                   }
[10:21:38.650]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.650]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.650]                     cond$call), session = sessionInformation(), 
[10:21:38.650]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.650]                   signalCondition(cond)
[10:21:38.650]                 }
[10:21:38.650]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.650]                 "immediateCondition"))) {
[10:21:38.650]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.650]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.650]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.650]                   if (TRUE && !signal) {
[10:21:38.650]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.650]                     {
[10:21:38.650]                       inherits <- base::inherits
[10:21:38.650]                       invokeRestart <- base::invokeRestart
[10:21:38.650]                       is.null <- base::is.null
[10:21:38.650]                       muffled <- FALSE
[10:21:38.650]                       if (inherits(cond, "message")) {
[10:21:38.650]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.650]                         if (muffled) 
[10:21:38.650]                           invokeRestart("muffleMessage")
[10:21:38.650]                       }
[10:21:38.650]                       else if (inherits(cond, "warning")) {
[10:21:38.650]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.650]                         if (muffled) 
[10:21:38.650]                           invokeRestart("muffleWarning")
[10:21:38.650]                       }
[10:21:38.650]                       else if (inherits(cond, "condition")) {
[10:21:38.650]                         if (!is.null(pattern)) {
[10:21:38.650]                           computeRestarts <- base::computeRestarts
[10:21:38.650]                           grepl <- base::grepl
[10:21:38.650]                           restarts <- computeRestarts(cond)
[10:21:38.650]                           for (restart in restarts) {
[10:21:38.650]                             name <- restart$name
[10:21:38.650]                             if (is.null(name)) 
[10:21:38.650]                               next
[10:21:38.650]                             if (!grepl(pattern, name)) 
[10:21:38.650]                               next
[10:21:38.650]                             invokeRestart(restart)
[10:21:38.650]                             muffled <- TRUE
[10:21:38.650]                             break
[10:21:38.650]                           }
[10:21:38.650]                         }
[10:21:38.650]                       }
[10:21:38.650]                       invisible(muffled)
[10:21:38.650]                     }
[10:21:38.650]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.650]                   }
[10:21:38.650]                 }
[10:21:38.650]                 else {
[10:21:38.650]                   if (TRUE) {
[10:21:38.650]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.650]                     {
[10:21:38.650]                       inherits <- base::inherits
[10:21:38.650]                       invokeRestart <- base::invokeRestart
[10:21:38.650]                       is.null <- base::is.null
[10:21:38.650]                       muffled <- FALSE
[10:21:38.650]                       if (inherits(cond, "message")) {
[10:21:38.650]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.650]                         if (muffled) 
[10:21:38.650]                           invokeRestart("muffleMessage")
[10:21:38.650]                       }
[10:21:38.650]                       else if (inherits(cond, "warning")) {
[10:21:38.650]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.650]                         if (muffled) 
[10:21:38.650]                           invokeRestart("muffleWarning")
[10:21:38.650]                       }
[10:21:38.650]                       else if (inherits(cond, "condition")) {
[10:21:38.650]                         if (!is.null(pattern)) {
[10:21:38.650]                           computeRestarts <- base::computeRestarts
[10:21:38.650]                           grepl <- base::grepl
[10:21:38.650]                           restarts <- computeRestarts(cond)
[10:21:38.650]                           for (restart in restarts) {
[10:21:38.650]                             name <- restart$name
[10:21:38.650]                             if (is.null(name)) 
[10:21:38.650]                               next
[10:21:38.650]                             if (!grepl(pattern, name)) 
[10:21:38.650]                               next
[10:21:38.650]                             invokeRestart(restart)
[10:21:38.650]                             muffled <- TRUE
[10:21:38.650]                             break
[10:21:38.650]                           }
[10:21:38.650]                         }
[10:21:38.650]                       }
[10:21:38.650]                       invisible(muffled)
[10:21:38.650]                     }
[10:21:38.650]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.650]                   }
[10:21:38.650]                 }
[10:21:38.650]             }
[10:21:38.650]         }))
[10:21:38.650]     }, error = function(ex) {
[10:21:38.650]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.650]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.650]                 ...future.rng), started = ...future.startTime, 
[10:21:38.650]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.650]             version = "1.8"), class = "FutureResult")
[10:21:38.650]     }, finally = {
[10:21:38.650]         if (!identical(...future.workdir, getwd())) 
[10:21:38.650]             setwd(...future.workdir)
[10:21:38.650]         {
[10:21:38.650]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.650]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.650]             }
[10:21:38.650]             base::options(...future.oldOptions)
[10:21:38.650]             if (.Platform$OS.type == "windows") {
[10:21:38.650]                 old_names <- names(...future.oldEnvVars)
[10:21:38.650]                 envs <- base::Sys.getenv()
[10:21:38.650]                 names <- names(envs)
[10:21:38.650]                 common <- intersect(names, old_names)
[10:21:38.650]                 added <- setdiff(names, old_names)
[10:21:38.650]                 removed <- setdiff(old_names, names)
[10:21:38.650]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.650]                   envs[common]]
[10:21:38.650]                 NAMES <- toupper(changed)
[10:21:38.650]                 args <- list()
[10:21:38.650]                 for (kk in seq_along(NAMES)) {
[10:21:38.650]                   name <- changed[[kk]]
[10:21:38.650]                   NAME <- NAMES[[kk]]
[10:21:38.650]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.650]                     next
[10:21:38.650]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.650]                 }
[10:21:38.650]                 NAMES <- toupper(added)
[10:21:38.650]                 for (kk in seq_along(NAMES)) {
[10:21:38.650]                   name <- added[[kk]]
[10:21:38.650]                   NAME <- NAMES[[kk]]
[10:21:38.650]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.650]                     next
[10:21:38.650]                   args[[name]] <- ""
[10:21:38.650]                 }
[10:21:38.650]                 NAMES <- toupper(removed)
[10:21:38.650]                 for (kk in seq_along(NAMES)) {
[10:21:38.650]                   name <- removed[[kk]]
[10:21:38.650]                   NAME <- NAMES[[kk]]
[10:21:38.650]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.650]                     next
[10:21:38.650]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.650]                 }
[10:21:38.650]                 if (length(args) > 0) 
[10:21:38.650]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.650]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.650]             }
[10:21:38.650]             else {
[10:21:38.650]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.650]             }
[10:21:38.650]             {
[10:21:38.650]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.650]                   0L) {
[10:21:38.650]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.650]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.650]                   base::options(opts)
[10:21:38.650]                 }
[10:21:38.650]                 {
[10:21:38.650]                   {
[10:21:38.650]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:38.650]                     NULL
[10:21:38.650]                   }
[10:21:38.650]                   options(future.plan = NULL)
[10:21:38.650]                   if (is.na(NA_character_)) 
[10:21:38.650]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.650]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.650]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.650]                     .init = FALSE)
[10:21:38.650]                 }
[10:21:38.650]             }
[10:21:38.650]         }
[10:21:38.650]     })
[10:21:38.650]     if (TRUE) {
[10:21:38.650]         base::sink(type = "output", split = FALSE)
[10:21:38.650]         if (TRUE) {
[10:21:38.650]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.650]         }
[10:21:38.650]         else {
[10:21:38.650]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.650]         }
[10:21:38.650]         base::close(...future.stdout)
[10:21:38.650]         ...future.stdout <- NULL
[10:21:38.650]     }
[10:21:38.650]     ...future.result$conditions <- ...future.conditions
[10:21:38.650]     ...future.result$finished <- base::Sys.time()
[10:21:38.650]     ...future.result
[10:21:38.650] }
[10:21:38.653] assign_globals() ...
[10:21:38.653] List of 1
[10:21:38.653]  $ x: list()
[10:21:38.653]  - attr(*, "where")=List of 1
[10:21:38.653]   ..$ x:<environment: R_EmptyEnv> 
[10:21:38.653]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:38.653]  - attr(*, "resolved")= logi TRUE
[10:21:38.653]  - attr(*, "total_size")= num 31
[10:21:38.653]  - attr(*, "already-done")= logi TRUE
[10:21:38.659] - copied ‘x’ to environment
[10:21:38.659] assign_globals() ... done
[10:21:38.659] requestCore(): workers = 2
[10:21:38.661] MulticoreFuture started
[10:21:38.662] - Launch lazy future ... done
[10:21:38.662] run() for ‘MulticoreFuture’ ... done
[10:21:38.662] plan(): Setting new future strategy stack:
[10:21:38.662] result() for MulticoreFuture ...
[10:21:38.662] List of future strategies:
[10:21:38.662] 1. sequential:
[10:21:38.662]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.662]    - tweaked: FALSE
[10:21:38.662]    - call: NULL
[10:21:38.663] plan(): nbrOfWorkers() = 1
[10:21:38.665] plan(): Setting new future strategy stack:
[10:21:38.666] List of future strategies:
[10:21:38.666] 1. multicore:
[10:21:38.666]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:38.666]    - tweaked: FALSE
[10:21:38.666]    - call: plan(strategy)
[10:21:38.669] plan(): nbrOfWorkers() = 2
[10:21:38.670] result() for MulticoreFuture ...
[10:21:38.670] result() for MulticoreFuture ... done
[10:21:38.670] result() for MulticoreFuture ... done
[10:21:38.670] result() for MulticoreFuture ...
[10:21:38.671] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.671] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.672] Searching for globals...
[10:21:38.674] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:38.675] Searching for globals ... DONE
[10:21:38.675] Resolving globals: TRUE
[10:21:38.675] Resolving any globals that are futures ...
[10:21:38.675] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:38.675] Resolving any globals that are futures ... DONE
[10:21:38.676] Resolving futures part of globals (recursively) ...
[10:21:38.676] resolve() on list ...
[10:21:38.676]  recursive: 99
[10:21:38.676]  length: 1
[10:21:38.676]  elements: ‘x’
[10:21:38.676]  length: 0 (resolved future 1)
[10:21:38.677] resolve() on list ... DONE
[10:21:38.677] - globals: [1] ‘x’
[10:21:38.677] Resolving futures part of globals (recursively) ... DONE
[10:21:38.677] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:38.677] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:38.677] - globals: [1] ‘x’
[10:21:38.678] 
[10:21:38.678] getGlobalsAndPackages() ... DONE
[10:21:38.678] run() for ‘Future’ ...
[10:21:38.678] - state: ‘created’
[10:21:38.678] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:38.680] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:38.681] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:38.681]   - Field: ‘label’
[10:21:38.681]   - Field: ‘local’
[10:21:38.681]   - Field: ‘owner’
[10:21:38.681]   - Field: ‘envir’
[10:21:38.681]   - Field: ‘workers’
[10:21:38.681]   - Field: ‘packages’
[10:21:38.681]   - Field: ‘gc’
[10:21:38.681]   - Field: ‘job’
[10:21:38.682]   - Field: ‘conditions’
[10:21:38.682]   - Field: ‘expr’
[10:21:38.682]   - Field: ‘uuid’
[10:21:38.682]   - Field: ‘seed’
[10:21:38.682]   - Field: ‘version’
[10:21:38.682]   - Field: ‘result’
[10:21:38.682]   - Field: ‘asynchronous’
[10:21:38.682]   - Field: ‘calls’
[10:21:38.682]   - Field: ‘globals’
[10:21:38.683]   - Field: ‘stdout’
[10:21:38.683]   - Field: ‘earlySignal’
[10:21:38.683]   - Field: ‘lazy’
[10:21:38.683]   - Field: ‘state’
[10:21:38.683] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:38.683] - Launch lazy future ...
[10:21:38.683] Packages needed by the future expression (n = 0): <none>
[10:21:38.684] Packages needed by future strategies (n = 0): <none>
[10:21:38.684] {
[10:21:38.684]     {
[10:21:38.684]         {
[10:21:38.684]             ...future.startTime <- base::Sys.time()
[10:21:38.684]             {
[10:21:38.684]                 {
[10:21:38.684]                   {
[10:21:38.684]                     {
[10:21:38.684]                       base::local({
[10:21:38.684]                         has_future <- base::requireNamespace("future", 
[10:21:38.684]                           quietly = TRUE)
[10:21:38.684]                         if (has_future) {
[10:21:38.684]                           ns <- base::getNamespace("future")
[10:21:38.684]                           version <- ns[[".package"]][["version"]]
[10:21:38.684]                           if (is.null(version)) 
[10:21:38.684]                             version <- utils::packageVersion("future")
[10:21:38.684]                         }
[10:21:38.684]                         else {
[10:21:38.684]                           version <- NULL
[10:21:38.684]                         }
[10:21:38.684]                         if (!has_future || version < "1.8.0") {
[10:21:38.684]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.684]                             "", base::R.version$version.string), 
[10:21:38.684]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:38.684]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.684]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.684]                               "release", "version")], collapse = " "), 
[10:21:38.684]                             hostname = base::Sys.info()[["nodename"]])
[10:21:38.684]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.684]                             info)
[10:21:38.684]                           info <- base::paste(info, collapse = "; ")
[10:21:38.684]                           if (!has_future) {
[10:21:38.684]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.684]                               info)
[10:21:38.684]                           }
[10:21:38.684]                           else {
[10:21:38.684]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.684]                               info, version)
[10:21:38.684]                           }
[10:21:38.684]                           base::stop(msg)
[10:21:38.684]                         }
[10:21:38.684]                       })
[10:21:38.684]                     }
[10:21:38.684]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:38.684]                     base::options(mc.cores = 1L)
[10:21:38.684]                   }
[10:21:38.684]                   ...future.strategy.old <- future::plan("list")
[10:21:38.684]                   options(future.plan = NULL)
[10:21:38.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.684]                 }
[10:21:38.684]                 ...future.workdir <- getwd()
[10:21:38.684]             }
[10:21:38.684]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.684]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.684]         }
[10:21:38.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.684]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.684]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.684]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.684]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.684]             base::names(...future.oldOptions))
[10:21:38.684]     }
[10:21:38.684]     if (FALSE) {
[10:21:38.684]     }
[10:21:38.684]     else {
[10:21:38.684]         if (TRUE) {
[10:21:38.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.684]                 open = "w")
[10:21:38.684]         }
[10:21:38.684]         else {
[10:21:38.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.684]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.684]         }
[10:21:38.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.684]             base::sink(type = "output", split = FALSE)
[10:21:38.684]             base::close(...future.stdout)
[10:21:38.684]         }, add = TRUE)
[10:21:38.684]     }
[10:21:38.684]     ...future.frame <- base::sys.nframe()
[10:21:38.684]     ...future.conditions <- base::list()
[10:21:38.684]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.684]     if (FALSE) {
[10:21:38.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.684]     }
[10:21:38.684]     ...future.result <- base::tryCatch({
[10:21:38.684]         base::withCallingHandlers({
[10:21:38.684]             ...future.value <- base::withVisible(base::local({
[10:21:38.684]                 withCallingHandlers({
[10:21:38.684]                   {
[10:21:38.684]                     x$a <- 1
[10:21:38.684]                     x
[10:21:38.684]                   }
[10:21:38.684]                 }, immediateCondition = function(cond) {
[10:21:38.684]                   save_rds <- function (object, pathname, ...) 
[10:21:38.684]                   {
[10:21:38.684]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:38.684]                     if (file_test("-f", pathname_tmp)) {
[10:21:38.684]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.684]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:38.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.684]                         fi_tmp[["mtime"]])
[10:21:38.684]                     }
[10:21:38.684]                     tryCatch({
[10:21:38.684]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:38.684]                     }, error = function(ex) {
[10:21:38.684]                       msg <- conditionMessage(ex)
[10:21:38.684]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.684]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:38.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.684]                         fi_tmp[["mtime"]], msg)
[10:21:38.684]                       ex$message <- msg
[10:21:38.684]                       stop(ex)
[10:21:38.684]                     })
[10:21:38.684]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:38.684]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:38.684]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:38.684]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.684]                       fi <- file.info(pathname)
[10:21:38.684]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:38.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.684]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:38.684]                         fi[["size"]], fi[["mtime"]])
[10:21:38.684]                       stop(msg)
[10:21:38.684]                     }
[10:21:38.684]                     invisible(pathname)
[10:21:38.684]                   }
[10:21:38.684]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:38.684]                     rootPath = tempdir()) 
[10:21:38.684]                   {
[10:21:38.684]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:38.684]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:38.684]                       tmpdir = path, fileext = ".rds")
[10:21:38.684]                     save_rds(obj, file)
[10:21:38.684]                   }
[10:21:38.684]                   saveImmediateCondition(cond, path = "/tmp/Rtmpfpiz4I/.future/immediateConditions")
[10:21:38.684]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.684]                   {
[10:21:38.684]                     inherits <- base::inherits
[10:21:38.684]                     invokeRestart <- base::invokeRestart
[10:21:38.684]                     is.null <- base::is.null
[10:21:38.684]                     muffled <- FALSE
[10:21:38.684]                     if (inherits(cond, "message")) {
[10:21:38.684]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:38.684]                       if (muffled) 
[10:21:38.684]                         invokeRestart("muffleMessage")
[10:21:38.684]                     }
[10:21:38.684]                     else if (inherits(cond, "warning")) {
[10:21:38.684]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:38.684]                       if (muffled) 
[10:21:38.684]                         invokeRestart("muffleWarning")
[10:21:38.684]                     }
[10:21:38.684]                     else if (inherits(cond, "condition")) {
[10:21:38.684]                       if (!is.null(pattern)) {
[10:21:38.684]                         computeRestarts <- base::computeRestarts
[10:21:38.684]                         grepl <- base::grepl
[10:21:38.684]                         restarts <- computeRestarts(cond)
[10:21:38.684]                         for (restart in restarts) {
[10:21:38.684]                           name <- restart$name
[10:21:38.684]                           if (is.null(name)) 
[10:21:38.684]                             next
[10:21:38.684]                           if (!grepl(pattern, name)) 
[10:21:38.684]                             next
[10:21:38.684]                           invokeRestart(restart)
[10:21:38.684]                           muffled <- TRUE
[10:21:38.684]                           break
[10:21:38.684]                         }
[10:21:38.684]                       }
[10:21:38.684]                     }
[10:21:38.684]                     invisible(muffled)
[10:21:38.684]                   }
[10:21:38.684]                   muffleCondition(cond)
[10:21:38.684]                 })
[10:21:38.684]             }))
[10:21:38.684]             future::FutureResult(value = ...future.value$value, 
[10:21:38.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.684]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.684]                     ...future.globalenv.names))
[10:21:38.684]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.684]         }, condition = base::local({
[10:21:38.684]             c <- base::c
[10:21:38.684]             inherits <- base::inherits
[10:21:38.684]             invokeRestart <- base::invokeRestart
[10:21:38.684]             length <- base::length
[10:21:38.684]             list <- base::list
[10:21:38.684]             seq.int <- base::seq.int
[10:21:38.684]             signalCondition <- base::signalCondition
[10:21:38.684]             sys.calls <- base::sys.calls
[10:21:38.684]             `[[` <- base::`[[`
[10:21:38.684]             `+` <- base::`+`
[10:21:38.684]             `<<-` <- base::`<<-`
[10:21:38.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.684]                   3L)]
[10:21:38.684]             }
[10:21:38.684]             function(cond) {
[10:21:38.684]                 is_error <- inherits(cond, "error")
[10:21:38.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.684]                   NULL)
[10:21:38.684]                 if (is_error) {
[10:21:38.684]                   sessionInformation <- function() {
[10:21:38.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.684]                       search = base::search(), system = base::Sys.info())
[10:21:38.684]                   }
[10:21:38.684]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.684]                     cond$call), session = sessionInformation(), 
[10:21:38.684]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.684]                   signalCondition(cond)
[10:21:38.684]                 }
[10:21:38.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.684]                 "immediateCondition"))) {
[10:21:38.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.684]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.684]                   if (TRUE && !signal) {
[10:21:38.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.684]                     {
[10:21:38.684]                       inherits <- base::inherits
[10:21:38.684]                       invokeRestart <- base::invokeRestart
[10:21:38.684]                       is.null <- base::is.null
[10:21:38.684]                       muffled <- FALSE
[10:21:38.684]                       if (inherits(cond, "message")) {
[10:21:38.684]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.684]                         if (muffled) 
[10:21:38.684]                           invokeRestart("muffleMessage")
[10:21:38.684]                       }
[10:21:38.684]                       else if (inherits(cond, "warning")) {
[10:21:38.684]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.684]                         if (muffled) 
[10:21:38.684]                           invokeRestart("muffleWarning")
[10:21:38.684]                       }
[10:21:38.684]                       else if (inherits(cond, "condition")) {
[10:21:38.684]                         if (!is.null(pattern)) {
[10:21:38.684]                           computeRestarts <- base::computeRestarts
[10:21:38.684]                           grepl <- base::grepl
[10:21:38.684]                           restarts <- computeRestarts(cond)
[10:21:38.684]                           for (restart in restarts) {
[10:21:38.684]                             name <- restart$name
[10:21:38.684]                             if (is.null(name)) 
[10:21:38.684]                               next
[10:21:38.684]                             if (!grepl(pattern, name)) 
[10:21:38.684]                               next
[10:21:38.684]                             invokeRestart(restart)
[10:21:38.684]                             muffled <- TRUE
[10:21:38.684]                             break
[10:21:38.684]                           }
[10:21:38.684]                         }
[10:21:38.684]                       }
[10:21:38.684]                       invisible(muffled)
[10:21:38.684]                     }
[10:21:38.684]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.684]                   }
[10:21:38.684]                 }
[10:21:38.684]                 else {
[10:21:38.684]                   if (TRUE) {
[10:21:38.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.684]                     {
[10:21:38.684]                       inherits <- base::inherits
[10:21:38.684]                       invokeRestart <- base::invokeRestart
[10:21:38.684]                       is.null <- base::is.null
[10:21:38.684]                       muffled <- FALSE
[10:21:38.684]                       if (inherits(cond, "message")) {
[10:21:38.684]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.684]                         if (muffled) 
[10:21:38.684]                           invokeRestart("muffleMessage")
[10:21:38.684]                       }
[10:21:38.684]                       else if (inherits(cond, "warning")) {
[10:21:38.684]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.684]                         if (muffled) 
[10:21:38.684]                           invokeRestart("muffleWarning")
[10:21:38.684]                       }
[10:21:38.684]                       else if (inherits(cond, "condition")) {
[10:21:38.684]                         if (!is.null(pattern)) {
[10:21:38.684]                           computeRestarts <- base::computeRestarts
[10:21:38.684]                           grepl <- base::grepl
[10:21:38.684]                           restarts <- computeRestarts(cond)
[10:21:38.684]                           for (restart in restarts) {
[10:21:38.684]                             name <- restart$name
[10:21:38.684]                             if (is.null(name)) 
[10:21:38.684]                               next
[10:21:38.684]                             if (!grepl(pattern, name)) 
[10:21:38.684]                               next
[10:21:38.684]                             invokeRestart(restart)
[10:21:38.684]                             muffled <- TRUE
[10:21:38.684]                             break
[10:21:38.684]                           }
[10:21:38.684]                         }
[10:21:38.684]                       }
[10:21:38.684]                       invisible(muffled)
[10:21:38.684]                     }
[10:21:38.684]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.684]                   }
[10:21:38.684]                 }
[10:21:38.684]             }
[10:21:38.684]         }))
[10:21:38.684]     }, error = function(ex) {
[10:21:38.684]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.684]                 ...future.rng), started = ...future.startTime, 
[10:21:38.684]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.684]             version = "1.8"), class = "FutureResult")
[10:21:38.684]     }, finally = {
[10:21:38.684]         if (!identical(...future.workdir, getwd())) 
[10:21:38.684]             setwd(...future.workdir)
[10:21:38.684]         {
[10:21:38.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.684]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.684]             }
[10:21:38.684]             base::options(...future.oldOptions)
[10:21:38.684]             if (.Platform$OS.type == "windows") {
[10:21:38.684]                 old_names <- names(...future.oldEnvVars)
[10:21:38.684]                 envs <- base::Sys.getenv()
[10:21:38.684]                 names <- names(envs)
[10:21:38.684]                 common <- intersect(names, old_names)
[10:21:38.684]                 added <- setdiff(names, old_names)
[10:21:38.684]                 removed <- setdiff(old_names, names)
[10:21:38.684]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.684]                   envs[common]]
[10:21:38.684]                 NAMES <- toupper(changed)
[10:21:38.684]                 args <- list()
[10:21:38.684]                 for (kk in seq_along(NAMES)) {
[10:21:38.684]                   name <- changed[[kk]]
[10:21:38.684]                   NAME <- NAMES[[kk]]
[10:21:38.684]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.684]                     next
[10:21:38.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.684]                 }
[10:21:38.684]                 NAMES <- toupper(added)
[10:21:38.684]                 for (kk in seq_along(NAMES)) {
[10:21:38.684]                   name <- added[[kk]]
[10:21:38.684]                   NAME <- NAMES[[kk]]
[10:21:38.684]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.684]                     next
[10:21:38.684]                   args[[name]] <- ""
[10:21:38.684]                 }
[10:21:38.684]                 NAMES <- toupper(removed)
[10:21:38.684]                 for (kk in seq_along(NAMES)) {
[10:21:38.684]                   name <- removed[[kk]]
[10:21:38.684]                   NAME <- NAMES[[kk]]
[10:21:38.684]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.684]                     next
[10:21:38.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.684]                 }
[10:21:38.684]                 if (length(args) > 0) 
[10:21:38.684]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.684]             }
[10:21:38.684]             else {
[10:21:38.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.684]             }
[10:21:38.684]             {
[10:21:38.684]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.684]                   0L) {
[10:21:38.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.684]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.684]                   base::options(opts)
[10:21:38.684]                 }
[10:21:38.684]                 {
[10:21:38.684]                   {
[10:21:38.684]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:38.684]                     NULL
[10:21:38.684]                   }
[10:21:38.684]                   options(future.plan = NULL)
[10:21:38.684]                   if (is.na(NA_character_)) 
[10:21:38.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.684]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.684]                     .init = FALSE)
[10:21:38.684]                 }
[10:21:38.684]             }
[10:21:38.684]         }
[10:21:38.684]     })
[10:21:38.684]     if (TRUE) {
[10:21:38.684]         base::sink(type = "output", split = FALSE)
[10:21:38.684]         if (TRUE) {
[10:21:38.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.684]         }
[10:21:38.684]         else {
[10:21:38.684]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.684]         }
[10:21:38.684]         base::close(...future.stdout)
[10:21:38.684]         ...future.stdout <- NULL
[10:21:38.684]     }
[10:21:38.684]     ...future.result$conditions <- ...future.conditions
[10:21:38.684]     ...future.result$finished <- base::Sys.time()
[10:21:38.684]     ...future.result
[10:21:38.684] }
[10:21:38.687] assign_globals() ...
[10:21:38.687] List of 1
[10:21:38.687]  $ x: list()
[10:21:38.687]  - attr(*, "where")=List of 1
[10:21:38.687]   ..$ x:<environment: R_EmptyEnv> 
[10:21:38.687]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:38.687]  - attr(*, "resolved")= logi TRUE
[10:21:38.687]  - attr(*, "total_size")= num 31
[10:21:38.687]  - attr(*, "already-done")= logi TRUE
[10:21:38.690] - copied ‘x’ to environment
[10:21:38.690] assign_globals() ... done
[10:21:38.690] requestCore(): workers = 2
[10:21:38.692] MulticoreFuture started
[10:21:38.693] - Launch lazy future ... done
[10:21:38.693] run() for ‘MulticoreFuture’ ... done
[10:21:38.693] plan(): Setting new future strategy stack:
[10:21:38.694] result() for MulticoreFuture ...
[10:21:38.693] List of future strategies:
[10:21:38.693] 1. sequential:
[10:21:38.693]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.693]    - tweaked: FALSE
[10:21:38.693]    - call: NULL
[10:21:38.694] plan(): nbrOfWorkers() = 1
[10:21:38.696] plan(): Setting new future strategy stack:
[10:21:38.697] List of future strategies:
[10:21:38.697] 1. multicore:
[10:21:38.697]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:38.697]    - tweaked: FALSE
[10:21:38.697]    - call: plan(strategy)
[10:21:38.700] plan(): nbrOfWorkers() = 2
[10:21:38.700] result() for MulticoreFuture ...
[10:21:38.701] result() for MulticoreFuture ... done
[10:21:38.701] result() for MulticoreFuture ... done
[10:21:38.701] result() for MulticoreFuture ...
[10:21:38.701] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.702] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.702] Searching for globals...
[10:21:38.705] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:38.705] Searching for globals ... DONE
[10:21:38.705] Resolving globals: TRUE
[10:21:38.705] Resolving any globals that are futures ...
[10:21:38.705] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:38.705] Resolving any globals that are futures ... DONE
[10:21:38.706] Resolving futures part of globals (recursively) ...
[10:21:38.706] resolve() on list ...
[10:21:38.706]  recursive: 99
[10:21:38.706]  length: 1
[10:21:38.707]  elements: ‘x’
[10:21:38.707]  length: 0 (resolved future 1)
[10:21:38.707] resolve() on list ... DONE
[10:21:38.709] - globals: [1] ‘x’
[10:21:38.709] Resolving futures part of globals (recursively) ... DONE
[10:21:38.709] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:38.710] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:38.710] - globals: [1] ‘x’
[10:21:38.710] 
[10:21:38.710] getGlobalsAndPackages() ... DONE
[10:21:38.711] run() for ‘Future’ ...
[10:21:38.711] - state: ‘created’
[10:21:38.711] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:38.713] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:38.713] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:38.713]   - Field: ‘label’
[10:21:38.714]   - Field: ‘local’
[10:21:38.714]   - Field: ‘owner’
[10:21:38.714]   - Field: ‘envir’
[10:21:38.714]   - Field: ‘workers’
[10:21:38.714]   - Field: ‘packages’
[10:21:38.714]   - Field: ‘gc’
[10:21:38.714]   - Field: ‘job’
[10:21:38.714]   - Field: ‘conditions’
[10:21:38.714]   - Field: ‘expr’
[10:21:38.715]   - Field: ‘uuid’
[10:21:38.715]   - Field: ‘seed’
[10:21:38.715]   - Field: ‘version’
[10:21:38.715]   - Field: ‘result’
[10:21:38.715]   - Field: ‘asynchronous’
[10:21:38.715]   - Field: ‘calls’
[10:21:38.715]   - Field: ‘globals’
[10:21:38.715]   - Field: ‘stdout’
[10:21:38.715]   - Field: ‘earlySignal’
[10:21:38.716]   - Field: ‘lazy’
[10:21:38.716]   - Field: ‘state’
[10:21:38.716] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:38.716] - Launch lazy future ...
[10:21:38.716] Packages needed by the future expression (n = 0): <none>
[10:21:38.716] Packages needed by future strategies (n = 0): <none>
[10:21:38.717] {
[10:21:38.717]     {
[10:21:38.717]         {
[10:21:38.717]             ...future.startTime <- base::Sys.time()
[10:21:38.717]             {
[10:21:38.717]                 {
[10:21:38.717]                   {
[10:21:38.717]                     {
[10:21:38.717]                       base::local({
[10:21:38.717]                         has_future <- base::requireNamespace("future", 
[10:21:38.717]                           quietly = TRUE)
[10:21:38.717]                         if (has_future) {
[10:21:38.717]                           ns <- base::getNamespace("future")
[10:21:38.717]                           version <- ns[[".package"]][["version"]]
[10:21:38.717]                           if (is.null(version)) 
[10:21:38.717]                             version <- utils::packageVersion("future")
[10:21:38.717]                         }
[10:21:38.717]                         else {
[10:21:38.717]                           version <- NULL
[10:21:38.717]                         }
[10:21:38.717]                         if (!has_future || version < "1.8.0") {
[10:21:38.717]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.717]                             "", base::R.version$version.string), 
[10:21:38.717]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:38.717]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.717]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.717]                               "release", "version")], collapse = " "), 
[10:21:38.717]                             hostname = base::Sys.info()[["nodename"]])
[10:21:38.717]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.717]                             info)
[10:21:38.717]                           info <- base::paste(info, collapse = "; ")
[10:21:38.717]                           if (!has_future) {
[10:21:38.717]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.717]                               info)
[10:21:38.717]                           }
[10:21:38.717]                           else {
[10:21:38.717]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.717]                               info, version)
[10:21:38.717]                           }
[10:21:38.717]                           base::stop(msg)
[10:21:38.717]                         }
[10:21:38.717]                       })
[10:21:38.717]                     }
[10:21:38.717]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:38.717]                     base::options(mc.cores = 1L)
[10:21:38.717]                   }
[10:21:38.717]                   ...future.strategy.old <- future::plan("list")
[10:21:38.717]                   options(future.plan = NULL)
[10:21:38.717]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.717]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.717]                 }
[10:21:38.717]                 ...future.workdir <- getwd()
[10:21:38.717]             }
[10:21:38.717]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.717]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.717]         }
[10:21:38.717]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.717]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.717]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.717]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.717]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.717]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.717]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.717]             base::names(...future.oldOptions))
[10:21:38.717]     }
[10:21:38.717]     if (FALSE) {
[10:21:38.717]     }
[10:21:38.717]     else {
[10:21:38.717]         if (TRUE) {
[10:21:38.717]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.717]                 open = "w")
[10:21:38.717]         }
[10:21:38.717]         else {
[10:21:38.717]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.717]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.717]         }
[10:21:38.717]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.717]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.717]             base::sink(type = "output", split = FALSE)
[10:21:38.717]             base::close(...future.stdout)
[10:21:38.717]         }, add = TRUE)
[10:21:38.717]     }
[10:21:38.717]     ...future.frame <- base::sys.nframe()
[10:21:38.717]     ...future.conditions <- base::list()
[10:21:38.717]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.717]     if (FALSE) {
[10:21:38.717]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.717]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.717]     }
[10:21:38.717]     ...future.result <- base::tryCatch({
[10:21:38.717]         base::withCallingHandlers({
[10:21:38.717]             ...future.value <- base::withVisible(base::local({
[10:21:38.717]                 withCallingHandlers({
[10:21:38.717]                   {
[10:21:38.717]                     x$a <- 1
[10:21:38.717]                     x
[10:21:38.717]                   }
[10:21:38.717]                 }, immediateCondition = function(cond) {
[10:21:38.717]                   save_rds <- function (object, pathname, ...) 
[10:21:38.717]                   {
[10:21:38.717]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:38.717]                     if (file_test("-f", pathname_tmp)) {
[10:21:38.717]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.717]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:38.717]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.717]                         fi_tmp[["mtime"]])
[10:21:38.717]                     }
[10:21:38.717]                     tryCatch({
[10:21:38.717]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:38.717]                     }, error = function(ex) {
[10:21:38.717]                       msg <- conditionMessage(ex)
[10:21:38.717]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.717]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:38.717]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.717]                         fi_tmp[["mtime"]], msg)
[10:21:38.717]                       ex$message <- msg
[10:21:38.717]                       stop(ex)
[10:21:38.717]                     })
[10:21:38.717]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:38.717]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:38.717]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:38.717]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.717]                       fi <- file.info(pathname)
[10:21:38.717]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:38.717]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.717]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:38.717]                         fi[["size"]], fi[["mtime"]])
[10:21:38.717]                       stop(msg)
[10:21:38.717]                     }
[10:21:38.717]                     invisible(pathname)
[10:21:38.717]                   }
[10:21:38.717]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:38.717]                     rootPath = tempdir()) 
[10:21:38.717]                   {
[10:21:38.717]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:38.717]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:38.717]                       tmpdir = path, fileext = ".rds")
[10:21:38.717]                     save_rds(obj, file)
[10:21:38.717]                   }
[10:21:38.717]                   saveImmediateCondition(cond, path = "/tmp/Rtmpfpiz4I/.future/immediateConditions")
[10:21:38.717]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.717]                   {
[10:21:38.717]                     inherits <- base::inherits
[10:21:38.717]                     invokeRestart <- base::invokeRestart
[10:21:38.717]                     is.null <- base::is.null
[10:21:38.717]                     muffled <- FALSE
[10:21:38.717]                     if (inherits(cond, "message")) {
[10:21:38.717]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:38.717]                       if (muffled) 
[10:21:38.717]                         invokeRestart("muffleMessage")
[10:21:38.717]                     }
[10:21:38.717]                     else if (inherits(cond, "warning")) {
[10:21:38.717]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:38.717]                       if (muffled) 
[10:21:38.717]                         invokeRestart("muffleWarning")
[10:21:38.717]                     }
[10:21:38.717]                     else if (inherits(cond, "condition")) {
[10:21:38.717]                       if (!is.null(pattern)) {
[10:21:38.717]                         computeRestarts <- base::computeRestarts
[10:21:38.717]                         grepl <- base::grepl
[10:21:38.717]                         restarts <- computeRestarts(cond)
[10:21:38.717]                         for (restart in restarts) {
[10:21:38.717]                           name <- restart$name
[10:21:38.717]                           if (is.null(name)) 
[10:21:38.717]                             next
[10:21:38.717]                           if (!grepl(pattern, name)) 
[10:21:38.717]                             next
[10:21:38.717]                           invokeRestart(restart)
[10:21:38.717]                           muffled <- TRUE
[10:21:38.717]                           break
[10:21:38.717]                         }
[10:21:38.717]                       }
[10:21:38.717]                     }
[10:21:38.717]                     invisible(muffled)
[10:21:38.717]                   }
[10:21:38.717]                   muffleCondition(cond)
[10:21:38.717]                 })
[10:21:38.717]             }))
[10:21:38.717]             future::FutureResult(value = ...future.value$value, 
[10:21:38.717]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.717]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.717]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.717]                     ...future.globalenv.names))
[10:21:38.717]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.717]         }, condition = base::local({
[10:21:38.717]             c <- base::c
[10:21:38.717]             inherits <- base::inherits
[10:21:38.717]             invokeRestart <- base::invokeRestart
[10:21:38.717]             length <- base::length
[10:21:38.717]             list <- base::list
[10:21:38.717]             seq.int <- base::seq.int
[10:21:38.717]             signalCondition <- base::signalCondition
[10:21:38.717]             sys.calls <- base::sys.calls
[10:21:38.717]             `[[` <- base::`[[`
[10:21:38.717]             `+` <- base::`+`
[10:21:38.717]             `<<-` <- base::`<<-`
[10:21:38.717]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.717]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.717]                   3L)]
[10:21:38.717]             }
[10:21:38.717]             function(cond) {
[10:21:38.717]                 is_error <- inherits(cond, "error")
[10:21:38.717]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.717]                   NULL)
[10:21:38.717]                 if (is_error) {
[10:21:38.717]                   sessionInformation <- function() {
[10:21:38.717]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.717]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.717]                       search = base::search(), system = base::Sys.info())
[10:21:38.717]                   }
[10:21:38.717]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.717]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.717]                     cond$call), session = sessionInformation(), 
[10:21:38.717]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.717]                   signalCondition(cond)
[10:21:38.717]                 }
[10:21:38.717]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.717]                 "immediateCondition"))) {
[10:21:38.717]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.717]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.717]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.717]                   if (TRUE && !signal) {
[10:21:38.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.717]                     {
[10:21:38.717]                       inherits <- base::inherits
[10:21:38.717]                       invokeRestart <- base::invokeRestart
[10:21:38.717]                       is.null <- base::is.null
[10:21:38.717]                       muffled <- FALSE
[10:21:38.717]                       if (inherits(cond, "message")) {
[10:21:38.717]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.717]                         if (muffled) 
[10:21:38.717]                           invokeRestart("muffleMessage")
[10:21:38.717]                       }
[10:21:38.717]                       else if (inherits(cond, "warning")) {
[10:21:38.717]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.717]                         if (muffled) 
[10:21:38.717]                           invokeRestart("muffleWarning")
[10:21:38.717]                       }
[10:21:38.717]                       else if (inherits(cond, "condition")) {
[10:21:38.717]                         if (!is.null(pattern)) {
[10:21:38.717]                           computeRestarts <- base::computeRestarts
[10:21:38.717]                           grepl <- base::grepl
[10:21:38.717]                           restarts <- computeRestarts(cond)
[10:21:38.717]                           for (restart in restarts) {
[10:21:38.717]                             name <- restart$name
[10:21:38.717]                             if (is.null(name)) 
[10:21:38.717]                               next
[10:21:38.717]                             if (!grepl(pattern, name)) 
[10:21:38.717]                               next
[10:21:38.717]                             invokeRestart(restart)
[10:21:38.717]                             muffled <- TRUE
[10:21:38.717]                             break
[10:21:38.717]                           }
[10:21:38.717]                         }
[10:21:38.717]                       }
[10:21:38.717]                       invisible(muffled)
[10:21:38.717]                     }
[10:21:38.717]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.717]                   }
[10:21:38.717]                 }
[10:21:38.717]                 else {
[10:21:38.717]                   if (TRUE) {
[10:21:38.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.717]                     {
[10:21:38.717]                       inherits <- base::inherits
[10:21:38.717]                       invokeRestart <- base::invokeRestart
[10:21:38.717]                       is.null <- base::is.null
[10:21:38.717]                       muffled <- FALSE
[10:21:38.717]                       if (inherits(cond, "message")) {
[10:21:38.717]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.717]                         if (muffled) 
[10:21:38.717]                           invokeRestart("muffleMessage")
[10:21:38.717]                       }
[10:21:38.717]                       else if (inherits(cond, "warning")) {
[10:21:38.717]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.717]                         if (muffled) 
[10:21:38.717]                           invokeRestart("muffleWarning")
[10:21:38.717]                       }
[10:21:38.717]                       else if (inherits(cond, "condition")) {
[10:21:38.717]                         if (!is.null(pattern)) {
[10:21:38.717]                           computeRestarts <- base::computeRestarts
[10:21:38.717]                           grepl <- base::grepl
[10:21:38.717]                           restarts <- computeRestarts(cond)
[10:21:38.717]                           for (restart in restarts) {
[10:21:38.717]                             name <- restart$name
[10:21:38.717]                             if (is.null(name)) 
[10:21:38.717]                               next
[10:21:38.717]                             if (!grepl(pattern, name)) 
[10:21:38.717]                               next
[10:21:38.717]                             invokeRestart(restart)
[10:21:38.717]                             muffled <- TRUE
[10:21:38.717]                             break
[10:21:38.717]                           }
[10:21:38.717]                         }
[10:21:38.717]                       }
[10:21:38.717]                       invisible(muffled)
[10:21:38.717]                     }
[10:21:38.717]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.717]                   }
[10:21:38.717]                 }
[10:21:38.717]             }
[10:21:38.717]         }))
[10:21:38.717]     }, error = function(ex) {
[10:21:38.717]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.717]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.717]                 ...future.rng), started = ...future.startTime, 
[10:21:38.717]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.717]             version = "1.8"), class = "FutureResult")
[10:21:38.717]     }, finally = {
[10:21:38.717]         if (!identical(...future.workdir, getwd())) 
[10:21:38.717]             setwd(...future.workdir)
[10:21:38.717]         {
[10:21:38.717]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.717]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.717]             }
[10:21:38.717]             base::options(...future.oldOptions)
[10:21:38.717]             if (.Platform$OS.type == "windows") {
[10:21:38.717]                 old_names <- names(...future.oldEnvVars)
[10:21:38.717]                 envs <- base::Sys.getenv()
[10:21:38.717]                 names <- names(envs)
[10:21:38.717]                 common <- intersect(names, old_names)
[10:21:38.717]                 added <- setdiff(names, old_names)
[10:21:38.717]                 removed <- setdiff(old_names, names)
[10:21:38.717]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.717]                   envs[common]]
[10:21:38.717]                 NAMES <- toupper(changed)
[10:21:38.717]                 args <- list()
[10:21:38.717]                 for (kk in seq_along(NAMES)) {
[10:21:38.717]                   name <- changed[[kk]]
[10:21:38.717]                   NAME <- NAMES[[kk]]
[10:21:38.717]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.717]                     next
[10:21:38.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.717]                 }
[10:21:38.717]                 NAMES <- toupper(added)
[10:21:38.717]                 for (kk in seq_along(NAMES)) {
[10:21:38.717]                   name <- added[[kk]]
[10:21:38.717]                   NAME <- NAMES[[kk]]
[10:21:38.717]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.717]                     next
[10:21:38.717]                   args[[name]] <- ""
[10:21:38.717]                 }
[10:21:38.717]                 NAMES <- toupper(removed)
[10:21:38.717]                 for (kk in seq_along(NAMES)) {
[10:21:38.717]                   name <- removed[[kk]]
[10:21:38.717]                   NAME <- NAMES[[kk]]
[10:21:38.717]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.717]                     next
[10:21:38.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.717]                 }
[10:21:38.717]                 if (length(args) > 0) 
[10:21:38.717]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.717]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.717]             }
[10:21:38.717]             else {
[10:21:38.717]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.717]             }
[10:21:38.717]             {
[10:21:38.717]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.717]                   0L) {
[10:21:38.717]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.717]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.717]                   base::options(opts)
[10:21:38.717]                 }
[10:21:38.717]                 {
[10:21:38.717]                   {
[10:21:38.717]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:38.717]                     NULL
[10:21:38.717]                   }
[10:21:38.717]                   options(future.plan = NULL)
[10:21:38.717]                   if (is.na(NA_character_)) 
[10:21:38.717]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.717]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.717]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.717]                     .init = FALSE)
[10:21:38.717]                 }
[10:21:38.717]             }
[10:21:38.717]         }
[10:21:38.717]     })
[10:21:38.717]     if (TRUE) {
[10:21:38.717]         base::sink(type = "output", split = FALSE)
[10:21:38.717]         if (TRUE) {
[10:21:38.717]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.717]         }
[10:21:38.717]         else {
[10:21:38.717]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.717]         }
[10:21:38.717]         base::close(...future.stdout)
[10:21:38.717]         ...future.stdout <- NULL
[10:21:38.717]     }
[10:21:38.717]     ...future.result$conditions <- ...future.conditions
[10:21:38.717]     ...future.result$finished <- base::Sys.time()
[10:21:38.717]     ...future.result
[10:21:38.717] }
[10:21:38.719] assign_globals() ...
[10:21:38.719] List of 1
[10:21:38.719]  $ x: list()
[10:21:38.719]  - attr(*, "where")=List of 1
[10:21:38.719]   ..$ x:<environment: R_EmptyEnv> 
[10:21:38.719]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:38.719]  - attr(*, "resolved")= logi TRUE
[10:21:38.719]  - attr(*, "total_size")= num 31
[10:21:38.719]  - attr(*, "already-done")= logi TRUE
[10:21:38.722] - copied ‘x’ to environment
[10:21:38.722] assign_globals() ... done
[10:21:38.723] requestCore(): workers = 2
[10:21:38.725] MulticoreFuture started
[10:21:38.725] - Launch lazy future ... done
[10:21:38.725] run() for ‘MulticoreFuture’ ... done
[10:21:38.726] plan(): Setting new future strategy stack:
[10:21:38.726] result() for MulticoreFuture ...
[10:21:38.726] List of future strategies:
[10:21:38.726] 1. sequential:
[10:21:38.726]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.726]    - tweaked: FALSE
[10:21:38.726]    - call: NULL
[10:21:38.727] plan(): nbrOfWorkers() = 1
[10:21:38.729] plan(): Setting new future strategy stack:
[10:21:38.729] List of future strategies:
[10:21:38.729] 1. multicore:
[10:21:38.729]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:38.729]    - tweaked: FALSE
[10:21:38.729]    - call: plan(strategy)
[10:21:38.732] plan(): nbrOfWorkers() = 2
[10:21:38.733] result() for MulticoreFuture ...
[10:21:38.733] result() for MulticoreFuture ... done
[10:21:38.733] result() for MulticoreFuture ... done
[10:21:38.733] result() for MulticoreFuture ...
[10:21:38.733] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.734] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.735] Searching for globals...
[10:21:38.738] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[10:21:38.738] Searching for globals ... DONE
[10:21:38.738] Resolving globals: TRUE
[10:21:38.738] Resolving any globals that are futures ...
[10:21:38.739] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[10:21:38.739] Resolving any globals that are futures ... DONE
[10:21:38.739] 
[10:21:38.739] 
[10:21:38.739] getGlobalsAndPackages() ... DONE
[10:21:38.740] run() for ‘Future’ ...
[10:21:38.740] - state: ‘created’
[10:21:38.740] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:38.742] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:38.742] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:38.742]   - Field: ‘label’
[10:21:38.742]   - Field: ‘local’
[10:21:38.743]   - Field: ‘owner’
[10:21:38.743]   - Field: ‘envir’
[10:21:38.743]   - Field: ‘workers’
[10:21:38.743]   - Field: ‘packages’
[10:21:38.743]   - Field: ‘gc’
[10:21:38.743]   - Field: ‘job’
[10:21:38.743]   - Field: ‘conditions’
[10:21:38.743]   - Field: ‘expr’
[10:21:38.743]   - Field: ‘uuid’
[10:21:38.744]   - Field: ‘seed’
[10:21:38.744]   - Field: ‘version’
[10:21:38.744]   - Field: ‘result’
[10:21:38.744]   - Field: ‘asynchronous’
[10:21:38.744]   - Field: ‘calls’
[10:21:38.744]   - Field: ‘globals’
[10:21:38.744]   - Field: ‘stdout’
[10:21:38.744]   - Field: ‘earlySignal’
[10:21:38.744]   - Field: ‘lazy’
[10:21:38.744]   - Field: ‘state’
[10:21:38.745] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:38.745] - Launch lazy future ...
[10:21:38.745] Packages needed by the future expression (n = 0): <none>
[10:21:38.745] Packages needed by future strategies (n = 0): <none>
[10:21:38.746] {
[10:21:38.746]     {
[10:21:38.746]         {
[10:21:38.746]             ...future.startTime <- base::Sys.time()
[10:21:38.746]             {
[10:21:38.746]                 {
[10:21:38.746]                   {
[10:21:38.746]                     {
[10:21:38.746]                       base::local({
[10:21:38.746]                         has_future <- base::requireNamespace("future", 
[10:21:38.746]                           quietly = TRUE)
[10:21:38.746]                         if (has_future) {
[10:21:38.746]                           ns <- base::getNamespace("future")
[10:21:38.746]                           version <- ns[[".package"]][["version"]]
[10:21:38.746]                           if (is.null(version)) 
[10:21:38.746]                             version <- utils::packageVersion("future")
[10:21:38.746]                         }
[10:21:38.746]                         else {
[10:21:38.746]                           version <- NULL
[10:21:38.746]                         }
[10:21:38.746]                         if (!has_future || version < "1.8.0") {
[10:21:38.746]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.746]                             "", base::R.version$version.string), 
[10:21:38.746]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:38.746]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.746]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.746]                               "release", "version")], collapse = " "), 
[10:21:38.746]                             hostname = base::Sys.info()[["nodename"]])
[10:21:38.746]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.746]                             info)
[10:21:38.746]                           info <- base::paste(info, collapse = "; ")
[10:21:38.746]                           if (!has_future) {
[10:21:38.746]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.746]                               info)
[10:21:38.746]                           }
[10:21:38.746]                           else {
[10:21:38.746]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.746]                               info, version)
[10:21:38.746]                           }
[10:21:38.746]                           base::stop(msg)
[10:21:38.746]                         }
[10:21:38.746]                       })
[10:21:38.746]                     }
[10:21:38.746]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:38.746]                     base::options(mc.cores = 1L)
[10:21:38.746]                   }
[10:21:38.746]                   ...future.strategy.old <- future::plan("list")
[10:21:38.746]                   options(future.plan = NULL)
[10:21:38.746]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.746]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.746]                 }
[10:21:38.746]                 ...future.workdir <- getwd()
[10:21:38.746]             }
[10:21:38.746]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.746]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.746]         }
[10:21:38.746]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.746]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.746]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.746]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.746]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.746]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.746]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.746]             base::names(...future.oldOptions))
[10:21:38.746]     }
[10:21:38.746]     if (FALSE) {
[10:21:38.746]     }
[10:21:38.746]     else {
[10:21:38.746]         if (TRUE) {
[10:21:38.746]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.746]                 open = "w")
[10:21:38.746]         }
[10:21:38.746]         else {
[10:21:38.746]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.746]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.746]         }
[10:21:38.746]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.746]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.746]             base::sink(type = "output", split = FALSE)
[10:21:38.746]             base::close(...future.stdout)
[10:21:38.746]         }, add = TRUE)
[10:21:38.746]     }
[10:21:38.746]     ...future.frame <- base::sys.nframe()
[10:21:38.746]     ...future.conditions <- base::list()
[10:21:38.746]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.746]     if (FALSE) {
[10:21:38.746]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.746]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.746]     }
[10:21:38.746]     ...future.result <- base::tryCatch({
[10:21:38.746]         base::withCallingHandlers({
[10:21:38.746]             ...future.value <- base::withVisible(base::local({
[10:21:38.746]                 withCallingHandlers({
[10:21:38.746]                   {
[10:21:38.746]                     x <- list(b = 2)
[10:21:38.746]                     x$a <- 1
[10:21:38.746]                     x
[10:21:38.746]                   }
[10:21:38.746]                 }, immediateCondition = function(cond) {
[10:21:38.746]                   save_rds <- function (object, pathname, ...) 
[10:21:38.746]                   {
[10:21:38.746]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:38.746]                     if (file_test("-f", pathname_tmp)) {
[10:21:38.746]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.746]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:38.746]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.746]                         fi_tmp[["mtime"]])
[10:21:38.746]                     }
[10:21:38.746]                     tryCatch({
[10:21:38.746]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:38.746]                     }, error = function(ex) {
[10:21:38.746]                       msg <- conditionMessage(ex)
[10:21:38.746]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.746]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:38.746]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.746]                         fi_tmp[["mtime"]], msg)
[10:21:38.746]                       ex$message <- msg
[10:21:38.746]                       stop(ex)
[10:21:38.746]                     })
[10:21:38.746]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:38.746]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:38.746]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:38.746]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.746]                       fi <- file.info(pathname)
[10:21:38.746]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:38.746]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.746]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:38.746]                         fi[["size"]], fi[["mtime"]])
[10:21:38.746]                       stop(msg)
[10:21:38.746]                     }
[10:21:38.746]                     invisible(pathname)
[10:21:38.746]                   }
[10:21:38.746]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:38.746]                     rootPath = tempdir()) 
[10:21:38.746]                   {
[10:21:38.746]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:38.746]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:38.746]                       tmpdir = path, fileext = ".rds")
[10:21:38.746]                     save_rds(obj, file)
[10:21:38.746]                   }
[10:21:38.746]                   saveImmediateCondition(cond, path = "/tmp/Rtmpfpiz4I/.future/immediateConditions")
[10:21:38.746]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.746]                   {
[10:21:38.746]                     inherits <- base::inherits
[10:21:38.746]                     invokeRestart <- base::invokeRestart
[10:21:38.746]                     is.null <- base::is.null
[10:21:38.746]                     muffled <- FALSE
[10:21:38.746]                     if (inherits(cond, "message")) {
[10:21:38.746]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:38.746]                       if (muffled) 
[10:21:38.746]                         invokeRestart("muffleMessage")
[10:21:38.746]                     }
[10:21:38.746]                     else if (inherits(cond, "warning")) {
[10:21:38.746]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:38.746]                       if (muffled) 
[10:21:38.746]                         invokeRestart("muffleWarning")
[10:21:38.746]                     }
[10:21:38.746]                     else if (inherits(cond, "condition")) {
[10:21:38.746]                       if (!is.null(pattern)) {
[10:21:38.746]                         computeRestarts <- base::computeRestarts
[10:21:38.746]                         grepl <- base::grepl
[10:21:38.746]                         restarts <- computeRestarts(cond)
[10:21:38.746]                         for (restart in restarts) {
[10:21:38.746]                           name <- restart$name
[10:21:38.746]                           if (is.null(name)) 
[10:21:38.746]                             next
[10:21:38.746]                           if (!grepl(pattern, name)) 
[10:21:38.746]                             next
[10:21:38.746]                           invokeRestart(restart)
[10:21:38.746]                           muffled <- TRUE
[10:21:38.746]                           break
[10:21:38.746]                         }
[10:21:38.746]                       }
[10:21:38.746]                     }
[10:21:38.746]                     invisible(muffled)
[10:21:38.746]                   }
[10:21:38.746]                   muffleCondition(cond)
[10:21:38.746]                 })
[10:21:38.746]             }))
[10:21:38.746]             future::FutureResult(value = ...future.value$value, 
[10:21:38.746]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.746]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.746]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.746]                     ...future.globalenv.names))
[10:21:38.746]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.746]         }, condition = base::local({
[10:21:38.746]             c <- base::c
[10:21:38.746]             inherits <- base::inherits
[10:21:38.746]             invokeRestart <- base::invokeRestart
[10:21:38.746]             length <- base::length
[10:21:38.746]             list <- base::list
[10:21:38.746]             seq.int <- base::seq.int
[10:21:38.746]             signalCondition <- base::signalCondition
[10:21:38.746]             sys.calls <- base::sys.calls
[10:21:38.746]             `[[` <- base::`[[`
[10:21:38.746]             `+` <- base::`+`
[10:21:38.746]             `<<-` <- base::`<<-`
[10:21:38.746]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.746]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.746]                   3L)]
[10:21:38.746]             }
[10:21:38.746]             function(cond) {
[10:21:38.746]                 is_error <- inherits(cond, "error")
[10:21:38.746]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.746]                   NULL)
[10:21:38.746]                 if (is_error) {
[10:21:38.746]                   sessionInformation <- function() {
[10:21:38.746]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.746]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.746]                       search = base::search(), system = base::Sys.info())
[10:21:38.746]                   }
[10:21:38.746]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.746]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.746]                     cond$call), session = sessionInformation(), 
[10:21:38.746]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.746]                   signalCondition(cond)
[10:21:38.746]                 }
[10:21:38.746]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.746]                 "immediateCondition"))) {
[10:21:38.746]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.746]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.746]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.746]                   if (TRUE && !signal) {
[10:21:38.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.746]                     {
[10:21:38.746]                       inherits <- base::inherits
[10:21:38.746]                       invokeRestart <- base::invokeRestart
[10:21:38.746]                       is.null <- base::is.null
[10:21:38.746]                       muffled <- FALSE
[10:21:38.746]                       if (inherits(cond, "message")) {
[10:21:38.746]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.746]                         if (muffled) 
[10:21:38.746]                           invokeRestart("muffleMessage")
[10:21:38.746]                       }
[10:21:38.746]                       else if (inherits(cond, "warning")) {
[10:21:38.746]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.746]                         if (muffled) 
[10:21:38.746]                           invokeRestart("muffleWarning")
[10:21:38.746]                       }
[10:21:38.746]                       else if (inherits(cond, "condition")) {
[10:21:38.746]                         if (!is.null(pattern)) {
[10:21:38.746]                           computeRestarts <- base::computeRestarts
[10:21:38.746]                           grepl <- base::grepl
[10:21:38.746]                           restarts <- computeRestarts(cond)
[10:21:38.746]                           for (restart in restarts) {
[10:21:38.746]                             name <- restart$name
[10:21:38.746]                             if (is.null(name)) 
[10:21:38.746]                               next
[10:21:38.746]                             if (!grepl(pattern, name)) 
[10:21:38.746]                               next
[10:21:38.746]                             invokeRestart(restart)
[10:21:38.746]                             muffled <- TRUE
[10:21:38.746]                             break
[10:21:38.746]                           }
[10:21:38.746]                         }
[10:21:38.746]                       }
[10:21:38.746]                       invisible(muffled)
[10:21:38.746]                     }
[10:21:38.746]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.746]                   }
[10:21:38.746]                 }
[10:21:38.746]                 else {
[10:21:38.746]                   if (TRUE) {
[10:21:38.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.746]                     {
[10:21:38.746]                       inherits <- base::inherits
[10:21:38.746]                       invokeRestart <- base::invokeRestart
[10:21:38.746]                       is.null <- base::is.null
[10:21:38.746]                       muffled <- FALSE
[10:21:38.746]                       if (inherits(cond, "message")) {
[10:21:38.746]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.746]                         if (muffled) 
[10:21:38.746]                           invokeRestart("muffleMessage")
[10:21:38.746]                       }
[10:21:38.746]                       else if (inherits(cond, "warning")) {
[10:21:38.746]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.746]                         if (muffled) 
[10:21:38.746]                           invokeRestart("muffleWarning")
[10:21:38.746]                       }
[10:21:38.746]                       else if (inherits(cond, "condition")) {
[10:21:38.746]                         if (!is.null(pattern)) {
[10:21:38.746]                           computeRestarts <- base::computeRestarts
[10:21:38.746]                           grepl <- base::grepl
[10:21:38.746]                           restarts <- computeRestarts(cond)
[10:21:38.746]                           for (restart in restarts) {
[10:21:38.746]                             name <- restart$name
[10:21:38.746]                             if (is.null(name)) 
[10:21:38.746]                               next
[10:21:38.746]                             if (!grepl(pattern, name)) 
[10:21:38.746]                               next
[10:21:38.746]                             invokeRestart(restart)
[10:21:38.746]                             muffled <- TRUE
[10:21:38.746]                             break
[10:21:38.746]                           }
[10:21:38.746]                         }
[10:21:38.746]                       }
[10:21:38.746]                       invisible(muffled)
[10:21:38.746]                     }
[10:21:38.746]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.746]                   }
[10:21:38.746]                 }
[10:21:38.746]             }
[10:21:38.746]         }))
[10:21:38.746]     }, error = function(ex) {
[10:21:38.746]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.746]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.746]                 ...future.rng), started = ...future.startTime, 
[10:21:38.746]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.746]             version = "1.8"), class = "FutureResult")
[10:21:38.746]     }, finally = {
[10:21:38.746]         if (!identical(...future.workdir, getwd())) 
[10:21:38.746]             setwd(...future.workdir)
[10:21:38.746]         {
[10:21:38.746]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.746]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.746]             }
[10:21:38.746]             base::options(...future.oldOptions)
[10:21:38.746]             if (.Platform$OS.type == "windows") {
[10:21:38.746]                 old_names <- names(...future.oldEnvVars)
[10:21:38.746]                 envs <- base::Sys.getenv()
[10:21:38.746]                 names <- names(envs)
[10:21:38.746]                 common <- intersect(names, old_names)
[10:21:38.746]                 added <- setdiff(names, old_names)
[10:21:38.746]                 removed <- setdiff(old_names, names)
[10:21:38.746]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.746]                   envs[common]]
[10:21:38.746]                 NAMES <- toupper(changed)
[10:21:38.746]                 args <- list()
[10:21:38.746]                 for (kk in seq_along(NAMES)) {
[10:21:38.746]                   name <- changed[[kk]]
[10:21:38.746]                   NAME <- NAMES[[kk]]
[10:21:38.746]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.746]                     next
[10:21:38.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.746]                 }
[10:21:38.746]                 NAMES <- toupper(added)
[10:21:38.746]                 for (kk in seq_along(NAMES)) {
[10:21:38.746]                   name <- added[[kk]]
[10:21:38.746]                   NAME <- NAMES[[kk]]
[10:21:38.746]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.746]                     next
[10:21:38.746]                   args[[name]] <- ""
[10:21:38.746]                 }
[10:21:38.746]                 NAMES <- toupper(removed)
[10:21:38.746]                 for (kk in seq_along(NAMES)) {
[10:21:38.746]                   name <- removed[[kk]]
[10:21:38.746]                   NAME <- NAMES[[kk]]
[10:21:38.746]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.746]                     next
[10:21:38.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.746]                 }
[10:21:38.746]                 if (length(args) > 0) 
[10:21:38.746]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.746]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.746]             }
[10:21:38.746]             else {
[10:21:38.746]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.746]             }
[10:21:38.746]             {
[10:21:38.746]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.746]                   0L) {
[10:21:38.746]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.746]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.746]                   base::options(opts)
[10:21:38.746]                 }
[10:21:38.746]                 {
[10:21:38.746]                   {
[10:21:38.746]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:38.746]                     NULL
[10:21:38.746]                   }
[10:21:38.746]                   options(future.plan = NULL)
[10:21:38.746]                   if (is.na(NA_character_)) 
[10:21:38.746]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.746]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.746]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.746]                     .init = FALSE)
[10:21:38.746]                 }
[10:21:38.746]             }
[10:21:38.746]         }
[10:21:38.746]     })
[10:21:38.746]     if (TRUE) {
[10:21:38.746]         base::sink(type = "output", split = FALSE)
[10:21:38.746]         if (TRUE) {
[10:21:38.746]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.746]         }
[10:21:38.746]         else {
[10:21:38.746]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.746]         }
[10:21:38.746]         base::close(...future.stdout)
[10:21:38.746]         ...future.stdout <- NULL
[10:21:38.746]     }
[10:21:38.746]     ...future.result$conditions <- ...future.conditions
[10:21:38.746]     ...future.result$finished <- base::Sys.time()
[10:21:38.746]     ...future.result
[10:21:38.746] }
[10:21:38.748] requestCore(): workers = 2
[10:21:38.750] MulticoreFuture started
[10:21:38.750] - Launch lazy future ... done
[10:21:38.751] run() for ‘MulticoreFuture’ ... done
[10:21:38.751] result() for MulticoreFuture ...
[10:21:38.751] plan(): Setting new future strategy stack:
[10:21:38.751] List of future strategies:
[10:21:38.751] 1. sequential:
[10:21:38.751]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.751]    - tweaked: FALSE
[10:21:38.751]    - call: NULL
[10:21:38.752] plan(): nbrOfWorkers() = 1
[10:21:38.754] plan(): Setting new future strategy stack:
[10:21:38.754] List of future strategies:
[10:21:38.754] 1. multicore:
[10:21:38.754]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:38.754]    - tweaked: FALSE
[10:21:38.754]    - call: plan(strategy)
[10:21:38.757] plan(): nbrOfWorkers() = 2
[10:21:38.758] result() for MulticoreFuture ...
[10:21:38.758] result() for MulticoreFuture ... done
[10:21:38.758] result() for MulticoreFuture ... done
[10:21:38.759] result() for MulticoreFuture ...
[10:21:38.759] result() for MulticoreFuture ... done
$b
[1] 2

$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.759] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.759] Searching for globals...
[10:21:38.765] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:21:38.765] Searching for globals ... DONE
[10:21:38.765] Resolving globals: TRUE
[10:21:38.765] Resolving any globals that are futures ...
[10:21:38.765] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:21:38.765] Resolving any globals that are futures ... DONE
[10:21:38.766] Resolving futures part of globals (recursively) ...
[10:21:38.766] resolve() on list ...
[10:21:38.766]  recursive: 99
[10:21:38.767]  length: 1
[10:21:38.767]  elements: ‘x’
[10:21:38.767]  length: 0 (resolved future 1)
[10:21:38.767] resolve() on list ... DONE
[10:21:38.767] - globals: [1] ‘x’
[10:21:38.767] Resolving futures part of globals (recursively) ... DONE
[10:21:38.767] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:38.768] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:38.768] - globals: [1] ‘x’
[10:21:38.768] 
[10:21:38.768] getGlobalsAndPackages() ... DONE
[10:21:38.768] run() for ‘Future’ ...
[10:21:38.769] - state: ‘created’
[10:21:38.769] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:38.771] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:38.771] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:38.771]   - Field: ‘label’
[10:21:38.771]   - Field: ‘local’
[10:21:38.771]   - Field: ‘owner’
[10:21:38.771]   - Field: ‘envir’
[10:21:38.771]   - Field: ‘workers’
[10:21:38.772]   - Field: ‘packages’
[10:21:38.772]   - Field: ‘gc’
[10:21:38.772]   - Field: ‘job’
[10:21:38.772]   - Field: ‘conditions’
[10:21:38.772]   - Field: ‘expr’
[10:21:38.772]   - Field: ‘uuid’
[10:21:38.772]   - Field: ‘seed’
[10:21:38.772]   - Field: ‘version’
[10:21:38.772]   - Field: ‘result’
[10:21:38.773]   - Field: ‘asynchronous’
[10:21:38.773]   - Field: ‘calls’
[10:21:38.773]   - Field: ‘globals’
[10:21:38.773]   - Field: ‘stdout’
[10:21:38.773]   - Field: ‘earlySignal’
[10:21:38.773]   - Field: ‘lazy’
[10:21:38.773]   - Field: ‘state’
[10:21:38.773] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:38.774] - Launch lazy future ...
[10:21:38.774] Packages needed by the future expression (n = 0): <none>
[10:21:38.774] Packages needed by future strategies (n = 0): <none>
[10:21:38.775] {
[10:21:38.775]     {
[10:21:38.775]         {
[10:21:38.775]             ...future.startTime <- base::Sys.time()
[10:21:38.775]             {
[10:21:38.775]                 {
[10:21:38.775]                   {
[10:21:38.775]                     {
[10:21:38.775]                       base::local({
[10:21:38.775]                         has_future <- base::requireNamespace("future", 
[10:21:38.775]                           quietly = TRUE)
[10:21:38.775]                         if (has_future) {
[10:21:38.775]                           ns <- base::getNamespace("future")
[10:21:38.775]                           version <- ns[[".package"]][["version"]]
[10:21:38.775]                           if (is.null(version)) 
[10:21:38.775]                             version <- utils::packageVersion("future")
[10:21:38.775]                         }
[10:21:38.775]                         else {
[10:21:38.775]                           version <- NULL
[10:21:38.775]                         }
[10:21:38.775]                         if (!has_future || version < "1.8.0") {
[10:21:38.775]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.775]                             "", base::R.version$version.string), 
[10:21:38.775]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:38.775]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.775]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.775]                               "release", "version")], collapse = " "), 
[10:21:38.775]                             hostname = base::Sys.info()[["nodename"]])
[10:21:38.775]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.775]                             info)
[10:21:38.775]                           info <- base::paste(info, collapse = "; ")
[10:21:38.775]                           if (!has_future) {
[10:21:38.775]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.775]                               info)
[10:21:38.775]                           }
[10:21:38.775]                           else {
[10:21:38.775]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.775]                               info, version)
[10:21:38.775]                           }
[10:21:38.775]                           base::stop(msg)
[10:21:38.775]                         }
[10:21:38.775]                       })
[10:21:38.775]                     }
[10:21:38.775]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:38.775]                     base::options(mc.cores = 1L)
[10:21:38.775]                   }
[10:21:38.775]                   ...future.strategy.old <- future::plan("list")
[10:21:38.775]                   options(future.plan = NULL)
[10:21:38.775]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.775]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.775]                 }
[10:21:38.775]                 ...future.workdir <- getwd()
[10:21:38.775]             }
[10:21:38.775]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.775]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.775]         }
[10:21:38.775]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.775]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.775]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.775]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.775]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.775]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.775]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.775]             base::names(...future.oldOptions))
[10:21:38.775]     }
[10:21:38.775]     if (FALSE) {
[10:21:38.775]     }
[10:21:38.775]     else {
[10:21:38.775]         if (TRUE) {
[10:21:38.775]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.775]                 open = "w")
[10:21:38.775]         }
[10:21:38.775]         else {
[10:21:38.775]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.775]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.775]         }
[10:21:38.775]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.775]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.775]             base::sink(type = "output", split = FALSE)
[10:21:38.775]             base::close(...future.stdout)
[10:21:38.775]         }, add = TRUE)
[10:21:38.775]     }
[10:21:38.775]     ...future.frame <- base::sys.nframe()
[10:21:38.775]     ...future.conditions <- base::list()
[10:21:38.775]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.775]     if (FALSE) {
[10:21:38.775]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.775]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.775]     }
[10:21:38.775]     ...future.result <- base::tryCatch({
[10:21:38.775]         base::withCallingHandlers({
[10:21:38.775]             ...future.value <- base::withVisible(base::local({
[10:21:38.775]                 withCallingHandlers({
[10:21:38.775]                   {
[10:21:38.775]                     x[["a"]] <- 1
[10:21:38.775]                     x
[10:21:38.775]                   }
[10:21:38.775]                 }, immediateCondition = function(cond) {
[10:21:38.775]                   save_rds <- function (object, pathname, ...) 
[10:21:38.775]                   {
[10:21:38.775]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:38.775]                     if (file_test("-f", pathname_tmp)) {
[10:21:38.775]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.775]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:38.775]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.775]                         fi_tmp[["mtime"]])
[10:21:38.775]                     }
[10:21:38.775]                     tryCatch({
[10:21:38.775]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:38.775]                     }, error = function(ex) {
[10:21:38.775]                       msg <- conditionMessage(ex)
[10:21:38.775]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.775]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:38.775]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.775]                         fi_tmp[["mtime"]], msg)
[10:21:38.775]                       ex$message <- msg
[10:21:38.775]                       stop(ex)
[10:21:38.775]                     })
[10:21:38.775]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:38.775]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:38.775]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:38.775]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.775]                       fi <- file.info(pathname)
[10:21:38.775]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:38.775]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.775]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:38.775]                         fi[["size"]], fi[["mtime"]])
[10:21:38.775]                       stop(msg)
[10:21:38.775]                     }
[10:21:38.775]                     invisible(pathname)
[10:21:38.775]                   }
[10:21:38.775]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:38.775]                     rootPath = tempdir()) 
[10:21:38.775]                   {
[10:21:38.775]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:38.775]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:38.775]                       tmpdir = path, fileext = ".rds")
[10:21:38.775]                     save_rds(obj, file)
[10:21:38.775]                   }
[10:21:38.775]                   saveImmediateCondition(cond, path = "/tmp/Rtmpfpiz4I/.future/immediateConditions")
[10:21:38.775]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.775]                   {
[10:21:38.775]                     inherits <- base::inherits
[10:21:38.775]                     invokeRestart <- base::invokeRestart
[10:21:38.775]                     is.null <- base::is.null
[10:21:38.775]                     muffled <- FALSE
[10:21:38.775]                     if (inherits(cond, "message")) {
[10:21:38.775]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:38.775]                       if (muffled) 
[10:21:38.775]                         invokeRestart("muffleMessage")
[10:21:38.775]                     }
[10:21:38.775]                     else if (inherits(cond, "warning")) {
[10:21:38.775]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:38.775]                       if (muffled) 
[10:21:38.775]                         invokeRestart("muffleWarning")
[10:21:38.775]                     }
[10:21:38.775]                     else if (inherits(cond, "condition")) {
[10:21:38.775]                       if (!is.null(pattern)) {
[10:21:38.775]                         computeRestarts <- base::computeRestarts
[10:21:38.775]                         grepl <- base::grepl
[10:21:38.775]                         restarts <- computeRestarts(cond)
[10:21:38.775]                         for (restart in restarts) {
[10:21:38.775]                           name <- restart$name
[10:21:38.775]                           if (is.null(name)) 
[10:21:38.775]                             next
[10:21:38.775]                           if (!grepl(pattern, name)) 
[10:21:38.775]                             next
[10:21:38.775]                           invokeRestart(restart)
[10:21:38.775]                           muffled <- TRUE
[10:21:38.775]                           break
[10:21:38.775]                         }
[10:21:38.775]                       }
[10:21:38.775]                     }
[10:21:38.775]                     invisible(muffled)
[10:21:38.775]                   }
[10:21:38.775]                   muffleCondition(cond)
[10:21:38.775]                 })
[10:21:38.775]             }))
[10:21:38.775]             future::FutureResult(value = ...future.value$value, 
[10:21:38.775]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.775]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.775]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.775]                     ...future.globalenv.names))
[10:21:38.775]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.775]         }, condition = base::local({
[10:21:38.775]             c <- base::c
[10:21:38.775]             inherits <- base::inherits
[10:21:38.775]             invokeRestart <- base::invokeRestart
[10:21:38.775]             length <- base::length
[10:21:38.775]             list <- base::list
[10:21:38.775]             seq.int <- base::seq.int
[10:21:38.775]             signalCondition <- base::signalCondition
[10:21:38.775]             sys.calls <- base::sys.calls
[10:21:38.775]             `[[` <- base::`[[`
[10:21:38.775]             `+` <- base::`+`
[10:21:38.775]             `<<-` <- base::`<<-`
[10:21:38.775]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.775]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.775]                   3L)]
[10:21:38.775]             }
[10:21:38.775]             function(cond) {
[10:21:38.775]                 is_error <- inherits(cond, "error")
[10:21:38.775]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.775]                   NULL)
[10:21:38.775]                 if (is_error) {
[10:21:38.775]                   sessionInformation <- function() {
[10:21:38.775]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.775]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.775]                       search = base::search(), system = base::Sys.info())
[10:21:38.775]                   }
[10:21:38.775]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.775]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.775]                     cond$call), session = sessionInformation(), 
[10:21:38.775]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.775]                   signalCondition(cond)
[10:21:38.775]                 }
[10:21:38.775]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.775]                 "immediateCondition"))) {
[10:21:38.775]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.775]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.775]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.775]                   if (TRUE && !signal) {
[10:21:38.775]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.775]                     {
[10:21:38.775]                       inherits <- base::inherits
[10:21:38.775]                       invokeRestart <- base::invokeRestart
[10:21:38.775]                       is.null <- base::is.null
[10:21:38.775]                       muffled <- FALSE
[10:21:38.775]                       if (inherits(cond, "message")) {
[10:21:38.775]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.775]                         if (muffled) 
[10:21:38.775]                           invokeRestart("muffleMessage")
[10:21:38.775]                       }
[10:21:38.775]                       else if (inherits(cond, "warning")) {
[10:21:38.775]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.775]                         if (muffled) 
[10:21:38.775]                           invokeRestart("muffleWarning")
[10:21:38.775]                       }
[10:21:38.775]                       else if (inherits(cond, "condition")) {
[10:21:38.775]                         if (!is.null(pattern)) {
[10:21:38.775]                           computeRestarts <- base::computeRestarts
[10:21:38.775]                           grepl <- base::grepl
[10:21:38.775]                           restarts <- computeRestarts(cond)
[10:21:38.775]                           for (restart in restarts) {
[10:21:38.775]                             name <- restart$name
[10:21:38.775]                             if (is.null(name)) 
[10:21:38.775]                               next
[10:21:38.775]                             if (!grepl(pattern, name)) 
[10:21:38.775]                               next
[10:21:38.775]                             invokeRestart(restart)
[10:21:38.775]                             muffled <- TRUE
[10:21:38.775]                             break
[10:21:38.775]                           }
[10:21:38.775]                         }
[10:21:38.775]                       }
[10:21:38.775]                       invisible(muffled)
[10:21:38.775]                     }
[10:21:38.775]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.775]                   }
[10:21:38.775]                 }
[10:21:38.775]                 else {
[10:21:38.775]                   if (TRUE) {
[10:21:38.775]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.775]                     {
[10:21:38.775]                       inherits <- base::inherits
[10:21:38.775]                       invokeRestart <- base::invokeRestart
[10:21:38.775]                       is.null <- base::is.null
[10:21:38.775]                       muffled <- FALSE
[10:21:38.775]                       if (inherits(cond, "message")) {
[10:21:38.775]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.775]                         if (muffled) 
[10:21:38.775]                           invokeRestart("muffleMessage")
[10:21:38.775]                       }
[10:21:38.775]                       else if (inherits(cond, "warning")) {
[10:21:38.775]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.775]                         if (muffled) 
[10:21:38.775]                           invokeRestart("muffleWarning")
[10:21:38.775]                       }
[10:21:38.775]                       else if (inherits(cond, "condition")) {
[10:21:38.775]                         if (!is.null(pattern)) {
[10:21:38.775]                           computeRestarts <- base::computeRestarts
[10:21:38.775]                           grepl <- base::grepl
[10:21:38.775]                           restarts <- computeRestarts(cond)
[10:21:38.775]                           for (restart in restarts) {
[10:21:38.775]                             name <- restart$name
[10:21:38.775]                             if (is.null(name)) 
[10:21:38.775]                               next
[10:21:38.775]                             if (!grepl(pattern, name)) 
[10:21:38.775]                               next
[10:21:38.775]                             invokeRestart(restart)
[10:21:38.775]                             muffled <- TRUE
[10:21:38.775]                             break
[10:21:38.775]                           }
[10:21:38.775]                         }
[10:21:38.775]                       }
[10:21:38.775]                       invisible(muffled)
[10:21:38.775]                     }
[10:21:38.775]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.775]                   }
[10:21:38.775]                 }
[10:21:38.775]             }
[10:21:38.775]         }))
[10:21:38.775]     }, error = function(ex) {
[10:21:38.775]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.775]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.775]                 ...future.rng), started = ...future.startTime, 
[10:21:38.775]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.775]             version = "1.8"), class = "FutureResult")
[10:21:38.775]     }, finally = {
[10:21:38.775]         if (!identical(...future.workdir, getwd())) 
[10:21:38.775]             setwd(...future.workdir)
[10:21:38.775]         {
[10:21:38.775]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.775]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.775]             }
[10:21:38.775]             base::options(...future.oldOptions)
[10:21:38.775]             if (.Platform$OS.type == "windows") {
[10:21:38.775]                 old_names <- names(...future.oldEnvVars)
[10:21:38.775]                 envs <- base::Sys.getenv()
[10:21:38.775]                 names <- names(envs)
[10:21:38.775]                 common <- intersect(names, old_names)
[10:21:38.775]                 added <- setdiff(names, old_names)
[10:21:38.775]                 removed <- setdiff(old_names, names)
[10:21:38.775]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.775]                   envs[common]]
[10:21:38.775]                 NAMES <- toupper(changed)
[10:21:38.775]                 args <- list()
[10:21:38.775]                 for (kk in seq_along(NAMES)) {
[10:21:38.775]                   name <- changed[[kk]]
[10:21:38.775]                   NAME <- NAMES[[kk]]
[10:21:38.775]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.775]                     next
[10:21:38.775]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.775]                 }
[10:21:38.775]                 NAMES <- toupper(added)
[10:21:38.775]                 for (kk in seq_along(NAMES)) {
[10:21:38.775]                   name <- added[[kk]]
[10:21:38.775]                   NAME <- NAMES[[kk]]
[10:21:38.775]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.775]                     next
[10:21:38.775]                   args[[name]] <- ""
[10:21:38.775]                 }
[10:21:38.775]                 NAMES <- toupper(removed)
[10:21:38.775]                 for (kk in seq_along(NAMES)) {
[10:21:38.775]                   name <- removed[[kk]]
[10:21:38.775]                   NAME <- NAMES[[kk]]
[10:21:38.775]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.775]                     next
[10:21:38.775]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.775]                 }
[10:21:38.775]                 if (length(args) > 0) 
[10:21:38.775]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.775]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.775]             }
[10:21:38.775]             else {
[10:21:38.775]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.775]             }
[10:21:38.775]             {
[10:21:38.775]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.775]                   0L) {
[10:21:38.775]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.775]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.775]                   base::options(opts)
[10:21:38.775]                 }
[10:21:38.775]                 {
[10:21:38.775]                   {
[10:21:38.775]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:38.775]                     NULL
[10:21:38.775]                   }
[10:21:38.775]                   options(future.plan = NULL)
[10:21:38.775]                   if (is.na(NA_character_)) 
[10:21:38.775]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.775]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.775]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.775]                     .init = FALSE)
[10:21:38.775]                 }
[10:21:38.775]             }
[10:21:38.775]         }
[10:21:38.775]     })
[10:21:38.775]     if (TRUE) {
[10:21:38.775]         base::sink(type = "output", split = FALSE)
[10:21:38.775]         if (TRUE) {
[10:21:38.775]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.775]         }
[10:21:38.775]         else {
[10:21:38.775]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.775]         }
[10:21:38.775]         base::close(...future.stdout)
[10:21:38.775]         ...future.stdout <- NULL
[10:21:38.775]     }
[10:21:38.775]     ...future.result$conditions <- ...future.conditions
[10:21:38.775]     ...future.result$finished <- base::Sys.time()
[10:21:38.775]     ...future.result
[10:21:38.775] }
[10:21:38.777] assign_globals() ...
[10:21:38.777] List of 1
[10:21:38.777]  $ x: list()
[10:21:38.777]  - attr(*, "where")=List of 1
[10:21:38.777]   ..$ x:<environment: R_EmptyEnv> 
[10:21:38.777]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:38.777]  - attr(*, "resolved")= logi TRUE
[10:21:38.777]  - attr(*, "total_size")= num 31
[10:21:38.777]  - attr(*, "already-done")= logi TRUE
[10:21:38.780] - copied ‘x’ to environment
[10:21:38.780] assign_globals() ... done
[10:21:38.780] requestCore(): workers = 2
[10:21:38.782] MulticoreFuture started
[10:21:38.782] - Launch lazy future ... done
[10:21:38.783] run() for ‘MulticoreFuture’ ... done
[10:21:38.783] result() for MulticoreFuture ...
[10:21:38.783] plan(): Setting new future strategy stack:
[10:21:38.783] List of future strategies:
[10:21:38.783] 1. sequential:
[10:21:38.783]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.783]    - tweaked: FALSE
[10:21:38.783]    - call: NULL
[10:21:38.784] plan(): nbrOfWorkers() = 1
[10:21:38.786] plan(): Setting new future strategy stack:
[10:21:38.786] List of future strategies:
[10:21:38.786] 1. multicore:
[10:21:38.786]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:38.786]    - tweaked: FALSE
[10:21:38.786]    - call: plan(strategy)
[10:21:38.789] plan(): nbrOfWorkers() = 2
[10:21:38.790] result() for MulticoreFuture ...
[10:21:38.790] result() for MulticoreFuture ... done
[10:21:38.791] result() for MulticoreFuture ... done
[10:21:38.791] result() for MulticoreFuture ...
[10:21:38.791] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.791] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.792] Searching for globals...
[10:21:38.794] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:21:38.794] Searching for globals ... DONE
[10:21:38.795] Resolving globals: TRUE
[10:21:38.795] Resolving any globals that are futures ...
[10:21:38.795] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:21:38.795] Resolving any globals that are futures ... DONE
[10:21:38.795] Resolving futures part of globals (recursively) ...
[10:21:38.796] resolve() on list ...
[10:21:38.796]  recursive: 99
[10:21:38.796]  length: 1
[10:21:38.796]  elements: ‘x’
[10:21:38.796]  length: 0 (resolved future 1)
[10:21:38.796] resolve() on list ... DONE
[10:21:38.796] - globals: [1] ‘x’
[10:21:38.797] Resolving futures part of globals (recursively) ... DONE
[10:21:38.797] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:38.797] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:38.797] - globals: [1] ‘x’
[10:21:38.797] 
[10:21:38.798] getGlobalsAndPackages() ... DONE
[10:21:38.798] run() for ‘Future’ ...
[10:21:38.798] - state: ‘created’
[10:21:38.798] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:38.800] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:38.800] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:38.801]   - Field: ‘label’
[10:21:38.801]   - Field: ‘local’
[10:21:38.801]   - Field: ‘owner’
[10:21:38.801]   - Field: ‘envir’
[10:21:38.801]   - Field: ‘workers’
[10:21:38.801]   - Field: ‘packages’
[10:21:38.801]   - Field: ‘gc’
[10:21:38.801]   - Field: ‘job’
[10:21:38.801]   - Field: ‘conditions’
[10:21:38.802]   - Field: ‘expr’
[10:21:38.802]   - Field: ‘uuid’
[10:21:38.802]   - Field: ‘seed’
[10:21:38.802]   - Field: ‘version’
[10:21:38.802]   - Field: ‘result’
[10:21:38.802]   - Field: ‘asynchronous’
[10:21:38.802]   - Field: ‘calls’
[10:21:38.802]   - Field: ‘globals’
[10:21:38.802]   - Field: ‘stdout’
[10:21:38.803]   - Field: ‘earlySignal’
[10:21:38.803]   - Field: ‘lazy’
[10:21:38.803]   - Field: ‘state’
[10:21:38.803] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:38.803] - Launch lazy future ...
[10:21:38.803] Packages needed by the future expression (n = 0): <none>
[10:21:38.803] Packages needed by future strategies (n = 0): <none>
[10:21:38.804] {
[10:21:38.804]     {
[10:21:38.804]         {
[10:21:38.804]             ...future.startTime <- base::Sys.time()
[10:21:38.804]             {
[10:21:38.804]                 {
[10:21:38.804]                   {
[10:21:38.804]                     {
[10:21:38.804]                       base::local({
[10:21:38.804]                         has_future <- base::requireNamespace("future", 
[10:21:38.804]                           quietly = TRUE)
[10:21:38.804]                         if (has_future) {
[10:21:38.804]                           ns <- base::getNamespace("future")
[10:21:38.804]                           version <- ns[[".package"]][["version"]]
[10:21:38.804]                           if (is.null(version)) 
[10:21:38.804]                             version <- utils::packageVersion("future")
[10:21:38.804]                         }
[10:21:38.804]                         else {
[10:21:38.804]                           version <- NULL
[10:21:38.804]                         }
[10:21:38.804]                         if (!has_future || version < "1.8.0") {
[10:21:38.804]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.804]                             "", base::R.version$version.string), 
[10:21:38.804]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:38.804]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.804]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.804]                               "release", "version")], collapse = " "), 
[10:21:38.804]                             hostname = base::Sys.info()[["nodename"]])
[10:21:38.804]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.804]                             info)
[10:21:38.804]                           info <- base::paste(info, collapse = "; ")
[10:21:38.804]                           if (!has_future) {
[10:21:38.804]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.804]                               info)
[10:21:38.804]                           }
[10:21:38.804]                           else {
[10:21:38.804]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.804]                               info, version)
[10:21:38.804]                           }
[10:21:38.804]                           base::stop(msg)
[10:21:38.804]                         }
[10:21:38.804]                       })
[10:21:38.804]                     }
[10:21:38.804]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:38.804]                     base::options(mc.cores = 1L)
[10:21:38.804]                   }
[10:21:38.804]                   ...future.strategy.old <- future::plan("list")
[10:21:38.804]                   options(future.plan = NULL)
[10:21:38.804]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.804]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.804]                 }
[10:21:38.804]                 ...future.workdir <- getwd()
[10:21:38.804]             }
[10:21:38.804]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.804]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.804]         }
[10:21:38.804]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.804]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.804]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.804]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.804]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.804]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.804]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.804]             base::names(...future.oldOptions))
[10:21:38.804]     }
[10:21:38.804]     if (FALSE) {
[10:21:38.804]     }
[10:21:38.804]     else {
[10:21:38.804]         if (TRUE) {
[10:21:38.804]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.804]                 open = "w")
[10:21:38.804]         }
[10:21:38.804]         else {
[10:21:38.804]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.804]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.804]         }
[10:21:38.804]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.804]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.804]             base::sink(type = "output", split = FALSE)
[10:21:38.804]             base::close(...future.stdout)
[10:21:38.804]         }, add = TRUE)
[10:21:38.804]     }
[10:21:38.804]     ...future.frame <- base::sys.nframe()
[10:21:38.804]     ...future.conditions <- base::list()
[10:21:38.804]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.804]     if (FALSE) {
[10:21:38.804]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.804]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.804]     }
[10:21:38.804]     ...future.result <- base::tryCatch({
[10:21:38.804]         base::withCallingHandlers({
[10:21:38.804]             ...future.value <- base::withVisible(base::local({
[10:21:38.804]                 withCallingHandlers({
[10:21:38.804]                   {
[10:21:38.804]                     x[["a"]] <- 1
[10:21:38.804]                     x
[10:21:38.804]                   }
[10:21:38.804]                 }, immediateCondition = function(cond) {
[10:21:38.804]                   save_rds <- function (object, pathname, ...) 
[10:21:38.804]                   {
[10:21:38.804]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:38.804]                     if (file_test("-f", pathname_tmp)) {
[10:21:38.804]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.804]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:38.804]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.804]                         fi_tmp[["mtime"]])
[10:21:38.804]                     }
[10:21:38.804]                     tryCatch({
[10:21:38.804]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:38.804]                     }, error = function(ex) {
[10:21:38.804]                       msg <- conditionMessage(ex)
[10:21:38.804]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.804]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:38.804]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.804]                         fi_tmp[["mtime"]], msg)
[10:21:38.804]                       ex$message <- msg
[10:21:38.804]                       stop(ex)
[10:21:38.804]                     })
[10:21:38.804]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:38.804]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:38.804]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:38.804]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.804]                       fi <- file.info(pathname)
[10:21:38.804]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:38.804]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.804]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:38.804]                         fi[["size"]], fi[["mtime"]])
[10:21:38.804]                       stop(msg)
[10:21:38.804]                     }
[10:21:38.804]                     invisible(pathname)
[10:21:38.804]                   }
[10:21:38.804]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:38.804]                     rootPath = tempdir()) 
[10:21:38.804]                   {
[10:21:38.804]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:38.804]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:38.804]                       tmpdir = path, fileext = ".rds")
[10:21:38.804]                     save_rds(obj, file)
[10:21:38.804]                   }
[10:21:38.804]                   saveImmediateCondition(cond, path = "/tmp/Rtmpfpiz4I/.future/immediateConditions")
[10:21:38.804]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.804]                   {
[10:21:38.804]                     inherits <- base::inherits
[10:21:38.804]                     invokeRestart <- base::invokeRestart
[10:21:38.804]                     is.null <- base::is.null
[10:21:38.804]                     muffled <- FALSE
[10:21:38.804]                     if (inherits(cond, "message")) {
[10:21:38.804]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:38.804]                       if (muffled) 
[10:21:38.804]                         invokeRestart("muffleMessage")
[10:21:38.804]                     }
[10:21:38.804]                     else if (inherits(cond, "warning")) {
[10:21:38.804]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:38.804]                       if (muffled) 
[10:21:38.804]                         invokeRestart("muffleWarning")
[10:21:38.804]                     }
[10:21:38.804]                     else if (inherits(cond, "condition")) {
[10:21:38.804]                       if (!is.null(pattern)) {
[10:21:38.804]                         computeRestarts <- base::computeRestarts
[10:21:38.804]                         grepl <- base::grepl
[10:21:38.804]                         restarts <- computeRestarts(cond)
[10:21:38.804]                         for (restart in restarts) {
[10:21:38.804]                           name <- restart$name
[10:21:38.804]                           if (is.null(name)) 
[10:21:38.804]                             next
[10:21:38.804]                           if (!grepl(pattern, name)) 
[10:21:38.804]                             next
[10:21:38.804]                           invokeRestart(restart)
[10:21:38.804]                           muffled <- TRUE
[10:21:38.804]                           break
[10:21:38.804]                         }
[10:21:38.804]                       }
[10:21:38.804]                     }
[10:21:38.804]                     invisible(muffled)
[10:21:38.804]                   }
[10:21:38.804]                   muffleCondition(cond)
[10:21:38.804]                 })
[10:21:38.804]             }))
[10:21:38.804]             future::FutureResult(value = ...future.value$value, 
[10:21:38.804]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.804]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.804]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.804]                     ...future.globalenv.names))
[10:21:38.804]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.804]         }, condition = base::local({
[10:21:38.804]             c <- base::c
[10:21:38.804]             inherits <- base::inherits
[10:21:38.804]             invokeRestart <- base::invokeRestart
[10:21:38.804]             length <- base::length
[10:21:38.804]             list <- base::list
[10:21:38.804]             seq.int <- base::seq.int
[10:21:38.804]             signalCondition <- base::signalCondition
[10:21:38.804]             sys.calls <- base::sys.calls
[10:21:38.804]             `[[` <- base::`[[`
[10:21:38.804]             `+` <- base::`+`
[10:21:38.804]             `<<-` <- base::`<<-`
[10:21:38.804]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.804]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.804]                   3L)]
[10:21:38.804]             }
[10:21:38.804]             function(cond) {
[10:21:38.804]                 is_error <- inherits(cond, "error")
[10:21:38.804]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.804]                   NULL)
[10:21:38.804]                 if (is_error) {
[10:21:38.804]                   sessionInformation <- function() {
[10:21:38.804]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.804]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.804]                       search = base::search(), system = base::Sys.info())
[10:21:38.804]                   }
[10:21:38.804]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.804]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.804]                     cond$call), session = sessionInformation(), 
[10:21:38.804]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.804]                   signalCondition(cond)
[10:21:38.804]                 }
[10:21:38.804]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.804]                 "immediateCondition"))) {
[10:21:38.804]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.804]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.804]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.804]                   if (TRUE && !signal) {
[10:21:38.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.804]                     {
[10:21:38.804]                       inherits <- base::inherits
[10:21:38.804]                       invokeRestart <- base::invokeRestart
[10:21:38.804]                       is.null <- base::is.null
[10:21:38.804]                       muffled <- FALSE
[10:21:38.804]                       if (inherits(cond, "message")) {
[10:21:38.804]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.804]                         if (muffled) 
[10:21:38.804]                           invokeRestart("muffleMessage")
[10:21:38.804]                       }
[10:21:38.804]                       else if (inherits(cond, "warning")) {
[10:21:38.804]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.804]                         if (muffled) 
[10:21:38.804]                           invokeRestart("muffleWarning")
[10:21:38.804]                       }
[10:21:38.804]                       else if (inherits(cond, "condition")) {
[10:21:38.804]                         if (!is.null(pattern)) {
[10:21:38.804]                           computeRestarts <- base::computeRestarts
[10:21:38.804]                           grepl <- base::grepl
[10:21:38.804]                           restarts <- computeRestarts(cond)
[10:21:38.804]                           for (restart in restarts) {
[10:21:38.804]                             name <- restart$name
[10:21:38.804]                             if (is.null(name)) 
[10:21:38.804]                               next
[10:21:38.804]                             if (!grepl(pattern, name)) 
[10:21:38.804]                               next
[10:21:38.804]                             invokeRestart(restart)
[10:21:38.804]                             muffled <- TRUE
[10:21:38.804]                             break
[10:21:38.804]                           }
[10:21:38.804]                         }
[10:21:38.804]                       }
[10:21:38.804]                       invisible(muffled)
[10:21:38.804]                     }
[10:21:38.804]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.804]                   }
[10:21:38.804]                 }
[10:21:38.804]                 else {
[10:21:38.804]                   if (TRUE) {
[10:21:38.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.804]                     {
[10:21:38.804]                       inherits <- base::inherits
[10:21:38.804]                       invokeRestart <- base::invokeRestart
[10:21:38.804]                       is.null <- base::is.null
[10:21:38.804]                       muffled <- FALSE
[10:21:38.804]                       if (inherits(cond, "message")) {
[10:21:38.804]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.804]                         if (muffled) 
[10:21:38.804]                           invokeRestart("muffleMessage")
[10:21:38.804]                       }
[10:21:38.804]                       else if (inherits(cond, "warning")) {
[10:21:38.804]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.804]                         if (muffled) 
[10:21:38.804]                           invokeRestart("muffleWarning")
[10:21:38.804]                       }
[10:21:38.804]                       else if (inherits(cond, "condition")) {
[10:21:38.804]                         if (!is.null(pattern)) {
[10:21:38.804]                           computeRestarts <- base::computeRestarts
[10:21:38.804]                           grepl <- base::grepl
[10:21:38.804]                           restarts <- computeRestarts(cond)
[10:21:38.804]                           for (restart in restarts) {
[10:21:38.804]                             name <- restart$name
[10:21:38.804]                             if (is.null(name)) 
[10:21:38.804]                               next
[10:21:38.804]                             if (!grepl(pattern, name)) 
[10:21:38.804]                               next
[10:21:38.804]                             invokeRestart(restart)
[10:21:38.804]                             muffled <- TRUE
[10:21:38.804]                             break
[10:21:38.804]                           }
[10:21:38.804]                         }
[10:21:38.804]                       }
[10:21:38.804]                       invisible(muffled)
[10:21:38.804]                     }
[10:21:38.804]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.804]                   }
[10:21:38.804]                 }
[10:21:38.804]             }
[10:21:38.804]         }))
[10:21:38.804]     }, error = function(ex) {
[10:21:38.804]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.804]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.804]                 ...future.rng), started = ...future.startTime, 
[10:21:38.804]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.804]             version = "1.8"), class = "FutureResult")
[10:21:38.804]     }, finally = {
[10:21:38.804]         if (!identical(...future.workdir, getwd())) 
[10:21:38.804]             setwd(...future.workdir)
[10:21:38.804]         {
[10:21:38.804]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.804]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.804]             }
[10:21:38.804]             base::options(...future.oldOptions)
[10:21:38.804]             if (.Platform$OS.type == "windows") {
[10:21:38.804]                 old_names <- names(...future.oldEnvVars)
[10:21:38.804]                 envs <- base::Sys.getenv()
[10:21:38.804]                 names <- names(envs)
[10:21:38.804]                 common <- intersect(names, old_names)
[10:21:38.804]                 added <- setdiff(names, old_names)
[10:21:38.804]                 removed <- setdiff(old_names, names)
[10:21:38.804]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.804]                   envs[common]]
[10:21:38.804]                 NAMES <- toupper(changed)
[10:21:38.804]                 args <- list()
[10:21:38.804]                 for (kk in seq_along(NAMES)) {
[10:21:38.804]                   name <- changed[[kk]]
[10:21:38.804]                   NAME <- NAMES[[kk]]
[10:21:38.804]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.804]                     next
[10:21:38.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.804]                 }
[10:21:38.804]                 NAMES <- toupper(added)
[10:21:38.804]                 for (kk in seq_along(NAMES)) {
[10:21:38.804]                   name <- added[[kk]]
[10:21:38.804]                   NAME <- NAMES[[kk]]
[10:21:38.804]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.804]                     next
[10:21:38.804]                   args[[name]] <- ""
[10:21:38.804]                 }
[10:21:38.804]                 NAMES <- toupper(removed)
[10:21:38.804]                 for (kk in seq_along(NAMES)) {
[10:21:38.804]                   name <- removed[[kk]]
[10:21:38.804]                   NAME <- NAMES[[kk]]
[10:21:38.804]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.804]                     next
[10:21:38.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.804]                 }
[10:21:38.804]                 if (length(args) > 0) 
[10:21:38.804]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.804]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.804]             }
[10:21:38.804]             else {
[10:21:38.804]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.804]             }
[10:21:38.804]             {
[10:21:38.804]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.804]                   0L) {
[10:21:38.804]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.804]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.804]                   base::options(opts)
[10:21:38.804]                 }
[10:21:38.804]                 {
[10:21:38.804]                   {
[10:21:38.804]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:38.804]                     NULL
[10:21:38.804]                   }
[10:21:38.804]                   options(future.plan = NULL)
[10:21:38.804]                   if (is.na(NA_character_)) 
[10:21:38.804]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.804]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.804]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.804]                     .init = FALSE)
[10:21:38.804]                 }
[10:21:38.804]             }
[10:21:38.804]         }
[10:21:38.804]     })
[10:21:38.804]     if (TRUE) {
[10:21:38.804]         base::sink(type = "output", split = FALSE)
[10:21:38.804]         if (TRUE) {
[10:21:38.804]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.804]         }
[10:21:38.804]         else {
[10:21:38.804]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.804]         }
[10:21:38.804]         base::close(...future.stdout)
[10:21:38.804]         ...future.stdout <- NULL
[10:21:38.804]     }
[10:21:38.804]     ...future.result$conditions <- ...future.conditions
[10:21:38.804]     ...future.result$finished <- base::Sys.time()
[10:21:38.804]     ...future.result
[10:21:38.804] }
[10:21:38.807] assign_globals() ...
[10:21:38.809] List of 1
[10:21:38.809]  $ x: list()
[10:21:38.809]  - attr(*, "where")=List of 1
[10:21:38.809]   ..$ x:<environment: R_EmptyEnv> 
[10:21:38.809]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:38.809]  - attr(*, "resolved")= logi TRUE
[10:21:38.809]  - attr(*, "total_size")= num 31
[10:21:38.809]  - attr(*, "already-done")= logi TRUE
[10:21:38.812] - copied ‘x’ to environment
[10:21:38.812] assign_globals() ... done
[10:21:38.813] requestCore(): workers = 2
[10:21:38.814] MulticoreFuture started
[10:21:38.815] - Launch lazy future ... done
[10:21:38.815] run() for ‘MulticoreFuture’ ... done
[10:21:38.815] result() for MulticoreFuture ...
[10:21:38.816] plan(): Setting new future strategy stack:
[10:21:38.816] List of future strategies:
[10:21:38.816] 1. sequential:
[10:21:38.816]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.816]    - tweaked: FALSE
[10:21:38.816]    - call: NULL
[10:21:38.817] plan(): nbrOfWorkers() = 1
[10:21:38.819] plan(): Setting new future strategy stack:
[10:21:38.819] List of future strategies:
[10:21:38.819] 1. multicore:
[10:21:38.819]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:38.819]    - tweaked: FALSE
[10:21:38.819]    - call: plan(strategy)
[10:21:38.822] plan(): nbrOfWorkers() = 2
[10:21:38.823] result() for MulticoreFuture ...
[10:21:38.823] result() for MulticoreFuture ... done
[10:21:38.823] result() for MulticoreFuture ... done
[10:21:38.823] result() for MulticoreFuture ...
[10:21:38.823] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.824] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.824] Searching for globals...
[10:21:38.827] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:21:38.827] Searching for globals ... DONE
[10:21:38.827] Resolving globals: TRUE
[10:21:38.828] Resolving any globals that are futures ...
[10:21:38.828] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:21:38.828] Resolving any globals that are futures ... DONE
[10:21:38.828] Resolving futures part of globals (recursively) ...
[10:21:38.829] resolve() on list ...
[10:21:38.829]  recursive: 99
[10:21:38.829]  length: 1
[10:21:38.829]  elements: ‘x’
[10:21:38.829]  length: 0 (resolved future 1)
[10:21:38.829] resolve() on list ... DONE
[10:21:38.829] - globals: [1] ‘x’
[10:21:38.830] Resolving futures part of globals (recursively) ... DONE
[10:21:38.830] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:38.830] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:38.830] - globals: [1] ‘x’
[10:21:38.830] 
[10:21:38.831] getGlobalsAndPackages() ... DONE
[10:21:38.831] run() for ‘Future’ ...
[10:21:38.831] - state: ‘created’
[10:21:38.831] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:38.833] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:38.833] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:38.834]   - Field: ‘label’
[10:21:38.834]   - Field: ‘local’
[10:21:38.834]   - Field: ‘owner’
[10:21:38.834]   - Field: ‘envir’
[10:21:38.834]   - Field: ‘workers’
[10:21:38.834]   - Field: ‘packages’
[10:21:38.834]   - Field: ‘gc’
[10:21:38.834]   - Field: ‘job’
[10:21:38.834]   - Field: ‘conditions’
[10:21:38.835]   - Field: ‘expr’
[10:21:38.835]   - Field: ‘uuid’
[10:21:38.835]   - Field: ‘seed’
[10:21:38.835]   - Field: ‘version’
[10:21:38.835]   - Field: ‘result’
[10:21:38.835]   - Field: ‘asynchronous’
[10:21:38.835]   - Field: ‘calls’
[10:21:38.835]   - Field: ‘globals’
[10:21:38.835]   - Field: ‘stdout’
[10:21:38.836]   - Field: ‘earlySignal’
[10:21:38.836]   - Field: ‘lazy’
[10:21:38.836]   - Field: ‘state’
[10:21:38.836] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:38.836] - Launch lazy future ...
[10:21:38.836] Packages needed by the future expression (n = 0): <none>
[10:21:38.836] Packages needed by future strategies (n = 0): <none>
[10:21:38.837] {
[10:21:38.837]     {
[10:21:38.837]         {
[10:21:38.837]             ...future.startTime <- base::Sys.time()
[10:21:38.837]             {
[10:21:38.837]                 {
[10:21:38.837]                   {
[10:21:38.837]                     {
[10:21:38.837]                       base::local({
[10:21:38.837]                         has_future <- base::requireNamespace("future", 
[10:21:38.837]                           quietly = TRUE)
[10:21:38.837]                         if (has_future) {
[10:21:38.837]                           ns <- base::getNamespace("future")
[10:21:38.837]                           version <- ns[[".package"]][["version"]]
[10:21:38.837]                           if (is.null(version)) 
[10:21:38.837]                             version <- utils::packageVersion("future")
[10:21:38.837]                         }
[10:21:38.837]                         else {
[10:21:38.837]                           version <- NULL
[10:21:38.837]                         }
[10:21:38.837]                         if (!has_future || version < "1.8.0") {
[10:21:38.837]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.837]                             "", base::R.version$version.string), 
[10:21:38.837]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:38.837]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.837]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.837]                               "release", "version")], collapse = " "), 
[10:21:38.837]                             hostname = base::Sys.info()[["nodename"]])
[10:21:38.837]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.837]                             info)
[10:21:38.837]                           info <- base::paste(info, collapse = "; ")
[10:21:38.837]                           if (!has_future) {
[10:21:38.837]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.837]                               info)
[10:21:38.837]                           }
[10:21:38.837]                           else {
[10:21:38.837]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.837]                               info, version)
[10:21:38.837]                           }
[10:21:38.837]                           base::stop(msg)
[10:21:38.837]                         }
[10:21:38.837]                       })
[10:21:38.837]                     }
[10:21:38.837]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:38.837]                     base::options(mc.cores = 1L)
[10:21:38.837]                   }
[10:21:38.837]                   ...future.strategy.old <- future::plan("list")
[10:21:38.837]                   options(future.plan = NULL)
[10:21:38.837]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.837]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.837]                 }
[10:21:38.837]                 ...future.workdir <- getwd()
[10:21:38.837]             }
[10:21:38.837]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.837]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.837]         }
[10:21:38.837]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.837]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.837]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.837]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.837]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.837]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.837]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.837]             base::names(...future.oldOptions))
[10:21:38.837]     }
[10:21:38.837]     if (FALSE) {
[10:21:38.837]     }
[10:21:38.837]     else {
[10:21:38.837]         if (TRUE) {
[10:21:38.837]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.837]                 open = "w")
[10:21:38.837]         }
[10:21:38.837]         else {
[10:21:38.837]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.837]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.837]         }
[10:21:38.837]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.837]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.837]             base::sink(type = "output", split = FALSE)
[10:21:38.837]             base::close(...future.stdout)
[10:21:38.837]         }, add = TRUE)
[10:21:38.837]     }
[10:21:38.837]     ...future.frame <- base::sys.nframe()
[10:21:38.837]     ...future.conditions <- base::list()
[10:21:38.837]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.837]     if (FALSE) {
[10:21:38.837]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.837]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.837]     }
[10:21:38.837]     ...future.result <- base::tryCatch({
[10:21:38.837]         base::withCallingHandlers({
[10:21:38.837]             ...future.value <- base::withVisible(base::local({
[10:21:38.837]                 withCallingHandlers({
[10:21:38.837]                   {
[10:21:38.837]                     x[["a"]] <- 1
[10:21:38.837]                     x
[10:21:38.837]                   }
[10:21:38.837]                 }, immediateCondition = function(cond) {
[10:21:38.837]                   save_rds <- function (object, pathname, ...) 
[10:21:38.837]                   {
[10:21:38.837]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:38.837]                     if (file_test("-f", pathname_tmp)) {
[10:21:38.837]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.837]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:38.837]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.837]                         fi_tmp[["mtime"]])
[10:21:38.837]                     }
[10:21:38.837]                     tryCatch({
[10:21:38.837]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:38.837]                     }, error = function(ex) {
[10:21:38.837]                       msg <- conditionMessage(ex)
[10:21:38.837]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.837]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:38.837]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.837]                         fi_tmp[["mtime"]], msg)
[10:21:38.837]                       ex$message <- msg
[10:21:38.837]                       stop(ex)
[10:21:38.837]                     })
[10:21:38.837]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:38.837]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:38.837]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:38.837]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.837]                       fi <- file.info(pathname)
[10:21:38.837]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:38.837]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.837]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:38.837]                         fi[["size"]], fi[["mtime"]])
[10:21:38.837]                       stop(msg)
[10:21:38.837]                     }
[10:21:38.837]                     invisible(pathname)
[10:21:38.837]                   }
[10:21:38.837]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:38.837]                     rootPath = tempdir()) 
[10:21:38.837]                   {
[10:21:38.837]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:38.837]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:38.837]                       tmpdir = path, fileext = ".rds")
[10:21:38.837]                     save_rds(obj, file)
[10:21:38.837]                   }
[10:21:38.837]                   saveImmediateCondition(cond, path = "/tmp/Rtmpfpiz4I/.future/immediateConditions")
[10:21:38.837]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.837]                   {
[10:21:38.837]                     inherits <- base::inherits
[10:21:38.837]                     invokeRestart <- base::invokeRestart
[10:21:38.837]                     is.null <- base::is.null
[10:21:38.837]                     muffled <- FALSE
[10:21:38.837]                     if (inherits(cond, "message")) {
[10:21:38.837]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:38.837]                       if (muffled) 
[10:21:38.837]                         invokeRestart("muffleMessage")
[10:21:38.837]                     }
[10:21:38.837]                     else if (inherits(cond, "warning")) {
[10:21:38.837]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:38.837]                       if (muffled) 
[10:21:38.837]                         invokeRestart("muffleWarning")
[10:21:38.837]                     }
[10:21:38.837]                     else if (inherits(cond, "condition")) {
[10:21:38.837]                       if (!is.null(pattern)) {
[10:21:38.837]                         computeRestarts <- base::computeRestarts
[10:21:38.837]                         grepl <- base::grepl
[10:21:38.837]                         restarts <- computeRestarts(cond)
[10:21:38.837]                         for (restart in restarts) {
[10:21:38.837]                           name <- restart$name
[10:21:38.837]                           if (is.null(name)) 
[10:21:38.837]                             next
[10:21:38.837]                           if (!grepl(pattern, name)) 
[10:21:38.837]                             next
[10:21:38.837]                           invokeRestart(restart)
[10:21:38.837]                           muffled <- TRUE
[10:21:38.837]                           break
[10:21:38.837]                         }
[10:21:38.837]                       }
[10:21:38.837]                     }
[10:21:38.837]                     invisible(muffled)
[10:21:38.837]                   }
[10:21:38.837]                   muffleCondition(cond)
[10:21:38.837]                 })
[10:21:38.837]             }))
[10:21:38.837]             future::FutureResult(value = ...future.value$value, 
[10:21:38.837]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.837]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.837]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.837]                     ...future.globalenv.names))
[10:21:38.837]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.837]         }, condition = base::local({
[10:21:38.837]             c <- base::c
[10:21:38.837]             inherits <- base::inherits
[10:21:38.837]             invokeRestart <- base::invokeRestart
[10:21:38.837]             length <- base::length
[10:21:38.837]             list <- base::list
[10:21:38.837]             seq.int <- base::seq.int
[10:21:38.837]             signalCondition <- base::signalCondition
[10:21:38.837]             sys.calls <- base::sys.calls
[10:21:38.837]             `[[` <- base::`[[`
[10:21:38.837]             `+` <- base::`+`
[10:21:38.837]             `<<-` <- base::`<<-`
[10:21:38.837]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.837]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.837]                   3L)]
[10:21:38.837]             }
[10:21:38.837]             function(cond) {
[10:21:38.837]                 is_error <- inherits(cond, "error")
[10:21:38.837]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.837]                   NULL)
[10:21:38.837]                 if (is_error) {
[10:21:38.837]                   sessionInformation <- function() {
[10:21:38.837]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.837]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.837]                       search = base::search(), system = base::Sys.info())
[10:21:38.837]                   }
[10:21:38.837]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.837]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.837]                     cond$call), session = sessionInformation(), 
[10:21:38.837]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.837]                   signalCondition(cond)
[10:21:38.837]                 }
[10:21:38.837]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.837]                 "immediateCondition"))) {
[10:21:38.837]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.837]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.837]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.837]                   if (TRUE && !signal) {
[10:21:38.837]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.837]                     {
[10:21:38.837]                       inherits <- base::inherits
[10:21:38.837]                       invokeRestart <- base::invokeRestart
[10:21:38.837]                       is.null <- base::is.null
[10:21:38.837]                       muffled <- FALSE
[10:21:38.837]                       if (inherits(cond, "message")) {
[10:21:38.837]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.837]                         if (muffled) 
[10:21:38.837]                           invokeRestart("muffleMessage")
[10:21:38.837]                       }
[10:21:38.837]                       else if (inherits(cond, "warning")) {
[10:21:38.837]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.837]                         if (muffled) 
[10:21:38.837]                           invokeRestart("muffleWarning")
[10:21:38.837]                       }
[10:21:38.837]                       else if (inherits(cond, "condition")) {
[10:21:38.837]                         if (!is.null(pattern)) {
[10:21:38.837]                           computeRestarts <- base::computeRestarts
[10:21:38.837]                           grepl <- base::grepl
[10:21:38.837]                           restarts <- computeRestarts(cond)
[10:21:38.837]                           for (restart in restarts) {
[10:21:38.837]                             name <- restart$name
[10:21:38.837]                             if (is.null(name)) 
[10:21:38.837]                               next
[10:21:38.837]                             if (!grepl(pattern, name)) 
[10:21:38.837]                               next
[10:21:38.837]                             invokeRestart(restart)
[10:21:38.837]                             muffled <- TRUE
[10:21:38.837]                             break
[10:21:38.837]                           }
[10:21:38.837]                         }
[10:21:38.837]                       }
[10:21:38.837]                       invisible(muffled)
[10:21:38.837]                     }
[10:21:38.837]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.837]                   }
[10:21:38.837]                 }
[10:21:38.837]                 else {
[10:21:38.837]                   if (TRUE) {
[10:21:38.837]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.837]                     {
[10:21:38.837]                       inherits <- base::inherits
[10:21:38.837]                       invokeRestart <- base::invokeRestart
[10:21:38.837]                       is.null <- base::is.null
[10:21:38.837]                       muffled <- FALSE
[10:21:38.837]                       if (inherits(cond, "message")) {
[10:21:38.837]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.837]                         if (muffled) 
[10:21:38.837]                           invokeRestart("muffleMessage")
[10:21:38.837]                       }
[10:21:38.837]                       else if (inherits(cond, "warning")) {
[10:21:38.837]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.837]                         if (muffled) 
[10:21:38.837]                           invokeRestart("muffleWarning")
[10:21:38.837]                       }
[10:21:38.837]                       else if (inherits(cond, "condition")) {
[10:21:38.837]                         if (!is.null(pattern)) {
[10:21:38.837]                           computeRestarts <- base::computeRestarts
[10:21:38.837]                           grepl <- base::grepl
[10:21:38.837]                           restarts <- computeRestarts(cond)
[10:21:38.837]                           for (restart in restarts) {
[10:21:38.837]                             name <- restart$name
[10:21:38.837]                             if (is.null(name)) 
[10:21:38.837]                               next
[10:21:38.837]                             if (!grepl(pattern, name)) 
[10:21:38.837]                               next
[10:21:38.837]                             invokeRestart(restart)
[10:21:38.837]                             muffled <- TRUE
[10:21:38.837]                             break
[10:21:38.837]                           }
[10:21:38.837]                         }
[10:21:38.837]                       }
[10:21:38.837]                       invisible(muffled)
[10:21:38.837]                     }
[10:21:38.837]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.837]                   }
[10:21:38.837]                 }
[10:21:38.837]             }
[10:21:38.837]         }))
[10:21:38.837]     }, error = function(ex) {
[10:21:38.837]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.837]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.837]                 ...future.rng), started = ...future.startTime, 
[10:21:38.837]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.837]             version = "1.8"), class = "FutureResult")
[10:21:38.837]     }, finally = {
[10:21:38.837]         if (!identical(...future.workdir, getwd())) 
[10:21:38.837]             setwd(...future.workdir)
[10:21:38.837]         {
[10:21:38.837]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.837]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.837]             }
[10:21:38.837]             base::options(...future.oldOptions)
[10:21:38.837]             if (.Platform$OS.type == "windows") {
[10:21:38.837]                 old_names <- names(...future.oldEnvVars)
[10:21:38.837]                 envs <- base::Sys.getenv()
[10:21:38.837]                 names <- names(envs)
[10:21:38.837]                 common <- intersect(names, old_names)
[10:21:38.837]                 added <- setdiff(names, old_names)
[10:21:38.837]                 removed <- setdiff(old_names, names)
[10:21:38.837]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.837]                   envs[common]]
[10:21:38.837]                 NAMES <- toupper(changed)
[10:21:38.837]                 args <- list()
[10:21:38.837]                 for (kk in seq_along(NAMES)) {
[10:21:38.837]                   name <- changed[[kk]]
[10:21:38.837]                   NAME <- NAMES[[kk]]
[10:21:38.837]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.837]                     next
[10:21:38.837]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.837]                 }
[10:21:38.837]                 NAMES <- toupper(added)
[10:21:38.837]                 for (kk in seq_along(NAMES)) {
[10:21:38.837]                   name <- added[[kk]]
[10:21:38.837]                   NAME <- NAMES[[kk]]
[10:21:38.837]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.837]                     next
[10:21:38.837]                   args[[name]] <- ""
[10:21:38.837]                 }
[10:21:38.837]                 NAMES <- toupper(removed)
[10:21:38.837]                 for (kk in seq_along(NAMES)) {
[10:21:38.837]                   name <- removed[[kk]]
[10:21:38.837]                   NAME <- NAMES[[kk]]
[10:21:38.837]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.837]                     next
[10:21:38.837]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.837]                 }
[10:21:38.837]                 if (length(args) > 0) 
[10:21:38.837]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.837]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.837]             }
[10:21:38.837]             else {
[10:21:38.837]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.837]             }
[10:21:38.837]             {
[10:21:38.837]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.837]                   0L) {
[10:21:38.837]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.837]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.837]                   base::options(opts)
[10:21:38.837]                 }
[10:21:38.837]                 {
[10:21:38.837]                   {
[10:21:38.837]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:38.837]                     NULL
[10:21:38.837]                   }
[10:21:38.837]                   options(future.plan = NULL)
[10:21:38.837]                   if (is.na(NA_character_)) 
[10:21:38.837]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.837]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.837]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.837]                     .init = FALSE)
[10:21:38.837]                 }
[10:21:38.837]             }
[10:21:38.837]         }
[10:21:38.837]     })
[10:21:38.837]     if (TRUE) {
[10:21:38.837]         base::sink(type = "output", split = FALSE)
[10:21:38.837]         if (TRUE) {
[10:21:38.837]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.837]         }
[10:21:38.837]         else {
[10:21:38.837]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.837]         }
[10:21:38.837]         base::close(...future.stdout)
[10:21:38.837]         ...future.stdout <- NULL
[10:21:38.837]     }
[10:21:38.837]     ...future.result$conditions <- ...future.conditions
[10:21:38.837]     ...future.result$finished <- base::Sys.time()
[10:21:38.837]     ...future.result
[10:21:38.837] }
[10:21:38.840] assign_globals() ...
[10:21:38.840] List of 1
[10:21:38.840]  $ x: list()
[10:21:38.840]  - attr(*, "where")=List of 1
[10:21:38.840]   ..$ x:<environment: R_EmptyEnv> 
[10:21:38.840]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:38.840]  - attr(*, "resolved")= logi TRUE
[10:21:38.840]  - attr(*, "total_size")= num 31
[10:21:38.840]  - attr(*, "already-done")= logi TRUE
[10:21:38.843] - copied ‘x’ to environment
[10:21:38.843] assign_globals() ... done
[10:21:38.843] requestCore(): workers = 2
[10:21:38.845] MulticoreFuture started
[10:21:38.846] - Launch lazy future ... done
[10:21:38.846] run() for ‘MulticoreFuture’ ... done
[10:21:38.846] result() for MulticoreFuture ...
[10:21:38.846] plan(): Setting new future strategy stack:
[10:21:38.846] List of future strategies:
[10:21:38.846] 1. sequential:
[10:21:38.846]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.846]    - tweaked: FALSE
[10:21:38.846]    - call: NULL
[10:21:38.847] plan(): nbrOfWorkers() = 1
[10:21:38.849] plan(): Setting new future strategy stack:
[10:21:38.850] List of future strategies:
[10:21:38.850] 1. multicore:
[10:21:38.850]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:38.850]    - tweaked: FALSE
[10:21:38.850]    - call: plan(strategy)
[10:21:38.853] plan(): nbrOfWorkers() = 2
[10:21:38.853] result() for MulticoreFuture ...
[10:21:38.854] result() for MulticoreFuture ... done
[10:21:38.854] result() for MulticoreFuture ... done
[10:21:38.854] result() for MulticoreFuture ...
[10:21:38.854] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.854] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.855] Searching for globals...
[10:21:38.858] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:21:38.858] Searching for globals ... DONE
[10:21:38.858] Resolving globals: TRUE
[10:21:38.858] Resolving any globals that are futures ...
[10:21:38.858] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:21:38.858] Resolving any globals that are futures ... DONE
[10:21:38.859] Resolving futures part of globals (recursively) ...
[10:21:38.861] resolve() on list ...
[10:21:38.862]  recursive: 99
[10:21:38.862]  length: 1
[10:21:38.862]  elements: ‘x’
[10:21:38.862]  length: 0 (resolved future 1)
[10:21:38.862] resolve() on list ... DONE
[10:21:38.862] - globals: [1] ‘x’
[10:21:38.863] Resolving futures part of globals (recursively) ... DONE
[10:21:38.863] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:38.863] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:38.863] - globals: [1] ‘x’
[10:21:38.864] 
[10:21:38.864] getGlobalsAndPackages() ... DONE
[10:21:38.864] run() for ‘Future’ ...
[10:21:38.864] - state: ‘created’
[10:21:38.864] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:38.866] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:38.866] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:38.867]   - Field: ‘label’
[10:21:38.867]   - Field: ‘local’
[10:21:38.867]   - Field: ‘owner’
[10:21:38.867]   - Field: ‘envir’
[10:21:38.867]   - Field: ‘workers’
[10:21:38.867]   - Field: ‘packages’
[10:21:38.867]   - Field: ‘gc’
[10:21:38.867]   - Field: ‘job’
[10:21:38.867]   - Field: ‘conditions’
[10:21:38.868]   - Field: ‘expr’
[10:21:38.868]   - Field: ‘uuid’
[10:21:38.868]   - Field: ‘seed’
[10:21:38.868]   - Field: ‘version’
[10:21:38.868]   - Field: ‘result’
[10:21:38.868]   - Field: ‘asynchronous’
[10:21:38.868]   - Field: ‘calls’
[10:21:38.868]   - Field: ‘globals’
[10:21:38.868]   - Field: ‘stdout’
[10:21:38.869]   - Field: ‘earlySignal’
[10:21:38.869]   - Field: ‘lazy’
[10:21:38.869]   - Field: ‘state’
[10:21:38.869] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:38.869] - Launch lazy future ...
[10:21:38.869] Packages needed by the future expression (n = 0): <none>
[10:21:38.870] Packages needed by future strategies (n = 0): <none>
[10:21:38.870] {
[10:21:38.870]     {
[10:21:38.870]         {
[10:21:38.870]             ...future.startTime <- base::Sys.time()
[10:21:38.870]             {
[10:21:38.870]                 {
[10:21:38.870]                   {
[10:21:38.870]                     {
[10:21:38.870]                       base::local({
[10:21:38.870]                         has_future <- base::requireNamespace("future", 
[10:21:38.870]                           quietly = TRUE)
[10:21:38.870]                         if (has_future) {
[10:21:38.870]                           ns <- base::getNamespace("future")
[10:21:38.870]                           version <- ns[[".package"]][["version"]]
[10:21:38.870]                           if (is.null(version)) 
[10:21:38.870]                             version <- utils::packageVersion("future")
[10:21:38.870]                         }
[10:21:38.870]                         else {
[10:21:38.870]                           version <- NULL
[10:21:38.870]                         }
[10:21:38.870]                         if (!has_future || version < "1.8.0") {
[10:21:38.870]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.870]                             "", base::R.version$version.string), 
[10:21:38.870]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:38.870]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.870]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.870]                               "release", "version")], collapse = " "), 
[10:21:38.870]                             hostname = base::Sys.info()[["nodename"]])
[10:21:38.870]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.870]                             info)
[10:21:38.870]                           info <- base::paste(info, collapse = "; ")
[10:21:38.870]                           if (!has_future) {
[10:21:38.870]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.870]                               info)
[10:21:38.870]                           }
[10:21:38.870]                           else {
[10:21:38.870]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.870]                               info, version)
[10:21:38.870]                           }
[10:21:38.870]                           base::stop(msg)
[10:21:38.870]                         }
[10:21:38.870]                       })
[10:21:38.870]                     }
[10:21:38.870]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:38.870]                     base::options(mc.cores = 1L)
[10:21:38.870]                   }
[10:21:38.870]                   ...future.strategy.old <- future::plan("list")
[10:21:38.870]                   options(future.plan = NULL)
[10:21:38.870]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.870]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.870]                 }
[10:21:38.870]                 ...future.workdir <- getwd()
[10:21:38.870]             }
[10:21:38.870]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.870]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.870]         }
[10:21:38.870]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.870]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.870]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.870]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.870]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.870]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.870]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.870]             base::names(...future.oldOptions))
[10:21:38.870]     }
[10:21:38.870]     if (FALSE) {
[10:21:38.870]     }
[10:21:38.870]     else {
[10:21:38.870]         if (TRUE) {
[10:21:38.870]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.870]                 open = "w")
[10:21:38.870]         }
[10:21:38.870]         else {
[10:21:38.870]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.870]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.870]         }
[10:21:38.870]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.870]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.870]             base::sink(type = "output", split = FALSE)
[10:21:38.870]             base::close(...future.stdout)
[10:21:38.870]         }, add = TRUE)
[10:21:38.870]     }
[10:21:38.870]     ...future.frame <- base::sys.nframe()
[10:21:38.870]     ...future.conditions <- base::list()
[10:21:38.870]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.870]     if (FALSE) {
[10:21:38.870]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.870]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.870]     }
[10:21:38.870]     ...future.result <- base::tryCatch({
[10:21:38.870]         base::withCallingHandlers({
[10:21:38.870]             ...future.value <- base::withVisible(base::local({
[10:21:38.870]                 withCallingHandlers({
[10:21:38.870]                   {
[10:21:38.870]                     x["a"] <- list(1)
[10:21:38.870]                     x
[10:21:38.870]                   }
[10:21:38.870]                 }, immediateCondition = function(cond) {
[10:21:38.870]                   save_rds <- function (object, pathname, ...) 
[10:21:38.870]                   {
[10:21:38.870]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:38.870]                     if (file_test("-f", pathname_tmp)) {
[10:21:38.870]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.870]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:38.870]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.870]                         fi_tmp[["mtime"]])
[10:21:38.870]                     }
[10:21:38.870]                     tryCatch({
[10:21:38.870]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:38.870]                     }, error = function(ex) {
[10:21:38.870]                       msg <- conditionMessage(ex)
[10:21:38.870]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.870]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:38.870]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.870]                         fi_tmp[["mtime"]], msg)
[10:21:38.870]                       ex$message <- msg
[10:21:38.870]                       stop(ex)
[10:21:38.870]                     })
[10:21:38.870]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:38.870]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:38.870]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:38.870]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.870]                       fi <- file.info(pathname)
[10:21:38.870]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:38.870]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.870]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:38.870]                         fi[["size"]], fi[["mtime"]])
[10:21:38.870]                       stop(msg)
[10:21:38.870]                     }
[10:21:38.870]                     invisible(pathname)
[10:21:38.870]                   }
[10:21:38.870]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:38.870]                     rootPath = tempdir()) 
[10:21:38.870]                   {
[10:21:38.870]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:38.870]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:38.870]                       tmpdir = path, fileext = ".rds")
[10:21:38.870]                     save_rds(obj, file)
[10:21:38.870]                   }
[10:21:38.870]                   saveImmediateCondition(cond, path = "/tmp/Rtmpfpiz4I/.future/immediateConditions")
[10:21:38.870]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.870]                   {
[10:21:38.870]                     inherits <- base::inherits
[10:21:38.870]                     invokeRestart <- base::invokeRestart
[10:21:38.870]                     is.null <- base::is.null
[10:21:38.870]                     muffled <- FALSE
[10:21:38.870]                     if (inherits(cond, "message")) {
[10:21:38.870]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:38.870]                       if (muffled) 
[10:21:38.870]                         invokeRestart("muffleMessage")
[10:21:38.870]                     }
[10:21:38.870]                     else if (inherits(cond, "warning")) {
[10:21:38.870]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:38.870]                       if (muffled) 
[10:21:38.870]                         invokeRestart("muffleWarning")
[10:21:38.870]                     }
[10:21:38.870]                     else if (inherits(cond, "condition")) {
[10:21:38.870]                       if (!is.null(pattern)) {
[10:21:38.870]                         computeRestarts <- base::computeRestarts
[10:21:38.870]                         grepl <- base::grepl
[10:21:38.870]                         restarts <- computeRestarts(cond)
[10:21:38.870]                         for (restart in restarts) {
[10:21:38.870]                           name <- restart$name
[10:21:38.870]                           if (is.null(name)) 
[10:21:38.870]                             next
[10:21:38.870]                           if (!grepl(pattern, name)) 
[10:21:38.870]                             next
[10:21:38.870]                           invokeRestart(restart)
[10:21:38.870]                           muffled <- TRUE
[10:21:38.870]                           break
[10:21:38.870]                         }
[10:21:38.870]                       }
[10:21:38.870]                     }
[10:21:38.870]                     invisible(muffled)
[10:21:38.870]                   }
[10:21:38.870]                   muffleCondition(cond)
[10:21:38.870]                 })
[10:21:38.870]             }))
[10:21:38.870]             future::FutureResult(value = ...future.value$value, 
[10:21:38.870]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.870]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.870]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.870]                     ...future.globalenv.names))
[10:21:38.870]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.870]         }, condition = base::local({
[10:21:38.870]             c <- base::c
[10:21:38.870]             inherits <- base::inherits
[10:21:38.870]             invokeRestart <- base::invokeRestart
[10:21:38.870]             length <- base::length
[10:21:38.870]             list <- base::list
[10:21:38.870]             seq.int <- base::seq.int
[10:21:38.870]             signalCondition <- base::signalCondition
[10:21:38.870]             sys.calls <- base::sys.calls
[10:21:38.870]             `[[` <- base::`[[`
[10:21:38.870]             `+` <- base::`+`
[10:21:38.870]             `<<-` <- base::`<<-`
[10:21:38.870]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.870]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.870]                   3L)]
[10:21:38.870]             }
[10:21:38.870]             function(cond) {
[10:21:38.870]                 is_error <- inherits(cond, "error")
[10:21:38.870]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.870]                   NULL)
[10:21:38.870]                 if (is_error) {
[10:21:38.870]                   sessionInformation <- function() {
[10:21:38.870]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.870]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.870]                       search = base::search(), system = base::Sys.info())
[10:21:38.870]                   }
[10:21:38.870]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.870]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.870]                     cond$call), session = sessionInformation(), 
[10:21:38.870]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.870]                   signalCondition(cond)
[10:21:38.870]                 }
[10:21:38.870]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.870]                 "immediateCondition"))) {
[10:21:38.870]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.870]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.870]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.870]                   if (TRUE && !signal) {
[10:21:38.870]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.870]                     {
[10:21:38.870]                       inherits <- base::inherits
[10:21:38.870]                       invokeRestart <- base::invokeRestart
[10:21:38.870]                       is.null <- base::is.null
[10:21:38.870]                       muffled <- FALSE
[10:21:38.870]                       if (inherits(cond, "message")) {
[10:21:38.870]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.870]                         if (muffled) 
[10:21:38.870]                           invokeRestart("muffleMessage")
[10:21:38.870]                       }
[10:21:38.870]                       else if (inherits(cond, "warning")) {
[10:21:38.870]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.870]                         if (muffled) 
[10:21:38.870]                           invokeRestart("muffleWarning")
[10:21:38.870]                       }
[10:21:38.870]                       else if (inherits(cond, "condition")) {
[10:21:38.870]                         if (!is.null(pattern)) {
[10:21:38.870]                           computeRestarts <- base::computeRestarts
[10:21:38.870]                           grepl <- base::grepl
[10:21:38.870]                           restarts <- computeRestarts(cond)
[10:21:38.870]                           for (restart in restarts) {
[10:21:38.870]                             name <- restart$name
[10:21:38.870]                             if (is.null(name)) 
[10:21:38.870]                               next
[10:21:38.870]                             if (!grepl(pattern, name)) 
[10:21:38.870]                               next
[10:21:38.870]                             invokeRestart(restart)
[10:21:38.870]                             muffled <- TRUE
[10:21:38.870]                             break
[10:21:38.870]                           }
[10:21:38.870]                         }
[10:21:38.870]                       }
[10:21:38.870]                       invisible(muffled)
[10:21:38.870]                     }
[10:21:38.870]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.870]                   }
[10:21:38.870]                 }
[10:21:38.870]                 else {
[10:21:38.870]                   if (TRUE) {
[10:21:38.870]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.870]                     {
[10:21:38.870]                       inherits <- base::inherits
[10:21:38.870]                       invokeRestart <- base::invokeRestart
[10:21:38.870]                       is.null <- base::is.null
[10:21:38.870]                       muffled <- FALSE
[10:21:38.870]                       if (inherits(cond, "message")) {
[10:21:38.870]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.870]                         if (muffled) 
[10:21:38.870]                           invokeRestart("muffleMessage")
[10:21:38.870]                       }
[10:21:38.870]                       else if (inherits(cond, "warning")) {
[10:21:38.870]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.870]                         if (muffled) 
[10:21:38.870]                           invokeRestart("muffleWarning")
[10:21:38.870]                       }
[10:21:38.870]                       else if (inherits(cond, "condition")) {
[10:21:38.870]                         if (!is.null(pattern)) {
[10:21:38.870]                           computeRestarts <- base::computeRestarts
[10:21:38.870]                           grepl <- base::grepl
[10:21:38.870]                           restarts <- computeRestarts(cond)
[10:21:38.870]                           for (restart in restarts) {
[10:21:38.870]                             name <- restart$name
[10:21:38.870]                             if (is.null(name)) 
[10:21:38.870]                               next
[10:21:38.870]                             if (!grepl(pattern, name)) 
[10:21:38.870]                               next
[10:21:38.870]                             invokeRestart(restart)
[10:21:38.870]                             muffled <- TRUE
[10:21:38.870]                             break
[10:21:38.870]                           }
[10:21:38.870]                         }
[10:21:38.870]                       }
[10:21:38.870]                       invisible(muffled)
[10:21:38.870]                     }
[10:21:38.870]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.870]                   }
[10:21:38.870]                 }
[10:21:38.870]             }
[10:21:38.870]         }))
[10:21:38.870]     }, error = function(ex) {
[10:21:38.870]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.870]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.870]                 ...future.rng), started = ...future.startTime, 
[10:21:38.870]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.870]             version = "1.8"), class = "FutureResult")
[10:21:38.870]     }, finally = {
[10:21:38.870]         if (!identical(...future.workdir, getwd())) 
[10:21:38.870]             setwd(...future.workdir)
[10:21:38.870]         {
[10:21:38.870]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.870]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.870]             }
[10:21:38.870]             base::options(...future.oldOptions)
[10:21:38.870]             if (.Platform$OS.type == "windows") {
[10:21:38.870]                 old_names <- names(...future.oldEnvVars)
[10:21:38.870]                 envs <- base::Sys.getenv()
[10:21:38.870]                 names <- names(envs)
[10:21:38.870]                 common <- intersect(names, old_names)
[10:21:38.870]                 added <- setdiff(names, old_names)
[10:21:38.870]                 removed <- setdiff(old_names, names)
[10:21:38.870]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.870]                   envs[common]]
[10:21:38.870]                 NAMES <- toupper(changed)
[10:21:38.870]                 args <- list()
[10:21:38.870]                 for (kk in seq_along(NAMES)) {
[10:21:38.870]                   name <- changed[[kk]]
[10:21:38.870]                   NAME <- NAMES[[kk]]
[10:21:38.870]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.870]                     next
[10:21:38.870]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.870]                 }
[10:21:38.870]                 NAMES <- toupper(added)
[10:21:38.870]                 for (kk in seq_along(NAMES)) {
[10:21:38.870]                   name <- added[[kk]]
[10:21:38.870]                   NAME <- NAMES[[kk]]
[10:21:38.870]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.870]                     next
[10:21:38.870]                   args[[name]] <- ""
[10:21:38.870]                 }
[10:21:38.870]                 NAMES <- toupper(removed)
[10:21:38.870]                 for (kk in seq_along(NAMES)) {
[10:21:38.870]                   name <- removed[[kk]]
[10:21:38.870]                   NAME <- NAMES[[kk]]
[10:21:38.870]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.870]                     next
[10:21:38.870]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.870]                 }
[10:21:38.870]                 if (length(args) > 0) 
[10:21:38.870]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.870]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.870]             }
[10:21:38.870]             else {
[10:21:38.870]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.870]             }
[10:21:38.870]             {
[10:21:38.870]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.870]                   0L) {
[10:21:38.870]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.870]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.870]                   base::options(opts)
[10:21:38.870]                 }
[10:21:38.870]                 {
[10:21:38.870]                   {
[10:21:38.870]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:38.870]                     NULL
[10:21:38.870]                   }
[10:21:38.870]                   options(future.plan = NULL)
[10:21:38.870]                   if (is.na(NA_character_)) 
[10:21:38.870]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.870]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.870]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.870]                     .init = FALSE)
[10:21:38.870]                 }
[10:21:38.870]             }
[10:21:38.870]         }
[10:21:38.870]     })
[10:21:38.870]     if (TRUE) {
[10:21:38.870]         base::sink(type = "output", split = FALSE)
[10:21:38.870]         if (TRUE) {
[10:21:38.870]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.870]         }
[10:21:38.870]         else {
[10:21:38.870]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.870]         }
[10:21:38.870]         base::close(...future.stdout)
[10:21:38.870]         ...future.stdout <- NULL
[10:21:38.870]     }
[10:21:38.870]     ...future.result$conditions <- ...future.conditions
[10:21:38.870]     ...future.result$finished <- base::Sys.time()
[10:21:38.870]     ...future.result
[10:21:38.870] }
[10:21:38.873] assign_globals() ...
[10:21:38.873] List of 1
[10:21:38.873]  $ x: list()
[10:21:38.873]  - attr(*, "where")=List of 1
[10:21:38.873]   ..$ x:<environment: R_EmptyEnv> 
[10:21:38.873]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:38.873]  - attr(*, "resolved")= logi TRUE
[10:21:38.873]  - attr(*, "total_size")= num 31
[10:21:38.873]  - attr(*, "already-done")= logi TRUE
[10:21:38.875] - copied ‘x’ to environment
[10:21:38.876] assign_globals() ... done
[10:21:38.876] requestCore(): workers = 2
[10:21:38.878] MulticoreFuture started
[10:21:38.878] - Launch lazy future ... done
[10:21:38.878] run() for ‘MulticoreFuture’ ... done
[10:21:38.879] result() for MulticoreFuture ...
[10:21:38.879] plan(): Setting new future strategy stack:
[10:21:38.879] List of future strategies:
[10:21:38.879] 1. sequential:
[10:21:38.879]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.879]    - tweaked: FALSE
[10:21:38.879]    - call: NULL
[10:21:38.880] plan(): nbrOfWorkers() = 1
[10:21:38.882] plan(): Setting new future strategy stack:
[10:21:38.882] List of future strategies:
[10:21:38.882] 1. multicore:
[10:21:38.882]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:38.882]    - tweaked: FALSE
[10:21:38.882]    - call: plan(strategy)
[10:21:38.885] plan(): nbrOfWorkers() = 2
[10:21:38.886] result() for MulticoreFuture ...
[10:21:38.886] result() for MulticoreFuture ... done
[10:21:38.886] result() for MulticoreFuture ... done
[10:21:38.886] result() for MulticoreFuture ...
[10:21:38.886] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.887] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.887] Searching for globals...
[10:21:38.890] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:21:38.890] Searching for globals ... DONE
[10:21:38.890] Resolving globals: TRUE
[10:21:38.891] Resolving any globals that are futures ...
[10:21:38.891] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:21:38.891] Resolving any globals that are futures ... DONE
[10:21:38.891] Resolving futures part of globals (recursively) ...
[10:21:38.892] resolve() on list ...
[10:21:38.892]  recursive: 99
[10:21:38.892]  length: 1
[10:21:38.892]  elements: ‘x’
[10:21:38.892]  length: 0 (resolved future 1)
[10:21:38.892] resolve() on list ... DONE
[10:21:38.892] - globals: [1] ‘x’
[10:21:38.893] Resolving futures part of globals (recursively) ... DONE
[10:21:38.893] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:38.893] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:38.893] - globals: [1] ‘x’
[10:21:38.893] 
[10:21:38.893] getGlobalsAndPackages() ... DONE
[10:21:38.894] run() for ‘Future’ ...
[10:21:38.894] - state: ‘created’
[10:21:38.894] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:38.896] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:38.896] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:38.896]   - Field: ‘label’
[10:21:38.897]   - Field: ‘local’
[10:21:38.897]   - Field: ‘owner’
[10:21:38.897]   - Field: ‘envir’
[10:21:38.897]   - Field: ‘workers’
[10:21:38.897]   - Field: ‘packages’
[10:21:38.897]   - Field: ‘gc’
[10:21:38.897]   - Field: ‘job’
[10:21:38.897]   - Field: ‘conditions’
[10:21:38.897]   - Field: ‘expr’
[10:21:38.898]   - Field: ‘uuid’
[10:21:38.898]   - Field: ‘seed’
[10:21:38.898]   - Field: ‘version’
[10:21:38.898]   - Field: ‘result’
[10:21:38.898]   - Field: ‘asynchronous’
[10:21:38.898]   - Field: ‘calls’
[10:21:38.898]   - Field: ‘globals’
[10:21:38.898]   - Field: ‘stdout’
[10:21:38.898]   - Field: ‘earlySignal’
[10:21:38.899]   - Field: ‘lazy’
[10:21:38.899]   - Field: ‘state’
[10:21:38.899] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:38.899] - Launch lazy future ...
[10:21:38.899] Packages needed by the future expression (n = 0): <none>
[10:21:38.899] Packages needed by future strategies (n = 0): <none>
[10:21:38.900] {
[10:21:38.900]     {
[10:21:38.900]         {
[10:21:38.900]             ...future.startTime <- base::Sys.time()
[10:21:38.900]             {
[10:21:38.900]                 {
[10:21:38.900]                   {
[10:21:38.900]                     {
[10:21:38.900]                       base::local({
[10:21:38.900]                         has_future <- base::requireNamespace("future", 
[10:21:38.900]                           quietly = TRUE)
[10:21:38.900]                         if (has_future) {
[10:21:38.900]                           ns <- base::getNamespace("future")
[10:21:38.900]                           version <- ns[[".package"]][["version"]]
[10:21:38.900]                           if (is.null(version)) 
[10:21:38.900]                             version <- utils::packageVersion("future")
[10:21:38.900]                         }
[10:21:38.900]                         else {
[10:21:38.900]                           version <- NULL
[10:21:38.900]                         }
[10:21:38.900]                         if (!has_future || version < "1.8.0") {
[10:21:38.900]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.900]                             "", base::R.version$version.string), 
[10:21:38.900]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:38.900]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.900]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.900]                               "release", "version")], collapse = " "), 
[10:21:38.900]                             hostname = base::Sys.info()[["nodename"]])
[10:21:38.900]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.900]                             info)
[10:21:38.900]                           info <- base::paste(info, collapse = "; ")
[10:21:38.900]                           if (!has_future) {
[10:21:38.900]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.900]                               info)
[10:21:38.900]                           }
[10:21:38.900]                           else {
[10:21:38.900]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.900]                               info, version)
[10:21:38.900]                           }
[10:21:38.900]                           base::stop(msg)
[10:21:38.900]                         }
[10:21:38.900]                       })
[10:21:38.900]                     }
[10:21:38.900]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:38.900]                     base::options(mc.cores = 1L)
[10:21:38.900]                   }
[10:21:38.900]                   ...future.strategy.old <- future::plan("list")
[10:21:38.900]                   options(future.plan = NULL)
[10:21:38.900]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.900]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.900]                 }
[10:21:38.900]                 ...future.workdir <- getwd()
[10:21:38.900]             }
[10:21:38.900]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.900]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.900]         }
[10:21:38.900]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.900]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.900]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.900]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.900]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.900]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.900]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.900]             base::names(...future.oldOptions))
[10:21:38.900]     }
[10:21:38.900]     if (FALSE) {
[10:21:38.900]     }
[10:21:38.900]     else {
[10:21:38.900]         if (TRUE) {
[10:21:38.900]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.900]                 open = "w")
[10:21:38.900]         }
[10:21:38.900]         else {
[10:21:38.900]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.900]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.900]         }
[10:21:38.900]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.900]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.900]             base::sink(type = "output", split = FALSE)
[10:21:38.900]             base::close(...future.stdout)
[10:21:38.900]         }, add = TRUE)
[10:21:38.900]     }
[10:21:38.900]     ...future.frame <- base::sys.nframe()
[10:21:38.900]     ...future.conditions <- base::list()
[10:21:38.900]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.900]     if (FALSE) {
[10:21:38.900]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.900]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.900]     }
[10:21:38.900]     ...future.result <- base::tryCatch({
[10:21:38.900]         base::withCallingHandlers({
[10:21:38.900]             ...future.value <- base::withVisible(base::local({
[10:21:38.900]                 withCallingHandlers({
[10:21:38.900]                   {
[10:21:38.900]                     x["a"] <- list(1)
[10:21:38.900]                     x
[10:21:38.900]                   }
[10:21:38.900]                 }, immediateCondition = function(cond) {
[10:21:38.900]                   save_rds <- function (object, pathname, ...) 
[10:21:38.900]                   {
[10:21:38.900]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:38.900]                     if (file_test("-f", pathname_tmp)) {
[10:21:38.900]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.900]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:38.900]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.900]                         fi_tmp[["mtime"]])
[10:21:38.900]                     }
[10:21:38.900]                     tryCatch({
[10:21:38.900]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:38.900]                     }, error = function(ex) {
[10:21:38.900]                       msg <- conditionMessage(ex)
[10:21:38.900]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.900]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:38.900]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.900]                         fi_tmp[["mtime"]], msg)
[10:21:38.900]                       ex$message <- msg
[10:21:38.900]                       stop(ex)
[10:21:38.900]                     })
[10:21:38.900]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:38.900]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:38.900]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:38.900]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.900]                       fi <- file.info(pathname)
[10:21:38.900]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:38.900]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.900]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:38.900]                         fi[["size"]], fi[["mtime"]])
[10:21:38.900]                       stop(msg)
[10:21:38.900]                     }
[10:21:38.900]                     invisible(pathname)
[10:21:38.900]                   }
[10:21:38.900]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:38.900]                     rootPath = tempdir()) 
[10:21:38.900]                   {
[10:21:38.900]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:38.900]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:38.900]                       tmpdir = path, fileext = ".rds")
[10:21:38.900]                     save_rds(obj, file)
[10:21:38.900]                   }
[10:21:38.900]                   saveImmediateCondition(cond, path = "/tmp/Rtmpfpiz4I/.future/immediateConditions")
[10:21:38.900]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.900]                   {
[10:21:38.900]                     inherits <- base::inherits
[10:21:38.900]                     invokeRestart <- base::invokeRestart
[10:21:38.900]                     is.null <- base::is.null
[10:21:38.900]                     muffled <- FALSE
[10:21:38.900]                     if (inherits(cond, "message")) {
[10:21:38.900]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:38.900]                       if (muffled) 
[10:21:38.900]                         invokeRestart("muffleMessage")
[10:21:38.900]                     }
[10:21:38.900]                     else if (inherits(cond, "warning")) {
[10:21:38.900]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:38.900]                       if (muffled) 
[10:21:38.900]                         invokeRestart("muffleWarning")
[10:21:38.900]                     }
[10:21:38.900]                     else if (inherits(cond, "condition")) {
[10:21:38.900]                       if (!is.null(pattern)) {
[10:21:38.900]                         computeRestarts <- base::computeRestarts
[10:21:38.900]                         grepl <- base::grepl
[10:21:38.900]                         restarts <- computeRestarts(cond)
[10:21:38.900]                         for (restart in restarts) {
[10:21:38.900]                           name <- restart$name
[10:21:38.900]                           if (is.null(name)) 
[10:21:38.900]                             next
[10:21:38.900]                           if (!grepl(pattern, name)) 
[10:21:38.900]                             next
[10:21:38.900]                           invokeRestart(restart)
[10:21:38.900]                           muffled <- TRUE
[10:21:38.900]                           break
[10:21:38.900]                         }
[10:21:38.900]                       }
[10:21:38.900]                     }
[10:21:38.900]                     invisible(muffled)
[10:21:38.900]                   }
[10:21:38.900]                   muffleCondition(cond)
[10:21:38.900]                 })
[10:21:38.900]             }))
[10:21:38.900]             future::FutureResult(value = ...future.value$value, 
[10:21:38.900]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.900]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.900]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.900]                     ...future.globalenv.names))
[10:21:38.900]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.900]         }, condition = base::local({
[10:21:38.900]             c <- base::c
[10:21:38.900]             inherits <- base::inherits
[10:21:38.900]             invokeRestart <- base::invokeRestart
[10:21:38.900]             length <- base::length
[10:21:38.900]             list <- base::list
[10:21:38.900]             seq.int <- base::seq.int
[10:21:38.900]             signalCondition <- base::signalCondition
[10:21:38.900]             sys.calls <- base::sys.calls
[10:21:38.900]             `[[` <- base::`[[`
[10:21:38.900]             `+` <- base::`+`
[10:21:38.900]             `<<-` <- base::`<<-`
[10:21:38.900]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.900]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.900]                   3L)]
[10:21:38.900]             }
[10:21:38.900]             function(cond) {
[10:21:38.900]                 is_error <- inherits(cond, "error")
[10:21:38.900]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.900]                   NULL)
[10:21:38.900]                 if (is_error) {
[10:21:38.900]                   sessionInformation <- function() {
[10:21:38.900]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.900]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.900]                       search = base::search(), system = base::Sys.info())
[10:21:38.900]                   }
[10:21:38.900]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.900]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.900]                     cond$call), session = sessionInformation(), 
[10:21:38.900]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.900]                   signalCondition(cond)
[10:21:38.900]                 }
[10:21:38.900]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.900]                 "immediateCondition"))) {
[10:21:38.900]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.900]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.900]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.900]                   if (TRUE && !signal) {
[10:21:38.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.900]                     {
[10:21:38.900]                       inherits <- base::inherits
[10:21:38.900]                       invokeRestart <- base::invokeRestart
[10:21:38.900]                       is.null <- base::is.null
[10:21:38.900]                       muffled <- FALSE
[10:21:38.900]                       if (inherits(cond, "message")) {
[10:21:38.900]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.900]                         if (muffled) 
[10:21:38.900]                           invokeRestart("muffleMessage")
[10:21:38.900]                       }
[10:21:38.900]                       else if (inherits(cond, "warning")) {
[10:21:38.900]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.900]                         if (muffled) 
[10:21:38.900]                           invokeRestart("muffleWarning")
[10:21:38.900]                       }
[10:21:38.900]                       else if (inherits(cond, "condition")) {
[10:21:38.900]                         if (!is.null(pattern)) {
[10:21:38.900]                           computeRestarts <- base::computeRestarts
[10:21:38.900]                           grepl <- base::grepl
[10:21:38.900]                           restarts <- computeRestarts(cond)
[10:21:38.900]                           for (restart in restarts) {
[10:21:38.900]                             name <- restart$name
[10:21:38.900]                             if (is.null(name)) 
[10:21:38.900]                               next
[10:21:38.900]                             if (!grepl(pattern, name)) 
[10:21:38.900]                               next
[10:21:38.900]                             invokeRestart(restart)
[10:21:38.900]                             muffled <- TRUE
[10:21:38.900]                             break
[10:21:38.900]                           }
[10:21:38.900]                         }
[10:21:38.900]                       }
[10:21:38.900]                       invisible(muffled)
[10:21:38.900]                     }
[10:21:38.900]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.900]                   }
[10:21:38.900]                 }
[10:21:38.900]                 else {
[10:21:38.900]                   if (TRUE) {
[10:21:38.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.900]                     {
[10:21:38.900]                       inherits <- base::inherits
[10:21:38.900]                       invokeRestart <- base::invokeRestart
[10:21:38.900]                       is.null <- base::is.null
[10:21:38.900]                       muffled <- FALSE
[10:21:38.900]                       if (inherits(cond, "message")) {
[10:21:38.900]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.900]                         if (muffled) 
[10:21:38.900]                           invokeRestart("muffleMessage")
[10:21:38.900]                       }
[10:21:38.900]                       else if (inherits(cond, "warning")) {
[10:21:38.900]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.900]                         if (muffled) 
[10:21:38.900]                           invokeRestart("muffleWarning")
[10:21:38.900]                       }
[10:21:38.900]                       else if (inherits(cond, "condition")) {
[10:21:38.900]                         if (!is.null(pattern)) {
[10:21:38.900]                           computeRestarts <- base::computeRestarts
[10:21:38.900]                           grepl <- base::grepl
[10:21:38.900]                           restarts <- computeRestarts(cond)
[10:21:38.900]                           for (restart in restarts) {
[10:21:38.900]                             name <- restart$name
[10:21:38.900]                             if (is.null(name)) 
[10:21:38.900]                               next
[10:21:38.900]                             if (!grepl(pattern, name)) 
[10:21:38.900]                               next
[10:21:38.900]                             invokeRestart(restart)
[10:21:38.900]                             muffled <- TRUE
[10:21:38.900]                             break
[10:21:38.900]                           }
[10:21:38.900]                         }
[10:21:38.900]                       }
[10:21:38.900]                       invisible(muffled)
[10:21:38.900]                     }
[10:21:38.900]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.900]                   }
[10:21:38.900]                 }
[10:21:38.900]             }
[10:21:38.900]         }))
[10:21:38.900]     }, error = function(ex) {
[10:21:38.900]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.900]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.900]                 ...future.rng), started = ...future.startTime, 
[10:21:38.900]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.900]             version = "1.8"), class = "FutureResult")
[10:21:38.900]     }, finally = {
[10:21:38.900]         if (!identical(...future.workdir, getwd())) 
[10:21:38.900]             setwd(...future.workdir)
[10:21:38.900]         {
[10:21:38.900]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.900]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.900]             }
[10:21:38.900]             base::options(...future.oldOptions)
[10:21:38.900]             if (.Platform$OS.type == "windows") {
[10:21:38.900]                 old_names <- names(...future.oldEnvVars)
[10:21:38.900]                 envs <- base::Sys.getenv()
[10:21:38.900]                 names <- names(envs)
[10:21:38.900]                 common <- intersect(names, old_names)
[10:21:38.900]                 added <- setdiff(names, old_names)
[10:21:38.900]                 removed <- setdiff(old_names, names)
[10:21:38.900]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.900]                   envs[common]]
[10:21:38.900]                 NAMES <- toupper(changed)
[10:21:38.900]                 args <- list()
[10:21:38.900]                 for (kk in seq_along(NAMES)) {
[10:21:38.900]                   name <- changed[[kk]]
[10:21:38.900]                   NAME <- NAMES[[kk]]
[10:21:38.900]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.900]                     next
[10:21:38.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.900]                 }
[10:21:38.900]                 NAMES <- toupper(added)
[10:21:38.900]                 for (kk in seq_along(NAMES)) {
[10:21:38.900]                   name <- added[[kk]]
[10:21:38.900]                   NAME <- NAMES[[kk]]
[10:21:38.900]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.900]                     next
[10:21:38.900]                   args[[name]] <- ""
[10:21:38.900]                 }
[10:21:38.900]                 NAMES <- toupper(removed)
[10:21:38.900]                 for (kk in seq_along(NAMES)) {
[10:21:38.900]                   name <- removed[[kk]]
[10:21:38.900]                   NAME <- NAMES[[kk]]
[10:21:38.900]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.900]                     next
[10:21:38.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.900]                 }
[10:21:38.900]                 if (length(args) > 0) 
[10:21:38.900]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.900]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.900]             }
[10:21:38.900]             else {
[10:21:38.900]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.900]             }
[10:21:38.900]             {
[10:21:38.900]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.900]                   0L) {
[10:21:38.900]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.900]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.900]                   base::options(opts)
[10:21:38.900]                 }
[10:21:38.900]                 {
[10:21:38.900]                   {
[10:21:38.900]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:38.900]                     NULL
[10:21:38.900]                   }
[10:21:38.900]                   options(future.plan = NULL)
[10:21:38.900]                   if (is.na(NA_character_)) 
[10:21:38.900]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.900]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.900]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.900]                     .init = FALSE)
[10:21:38.900]                 }
[10:21:38.900]             }
[10:21:38.900]         }
[10:21:38.900]     })
[10:21:38.900]     if (TRUE) {
[10:21:38.900]         base::sink(type = "output", split = FALSE)
[10:21:38.900]         if (TRUE) {
[10:21:38.900]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.900]         }
[10:21:38.900]         else {
[10:21:38.900]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.900]         }
[10:21:38.900]         base::close(...future.stdout)
[10:21:38.900]         ...future.stdout <- NULL
[10:21:38.900]     }
[10:21:38.900]     ...future.result$conditions <- ...future.conditions
[10:21:38.900]     ...future.result$finished <- base::Sys.time()
[10:21:38.900]     ...future.result
[10:21:38.900] }
[10:21:38.903] assign_globals() ...
[10:21:38.903] List of 1
[10:21:38.903]  $ x: list()
[10:21:38.903]  - attr(*, "where")=List of 1
[10:21:38.903]   ..$ x:<environment: R_EmptyEnv> 
[10:21:38.903]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:38.903]  - attr(*, "resolved")= logi TRUE
[10:21:38.903]  - attr(*, "total_size")= num 31
[10:21:38.903]  - attr(*, "already-done")= logi TRUE
[10:21:38.908] - copied ‘x’ to environment
[10:21:38.908] assign_globals() ... done
[10:21:38.908] requestCore(): workers = 2
[10:21:38.910] MulticoreFuture started
[10:21:38.911] - Launch lazy future ... done
[10:21:38.911] run() for ‘MulticoreFuture’ ... done
[10:21:38.911] result() for MulticoreFuture ...
[10:21:38.911] plan(): Setting new future strategy stack:
[10:21:38.912] List of future strategies:
[10:21:38.912] 1. sequential:
[10:21:38.912]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.912]    - tweaked: FALSE
[10:21:38.912]    - call: NULL
[10:21:38.913] plan(): nbrOfWorkers() = 1
[10:21:38.915] plan(): Setting new future strategy stack:
[10:21:38.915] List of future strategies:
[10:21:38.915] 1. multicore:
[10:21:38.915]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:38.915]    - tweaked: FALSE
[10:21:38.915]    - call: plan(strategy)
[10:21:38.918] plan(): nbrOfWorkers() = 2
[10:21:38.919] result() for MulticoreFuture ...
[10:21:38.919] result() for MulticoreFuture ... done
[10:21:38.919] result() for MulticoreFuture ... done
[10:21:38.920] result() for MulticoreFuture ...
[10:21:38.920] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.921] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.921] Searching for globals...
[10:21:38.924] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:21:38.924] Searching for globals ... DONE
[10:21:38.924] Resolving globals: TRUE
[10:21:38.924] Resolving any globals that are futures ...
[10:21:38.924] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:21:38.925] Resolving any globals that are futures ... DONE
[10:21:38.925] Resolving futures part of globals (recursively) ...
[10:21:38.925] resolve() on list ...
[10:21:38.925]  recursive: 99
[10:21:38.926]  length: 1
[10:21:38.926]  elements: ‘x’
[10:21:38.926]  length: 0 (resolved future 1)
[10:21:38.926] resolve() on list ... DONE
[10:21:38.926] - globals: [1] ‘x’
[10:21:38.926] Resolving futures part of globals (recursively) ... DONE
[10:21:38.926] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:38.927] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:38.927] - globals: [1] ‘x’
[10:21:38.927] 
[10:21:38.927] getGlobalsAndPackages() ... DONE
[10:21:38.928] run() for ‘Future’ ...
[10:21:38.928] - state: ‘created’
[10:21:38.928] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:38.930] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:38.930] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:38.930]   - Field: ‘label’
[10:21:38.930]   - Field: ‘local’
[10:21:38.930]   - Field: ‘owner’
[10:21:38.931]   - Field: ‘envir’
[10:21:38.931]   - Field: ‘workers’
[10:21:38.931]   - Field: ‘packages’
[10:21:38.931]   - Field: ‘gc’
[10:21:38.931]   - Field: ‘job’
[10:21:38.931]   - Field: ‘conditions’
[10:21:38.931]   - Field: ‘expr’
[10:21:38.931]   - Field: ‘uuid’
[10:21:38.931]   - Field: ‘seed’
[10:21:38.932]   - Field: ‘version’
[10:21:38.932]   - Field: ‘result’
[10:21:38.932]   - Field: ‘asynchronous’
[10:21:38.932]   - Field: ‘calls’
[10:21:38.932]   - Field: ‘globals’
[10:21:38.932]   - Field: ‘stdout’
[10:21:38.932]   - Field: ‘earlySignal’
[10:21:38.932]   - Field: ‘lazy’
[10:21:38.932]   - Field: ‘state’
[10:21:38.932] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:38.933] - Launch lazy future ...
[10:21:38.933] Packages needed by the future expression (n = 0): <none>
[10:21:38.933] Packages needed by future strategies (n = 0): <none>
[10:21:38.934] {
[10:21:38.934]     {
[10:21:38.934]         {
[10:21:38.934]             ...future.startTime <- base::Sys.time()
[10:21:38.934]             {
[10:21:38.934]                 {
[10:21:38.934]                   {
[10:21:38.934]                     {
[10:21:38.934]                       base::local({
[10:21:38.934]                         has_future <- base::requireNamespace("future", 
[10:21:38.934]                           quietly = TRUE)
[10:21:38.934]                         if (has_future) {
[10:21:38.934]                           ns <- base::getNamespace("future")
[10:21:38.934]                           version <- ns[[".package"]][["version"]]
[10:21:38.934]                           if (is.null(version)) 
[10:21:38.934]                             version <- utils::packageVersion("future")
[10:21:38.934]                         }
[10:21:38.934]                         else {
[10:21:38.934]                           version <- NULL
[10:21:38.934]                         }
[10:21:38.934]                         if (!has_future || version < "1.8.0") {
[10:21:38.934]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.934]                             "", base::R.version$version.string), 
[10:21:38.934]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:38.934]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.934]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.934]                               "release", "version")], collapse = " "), 
[10:21:38.934]                             hostname = base::Sys.info()[["nodename"]])
[10:21:38.934]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.934]                             info)
[10:21:38.934]                           info <- base::paste(info, collapse = "; ")
[10:21:38.934]                           if (!has_future) {
[10:21:38.934]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.934]                               info)
[10:21:38.934]                           }
[10:21:38.934]                           else {
[10:21:38.934]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.934]                               info, version)
[10:21:38.934]                           }
[10:21:38.934]                           base::stop(msg)
[10:21:38.934]                         }
[10:21:38.934]                       })
[10:21:38.934]                     }
[10:21:38.934]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:38.934]                     base::options(mc.cores = 1L)
[10:21:38.934]                   }
[10:21:38.934]                   ...future.strategy.old <- future::plan("list")
[10:21:38.934]                   options(future.plan = NULL)
[10:21:38.934]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.934]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.934]                 }
[10:21:38.934]                 ...future.workdir <- getwd()
[10:21:38.934]             }
[10:21:38.934]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.934]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.934]         }
[10:21:38.934]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.934]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.934]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.934]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.934]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.934]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.934]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.934]             base::names(...future.oldOptions))
[10:21:38.934]     }
[10:21:38.934]     if (FALSE) {
[10:21:38.934]     }
[10:21:38.934]     else {
[10:21:38.934]         if (TRUE) {
[10:21:38.934]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.934]                 open = "w")
[10:21:38.934]         }
[10:21:38.934]         else {
[10:21:38.934]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.934]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.934]         }
[10:21:38.934]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.934]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.934]             base::sink(type = "output", split = FALSE)
[10:21:38.934]             base::close(...future.stdout)
[10:21:38.934]         }, add = TRUE)
[10:21:38.934]     }
[10:21:38.934]     ...future.frame <- base::sys.nframe()
[10:21:38.934]     ...future.conditions <- base::list()
[10:21:38.934]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.934]     if (FALSE) {
[10:21:38.934]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.934]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.934]     }
[10:21:38.934]     ...future.result <- base::tryCatch({
[10:21:38.934]         base::withCallingHandlers({
[10:21:38.934]             ...future.value <- base::withVisible(base::local({
[10:21:38.934]                 withCallingHandlers({
[10:21:38.934]                   {
[10:21:38.934]                     x["a"] <- list(1)
[10:21:38.934]                     x
[10:21:38.934]                   }
[10:21:38.934]                 }, immediateCondition = function(cond) {
[10:21:38.934]                   save_rds <- function (object, pathname, ...) 
[10:21:38.934]                   {
[10:21:38.934]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:38.934]                     if (file_test("-f", pathname_tmp)) {
[10:21:38.934]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.934]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:38.934]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.934]                         fi_tmp[["mtime"]])
[10:21:38.934]                     }
[10:21:38.934]                     tryCatch({
[10:21:38.934]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:38.934]                     }, error = function(ex) {
[10:21:38.934]                       msg <- conditionMessage(ex)
[10:21:38.934]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.934]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:38.934]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.934]                         fi_tmp[["mtime"]], msg)
[10:21:38.934]                       ex$message <- msg
[10:21:38.934]                       stop(ex)
[10:21:38.934]                     })
[10:21:38.934]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:38.934]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:38.934]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:38.934]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.934]                       fi <- file.info(pathname)
[10:21:38.934]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:38.934]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.934]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:38.934]                         fi[["size"]], fi[["mtime"]])
[10:21:38.934]                       stop(msg)
[10:21:38.934]                     }
[10:21:38.934]                     invisible(pathname)
[10:21:38.934]                   }
[10:21:38.934]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:38.934]                     rootPath = tempdir()) 
[10:21:38.934]                   {
[10:21:38.934]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:38.934]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:38.934]                       tmpdir = path, fileext = ".rds")
[10:21:38.934]                     save_rds(obj, file)
[10:21:38.934]                   }
[10:21:38.934]                   saveImmediateCondition(cond, path = "/tmp/Rtmpfpiz4I/.future/immediateConditions")
[10:21:38.934]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.934]                   {
[10:21:38.934]                     inherits <- base::inherits
[10:21:38.934]                     invokeRestart <- base::invokeRestart
[10:21:38.934]                     is.null <- base::is.null
[10:21:38.934]                     muffled <- FALSE
[10:21:38.934]                     if (inherits(cond, "message")) {
[10:21:38.934]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:38.934]                       if (muffled) 
[10:21:38.934]                         invokeRestart("muffleMessage")
[10:21:38.934]                     }
[10:21:38.934]                     else if (inherits(cond, "warning")) {
[10:21:38.934]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:38.934]                       if (muffled) 
[10:21:38.934]                         invokeRestart("muffleWarning")
[10:21:38.934]                     }
[10:21:38.934]                     else if (inherits(cond, "condition")) {
[10:21:38.934]                       if (!is.null(pattern)) {
[10:21:38.934]                         computeRestarts <- base::computeRestarts
[10:21:38.934]                         grepl <- base::grepl
[10:21:38.934]                         restarts <- computeRestarts(cond)
[10:21:38.934]                         for (restart in restarts) {
[10:21:38.934]                           name <- restart$name
[10:21:38.934]                           if (is.null(name)) 
[10:21:38.934]                             next
[10:21:38.934]                           if (!grepl(pattern, name)) 
[10:21:38.934]                             next
[10:21:38.934]                           invokeRestart(restart)
[10:21:38.934]                           muffled <- TRUE
[10:21:38.934]                           break
[10:21:38.934]                         }
[10:21:38.934]                       }
[10:21:38.934]                     }
[10:21:38.934]                     invisible(muffled)
[10:21:38.934]                   }
[10:21:38.934]                   muffleCondition(cond)
[10:21:38.934]                 })
[10:21:38.934]             }))
[10:21:38.934]             future::FutureResult(value = ...future.value$value, 
[10:21:38.934]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.934]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.934]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.934]                     ...future.globalenv.names))
[10:21:38.934]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.934]         }, condition = base::local({
[10:21:38.934]             c <- base::c
[10:21:38.934]             inherits <- base::inherits
[10:21:38.934]             invokeRestart <- base::invokeRestart
[10:21:38.934]             length <- base::length
[10:21:38.934]             list <- base::list
[10:21:38.934]             seq.int <- base::seq.int
[10:21:38.934]             signalCondition <- base::signalCondition
[10:21:38.934]             sys.calls <- base::sys.calls
[10:21:38.934]             `[[` <- base::`[[`
[10:21:38.934]             `+` <- base::`+`
[10:21:38.934]             `<<-` <- base::`<<-`
[10:21:38.934]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.934]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.934]                   3L)]
[10:21:38.934]             }
[10:21:38.934]             function(cond) {
[10:21:38.934]                 is_error <- inherits(cond, "error")
[10:21:38.934]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.934]                   NULL)
[10:21:38.934]                 if (is_error) {
[10:21:38.934]                   sessionInformation <- function() {
[10:21:38.934]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.934]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.934]                       search = base::search(), system = base::Sys.info())
[10:21:38.934]                   }
[10:21:38.934]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.934]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.934]                     cond$call), session = sessionInformation(), 
[10:21:38.934]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.934]                   signalCondition(cond)
[10:21:38.934]                 }
[10:21:38.934]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.934]                 "immediateCondition"))) {
[10:21:38.934]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.934]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.934]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.934]                   if (TRUE && !signal) {
[10:21:38.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.934]                     {
[10:21:38.934]                       inherits <- base::inherits
[10:21:38.934]                       invokeRestart <- base::invokeRestart
[10:21:38.934]                       is.null <- base::is.null
[10:21:38.934]                       muffled <- FALSE
[10:21:38.934]                       if (inherits(cond, "message")) {
[10:21:38.934]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.934]                         if (muffled) 
[10:21:38.934]                           invokeRestart("muffleMessage")
[10:21:38.934]                       }
[10:21:38.934]                       else if (inherits(cond, "warning")) {
[10:21:38.934]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.934]                         if (muffled) 
[10:21:38.934]                           invokeRestart("muffleWarning")
[10:21:38.934]                       }
[10:21:38.934]                       else if (inherits(cond, "condition")) {
[10:21:38.934]                         if (!is.null(pattern)) {
[10:21:38.934]                           computeRestarts <- base::computeRestarts
[10:21:38.934]                           grepl <- base::grepl
[10:21:38.934]                           restarts <- computeRestarts(cond)
[10:21:38.934]                           for (restart in restarts) {
[10:21:38.934]                             name <- restart$name
[10:21:38.934]                             if (is.null(name)) 
[10:21:38.934]                               next
[10:21:38.934]                             if (!grepl(pattern, name)) 
[10:21:38.934]                               next
[10:21:38.934]                             invokeRestart(restart)
[10:21:38.934]                             muffled <- TRUE
[10:21:38.934]                             break
[10:21:38.934]                           }
[10:21:38.934]                         }
[10:21:38.934]                       }
[10:21:38.934]                       invisible(muffled)
[10:21:38.934]                     }
[10:21:38.934]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.934]                   }
[10:21:38.934]                 }
[10:21:38.934]                 else {
[10:21:38.934]                   if (TRUE) {
[10:21:38.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.934]                     {
[10:21:38.934]                       inherits <- base::inherits
[10:21:38.934]                       invokeRestart <- base::invokeRestart
[10:21:38.934]                       is.null <- base::is.null
[10:21:38.934]                       muffled <- FALSE
[10:21:38.934]                       if (inherits(cond, "message")) {
[10:21:38.934]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.934]                         if (muffled) 
[10:21:38.934]                           invokeRestart("muffleMessage")
[10:21:38.934]                       }
[10:21:38.934]                       else if (inherits(cond, "warning")) {
[10:21:38.934]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.934]                         if (muffled) 
[10:21:38.934]                           invokeRestart("muffleWarning")
[10:21:38.934]                       }
[10:21:38.934]                       else if (inherits(cond, "condition")) {
[10:21:38.934]                         if (!is.null(pattern)) {
[10:21:38.934]                           computeRestarts <- base::computeRestarts
[10:21:38.934]                           grepl <- base::grepl
[10:21:38.934]                           restarts <- computeRestarts(cond)
[10:21:38.934]                           for (restart in restarts) {
[10:21:38.934]                             name <- restart$name
[10:21:38.934]                             if (is.null(name)) 
[10:21:38.934]                               next
[10:21:38.934]                             if (!grepl(pattern, name)) 
[10:21:38.934]                               next
[10:21:38.934]                             invokeRestart(restart)
[10:21:38.934]                             muffled <- TRUE
[10:21:38.934]                             break
[10:21:38.934]                           }
[10:21:38.934]                         }
[10:21:38.934]                       }
[10:21:38.934]                       invisible(muffled)
[10:21:38.934]                     }
[10:21:38.934]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.934]                   }
[10:21:38.934]                 }
[10:21:38.934]             }
[10:21:38.934]         }))
[10:21:38.934]     }, error = function(ex) {
[10:21:38.934]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.934]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.934]                 ...future.rng), started = ...future.startTime, 
[10:21:38.934]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.934]             version = "1.8"), class = "FutureResult")
[10:21:38.934]     }, finally = {
[10:21:38.934]         if (!identical(...future.workdir, getwd())) 
[10:21:38.934]             setwd(...future.workdir)
[10:21:38.934]         {
[10:21:38.934]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.934]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.934]             }
[10:21:38.934]             base::options(...future.oldOptions)
[10:21:38.934]             if (.Platform$OS.type == "windows") {
[10:21:38.934]                 old_names <- names(...future.oldEnvVars)
[10:21:38.934]                 envs <- base::Sys.getenv()
[10:21:38.934]                 names <- names(envs)
[10:21:38.934]                 common <- intersect(names, old_names)
[10:21:38.934]                 added <- setdiff(names, old_names)
[10:21:38.934]                 removed <- setdiff(old_names, names)
[10:21:38.934]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.934]                   envs[common]]
[10:21:38.934]                 NAMES <- toupper(changed)
[10:21:38.934]                 args <- list()
[10:21:38.934]                 for (kk in seq_along(NAMES)) {
[10:21:38.934]                   name <- changed[[kk]]
[10:21:38.934]                   NAME <- NAMES[[kk]]
[10:21:38.934]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.934]                     next
[10:21:38.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.934]                 }
[10:21:38.934]                 NAMES <- toupper(added)
[10:21:38.934]                 for (kk in seq_along(NAMES)) {
[10:21:38.934]                   name <- added[[kk]]
[10:21:38.934]                   NAME <- NAMES[[kk]]
[10:21:38.934]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.934]                     next
[10:21:38.934]                   args[[name]] <- ""
[10:21:38.934]                 }
[10:21:38.934]                 NAMES <- toupper(removed)
[10:21:38.934]                 for (kk in seq_along(NAMES)) {
[10:21:38.934]                   name <- removed[[kk]]
[10:21:38.934]                   NAME <- NAMES[[kk]]
[10:21:38.934]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.934]                     next
[10:21:38.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.934]                 }
[10:21:38.934]                 if (length(args) > 0) 
[10:21:38.934]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.934]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.934]             }
[10:21:38.934]             else {
[10:21:38.934]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.934]             }
[10:21:38.934]             {
[10:21:38.934]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.934]                   0L) {
[10:21:38.934]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.934]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.934]                   base::options(opts)
[10:21:38.934]                 }
[10:21:38.934]                 {
[10:21:38.934]                   {
[10:21:38.934]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:38.934]                     NULL
[10:21:38.934]                   }
[10:21:38.934]                   options(future.plan = NULL)
[10:21:38.934]                   if (is.na(NA_character_)) 
[10:21:38.934]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.934]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.934]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.934]                     .init = FALSE)
[10:21:38.934]                 }
[10:21:38.934]             }
[10:21:38.934]         }
[10:21:38.934]     })
[10:21:38.934]     if (TRUE) {
[10:21:38.934]         base::sink(type = "output", split = FALSE)
[10:21:38.934]         if (TRUE) {
[10:21:38.934]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.934]         }
[10:21:38.934]         else {
[10:21:38.934]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.934]         }
[10:21:38.934]         base::close(...future.stdout)
[10:21:38.934]         ...future.stdout <- NULL
[10:21:38.934]     }
[10:21:38.934]     ...future.result$conditions <- ...future.conditions
[10:21:38.934]     ...future.result$finished <- base::Sys.time()
[10:21:38.934]     ...future.result
[10:21:38.934] }
[10:21:38.936] assign_globals() ...
[10:21:38.937] List of 1
[10:21:38.937]  $ x: list()
[10:21:38.937]  - attr(*, "where")=List of 1
[10:21:38.937]   ..$ x:<environment: R_EmptyEnv> 
[10:21:38.937]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:38.937]  - attr(*, "resolved")= logi TRUE
[10:21:38.937]  - attr(*, "total_size")= num 31
[10:21:38.937]  - attr(*, "already-done")= logi TRUE
[10:21:38.939] - copied ‘x’ to environment
[10:21:38.940] assign_globals() ... done
[10:21:38.940] requestCore(): workers = 2
[10:21:38.941] MulticoreFuture started
[10:21:38.942] - Launch lazy future ... done
[10:21:38.942] run() for ‘MulticoreFuture’ ... done
[10:21:38.942] result() for MulticoreFuture ...
[10:21:38.942] plan(): Setting new future strategy stack:
[10:21:38.943] List of future strategies:
[10:21:38.943] 1. sequential:
[10:21:38.943]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.943]    - tweaked: FALSE
[10:21:38.943]    - call: NULL
[10:21:38.944] plan(): nbrOfWorkers() = 1
[10:21:38.946] plan(): Setting new future strategy stack:
[10:21:38.946] List of future strategies:
[10:21:38.946] 1. multicore:
[10:21:38.946]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:38.946]    - tweaked: FALSE
[10:21:38.946]    - call: plan(strategy)
[10:21:38.949] plan(): nbrOfWorkers() = 2
[10:21:38.950] result() for MulticoreFuture ...
[10:21:38.950] result() for MulticoreFuture ... done
[10:21:38.950] result() for MulticoreFuture ... done
[10:21:38.950] result() for MulticoreFuture ...
[10:21:38.950] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.951] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.951] Searching for globals...
[10:21:38.954] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[10:21:38.954] Searching for globals ... DONE
[10:21:38.954] Resolving globals: TRUE
[10:21:38.954] Resolving any globals that are futures ...
[10:21:38.955] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[10:21:38.955] Resolving any globals that are futures ... DONE
[10:21:38.955] Resolving futures part of globals (recursively) ...
[10:21:38.956] resolve() on list ...
[10:21:38.956]  recursive: 99
[10:21:38.956]  length: 2
[10:21:38.956]  elements: ‘x’, ‘name’
[10:21:38.956]  length: 1 (resolved future 1)
[10:21:38.959]  length: 0 (resolved future 2)
[10:21:38.959] resolve() on list ... DONE
[10:21:38.959] - globals: [2] ‘x’, ‘name’
[10:21:38.959] Resolving futures part of globals (recursively) ... DONE
[10:21:38.959] The total size of the 2 globals is 71 bytes (71 bytes)
[10:21:38.960] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 71 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (40 bytes of class ‘character’) and ‘x’ (31 bytes of class ‘list’)
[10:21:38.960] - globals: [2] ‘x’, ‘name’
[10:21:38.960] 
[10:21:38.960] getGlobalsAndPackages() ... DONE
[10:21:38.961] run() for ‘Future’ ...
[10:21:38.961] - state: ‘created’
[10:21:38.961] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:38.963] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:38.963] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:38.963]   - Field: ‘label’
[10:21:38.963]   - Field: ‘local’
[10:21:38.964]   - Field: ‘owner’
[10:21:38.964]   - Field: ‘envir’
[10:21:38.964]   - Field: ‘workers’
[10:21:38.964]   - Field: ‘packages’
[10:21:38.964]   - Field: ‘gc’
[10:21:38.964]   - Field: ‘job’
[10:21:38.964]   - Field: ‘conditions’
[10:21:38.964]   - Field: ‘expr’
[10:21:38.964]   - Field: ‘uuid’
[10:21:38.965]   - Field: ‘seed’
[10:21:38.965]   - Field: ‘version’
[10:21:38.965]   - Field: ‘result’
[10:21:38.965]   - Field: ‘asynchronous’
[10:21:38.965]   - Field: ‘calls’
[10:21:38.965]   - Field: ‘globals’
[10:21:38.965]   - Field: ‘stdout’
[10:21:38.965]   - Field: ‘earlySignal’
[10:21:38.965]   - Field: ‘lazy’
[10:21:38.966]   - Field: ‘state’
[10:21:38.966] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:38.966] - Launch lazy future ...
[10:21:38.966] Packages needed by the future expression (n = 0): <none>
[10:21:38.966] Packages needed by future strategies (n = 0): <none>
[10:21:38.967] {
[10:21:38.967]     {
[10:21:38.967]         {
[10:21:38.967]             ...future.startTime <- base::Sys.time()
[10:21:38.967]             {
[10:21:38.967]                 {
[10:21:38.967]                   {
[10:21:38.967]                     {
[10:21:38.967]                       base::local({
[10:21:38.967]                         has_future <- base::requireNamespace("future", 
[10:21:38.967]                           quietly = TRUE)
[10:21:38.967]                         if (has_future) {
[10:21:38.967]                           ns <- base::getNamespace("future")
[10:21:38.967]                           version <- ns[[".package"]][["version"]]
[10:21:38.967]                           if (is.null(version)) 
[10:21:38.967]                             version <- utils::packageVersion("future")
[10:21:38.967]                         }
[10:21:38.967]                         else {
[10:21:38.967]                           version <- NULL
[10:21:38.967]                         }
[10:21:38.967]                         if (!has_future || version < "1.8.0") {
[10:21:38.967]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:38.967]                             "", base::R.version$version.string), 
[10:21:38.967]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:38.967]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:38.967]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:38.967]                               "release", "version")], collapse = " "), 
[10:21:38.967]                             hostname = base::Sys.info()[["nodename"]])
[10:21:38.967]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:38.967]                             info)
[10:21:38.967]                           info <- base::paste(info, collapse = "; ")
[10:21:38.967]                           if (!has_future) {
[10:21:38.967]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:38.967]                               info)
[10:21:38.967]                           }
[10:21:38.967]                           else {
[10:21:38.967]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:38.967]                               info, version)
[10:21:38.967]                           }
[10:21:38.967]                           base::stop(msg)
[10:21:38.967]                         }
[10:21:38.967]                       })
[10:21:38.967]                     }
[10:21:38.967]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:38.967]                     base::options(mc.cores = 1L)
[10:21:38.967]                   }
[10:21:38.967]                   ...future.strategy.old <- future::plan("list")
[10:21:38.967]                   options(future.plan = NULL)
[10:21:38.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:38.967]                 }
[10:21:38.967]                 ...future.workdir <- getwd()
[10:21:38.967]             }
[10:21:38.967]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:38.967]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:38.967]         }
[10:21:38.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:38.967]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:38.967]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:38.967]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:38.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:38.967]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:38.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:38.967]             base::names(...future.oldOptions))
[10:21:38.967]     }
[10:21:38.967]     if (FALSE) {
[10:21:38.967]     }
[10:21:38.967]     else {
[10:21:38.967]         if (TRUE) {
[10:21:38.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:38.967]                 open = "w")
[10:21:38.967]         }
[10:21:38.967]         else {
[10:21:38.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:38.967]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:38.967]         }
[10:21:38.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:38.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:38.967]             base::sink(type = "output", split = FALSE)
[10:21:38.967]             base::close(...future.stdout)
[10:21:38.967]         }, add = TRUE)
[10:21:38.967]     }
[10:21:38.967]     ...future.frame <- base::sys.nframe()
[10:21:38.967]     ...future.conditions <- base::list()
[10:21:38.967]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:38.967]     if (FALSE) {
[10:21:38.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:38.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:38.967]     }
[10:21:38.967]     ...future.result <- base::tryCatch({
[10:21:38.967]         base::withCallingHandlers({
[10:21:38.967]             ...future.value <- base::withVisible(base::local({
[10:21:38.967]                 withCallingHandlers({
[10:21:38.967]                   {
[10:21:38.967]                     x[name] <- list(1)
[10:21:38.967]                     x
[10:21:38.967]                   }
[10:21:38.967]                 }, immediateCondition = function(cond) {
[10:21:38.967]                   save_rds <- function (object, pathname, ...) 
[10:21:38.967]                   {
[10:21:38.967]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:38.967]                     if (file_test("-f", pathname_tmp)) {
[10:21:38.967]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.967]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:38.967]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.967]                         fi_tmp[["mtime"]])
[10:21:38.967]                     }
[10:21:38.967]                     tryCatch({
[10:21:38.967]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:38.967]                     }, error = function(ex) {
[10:21:38.967]                       msg <- conditionMessage(ex)
[10:21:38.967]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.967]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:38.967]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.967]                         fi_tmp[["mtime"]], msg)
[10:21:38.967]                       ex$message <- msg
[10:21:38.967]                       stop(ex)
[10:21:38.967]                     })
[10:21:38.967]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:38.967]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:38.967]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:38.967]                       fi_tmp <- file.info(pathname_tmp)
[10:21:38.967]                       fi <- file.info(pathname)
[10:21:38.967]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:38.967]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:38.967]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:38.967]                         fi[["size"]], fi[["mtime"]])
[10:21:38.967]                       stop(msg)
[10:21:38.967]                     }
[10:21:38.967]                     invisible(pathname)
[10:21:38.967]                   }
[10:21:38.967]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:38.967]                     rootPath = tempdir()) 
[10:21:38.967]                   {
[10:21:38.967]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:38.967]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:38.967]                       tmpdir = path, fileext = ".rds")
[10:21:38.967]                     save_rds(obj, file)
[10:21:38.967]                   }
[10:21:38.967]                   saveImmediateCondition(cond, path = "/tmp/Rtmpfpiz4I/.future/immediateConditions")
[10:21:38.967]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.967]                   {
[10:21:38.967]                     inherits <- base::inherits
[10:21:38.967]                     invokeRestart <- base::invokeRestart
[10:21:38.967]                     is.null <- base::is.null
[10:21:38.967]                     muffled <- FALSE
[10:21:38.967]                     if (inherits(cond, "message")) {
[10:21:38.967]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:38.967]                       if (muffled) 
[10:21:38.967]                         invokeRestart("muffleMessage")
[10:21:38.967]                     }
[10:21:38.967]                     else if (inherits(cond, "warning")) {
[10:21:38.967]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:38.967]                       if (muffled) 
[10:21:38.967]                         invokeRestart("muffleWarning")
[10:21:38.967]                     }
[10:21:38.967]                     else if (inherits(cond, "condition")) {
[10:21:38.967]                       if (!is.null(pattern)) {
[10:21:38.967]                         computeRestarts <- base::computeRestarts
[10:21:38.967]                         grepl <- base::grepl
[10:21:38.967]                         restarts <- computeRestarts(cond)
[10:21:38.967]                         for (restart in restarts) {
[10:21:38.967]                           name <- restart$name
[10:21:38.967]                           if (is.null(name)) 
[10:21:38.967]                             next
[10:21:38.967]                           if (!grepl(pattern, name)) 
[10:21:38.967]                             next
[10:21:38.967]                           invokeRestart(restart)
[10:21:38.967]                           muffled <- TRUE
[10:21:38.967]                           break
[10:21:38.967]                         }
[10:21:38.967]                       }
[10:21:38.967]                     }
[10:21:38.967]                     invisible(muffled)
[10:21:38.967]                   }
[10:21:38.967]                   muffleCondition(cond)
[10:21:38.967]                 })
[10:21:38.967]             }))
[10:21:38.967]             future::FutureResult(value = ...future.value$value, 
[10:21:38.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.967]                   ...future.rng), globalenv = if (FALSE) 
[10:21:38.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:38.967]                     ...future.globalenv.names))
[10:21:38.967]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:38.967]         }, condition = base::local({
[10:21:38.967]             c <- base::c
[10:21:38.967]             inherits <- base::inherits
[10:21:38.967]             invokeRestart <- base::invokeRestart
[10:21:38.967]             length <- base::length
[10:21:38.967]             list <- base::list
[10:21:38.967]             seq.int <- base::seq.int
[10:21:38.967]             signalCondition <- base::signalCondition
[10:21:38.967]             sys.calls <- base::sys.calls
[10:21:38.967]             `[[` <- base::`[[`
[10:21:38.967]             `+` <- base::`+`
[10:21:38.967]             `<<-` <- base::`<<-`
[10:21:38.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:38.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:38.967]                   3L)]
[10:21:38.967]             }
[10:21:38.967]             function(cond) {
[10:21:38.967]                 is_error <- inherits(cond, "error")
[10:21:38.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:38.967]                   NULL)
[10:21:38.967]                 if (is_error) {
[10:21:38.967]                   sessionInformation <- function() {
[10:21:38.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:38.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:38.967]                       search = base::search(), system = base::Sys.info())
[10:21:38.967]                   }
[10:21:38.967]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:38.967]                     cond$call), session = sessionInformation(), 
[10:21:38.967]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:38.967]                   signalCondition(cond)
[10:21:38.967]                 }
[10:21:38.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:38.967]                 "immediateCondition"))) {
[10:21:38.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:38.967]                   ...future.conditions[[length(...future.conditions) + 
[10:21:38.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:38.967]                   if (TRUE && !signal) {
[10:21:38.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.967]                     {
[10:21:38.967]                       inherits <- base::inherits
[10:21:38.967]                       invokeRestart <- base::invokeRestart
[10:21:38.967]                       is.null <- base::is.null
[10:21:38.967]                       muffled <- FALSE
[10:21:38.967]                       if (inherits(cond, "message")) {
[10:21:38.967]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.967]                         if (muffled) 
[10:21:38.967]                           invokeRestart("muffleMessage")
[10:21:38.967]                       }
[10:21:38.967]                       else if (inherits(cond, "warning")) {
[10:21:38.967]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.967]                         if (muffled) 
[10:21:38.967]                           invokeRestart("muffleWarning")
[10:21:38.967]                       }
[10:21:38.967]                       else if (inherits(cond, "condition")) {
[10:21:38.967]                         if (!is.null(pattern)) {
[10:21:38.967]                           computeRestarts <- base::computeRestarts
[10:21:38.967]                           grepl <- base::grepl
[10:21:38.967]                           restarts <- computeRestarts(cond)
[10:21:38.967]                           for (restart in restarts) {
[10:21:38.967]                             name <- restart$name
[10:21:38.967]                             if (is.null(name)) 
[10:21:38.967]                               next
[10:21:38.967]                             if (!grepl(pattern, name)) 
[10:21:38.967]                               next
[10:21:38.967]                             invokeRestart(restart)
[10:21:38.967]                             muffled <- TRUE
[10:21:38.967]                             break
[10:21:38.967]                           }
[10:21:38.967]                         }
[10:21:38.967]                       }
[10:21:38.967]                       invisible(muffled)
[10:21:38.967]                     }
[10:21:38.967]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.967]                   }
[10:21:38.967]                 }
[10:21:38.967]                 else {
[10:21:38.967]                   if (TRUE) {
[10:21:38.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:38.967]                     {
[10:21:38.967]                       inherits <- base::inherits
[10:21:38.967]                       invokeRestart <- base::invokeRestart
[10:21:38.967]                       is.null <- base::is.null
[10:21:38.967]                       muffled <- FALSE
[10:21:38.967]                       if (inherits(cond, "message")) {
[10:21:38.967]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:38.967]                         if (muffled) 
[10:21:38.967]                           invokeRestart("muffleMessage")
[10:21:38.967]                       }
[10:21:38.967]                       else if (inherits(cond, "warning")) {
[10:21:38.967]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:38.967]                         if (muffled) 
[10:21:38.967]                           invokeRestart("muffleWarning")
[10:21:38.967]                       }
[10:21:38.967]                       else if (inherits(cond, "condition")) {
[10:21:38.967]                         if (!is.null(pattern)) {
[10:21:38.967]                           computeRestarts <- base::computeRestarts
[10:21:38.967]                           grepl <- base::grepl
[10:21:38.967]                           restarts <- computeRestarts(cond)
[10:21:38.967]                           for (restart in restarts) {
[10:21:38.967]                             name <- restart$name
[10:21:38.967]                             if (is.null(name)) 
[10:21:38.967]                               next
[10:21:38.967]                             if (!grepl(pattern, name)) 
[10:21:38.967]                               next
[10:21:38.967]                             invokeRestart(restart)
[10:21:38.967]                             muffled <- TRUE
[10:21:38.967]                             break
[10:21:38.967]                           }
[10:21:38.967]                         }
[10:21:38.967]                       }
[10:21:38.967]                       invisible(muffled)
[10:21:38.967]                     }
[10:21:38.967]                     muffleCondition(cond, pattern = "^muffle")
[10:21:38.967]                   }
[10:21:38.967]                 }
[10:21:38.967]             }
[10:21:38.967]         }))
[10:21:38.967]     }, error = function(ex) {
[10:21:38.967]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:38.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:38.967]                 ...future.rng), started = ...future.startTime, 
[10:21:38.967]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:38.967]             version = "1.8"), class = "FutureResult")
[10:21:38.967]     }, finally = {
[10:21:38.967]         if (!identical(...future.workdir, getwd())) 
[10:21:38.967]             setwd(...future.workdir)
[10:21:38.967]         {
[10:21:38.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:38.967]                 ...future.oldOptions$nwarnings <- NULL
[10:21:38.967]             }
[10:21:38.967]             base::options(...future.oldOptions)
[10:21:38.967]             if (.Platform$OS.type == "windows") {
[10:21:38.967]                 old_names <- names(...future.oldEnvVars)
[10:21:38.967]                 envs <- base::Sys.getenv()
[10:21:38.967]                 names <- names(envs)
[10:21:38.967]                 common <- intersect(names, old_names)
[10:21:38.967]                 added <- setdiff(names, old_names)
[10:21:38.967]                 removed <- setdiff(old_names, names)
[10:21:38.967]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:38.967]                   envs[common]]
[10:21:38.967]                 NAMES <- toupper(changed)
[10:21:38.967]                 args <- list()
[10:21:38.967]                 for (kk in seq_along(NAMES)) {
[10:21:38.967]                   name <- changed[[kk]]
[10:21:38.967]                   NAME <- NAMES[[kk]]
[10:21:38.967]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.967]                     next
[10:21:38.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.967]                 }
[10:21:38.967]                 NAMES <- toupper(added)
[10:21:38.967]                 for (kk in seq_along(NAMES)) {
[10:21:38.967]                   name <- added[[kk]]
[10:21:38.967]                   NAME <- NAMES[[kk]]
[10:21:38.967]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.967]                     next
[10:21:38.967]                   args[[name]] <- ""
[10:21:38.967]                 }
[10:21:38.967]                 NAMES <- toupper(removed)
[10:21:38.967]                 for (kk in seq_along(NAMES)) {
[10:21:38.967]                   name <- removed[[kk]]
[10:21:38.967]                   NAME <- NAMES[[kk]]
[10:21:38.967]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:38.967]                     next
[10:21:38.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:38.967]                 }
[10:21:38.967]                 if (length(args) > 0) 
[10:21:38.967]                   base::do.call(base::Sys.setenv, args = args)
[10:21:38.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:38.967]             }
[10:21:38.967]             else {
[10:21:38.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:38.967]             }
[10:21:38.967]             {
[10:21:38.967]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:38.967]                   0L) {
[10:21:38.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:38.967]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:38.967]                   base::options(opts)
[10:21:38.967]                 }
[10:21:38.967]                 {
[10:21:38.967]                   {
[10:21:38.967]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:38.967]                     NULL
[10:21:38.967]                   }
[10:21:38.967]                   options(future.plan = NULL)
[10:21:38.967]                   if (is.na(NA_character_)) 
[10:21:38.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:38.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:38.967]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:38.967]                     .init = FALSE)
[10:21:38.967]                 }
[10:21:38.967]             }
[10:21:38.967]         }
[10:21:38.967]     })
[10:21:38.967]     if (TRUE) {
[10:21:38.967]         base::sink(type = "output", split = FALSE)
[10:21:38.967]         if (TRUE) {
[10:21:38.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:38.967]         }
[10:21:38.967]         else {
[10:21:38.967]             ...future.result["stdout"] <- base::list(NULL)
[10:21:38.967]         }
[10:21:38.967]         base::close(...future.stdout)
[10:21:38.967]         ...future.stdout <- NULL
[10:21:38.967]     }
[10:21:38.967]     ...future.result$conditions <- ...future.conditions
[10:21:38.967]     ...future.result$finished <- base::Sys.time()
[10:21:38.967]     ...future.result
[10:21:38.967] }
[10:21:38.969] assign_globals() ...
[10:21:38.969] List of 2
[10:21:38.969]  $ x   : list()
[10:21:38.969]  $ name: chr "a"
[10:21:38.969]  - attr(*, "where")=List of 2
[10:21:38.969]   ..$ x   :<environment: R_EmptyEnv> 
[10:21:38.969]   ..$ name:<environment: R_EmptyEnv> 
[10:21:38.969]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:38.969]  - attr(*, "resolved")= logi TRUE
[10:21:38.969]  - attr(*, "total_size")= num 71
[10:21:38.969]  - attr(*, "already-done")= logi TRUE
[10:21:38.973] - copied ‘x’ to environment
[10:21:38.973] - copied ‘name’ to environment
[10:21:38.973] assign_globals() ... done
[10:21:38.973] requestCore(): workers = 2
[10:21:38.975] MulticoreFuture started
[10:21:38.976] - Launch lazy future ... done
[10:21:38.976] run() for ‘MulticoreFuture’ ... done
[10:21:38.976] result() for MulticoreFuture ...
[10:21:38.976] plan(): Setting new future strategy stack:
[10:21:38.977] List of future strategies:
[10:21:38.977] 1. sequential:
[10:21:38.977]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:38.977]    - tweaked: FALSE
[10:21:38.977]    - call: NULL
[10:21:38.978] plan(): nbrOfWorkers() = 1
[10:21:38.980] plan(): Setting new future strategy stack:
[10:21:38.980] List of future strategies:
[10:21:38.980] 1. multicore:
[10:21:38.980]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:38.980]    - tweaked: FALSE
[10:21:38.980]    - call: plan(strategy)
[10:21:38.983] plan(): nbrOfWorkers() = 2
[10:21:38.984] result() for MulticoreFuture ...
[10:21:38.984] result() for MulticoreFuture ... done
[10:21:38.984] result() for MulticoreFuture ... done
[10:21:38.984] result() for MulticoreFuture ...
[10:21:38.984] result() for MulticoreFuture ... done
$a
[1] 1

- plan('multisession') ...
[10:21:38.985] plan(): Setting new future strategy stack:
[10:21:38.985] List of future strategies:
[10:21:38.985] 1. multisession:
[10:21:38.985]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:38.985]    - tweaked: FALSE
[10:21:38.985]    - call: plan(strategy)
[10:21:38.986] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:21:38.986] multisession:
[10:21:38.986] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:38.986] - tweaked: FALSE
[10:21:38.986] - call: plan(strategy)
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:38.991] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:38.991] Not searching for globals
[10:21:38.991] - globals: [0] <none>
[10:21:38.991] getGlobalsAndPackages() ... DONE
[10:21:39.479] Packages needed by the future expression (n = 0): <none>
[10:21:39.479] Packages needed by future strategies (n = 0): <none>
[10:21:39.479] {
[10:21:39.479]     {
[10:21:39.479]         {
[10:21:39.479]             ...future.startTime <- base::Sys.time()
[10:21:39.479]             {
[10:21:39.479]                 {
[10:21:39.479]                   {
[10:21:39.479]                     {
[10:21:39.479]                       base::local({
[10:21:39.479]                         has_future <- base::requireNamespace("future", 
[10:21:39.479]                           quietly = TRUE)
[10:21:39.479]                         if (has_future) {
[10:21:39.479]                           ns <- base::getNamespace("future")
[10:21:39.479]                           version <- ns[[".package"]][["version"]]
[10:21:39.479]                           if (is.null(version)) 
[10:21:39.479]                             version <- utils::packageVersion("future")
[10:21:39.479]                         }
[10:21:39.479]                         else {
[10:21:39.479]                           version <- NULL
[10:21:39.479]                         }
[10:21:39.479]                         if (!has_future || version < "1.8.0") {
[10:21:39.479]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:39.479]                             "", base::R.version$version.string), 
[10:21:39.479]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:39.479]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:39.479]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:39.479]                               "release", "version")], collapse = " "), 
[10:21:39.479]                             hostname = base::Sys.info()[["nodename"]])
[10:21:39.479]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:39.479]                             info)
[10:21:39.479]                           info <- base::paste(info, collapse = "; ")
[10:21:39.479]                           if (!has_future) {
[10:21:39.479]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:39.479]                               info)
[10:21:39.479]                           }
[10:21:39.479]                           else {
[10:21:39.479]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:39.479]                               info, version)
[10:21:39.479]                           }
[10:21:39.479]                           base::stop(msg)
[10:21:39.479]                         }
[10:21:39.479]                       })
[10:21:39.479]                     }
[10:21:39.479]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:39.479]                     base::options(mc.cores = 1L)
[10:21:39.479]                   }
[10:21:39.479]                   ...future.strategy.old <- future::plan("list")
[10:21:39.479]                   options(future.plan = NULL)
[10:21:39.479]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:39.479]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:39.479]                 }
[10:21:39.479]                 ...future.workdir <- getwd()
[10:21:39.479]             }
[10:21:39.479]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:39.479]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:39.479]         }
[10:21:39.479]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:39.479]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:39.479]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:39.479]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:39.479]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:39.479]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:39.479]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:39.479]             base::names(...future.oldOptions))
[10:21:39.479]     }
[10:21:39.479]     if (FALSE) {
[10:21:39.479]     }
[10:21:39.479]     else {
[10:21:39.479]         if (TRUE) {
[10:21:39.479]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:39.479]                 open = "w")
[10:21:39.479]         }
[10:21:39.479]         else {
[10:21:39.479]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:39.479]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:39.479]         }
[10:21:39.479]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:39.479]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:39.479]             base::sink(type = "output", split = FALSE)
[10:21:39.479]             base::close(...future.stdout)
[10:21:39.479]         }, add = TRUE)
[10:21:39.479]     }
[10:21:39.479]     ...future.frame <- base::sys.nframe()
[10:21:39.479]     ...future.conditions <- base::list()
[10:21:39.479]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:39.479]     if (FALSE) {
[10:21:39.479]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:39.479]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:39.479]     }
[10:21:39.479]     ...future.result <- base::tryCatch({
[10:21:39.479]         base::withCallingHandlers({
[10:21:39.479]             ...future.value <- base::withVisible(base::local({
[10:21:39.479]                 ...future.makeSendCondition <- base::local({
[10:21:39.479]                   sendCondition <- NULL
[10:21:39.479]                   function(frame = 1L) {
[10:21:39.479]                     if (is.function(sendCondition)) 
[10:21:39.479]                       return(sendCondition)
[10:21:39.479]                     ns <- getNamespace("parallel")
[10:21:39.479]                     if (exists("sendData", mode = "function", 
[10:21:39.479]                       envir = ns)) {
[10:21:39.479]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:39.479]                         envir = ns)
[10:21:39.479]                       envir <- sys.frame(frame)
[10:21:39.479]                       master <- NULL
[10:21:39.479]                       while (!identical(envir, .GlobalEnv) && 
[10:21:39.479]                         !identical(envir, emptyenv())) {
[10:21:39.479]                         if (exists("master", mode = "list", envir = envir, 
[10:21:39.479]                           inherits = FALSE)) {
[10:21:39.479]                           master <- get("master", mode = "list", 
[10:21:39.479]                             envir = envir, inherits = FALSE)
[10:21:39.479]                           if (inherits(master, c("SOCKnode", 
[10:21:39.479]                             "SOCK0node"))) {
[10:21:39.479]                             sendCondition <<- function(cond) {
[10:21:39.479]                               data <- list(type = "VALUE", value = cond, 
[10:21:39.479]                                 success = TRUE)
[10:21:39.479]                               parallel_sendData(master, data)
[10:21:39.479]                             }
[10:21:39.479]                             return(sendCondition)
[10:21:39.479]                           }
[10:21:39.479]                         }
[10:21:39.479]                         frame <- frame + 1L
[10:21:39.479]                         envir <- sys.frame(frame)
[10:21:39.479]                       }
[10:21:39.479]                     }
[10:21:39.479]                     sendCondition <<- function(cond) NULL
[10:21:39.479]                   }
[10:21:39.479]                 })
[10:21:39.479]                 withCallingHandlers({
[10:21:39.479]                   NA
[10:21:39.479]                 }, immediateCondition = function(cond) {
[10:21:39.479]                   sendCondition <- ...future.makeSendCondition()
[10:21:39.479]                   sendCondition(cond)
[10:21:39.479]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:39.479]                   {
[10:21:39.479]                     inherits <- base::inherits
[10:21:39.479]                     invokeRestart <- base::invokeRestart
[10:21:39.479]                     is.null <- base::is.null
[10:21:39.479]                     muffled <- FALSE
[10:21:39.479]                     if (inherits(cond, "message")) {
[10:21:39.479]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:39.479]                       if (muffled) 
[10:21:39.479]                         invokeRestart("muffleMessage")
[10:21:39.479]                     }
[10:21:39.479]                     else if (inherits(cond, "warning")) {
[10:21:39.479]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:39.479]                       if (muffled) 
[10:21:39.479]                         invokeRestart("muffleWarning")
[10:21:39.479]                     }
[10:21:39.479]                     else if (inherits(cond, "condition")) {
[10:21:39.479]                       if (!is.null(pattern)) {
[10:21:39.479]                         computeRestarts <- base::computeRestarts
[10:21:39.479]                         grepl <- base::grepl
[10:21:39.479]                         restarts <- computeRestarts(cond)
[10:21:39.479]                         for (restart in restarts) {
[10:21:39.479]                           name <- restart$name
[10:21:39.479]                           if (is.null(name)) 
[10:21:39.479]                             next
[10:21:39.479]                           if (!grepl(pattern, name)) 
[10:21:39.479]                             next
[10:21:39.479]                           invokeRestart(restart)
[10:21:39.479]                           muffled <- TRUE
[10:21:39.479]                           break
[10:21:39.479]                         }
[10:21:39.479]                       }
[10:21:39.479]                     }
[10:21:39.479]                     invisible(muffled)
[10:21:39.479]                   }
[10:21:39.479]                   muffleCondition(cond)
[10:21:39.479]                 })
[10:21:39.479]             }))
[10:21:39.479]             future::FutureResult(value = ...future.value$value, 
[10:21:39.479]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:39.479]                   ...future.rng), globalenv = if (FALSE) 
[10:21:39.479]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:39.479]                     ...future.globalenv.names))
[10:21:39.479]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:39.479]         }, condition = base::local({
[10:21:39.479]             c <- base::c
[10:21:39.479]             inherits <- base::inherits
[10:21:39.479]             invokeRestart <- base::invokeRestart
[10:21:39.479]             length <- base::length
[10:21:39.479]             list <- base::list
[10:21:39.479]             seq.int <- base::seq.int
[10:21:39.479]             signalCondition <- base::signalCondition
[10:21:39.479]             sys.calls <- base::sys.calls
[10:21:39.479]             `[[` <- base::`[[`
[10:21:39.479]             `+` <- base::`+`
[10:21:39.479]             `<<-` <- base::`<<-`
[10:21:39.479]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:39.479]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:39.479]                   3L)]
[10:21:39.479]             }
[10:21:39.479]             function(cond) {
[10:21:39.479]                 is_error <- inherits(cond, "error")
[10:21:39.479]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:39.479]                   NULL)
[10:21:39.479]                 if (is_error) {
[10:21:39.479]                   sessionInformation <- function() {
[10:21:39.479]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:39.479]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:39.479]                       search = base::search(), system = base::Sys.info())
[10:21:39.479]                   }
[10:21:39.479]                   ...future.conditions[[length(...future.conditions) + 
[10:21:39.479]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:39.479]                     cond$call), session = sessionInformation(), 
[10:21:39.479]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:39.479]                   signalCondition(cond)
[10:21:39.479]                 }
[10:21:39.479]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:39.479]                 "immediateCondition"))) {
[10:21:39.479]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:39.479]                   ...future.conditions[[length(...future.conditions) + 
[10:21:39.479]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:39.479]                   if (TRUE && !signal) {
[10:21:39.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:39.479]                     {
[10:21:39.479]                       inherits <- base::inherits
[10:21:39.479]                       invokeRestart <- base::invokeRestart
[10:21:39.479]                       is.null <- base::is.null
[10:21:39.479]                       muffled <- FALSE
[10:21:39.479]                       if (inherits(cond, "message")) {
[10:21:39.479]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:39.479]                         if (muffled) 
[10:21:39.479]                           invokeRestart("muffleMessage")
[10:21:39.479]                       }
[10:21:39.479]                       else if (inherits(cond, "warning")) {
[10:21:39.479]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:39.479]                         if (muffled) 
[10:21:39.479]                           invokeRestart("muffleWarning")
[10:21:39.479]                       }
[10:21:39.479]                       else if (inherits(cond, "condition")) {
[10:21:39.479]                         if (!is.null(pattern)) {
[10:21:39.479]                           computeRestarts <- base::computeRestarts
[10:21:39.479]                           grepl <- base::grepl
[10:21:39.479]                           restarts <- computeRestarts(cond)
[10:21:39.479]                           for (restart in restarts) {
[10:21:39.479]                             name <- restart$name
[10:21:39.479]                             if (is.null(name)) 
[10:21:39.479]                               next
[10:21:39.479]                             if (!grepl(pattern, name)) 
[10:21:39.479]                               next
[10:21:39.479]                             invokeRestart(restart)
[10:21:39.479]                             muffled <- TRUE
[10:21:39.479]                             break
[10:21:39.479]                           }
[10:21:39.479]                         }
[10:21:39.479]                       }
[10:21:39.479]                       invisible(muffled)
[10:21:39.479]                     }
[10:21:39.479]                     muffleCondition(cond, pattern = "^muffle")
[10:21:39.479]                   }
[10:21:39.479]                 }
[10:21:39.479]                 else {
[10:21:39.479]                   if (TRUE) {
[10:21:39.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:39.479]                     {
[10:21:39.479]                       inherits <- base::inherits
[10:21:39.479]                       invokeRestart <- base::invokeRestart
[10:21:39.479]                       is.null <- base::is.null
[10:21:39.479]                       muffled <- FALSE
[10:21:39.479]                       if (inherits(cond, "message")) {
[10:21:39.479]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:39.479]                         if (muffled) 
[10:21:39.479]                           invokeRestart("muffleMessage")
[10:21:39.479]                       }
[10:21:39.479]                       else if (inherits(cond, "warning")) {
[10:21:39.479]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:39.479]                         if (muffled) 
[10:21:39.479]                           invokeRestart("muffleWarning")
[10:21:39.479]                       }
[10:21:39.479]                       else if (inherits(cond, "condition")) {
[10:21:39.479]                         if (!is.null(pattern)) {
[10:21:39.479]                           computeRestarts <- base::computeRestarts
[10:21:39.479]                           grepl <- base::grepl
[10:21:39.479]                           restarts <- computeRestarts(cond)
[10:21:39.479]                           for (restart in restarts) {
[10:21:39.479]                             name <- restart$name
[10:21:39.479]                             if (is.null(name)) 
[10:21:39.479]                               next
[10:21:39.479]                             if (!grepl(pattern, name)) 
[10:21:39.479]                               next
[10:21:39.479]                             invokeRestart(restart)
[10:21:39.479]                             muffled <- TRUE
[10:21:39.479]                             break
[10:21:39.479]                           }
[10:21:39.479]                         }
[10:21:39.479]                       }
[10:21:39.479]                       invisible(muffled)
[10:21:39.479]                     }
[10:21:39.479]                     muffleCondition(cond, pattern = "^muffle")
[10:21:39.479]                   }
[10:21:39.479]                 }
[10:21:39.479]             }
[10:21:39.479]         }))
[10:21:39.479]     }, error = function(ex) {
[10:21:39.479]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:39.479]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:39.479]                 ...future.rng), started = ...future.startTime, 
[10:21:39.479]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:39.479]             version = "1.8"), class = "FutureResult")
[10:21:39.479]     }, finally = {
[10:21:39.479]         if (!identical(...future.workdir, getwd())) 
[10:21:39.479]             setwd(...future.workdir)
[10:21:39.479]         {
[10:21:39.479]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:39.479]                 ...future.oldOptions$nwarnings <- NULL
[10:21:39.479]             }
[10:21:39.479]             base::options(...future.oldOptions)
[10:21:39.479]             if (.Platform$OS.type == "windows") {
[10:21:39.479]                 old_names <- names(...future.oldEnvVars)
[10:21:39.479]                 envs <- base::Sys.getenv()
[10:21:39.479]                 names <- names(envs)
[10:21:39.479]                 common <- intersect(names, old_names)
[10:21:39.479]                 added <- setdiff(names, old_names)
[10:21:39.479]                 removed <- setdiff(old_names, names)
[10:21:39.479]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:39.479]                   envs[common]]
[10:21:39.479]                 NAMES <- toupper(changed)
[10:21:39.479]                 args <- list()
[10:21:39.479]                 for (kk in seq_along(NAMES)) {
[10:21:39.479]                   name <- changed[[kk]]
[10:21:39.479]                   NAME <- NAMES[[kk]]
[10:21:39.479]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:39.479]                     next
[10:21:39.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:39.479]                 }
[10:21:39.479]                 NAMES <- toupper(added)
[10:21:39.479]                 for (kk in seq_along(NAMES)) {
[10:21:39.479]                   name <- added[[kk]]
[10:21:39.479]                   NAME <- NAMES[[kk]]
[10:21:39.479]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:39.479]                     next
[10:21:39.479]                   args[[name]] <- ""
[10:21:39.479]                 }
[10:21:39.479]                 NAMES <- toupper(removed)
[10:21:39.479]                 for (kk in seq_along(NAMES)) {
[10:21:39.479]                   name <- removed[[kk]]
[10:21:39.479]                   NAME <- NAMES[[kk]]
[10:21:39.479]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:39.479]                     next
[10:21:39.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:39.479]                 }
[10:21:39.479]                 if (length(args) > 0) 
[10:21:39.479]                   base::do.call(base::Sys.setenv, args = args)
[10:21:39.479]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:39.479]             }
[10:21:39.479]             else {
[10:21:39.479]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:39.479]             }
[10:21:39.479]             {
[10:21:39.479]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:39.479]                   0L) {
[10:21:39.479]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:39.479]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:39.479]                   base::options(opts)
[10:21:39.479]                 }
[10:21:39.479]                 {
[10:21:39.479]                   {
[10:21:39.479]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:39.479]                     NULL
[10:21:39.479]                   }
[10:21:39.479]                   options(future.plan = NULL)
[10:21:39.479]                   if (is.na(NA_character_)) 
[10:21:39.479]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:39.479]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:39.479]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:39.479]                     .init = FALSE)
[10:21:39.479]                 }
[10:21:39.479]             }
[10:21:39.479]         }
[10:21:39.479]     })
[10:21:39.479]     if (TRUE) {
[10:21:39.479]         base::sink(type = "output", split = FALSE)
[10:21:39.479]         if (TRUE) {
[10:21:39.479]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:39.479]         }
[10:21:39.479]         else {
[10:21:39.479]             ...future.result["stdout"] <- base::list(NULL)
[10:21:39.479]         }
[10:21:39.479]         base::close(...future.stdout)
[10:21:39.479]         ...future.stdout <- NULL
[10:21:39.479]     }
[10:21:39.479]     ...future.result$conditions <- ...future.conditions
[10:21:39.479]     ...future.result$finished <- base::Sys.time()
[10:21:39.479]     ...future.result
[10:21:39.479] }
[10:21:39.532] MultisessionFuture started
[10:21:39.533] result() for ClusterFuture ...
[10:21:39.533] receiveMessageFromWorker() for ClusterFuture ...
[10:21:39.533] - Validating connection of MultisessionFuture
[10:21:39.564] - received message: FutureResult
[10:21:39.564] - Received FutureResult
[10:21:39.564] - Erased future from FutureRegistry
[10:21:39.564] result() for ClusterFuture ...
[10:21:39.564] - result already collected: FutureResult
[10:21:39.565] result() for ClusterFuture ... done
[10:21:39.565] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:39.565] result() for ClusterFuture ... done
[10:21:39.565] result() for ClusterFuture ...
[10:21:39.565] - result already collected: FutureResult
[10:21:39.565] result() for ClusterFuture ... done
[10:21:39.565] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:21:39.567] plan(): nbrOfWorkers() = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:39.567] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:39.567] Searching for globals...
[10:21:39.569] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:39.569] Searching for globals ... DONE
[10:21:39.569] Resolving globals: TRUE
[10:21:39.569] Resolving any globals that are futures ...
[10:21:39.569] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:39.570] Resolving any globals that are futures ... DONE
[10:21:39.570] Resolving futures part of globals (recursively) ...
[10:21:39.570] resolve() on list ...
[10:21:39.570]  recursive: 99
[10:21:39.570]  length: 1
[10:21:39.570]  elements: ‘x’
[10:21:39.571]  length: 0 (resolved future 1)
[10:21:39.571] resolve() on list ... DONE
[10:21:39.571] - globals: [1] ‘x’
[10:21:39.571] Resolving futures part of globals (recursively) ... DONE
[10:21:39.571] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:39.571] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:39.571] - globals: [1] ‘x’
[10:21:39.572] 
[10:21:39.572] getGlobalsAndPackages() ... DONE
[10:21:39.572] run() for ‘Future’ ...
[10:21:39.572] - state: ‘created’
[10:21:39.572] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:39.586] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:39.586] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:39.586]   - Field: ‘node’
[10:21:39.586]   - Field: ‘label’
[10:21:39.586]   - Field: ‘local’
[10:21:39.587]   - Field: ‘owner’
[10:21:39.587]   - Field: ‘envir’
[10:21:39.587]   - Field: ‘workers’
[10:21:39.587]   - Field: ‘packages’
[10:21:39.587]   - Field: ‘gc’
[10:21:39.587]   - Field: ‘conditions’
[10:21:39.587]   - Field: ‘persistent’
[10:21:39.587]   - Field: ‘expr’
[10:21:39.587]   - Field: ‘uuid’
[10:21:39.587]   - Field: ‘seed’
[10:21:39.587]   - Field: ‘version’
[10:21:39.588]   - Field: ‘result’
[10:21:39.588]   - Field: ‘asynchronous’
[10:21:39.588]   - Field: ‘calls’
[10:21:39.588]   - Field: ‘globals’
[10:21:39.588]   - Field: ‘stdout’
[10:21:39.588]   - Field: ‘earlySignal’
[10:21:39.588]   - Field: ‘lazy’
[10:21:39.588]   - Field: ‘state’
[10:21:39.588] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:39.588] - Launch lazy future ...
[10:21:39.589] Packages needed by the future expression (n = 0): <none>
[10:21:39.589] Packages needed by future strategies (n = 0): <none>
[10:21:39.589] {
[10:21:39.589]     {
[10:21:39.589]         {
[10:21:39.589]             ...future.startTime <- base::Sys.time()
[10:21:39.589]             {
[10:21:39.589]                 {
[10:21:39.589]                   {
[10:21:39.589]                     {
[10:21:39.589]                       base::local({
[10:21:39.589]                         has_future <- base::requireNamespace("future", 
[10:21:39.589]                           quietly = TRUE)
[10:21:39.589]                         if (has_future) {
[10:21:39.589]                           ns <- base::getNamespace("future")
[10:21:39.589]                           version <- ns[[".package"]][["version"]]
[10:21:39.589]                           if (is.null(version)) 
[10:21:39.589]                             version <- utils::packageVersion("future")
[10:21:39.589]                         }
[10:21:39.589]                         else {
[10:21:39.589]                           version <- NULL
[10:21:39.589]                         }
[10:21:39.589]                         if (!has_future || version < "1.8.0") {
[10:21:39.589]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:39.589]                             "", base::R.version$version.string), 
[10:21:39.589]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:39.589]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:39.589]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:39.589]                               "release", "version")], collapse = " "), 
[10:21:39.589]                             hostname = base::Sys.info()[["nodename"]])
[10:21:39.589]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:39.589]                             info)
[10:21:39.589]                           info <- base::paste(info, collapse = "; ")
[10:21:39.589]                           if (!has_future) {
[10:21:39.589]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:39.589]                               info)
[10:21:39.589]                           }
[10:21:39.589]                           else {
[10:21:39.589]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:39.589]                               info, version)
[10:21:39.589]                           }
[10:21:39.589]                           base::stop(msg)
[10:21:39.589]                         }
[10:21:39.589]                       })
[10:21:39.589]                     }
[10:21:39.589]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:39.589]                     base::options(mc.cores = 1L)
[10:21:39.589]                   }
[10:21:39.589]                   ...future.strategy.old <- future::plan("list")
[10:21:39.589]                   options(future.plan = NULL)
[10:21:39.589]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:39.589]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:39.589]                 }
[10:21:39.589]                 ...future.workdir <- getwd()
[10:21:39.589]             }
[10:21:39.589]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:39.589]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:39.589]         }
[10:21:39.589]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:39.589]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:39.589]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:39.589]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:39.589]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:39.589]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:39.589]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:39.589]             base::names(...future.oldOptions))
[10:21:39.589]     }
[10:21:39.589]     if (FALSE) {
[10:21:39.589]     }
[10:21:39.589]     else {
[10:21:39.589]         if (TRUE) {
[10:21:39.589]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:39.589]                 open = "w")
[10:21:39.589]         }
[10:21:39.589]         else {
[10:21:39.589]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:39.589]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:39.589]         }
[10:21:39.589]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:39.589]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:39.589]             base::sink(type = "output", split = FALSE)
[10:21:39.589]             base::close(...future.stdout)
[10:21:39.589]         }, add = TRUE)
[10:21:39.589]     }
[10:21:39.589]     ...future.frame <- base::sys.nframe()
[10:21:39.589]     ...future.conditions <- base::list()
[10:21:39.589]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:39.589]     if (FALSE) {
[10:21:39.589]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:39.589]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:39.589]     }
[10:21:39.589]     ...future.result <- base::tryCatch({
[10:21:39.589]         base::withCallingHandlers({
[10:21:39.589]             ...future.value <- base::withVisible(base::local({
[10:21:39.589]                 ...future.makeSendCondition <- base::local({
[10:21:39.589]                   sendCondition <- NULL
[10:21:39.589]                   function(frame = 1L) {
[10:21:39.589]                     if (is.function(sendCondition)) 
[10:21:39.589]                       return(sendCondition)
[10:21:39.589]                     ns <- getNamespace("parallel")
[10:21:39.589]                     if (exists("sendData", mode = "function", 
[10:21:39.589]                       envir = ns)) {
[10:21:39.589]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:39.589]                         envir = ns)
[10:21:39.589]                       envir <- sys.frame(frame)
[10:21:39.589]                       master <- NULL
[10:21:39.589]                       while (!identical(envir, .GlobalEnv) && 
[10:21:39.589]                         !identical(envir, emptyenv())) {
[10:21:39.589]                         if (exists("master", mode = "list", envir = envir, 
[10:21:39.589]                           inherits = FALSE)) {
[10:21:39.589]                           master <- get("master", mode = "list", 
[10:21:39.589]                             envir = envir, inherits = FALSE)
[10:21:39.589]                           if (inherits(master, c("SOCKnode", 
[10:21:39.589]                             "SOCK0node"))) {
[10:21:39.589]                             sendCondition <<- function(cond) {
[10:21:39.589]                               data <- list(type = "VALUE", value = cond, 
[10:21:39.589]                                 success = TRUE)
[10:21:39.589]                               parallel_sendData(master, data)
[10:21:39.589]                             }
[10:21:39.589]                             return(sendCondition)
[10:21:39.589]                           }
[10:21:39.589]                         }
[10:21:39.589]                         frame <- frame + 1L
[10:21:39.589]                         envir <- sys.frame(frame)
[10:21:39.589]                       }
[10:21:39.589]                     }
[10:21:39.589]                     sendCondition <<- function(cond) NULL
[10:21:39.589]                   }
[10:21:39.589]                 })
[10:21:39.589]                 withCallingHandlers({
[10:21:39.589]                   {
[10:21:39.589]                     x$a <- 1
[10:21:39.589]                     x
[10:21:39.589]                   }
[10:21:39.589]                 }, immediateCondition = function(cond) {
[10:21:39.589]                   sendCondition <- ...future.makeSendCondition()
[10:21:39.589]                   sendCondition(cond)
[10:21:39.589]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:39.589]                   {
[10:21:39.589]                     inherits <- base::inherits
[10:21:39.589]                     invokeRestart <- base::invokeRestart
[10:21:39.589]                     is.null <- base::is.null
[10:21:39.589]                     muffled <- FALSE
[10:21:39.589]                     if (inherits(cond, "message")) {
[10:21:39.589]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:39.589]                       if (muffled) 
[10:21:39.589]                         invokeRestart("muffleMessage")
[10:21:39.589]                     }
[10:21:39.589]                     else if (inherits(cond, "warning")) {
[10:21:39.589]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:39.589]                       if (muffled) 
[10:21:39.589]                         invokeRestart("muffleWarning")
[10:21:39.589]                     }
[10:21:39.589]                     else if (inherits(cond, "condition")) {
[10:21:39.589]                       if (!is.null(pattern)) {
[10:21:39.589]                         computeRestarts <- base::computeRestarts
[10:21:39.589]                         grepl <- base::grepl
[10:21:39.589]                         restarts <- computeRestarts(cond)
[10:21:39.589]                         for (restart in restarts) {
[10:21:39.589]                           name <- restart$name
[10:21:39.589]                           if (is.null(name)) 
[10:21:39.589]                             next
[10:21:39.589]                           if (!grepl(pattern, name)) 
[10:21:39.589]                             next
[10:21:39.589]                           invokeRestart(restart)
[10:21:39.589]                           muffled <- TRUE
[10:21:39.589]                           break
[10:21:39.589]                         }
[10:21:39.589]                       }
[10:21:39.589]                     }
[10:21:39.589]                     invisible(muffled)
[10:21:39.589]                   }
[10:21:39.589]                   muffleCondition(cond)
[10:21:39.589]                 })
[10:21:39.589]             }))
[10:21:39.589]             future::FutureResult(value = ...future.value$value, 
[10:21:39.589]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:39.589]                   ...future.rng), globalenv = if (FALSE) 
[10:21:39.589]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:39.589]                     ...future.globalenv.names))
[10:21:39.589]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:39.589]         }, condition = base::local({
[10:21:39.589]             c <- base::c
[10:21:39.589]             inherits <- base::inherits
[10:21:39.589]             invokeRestart <- base::invokeRestart
[10:21:39.589]             length <- base::length
[10:21:39.589]             list <- base::list
[10:21:39.589]             seq.int <- base::seq.int
[10:21:39.589]             signalCondition <- base::signalCondition
[10:21:39.589]             sys.calls <- base::sys.calls
[10:21:39.589]             `[[` <- base::`[[`
[10:21:39.589]             `+` <- base::`+`
[10:21:39.589]             `<<-` <- base::`<<-`
[10:21:39.589]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:39.589]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:39.589]                   3L)]
[10:21:39.589]             }
[10:21:39.589]             function(cond) {
[10:21:39.589]                 is_error <- inherits(cond, "error")
[10:21:39.589]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:39.589]                   NULL)
[10:21:39.589]                 if (is_error) {
[10:21:39.589]                   sessionInformation <- function() {
[10:21:39.589]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:39.589]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:39.589]                       search = base::search(), system = base::Sys.info())
[10:21:39.589]                   }
[10:21:39.589]                   ...future.conditions[[length(...future.conditions) + 
[10:21:39.589]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:39.589]                     cond$call), session = sessionInformation(), 
[10:21:39.589]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:39.589]                   signalCondition(cond)
[10:21:39.589]                 }
[10:21:39.589]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:39.589]                 "immediateCondition"))) {
[10:21:39.589]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:39.589]                   ...future.conditions[[length(...future.conditions) + 
[10:21:39.589]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:39.589]                   if (TRUE && !signal) {
[10:21:39.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:39.589]                     {
[10:21:39.589]                       inherits <- base::inherits
[10:21:39.589]                       invokeRestart <- base::invokeRestart
[10:21:39.589]                       is.null <- base::is.null
[10:21:39.589]                       muffled <- FALSE
[10:21:39.589]                       if (inherits(cond, "message")) {
[10:21:39.589]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:39.589]                         if (muffled) 
[10:21:39.589]                           invokeRestart("muffleMessage")
[10:21:39.589]                       }
[10:21:39.589]                       else if (inherits(cond, "warning")) {
[10:21:39.589]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:39.589]                         if (muffled) 
[10:21:39.589]                           invokeRestart("muffleWarning")
[10:21:39.589]                       }
[10:21:39.589]                       else if (inherits(cond, "condition")) {
[10:21:39.589]                         if (!is.null(pattern)) {
[10:21:39.589]                           computeRestarts <- base::computeRestarts
[10:21:39.589]                           grepl <- base::grepl
[10:21:39.589]                           restarts <- computeRestarts(cond)
[10:21:39.589]                           for (restart in restarts) {
[10:21:39.589]                             name <- restart$name
[10:21:39.589]                             if (is.null(name)) 
[10:21:39.589]                               next
[10:21:39.589]                             if (!grepl(pattern, name)) 
[10:21:39.589]                               next
[10:21:39.589]                             invokeRestart(restart)
[10:21:39.589]                             muffled <- TRUE
[10:21:39.589]                             break
[10:21:39.589]                           }
[10:21:39.589]                         }
[10:21:39.589]                       }
[10:21:39.589]                       invisible(muffled)
[10:21:39.589]                     }
[10:21:39.589]                     muffleCondition(cond, pattern = "^muffle")
[10:21:39.589]                   }
[10:21:39.589]                 }
[10:21:39.589]                 else {
[10:21:39.589]                   if (TRUE) {
[10:21:39.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:39.589]                     {
[10:21:39.589]                       inherits <- base::inherits
[10:21:39.589]                       invokeRestart <- base::invokeRestart
[10:21:39.589]                       is.null <- base::is.null
[10:21:39.589]                       muffled <- FALSE
[10:21:39.589]                       if (inherits(cond, "message")) {
[10:21:39.589]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:39.589]                         if (muffled) 
[10:21:39.589]                           invokeRestart("muffleMessage")
[10:21:39.589]                       }
[10:21:39.589]                       else if (inherits(cond, "warning")) {
[10:21:39.589]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:39.589]                         if (muffled) 
[10:21:39.589]                           invokeRestart("muffleWarning")
[10:21:39.589]                       }
[10:21:39.589]                       else if (inherits(cond, "condition")) {
[10:21:39.589]                         if (!is.null(pattern)) {
[10:21:39.589]                           computeRestarts <- base::computeRestarts
[10:21:39.589]                           grepl <- base::grepl
[10:21:39.589]                           restarts <- computeRestarts(cond)
[10:21:39.589]                           for (restart in restarts) {
[10:21:39.589]                             name <- restart$name
[10:21:39.589]                             if (is.null(name)) 
[10:21:39.589]                               next
[10:21:39.589]                             if (!grepl(pattern, name)) 
[10:21:39.589]                               next
[10:21:39.589]                             invokeRestart(restart)
[10:21:39.589]                             muffled <- TRUE
[10:21:39.589]                             break
[10:21:39.589]                           }
[10:21:39.589]                         }
[10:21:39.589]                       }
[10:21:39.589]                       invisible(muffled)
[10:21:39.589]                     }
[10:21:39.589]                     muffleCondition(cond, pattern = "^muffle")
[10:21:39.589]                   }
[10:21:39.589]                 }
[10:21:39.589]             }
[10:21:39.589]         }))
[10:21:39.589]     }, error = function(ex) {
[10:21:39.589]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:39.589]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:39.589]                 ...future.rng), started = ...future.startTime, 
[10:21:39.589]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:39.589]             version = "1.8"), class = "FutureResult")
[10:21:39.589]     }, finally = {
[10:21:39.589]         if (!identical(...future.workdir, getwd())) 
[10:21:39.589]             setwd(...future.workdir)
[10:21:39.589]         {
[10:21:39.589]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:39.589]                 ...future.oldOptions$nwarnings <- NULL
[10:21:39.589]             }
[10:21:39.589]             base::options(...future.oldOptions)
[10:21:39.589]             if (.Platform$OS.type == "windows") {
[10:21:39.589]                 old_names <- names(...future.oldEnvVars)
[10:21:39.589]                 envs <- base::Sys.getenv()
[10:21:39.589]                 names <- names(envs)
[10:21:39.589]                 common <- intersect(names, old_names)
[10:21:39.589]                 added <- setdiff(names, old_names)
[10:21:39.589]                 removed <- setdiff(old_names, names)
[10:21:39.589]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:39.589]                   envs[common]]
[10:21:39.589]                 NAMES <- toupper(changed)
[10:21:39.589]                 args <- list()
[10:21:39.589]                 for (kk in seq_along(NAMES)) {
[10:21:39.589]                   name <- changed[[kk]]
[10:21:39.589]                   NAME <- NAMES[[kk]]
[10:21:39.589]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:39.589]                     next
[10:21:39.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:39.589]                 }
[10:21:39.589]                 NAMES <- toupper(added)
[10:21:39.589]                 for (kk in seq_along(NAMES)) {
[10:21:39.589]                   name <- added[[kk]]
[10:21:39.589]                   NAME <- NAMES[[kk]]
[10:21:39.589]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:39.589]                     next
[10:21:39.589]                   args[[name]] <- ""
[10:21:39.589]                 }
[10:21:39.589]                 NAMES <- toupper(removed)
[10:21:39.589]                 for (kk in seq_along(NAMES)) {
[10:21:39.589]                   name <- removed[[kk]]
[10:21:39.589]                   NAME <- NAMES[[kk]]
[10:21:39.589]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:39.589]                     next
[10:21:39.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:39.589]                 }
[10:21:39.589]                 if (length(args) > 0) 
[10:21:39.589]                   base::do.call(base::Sys.setenv, args = args)
[10:21:39.589]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:39.589]             }
[10:21:39.589]             else {
[10:21:39.589]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:39.589]             }
[10:21:39.589]             {
[10:21:39.589]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:39.589]                   0L) {
[10:21:39.589]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:39.589]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:39.589]                   base::options(opts)
[10:21:39.589]                 }
[10:21:39.589]                 {
[10:21:39.589]                   {
[10:21:39.589]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:39.589]                     NULL
[10:21:39.589]                   }
[10:21:39.589]                   options(future.plan = NULL)
[10:21:39.589]                   if (is.na(NA_character_)) 
[10:21:39.589]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:39.589]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:39.589]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:39.589]                     .init = FALSE)
[10:21:39.589]                 }
[10:21:39.589]             }
[10:21:39.589]         }
[10:21:39.589]     })
[10:21:39.589]     if (TRUE) {
[10:21:39.589]         base::sink(type = "output", split = FALSE)
[10:21:39.589]         if (TRUE) {
[10:21:39.589]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:39.589]         }
[10:21:39.589]         else {
[10:21:39.589]             ...future.result["stdout"] <- base::list(NULL)
[10:21:39.589]         }
[10:21:39.589]         base::close(...future.stdout)
[10:21:39.589]         ...future.stdout <- NULL
[10:21:39.589]     }
[10:21:39.589]     ...future.result$conditions <- ...future.conditions
[10:21:39.589]     ...future.result$finished <- base::Sys.time()
[10:21:39.589]     ...future.result
[10:21:39.589] }
[10:21:39.592] Exporting 1 global objects (338 bytes) to cluster node #1 ...
[10:21:39.592] Exporting ‘x’ (31 bytes) to cluster node #1 ...
[10:21:39.592] Exporting ‘x’ (31 bytes) to cluster node #1 ... DONE
[10:21:39.592] Exporting 1 global objects (338 bytes) to cluster node #1 ... DONE
[10:21:39.593] MultisessionFuture started
[10:21:39.593] - Launch lazy future ... done
[10:21:39.593] run() for ‘MultisessionFuture’ ... done
[10:21:39.593] result() for ClusterFuture ...
[10:21:39.593] receiveMessageFromWorker() for ClusterFuture ...
[10:21:39.593] - Validating connection of MultisessionFuture
[10:21:39.635] - received message: FutureResult
[10:21:39.635] - Received FutureResult
[10:21:39.635] - Erased future from FutureRegistry
[10:21:39.635] result() for ClusterFuture ...
[10:21:39.635] - result already collected: FutureResult
[10:21:39.636] result() for ClusterFuture ... done
[10:21:39.636] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:39.636] result() for ClusterFuture ... done
[10:21:39.636] result() for ClusterFuture ...
[10:21:39.636] - result already collected: FutureResult
[10:21:39.636] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:39.636] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:39.636] Searching for globals...
[10:21:39.638] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:39.639] Searching for globals ... DONE
[10:21:39.639] Resolving globals: TRUE
[10:21:39.639] Resolving any globals that are futures ...
[10:21:39.639] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:39.639] Resolving any globals that are futures ... DONE
[10:21:39.639] Resolving futures part of globals (recursively) ...
[10:21:39.640] resolve() on list ...
[10:21:39.640]  recursive: 99
[10:21:39.640]  length: 1
[10:21:39.640]  elements: ‘x’
[10:21:39.640]  length: 0 (resolved future 1)
[10:21:39.640] resolve() on list ... DONE
[10:21:39.640] - globals: [1] ‘x’
[10:21:39.640] Resolving futures part of globals (recursively) ... DONE
[10:21:39.641] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:39.641] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:39.641] - globals: [1] ‘x’
[10:21:39.641] 
[10:21:39.641] getGlobalsAndPackages() ... DONE
[10:21:39.642] run() for ‘Future’ ...
[10:21:39.642] - state: ‘created’
[10:21:39.642] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:39.657] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:39.657] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:39.657]   - Field: ‘node’
[10:21:39.657]   - Field: ‘label’
[10:21:39.657]   - Field: ‘local’
[10:21:39.657]   - Field: ‘owner’
[10:21:39.657]   - Field: ‘envir’
[10:21:39.657]   - Field: ‘workers’
[10:21:39.657]   - Field: ‘packages’
[10:21:39.657]   - Field: ‘gc’
[10:21:39.658]   - Field: ‘conditions’
[10:21:39.658]   - Field: ‘persistent’
[10:21:39.658]   - Field: ‘expr’
[10:21:39.658]   - Field: ‘uuid’
[10:21:39.658]   - Field: ‘seed’
[10:21:39.658]   - Field: ‘version’
[10:21:39.658]   - Field: ‘result’
[10:21:39.658]   - Field: ‘asynchronous’
[10:21:39.658]   - Field: ‘calls’
[10:21:39.659]   - Field: ‘globals’
[10:21:39.659]   - Field: ‘stdout’
[10:21:39.659]   - Field: ‘earlySignal’
[10:21:39.659]   - Field: ‘lazy’
[10:21:39.659]   - Field: ‘state’
[10:21:39.659] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:39.659] - Launch lazy future ...
[10:21:39.660] Packages needed by the future expression (n = 0): <none>
[10:21:39.660] Packages needed by future strategies (n = 0): <none>
[10:21:39.660] {
[10:21:39.660]     {
[10:21:39.660]         {
[10:21:39.660]             ...future.startTime <- base::Sys.time()
[10:21:39.660]             {
[10:21:39.660]                 {
[10:21:39.660]                   {
[10:21:39.660]                     {
[10:21:39.660]                       base::local({
[10:21:39.660]                         has_future <- base::requireNamespace("future", 
[10:21:39.660]                           quietly = TRUE)
[10:21:39.660]                         if (has_future) {
[10:21:39.660]                           ns <- base::getNamespace("future")
[10:21:39.660]                           version <- ns[[".package"]][["version"]]
[10:21:39.660]                           if (is.null(version)) 
[10:21:39.660]                             version <- utils::packageVersion("future")
[10:21:39.660]                         }
[10:21:39.660]                         else {
[10:21:39.660]                           version <- NULL
[10:21:39.660]                         }
[10:21:39.660]                         if (!has_future || version < "1.8.0") {
[10:21:39.660]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:39.660]                             "", base::R.version$version.string), 
[10:21:39.660]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:39.660]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:39.660]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:39.660]                               "release", "version")], collapse = " "), 
[10:21:39.660]                             hostname = base::Sys.info()[["nodename"]])
[10:21:39.660]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:39.660]                             info)
[10:21:39.660]                           info <- base::paste(info, collapse = "; ")
[10:21:39.660]                           if (!has_future) {
[10:21:39.660]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:39.660]                               info)
[10:21:39.660]                           }
[10:21:39.660]                           else {
[10:21:39.660]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:39.660]                               info, version)
[10:21:39.660]                           }
[10:21:39.660]                           base::stop(msg)
[10:21:39.660]                         }
[10:21:39.660]                       })
[10:21:39.660]                     }
[10:21:39.660]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:39.660]                     base::options(mc.cores = 1L)
[10:21:39.660]                   }
[10:21:39.660]                   ...future.strategy.old <- future::plan("list")
[10:21:39.660]                   options(future.plan = NULL)
[10:21:39.660]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:39.660]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:39.660]                 }
[10:21:39.660]                 ...future.workdir <- getwd()
[10:21:39.660]             }
[10:21:39.660]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:39.660]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:39.660]         }
[10:21:39.660]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:39.660]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:39.660]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:39.660]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:39.660]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:39.660]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:39.660]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:39.660]             base::names(...future.oldOptions))
[10:21:39.660]     }
[10:21:39.660]     if (FALSE) {
[10:21:39.660]     }
[10:21:39.660]     else {
[10:21:39.660]         if (TRUE) {
[10:21:39.660]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:39.660]                 open = "w")
[10:21:39.660]         }
[10:21:39.660]         else {
[10:21:39.660]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:39.660]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:39.660]         }
[10:21:39.660]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:39.660]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:39.660]             base::sink(type = "output", split = FALSE)
[10:21:39.660]             base::close(...future.stdout)
[10:21:39.660]         }, add = TRUE)
[10:21:39.660]     }
[10:21:39.660]     ...future.frame <- base::sys.nframe()
[10:21:39.660]     ...future.conditions <- base::list()
[10:21:39.660]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:39.660]     if (FALSE) {
[10:21:39.660]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:39.660]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:39.660]     }
[10:21:39.660]     ...future.result <- base::tryCatch({
[10:21:39.660]         base::withCallingHandlers({
[10:21:39.660]             ...future.value <- base::withVisible(base::local({
[10:21:39.660]                 ...future.makeSendCondition <- base::local({
[10:21:39.660]                   sendCondition <- NULL
[10:21:39.660]                   function(frame = 1L) {
[10:21:39.660]                     if (is.function(sendCondition)) 
[10:21:39.660]                       return(sendCondition)
[10:21:39.660]                     ns <- getNamespace("parallel")
[10:21:39.660]                     if (exists("sendData", mode = "function", 
[10:21:39.660]                       envir = ns)) {
[10:21:39.660]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:39.660]                         envir = ns)
[10:21:39.660]                       envir <- sys.frame(frame)
[10:21:39.660]                       master <- NULL
[10:21:39.660]                       while (!identical(envir, .GlobalEnv) && 
[10:21:39.660]                         !identical(envir, emptyenv())) {
[10:21:39.660]                         if (exists("master", mode = "list", envir = envir, 
[10:21:39.660]                           inherits = FALSE)) {
[10:21:39.660]                           master <- get("master", mode = "list", 
[10:21:39.660]                             envir = envir, inherits = FALSE)
[10:21:39.660]                           if (inherits(master, c("SOCKnode", 
[10:21:39.660]                             "SOCK0node"))) {
[10:21:39.660]                             sendCondition <<- function(cond) {
[10:21:39.660]                               data <- list(type = "VALUE", value = cond, 
[10:21:39.660]                                 success = TRUE)
[10:21:39.660]                               parallel_sendData(master, data)
[10:21:39.660]                             }
[10:21:39.660]                             return(sendCondition)
[10:21:39.660]                           }
[10:21:39.660]                         }
[10:21:39.660]                         frame <- frame + 1L
[10:21:39.660]                         envir <- sys.frame(frame)
[10:21:39.660]                       }
[10:21:39.660]                     }
[10:21:39.660]                     sendCondition <<- function(cond) NULL
[10:21:39.660]                   }
[10:21:39.660]                 })
[10:21:39.660]                 withCallingHandlers({
[10:21:39.660]                   {
[10:21:39.660]                     x$a <- 1
[10:21:39.660]                     x
[10:21:39.660]                   }
[10:21:39.660]                 }, immediateCondition = function(cond) {
[10:21:39.660]                   sendCondition <- ...future.makeSendCondition()
[10:21:39.660]                   sendCondition(cond)
[10:21:39.660]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:39.660]                   {
[10:21:39.660]                     inherits <- base::inherits
[10:21:39.660]                     invokeRestart <- base::invokeRestart
[10:21:39.660]                     is.null <- base::is.null
[10:21:39.660]                     muffled <- FALSE
[10:21:39.660]                     if (inherits(cond, "message")) {
[10:21:39.660]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:39.660]                       if (muffled) 
[10:21:39.660]                         invokeRestart("muffleMessage")
[10:21:39.660]                     }
[10:21:39.660]                     else if (inherits(cond, "warning")) {
[10:21:39.660]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:39.660]                       if (muffled) 
[10:21:39.660]                         invokeRestart("muffleWarning")
[10:21:39.660]                     }
[10:21:39.660]                     else if (inherits(cond, "condition")) {
[10:21:39.660]                       if (!is.null(pattern)) {
[10:21:39.660]                         computeRestarts <- base::computeRestarts
[10:21:39.660]                         grepl <- base::grepl
[10:21:39.660]                         restarts <- computeRestarts(cond)
[10:21:39.660]                         for (restart in restarts) {
[10:21:39.660]                           name <- restart$name
[10:21:39.660]                           if (is.null(name)) 
[10:21:39.660]                             next
[10:21:39.660]                           if (!grepl(pattern, name)) 
[10:21:39.660]                             next
[10:21:39.660]                           invokeRestart(restart)
[10:21:39.660]                           muffled <- TRUE
[10:21:39.660]                           break
[10:21:39.660]                         }
[10:21:39.660]                       }
[10:21:39.660]                     }
[10:21:39.660]                     invisible(muffled)
[10:21:39.660]                   }
[10:21:39.660]                   muffleCondition(cond)
[10:21:39.660]                 })
[10:21:39.660]             }))
[10:21:39.660]             future::FutureResult(value = ...future.value$value, 
[10:21:39.660]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:39.660]                   ...future.rng), globalenv = if (FALSE) 
[10:21:39.660]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:39.660]                     ...future.globalenv.names))
[10:21:39.660]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:39.660]         }, condition = base::local({
[10:21:39.660]             c <- base::c
[10:21:39.660]             inherits <- base::inherits
[10:21:39.660]             invokeRestart <- base::invokeRestart
[10:21:39.660]             length <- base::length
[10:21:39.660]             list <- base::list
[10:21:39.660]             seq.int <- base::seq.int
[10:21:39.660]             signalCondition <- base::signalCondition
[10:21:39.660]             sys.calls <- base::sys.calls
[10:21:39.660]             `[[` <- base::`[[`
[10:21:39.660]             `+` <- base::`+`
[10:21:39.660]             `<<-` <- base::`<<-`
[10:21:39.660]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:39.660]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:39.660]                   3L)]
[10:21:39.660]             }
[10:21:39.660]             function(cond) {
[10:21:39.660]                 is_error <- inherits(cond, "error")
[10:21:39.660]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:39.660]                   NULL)
[10:21:39.660]                 if (is_error) {
[10:21:39.660]                   sessionInformation <- function() {
[10:21:39.660]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:39.660]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:39.660]                       search = base::search(), system = base::Sys.info())
[10:21:39.660]                   }
[10:21:39.660]                   ...future.conditions[[length(...future.conditions) + 
[10:21:39.660]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:39.660]                     cond$call), session = sessionInformation(), 
[10:21:39.660]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:39.660]                   signalCondition(cond)
[10:21:39.660]                 }
[10:21:39.660]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:39.660]                 "immediateCondition"))) {
[10:21:39.660]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:39.660]                   ...future.conditions[[length(...future.conditions) + 
[10:21:39.660]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:39.660]                   if (TRUE && !signal) {
[10:21:39.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:39.660]                     {
[10:21:39.660]                       inherits <- base::inherits
[10:21:39.660]                       invokeRestart <- base::invokeRestart
[10:21:39.660]                       is.null <- base::is.null
[10:21:39.660]                       muffled <- FALSE
[10:21:39.660]                       if (inherits(cond, "message")) {
[10:21:39.660]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:39.660]                         if (muffled) 
[10:21:39.660]                           invokeRestart("muffleMessage")
[10:21:39.660]                       }
[10:21:39.660]                       else if (inherits(cond, "warning")) {
[10:21:39.660]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:39.660]                         if (muffled) 
[10:21:39.660]                           invokeRestart("muffleWarning")
[10:21:39.660]                       }
[10:21:39.660]                       else if (inherits(cond, "condition")) {
[10:21:39.660]                         if (!is.null(pattern)) {
[10:21:39.660]                           computeRestarts <- base::computeRestarts
[10:21:39.660]                           grepl <- base::grepl
[10:21:39.660]                           restarts <- computeRestarts(cond)
[10:21:39.660]                           for (restart in restarts) {
[10:21:39.660]                             name <- restart$name
[10:21:39.660]                             if (is.null(name)) 
[10:21:39.660]                               next
[10:21:39.660]                             if (!grepl(pattern, name)) 
[10:21:39.660]                               next
[10:21:39.660]                             invokeRestart(restart)
[10:21:39.660]                             muffled <- TRUE
[10:21:39.660]                             break
[10:21:39.660]                           }
[10:21:39.660]                         }
[10:21:39.660]                       }
[10:21:39.660]                       invisible(muffled)
[10:21:39.660]                     }
[10:21:39.660]                     muffleCondition(cond, pattern = "^muffle")
[10:21:39.660]                   }
[10:21:39.660]                 }
[10:21:39.660]                 else {
[10:21:39.660]                   if (TRUE) {
[10:21:39.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:39.660]                     {
[10:21:39.660]                       inherits <- base::inherits
[10:21:39.660]                       invokeRestart <- base::invokeRestart
[10:21:39.660]                       is.null <- base::is.null
[10:21:39.660]                       muffled <- FALSE
[10:21:39.660]                       if (inherits(cond, "message")) {
[10:21:39.660]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:39.660]                         if (muffled) 
[10:21:39.660]                           invokeRestart("muffleMessage")
[10:21:39.660]                       }
[10:21:39.660]                       else if (inherits(cond, "warning")) {
[10:21:39.660]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:39.660]                         if (muffled) 
[10:21:39.660]                           invokeRestart("muffleWarning")
[10:21:39.660]                       }
[10:21:39.660]                       else if (inherits(cond, "condition")) {
[10:21:39.660]                         if (!is.null(pattern)) {
[10:21:39.660]                           computeRestarts <- base::computeRestarts
[10:21:39.660]                           grepl <- base::grepl
[10:21:39.660]                           restarts <- computeRestarts(cond)
[10:21:39.660]                           for (restart in restarts) {
[10:21:39.660]                             name <- restart$name
[10:21:39.660]                             if (is.null(name)) 
[10:21:39.660]                               next
[10:21:39.660]                             if (!grepl(pattern, name)) 
[10:21:39.660]                               next
[10:21:39.660]                             invokeRestart(restart)
[10:21:39.660]                             muffled <- TRUE
[10:21:39.660]                             break
[10:21:39.660]                           }
[10:21:39.660]                         }
[10:21:39.660]                       }
[10:21:39.660]                       invisible(muffled)
[10:21:39.660]                     }
[10:21:39.660]                     muffleCondition(cond, pattern = "^muffle")
[10:21:39.660]                   }
[10:21:39.660]                 }
[10:21:39.660]             }
[10:21:39.660]         }))
[10:21:39.660]     }, error = function(ex) {
[10:21:39.660]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:39.660]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:39.660]                 ...future.rng), started = ...future.startTime, 
[10:21:39.660]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:39.660]             version = "1.8"), class = "FutureResult")
[10:21:39.660]     }, finally = {
[10:21:39.660]         if (!identical(...future.workdir, getwd())) 
[10:21:39.660]             setwd(...future.workdir)
[10:21:39.660]         {
[10:21:39.660]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:39.660]                 ...future.oldOptions$nwarnings <- NULL
[10:21:39.660]             }
[10:21:39.660]             base::options(...future.oldOptions)
[10:21:39.660]             if (.Platform$OS.type == "windows") {
[10:21:39.660]                 old_names <- names(...future.oldEnvVars)
[10:21:39.660]                 envs <- base::Sys.getenv()
[10:21:39.660]                 names <- names(envs)
[10:21:39.660]                 common <- intersect(names, old_names)
[10:21:39.660]                 added <- setdiff(names, old_names)
[10:21:39.660]                 removed <- setdiff(old_names, names)
[10:21:39.660]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:39.660]                   envs[common]]
[10:21:39.660]                 NAMES <- toupper(changed)
[10:21:39.660]                 args <- list()
[10:21:39.660]                 for (kk in seq_along(NAMES)) {
[10:21:39.660]                   name <- changed[[kk]]
[10:21:39.660]                   NAME <- NAMES[[kk]]
[10:21:39.660]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:39.660]                     next
[10:21:39.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:39.660]                 }
[10:21:39.660]                 NAMES <- toupper(added)
[10:21:39.660]                 for (kk in seq_along(NAMES)) {
[10:21:39.660]                   name <- added[[kk]]
[10:21:39.660]                   NAME <- NAMES[[kk]]
[10:21:39.660]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:39.660]                     next
[10:21:39.660]                   args[[name]] <- ""
[10:21:39.660]                 }
[10:21:39.660]                 NAMES <- toupper(removed)
[10:21:39.660]                 for (kk in seq_along(NAMES)) {
[10:21:39.660]                   name <- removed[[kk]]
[10:21:39.660]                   NAME <- NAMES[[kk]]
[10:21:39.660]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:39.660]                     next
[10:21:39.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:39.660]                 }
[10:21:39.660]                 if (length(args) > 0) 
[10:21:39.660]                   base::do.call(base::Sys.setenv, args = args)
[10:21:39.660]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:39.660]             }
[10:21:39.660]             else {
[10:21:39.660]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:39.660]             }
[10:21:39.660]             {
[10:21:39.660]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:39.660]                   0L) {
[10:21:39.660]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:39.660]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:39.660]                   base::options(opts)
[10:21:39.660]                 }
[10:21:39.660]                 {
[10:21:39.660]                   {
[10:21:39.660]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:39.660]                     NULL
[10:21:39.660]                   }
[10:21:39.660]                   options(future.plan = NULL)
[10:21:39.660]                   if (is.na(NA_character_)) 
[10:21:39.660]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:39.660]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:39.660]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:39.660]                     .init = FALSE)
[10:21:39.660]                 }
[10:21:39.660]             }
[10:21:39.660]         }
[10:21:39.660]     })
[10:21:39.660]     if (TRUE) {
[10:21:39.660]         base::sink(type = "output", split = FALSE)
[10:21:39.660]         if (TRUE) {
[10:21:39.660]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:39.660]         }
[10:21:39.660]         else {
[10:21:39.660]             ...future.result["stdout"] <- base::list(NULL)
[10:21:39.660]         }
[10:21:39.660]         base::close(...future.stdout)
[10:21:39.660]         ...future.stdout <- NULL
[10:21:39.660]     }
[10:21:39.660]     ...future.result$conditions <- ...future.conditions
[10:21:39.660]     ...future.result$finished <- base::Sys.time()
[10:21:39.660]     ...future.result
[10:21:39.660] }
[10:21:39.667] Exporting 1 global objects (338 bytes) to cluster node #1 ...
[10:21:39.667] Exporting ‘x’ (31 bytes) to cluster node #1 ...
[10:21:39.668] Exporting ‘x’ (31 bytes) to cluster node #1 ... DONE
[10:21:39.668] Exporting 1 global objects (338 bytes) to cluster node #1 ... DONE
[10:21:39.668] MultisessionFuture started
[10:21:39.668] - Launch lazy future ... done
[10:21:39.669] run() for ‘MultisessionFuture’ ... done
[10:21:39.669] result() for ClusterFuture ...
[10:21:39.669] receiveMessageFromWorker() for ClusterFuture ...
[10:21:39.669] - Validating connection of MultisessionFuture
[10:21:39.710] - received message: FutureResult
[10:21:39.711] - Received FutureResult
[10:21:39.711] - Erased future from FutureRegistry
[10:21:39.711] result() for ClusterFuture ...
[10:21:39.711] - result already collected: FutureResult
[10:21:39.711] result() for ClusterFuture ... done
[10:21:39.711] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:39.711] result() for ClusterFuture ... done
[10:21:39.711] result() for ClusterFuture ...
[10:21:39.712] - result already collected: FutureResult
[10:21:39.712] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:39.712] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:39.713] Searching for globals...
[10:21:39.715] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:39.715] Searching for globals ... DONE
[10:21:39.715] Resolving globals: TRUE
[10:21:39.715] Resolving any globals that are futures ...
[10:21:39.716] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:39.716] Resolving any globals that are futures ... DONE
[10:21:39.716] Resolving futures part of globals (recursively) ...
[10:21:39.716] resolve() on list ...
[10:21:39.717]  recursive: 99
[10:21:39.717]  length: 1
[10:21:39.717]  elements: ‘x’
[10:21:39.717]  length: 0 (resolved future 1)
[10:21:39.717] resolve() on list ... DONE
[10:21:39.717] - globals: [1] ‘x’
[10:21:39.717] Resolving futures part of globals (recursively) ... DONE
[10:21:39.717] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:39.718] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:39.718] - globals: [1] ‘x’
[10:21:39.718] 
[10:21:39.718] getGlobalsAndPackages() ... DONE
[10:21:39.718] run() for ‘Future’ ...
[10:21:39.719] - state: ‘created’
[10:21:39.719] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:39.734] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:39.734] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:39.734]   - Field: ‘node’
[10:21:39.734]   - Field: ‘label’
[10:21:39.734]   - Field: ‘local’
[10:21:39.734]   - Field: ‘owner’
[10:21:39.734]   - Field: ‘envir’
[10:21:39.734]   - Field: ‘workers’
[10:21:39.734]   - Field: ‘packages’
[10:21:39.734]   - Field: ‘gc’
[10:21:39.735]   - Field: ‘conditions’
[10:21:39.735]   - Field: ‘persistent’
[10:21:39.735]   - Field: ‘expr’
[10:21:39.735]   - Field: ‘uuid’
[10:21:39.735]   - Field: ‘seed’
[10:21:39.735]   - Field: ‘version’
[10:21:39.735]   - Field: ‘result’
[10:21:39.735]   - Field: ‘asynchronous’
[10:21:39.735]   - Field: ‘calls’
[10:21:39.736]   - Field: ‘globals’
[10:21:39.736]   - Field: ‘stdout’
[10:21:39.736]   - Field: ‘earlySignal’
[10:21:39.736]   - Field: ‘lazy’
[10:21:39.736]   - Field: ‘state’
[10:21:39.736] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:39.736] - Launch lazy future ...
[10:21:39.737] Packages needed by the future expression (n = 0): <none>
[10:21:39.737] Packages needed by future strategies (n = 0): <none>
[10:21:39.737] {
[10:21:39.737]     {
[10:21:39.737]         {
[10:21:39.737]             ...future.startTime <- base::Sys.time()
[10:21:39.737]             {
[10:21:39.737]                 {
[10:21:39.737]                   {
[10:21:39.737]                     {
[10:21:39.737]                       base::local({
[10:21:39.737]                         has_future <- base::requireNamespace("future", 
[10:21:39.737]                           quietly = TRUE)
[10:21:39.737]                         if (has_future) {
[10:21:39.737]                           ns <- base::getNamespace("future")
[10:21:39.737]                           version <- ns[[".package"]][["version"]]
[10:21:39.737]                           if (is.null(version)) 
[10:21:39.737]                             version <- utils::packageVersion("future")
[10:21:39.737]                         }
[10:21:39.737]                         else {
[10:21:39.737]                           version <- NULL
[10:21:39.737]                         }
[10:21:39.737]                         if (!has_future || version < "1.8.0") {
[10:21:39.737]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:39.737]                             "", base::R.version$version.string), 
[10:21:39.737]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:39.737]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:39.737]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:39.737]                               "release", "version")], collapse = " "), 
[10:21:39.737]                             hostname = base::Sys.info()[["nodename"]])
[10:21:39.737]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:39.737]                             info)
[10:21:39.737]                           info <- base::paste(info, collapse = "; ")
[10:21:39.737]                           if (!has_future) {
[10:21:39.737]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:39.737]                               info)
[10:21:39.737]                           }
[10:21:39.737]                           else {
[10:21:39.737]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:39.737]                               info, version)
[10:21:39.737]                           }
[10:21:39.737]                           base::stop(msg)
[10:21:39.737]                         }
[10:21:39.737]                       })
[10:21:39.737]                     }
[10:21:39.737]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:39.737]                     base::options(mc.cores = 1L)
[10:21:39.737]                   }
[10:21:39.737]                   ...future.strategy.old <- future::plan("list")
[10:21:39.737]                   options(future.plan = NULL)
[10:21:39.737]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:39.737]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:39.737]                 }
[10:21:39.737]                 ...future.workdir <- getwd()
[10:21:39.737]             }
[10:21:39.737]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:39.737]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:39.737]         }
[10:21:39.737]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:39.737]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:39.737]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:39.737]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:39.737]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:39.737]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:39.737]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:39.737]             base::names(...future.oldOptions))
[10:21:39.737]     }
[10:21:39.737]     if (FALSE) {
[10:21:39.737]     }
[10:21:39.737]     else {
[10:21:39.737]         if (TRUE) {
[10:21:39.737]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:39.737]                 open = "w")
[10:21:39.737]         }
[10:21:39.737]         else {
[10:21:39.737]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:39.737]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:39.737]         }
[10:21:39.737]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:39.737]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:39.737]             base::sink(type = "output", split = FALSE)
[10:21:39.737]             base::close(...future.stdout)
[10:21:39.737]         }, add = TRUE)
[10:21:39.737]     }
[10:21:39.737]     ...future.frame <- base::sys.nframe()
[10:21:39.737]     ...future.conditions <- base::list()
[10:21:39.737]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:39.737]     if (FALSE) {
[10:21:39.737]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:39.737]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:39.737]     }
[10:21:39.737]     ...future.result <- base::tryCatch({
[10:21:39.737]         base::withCallingHandlers({
[10:21:39.737]             ...future.value <- base::withVisible(base::local({
[10:21:39.737]                 ...future.makeSendCondition <- base::local({
[10:21:39.737]                   sendCondition <- NULL
[10:21:39.737]                   function(frame = 1L) {
[10:21:39.737]                     if (is.function(sendCondition)) 
[10:21:39.737]                       return(sendCondition)
[10:21:39.737]                     ns <- getNamespace("parallel")
[10:21:39.737]                     if (exists("sendData", mode = "function", 
[10:21:39.737]                       envir = ns)) {
[10:21:39.737]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:39.737]                         envir = ns)
[10:21:39.737]                       envir <- sys.frame(frame)
[10:21:39.737]                       master <- NULL
[10:21:39.737]                       while (!identical(envir, .GlobalEnv) && 
[10:21:39.737]                         !identical(envir, emptyenv())) {
[10:21:39.737]                         if (exists("master", mode = "list", envir = envir, 
[10:21:39.737]                           inherits = FALSE)) {
[10:21:39.737]                           master <- get("master", mode = "list", 
[10:21:39.737]                             envir = envir, inherits = FALSE)
[10:21:39.737]                           if (inherits(master, c("SOCKnode", 
[10:21:39.737]                             "SOCK0node"))) {
[10:21:39.737]                             sendCondition <<- function(cond) {
[10:21:39.737]                               data <- list(type = "VALUE", value = cond, 
[10:21:39.737]                                 success = TRUE)
[10:21:39.737]                               parallel_sendData(master, data)
[10:21:39.737]                             }
[10:21:39.737]                             return(sendCondition)
[10:21:39.737]                           }
[10:21:39.737]                         }
[10:21:39.737]                         frame <- frame + 1L
[10:21:39.737]                         envir <- sys.frame(frame)
[10:21:39.737]                       }
[10:21:39.737]                     }
[10:21:39.737]                     sendCondition <<- function(cond) NULL
[10:21:39.737]                   }
[10:21:39.737]                 })
[10:21:39.737]                 withCallingHandlers({
[10:21:39.737]                   {
[10:21:39.737]                     x$a <- 1
[10:21:39.737]                     x
[10:21:39.737]                   }
[10:21:39.737]                 }, immediateCondition = function(cond) {
[10:21:39.737]                   sendCondition <- ...future.makeSendCondition()
[10:21:39.737]                   sendCondition(cond)
[10:21:39.737]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:39.737]                   {
[10:21:39.737]                     inherits <- base::inherits
[10:21:39.737]                     invokeRestart <- base::invokeRestart
[10:21:39.737]                     is.null <- base::is.null
[10:21:39.737]                     muffled <- FALSE
[10:21:39.737]                     if (inherits(cond, "message")) {
[10:21:39.737]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:39.737]                       if (muffled) 
[10:21:39.737]                         invokeRestart("muffleMessage")
[10:21:39.737]                     }
[10:21:39.737]                     else if (inherits(cond, "warning")) {
[10:21:39.737]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:39.737]                       if (muffled) 
[10:21:39.737]                         invokeRestart("muffleWarning")
[10:21:39.737]                     }
[10:21:39.737]                     else if (inherits(cond, "condition")) {
[10:21:39.737]                       if (!is.null(pattern)) {
[10:21:39.737]                         computeRestarts <- base::computeRestarts
[10:21:39.737]                         grepl <- base::grepl
[10:21:39.737]                         restarts <- computeRestarts(cond)
[10:21:39.737]                         for (restart in restarts) {
[10:21:39.737]                           name <- restart$name
[10:21:39.737]                           if (is.null(name)) 
[10:21:39.737]                             next
[10:21:39.737]                           if (!grepl(pattern, name)) 
[10:21:39.737]                             next
[10:21:39.737]                           invokeRestart(restart)
[10:21:39.737]                           muffled <- TRUE
[10:21:39.737]                           break
[10:21:39.737]                         }
[10:21:39.737]                       }
[10:21:39.737]                     }
[10:21:39.737]                     invisible(muffled)
[10:21:39.737]                   }
[10:21:39.737]                   muffleCondition(cond)
[10:21:39.737]                 })
[10:21:39.737]             }))
[10:21:39.737]             future::FutureResult(value = ...future.value$value, 
[10:21:39.737]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:39.737]                   ...future.rng), globalenv = if (FALSE) 
[10:21:39.737]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:39.737]                     ...future.globalenv.names))
[10:21:39.737]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:39.737]         }, condition = base::local({
[10:21:39.737]             c <- base::c
[10:21:39.737]             inherits <- base::inherits
[10:21:39.737]             invokeRestart <- base::invokeRestart
[10:21:39.737]             length <- base::length
[10:21:39.737]             list <- base::list
[10:21:39.737]             seq.int <- base::seq.int
[10:21:39.737]             signalCondition <- base::signalCondition
[10:21:39.737]             sys.calls <- base::sys.calls
[10:21:39.737]             `[[` <- base::`[[`
[10:21:39.737]             `+` <- base::`+`
[10:21:39.737]             `<<-` <- base::`<<-`
[10:21:39.737]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:39.737]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:39.737]                   3L)]
[10:21:39.737]             }
[10:21:39.737]             function(cond) {
[10:21:39.737]                 is_error <- inherits(cond, "error")
[10:21:39.737]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:39.737]                   NULL)
[10:21:39.737]                 if (is_error) {
[10:21:39.737]                   sessionInformation <- function() {
[10:21:39.737]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:39.737]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:39.737]                       search = base::search(), system = base::Sys.info())
[10:21:39.737]                   }
[10:21:39.737]                   ...future.conditions[[length(...future.conditions) + 
[10:21:39.737]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:39.737]                     cond$call), session = sessionInformation(), 
[10:21:39.737]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:39.737]                   signalCondition(cond)
[10:21:39.737]                 }
[10:21:39.737]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:39.737]                 "immediateCondition"))) {
[10:21:39.737]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:39.737]                   ...future.conditions[[length(...future.conditions) + 
[10:21:39.737]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:39.737]                   if (TRUE && !signal) {
[10:21:39.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:39.737]                     {
[10:21:39.737]                       inherits <- base::inherits
[10:21:39.737]                       invokeRestart <- base::invokeRestart
[10:21:39.737]                       is.null <- base::is.null
[10:21:39.737]                       muffled <- FALSE
[10:21:39.737]                       if (inherits(cond, "message")) {
[10:21:39.737]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:39.737]                         if (muffled) 
[10:21:39.737]                           invokeRestart("muffleMessage")
[10:21:39.737]                       }
[10:21:39.737]                       else if (inherits(cond, "warning")) {
[10:21:39.737]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:39.737]                         if (muffled) 
[10:21:39.737]                           invokeRestart("muffleWarning")
[10:21:39.737]                       }
[10:21:39.737]                       else if (inherits(cond, "condition")) {
[10:21:39.737]                         if (!is.null(pattern)) {
[10:21:39.737]                           computeRestarts <- base::computeRestarts
[10:21:39.737]                           grepl <- base::grepl
[10:21:39.737]                           restarts <- computeRestarts(cond)
[10:21:39.737]                           for (restart in restarts) {
[10:21:39.737]                             name <- restart$name
[10:21:39.737]                             if (is.null(name)) 
[10:21:39.737]                               next
[10:21:39.737]                             if (!grepl(pattern, name)) 
[10:21:39.737]                               next
[10:21:39.737]                             invokeRestart(restart)
[10:21:39.737]                             muffled <- TRUE
[10:21:39.737]                             break
[10:21:39.737]                           }
[10:21:39.737]                         }
[10:21:39.737]                       }
[10:21:39.737]                       invisible(muffled)
[10:21:39.737]                     }
[10:21:39.737]                     muffleCondition(cond, pattern = "^muffle")
[10:21:39.737]                   }
[10:21:39.737]                 }
[10:21:39.737]                 else {
[10:21:39.737]                   if (TRUE) {
[10:21:39.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:39.737]                     {
[10:21:39.737]                       inherits <- base::inherits
[10:21:39.737]                       invokeRestart <- base::invokeRestart
[10:21:39.737]                       is.null <- base::is.null
[10:21:39.737]                       muffled <- FALSE
[10:21:39.737]                       if (inherits(cond, "message")) {
[10:21:39.737]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:39.737]                         if (muffled) 
[10:21:39.737]                           invokeRestart("muffleMessage")
[10:21:39.737]                       }
[10:21:39.737]                       else if (inherits(cond, "warning")) {
[10:21:39.737]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:39.737]                         if (muffled) 
[10:21:39.737]                           invokeRestart("muffleWarning")
[10:21:39.737]                       }
[10:21:39.737]                       else if (inherits(cond, "condition")) {
[10:21:39.737]                         if (!is.null(pattern)) {
[10:21:39.737]                           computeRestarts <- base::computeRestarts
[10:21:39.737]                           grepl <- base::grepl
[10:21:39.737]                           restarts <- computeRestarts(cond)
[10:21:39.737]                           for (restart in restarts) {
[10:21:39.737]                             name <- restart$name
[10:21:39.737]                             if (is.null(name)) 
[10:21:39.737]                               next
[10:21:39.737]                             if (!grepl(pattern, name)) 
[10:21:39.737]                               next
[10:21:39.737]                             invokeRestart(restart)
[10:21:39.737]                             muffled <- TRUE
[10:21:39.737]                             break
[10:21:39.737]                           }
[10:21:39.737]                         }
[10:21:39.737]                       }
[10:21:39.737]                       invisible(muffled)
[10:21:39.737]                     }
[10:21:39.737]                     muffleCondition(cond, pattern = "^muffle")
[10:21:39.737]                   }
[10:21:39.737]                 }
[10:21:39.737]             }
[10:21:39.737]         }))
[10:21:39.737]     }, error = function(ex) {
[10:21:39.737]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:39.737]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:39.737]                 ...future.rng), started = ...future.startTime, 
[10:21:39.737]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:39.737]             version = "1.8"), class = "FutureResult")
[10:21:39.737]     }, finally = {
[10:21:39.737]         if (!identical(...future.workdir, getwd())) 
[10:21:39.737]             setwd(...future.workdir)
[10:21:39.737]         {
[10:21:39.737]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:39.737]                 ...future.oldOptions$nwarnings <- NULL
[10:21:39.737]             }
[10:21:39.737]             base::options(...future.oldOptions)
[10:21:39.737]             if (.Platform$OS.type == "windows") {
[10:21:39.737]                 old_names <- names(...future.oldEnvVars)
[10:21:39.737]                 envs <- base::Sys.getenv()
[10:21:39.737]                 names <- names(envs)
[10:21:39.737]                 common <- intersect(names, old_names)
[10:21:39.737]                 added <- setdiff(names, old_names)
[10:21:39.737]                 removed <- setdiff(old_names, names)
[10:21:39.737]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:39.737]                   envs[common]]
[10:21:39.737]                 NAMES <- toupper(changed)
[10:21:39.737]                 args <- list()
[10:21:39.737]                 for (kk in seq_along(NAMES)) {
[10:21:39.737]                   name <- changed[[kk]]
[10:21:39.737]                   NAME <- NAMES[[kk]]
[10:21:39.737]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:39.737]                     next
[10:21:39.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:39.737]                 }
[10:21:39.737]                 NAMES <- toupper(added)
[10:21:39.737]                 for (kk in seq_along(NAMES)) {
[10:21:39.737]                   name <- added[[kk]]
[10:21:39.737]                   NAME <- NAMES[[kk]]
[10:21:39.737]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:39.737]                     next
[10:21:39.737]                   args[[name]] <- ""
[10:21:39.737]                 }
[10:21:39.737]                 NAMES <- toupper(removed)
[10:21:39.737]                 for (kk in seq_along(NAMES)) {
[10:21:39.737]                   name <- removed[[kk]]
[10:21:39.737]                   NAME <- NAMES[[kk]]
[10:21:39.737]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:39.737]                     next
[10:21:39.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:39.737]                 }
[10:21:39.737]                 if (length(args) > 0) 
[10:21:39.737]                   base::do.call(base::Sys.setenv, args = args)
[10:21:39.737]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:39.737]             }
[10:21:39.737]             else {
[10:21:39.737]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:39.737]             }
[10:21:39.737]             {
[10:21:39.737]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:39.737]                   0L) {
[10:21:39.737]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:39.737]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:39.737]                   base::options(opts)
[10:21:39.737]                 }
[10:21:39.737]                 {
[10:21:39.737]                   {
[10:21:39.737]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:39.737]                     NULL
[10:21:39.737]                   }
[10:21:39.737]                   options(future.plan = NULL)
[10:21:39.737]                   if (is.na(NA_character_)) 
[10:21:39.737]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:39.737]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:39.737]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:39.737]                     .init = FALSE)
[10:21:39.737]                 }
[10:21:39.737]             }
[10:21:39.737]         }
[10:21:39.737]     })
[10:21:39.737]     if (TRUE) {
[10:21:39.737]         base::sink(type = "output", split = FALSE)
[10:21:39.737]         if (TRUE) {
[10:21:39.737]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:39.737]         }
[10:21:39.737]         else {
[10:21:39.737]             ...future.result["stdout"] <- base::list(NULL)
[10:21:39.737]         }
[10:21:39.737]         base::close(...future.stdout)
[10:21:39.737]         ...future.stdout <- NULL
[10:21:39.737]     }
[10:21:39.737]     ...future.result$conditions <- ...future.conditions
[10:21:39.737]     ...future.result$finished <- base::Sys.time()
[10:21:39.737]     ...future.result
[10:21:39.737] }
[10:21:39.740] Exporting 1 global objects (338 bytes) to cluster node #1 ...
[10:21:39.740] Exporting ‘x’ (31 bytes) to cluster node #1 ...
[10:21:39.741] Exporting ‘x’ (31 bytes) to cluster node #1 ... DONE
[10:21:39.741] Exporting 1 global objects (338 bytes) to cluster node #1 ... DONE
[10:21:39.741] MultisessionFuture started
[10:21:39.742] - Launch lazy future ... done
[10:21:39.742] run() for ‘MultisessionFuture’ ... done
[10:21:39.742] result() for ClusterFuture ...
[10:21:39.742] receiveMessageFromWorker() for ClusterFuture ...
[10:21:39.742] - Validating connection of MultisessionFuture
[10:21:39.784] - received message: FutureResult
[10:21:39.784] - Received FutureResult
[10:21:39.784] - Erased future from FutureRegistry
[10:21:39.784] result() for ClusterFuture ...
[10:21:39.785] - result already collected: FutureResult
[10:21:39.785] result() for ClusterFuture ... done
[10:21:39.785] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:39.785] result() for ClusterFuture ... done
[10:21:39.785] result() for ClusterFuture ...
[10:21:39.785] - result already collected: FutureResult
[10:21:39.785] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:39.786] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:39.786] Searching for globals...
[10:21:39.789] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:39.789] Searching for globals ... DONE
[10:21:39.789] Resolving globals: TRUE
[10:21:39.789] Resolving any globals that are futures ...
[10:21:39.789] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[10:21:39.789] Resolving any globals that are futures ... DONE
[10:21:39.790] Resolving futures part of globals (recursively) ...
[10:21:39.790] resolve() on list ...
[10:21:39.790]  recursive: 99
[10:21:39.790]  length: 1
[10:21:39.790]  elements: ‘x’
[10:21:39.790]  length: 0 (resolved future 1)
[10:21:39.791] resolve() on list ... DONE
[10:21:39.791] - globals: [1] ‘x’
[10:21:39.791] Resolving futures part of globals (recursively) ... DONE
[10:21:39.791] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:39.791] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:39.791] - globals: [1] ‘x’
[10:21:39.792] 
[10:21:39.792] getGlobalsAndPackages() ... DONE
[10:21:39.792] run() for ‘Future’ ...
[10:21:39.792] - state: ‘created’
[10:21:39.792] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:39.807] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:39.807] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:39.807]   - Field: ‘node’
[10:21:39.807]   - Field: ‘label’
[10:21:39.808]   - Field: ‘local’
[10:21:39.808]   - Field: ‘owner’
[10:21:39.808]   - Field: ‘envir’
[10:21:39.808]   - Field: ‘workers’
[10:21:39.808]   - Field: ‘packages’
[10:21:39.808]   - Field: ‘gc’
[10:21:39.808]   - Field: ‘conditions’
[10:21:39.808]   - Field: ‘persistent’
[10:21:39.808]   - Field: ‘expr’
[10:21:39.808]   - Field: ‘uuid’
[10:21:39.808]   - Field: ‘seed’
[10:21:39.809]   - Field: ‘version’
[10:21:39.809]   - Field: ‘result’
[10:21:39.809]   - Field: ‘asynchronous’
[10:21:39.809]   - Field: ‘calls’
[10:21:39.809]   - Field: ‘globals’
[10:21:39.809]   - Field: ‘stdout’
[10:21:39.809]   - Field: ‘earlySignal’
[10:21:39.809]   - Field: ‘lazy’
[10:21:39.809]   - Field: ‘state’
[10:21:39.810] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:39.810] - Launch lazy future ...
[10:21:39.810] Packages needed by the future expression (n = 0): <none>
[10:21:39.810] Packages needed by future strategies (n = 0): <none>
[10:21:39.811] {
[10:21:39.811]     {
[10:21:39.811]         {
[10:21:39.811]             ...future.startTime <- base::Sys.time()
[10:21:39.811]             {
[10:21:39.811]                 {
[10:21:39.811]                   {
[10:21:39.811]                     {
[10:21:39.811]                       base::local({
[10:21:39.811]                         has_future <- base::requireNamespace("future", 
[10:21:39.811]                           quietly = TRUE)
[10:21:39.811]                         if (has_future) {
[10:21:39.811]                           ns <- base::getNamespace("future")
[10:21:39.811]                           version <- ns[[".package"]][["version"]]
[10:21:39.811]                           if (is.null(version)) 
[10:21:39.811]                             version <- utils::packageVersion("future")
[10:21:39.811]                         }
[10:21:39.811]                         else {
[10:21:39.811]                           version <- NULL
[10:21:39.811]                         }
[10:21:39.811]                         if (!has_future || version < "1.8.0") {
[10:21:39.811]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:39.811]                             "", base::R.version$version.string), 
[10:21:39.811]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:39.811]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:39.811]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:39.811]                               "release", "version")], collapse = " "), 
[10:21:39.811]                             hostname = base::Sys.info()[["nodename"]])
[10:21:39.811]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:39.811]                             info)
[10:21:39.811]                           info <- base::paste(info, collapse = "; ")
[10:21:39.811]                           if (!has_future) {
[10:21:39.811]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:39.811]                               info)
[10:21:39.811]                           }
[10:21:39.811]                           else {
[10:21:39.811]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:39.811]                               info, version)
[10:21:39.811]                           }
[10:21:39.811]                           base::stop(msg)
[10:21:39.811]                         }
[10:21:39.811]                       })
[10:21:39.811]                     }
[10:21:39.811]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:39.811]                     base::options(mc.cores = 1L)
[10:21:39.811]                   }
[10:21:39.811]                   ...future.strategy.old <- future::plan("list")
[10:21:39.811]                   options(future.plan = NULL)
[10:21:39.811]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:39.811]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:39.811]                 }
[10:21:39.811]                 ...future.workdir <- getwd()
[10:21:39.811]             }
[10:21:39.811]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:39.811]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:39.811]         }
[10:21:39.811]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:39.811]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:39.811]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:39.811]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:39.811]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:39.811]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:39.811]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:39.811]             base::names(...future.oldOptions))
[10:21:39.811]     }
[10:21:39.811]     if (FALSE) {
[10:21:39.811]     }
[10:21:39.811]     else {
[10:21:39.811]         if (TRUE) {
[10:21:39.811]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:39.811]                 open = "w")
[10:21:39.811]         }
[10:21:39.811]         else {
[10:21:39.811]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:39.811]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:39.811]         }
[10:21:39.811]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:39.811]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:39.811]             base::sink(type = "output", split = FALSE)
[10:21:39.811]             base::close(...future.stdout)
[10:21:39.811]         }, add = TRUE)
[10:21:39.811]     }
[10:21:39.811]     ...future.frame <- base::sys.nframe()
[10:21:39.811]     ...future.conditions <- base::list()
[10:21:39.811]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:39.811]     if (FALSE) {
[10:21:39.811]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:39.811]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:39.811]     }
[10:21:39.811]     ...future.result <- base::tryCatch({
[10:21:39.811]         base::withCallingHandlers({
[10:21:39.811]             ...future.value <- base::withVisible(base::local({
[10:21:39.811]                 ...future.makeSendCondition <- base::local({
[10:21:39.811]                   sendCondition <- NULL
[10:21:39.811]                   function(frame = 1L) {
[10:21:39.811]                     if (is.function(sendCondition)) 
[10:21:39.811]                       return(sendCondition)
[10:21:39.811]                     ns <- getNamespace("parallel")
[10:21:39.811]                     if (exists("sendData", mode = "function", 
[10:21:39.811]                       envir = ns)) {
[10:21:39.811]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:39.811]                         envir = ns)
[10:21:39.811]                       envir <- sys.frame(frame)
[10:21:39.811]                       master <- NULL
[10:21:39.811]                       while (!identical(envir, .GlobalEnv) && 
[10:21:39.811]                         !identical(envir, emptyenv())) {
[10:21:39.811]                         if (exists("master", mode = "list", envir = envir, 
[10:21:39.811]                           inherits = FALSE)) {
[10:21:39.811]                           master <- get("master", mode = "list", 
[10:21:39.811]                             envir = envir, inherits = FALSE)
[10:21:39.811]                           if (inherits(master, c("SOCKnode", 
[10:21:39.811]                             "SOCK0node"))) {
[10:21:39.811]                             sendCondition <<- function(cond) {
[10:21:39.811]                               data <- list(type = "VALUE", value = cond, 
[10:21:39.811]                                 success = TRUE)
[10:21:39.811]                               parallel_sendData(master, data)
[10:21:39.811]                             }
[10:21:39.811]                             return(sendCondition)
[10:21:39.811]                           }
[10:21:39.811]                         }
[10:21:39.811]                         frame <- frame + 1L
[10:21:39.811]                         envir <- sys.frame(frame)
[10:21:39.811]                       }
[10:21:39.811]                     }
[10:21:39.811]                     sendCondition <<- function(cond) NULL
[10:21:39.811]                   }
[10:21:39.811]                 })
[10:21:39.811]                 withCallingHandlers({
[10:21:39.811]                   {
[10:21:39.811]                     x$a <- 1
[10:21:39.811]                     x
[10:21:39.811]                   }
[10:21:39.811]                 }, immediateCondition = function(cond) {
[10:21:39.811]                   sendCondition <- ...future.makeSendCondition()
[10:21:39.811]                   sendCondition(cond)
[10:21:39.811]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:39.811]                   {
[10:21:39.811]                     inherits <- base::inherits
[10:21:39.811]                     invokeRestart <- base::invokeRestart
[10:21:39.811]                     is.null <- base::is.null
[10:21:39.811]                     muffled <- FALSE
[10:21:39.811]                     if (inherits(cond, "message")) {
[10:21:39.811]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:39.811]                       if (muffled) 
[10:21:39.811]                         invokeRestart("muffleMessage")
[10:21:39.811]                     }
[10:21:39.811]                     else if (inherits(cond, "warning")) {
[10:21:39.811]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:39.811]                       if (muffled) 
[10:21:39.811]                         invokeRestart("muffleWarning")
[10:21:39.811]                     }
[10:21:39.811]                     else if (inherits(cond, "condition")) {
[10:21:39.811]                       if (!is.null(pattern)) {
[10:21:39.811]                         computeRestarts <- base::computeRestarts
[10:21:39.811]                         grepl <- base::grepl
[10:21:39.811]                         restarts <- computeRestarts(cond)
[10:21:39.811]                         for (restart in restarts) {
[10:21:39.811]                           name <- restart$name
[10:21:39.811]                           if (is.null(name)) 
[10:21:39.811]                             next
[10:21:39.811]                           if (!grepl(pattern, name)) 
[10:21:39.811]                             next
[10:21:39.811]                           invokeRestart(restart)
[10:21:39.811]                           muffled <- TRUE
[10:21:39.811]                           break
[10:21:39.811]                         }
[10:21:39.811]                       }
[10:21:39.811]                     }
[10:21:39.811]                     invisible(muffled)
[10:21:39.811]                   }
[10:21:39.811]                   muffleCondition(cond)
[10:21:39.811]                 })
[10:21:39.811]             }))
[10:21:39.811]             future::FutureResult(value = ...future.value$value, 
[10:21:39.811]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:39.811]                   ...future.rng), globalenv = if (FALSE) 
[10:21:39.811]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:39.811]                     ...future.globalenv.names))
[10:21:39.811]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:39.811]         }, condition = base::local({
[10:21:39.811]             c <- base::c
[10:21:39.811]             inherits <- base::inherits
[10:21:39.811]             invokeRestart <- base::invokeRestart
[10:21:39.811]             length <- base::length
[10:21:39.811]             list <- base::list
[10:21:39.811]             seq.int <- base::seq.int
[10:21:39.811]             signalCondition <- base::signalCondition
[10:21:39.811]             sys.calls <- base::sys.calls
[10:21:39.811]             `[[` <- base::`[[`
[10:21:39.811]             `+` <- base::`+`
[10:21:39.811]             `<<-` <- base::`<<-`
[10:21:39.811]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:39.811]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:39.811]                   3L)]
[10:21:39.811]             }
[10:21:39.811]             function(cond) {
[10:21:39.811]                 is_error <- inherits(cond, "error")
[10:21:39.811]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:39.811]                   NULL)
[10:21:39.811]                 if (is_error) {
[10:21:39.811]                   sessionInformation <- function() {
[10:21:39.811]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:39.811]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:39.811]                       search = base::search(), system = base::Sys.info())
[10:21:39.811]                   }
[10:21:39.811]                   ...future.conditions[[length(...future.conditions) + 
[10:21:39.811]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:39.811]                     cond$call), session = sessionInformation(), 
[10:21:39.811]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:39.811]                   signalCondition(cond)
[10:21:39.811]                 }
[10:21:39.811]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:39.811]                 "immediateCondition"))) {
[10:21:39.811]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:39.811]                   ...future.conditions[[length(...future.conditions) + 
[10:21:39.811]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:39.811]                   if (TRUE && !signal) {
[10:21:39.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:39.811]                     {
[10:21:39.811]                       inherits <- base::inherits
[10:21:39.811]                       invokeRestart <- base::invokeRestart
[10:21:39.811]                       is.null <- base::is.null
[10:21:39.811]                       muffled <- FALSE
[10:21:39.811]                       if (inherits(cond, "message")) {
[10:21:39.811]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:39.811]                         if (muffled) 
[10:21:39.811]                           invokeRestart("muffleMessage")
[10:21:39.811]                       }
[10:21:39.811]                       else if (inherits(cond, "warning")) {
[10:21:39.811]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:39.811]                         if (muffled) 
[10:21:39.811]                           invokeRestart("muffleWarning")
[10:21:39.811]                       }
[10:21:39.811]                       else if (inherits(cond, "condition")) {
[10:21:39.811]                         if (!is.null(pattern)) {
[10:21:39.811]                           computeRestarts <- base::computeRestarts
[10:21:39.811]                           grepl <- base::grepl
[10:21:39.811]                           restarts <- computeRestarts(cond)
[10:21:39.811]                           for (restart in restarts) {
[10:21:39.811]                             name <- restart$name
[10:21:39.811]                             if (is.null(name)) 
[10:21:39.811]                               next
[10:21:39.811]                             if (!grepl(pattern, name)) 
[10:21:39.811]                               next
[10:21:39.811]                             invokeRestart(restart)
[10:21:39.811]                             muffled <- TRUE
[10:21:39.811]                             break
[10:21:39.811]                           }
[10:21:39.811]                         }
[10:21:39.811]                       }
[10:21:39.811]                       invisible(muffled)
[10:21:39.811]                     }
[10:21:39.811]                     muffleCondition(cond, pattern = "^muffle")
[10:21:39.811]                   }
[10:21:39.811]                 }
[10:21:39.811]                 else {
[10:21:39.811]                   if (TRUE) {
[10:21:39.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:39.811]                     {
[10:21:39.811]                       inherits <- base::inherits
[10:21:39.811]                       invokeRestart <- base::invokeRestart
[10:21:39.811]                       is.null <- base::is.null
[10:21:39.811]                       muffled <- FALSE
[10:21:39.811]                       if (inherits(cond, "message")) {
[10:21:39.811]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:39.811]                         if (muffled) 
[10:21:39.811]                           invokeRestart("muffleMessage")
[10:21:39.811]                       }
[10:21:39.811]                       else if (inherits(cond, "warning")) {
[10:21:39.811]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:39.811]                         if (muffled) 
[10:21:39.811]                           invokeRestart("muffleWarning")
[10:21:39.811]                       }
[10:21:39.811]                       else if (inherits(cond, "condition")) {
[10:21:39.811]                         if (!is.null(pattern)) {
[10:21:39.811]                           computeRestarts <- base::computeRestarts
[10:21:39.811]                           grepl <- base::grepl
[10:21:39.811]                           restarts <- computeRestarts(cond)
[10:21:39.811]                           for (restart in restarts) {
[10:21:39.811]                             name <- restart$name
[10:21:39.811]                             if (is.null(name)) 
[10:21:39.811]                               next
[10:21:39.811]                             if (!grepl(pattern, name)) 
[10:21:39.811]                               next
[10:21:39.811]                             invokeRestart(restart)
[10:21:39.811]                             muffled <- TRUE
[10:21:39.811]                             break
[10:21:39.811]                           }
[10:21:39.811]                         }
[10:21:39.811]                       }
[10:21:39.811]                       invisible(muffled)
[10:21:39.811]                     }
[10:21:39.811]                     muffleCondition(cond, pattern = "^muffle")
[10:21:39.811]                   }
[10:21:39.811]                 }
[10:21:39.811]             }
[10:21:39.811]         }))
[10:21:39.811]     }, error = function(ex) {
[10:21:39.811]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:39.811]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:39.811]                 ...future.rng), started = ...future.startTime, 
[10:21:39.811]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:39.811]             version = "1.8"), class = "FutureResult")
[10:21:39.811]     }, finally = {
[10:21:39.811]         if (!identical(...future.workdir, getwd())) 
[10:21:39.811]             setwd(...future.workdir)
[10:21:39.811]         {
[10:21:39.811]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:39.811]                 ...future.oldOptions$nwarnings <- NULL
[10:21:39.811]             }
[10:21:39.811]             base::options(...future.oldOptions)
[10:21:39.811]             if (.Platform$OS.type == "windows") {
[10:21:39.811]                 old_names <- names(...future.oldEnvVars)
[10:21:39.811]                 envs <- base::Sys.getenv()
[10:21:39.811]                 names <- names(envs)
[10:21:39.811]                 common <- intersect(names, old_names)
[10:21:39.811]                 added <- setdiff(names, old_names)
[10:21:39.811]                 removed <- setdiff(old_names, names)
[10:21:39.811]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:39.811]                   envs[common]]
[10:21:39.811]                 NAMES <- toupper(changed)
[10:21:39.811]                 args <- list()
[10:21:39.811]                 for (kk in seq_along(NAMES)) {
[10:21:39.811]                   name <- changed[[kk]]
[10:21:39.811]                   NAME <- NAMES[[kk]]
[10:21:39.811]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:39.811]                     next
[10:21:39.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:39.811]                 }
[10:21:39.811]                 NAMES <- toupper(added)
[10:21:39.811]                 for (kk in seq_along(NAMES)) {
[10:21:39.811]                   name <- added[[kk]]
[10:21:39.811]                   NAME <- NAMES[[kk]]
[10:21:39.811]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:39.811]                     next
[10:21:39.811]                   args[[name]] <- ""
[10:21:39.811]                 }
[10:21:39.811]                 NAMES <- toupper(removed)
[10:21:39.811]                 for (kk in seq_along(NAMES)) {
[10:21:39.811]                   name <- removed[[kk]]
[10:21:39.811]                   NAME <- NAMES[[kk]]
[10:21:39.811]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:39.811]                     next
[10:21:39.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:39.811]                 }
[10:21:39.811]                 if (length(args) > 0) 
[10:21:39.811]                   base::do.call(base::Sys.setenv, args = args)
[10:21:39.811]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:39.811]             }
[10:21:39.811]             else {
[10:21:39.811]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:39.811]             }
[10:21:39.811]             {
[10:21:39.811]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:39.811]                   0L) {
[10:21:39.811]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:39.811]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:39.811]                   base::options(opts)
[10:21:39.811]                 }
[10:21:39.811]                 {
[10:21:39.811]                   {
[10:21:39.811]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:39.811]                     NULL
[10:21:39.811]                   }
[10:21:39.811]                   options(future.plan = NULL)
[10:21:39.811]                   if (is.na(NA_character_)) 
[10:21:39.811]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:39.811]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:39.811]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:39.811]                     .init = FALSE)
[10:21:39.811]                 }
[10:21:39.811]             }
[10:21:39.811]         }
[10:21:39.811]     })
[10:21:39.811]     if (TRUE) {
[10:21:39.811]         base::sink(type = "output", split = FALSE)
[10:21:39.811]         if (TRUE) {
[10:21:39.811]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:39.811]         }
[10:21:39.811]         else {
[10:21:39.811]             ...future.result["stdout"] <- base::list(NULL)
[10:21:39.811]         }
[10:21:39.811]         base::close(...future.stdout)
[10:21:39.811]         ...future.stdout <- NULL
[10:21:39.811]     }
[10:21:39.811]     ...future.result$conditions <- ...future.conditions
[10:21:39.811]     ...future.result$finished <- base::Sys.time()
[10:21:39.811]     ...future.result
[10:21:39.811] }
[10:21:39.814] Exporting 1 global objects (338 bytes) to cluster node #1 ...
[10:21:39.814] Exporting ‘x’ (31 bytes) to cluster node #1 ...
[10:21:39.814] Exporting ‘x’ (31 bytes) to cluster node #1 ... DONE
[10:21:39.814] Exporting 1 global objects (338 bytes) to cluster node #1 ... DONE
[10:21:39.815] MultisessionFuture started
[10:21:39.815] - Launch lazy future ... done
[10:21:39.815] run() for ‘MultisessionFuture’ ... done
[10:21:39.815] result() for ClusterFuture ...
[10:21:39.815] receiveMessageFromWorker() for ClusterFuture ...
[10:21:39.816] - Validating connection of MultisessionFuture
[10:21:39.857] - received message: FutureResult
[10:21:39.857] - Received FutureResult
[10:21:39.857] - Erased future from FutureRegistry
[10:21:39.858] result() for ClusterFuture ...
[10:21:39.858] - result already collected: FutureResult
[10:21:39.858] result() for ClusterFuture ... done
[10:21:39.858] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:39.858] result() for ClusterFuture ... done
[10:21:39.858] result() for ClusterFuture ...
[10:21:39.858] - result already collected: FutureResult
[10:21:39.858] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:39.859] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:39.859] Searching for globals...
[10:21:39.865] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[10:21:39.865] Searching for globals ... DONE
[10:21:39.865] Resolving globals: TRUE
[10:21:39.865] Resolving any globals that are futures ...
[10:21:39.865] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[10:21:39.865] Resolving any globals that are futures ... DONE
[10:21:39.866] 
[10:21:39.866] 
[10:21:39.866] getGlobalsAndPackages() ... DONE
[10:21:39.866] run() for ‘Future’ ...
[10:21:39.866] - state: ‘created’
[10:21:39.866] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:39.880] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:39.880] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:39.880]   - Field: ‘node’
[10:21:39.880]   - Field: ‘label’
[10:21:39.881]   - Field: ‘local’
[10:21:39.881]   - Field: ‘owner’
[10:21:39.881]   - Field: ‘envir’
[10:21:39.881]   - Field: ‘workers’
[10:21:39.881]   - Field: ‘packages’
[10:21:39.881]   - Field: ‘gc’
[10:21:39.881]   - Field: ‘conditions’
[10:21:39.881]   - Field: ‘persistent’
[10:21:39.881]   - Field: ‘expr’
[10:21:39.881]   - Field: ‘uuid’
[10:21:39.881]   - Field: ‘seed’
[10:21:39.881]   - Field: ‘version’
[10:21:39.882]   - Field: ‘result’
[10:21:39.882]   - Field: ‘asynchronous’
[10:21:39.882]   - Field: ‘calls’
[10:21:39.882]   - Field: ‘globals’
[10:21:39.882]   - Field: ‘stdout’
[10:21:39.882]   - Field: ‘earlySignal’
[10:21:39.882]   - Field: ‘lazy’
[10:21:39.882]   - Field: ‘state’
[10:21:39.882] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:39.882] - Launch lazy future ...
[10:21:39.883] Packages needed by the future expression (n = 0): <none>
[10:21:39.883] Packages needed by future strategies (n = 0): <none>
[10:21:39.883] {
[10:21:39.883]     {
[10:21:39.883]         {
[10:21:39.883]             ...future.startTime <- base::Sys.time()
[10:21:39.883]             {
[10:21:39.883]                 {
[10:21:39.883]                   {
[10:21:39.883]                     {
[10:21:39.883]                       base::local({
[10:21:39.883]                         has_future <- base::requireNamespace("future", 
[10:21:39.883]                           quietly = TRUE)
[10:21:39.883]                         if (has_future) {
[10:21:39.883]                           ns <- base::getNamespace("future")
[10:21:39.883]                           version <- ns[[".package"]][["version"]]
[10:21:39.883]                           if (is.null(version)) 
[10:21:39.883]                             version <- utils::packageVersion("future")
[10:21:39.883]                         }
[10:21:39.883]                         else {
[10:21:39.883]                           version <- NULL
[10:21:39.883]                         }
[10:21:39.883]                         if (!has_future || version < "1.8.0") {
[10:21:39.883]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:39.883]                             "", base::R.version$version.string), 
[10:21:39.883]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:39.883]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:39.883]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:39.883]                               "release", "version")], collapse = " "), 
[10:21:39.883]                             hostname = base::Sys.info()[["nodename"]])
[10:21:39.883]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:39.883]                             info)
[10:21:39.883]                           info <- base::paste(info, collapse = "; ")
[10:21:39.883]                           if (!has_future) {
[10:21:39.883]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:39.883]                               info)
[10:21:39.883]                           }
[10:21:39.883]                           else {
[10:21:39.883]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:39.883]                               info, version)
[10:21:39.883]                           }
[10:21:39.883]                           base::stop(msg)
[10:21:39.883]                         }
[10:21:39.883]                       })
[10:21:39.883]                     }
[10:21:39.883]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:39.883]                     base::options(mc.cores = 1L)
[10:21:39.883]                   }
[10:21:39.883]                   ...future.strategy.old <- future::plan("list")
[10:21:39.883]                   options(future.plan = NULL)
[10:21:39.883]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:39.883]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:39.883]                 }
[10:21:39.883]                 ...future.workdir <- getwd()
[10:21:39.883]             }
[10:21:39.883]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:39.883]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:39.883]         }
[10:21:39.883]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:39.883]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:39.883]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:39.883]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:39.883]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:39.883]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:39.883]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:39.883]             base::names(...future.oldOptions))
[10:21:39.883]     }
[10:21:39.883]     if (FALSE) {
[10:21:39.883]     }
[10:21:39.883]     else {
[10:21:39.883]         if (TRUE) {
[10:21:39.883]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:39.883]                 open = "w")
[10:21:39.883]         }
[10:21:39.883]         else {
[10:21:39.883]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:39.883]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:39.883]         }
[10:21:39.883]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:39.883]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:39.883]             base::sink(type = "output", split = FALSE)
[10:21:39.883]             base::close(...future.stdout)
[10:21:39.883]         }, add = TRUE)
[10:21:39.883]     }
[10:21:39.883]     ...future.frame <- base::sys.nframe()
[10:21:39.883]     ...future.conditions <- base::list()
[10:21:39.883]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:39.883]     if (FALSE) {
[10:21:39.883]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:39.883]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:39.883]     }
[10:21:39.883]     ...future.result <- base::tryCatch({
[10:21:39.883]         base::withCallingHandlers({
[10:21:39.883]             ...future.value <- base::withVisible(base::local({
[10:21:39.883]                 ...future.makeSendCondition <- base::local({
[10:21:39.883]                   sendCondition <- NULL
[10:21:39.883]                   function(frame = 1L) {
[10:21:39.883]                     if (is.function(sendCondition)) 
[10:21:39.883]                       return(sendCondition)
[10:21:39.883]                     ns <- getNamespace("parallel")
[10:21:39.883]                     if (exists("sendData", mode = "function", 
[10:21:39.883]                       envir = ns)) {
[10:21:39.883]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:39.883]                         envir = ns)
[10:21:39.883]                       envir <- sys.frame(frame)
[10:21:39.883]                       master <- NULL
[10:21:39.883]                       while (!identical(envir, .GlobalEnv) && 
[10:21:39.883]                         !identical(envir, emptyenv())) {
[10:21:39.883]                         if (exists("master", mode = "list", envir = envir, 
[10:21:39.883]                           inherits = FALSE)) {
[10:21:39.883]                           master <- get("master", mode = "list", 
[10:21:39.883]                             envir = envir, inherits = FALSE)
[10:21:39.883]                           if (inherits(master, c("SOCKnode", 
[10:21:39.883]                             "SOCK0node"))) {
[10:21:39.883]                             sendCondition <<- function(cond) {
[10:21:39.883]                               data <- list(type = "VALUE", value = cond, 
[10:21:39.883]                                 success = TRUE)
[10:21:39.883]                               parallel_sendData(master, data)
[10:21:39.883]                             }
[10:21:39.883]                             return(sendCondition)
[10:21:39.883]                           }
[10:21:39.883]                         }
[10:21:39.883]                         frame <- frame + 1L
[10:21:39.883]                         envir <- sys.frame(frame)
[10:21:39.883]                       }
[10:21:39.883]                     }
[10:21:39.883]                     sendCondition <<- function(cond) NULL
[10:21:39.883]                   }
[10:21:39.883]                 })
[10:21:39.883]                 withCallingHandlers({
[10:21:39.883]                   {
[10:21:39.883]                     x <- list(b = 2)
[10:21:39.883]                     x$a <- 1
[10:21:39.883]                     x
[10:21:39.883]                   }
[10:21:39.883]                 }, immediateCondition = function(cond) {
[10:21:39.883]                   sendCondition <- ...future.makeSendCondition()
[10:21:39.883]                   sendCondition(cond)
[10:21:39.883]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:39.883]                   {
[10:21:39.883]                     inherits <- base::inherits
[10:21:39.883]                     invokeRestart <- base::invokeRestart
[10:21:39.883]                     is.null <- base::is.null
[10:21:39.883]                     muffled <- FALSE
[10:21:39.883]                     if (inherits(cond, "message")) {
[10:21:39.883]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:39.883]                       if (muffled) 
[10:21:39.883]                         invokeRestart("muffleMessage")
[10:21:39.883]                     }
[10:21:39.883]                     else if (inherits(cond, "warning")) {
[10:21:39.883]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:39.883]                       if (muffled) 
[10:21:39.883]                         invokeRestart("muffleWarning")
[10:21:39.883]                     }
[10:21:39.883]                     else if (inherits(cond, "condition")) {
[10:21:39.883]                       if (!is.null(pattern)) {
[10:21:39.883]                         computeRestarts <- base::computeRestarts
[10:21:39.883]                         grepl <- base::grepl
[10:21:39.883]                         restarts <- computeRestarts(cond)
[10:21:39.883]                         for (restart in restarts) {
[10:21:39.883]                           name <- restart$name
[10:21:39.883]                           if (is.null(name)) 
[10:21:39.883]                             next
[10:21:39.883]                           if (!grepl(pattern, name)) 
[10:21:39.883]                             next
[10:21:39.883]                           invokeRestart(restart)
[10:21:39.883]                           muffled <- TRUE
[10:21:39.883]                           break
[10:21:39.883]                         }
[10:21:39.883]                       }
[10:21:39.883]                     }
[10:21:39.883]                     invisible(muffled)
[10:21:39.883]                   }
[10:21:39.883]                   muffleCondition(cond)
[10:21:39.883]                 })
[10:21:39.883]             }))
[10:21:39.883]             future::FutureResult(value = ...future.value$value, 
[10:21:39.883]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:39.883]                   ...future.rng), globalenv = if (FALSE) 
[10:21:39.883]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:39.883]                     ...future.globalenv.names))
[10:21:39.883]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:39.883]         }, condition = base::local({
[10:21:39.883]             c <- base::c
[10:21:39.883]             inherits <- base::inherits
[10:21:39.883]             invokeRestart <- base::invokeRestart
[10:21:39.883]             length <- base::length
[10:21:39.883]             list <- base::list
[10:21:39.883]             seq.int <- base::seq.int
[10:21:39.883]             signalCondition <- base::signalCondition
[10:21:39.883]             sys.calls <- base::sys.calls
[10:21:39.883]             `[[` <- base::`[[`
[10:21:39.883]             `+` <- base::`+`
[10:21:39.883]             `<<-` <- base::`<<-`
[10:21:39.883]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:39.883]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:39.883]                   3L)]
[10:21:39.883]             }
[10:21:39.883]             function(cond) {
[10:21:39.883]                 is_error <- inherits(cond, "error")
[10:21:39.883]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:39.883]                   NULL)
[10:21:39.883]                 if (is_error) {
[10:21:39.883]                   sessionInformation <- function() {
[10:21:39.883]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:39.883]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:39.883]                       search = base::search(), system = base::Sys.info())
[10:21:39.883]                   }
[10:21:39.883]                   ...future.conditions[[length(...future.conditions) + 
[10:21:39.883]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:39.883]                     cond$call), session = sessionInformation(), 
[10:21:39.883]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:39.883]                   signalCondition(cond)
[10:21:39.883]                 }
[10:21:39.883]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:39.883]                 "immediateCondition"))) {
[10:21:39.883]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:39.883]                   ...future.conditions[[length(...future.conditions) + 
[10:21:39.883]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:39.883]                   if (TRUE && !signal) {
[10:21:39.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:39.883]                     {
[10:21:39.883]                       inherits <- base::inherits
[10:21:39.883]                       invokeRestart <- base::invokeRestart
[10:21:39.883]                       is.null <- base::is.null
[10:21:39.883]                       muffled <- FALSE
[10:21:39.883]                       if (inherits(cond, "message")) {
[10:21:39.883]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:39.883]                         if (muffled) 
[10:21:39.883]                           invokeRestart("muffleMessage")
[10:21:39.883]                       }
[10:21:39.883]                       else if (inherits(cond, "warning")) {
[10:21:39.883]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:39.883]                         if (muffled) 
[10:21:39.883]                           invokeRestart("muffleWarning")
[10:21:39.883]                       }
[10:21:39.883]                       else if (inherits(cond, "condition")) {
[10:21:39.883]                         if (!is.null(pattern)) {
[10:21:39.883]                           computeRestarts <- base::computeRestarts
[10:21:39.883]                           grepl <- base::grepl
[10:21:39.883]                           restarts <- computeRestarts(cond)
[10:21:39.883]                           for (restart in restarts) {
[10:21:39.883]                             name <- restart$name
[10:21:39.883]                             if (is.null(name)) 
[10:21:39.883]                               next
[10:21:39.883]                             if (!grepl(pattern, name)) 
[10:21:39.883]                               next
[10:21:39.883]                             invokeRestart(restart)
[10:21:39.883]                             muffled <- TRUE
[10:21:39.883]                             break
[10:21:39.883]                           }
[10:21:39.883]                         }
[10:21:39.883]                       }
[10:21:39.883]                       invisible(muffled)
[10:21:39.883]                     }
[10:21:39.883]                     muffleCondition(cond, pattern = "^muffle")
[10:21:39.883]                   }
[10:21:39.883]                 }
[10:21:39.883]                 else {
[10:21:39.883]                   if (TRUE) {
[10:21:39.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:39.883]                     {
[10:21:39.883]                       inherits <- base::inherits
[10:21:39.883]                       invokeRestart <- base::invokeRestart
[10:21:39.883]                       is.null <- base::is.null
[10:21:39.883]                       muffled <- FALSE
[10:21:39.883]                       if (inherits(cond, "message")) {
[10:21:39.883]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:39.883]                         if (muffled) 
[10:21:39.883]                           invokeRestart("muffleMessage")
[10:21:39.883]                       }
[10:21:39.883]                       else if (inherits(cond, "warning")) {
[10:21:39.883]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:39.883]                         if (muffled) 
[10:21:39.883]                           invokeRestart("muffleWarning")
[10:21:39.883]                       }
[10:21:39.883]                       else if (inherits(cond, "condition")) {
[10:21:39.883]                         if (!is.null(pattern)) {
[10:21:39.883]                           computeRestarts <- base::computeRestarts
[10:21:39.883]                           grepl <- base::grepl
[10:21:39.883]                           restarts <- computeRestarts(cond)
[10:21:39.883]                           for (restart in restarts) {
[10:21:39.883]                             name <- restart$name
[10:21:39.883]                             if (is.null(name)) 
[10:21:39.883]                               next
[10:21:39.883]                             if (!grepl(pattern, name)) 
[10:21:39.883]                               next
[10:21:39.883]                             invokeRestart(restart)
[10:21:39.883]                             muffled <- TRUE
[10:21:39.883]                             break
[10:21:39.883]                           }
[10:21:39.883]                         }
[10:21:39.883]                       }
[10:21:39.883]                       invisible(muffled)
[10:21:39.883]                     }
[10:21:39.883]                     muffleCondition(cond, pattern = "^muffle")
[10:21:39.883]                   }
[10:21:39.883]                 }
[10:21:39.883]             }
[10:21:39.883]         }))
[10:21:39.883]     }, error = function(ex) {
[10:21:39.883]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:39.883]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:39.883]                 ...future.rng), started = ...future.startTime, 
[10:21:39.883]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:39.883]             version = "1.8"), class = "FutureResult")
[10:21:39.883]     }, finally = {
[10:21:39.883]         if (!identical(...future.workdir, getwd())) 
[10:21:39.883]             setwd(...future.workdir)
[10:21:39.883]         {
[10:21:39.883]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:39.883]                 ...future.oldOptions$nwarnings <- NULL
[10:21:39.883]             }
[10:21:39.883]             base::options(...future.oldOptions)
[10:21:39.883]             if (.Platform$OS.type == "windows") {
[10:21:39.883]                 old_names <- names(...future.oldEnvVars)
[10:21:39.883]                 envs <- base::Sys.getenv()
[10:21:39.883]                 names <- names(envs)
[10:21:39.883]                 common <- intersect(names, old_names)
[10:21:39.883]                 added <- setdiff(names, old_names)
[10:21:39.883]                 removed <- setdiff(old_names, names)
[10:21:39.883]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:39.883]                   envs[common]]
[10:21:39.883]                 NAMES <- toupper(changed)
[10:21:39.883]                 args <- list()
[10:21:39.883]                 for (kk in seq_along(NAMES)) {
[10:21:39.883]                   name <- changed[[kk]]
[10:21:39.883]                   NAME <- NAMES[[kk]]
[10:21:39.883]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:39.883]                     next
[10:21:39.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:39.883]                 }
[10:21:39.883]                 NAMES <- toupper(added)
[10:21:39.883]                 for (kk in seq_along(NAMES)) {
[10:21:39.883]                   name <- added[[kk]]
[10:21:39.883]                   NAME <- NAMES[[kk]]
[10:21:39.883]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:39.883]                     next
[10:21:39.883]                   args[[name]] <- ""
[10:21:39.883]                 }
[10:21:39.883]                 NAMES <- toupper(removed)
[10:21:39.883]                 for (kk in seq_along(NAMES)) {
[10:21:39.883]                   name <- removed[[kk]]
[10:21:39.883]                   NAME <- NAMES[[kk]]
[10:21:39.883]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:39.883]                     next
[10:21:39.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:39.883]                 }
[10:21:39.883]                 if (length(args) > 0) 
[10:21:39.883]                   base::do.call(base::Sys.setenv, args = args)
[10:21:39.883]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:39.883]             }
[10:21:39.883]             else {
[10:21:39.883]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:39.883]             }
[10:21:39.883]             {
[10:21:39.883]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:39.883]                   0L) {
[10:21:39.883]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:39.883]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:39.883]                   base::options(opts)
[10:21:39.883]                 }
[10:21:39.883]                 {
[10:21:39.883]                   {
[10:21:39.883]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:39.883]                     NULL
[10:21:39.883]                   }
[10:21:39.883]                   options(future.plan = NULL)
[10:21:39.883]                   if (is.na(NA_character_)) 
[10:21:39.883]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:39.883]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:39.883]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:39.883]                     .init = FALSE)
[10:21:39.883]                 }
[10:21:39.883]             }
[10:21:39.883]         }
[10:21:39.883]     })
[10:21:39.883]     if (TRUE) {
[10:21:39.883]         base::sink(type = "output", split = FALSE)
[10:21:39.883]         if (TRUE) {
[10:21:39.883]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:39.883]         }
[10:21:39.883]         else {
[10:21:39.883]             ...future.result["stdout"] <- base::list(NULL)
[10:21:39.883]         }
[10:21:39.883]         base::close(...future.stdout)
[10:21:39.883]         ...future.stdout <- NULL
[10:21:39.883]     }
[10:21:39.883]     ...future.result$conditions <- ...future.conditions
[10:21:39.883]     ...future.result$finished <- base::Sys.time()
[10:21:39.883]     ...future.result
[10:21:39.883] }
[10:21:39.886] MultisessionFuture started
[10:21:39.886] - Launch lazy future ... done
[10:21:39.886] run() for ‘MultisessionFuture’ ... done
[10:21:39.887] result() for ClusterFuture ...
[10:21:39.887] receiveMessageFromWorker() for ClusterFuture ...
[10:21:39.887] - Validating connection of MultisessionFuture
[10:21:39.928] - received message: FutureResult
[10:21:39.928] - Received FutureResult
[10:21:39.929] - Erased future from FutureRegistry
[10:21:39.929] result() for ClusterFuture ...
[10:21:39.929] - result already collected: FutureResult
[10:21:39.929] result() for ClusterFuture ... done
[10:21:39.929] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:39.929] result() for ClusterFuture ... done
[10:21:39.929] result() for ClusterFuture ...
[10:21:39.929] - result already collected: FutureResult
[10:21:39.929] result() for ClusterFuture ... done
$b
[1] 2

$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:39.930] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:39.930] Searching for globals...
[10:21:39.932] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:21:39.932] Searching for globals ... DONE
[10:21:39.932] Resolving globals: TRUE
[10:21:39.932] Resolving any globals that are futures ...
[10:21:39.932] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:21:39.932] Resolving any globals that are futures ... DONE
[10:21:39.933] Resolving futures part of globals (recursively) ...
[10:21:39.933] resolve() on list ...
[10:21:39.933]  recursive: 99
[10:21:39.933]  length: 1
[10:21:39.933]  elements: ‘x’
[10:21:39.933]  length: 0 (resolved future 1)
[10:21:39.933] resolve() on list ... DONE
[10:21:39.933] - globals: [1] ‘x’
[10:21:39.933] Resolving futures part of globals (recursively) ... DONE
[10:21:39.934] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:39.934] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:39.934] - globals: [1] ‘x’
[10:21:39.934] 
[10:21:39.934] getGlobalsAndPackages() ... DONE
[10:21:39.935] run() for ‘Future’ ...
[10:21:39.935] - state: ‘created’
[10:21:39.935] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:39.949] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:39.949] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:39.949]   - Field: ‘node’
[10:21:39.949]   - Field: ‘label’
[10:21:39.949]   - Field: ‘local’
[10:21:39.950]   - Field: ‘owner’
[10:21:39.950]   - Field: ‘envir’
[10:21:39.950]   - Field: ‘workers’
[10:21:39.950]   - Field: ‘packages’
[10:21:39.950]   - Field: ‘gc’
[10:21:39.950]   - Field: ‘conditions’
[10:21:39.950]   - Field: ‘persistent’
[10:21:39.950]   - Field: ‘expr’
[10:21:39.950]   - Field: ‘uuid’
[10:21:39.950]   - Field: ‘seed’
[10:21:39.950]   - Field: ‘version’
[10:21:39.950]   - Field: ‘result’
[10:21:39.951]   - Field: ‘asynchronous’
[10:21:39.951]   - Field: ‘calls’
[10:21:39.951]   - Field: ‘globals’
[10:21:39.951]   - Field: ‘stdout’
[10:21:39.951]   - Field: ‘earlySignal’
[10:21:39.951]   - Field: ‘lazy’
[10:21:39.951]   - Field: ‘state’
[10:21:39.951] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:39.951] - Launch lazy future ...
[10:21:39.951] Packages needed by the future expression (n = 0): <none>
[10:21:39.952] Packages needed by future strategies (n = 0): <none>
[10:21:39.952] {
[10:21:39.952]     {
[10:21:39.952]         {
[10:21:39.952]             ...future.startTime <- base::Sys.time()
[10:21:39.952]             {
[10:21:39.952]                 {
[10:21:39.952]                   {
[10:21:39.952]                     {
[10:21:39.952]                       base::local({
[10:21:39.952]                         has_future <- base::requireNamespace("future", 
[10:21:39.952]                           quietly = TRUE)
[10:21:39.952]                         if (has_future) {
[10:21:39.952]                           ns <- base::getNamespace("future")
[10:21:39.952]                           version <- ns[[".package"]][["version"]]
[10:21:39.952]                           if (is.null(version)) 
[10:21:39.952]                             version <- utils::packageVersion("future")
[10:21:39.952]                         }
[10:21:39.952]                         else {
[10:21:39.952]                           version <- NULL
[10:21:39.952]                         }
[10:21:39.952]                         if (!has_future || version < "1.8.0") {
[10:21:39.952]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:39.952]                             "", base::R.version$version.string), 
[10:21:39.952]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:39.952]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:39.952]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:39.952]                               "release", "version")], collapse = " "), 
[10:21:39.952]                             hostname = base::Sys.info()[["nodename"]])
[10:21:39.952]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:39.952]                             info)
[10:21:39.952]                           info <- base::paste(info, collapse = "; ")
[10:21:39.952]                           if (!has_future) {
[10:21:39.952]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:39.952]                               info)
[10:21:39.952]                           }
[10:21:39.952]                           else {
[10:21:39.952]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:39.952]                               info, version)
[10:21:39.952]                           }
[10:21:39.952]                           base::stop(msg)
[10:21:39.952]                         }
[10:21:39.952]                       })
[10:21:39.952]                     }
[10:21:39.952]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:39.952]                     base::options(mc.cores = 1L)
[10:21:39.952]                   }
[10:21:39.952]                   ...future.strategy.old <- future::plan("list")
[10:21:39.952]                   options(future.plan = NULL)
[10:21:39.952]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:39.952]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:39.952]                 }
[10:21:39.952]                 ...future.workdir <- getwd()
[10:21:39.952]             }
[10:21:39.952]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:39.952]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:39.952]         }
[10:21:39.952]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:39.952]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:39.952]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:39.952]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:39.952]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:39.952]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:39.952]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:39.952]             base::names(...future.oldOptions))
[10:21:39.952]     }
[10:21:39.952]     if (FALSE) {
[10:21:39.952]     }
[10:21:39.952]     else {
[10:21:39.952]         if (TRUE) {
[10:21:39.952]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:39.952]                 open = "w")
[10:21:39.952]         }
[10:21:39.952]         else {
[10:21:39.952]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:39.952]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:39.952]         }
[10:21:39.952]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:39.952]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:39.952]             base::sink(type = "output", split = FALSE)
[10:21:39.952]             base::close(...future.stdout)
[10:21:39.952]         }, add = TRUE)
[10:21:39.952]     }
[10:21:39.952]     ...future.frame <- base::sys.nframe()
[10:21:39.952]     ...future.conditions <- base::list()
[10:21:39.952]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:39.952]     if (FALSE) {
[10:21:39.952]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:39.952]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:39.952]     }
[10:21:39.952]     ...future.result <- base::tryCatch({
[10:21:39.952]         base::withCallingHandlers({
[10:21:39.952]             ...future.value <- base::withVisible(base::local({
[10:21:39.952]                 ...future.makeSendCondition <- base::local({
[10:21:39.952]                   sendCondition <- NULL
[10:21:39.952]                   function(frame = 1L) {
[10:21:39.952]                     if (is.function(sendCondition)) 
[10:21:39.952]                       return(sendCondition)
[10:21:39.952]                     ns <- getNamespace("parallel")
[10:21:39.952]                     if (exists("sendData", mode = "function", 
[10:21:39.952]                       envir = ns)) {
[10:21:39.952]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:39.952]                         envir = ns)
[10:21:39.952]                       envir <- sys.frame(frame)
[10:21:39.952]                       master <- NULL
[10:21:39.952]                       while (!identical(envir, .GlobalEnv) && 
[10:21:39.952]                         !identical(envir, emptyenv())) {
[10:21:39.952]                         if (exists("master", mode = "list", envir = envir, 
[10:21:39.952]                           inherits = FALSE)) {
[10:21:39.952]                           master <- get("master", mode = "list", 
[10:21:39.952]                             envir = envir, inherits = FALSE)
[10:21:39.952]                           if (inherits(master, c("SOCKnode", 
[10:21:39.952]                             "SOCK0node"))) {
[10:21:39.952]                             sendCondition <<- function(cond) {
[10:21:39.952]                               data <- list(type = "VALUE", value = cond, 
[10:21:39.952]                                 success = TRUE)
[10:21:39.952]                               parallel_sendData(master, data)
[10:21:39.952]                             }
[10:21:39.952]                             return(sendCondition)
[10:21:39.952]                           }
[10:21:39.952]                         }
[10:21:39.952]                         frame <- frame + 1L
[10:21:39.952]                         envir <- sys.frame(frame)
[10:21:39.952]                       }
[10:21:39.952]                     }
[10:21:39.952]                     sendCondition <<- function(cond) NULL
[10:21:39.952]                   }
[10:21:39.952]                 })
[10:21:39.952]                 withCallingHandlers({
[10:21:39.952]                   {
[10:21:39.952]                     x[["a"]] <- 1
[10:21:39.952]                     x
[10:21:39.952]                   }
[10:21:39.952]                 }, immediateCondition = function(cond) {
[10:21:39.952]                   sendCondition <- ...future.makeSendCondition()
[10:21:39.952]                   sendCondition(cond)
[10:21:39.952]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:39.952]                   {
[10:21:39.952]                     inherits <- base::inherits
[10:21:39.952]                     invokeRestart <- base::invokeRestart
[10:21:39.952]                     is.null <- base::is.null
[10:21:39.952]                     muffled <- FALSE
[10:21:39.952]                     if (inherits(cond, "message")) {
[10:21:39.952]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:39.952]                       if (muffled) 
[10:21:39.952]                         invokeRestart("muffleMessage")
[10:21:39.952]                     }
[10:21:39.952]                     else if (inherits(cond, "warning")) {
[10:21:39.952]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:39.952]                       if (muffled) 
[10:21:39.952]                         invokeRestart("muffleWarning")
[10:21:39.952]                     }
[10:21:39.952]                     else if (inherits(cond, "condition")) {
[10:21:39.952]                       if (!is.null(pattern)) {
[10:21:39.952]                         computeRestarts <- base::computeRestarts
[10:21:39.952]                         grepl <- base::grepl
[10:21:39.952]                         restarts <- computeRestarts(cond)
[10:21:39.952]                         for (restart in restarts) {
[10:21:39.952]                           name <- restart$name
[10:21:39.952]                           if (is.null(name)) 
[10:21:39.952]                             next
[10:21:39.952]                           if (!grepl(pattern, name)) 
[10:21:39.952]                             next
[10:21:39.952]                           invokeRestart(restart)
[10:21:39.952]                           muffled <- TRUE
[10:21:39.952]                           break
[10:21:39.952]                         }
[10:21:39.952]                       }
[10:21:39.952]                     }
[10:21:39.952]                     invisible(muffled)
[10:21:39.952]                   }
[10:21:39.952]                   muffleCondition(cond)
[10:21:39.952]                 })
[10:21:39.952]             }))
[10:21:39.952]             future::FutureResult(value = ...future.value$value, 
[10:21:39.952]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:39.952]                   ...future.rng), globalenv = if (FALSE) 
[10:21:39.952]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:39.952]                     ...future.globalenv.names))
[10:21:39.952]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:39.952]         }, condition = base::local({
[10:21:39.952]             c <- base::c
[10:21:39.952]             inherits <- base::inherits
[10:21:39.952]             invokeRestart <- base::invokeRestart
[10:21:39.952]             length <- base::length
[10:21:39.952]             list <- base::list
[10:21:39.952]             seq.int <- base::seq.int
[10:21:39.952]             signalCondition <- base::signalCondition
[10:21:39.952]             sys.calls <- base::sys.calls
[10:21:39.952]             `[[` <- base::`[[`
[10:21:39.952]             `+` <- base::`+`
[10:21:39.952]             `<<-` <- base::`<<-`
[10:21:39.952]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:39.952]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:39.952]                   3L)]
[10:21:39.952]             }
[10:21:39.952]             function(cond) {
[10:21:39.952]                 is_error <- inherits(cond, "error")
[10:21:39.952]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:39.952]                   NULL)
[10:21:39.952]                 if (is_error) {
[10:21:39.952]                   sessionInformation <- function() {
[10:21:39.952]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:39.952]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:39.952]                       search = base::search(), system = base::Sys.info())
[10:21:39.952]                   }
[10:21:39.952]                   ...future.conditions[[length(...future.conditions) + 
[10:21:39.952]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:39.952]                     cond$call), session = sessionInformation(), 
[10:21:39.952]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:39.952]                   signalCondition(cond)
[10:21:39.952]                 }
[10:21:39.952]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:39.952]                 "immediateCondition"))) {
[10:21:39.952]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:39.952]                   ...future.conditions[[length(...future.conditions) + 
[10:21:39.952]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:39.952]                   if (TRUE && !signal) {
[10:21:39.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:39.952]                     {
[10:21:39.952]                       inherits <- base::inherits
[10:21:39.952]                       invokeRestart <- base::invokeRestart
[10:21:39.952]                       is.null <- base::is.null
[10:21:39.952]                       muffled <- FALSE
[10:21:39.952]                       if (inherits(cond, "message")) {
[10:21:39.952]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:39.952]                         if (muffled) 
[10:21:39.952]                           invokeRestart("muffleMessage")
[10:21:39.952]                       }
[10:21:39.952]                       else if (inherits(cond, "warning")) {
[10:21:39.952]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:39.952]                         if (muffled) 
[10:21:39.952]                           invokeRestart("muffleWarning")
[10:21:39.952]                       }
[10:21:39.952]                       else if (inherits(cond, "condition")) {
[10:21:39.952]                         if (!is.null(pattern)) {
[10:21:39.952]                           computeRestarts <- base::computeRestarts
[10:21:39.952]                           grepl <- base::grepl
[10:21:39.952]                           restarts <- computeRestarts(cond)
[10:21:39.952]                           for (restart in restarts) {
[10:21:39.952]                             name <- restart$name
[10:21:39.952]                             if (is.null(name)) 
[10:21:39.952]                               next
[10:21:39.952]                             if (!grepl(pattern, name)) 
[10:21:39.952]                               next
[10:21:39.952]                             invokeRestart(restart)
[10:21:39.952]                             muffled <- TRUE
[10:21:39.952]                             break
[10:21:39.952]                           }
[10:21:39.952]                         }
[10:21:39.952]                       }
[10:21:39.952]                       invisible(muffled)
[10:21:39.952]                     }
[10:21:39.952]                     muffleCondition(cond, pattern = "^muffle")
[10:21:39.952]                   }
[10:21:39.952]                 }
[10:21:39.952]                 else {
[10:21:39.952]                   if (TRUE) {
[10:21:39.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:39.952]                     {
[10:21:39.952]                       inherits <- base::inherits
[10:21:39.952]                       invokeRestart <- base::invokeRestart
[10:21:39.952]                       is.null <- base::is.null
[10:21:39.952]                       muffled <- FALSE
[10:21:39.952]                       if (inherits(cond, "message")) {
[10:21:39.952]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:39.952]                         if (muffled) 
[10:21:39.952]                           invokeRestart("muffleMessage")
[10:21:39.952]                       }
[10:21:39.952]                       else if (inherits(cond, "warning")) {
[10:21:39.952]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:39.952]                         if (muffled) 
[10:21:39.952]                           invokeRestart("muffleWarning")
[10:21:39.952]                       }
[10:21:39.952]                       else if (inherits(cond, "condition")) {
[10:21:39.952]                         if (!is.null(pattern)) {
[10:21:39.952]                           computeRestarts <- base::computeRestarts
[10:21:39.952]                           grepl <- base::grepl
[10:21:39.952]                           restarts <- computeRestarts(cond)
[10:21:39.952]                           for (restart in restarts) {
[10:21:39.952]                             name <- restart$name
[10:21:39.952]                             if (is.null(name)) 
[10:21:39.952]                               next
[10:21:39.952]                             if (!grepl(pattern, name)) 
[10:21:39.952]                               next
[10:21:39.952]                             invokeRestart(restart)
[10:21:39.952]                             muffled <- TRUE
[10:21:39.952]                             break
[10:21:39.952]                           }
[10:21:39.952]                         }
[10:21:39.952]                       }
[10:21:39.952]                       invisible(muffled)
[10:21:39.952]                     }
[10:21:39.952]                     muffleCondition(cond, pattern = "^muffle")
[10:21:39.952]                   }
[10:21:39.952]                 }
[10:21:39.952]             }
[10:21:39.952]         }))
[10:21:39.952]     }, error = function(ex) {
[10:21:39.952]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:39.952]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:39.952]                 ...future.rng), started = ...future.startTime, 
[10:21:39.952]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:39.952]             version = "1.8"), class = "FutureResult")
[10:21:39.952]     }, finally = {
[10:21:39.952]         if (!identical(...future.workdir, getwd())) 
[10:21:39.952]             setwd(...future.workdir)
[10:21:39.952]         {
[10:21:39.952]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:39.952]                 ...future.oldOptions$nwarnings <- NULL
[10:21:39.952]             }
[10:21:39.952]             base::options(...future.oldOptions)
[10:21:39.952]             if (.Platform$OS.type == "windows") {
[10:21:39.952]                 old_names <- names(...future.oldEnvVars)
[10:21:39.952]                 envs <- base::Sys.getenv()
[10:21:39.952]                 names <- names(envs)
[10:21:39.952]                 common <- intersect(names, old_names)
[10:21:39.952]                 added <- setdiff(names, old_names)
[10:21:39.952]                 removed <- setdiff(old_names, names)
[10:21:39.952]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:39.952]                   envs[common]]
[10:21:39.952]                 NAMES <- toupper(changed)
[10:21:39.952]                 args <- list()
[10:21:39.952]                 for (kk in seq_along(NAMES)) {
[10:21:39.952]                   name <- changed[[kk]]
[10:21:39.952]                   NAME <- NAMES[[kk]]
[10:21:39.952]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:39.952]                     next
[10:21:39.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:39.952]                 }
[10:21:39.952]                 NAMES <- toupper(added)
[10:21:39.952]                 for (kk in seq_along(NAMES)) {
[10:21:39.952]                   name <- added[[kk]]
[10:21:39.952]                   NAME <- NAMES[[kk]]
[10:21:39.952]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:39.952]                     next
[10:21:39.952]                   args[[name]] <- ""
[10:21:39.952]                 }
[10:21:39.952]                 NAMES <- toupper(removed)
[10:21:39.952]                 for (kk in seq_along(NAMES)) {
[10:21:39.952]                   name <- removed[[kk]]
[10:21:39.952]                   NAME <- NAMES[[kk]]
[10:21:39.952]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:39.952]                     next
[10:21:39.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:39.952]                 }
[10:21:39.952]                 if (length(args) > 0) 
[10:21:39.952]                   base::do.call(base::Sys.setenv, args = args)
[10:21:39.952]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:39.952]             }
[10:21:39.952]             else {
[10:21:39.952]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:39.952]             }
[10:21:39.952]             {
[10:21:39.952]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:39.952]                   0L) {
[10:21:39.952]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:39.952]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:39.952]                   base::options(opts)
[10:21:39.952]                 }
[10:21:39.952]                 {
[10:21:39.952]                   {
[10:21:39.952]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:39.952]                     NULL
[10:21:39.952]                   }
[10:21:39.952]                   options(future.plan = NULL)
[10:21:39.952]                   if (is.na(NA_character_)) 
[10:21:39.952]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:39.952]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:39.952]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:39.952]                     .init = FALSE)
[10:21:39.952]                 }
[10:21:39.952]             }
[10:21:39.952]         }
[10:21:39.952]     })
[10:21:39.952]     if (TRUE) {
[10:21:39.952]         base::sink(type = "output", split = FALSE)
[10:21:39.952]         if (TRUE) {
[10:21:39.952]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:39.952]         }
[10:21:39.952]         else {
[10:21:39.952]             ...future.result["stdout"] <- base::list(NULL)
[10:21:39.952]         }
[10:21:39.952]         base::close(...future.stdout)
[10:21:39.952]         ...future.stdout <- NULL
[10:21:39.952]     }
[10:21:39.952]     ...future.result$conditions <- ...future.conditions
[10:21:39.952]     ...future.result$finished <- base::Sys.time()
[10:21:39.952]     ...future.result
[10:21:39.952] }
[10:21:39.955] Exporting 1 global objects (338 bytes) to cluster node #1 ...
[10:21:39.955] Exporting ‘x’ (31 bytes) to cluster node #1 ...
[10:21:39.955] Exporting ‘x’ (31 bytes) to cluster node #1 ... DONE
[10:21:39.955] Exporting 1 global objects (338 bytes) to cluster node #1 ... DONE
[10:21:39.956] MultisessionFuture started
[10:21:39.956] - Launch lazy future ... done
[10:21:39.956] run() for ‘MultisessionFuture’ ... done
[10:21:39.956] result() for ClusterFuture ...
[10:21:39.956] receiveMessageFromWorker() for ClusterFuture ...
[10:21:39.956] - Validating connection of MultisessionFuture
[10:21:39.998] - received message: FutureResult
[10:21:39.999] - Received FutureResult
[10:21:39.999] - Erased future from FutureRegistry
[10:21:39.999] result() for ClusterFuture ...
[10:21:39.999] - result already collected: FutureResult
[10:21:39.999] result() for ClusterFuture ... done
[10:21:39.999] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:39.999] result() for ClusterFuture ... done
[10:21:39.999] result() for ClusterFuture ...
[10:21:39.999] - result already collected: FutureResult
[10:21:39.999] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:40.000] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:40.000] Searching for globals...
[10:21:40.002] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:21:40.002] Searching for globals ... DONE
[10:21:40.002] Resolving globals: TRUE
[10:21:40.002] Resolving any globals that are futures ...
[10:21:40.002] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:21:40.002] Resolving any globals that are futures ... DONE
[10:21:40.003] Resolving futures part of globals (recursively) ...
[10:21:40.003] resolve() on list ...
[10:21:40.003]  recursive: 99
[10:21:40.003]  length: 1
[10:21:40.003]  elements: ‘x’
[10:21:40.003]  length: 0 (resolved future 1)
[10:21:40.004] resolve() on list ... DONE
[10:21:40.004] - globals: [1] ‘x’
[10:21:40.004] Resolving futures part of globals (recursively) ... DONE
[10:21:40.004] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:40.004] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:40.004] - globals: [1] ‘x’
[10:21:40.004] 
[10:21:40.005] getGlobalsAndPackages() ... DONE
[10:21:40.005] run() for ‘Future’ ...
[10:21:40.005] - state: ‘created’
[10:21:40.005] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:40.019] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:40.019] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:40.019]   - Field: ‘node’
[10:21:40.019]   - Field: ‘label’
[10:21:40.019]   - Field: ‘local’
[10:21:40.020]   - Field: ‘owner’
[10:21:40.020]   - Field: ‘envir’
[10:21:40.020]   - Field: ‘workers’
[10:21:40.020]   - Field: ‘packages’
[10:21:40.020]   - Field: ‘gc’
[10:21:40.020]   - Field: ‘conditions’
[10:21:40.020]   - Field: ‘persistent’
[10:21:40.020]   - Field: ‘expr’
[10:21:40.020]   - Field: ‘uuid’
[10:21:40.020]   - Field: ‘seed’
[10:21:40.020]   - Field: ‘version’
[10:21:40.020]   - Field: ‘result’
[10:21:40.021]   - Field: ‘asynchronous’
[10:21:40.021]   - Field: ‘calls’
[10:21:40.021]   - Field: ‘globals’
[10:21:40.021]   - Field: ‘stdout’
[10:21:40.021]   - Field: ‘earlySignal’
[10:21:40.021]   - Field: ‘lazy’
[10:21:40.021]   - Field: ‘state’
[10:21:40.021] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:40.021] - Launch lazy future ...
[10:21:40.021] Packages needed by the future expression (n = 0): <none>
[10:21:40.022] Packages needed by future strategies (n = 0): <none>
[10:21:40.022] {
[10:21:40.022]     {
[10:21:40.022]         {
[10:21:40.022]             ...future.startTime <- base::Sys.time()
[10:21:40.022]             {
[10:21:40.022]                 {
[10:21:40.022]                   {
[10:21:40.022]                     {
[10:21:40.022]                       base::local({
[10:21:40.022]                         has_future <- base::requireNamespace("future", 
[10:21:40.022]                           quietly = TRUE)
[10:21:40.022]                         if (has_future) {
[10:21:40.022]                           ns <- base::getNamespace("future")
[10:21:40.022]                           version <- ns[[".package"]][["version"]]
[10:21:40.022]                           if (is.null(version)) 
[10:21:40.022]                             version <- utils::packageVersion("future")
[10:21:40.022]                         }
[10:21:40.022]                         else {
[10:21:40.022]                           version <- NULL
[10:21:40.022]                         }
[10:21:40.022]                         if (!has_future || version < "1.8.0") {
[10:21:40.022]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:40.022]                             "", base::R.version$version.string), 
[10:21:40.022]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:40.022]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:40.022]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:40.022]                               "release", "version")], collapse = " "), 
[10:21:40.022]                             hostname = base::Sys.info()[["nodename"]])
[10:21:40.022]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:40.022]                             info)
[10:21:40.022]                           info <- base::paste(info, collapse = "; ")
[10:21:40.022]                           if (!has_future) {
[10:21:40.022]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:40.022]                               info)
[10:21:40.022]                           }
[10:21:40.022]                           else {
[10:21:40.022]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:40.022]                               info, version)
[10:21:40.022]                           }
[10:21:40.022]                           base::stop(msg)
[10:21:40.022]                         }
[10:21:40.022]                       })
[10:21:40.022]                     }
[10:21:40.022]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:40.022]                     base::options(mc.cores = 1L)
[10:21:40.022]                   }
[10:21:40.022]                   ...future.strategy.old <- future::plan("list")
[10:21:40.022]                   options(future.plan = NULL)
[10:21:40.022]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:40.022]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:40.022]                 }
[10:21:40.022]                 ...future.workdir <- getwd()
[10:21:40.022]             }
[10:21:40.022]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:40.022]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:40.022]         }
[10:21:40.022]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:40.022]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:40.022]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:40.022]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:40.022]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:40.022]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:40.022]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:40.022]             base::names(...future.oldOptions))
[10:21:40.022]     }
[10:21:40.022]     if (FALSE) {
[10:21:40.022]     }
[10:21:40.022]     else {
[10:21:40.022]         if (TRUE) {
[10:21:40.022]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:40.022]                 open = "w")
[10:21:40.022]         }
[10:21:40.022]         else {
[10:21:40.022]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:40.022]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:40.022]         }
[10:21:40.022]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:40.022]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:40.022]             base::sink(type = "output", split = FALSE)
[10:21:40.022]             base::close(...future.stdout)
[10:21:40.022]         }, add = TRUE)
[10:21:40.022]     }
[10:21:40.022]     ...future.frame <- base::sys.nframe()
[10:21:40.022]     ...future.conditions <- base::list()
[10:21:40.022]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:40.022]     if (FALSE) {
[10:21:40.022]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:40.022]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:40.022]     }
[10:21:40.022]     ...future.result <- base::tryCatch({
[10:21:40.022]         base::withCallingHandlers({
[10:21:40.022]             ...future.value <- base::withVisible(base::local({
[10:21:40.022]                 ...future.makeSendCondition <- base::local({
[10:21:40.022]                   sendCondition <- NULL
[10:21:40.022]                   function(frame = 1L) {
[10:21:40.022]                     if (is.function(sendCondition)) 
[10:21:40.022]                       return(sendCondition)
[10:21:40.022]                     ns <- getNamespace("parallel")
[10:21:40.022]                     if (exists("sendData", mode = "function", 
[10:21:40.022]                       envir = ns)) {
[10:21:40.022]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:40.022]                         envir = ns)
[10:21:40.022]                       envir <- sys.frame(frame)
[10:21:40.022]                       master <- NULL
[10:21:40.022]                       while (!identical(envir, .GlobalEnv) && 
[10:21:40.022]                         !identical(envir, emptyenv())) {
[10:21:40.022]                         if (exists("master", mode = "list", envir = envir, 
[10:21:40.022]                           inherits = FALSE)) {
[10:21:40.022]                           master <- get("master", mode = "list", 
[10:21:40.022]                             envir = envir, inherits = FALSE)
[10:21:40.022]                           if (inherits(master, c("SOCKnode", 
[10:21:40.022]                             "SOCK0node"))) {
[10:21:40.022]                             sendCondition <<- function(cond) {
[10:21:40.022]                               data <- list(type = "VALUE", value = cond, 
[10:21:40.022]                                 success = TRUE)
[10:21:40.022]                               parallel_sendData(master, data)
[10:21:40.022]                             }
[10:21:40.022]                             return(sendCondition)
[10:21:40.022]                           }
[10:21:40.022]                         }
[10:21:40.022]                         frame <- frame + 1L
[10:21:40.022]                         envir <- sys.frame(frame)
[10:21:40.022]                       }
[10:21:40.022]                     }
[10:21:40.022]                     sendCondition <<- function(cond) NULL
[10:21:40.022]                   }
[10:21:40.022]                 })
[10:21:40.022]                 withCallingHandlers({
[10:21:40.022]                   {
[10:21:40.022]                     x[["a"]] <- 1
[10:21:40.022]                     x
[10:21:40.022]                   }
[10:21:40.022]                 }, immediateCondition = function(cond) {
[10:21:40.022]                   sendCondition <- ...future.makeSendCondition()
[10:21:40.022]                   sendCondition(cond)
[10:21:40.022]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:40.022]                   {
[10:21:40.022]                     inherits <- base::inherits
[10:21:40.022]                     invokeRestart <- base::invokeRestart
[10:21:40.022]                     is.null <- base::is.null
[10:21:40.022]                     muffled <- FALSE
[10:21:40.022]                     if (inherits(cond, "message")) {
[10:21:40.022]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:40.022]                       if (muffled) 
[10:21:40.022]                         invokeRestart("muffleMessage")
[10:21:40.022]                     }
[10:21:40.022]                     else if (inherits(cond, "warning")) {
[10:21:40.022]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:40.022]                       if (muffled) 
[10:21:40.022]                         invokeRestart("muffleWarning")
[10:21:40.022]                     }
[10:21:40.022]                     else if (inherits(cond, "condition")) {
[10:21:40.022]                       if (!is.null(pattern)) {
[10:21:40.022]                         computeRestarts <- base::computeRestarts
[10:21:40.022]                         grepl <- base::grepl
[10:21:40.022]                         restarts <- computeRestarts(cond)
[10:21:40.022]                         for (restart in restarts) {
[10:21:40.022]                           name <- restart$name
[10:21:40.022]                           if (is.null(name)) 
[10:21:40.022]                             next
[10:21:40.022]                           if (!grepl(pattern, name)) 
[10:21:40.022]                             next
[10:21:40.022]                           invokeRestart(restart)
[10:21:40.022]                           muffled <- TRUE
[10:21:40.022]                           break
[10:21:40.022]                         }
[10:21:40.022]                       }
[10:21:40.022]                     }
[10:21:40.022]                     invisible(muffled)
[10:21:40.022]                   }
[10:21:40.022]                   muffleCondition(cond)
[10:21:40.022]                 })
[10:21:40.022]             }))
[10:21:40.022]             future::FutureResult(value = ...future.value$value, 
[10:21:40.022]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:40.022]                   ...future.rng), globalenv = if (FALSE) 
[10:21:40.022]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:40.022]                     ...future.globalenv.names))
[10:21:40.022]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:40.022]         }, condition = base::local({
[10:21:40.022]             c <- base::c
[10:21:40.022]             inherits <- base::inherits
[10:21:40.022]             invokeRestart <- base::invokeRestart
[10:21:40.022]             length <- base::length
[10:21:40.022]             list <- base::list
[10:21:40.022]             seq.int <- base::seq.int
[10:21:40.022]             signalCondition <- base::signalCondition
[10:21:40.022]             sys.calls <- base::sys.calls
[10:21:40.022]             `[[` <- base::`[[`
[10:21:40.022]             `+` <- base::`+`
[10:21:40.022]             `<<-` <- base::`<<-`
[10:21:40.022]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:40.022]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:40.022]                   3L)]
[10:21:40.022]             }
[10:21:40.022]             function(cond) {
[10:21:40.022]                 is_error <- inherits(cond, "error")
[10:21:40.022]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:40.022]                   NULL)
[10:21:40.022]                 if (is_error) {
[10:21:40.022]                   sessionInformation <- function() {
[10:21:40.022]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:40.022]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:40.022]                       search = base::search(), system = base::Sys.info())
[10:21:40.022]                   }
[10:21:40.022]                   ...future.conditions[[length(...future.conditions) + 
[10:21:40.022]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:40.022]                     cond$call), session = sessionInformation(), 
[10:21:40.022]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:40.022]                   signalCondition(cond)
[10:21:40.022]                 }
[10:21:40.022]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:40.022]                 "immediateCondition"))) {
[10:21:40.022]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:40.022]                   ...future.conditions[[length(...future.conditions) + 
[10:21:40.022]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:40.022]                   if (TRUE && !signal) {
[10:21:40.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:40.022]                     {
[10:21:40.022]                       inherits <- base::inherits
[10:21:40.022]                       invokeRestart <- base::invokeRestart
[10:21:40.022]                       is.null <- base::is.null
[10:21:40.022]                       muffled <- FALSE
[10:21:40.022]                       if (inherits(cond, "message")) {
[10:21:40.022]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:40.022]                         if (muffled) 
[10:21:40.022]                           invokeRestart("muffleMessage")
[10:21:40.022]                       }
[10:21:40.022]                       else if (inherits(cond, "warning")) {
[10:21:40.022]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:40.022]                         if (muffled) 
[10:21:40.022]                           invokeRestart("muffleWarning")
[10:21:40.022]                       }
[10:21:40.022]                       else if (inherits(cond, "condition")) {
[10:21:40.022]                         if (!is.null(pattern)) {
[10:21:40.022]                           computeRestarts <- base::computeRestarts
[10:21:40.022]                           grepl <- base::grepl
[10:21:40.022]                           restarts <- computeRestarts(cond)
[10:21:40.022]                           for (restart in restarts) {
[10:21:40.022]                             name <- restart$name
[10:21:40.022]                             if (is.null(name)) 
[10:21:40.022]                               next
[10:21:40.022]                             if (!grepl(pattern, name)) 
[10:21:40.022]                               next
[10:21:40.022]                             invokeRestart(restart)
[10:21:40.022]                             muffled <- TRUE
[10:21:40.022]                             break
[10:21:40.022]                           }
[10:21:40.022]                         }
[10:21:40.022]                       }
[10:21:40.022]                       invisible(muffled)
[10:21:40.022]                     }
[10:21:40.022]                     muffleCondition(cond, pattern = "^muffle")
[10:21:40.022]                   }
[10:21:40.022]                 }
[10:21:40.022]                 else {
[10:21:40.022]                   if (TRUE) {
[10:21:40.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:40.022]                     {
[10:21:40.022]                       inherits <- base::inherits
[10:21:40.022]                       invokeRestart <- base::invokeRestart
[10:21:40.022]                       is.null <- base::is.null
[10:21:40.022]                       muffled <- FALSE
[10:21:40.022]                       if (inherits(cond, "message")) {
[10:21:40.022]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:40.022]                         if (muffled) 
[10:21:40.022]                           invokeRestart("muffleMessage")
[10:21:40.022]                       }
[10:21:40.022]                       else if (inherits(cond, "warning")) {
[10:21:40.022]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:40.022]                         if (muffled) 
[10:21:40.022]                           invokeRestart("muffleWarning")
[10:21:40.022]                       }
[10:21:40.022]                       else if (inherits(cond, "condition")) {
[10:21:40.022]                         if (!is.null(pattern)) {
[10:21:40.022]                           computeRestarts <- base::computeRestarts
[10:21:40.022]                           grepl <- base::grepl
[10:21:40.022]                           restarts <- computeRestarts(cond)
[10:21:40.022]                           for (restart in restarts) {
[10:21:40.022]                             name <- restart$name
[10:21:40.022]                             if (is.null(name)) 
[10:21:40.022]                               next
[10:21:40.022]                             if (!grepl(pattern, name)) 
[10:21:40.022]                               next
[10:21:40.022]                             invokeRestart(restart)
[10:21:40.022]                             muffled <- TRUE
[10:21:40.022]                             break
[10:21:40.022]                           }
[10:21:40.022]                         }
[10:21:40.022]                       }
[10:21:40.022]                       invisible(muffled)
[10:21:40.022]                     }
[10:21:40.022]                     muffleCondition(cond, pattern = "^muffle")
[10:21:40.022]                   }
[10:21:40.022]                 }
[10:21:40.022]             }
[10:21:40.022]         }))
[10:21:40.022]     }, error = function(ex) {
[10:21:40.022]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:40.022]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:40.022]                 ...future.rng), started = ...future.startTime, 
[10:21:40.022]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:40.022]             version = "1.8"), class = "FutureResult")
[10:21:40.022]     }, finally = {
[10:21:40.022]         if (!identical(...future.workdir, getwd())) 
[10:21:40.022]             setwd(...future.workdir)
[10:21:40.022]         {
[10:21:40.022]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:40.022]                 ...future.oldOptions$nwarnings <- NULL
[10:21:40.022]             }
[10:21:40.022]             base::options(...future.oldOptions)
[10:21:40.022]             if (.Platform$OS.type == "windows") {
[10:21:40.022]                 old_names <- names(...future.oldEnvVars)
[10:21:40.022]                 envs <- base::Sys.getenv()
[10:21:40.022]                 names <- names(envs)
[10:21:40.022]                 common <- intersect(names, old_names)
[10:21:40.022]                 added <- setdiff(names, old_names)
[10:21:40.022]                 removed <- setdiff(old_names, names)
[10:21:40.022]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:40.022]                   envs[common]]
[10:21:40.022]                 NAMES <- toupper(changed)
[10:21:40.022]                 args <- list()
[10:21:40.022]                 for (kk in seq_along(NAMES)) {
[10:21:40.022]                   name <- changed[[kk]]
[10:21:40.022]                   NAME <- NAMES[[kk]]
[10:21:40.022]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:40.022]                     next
[10:21:40.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:40.022]                 }
[10:21:40.022]                 NAMES <- toupper(added)
[10:21:40.022]                 for (kk in seq_along(NAMES)) {
[10:21:40.022]                   name <- added[[kk]]
[10:21:40.022]                   NAME <- NAMES[[kk]]
[10:21:40.022]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:40.022]                     next
[10:21:40.022]                   args[[name]] <- ""
[10:21:40.022]                 }
[10:21:40.022]                 NAMES <- toupper(removed)
[10:21:40.022]                 for (kk in seq_along(NAMES)) {
[10:21:40.022]                   name <- removed[[kk]]
[10:21:40.022]                   NAME <- NAMES[[kk]]
[10:21:40.022]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:40.022]                     next
[10:21:40.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:40.022]                 }
[10:21:40.022]                 if (length(args) > 0) 
[10:21:40.022]                   base::do.call(base::Sys.setenv, args = args)
[10:21:40.022]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:40.022]             }
[10:21:40.022]             else {
[10:21:40.022]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:40.022]             }
[10:21:40.022]             {
[10:21:40.022]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:40.022]                   0L) {
[10:21:40.022]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:40.022]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:40.022]                   base::options(opts)
[10:21:40.022]                 }
[10:21:40.022]                 {
[10:21:40.022]                   {
[10:21:40.022]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:40.022]                     NULL
[10:21:40.022]                   }
[10:21:40.022]                   options(future.plan = NULL)
[10:21:40.022]                   if (is.na(NA_character_)) 
[10:21:40.022]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:40.022]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:40.022]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:40.022]                     .init = FALSE)
[10:21:40.022]                 }
[10:21:40.022]             }
[10:21:40.022]         }
[10:21:40.022]     })
[10:21:40.022]     if (TRUE) {
[10:21:40.022]         base::sink(type = "output", split = FALSE)
[10:21:40.022]         if (TRUE) {
[10:21:40.022]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:40.022]         }
[10:21:40.022]         else {
[10:21:40.022]             ...future.result["stdout"] <- base::list(NULL)
[10:21:40.022]         }
[10:21:40.022]         base::close(...future.stdout)
[10:21:40.022]         ...future.stdout <- NULL
[10:21:40.022]     }
[10:21:40.022]     ...future.result$conditions <- ...future.conditions
[10:21:40.022]     ...future.result$finished <- base::Sys.time()
[10:21:40.022]     ...future.result
[10:21:40.022] }
[10:21:40.025] Exporting 1 global objects (338 bytes) to cluster node #1 ...
[10:21:40.025] Exporting ‘x’ (31 bytes) to cluster node #1 ...
[10:21:40.025] Exporting ‘x’ (31 bytes) to cluster node #1 ... DONE
[10:21:40.025] Exporting 1 global objects (338 bytes) to cluster node #1 ... DONE
[10:21:40.026] MultisessionFuture started
[10:21:40.026] - Launch lazy future ... done
[10:21:40.026] run() for ‘MultisessionFuture’ ... done
[10:21:40.026] result() for ClusterFuture ...
[10:21:40.026] receiveMessageFromWorker() for ClusterFuture ...
[10:21:40.026] - Validating connection of MultisessionFuture
[10:21:40.068] - received message: FutureResult
[10:21:40.069] - Received FutureResult
[10:21:40.069] - Erased future from FutureRegistry
[10:21:40.069] result() for ClusterFuture ...
[10:21:40.069] - result already collected: FutureResult
[10:21:40.069] result() for ClusterFuture ... done
[10:21:40.069] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:40.069] result() for ClusterFuture ... done
[10:21:40.069] result() for ClusterFuture ...
[10:21:40.070] - result already collected: FutureResult
[10:21:40.070] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:40.070] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:40.070] Searching for globals...
[10:21:40.072] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:21:40.073] Searching for globals ... DONE
[10:21:40.073] Resolving globals: TRUE
[10:21:40.073] Resolving any globals that are futures ...
[10:21:40.073] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[10:21:40.073] Resolving any globals that are futures ... DONE
[10:21:40.073] Resolving futures part of globals (recursively) ...
[10:21:40.074] resolve() on list ...
[10:21:40.074]  recursive: 99
[10:21:40.074]  length: 1
[10:21:40.074]  elements: ‘x’
[10:21:40.074]  length: 0 (resolved future 1)
[10:21:40.074] resolve() on list ... DONE
[10:21:40.074] - globals: [1] ‘x’
[10:21:40.074] Resolving futures part of globals (recursively) ... DONE
[10:21:40.074] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:40.075] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:40.075] - globals: [1] ‘x’
[10:21:40.075] 
[10:21:40.075] getGlobalsAndPackages() ... DONE
[10:21:40.075] run() for ‘Future’ ...
[10:21:40.075] - state: ‘created’
[10:21:40.076] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:40.090] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:40.090] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:40.090]   - Field: ‘node’
[10:21:40.090]   - Field: ‘label’
[10:21:40.090]   - Field: ‘local’
[10:21:40.090]   - Field: ‘owner’
[10:21:40.090]   - Field: ‘envir’
[10:21:40.090]   - Field: ‘workers’
[10:21:40.090]   - Field: ‘packages’
[10:21:40.091]   - Field: ‘gc’
[10:21:40.091]   - Field: ‘conditions’
[10:21:40.091]   - Field: ‘persistent’
[10:21:40.091]   - Field: ‘expr’
[10:21:40.091]   - Field: ‘uuid’
[10:21:40.091]   - Field: ‘seed’
[10:21:40.091]   - Field: ‘version’
[10:21:40.091]   - Field: ‘result’
[10:21:40.091]   - Field: ‘asynchronous’
[10:21:40.091]   - Field: ‘calls’
[10:21:40.091]   - Field: ‘globals’
[10:21:40.092]   - Field: ‘stdout’
[10:21:40.092]   - Field: ‘earlySignal’
[10:21:40.092]   - Field: ‘lazy’
[10:21:40.092]   - Field: ‘state’
[10:21:40.092] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:40.092] - Launch lazy future ...
[10:21:40.092] Packages needed by the future expression (n = 0): <none>
[10:21:40.092] Packages needed by future strategies (n = 0): <none>
[10:21:40.093] {
[10:21:40.093]     {
[10:21:40.093]         {
[10:21:40.093]             ...future.startTime <- base::Sys.time()
[10:21:40.093]             {
[10:21:40.093]                 {
[10:21:40.093]                   {
[10:21:40.093]                     {
[10:21:40.093]                       base::local({
[10:21:40.093]                         has_future <- base::requireNamespace("future", 
[10:21:40.093]                           quietly = TRUE)
[10:21:40.093]                         if (has_future) {
[10:21:40.093]                           ns <- base::getNamespace("future")
[10:21:40.093]                           version <- ns[[".package"]][["version"]]
[10:21:40.093]                           if (is.null(version)) 
[10:21:40.093]                             version <- utils::packageVersion("future")
[10:21:40.093]                         }
[10:21:40.093]                         else {
[10:21:40.093]                           version <- NULL
[10:21:40.093]                         }
[10:21:40.093]                         if (!has_future || version < "1.8.0") {
[10:21:40.093]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:40.093]                             "", base::R.version$version.string), 
[10:21:40.093]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:40.093]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:40.093]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:40.093]                               "release", "version")], collapse = " "), 
[10:21:40.093]                             hostname = base::Sys.info()[["nodename"]])
[10:21:40.093]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:40.093]                             info)
[10:21:40.093]                           info <- base::paste(info, collapse = "; ")
[10:21:40.093]                           if (!has_future) {
[10:21:40.093]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:40.093]                               info)
[10:21:40.093]                           }
[10:21:40.093]                           else {
[10:21:40.093]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:40.093]                               info, version)
[10:21:40.093]                           }
[10:21:40.093]                           base::stop(msg)
[10:21:40.093]                         }
[10:21:40.093]                       })
[10:21:40.093]                     }
[10:21:40.093]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:40.093]                     base::options(mc.cores = 1L)
[10:21:40.093]                   }
[10:21:40.093]                   ...future.strategy.old <- future::plan("list")
[10:21:40.093]                   options(future.plan = NULL)
[10:21:40.093]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:40.093]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:40.093]                 }
[10:21:40.093]                 ...future.workdir <- getwd()
[10:21:40.093]             }
[10:21:40.093]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:40.093]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:40.093]         }
[10:21:40.093]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:40.093]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:40.093]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:40.093]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:40.093]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:40.093]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:40.093]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:40.093]             base::names(...future.oldOptions))
[10:21:40.093]     }
[10:21:40.093]     if (FALSE) {
[10:21:40.093]     }
[10:21:40.093]     else {
[10:21:40.093]         if (TRUE) {
[10:21:40.093]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:40.093]                 open = "w")
[10:21:40.093]         }
[10:21:40.093]         else {
[10:21:40.093]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:40.093]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:40.093]         }
[10:21:40.093]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:40.093]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:40.093]             base::sink(type = "output", split = FALSE)
[10:21:40.093]             base::close(...future.stdout)
[10:21:40.093]         }, add = TRUE)
[10:21:40.093]     }
[10:21:40.093]     ...future.frame <- base::sys.nframe()
[10:21:40.093]     ...future.conditions <- base::list()
[10:21:40.093]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:40.093]     if (FALSE) {
[10:21:40.093]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:40.093]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:40.093]     }
[10:21:40.093]     ...future.result <- base::tryCatch({
[10:21:40.093]         base::withCallingHandlers({
[10:21:40.093]             ...future.value <- base::withVisible(base::local({
[10:21:40.093]                 ...future.makeSendCondition <- base::local({
[10:21:40.093]                   sendCondition <- NULL
[10:21:40.093]                   function(frame = 1L) {
[10:21:40.093]                     if (is.function(sendCondition)) 
[10:21:40.093]                       return(sendCondition)
[10:21:40.093]                     ns <- getNamespace("parallel")
[10:21:40.093]                     if (exists("sendData", mode = "function", 
[10:21:40.093]                       envir = ns)) {
[10:21:40.093]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:40.093]                         envir = ns)
[10:21:40.093]                       envir <- sys.frame(frame)
[10:21:40.093]                       master <- NULL
[10:21:40.093]                       while (!identical(envir, .GlobalEnv) && 
[10:21:40.093]                         !identical(envir, emptyenv())) {
[10:21:40.093]                         if (exists("master", mode = "list", envir = envir, 
[10:21:40.093]                           inherits = FALSE)) {
[10:21:40.093]                           master <- get("master", mode = "list", 
[10:21:40.093]                             envir = envir, inherits = FALSE)
[10:21:40.093]                           if (inherits(master, c("SOCKnode", 
[10:21:40.093]                             "SOCK0node"))) {
[10:21:40.093]                             sendCondition <<- function(cond) {
[10:21:40.093]                               data <- list(type = "VALUE", value = cond, 
[10:21:40.093]                                 success = TRUE)
[10:21:40.093]                               parallel_sendData(master, data)
[10:21:40.093]                             }
[10:21:40.093]                             return(sendCondition)
[10:21:40.093]                           }
[10:21:40.093]                         }
[10:21:40.093]                         frame <- frame + 1L
[10:21:40.093]                         envir <- sys.frame(frame)
[10:21:40.093]                       }
[10:21:40.093]                     }
[10:21:40.093]                     sendCondition <<- function(cond) NULL
[10:21:40.093]                   }
[10:21:40.093]                 })
[10:21:40.093]                 withCallingHandlers({
[10:21:40.093]                   {
[10:21:40.093]                     x[["a"]] <- 1
[10:21:40.093]                     x
[10:21:40.093]                   }
[10:21:40.093]                 }, immediateCondition = function(cond) {
[10:21:40.093]                   sendCondition <- ...future.makeSendCondition()
[10:21:40.093]                   sendCondition(cond)
[10:21:40.093]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:40.093]                   {
[10:21:40.093]                     inherits <- base::inherits
[10:21:40.093]                     invokeRestart <- base::invokeRestart
[10:21:40.093]                     is.null <- base::is.null
[10:21:40.093]                     muffled <- FALSE
[10:21:40.093]                     if (inherits(cond, "message")) {
[10:21:40.093]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:40.093]                       if (muffled) 
[10:21:40.093]                         invokeRestart("muffleMessage")
[10:21:40.093]                     }
[10:21:40.093]                     else if (inherits(cond, "warning")) {
[10:21:40.093]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:40.093]                       if (muffled) 
[10:21:40.093]                         invokeRestart("muffleWarning")
[10:21:40.093]                     }
[10:21:40.093]                     else if (inherits(cond, "condition")) {
[10:21:40.093]                       if (!is.null(pattern)) {
[10:21:40.093]                         computeRestarts <- base::computeRestarts
[10:21:40.093]                         grepl <- base::grepl
[10:21:40.093]                         restarts <- computeRestarts(cond)
[10:21:40.093]                         for (restart in restarts) {
[10:21:40.093]                           name <- restart$name
[10:21:40.093]                           if (is.null(name)) 
[10:21:40.093]                             next
[10:21:40.093]                           if (!grepl(pattern, name)) 
[10:21:40.093]                             next
[10:21:40.093]                           invokeRestart(restart)
[10:21:40.093]                           muffled <- TRUE
[10:21:40.093]                           break
[10:21:40.093]                         }
[10:21:40.093]                       }
[10:21:40.093]                     }
[10:21:40.093]                     invisible(muffled)
[10:21:40.093]                   }
[10:21:40.093]                   muffleCondition(cond)
[10:21:40.093]                 })
[10:21:40.093]             }))
[10:21:40.093]             future::FutureResult(value = ...future.value$value, 
[10:21:40.093]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:40.093]                   ...future.rng), globalenv = if (FALSE) 
[10:21:40.093]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:40.093]                     ...future.globalenv.names))
[10:21:40.093]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:40.093]         }, condition = base::local({
[10:21:40.093]             c <- base::c
[10:21:40.093]             inherits <- base::inherits
[10:21:40.093]             invokeRestart <- base::invokeRestart
[10:21:40.093]             length <- base::length
[10:21:40.093]             list <- base::list
[10:21:40.093]             seq.int <- base::seq.int
[10:21:40.093]             signalCondition <- base::signalCondition
[10:21:40.093]             sys.calls <- base::sys.calls
[10:21:40.093]             `[[` <- base::`[[`
[10:21:40.093]             `+` <- base::`+`
[10:21:40.093]             `<<-` <- base::`<<-`
[10:21:40.093]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:40.093]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:40.093]                   3L)]
[10:21:40.093]             }
[10:21:40.093]             function(cond) {
[10:21:40.093]                 is_error <- inherits(cond, "error")
[10:21:40.093]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:40.093]                   NULL)
[10:21:40.093]                 if (is_error) {
[10:21:40.093]                   sessionInformation <- function() {
[10:21:40.093]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:40.093]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:40.093]                       search = base::search(), system = base::Sys.info())
[10:21:40.093]                   }
[10:21:40.093]                   ...future.conditions[[length(...future.conditions) + 
[10:21:40.093]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:40.093]                     cond$call), session = sessionInformation(), 
[10:21:40.093]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:40.093]                   signalCondition(cond)
[10:21:40.093]                 }
[10:21:40.093]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:40.093]                 "immediateCondition"))) {
[10:21:40.093]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:40.093]                   ...future.conditions[[length(...future.conditions) + 
[10:21:40.093]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:40.093]                   if (TRUE && !signal) {
[10:21:40.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:40.093]                     {
[10:21:40.093]                       inherits <- base::inherits
[10:21:40.093]                       invokeRestart <- base::invokeRestart
[10:21:40.093]                       is.null <- base::is.null
[10:21:40.093]                       muffled <- FALSE
[10:21:40.093]                       if (inherits(cond, "message")) {
[10:21:40.093]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:40.093]                         if (muffled) 
[10:21:40.093]                           invokeRestart("muffleMessage")
[10:21:40.093]                       }
[10:21:40.093]                       else if (inherits(cond, "warning")) {
[10:21:40.093]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:40.093]                         if (muffled) 
[10:21:40.093]                           invokeRestart("muffleWarning")
[10:21:40.093]                       }
[10:21:40.093]                       else if (inherits(cond, "condition")) {
[10:21:40.093]                         if (!is.null(pattern)) {
[10:21:40.093]                           computeRestarts <- base::computeRestarts
[10:21:40.093]                           grepl <- base::grepl
[10:21:40.093]                           restarts <- computeRestarts(cond)
[10:21:40.093]                           for (restart in restarts) {
[10:21:40.093]                             name <- restart$name
[10:21:40.093]                             if (is.null(name)) 
[10:21:40.093]                               next
[10:21:40.093]                             if (!grepl(pattern, name)) 
[10:21:40.093]                               next
[10:21:40.093]                             invokeRestart(restart)
[10:21:40.093]                             muffled <- TRUE
[10:21:40.093]                             break
[10:21:40.093]                           }
[10:21:40.093]                         }
[10:21:40.093]                       }
[10:21:40.093]                       invisible(muffled)
[10:21:40.093]                     }
[10:21:40.093]                     muffleCondition(cond, pattern = "^muffle")
[10:21:40.093]                   }
[10:21:40.093]                 }
[10:21:40.093]                 else {
[10:21:40.093]                   if (TRUE) {
[10:21:40.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:40.093]                     {
[10:21:40.093]                       inherits <- base::inherits
[10:21:40.093]                       invokeRestart <- base::invokeRestart
[10:21:40.093]                       is.null <- base::is.null
[10:21:40.093]                       muffled <- FALSE
[10:21:40.093]                       if (inherits(cond, "message")) {
[10:21:40.093]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:40.093]                         if (muffled) 
[10:21:40.093]                           invokeRestart("muffleMessage")
[10:21:40.093]                       }
[10:21:40.093]                       else if (inherits(cond, "warning")) {
[10:21:40.093]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:40.093]                         if (muffled) 
[10:21:40.093]                           invokeRestart("muffleWarning")
[10:21:40.093]                       }
[10:21:40.093]                       else if (inherits(cond, "condition")) {
[10:21:40.093]                         if (!is.null(pattern)) {
[10:21:40.093]                           computeRestarts <- base::computeRestarts
[10:21:40.093]                           grepl <- base::grepl
[10:21:40.093]                           restarts <- computeRestarts(cond)
[10:21:40.093]                           for (restart in restarts) {
[10:21:40.093]                             name <- restart$name
[10:21:40.093]                             if (is.null(name)) 
[10:21:40.093]                               next
[10:21:40.093]                             if (!grepl(pattern, name)) 
[10:21:40.093]                               next
[10:21:40.093]                             invokeRestart(restart)
[10:21:40.093]                             muffled <- TRUE
[10:21:40.093]                             break
[10:21:40.093]                           }
[10:21:40.093]                         }
[10:21:40.093]                       }
[10:21:40.093]                       invisible(muffled)
[10:21:40.093]                     }
[10:21:40.093]                     muffleCondition(cond, pattern = "^muffle")
[10:21:40.093]                   }
[10:21:40.093]                 }
[10:21:40.093]             }
[10:21:40.093]         }))
[10:21:40.093]     }, error = function(ex) {
[10:21:40.093]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:40.093]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:40.093]                 ...future.rng), started = ...future.startTime, 
[10:21:40.093]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:40.093]             version = "1.8"), class = "FutureResult")
[10:21:40.093]     }, finally = {
[10:21:40.093]         if (!identical(...future.workdir, getwd())) 
[10:21:40.093]             setwd(...future.workdir)
[10:21:40.093]         {
[10:21:40.093]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:40.093]                 ...future.oldOptions$nwarnings <- NULL
[10:21:40.093]             }
[10:21:40.093]             base::options(...future.oldOptions)
[10:21:40.093]             if (.Platform$OS.type == "windows") {
[10:21:40.093]                 old_names <- names(...future.oldEnvVars)
[10:21:40.093]                 envs <- base::Sys.getenv()
[10:21:40.093]                 names <- names(envs)
[10:21:40.093]                 common <- intersect(names, old_names)
[10:21:40.093]                 added <- setdiff(names, old_names)
[10:21:40.093]                 removed <- setdiff(old_names, names)
[10:21:40.093]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:40.093]                   envs[common]]
[10:21:40.093]                 NAMES <- toupper(changed)
[10:21:40.093]                 args <- list()
[10:21:40.093]                 for (kk in seq_along(NAMES)) {
[10:21:40.093]                   name <- changed[[kk]]
[10:21:40.093]                   NAME <- NAMES[[kk]]
[10:21:40.093]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:40.093]                     next
[10:21:40.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:40.093]                 }
[10:21:40.093]                 NAMES <- toupper(added)
[10:21:40.093]                 for (kk in seq_along(NAMES)) {
[10:21:40.093]                   name <- added[[kk]]
[10:21:40.093]                   NAME <- NAMES[[kk]]
[10:21:40.093]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:40.093]                     next
[10:21:40.093]                   args[[name]] <- ""
[10:21:40.093]                 }
[10:21:40.093]                 NAMES <- toupper(removed)
[10:21:40.093]                 for (kk in seq_along(NAMES)) {
[10:21:40.093]                   name <- removed[[kk]]
[10:21:40.093]                   NAME <- NAMES[[kk]]
[10:21:40.093]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:40.093]                     next
[10:21:40.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:40.093]                 }
[10:21:40.093]                 if (length(args) > 0) 
[10:21:40.093]                   base::do.call(base::Sys.setenv, args = args)
[10:21:40.093]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:40.093]             }
[10:21:40.093]             else {
[10:21:40.093]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:40.093]             }
[10:21:40.093]             {
[10:21:40.093]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:40.093]                   0L) {
[10:21:40.093]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:40.093]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:40.093]                   base::options(opts)
[10:21:40.093]                 }
[10:21:40.093]                 {
[10:21:40.093]                   {
[10:21:40.093]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:40.093]                     NULL
[10:21:40.093]                   }
[10:21:40.093]                   options(future.plan = NULL)
[10:21:40.093]                   if (is.na(NA_character_)) 
[10:21:40.093]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:40.093]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:40.093]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:40.093]                     .init = FALSE)
[10:21:40.093]                 }
[10:21:40.093]             }
[10:21:40.093]         }
[10:21:40.093]     })
[10:21:40.093]     if (TRUE) {
[10:21:40.093]         base::sink(type = "output", split = FALSE)
[10:21:40.093]         if (TRUE) {
[10:21:40.093]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:40.093]         }
[10:21:40.093]         else {
[10:21:40.093]             ...future.result["stdout"] <- base::list(NULL)
[10:21:40.093]         }
[10:21:40.093]         base::close(...future.stdout)
[10:21:40.093]         ...future.stdout <- NULL
[10:21:40.093]     }
[10:21:40.093]     ...future.result$conditions <- ...future.conditions
[10:21:40.093]     ...future.result$finished <- base::Sys.time()
[10:21:40.093]     ...future.result
[10:21:40.093] }
[10:21:40.096] Exporting 1 global objects (338 bytes) to cluster node #1 ...
[10:21:40.096] Exporting ‘x’ (31 bytes) to cluster node #1 ...
[10:21:40.096] Exporting ‘x’ (31 bytes) to cluster node #1 ... DONE
[10:21:40.096] Exporting 1 global objects (338 bytes) to cluster node #1 ... DONE
[10:21:40.097] MultisessionFuture started
[10:21:40.097] - Launch lazy future ... done
[10:21:40.097] run() for ‘MultisessionFuture’ ... done
[10:21:40.097] result() for ClusterFuture ...
[10:21:40.097] receiveMessageFromWorker() for ClusterFuture ...
[10:21:40.098] - Validating connection of MultisessionFuture
[10:21:40.139] - received message: FutureResult
[10:21:40.139] - Received FutureResult
[10:21:40.140] - Erased future from FutureRegistry
[10:21:40.140] result() for ClusterFuture ...
[10:21:40.140] - result already collected: FutureResult
[10:21:40.140] result() for ClusterFuture ... done
[10:21:40.140] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:40.140] result() for ClusterFuture ... done
[10:21:40.140] result() for ClusterFuture ...
[10:21:40.140] - result already collected: FutureResult
[10:21:40.140] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:40.141] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:40.141] Searching for globals...
[10:21:40.143] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:21:40.143] Searching for globals ... DONE
[10:21:40.143] Resolving globals: TRUE
[10:21:40.143] Resolving any globals that are futures ...
[10:21:40.143] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:21:40.144] Resolving any globals that are futures ... DONE
[10:21:40.144] Resolving futures part of globals (recursively) ...
[10:21:40.144] resolve() on list ...
[10:21:40.144]  recursive: 99
[10:21:40.144]  length: 1
[10:21:40.144]  elements: ‘x’
[10:21:40.145]  length: 0 (resolved future 1)
[10:21:40.145] resolve() on list ... DONE
[10:21:40.145] - globals: [1] ‘x’
[10:21:40.145] Resolving futures part of globals (recursively) ... DONE
[10:21:40.145] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:40.145] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:40.145] - globals: [1] ‘x’
[10:21:40.146] 
[10:21:40.146] getGlobalsAndPackages() ... DONE
[10:21:40.146] run() for ‘Future’ ...
[10:21:40.146] - state: ‘created’
[10:21:40.146] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:40.160] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:40.160] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:40.160]   - Field: ‘node’
[10:21:40.160]   - Field: ‘label’
[10:21:40.160]   - Field: ‘local’
[10:21:40.161]   - Field: ‘owner’
[10:21:40.161]   - Field: ‘envir’
[10:21:40.161]   - Field: ‘workers’
[10:21:40.161]   - Field: ‘packages’
[10:21:40.161]   - Field: ‘gc’
[10:21:40.161]   - Field: ‘conditions’
[10:21:40.161]   - Field: ‘persistent’
[10:21:40.161]   - Field: ‘expr’
[10:21:40.161]   - Field: ‘uuid’
[10:21:40.161]   - Field: ‘seed’
[10:21:40.161]   - Field: ‘version’
[10:21:40.161]   - Field: ‘result’
[10:21:40.162]   - Field: ‘asynchronous’
[10:21:40.162]   - Field: ‘calls’
[10:21:40.162]   - Field: ‘globals’
[10:21:40.162]   - Field: ‘stdout’
[10:21:40.162]   - Field: ‘earlySignal’
[10:21:40.162]   - Field: ‘lazy’
[10:21:40.162]   - Field: ‘state’
[10:21:40.162] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:40.162] - Launch lazy future ...
[10:21:40.163] Packages needed by the future expression (n = 0): <none>
[10:21:40.163] Packages needed by future strategies (n = 0): <none>
[10:21:40.163] {
[10:21:40.163]     {
[10:21:40.163]         {
[10:21:40.163]             ...future.startTime <- base::Sys.time()
[10:21:40.163]             {
[10:21:40.163]                 {
[10:21:40.163]                   {
[10:21:40.163]                     {
[10:21:40.163]                       base::local({
[10:21:40.163]                         has_future <- base::requireNamespace("future", 
[10:21:40.163]                           quietly = TRUE)
[10:21:40.163]                         if (has_future) {
[10:21:40.163]                           ns <- base::getNamespace("future")
[10:21:40.163]                           version <- ns[[".package"]][["version"]]
[10:21:40.163]                           if (is.null(version)) 
[10:21:40.163]                             version <- utils::packageVersion("future")
[10:21:40.163]                         }
[10:21:40.163]                         else {
[10:21:40.163]                           version <- NULL
[10:21:40.163]                         }
[10:21:40.163]                         if (!has_future || version < "1.8.0") {
[10:21:40.163]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:40.163]                             "", base::R.version$version.string), 
[10:21:40.163]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:40.163]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:40.163]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:40.163]                               "release", "version")], collapse = " "), 
[10:21:40.163]                             hostname = base::Sys.info()[["nodename"]])
[10:21:40.163]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:40.163]                             info)
[10:21:40.163]                           info <- base::paste(info, collapse = "; ")
[10:21:40.163]                           if (!has_future) {
[10:21:40.163]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:40.163]                               info)
[10:21:40.163]                           }
[10:21:40.163]                           else {
[10:21:40.163]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:40.163]                               info, version)
[10:21:40.163]                           }
[10:21:40.163]                           base::stop(msg)
[10:21:40.163]                         }
[10:21:40.163]                       })
[10:21:40.163]                     }
[10:21:40.163]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:40.163]                     base::options(mc.cores = 1L)
[10:21:40.163]                   }
[10:21:40.163]                   ...future.strategy.old <- future::plan("list")
[10:21:40.163]                   options(future.plan = NULL)
[10:21:40.163]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:40.163]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:40.163]                 }
[10:21:40.163]                 ...future.workdir <- getwd()
[10:21:40.163]             }
[10:21:40.163]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:40.163]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:40.163]         }
[10:21:40.163]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:40.163]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:40.163]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:40.163]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:40.163]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:40.163]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:40.163]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:40.163]             base::names(...future.oldOptions))
[10:21:40.163]     }
[10:21:40.163]     if (FALSE) {
[10:21:40.163]     }
[10:21:40.163]     else {
[10:21:40.163]         if (TRUE) {
[10:21:40.163]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:40.163]                 open = "w")
[10:21:40.163]         }
[10:21:40.163]         else {
[10:21:40.163]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:40.163]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:40.163]         }
[10:21:40.163]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:40.163]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:40.163]             base::sink(type = "output", split = FALSE)
[10:21:40.163]             base::close(...future.stdout)
[10:21:40.163]         }, add = TRUE)
[10:21:40.163]     }
[10:21:40.163]     ...future.frame <- base::sys.nframe()
[10:21:40.163]     ...future.conditions <- base::list()
[10:21:40.163]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:40.163]     if (FALSE) {
[10:21:40.163]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:40.163]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:40.163]     }
[10:21:40.163]     ...future.result <- base::tryCatch({
[10:21:40.163]         base::withCallingHandlers({
[10:21:40.163]             ...future.value <- base::withVisible(base::local({
[10:21:40.163]                 ...future.makeSendCondition <- base::local({
[10:21:40.163]                   sendCondition <- NULL
[10:21:40.163]                   function(frame = 1L) {
[10:21:40.163]                     if (is.function(sendCondition)) 
[10:21:40.163]                       return(sendCondition)
[10:21:40.163]                     ns <- getNamespace("parallel")
[10:21:40.163]                     if (exists("sendData", mode = "function", 
[10:21:40.163]                       envir = ns)) {
[10:21:40.163]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:40.163]                         envir = ns)
[10:21:40.163]                       envir <- sys.frame(frame)
[10:21:40.163]                       master <- NULL
[10:21:40.163]                       while (!identical(envir, .GlobalEnv) && 
[10:21:40.163]                         !identical(envir, emptyenv())) {
[10:21:40.163]                         if (exists("master", mode = "list", envir = envir, 
[10:21:40.163]                           inherits = FALSE)) {
[10:21:40.163]                           master <- get("master", mode = "list", 
[10:21:40.163]                             envir = envir, inherits = FALSE)
[10:21:40.163]                           if (inherits(master, c("SOCKnode", 
[10:21:40.163]                             "SOCK0node"))) {
[10:21:40.163]                             sendCondition <<- function(cond) {
[10:21:40.163]                               data <- list(type = "VALUE", value = cond, 
[10:21:40.163]                                 success = TRUE)
[10:21:40.163]                               parallel_sendData(master, data)
[10:21:40.163]                             }
[10:21:40.163]                             return(sendCondition)
[10:21:40.163]                           }
[10:21:40.163]                         }
[10:21:40.163]                         frame <- frame + 1L
[10:21:40.163]                         envir <- sys.frame(frame)
[10:21:40.163]                       }
[10:21:40.163]                     }
[10:21:40.163]                     sendCondition <<- function(cond) NULL
[10:21:40.163]                   }
[10:21:40.163]                 })
[10:21:40.163]                 withCallingHandlers({
[10:21:40.163]                   {
[10:21:40.163]                     x["a"] <- list(1)
[10:21:40.163]                     x
[10:21:40.163]                   }
[10:21:40.163]                 }, immediateCondition = function(cond) {
[10:21:40.163]                   sendCondition <- ...future.makeSendCondition()
[10:21:40.163]                   sendCondition(cond)
[10:21:40.163]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:40.163]                   {
[10:21:40.163]                     inherits <- base::inherits
[10:21:40.163]                     invokeRestart <- base::invokeRestart
[10:21:40.163]                     is.null <- base::is.null
[10:21:40.163]                     muffled <- FALSE
[10:21:40.163]                     if (inherits(cond, "message")) {
[10:21:40.163]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:40.163]                       if (muffled) 
[10:21:40.163]                         invokeRestart("muffleMessage")
[10:21:40.163]                     }
[10:21:40.163]                     else if (inherits(cond, "warning")) {
[10:21:40.163]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:40.163]                       if (muffled) 
[10:21:40.163]                         invokeRestart("muffleWarning")
[10:21:40.163]                     }
[10:21:40.163]                     else if (inherits(cond, "condition")) {
[10:21:40.163]                       if (!is.null(pattern)) {
[10:21:40.163]                         computeRestarts <- base::computeRestarts
[10:21:40.163]                         grepl <- base::grepl
[10:21:40.163]                         restarts <- computeRestarts(cond)
[10:21:40.163]                         for (restart in restarts) {
[10:21:40.163]                           name <- restart$name
[10:21:40.163]                           if (is.null(name)) 
[10:21:40.163]                             next
[10:21:40.163]                           if (!grepl(pattern, name)) 
[10:21:40.163]                             next
[10:21:40.163]                           invokeRestart(restart)
[10:21:40.163]                           muffled <- TRUE
[10:21:40.163]                           break
[10:21:40.163]                         }
[10:21:40.163]                       }
[10:21:40.163]                     }
[10:21:40.163]                     invisible(muffled)
[10:21:40.163]                   }
[10:21:40.163]                   muffleCondition(cond)
[10:21:40.163]                 })
[10:21:40.163]             }))
[10:21:40.163]             future::FutureResult(value = ...future.value$value, 
[10:21:40.163]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:40.163]                   ...future.rng), globalenv = if (FALSE) 
[10:21:40.163]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:40.163]                     ...future.globalenv.names))
[10:21:40.163]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:40.163]         }, condition = base::local({
[10:21:40.163]             c <- base::c
[10:21:40.163]             inherits <- base::inherits
[10:21:40.163]             invokeRestart <- base::invokeRestart
[10:21:40.163]             length <- base::length
[10:21:40.163]             list <- base::list
[10:21:40.163]             seq.int <- base::seq.int
[10:21:40.163]             signalCondition <- base::signalCondition
[10:21:40.163]             sys.calls <- base::sys.calls
[10:21:40.163]             `[[` <- base::`[[`
[10:21:40.163]             `+` <- base::`+`
[10:21:40.163]             `<<-` <- base::`<<-`
[10:21:40.163]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:40.163]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:40.163]                   3L)]
[10:21:40.163]             }
[10:21:40.163]             function(cond) {
[10:21:40.163]                 is_error <- inherits(cond, "error")
[10:21:40.163]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:40.163]                   NULL)
[10:21:40.163]                 if (is_error) {
[10:21:40.163]                   sessionInformation <- function() {
[10:21:40.163]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:40.163]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:40.163]                       search = base::search(), system = base::Sys.info())
[10:21:40.163]                   }
[10:21:40.163]                   ...future.conditions[[length(...future.conditions) + 
[10:21:40.163]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:40.163]                     cond$call), session = sessionInformation(), 
[10:21:40.163]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:40.163]                   signalCondition(cond)
[10:21:40.163]                 }
[10:21:40.163]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:40.163]                 "immediateCondition"))) {
[10:21:40.163]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:40.163]                   ...future.conditions[[length(...future.conditions) + 
[10:21:40.163]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:40.163]                   if (TRUE && !signal) {
[10:21:40.163]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:40.163]                     {
[10:21:40.163]                       inherits <- base::inherits
[10:21:40.163]                       invokeRestart <- base::invokeRestart
[10:21:40.163]                       is.null <- base::is.null
[10:21:40.163]                       muffled <- FALSE
[10:21:40.163]                       if (inherits(cond, "message")) {
[10:21:40.163]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:40.163]                         if (muffled) 
[10:21:40.163]                           invokeRestart("muffleMessage")
[10:21:40.163]                       }
[10:21:40.163]                       else if (inherits(cond, "warning")) {
[10:21:40.163]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:40.163]                         if (muffled) 
[10:21:40.163]                           invokeRestart("muffleWarning")
[10:21:40.163]                       }
[10:21:40.163]                       else if (inherits(cond, "condition")) {
[10:21:40.163]                         if (!is.null(pattern)) {
[10:21:40.163]                           computeRestarts <- base::computeRestarts
[10:21:40.163]                           grepl <- base::grepl
[10:21:40.163]                           restarts <- computeRestarts(cond)
[10:21:40.163]                           for (restart in restarts) {
[10:21:40.163]                             name <- restart$name
[10:21:40.163]                             if (is.null(name)) 
[10:21:40.163]                               next
[10:21:40.163]                             if (!grepl(pattern, name)) 
[10:21:40.163]                               next
[10:21:40.163]                             invokeRestart(restart)
[10:21:40.163]                             muffled <- TRUE
[10:21:40.163]                             break
[10:21:40.163]                           }
[10:21:40.163]                         }
[10:21:40.163]                       }
[10:21:40.163]                       invisible(muffled)
[10:21:40.163]                     }
[10:21:40.163]                     muffleCondition(cond, pattern = "^muffle")
[10:21:40.163]                   }
[10:21:40.163]                 }
[10:21:40.163]                 else {
[10:21:40.163]                   if (TRUE) {
[10:21:40.163]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:40.163]                     {
[10:21:40.163]                       inherits <- base::inherits
[10:21:40.163]                       invokeRestart <- base::invokeRestart
[10:21:40.163]                       is.null <- base::is.null
[10:21:40.163]                       muffled <- FALSE
[10:21:40.163]                       if (inherits(cond, "message")) {
[10:21:40.163]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:40.163]                         if (muffled) 
[10:21:40.163]                           invokeRestart("muffleMessage")
[10:21:40.163]                       }
[10:21:40.163]                       else if (inherits(cond, "warning")) {
[10:21:40.163]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:40.163]                         if (muffled) 
[10:21:40.163]                           invokeRestart("muffleWarning")
[10:21:40.163]                       }
[10:21:40.163]                       else if (inherits(cond, "condition")) {
[10:21:40.163]                         if (!is.null(pattern)) {
[10:21:40.163]                           computeRestarts <- base::computeRestarts
[10:21:40.163]                           grepl <- base::grepl
[10:21:40.163]                           restarts <- computeRestarts(cond)
[10:21:40.163]                           for (restart in restarts) {
[10:21:40.163]                             name <- restart$name
[10:21:40.163]                             if (is.null(name)) 
[10:21:40.163]                               next
[10:21:40.163]                             if (!grepl(pattern, name)) 
[10:21:40.163]                               next
[10:21:40.163]                             invokeRestart(restart)
[10:21:40.163]                             muffled <- TRUE
[10:21:40.163]                             break
[10:21:40.163]                           }
[10:21:40.163]                         }
[10:21:40.163]                       }
[10:21:40.163]                       invisible(muffled)
[10:21:40.163]                     }
[10:21:40.163]                     muffleCondition(cond, pattern = "^muffle")
[10:21:40.163]                   }
[10:21:40.163]                 }
[10:21:40.163]             }
[10:21:40.163]         }))
[10:21:40.163]     }, error = function(ex) {
[10:21:40.163]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:40.163]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:40.163]                 ...future.rng), started = ...future.startTime, 
[10:21:40.163]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:40.163]             version = "1.8"), class = "FutureResult")
[10:21:40.163]     }, finally = {
[10:21:40.163]         if (!identical(...future.workdir, getwd())) 
[10:21:40.163]             setwd(...future.workdir)
[10:21:40.163]         {
[10:21:40.163]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:40.163]                 ...future.oldOptions$nwarnings <- NULL
[10:21:40.163]             }
[10:21:40.163]             base::options(...future.oldOptions)
[10:21:40.163]             if (.Platform$OS.type == "windows") {
[10:21:40.163]                 old_names <- names(...future.oldEnvVars)
[10:21:40.163]                 envs <- base::Sys.getenv()
[10:21:40.163]                 names <- names(envs)
[10:21:40.163]                 common <- intersect(names, old_names)
[10:21:40.163]                 added <- setdiff(names, old_names)
[10:21:40.163]                 removed <- setdiff(old_names, names)
[10:21:40.163]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:40.163]                   envs[common]]
[10:21:40.163]                 NAMES <- toupper(changed)
[10:21:40.163]                 args <- list()
[10:21:40.163]                 for (kk in seq_along(NAMES)) {
[10:21:40.163]                   name <- changed[[kk]]
[10:21:40.163]                   NAME <- NAMES[[kk]]
[10:21:40.163]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:40.163]                     next
[10:21:40.163]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:40.163]                 }
[10:21:40.163]                 NAMES <- toupper(added)
[10:21:40.163]                 for (kk in seq_along(NAMES)) {
[10:21:40.163]                   name <- added[[kk]]
[10:21:40.163]                   NAME <- NAMES[[kk]]
[10:21:40.163]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:40.163]                     next
[10:21:40.163]                   args[[name]] <- ""
[10:21:40.163]                 }
[10:21:40.163]                 NAMES <- toupper(removed)
[10:21:40.163]                 for (kk in seq_along(NAMES)) {
[10:21:40.163]                   name <- removed[[kk]]
[10:21:40.163]                   NAME <- NAMES[[kk]]
[10:21:40.163]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:40.163]                     next
[10:21:40.163]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:40.163]                 }
[10:21:40.163]                 if (length(args) > 0) 
[10:21:40.163]                   base::do.call(base::Sys.setenv, args = args)
[10:21:40.163]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:40.163]             }
[10:21:40.163]             else {
[10:21:40.163]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:40.163]             }
[10:21:40.163]             {
[10:21:40.163]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:40.163]                   0L) {
[10:21:40.163]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:40.163]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:40.163]                   base::options(opts)
[10:21:40.163]                 }
[10:21:40.163]                 {
[10:21:40.163]                   {
[10:21:40.163]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:40.163]                     NULL
[10:21:40.163]                   }
[10:21:40.163]                   options(future.plan = NULL)
[10:21:40.163]                   if (is.na(NA_character_)) 
[10:21:40.163]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:40.163]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:40.163]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:40.163]                     .init = FALSE)
[10:21:40.163]                 }
[10:21:40.163]             }
[10:21:40.163]         }
[10:21:40.163]     })
[10:21:40.163]     if (TRUE) {
[10:21:40.163]         base::sink(type = "output", split = FALSE)
[10:21:40.163]         if (TRUE) {
[10:21:40.163]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:40.163]         }
[10:21:40.163]         else {
[10:21:40.163]             ...future.result["stdout"] <- base::list(NULL)
[10:21:40.163]         }
[10:21:40.163]         base::close(...future.stdout)
[10:21:40.163]         ...future.stdout <- NULL
[10:21:40.163]     }
[10:21:40.163]     ...future.result$conditions <- ...future.conditions
[10:21:40.163]     ...future.result$finished <- base::Sys.time()
[10:21:40.163]     ...future.result
[10:21:40.163] }
[10:21:40.166] Exporting 1 global objects (338 bytes) to cluster node #1 ...
[10:21:40.166] Exporting ‘x’ (31 bytes) to cluster node #1 ...
[10:21:40.166] Exporting ‘x’ (31 bytes) to cluster node #1 ... DONE
[10:21:40.167] Exporting 1 global objects (338 bytes) to cluster node #1 ... DONE
[10:21:40.167] MultisessionFuture started
[10:21:40.167] - Launch lazy future ... done
[10:21:40.167] run() for ‘MultisessionFuture’ ... done
[10:21:40.167] result() for ClusterFuture ...
[10:21:40.168] receiveMessageFromWorker() for ClusterFuture ...
[10:21:40.168] - Validating connection of MultisessionFuture
[10:21:40.209] - received message: FutureResult
[10:21:40.210] - Received FutureResult
[10:21:40.210] - Erased future from FutureRegistry
[10:21:40.210] result() for ClusterFuture ...
[10:21:40.210] - result already collected: FutureResult
[10:21:40.210] result() for ClusterFuture ... done
[10:21:40.210] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:40.210] result() for ClusterFuture ... done
[10:21:40.210] result() for ClusterFuture ...
[10:21:40.210] - result already collected: FutureResult
[10:21:40.210] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:40.211] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:40.211] Searching for globals...
[10:21:40.213] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:21:40.213] Searching for globals ... DONE
[10:21:40.213] Resolving globals: TRUE
[10:21:40.214] Resolving any globals that are futures ...
[10:21:40.214] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:21:40.219] Resolving any globals that are futures ... DONE
[10:21:40.219] Resolving futures part of globals (recursively) ...
[10:21:40.220] resolve() on list ...
[10:21:40.220]  recursive: 99
[10:21:40.220]  length: 1
[10:21:40.220]  elements: ‘x’
[10:21:40.220]  length: 0 (resolved future 1)
[10:21:40.220] resolve() on list ... DONE
[10:21:40.220] - globals: [1] ‘x’
[10:21:40.220] Resolving futures part of globals (recursively) ... DONE
[10:21:40.220] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:40.221] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:40.221] - globals: [1] ‘x’
[10:21:40.221] 
[10:21:40.221] getGlobalsAndPackages() ... DONE
[10:21:40.221] run() for ‘Future’ ...
[10:21:40.221] - state: ‘created’
[10:21:40.221] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:40.236] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:40.236] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:40.236]   - Field: ‘node’
[10:21:40.236]   - Field: ‘label’
[10:21:40.236]   - Field: ‘local’
[10:21:40.236]   - Field: ‘owner’
[10:21:40.236]   - Field: ‘envir’
[10:21:40.236]   - Field: ‘workers’
[10:21:40.237]   - Field: ‘packages’
[10:21:40.237]   - Field: ‘gc’
[10:21:40.237]   - Field: ‘conditions’
[10:21:40.237]   - Field: ‘persistent’
[10:21:40.237]   - Field: ‘expr’
[10:21:40.237]   - Field: ‘uuid’
[10:21:40.237]   - Field: ‘seed’
[10:21:40.237]   - Field: ‘version’
[10:21:40.237]   - Field: ‘result’
[10:21:40.237]   - Field: ‘asynchronous’
[10:21:40.237]   - Field: ‘calls’
[10:21:40.237]   - Field: ‘globals’
[10:21:40.238]   - Field: ‘stdout’
[10:21:40.238]   - Field: ‘earlySignal’
[10:21:40.238]   - Field: ‘lazy’
[10:21:40.238]   - Field: ‘state’
[10:21:40.238] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:40.238] - Launch lazy future ...
[10:21:40.238] Packages needed by the future expression (n = 0): <none>
[10:21:40.238] Packages needed by future strategies (n = 0): <none>
[10:21:40.239] {
[10:21:40.239]     {
[10:21:40.239]         {
[10:21:40.239]             ...future.startTime <- base::Sys.time()
[10:21:40.239]             {
[10:21:40.239]                 {
[10:21:40.239]                   {
[10:21:40.239]                     {
[10:21:40.239]                       base::local({
[10:21:40.239]                         has_future <- base::requireNamespace("future", 
[10:21:40.239]                           quietly = TRUE)
[10:21:40.239]                         if (has_future) {
[10:21:40.239]                           ns <- base::getNamespace("future")
[10:21:40.239]                           version <- ns[[".package"]][["version"]]
[10:21:40.239]                           if (is.null(version)) 
[10:21:40.239]                             version <- utils::packageVersion("future")
[10:21:40.239]                         }
[10:21:40.239]                         else {
[10:21:40.239]                           version <- NULL
[10:21:40.239]                         }
[10:21:40.239]                         if (!has_future || version < "1.8.0") {
[10:21:40.239]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:40.239]                             "", base::R.version$version.string), 
[10:21:40.239]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:40.239]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:40.239]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:40.239]                               "release", "version")], collapse = " "), 
[10:21:40.239]                             hostname = base::Sys.info()[["nodename"]])
[10:21:40.239]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:40.239]                             info)
[10:21:40.239]                           info <- base::paste(info, collapse = "; ")
[10:21:40.239]                           if (!has_future) {
[10:21:40.239]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:40.239]                               info)
[10:21:40.239]                           }
[10:21:40.239]                           else {
[10:21:40.239]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:40.239]                               info, version)
[10:21:40.239]                           }
[10:21:40.239]                           base::stop(msg)
[10:21:40.239]                         }
[10:21:40.239]                       })
[10:21:40.239]                     }
[10:21:40.239]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:40.239]                     base::options(mc.cores = 1L)
[10:21:40.239]                   }
[10:21:40.239]                   ...future.strategy.old <- future::plan("list")
[10:21:40.239]                   options(future.plan = NULL)
[10:21:40.239]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:40.239]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:40.239]                 }
[10:21:40.239]                 ...future.workdir <- getwd()
[10:21:40.239]             }
[10:21:40.239]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:40.239]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:40.239]         }
[10:21:40.239]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:40.239]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:40.239]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:40.239]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:40.239]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:40.239]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:40.239]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:40.239]             base::names(...future.oldOptions))
[10:21:40.239]     }
[10:21:40.239]     if (FALSE) {
[10:21:40.239]     }
[10:21:40.239]     else {
[10:21:40.239]         if (TRUE) {
[10:21:40.239]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:40.239]                 open = "w")
[10:21:40.239]         }
[10:21:40.239]         else {
[10:21:40.239]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:40.239]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:40.239]         }
[10:21:40.239]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:40.239]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:40.239]             base::sink(type = "output", split = FALSE)
[10:21:40.239]             base::close(...future.stdout)
[10:21:40.239]         }, add = TRUE)
[10:21:40.239]     }
[10:21:40.239]     ...future.frame <- base::sys.nframe()
[10:21:40.239]     ...future.conditions <- base::list()
[10:21:40.239]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:40.239]     if (FALSE) {
[10:21:40.239]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:40.239]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:40.239]     }
[10:21:40.239]     ...future.result <- base::tryCatch({
[10:21:40.239]         base::withCallingHandlers({
[10:21:40.239]             ...future.value <- base::withVisible(base::local({
[10:21:40.239]                 ...future.makeSendCondition <- base::local({
[10:21:40.239]                   sendCondition <- NULL
[10:21:40.239]                   function(frame = 1L) {
[10:21:40.239]                     if (is.function(sendCondition)) 
[10:21:40.239]                       return(sendCondition)
[10:21:40.239]                     ns <- getNamespace("parallel")
[10:21:40.239]                     if (exists("sendData", mode = "function", 
[10:21:40.239]                       envir = ns)) {
[10:21:40.239]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:40.239]                         envir = ns)
[10:21:40.239]                       envir <- sys.frame(frame)
[10:21:40.239]                       master <- NULL
[10:21:40.239]                       while (!identical(envir, .GlobalEnv) && 
[10:21:40.239]                         !identical(envir, emptyenv())) {
[10:21:40.239]                         if (exists("master", mode = "list", envir = envir, 
[10:21:40.239]                           inherits = FALSE)) {
[10:21:40.239]                           master <- get("master", mode = "list", 
[10:21:40.239]                             envir = envir, inherits = FALSE)
[10:21:40.239]                           if (inherits(master, c("SOCKnode", 
[10:21:40.239]                             "SOCK0node"))) {
[10:21:40.239]                             sendCondition <<- function(cond) {
[10:21:40.239]                               data <- list(type = "VALUE", value = cond, 
[10:21:40.239]                                 success = TRUE)
[10:21:40.239]                               parallel_sendData(master, data)
[10:21:40.239]                             }
[10:21:40.239]                             return(sendCondition)
[10:21:40.239]                           }
[10:21:40.239]                         }
[10:21:40.239]                         frame <- frame + 1L
[10:21:40.239]                         envir <- sys.frame(frame)
[10:21:40.239]                       }
[10:21:40.239]                     }
[10:21:40.239]                     sendCondition <<- function(cond) NULL
[10:21:40.239]                   }
[10:21:40.239]                 })
[10:21:40.239]                 withCallingHandlers({
[10:21:40.239]                   {
[10:21:40.239]                     x["a"] <- list(1)
[10:21:40.239]                     x
[10:21:40.239]                   }
[10:21:40.239]                 }, immediateCondition = function(cond) {
[10:21:40.239]                   sendCondition <- ...future.makeSendCondition()
[10:21:40.239]                   sendCondition(cond)
[10:21:40.239]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:40.239]                   {
[10:21:40.239]                     inherits <- base::inherits
[10:21:40.239]                     invokeRestart <- base::invokeRestart
[10:21:40.239]                     is.null <- base::is.null
[10:21:40.239]                     muffled <- FALSE
[10:21:40.239]                     if (inherits(cond, "message")) {
[10:21:40.239]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:40.239]                       if (muffled) 
[10:21:40.239]                         invokeRestart("muffleMessage")
[10:21:40.239]                     }
[10:21:40.239]                     else if (inherits(cond, "warning")) {
[10:21:40.239]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:40.239]                       if (muffled) 
[10:21:40.239]                         invokeRestart("muffleWarning")
[10:21:40.239]                     }
[10:21:40.239]                     else if (inherits(cond, "condition")) {
[10:21:40.239]                       if (!is.null(pattern)) {
[10:21:40.239]                         computeRestarts <- base::computeRestarts
[10:21:40.239]                         grepl <- base::grepl
[10:21:40.239]                         restarts <- computeRestarts(cond)
[10:21:40.239]                         for (restart in restarts) {
[10:21:40.239]                           name <- restart$name
[10:21:40.239]                           if (is.null(name)) 
[10:21:40.239]                             next
[10:21:40.239]                           if (!grepl(pattern, name)) 
[10:21:40.239]                             next
[10:21:40.239]                           invokeRestart(restart)
[10:21:40.239]                           muffled <- TRUE
[10:21:40.239]                           break
[10:21:40.239]                         }
[10:21:40.239]                       }
[10:21:40.239]                     }
[10:21:40.239]                     invisible(muffled)
[10:21:40.239]                   }
[10:21:40.239]                   muffleCondition(cond)
[10:21:40.239]                 })
[10:21:40.239]             }))
[10:21:40.239]             future::FutureResult(value = ...future.value$value, 
[10:21:40.239]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:40.239]                   ...future.rng), globalenv = if (FALSE) 
[10:21:40.239]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:40.239]                     ...future.globalenv.names))
[10:21:40.239]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:40.239]         }, condition = base::local({
[10:21:40.239]             c <- base::c
[10:21:40.239]             inherits <- base::inherits
[10:21:40.239]             invokeRestart <- base::invokeRestart
[10:21:40.239]             length <- base::length
[10:21:40.239]             list <- base::list
[10:21:40.239]             seq.int <- base::seq.int
[10:21:40.239]             signalCondition <- base::signalCondition
[10:21:40.239]             sys.calls <- base::sys.calls
[10:21:40.239]             `[[` <- base::`[[`
[10:21:40.239]             `+` <- base::`+`
[10:21:40.239]             `<<-` <- base::`<<-`
[10:21:40.239]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:40.239]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:40.239]                   3L)]
[10:21:40.239]             }
[10:21:40.239]             function(cond) {
[10:21:40.239]                 is_error <- inherits(cond, "error")
[10:21:40.239]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:40.239]                   NULL)
[10:21:40.239]                 if (is_error) {
[10:21:40.239]                   sessionInformation <- function() {
[10:21:40.239]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:40.239]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:40.239]                       search = base::search(), system = base::Sys.info())
[10:21:40.239]                   }
[10:21:40.239]                   ...future.conditions[[length(...future.conditions) + 
[10:21:40.239]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:40.239]                     cond$call), session = sessionInformation(), 
[10:21:40.239]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:40.239]                   signalCondition(cond)
[10:21:40.239]                 }
[10:21:40.239]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:40.239]                 "immediateCondition"))) {
[10:21:40.239]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:40.239]                   ...future.conditions[[length(...future.conditions) + 
[10:21:40.239]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:40.239]                   if (TRUE && !signal) {
[10:21:40.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:40.239]                     {
[10:21:40.239]                       inherits <- base::inherits
[10:21:40.239]                       invokeRestart <- base::invokeRestart
[10:21:40.239]                       is.null <- base::is.null
[10:21:40.239]                       muffled <- FALSE
[10:21:40.239]                       if (inherits(cond, "message")) {
[10:21:40.239]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:40.239]                         if (muffled) 
[10:21:40.239]                           invokeRestart("muffleMessage")
[10:21:40.239]                       }
[10:21:40.239]                       else if (inherits(cond, "warning")) {
[10:21:40.239]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:40.239]                         if (muffled) 
[10:21:40.239]                           invokeRestart("muffleWarning")
[10:21:40.239]                       }
[10:21:40.239]                       else if (inherits(cond, "condition")) {
[10:21:40.239]                         if (!is.null(pattern)) {
[10:21:40.239]                           computeRestarts <- base::computeRestarts
[10:21:40.239]                           grepl <- base::grepl
[10:21:40.239]                           restarts <- computeRestarts(cond)
[10:21:40.239]                           for (restart in restarts) {
[10:21:40.239]                             name <- restart$name
[10:21:40.239]                             if (is.null(name)) 
[10:21:40.239]                               next
[10:21:40.239]                             if (!grepl(pattern, name)) 
[10:21:40.239]                               next
[10:21:40.239]                             invokeRestart(restart)
[10:21:40.239]                             muffled <- TRUE
[10:21:40.239]                             break
[10:21:40.239]                           }
[10:21:40.239]                         }
[10:21:40.239]                       }
[10:21:40.239]                       invisible(muffled)
[10:21:40.239]                     }
[10:21:40.239]                     muffleCondition(cond, pattern = "^muffle")
[10:21:40.239]                   }
[10:21:40.239]                 }
[10:21:40.239]                 else {
[10:21:40.239]                   if (TRUE) {
[10:21:40.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:40.239]                     {
[10:21:40.239]                       inherits <- base::inherits
[10:21:40.239]                       invokeRestart <- base::invokeRestart
[10:21:40.239]                       is.null <- base::is.null
[10:21:40.239]                       muffled <- FALSE
[10:21:40.239]                       if (inherits(cond, "message")) {
[10:21:40.239]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:40.239]                         if (muffled) 
[10:21:40.239]                           invokeRestart("muffleMessage")
[10:21:40.239]                       }
[10:21:40.239]                       else if (inherits(cond, "warning")) {
[10:21:40.239]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:40.239]                         if (muffled) 
[10:21:40.239]                           invokeRestart("muffleWarning")
[10:21:40.239]                       }
[10:21:40.239]                       else if (inherits(cond, "condition")) {
[10:21:40.239]                         if (!is.null(pattern)) {
[10:21:40.239]                           computeRestarts <- base::computeRestarts
[10:21:40.239]                           grepl <- base::grepl
[10:21:40.239]                           restarts <- computeRestarts(cond)
[10:21:40.239]                           for (restart in restarts) {
[10:21:40.239]                             name <- restart$name
[10:21:40.239]                             if (is.null(name)) 
[10:21:40.239]                               next
[10:21:40.239]                             if (!grepl(pattern, name)) 
[10:21:40.239]                               next
[10:21:40.239]                             invokeRestart(restart)
[10:21:40.239]                             muffled <- TRUE
[10:21:40.239]                             break
[10:21:40.239]                           }
[10:21:40.239]                         }
[10:21:40.239]                       }
[10:21:40.239]                       invisible(muffled)
[10:21:40.239]                     }
[10:21:40.239]                     muffleCondition(cond, pattern = "^muffle")
[10:21:40.239]                   }
[10:21:40.239]                 }
[10:21:40.239]             }
[10:21:40.239]         }))
[10:21:40.239]     }, error = function(ex) {
[10:21:40.239]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:40.239]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:40.239]                 ...future.rng), started = ...future.startTime, 
[10:21:40.239]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:40.239]             version = "1.8"), class = "FutureResult")
[10:21:40.239]     }, finally = {
[10:21:40.239]         if (!identical(...future.workdir, getwd())) 
[10:21:40.239]             setwd(...future.workdir)
[10:21:40.239]         {
[10:21:40.239]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:40.239]                 ...future.oldOptions$nwarnings <- NULL
[10:21:40.239]             }
[10:21:40.239]             base::options(...future.oldOptions)
[10:21:40.239]             if (.Platform$OS.type == "windows") {
[10:21:40.239]                 old_names <- names(...future.oldEnvVars)
[10:21:40.239]                 envs <- base::Sys.getenv()
[10:21:40.239]                 names <- names(envs)
[10:21:40.239]                 common <- intersect(names, old_names)
[10:21:40.239]                 added <- setdiff(names, old_names)
[10:21:40.239]                 removed <- setdiff(old_names, names)
[10:21:40.239]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:40.239]                   envs[common]]
[10:21:40.239]                 NAMES <- toupper(changed)
[10:21:40.239]                 args <- list()
[10:21:40.239]                 for (kk in seq_along(NAMES)) {
[10:21:40.239]                   name <- changed[[kk]]
[10:21:40.239]                   NAME <- NAMES[[kk]]
[10:21:40.239]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:40.239]                     next
[10:21:40.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:40.239]                 }
[10:21:40.239]                 NAMES <- toupper(added)
[10:21:40.239]                 for (kk in seq_along(NAMES)) {
[10:21:40.239]                   name <- added[[kk]]
[10:21:40.239]                   NAME <- NAMES[[kk]]
[10:21:40.239]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:40.239]                     next
[10:21:40.239]                   args[[name]] <- ""
[10:21:40.239]                 }
[10:21:40.239]                 NAMES <- toupper(removed)
[10:21:40.239]                 for (kk in seq_along(NAMES)) {
[10:21:40.239]                   name <- removed[[kk]]
[10:21:40.239]                   NAME <- NAMES[[kk]]
[10:21:40.239]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:40.239]                     next
[10:21:40.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:40.239]                 }
[10:21:40.239]                 if (length(args) > 0) 
[10:21:40.239]                   base::do.call(base::Sys.setenv, args = args)
[10:21:40.239]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:40.239]             }
[10:21:40.239]             else {
[10:21:40.239]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:40.239]             }
[10:21:40.239]             {
[10:21:40.239]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:40.239]                   0L) {
[10:21:40.239]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:40.239]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:40.239]                   base::options(opts)
[10:21:40.239]                 }
[10:21:40.239]                 {
[10:21:40.239]                   {
[10:21:40.239]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:40.239]                     NULL
[10:21:40.239]                   }
[10:21:40.239]                   options(future.plan = NULL)
[10:21:40.239]                   if (is.na(NA_character_)) 
[10:21:40.239]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:40.239]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:40.239]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:40.239]                     .init = FALSE)
[10:21:40.239]                 }
[10:21:40.239]             }
[10:21:40.239]         }
[10:21:40.239]     })
[10:21:40.239]     if (TRUE) {
[10:21:40.239]         base::sink(type = "output", split = FALSE)
[10:21:40.239]         if (TRUE) {
[10:21:40.239]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:40.239]         }
[10:21:40.239]         else {
[10:21:40.239]             ...future.result["stdout"] <- base::list(NULL)
[10:21:40.239]         }
[10:21:40.239]         base::close(...future.stdout)
[10:21:40.239]         ...future.stdout <- NULL
[10:21:40.239]     }
[10:21:40.239]     ...future.result$conditions <- ...future.conditions
[10:21:40.239]     ...future.result$finished <- base::Sys.time()
[10:21:40.239]     ...future.result
[10:21:40.239] }
[10:21:40.242] Exporting 1 global objects (338 bytes) to cluster node #1 ...
[10:21:40.242] Exporting ‘x’ (31 bytes) to cluster node #1 ...
[10:21:40.242] Exporting ‘x’ (31 bytes) to cluster node #1 ... DONE
[10:21:40.242] Exporting 1 global objects (338 bytes) to cluster node #1 ... DONE
[10:21:40.243] MultisessionFuture started
[10:21:40.243] - Launch lazy future ... done
[10:21:40.243] run() for ‘MultisessionFuture’ ... done
[10:21:40.243] result() for ClusterFuture ...
[10:21:40.243] receiveMessageFromWorker() for ClusterFuture ...
[10:21:40.243] - Validating connection of MultisessionFuture
[10:21:40.285] - received message: FutureResult
[10:21:40.285] - Received FutureResult
[10:21:40.285] - Erased future from FutureRegistry
[10:21:40.286] result() for ClusterFuture ...
[10:21:40.286] - result already collected: FutureResult
[10:21:40.286] result() for ClusterFuture ... done
[10:21:40.286] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:40.286] result() for ClusterFuture ... done
[10:21:40.286] result() for ClusterFuture ...
[10:21:40.286] - result already collected: FutureResult
[10:21:40.286] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:40.287] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:40.287] Searching for globals...
[10:21:40.289] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:21:40.289] Searching for globals ... DONE
[10:21:40.289] Resolving globals: TRUE
[10:21:40.289] Resolving any globals that are futures ...
[10:21:40.289] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[10:21:40.289] Resolving any globals that are futures ... DONE
[10:21:40.290] Resolving futures part of globals (recursively) ...
[10:21:40.290] resolve() on list ...
[10:21:40.290]  recursive: 99
[10:21:40.290]  length: 1
[10:21:40.290]  elements: ‘x’
[10:21:40.290]  length: 0 (resolved future 1)
[10:21:40.290] resolve() on list ... DONE
[10:21:40.291] - globals: [1] ‘x’
[10:21:40.291] Resolving futures part of globals (recursively) ... DONE
[10:21:40.291] The total size of the 1 globals is 31 bytes (31 bytes)
[10:21:40.291] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 31 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (31 bytes of class ‘list’)
[10:21:40.291] - globals: [1] ‘x’
[10:21:40.291] 
[10:21:40.291] getGlobalsAndPackages() ... DONE
[10:21:40.292] run() for ‘Future’ ...
[10:21:40.292] - state: ‘created’
[10:21:40.292] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:40.306] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:40.306] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:40.306]   - Field: ‘node’
[10:21:40.306]   - Field: ‘label’
[10:21:40.306]   - Field: ‘local’
[10:21:40.306]   - Field: ‘owner’
[10:21:40.306]   - Field: ‘envir’
[10:21:40.307]   - Field: ‘workers’
[10:21:40.307]   - Field: ‘packages’
[10:21:40.307]   - Field: ‘gc’
[10:21:40.307]   - Field: ‘conditions’
[10:21:40.307]   - Field: ‘persistent’
[10:21:40.307]   - Field: ‘expr’
[10:21:40.307]   - Field: ‘uuid’
[10:21:40.307]   - Field: ‘seed’
[10:21:40.307]   - Field: ‘version’
[10:21:40.307]   - Field: ‘result’
[10:21:40.307]   - Field: ‘asynchronous’
[10:21:40.307]   - Field: ‘calls’
[10:21:40.308]   - Field: ‘globals’
[10:21:40.308]   - Field: ‘stdout’
[10:21:40.308]   - Field: ‘earlySignal’
[10:21:40.308]   - Field: ‘lazy’
[10:21:40.308]   - Field: ‘state’
[10:21:40.308] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:40.308] - Launch lazy future ...
[10:21:40.308] Packages needed by the future expression (n = 0): <none>
[10:21:40.308] Packages needed by future strategies (n = 0): <none>
[10:21:40.309] {
[10:21:40.309]     {
[10:21:40.309]         {
[10:21:40.309]             ...future.startTime <- base::Sys.time()
[10:21:40.309]             {
[10:21:40.309]                 {
[10:21:40.309]                   {
[10:21:40.309]                     {
[10:21:40.309]                       base::local({
[10:21:40.309]                         has_future <- base::requireNamespace("future", 
[10:21:40.309]                           quietly = TRUE)
[10:21:40.309]                         if (has_future) {
[10:21:40.309]                           ns <- base::getNamespace("future")
[10:21:40.309]                           version <- ns[[".package"]][["version"]]
[10:21:40.309]                           if (is.null(version)) 
[10:21:40.309]                             version <- utils::packageVersion("future")
[10:21:40.309]                         }
[10:21:40.309]                         else {
[10:21:40.309]                           version <- NULL
[10:21:40.309]                         }
[10:21:40.309]                         if (!has_future || version < "1.8.0") {
[10:21:40.309]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:40.309]                             "", base::R.version$version.string), 
[10:21:40.309]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:40.309]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:40.309]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:40.309]                               "release", "version")], collapse = " "), 
[10:21:40.309]                             hostname = base::Sys.info()[["nodename"]])
[10:21:40.309]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:40.309]                             info)
[10:21:40.309]                           info <- base::paste(info, collapse = "; ")
[10:21:40.309]                           if (!has_future) {
[10:21:40.309]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:40.309]                               info)
[10:21:40.309]                           }
[10:21:40.309]                           else {
[10:21:40.309]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:40.309]                               info, version)
[10:21:40.309]                           }
[10:21:40.309]                           base::stop(msg)
[10:21:40.309]                         }
[10:21:40.309]                       })
[10:21:40.309]                     }
[10:21:40.309]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:40.309]                     base::options(mc.cores = 1L)
[10:21:40.309]                   }
[10:21:40.309]                   ...future.strategy.old <- future::plan("list")
[10:21:40.309]                   options(future.plan = NULL)
[10:21:40.309]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:40.309]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:40.309]                 }
[10:21:40.309]                 ...future.workdir <- getwd()
[10:21:40.309]             }
[10:21:40.309]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:40.309]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:40.309]         }
[10:21:40.309]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:40.309]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:40.309]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:40.309]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:40.309]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:40.309]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:40.309]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:40.309]             base::names(...future.oldOptions))
[10:21:40.309]     }
[10:21:40.309]     if (FALSE) {
[10:21:40.309]     }
[10:21:40.309]     else {
[10:21:40.309]         if (TRUE) {
[10:21:40.309]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:40.309]                 open = "w")
[10:21:40.309]         }
[10:21:40.309]         else {
[10:21:40.309]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:40.309]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:40.309]         }
[10:21:40.309]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:40.309]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:40.309]             base::sink(type = "output", split = FALSE)
[10:21:40.309]             base::close(...future.stdout)
[10:21:40.309]         }, add = TRUE)
[10:21:40.309]     }
[10:21:40.309]     ...future.frame <- base::sys.nframe()
[10:21:40.309]     ...future.conditions <- base::list()
[10:21:40.309]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:40.309]     if (FALSE) {
[10:21:40.309]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:40.309]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:40.309]     }
[10:21:40.309]     ...future.result <- base::tryCatch({
[10:21:40.309]         base::withCallingHandlers({
[10:21:40.309]             ...future.value <- base::withVisible(base::local({
[10:21:40.309]                 ...future.makeSendCondition <- base::local({
[10:21:40.309]                   sendCondition <- NULL
[10:21:40.309]                   function(frame = 1L) {
[10:21:40.309]                     if (is.function(sendCondition)) 
[10:21:40.309]                       return(sendCondition)
[10:21:40.309]                     ns <- getNamespace("parallel")
[10:21:40.309]                     if (exists("sendData", mode = "function", 
[10:21:40.309]                       envir = ns)) {
[10:21:40.309]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:40.309]                         envir = ns)
[10:21:40.309]                       envir <- sys.frame(frame)
[10:21:40.309]                       master <- NULL
[10:21:40.309]                       while (!identical(envir, .GlobalEnv) && 
[10:21:40.309]                         !identical(envir, emptyenv())) {
[10:21:40.309]                         if (exists("master", mode = "list", envir = envir, 
[10:21:40.309]                           inherits = FALSE)) {
[10:21:40.309]                           master <- get("master", mode = "list", 
[10:21:40.309]                             envir = envir, inherits = FALSE)
[10:21:40.309]                           if (inherits(master, c("SOCKnode", 
[10:21:40.309]                             "SOCK0node"))) {
[10:21:40.309]                             sendCondition <<- function(cond) {
[10:21:40.309]                               data <- list(type = "VALUE", value = cond, 
[10:21:40.309]                                 success = TRUE)
[10:21:40.309]                               parallel_sendData(master, data)
[10:21:40.309]                             }
[10:21:40.309]                             return(sendCondition)
[10:21:40.309]                           }
[10:21:40.309]                         }
[10:21:40.309]                         frame <- frame + 1L
[10:21:40.309]                         envir <- sys.frame(frame)
[10:21:40.309]                       }
[10:21:40.309]                     }
[10:21:40.309]                     sendCondition <<- function(cond) NULL
[10:21:40.309]                   }
[10:21:40.309]                 })
[10:21:40.309]                 withCallingHandlers({
[10:21:40.309]                   {
[10:21:40.309]                     x["a"] <- list(1)
[10:21:40.309]                     x
[10:21:40.309]                   }
[10:21:40.309]                 }, immediateCondition = function(cond) {
[10:21:40.309]                   sendCondition <- ...future.makeSendCondition()
[10:21:40.309]                   sendCondition(cond)
[10:21:40.309]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:40.309]                   {
[10:21:40.309]                     inherits <- base::inherits
[10:21:40.309]                     invokeRestart <- base::invokeRestart
[10:21:40.309]                     is.null <- base::is.null
[10:21:40.309]                     muffled <- FALSE
[10:21:40.309]                     if (inherits(cond, "message")) {
[10:21:40.309]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:40.309]                       if (muffled) 
[10:21:40.309]                         invokeRestart("muffleMessage")
[10:21:40.309]                     }
[10:21:40.309]                     else if (inherits(cond, "warning")) {
[10:21:40.309]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:40.309]                       if (muffled) 
[10:21:40.309]                         invokeRestart("muffleWarning")
[10:21:40.309]                     }
[10:21:40.309]                     else if (inherits(cond, "condition")) {
[10:21:40.309]                       if (!is.null(pattern)) {
[10:21:40.309]                         computeRestarts <- base::computeRestarts
[10:21:40.309]                         grepl <- base::grepl
[10:21:40.309]                         restarts <- computeRestarts(cond)
[10:21:40.309]                         for (restart in restarts) {
[10:21:40.309]                           name <- restart$name
[10:21:40.309]                           if (is.null(name)) 
[10:21:40.309]                             next
[10:21:40.309]                           if (!grepl(pattern, name)) 
[10:21:40.309]                             next
[10:21:40.309]                           invokeRestart(restart)
[10:21:40.309]                           muffled <- TRUE
[10:21:40.309]                           break
[10:21:40.309]                         }
[10:21:40.309]                       }
[10:21:40.309]                     }
[10:21:40.309]                     invisible(muffled)
[10:21:40.309]                   }
[10:21:40.309]                   muffleCondition(cond)
[10:21:40.309]                 })
[10:21:40.309]             }))
[10:21:40.309]             future::FutureResult(value = ...future.value$value, 
[10:21:40.309]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:40.309]                   ...future.rng), globalenv = if (FALSE) 
[10:21:40.309]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:40.309]                     ...future.globalenv.names))
[10:21:40.309]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:40.309]         }, condition = base::local({
[10:21:40.309]             c <- base::c
[10:21:40.309]             inherits <- base::inherits
[10:21:40.309]             invokeRestart <- base::invokeRestart
[10:21:40.309]             length <- base::length
[10:21:40.309]             list <- base::list
[10:21:40.309]             seq.int <- base::seq.int
[10:21:40.309]             signalCondition <- base::signalCondition
[10:21:40.309]             sys.calls <- base::sys.calls
[10:21:40.309]             `[[` <- base::`[[`
[10:21:40.309]             `+` <- base::`+`
[10:21:40.309]             `<<-` <- base::`<<-`
[10:21:40.309]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:40.309]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:40.309]                   3L)]
[10:21:40.309]             }
[10:21:40.309]             function(cond) {
[10:21:40.309]                 is_error <- inherits(cond, "error")
[10:21:40.309]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:40.309]                   NULL)
[10:21:40.309]                 if (is_error) {
[10:21:40.309]                   sessionInformation <- function() {
[10:21:40.309]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:40.309]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:40.309]                       search = base::search(), system = base::Sys.info())
[10:21:40.309]                   }
[10:21:40.309]                   ...future.conditions[[length(...future.conditions) + 
[10:21:40.309]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:40.309]                     cond$call), session = sessionInformation(), 
[10:21:40.309]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:40.309]                   signalCondition(cond)
[10:21:40.309]                 }
[10:21:40.309]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:40.309]                 "immediateCondition"))) {
[10:21:40.309]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:40.309]                   ...future.conditions[[length(...future.conditions) + 
[10:21:40.309]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:40.309]                   if (TRUE && !signal) {
[10:21:40.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:40.309]                     {
[10:21:40.309]                       inherits <- base::inherits
[10:21:40.309]                       invokeRestart <- base::invokeRestart
[10:21:40.309]                       is.null <- base::is.null
[10:21:40.309]                       muffled <- FALSE
[10:21:40.309]                       if (inherits(cond, "message")) {
[10:21:40.309]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:40.309]                         if (muffled) 
[10:21:40.309]                           invokeRestart("muffleMessage")
[10:21:40.309]                       }
[10:21:40.309]                       else if (inherits(cond, "warning")) {
[10:21:40.309]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:40.309]                         if (muffled) 
[10:21:40.309]                           invokeRestart("muffleWarning")
[10:21:40.309]                       }
[10:21:40.309]                       else if (inherits(cond, "condition")) {
[10:21:40.309]                         if (!is.null(pattern)) {
[10:21:40.309]                           computeRestarts <- base::computeRestarts
[10:21:40.309]                           grepl <- base::grepl
[10:21:40.309]                           restarts <- computeRestarts(cond)
[10:21:40.309]                           for (restart in restarts) {
[10:21:40.309]                             name <- restart$name
[10:21:40.309]                             if (is.null(name)) 
[10:21:40.309]                               next
[10:21:40.309]                             if (!grepl(pattern, name)) 
[10:21:40.309]                               next
[10:21:40.309]                             invokeRestart(restart)
[10:21:40.309]                             muffled <- TRUE
[10:21:40.309]                             break
[10:21:40.309]                           }
[10:21:40.309]                         }
[10:21:40.309]                       }
[10:21:40.309]                       invisible(muffled)
[10:21:40.309]                     }
[10:21:40.309]                     muffleCondition(cond, pattern = "^muffle")
[10:21:40.309]                   }
[10:21:40.309]                 }
[10:21:40.309]                 else {
[10:21:40.309]                   if (TRUE) {
[10:21:40.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:40.309]                     {
[10:21:40.309]                       inherits <- base::inherits
[10:21:40.309]                       invokeRestart <- base::invokeRestart
[10:21:40.309]                       is.null <- base::is.null
[10:21:40.309]                       muffled <- FALSE
[10:21:40.309]                       if (inherits(cond, "message")) {
[10:21:40.309]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:40.309]                         if (muffled) 
[10:21:40.309]                           invokeRestart("muffleMessage")
[10:21:40.309]                       }
[10:21:40.309]                       else if (inherits(cond, "warning")) {
[10:21:40.309]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:40.309]                         if (muffled) 
[10:21:40.309]                           invokeRestart("muffleWarning")
[10:21:40.309]                       }
[10:21:40.309]                       else if (inherits(cond, "condition")) {
[10:21:40.309]                         if (!is.null(pattern)) {
[10:21:40.309]                           computeRestarts <- base::computeRestarts
[10:21:40.309]                           grepl <- base::grepl
[10:21:40.309]                           restarts <- computeRestarts(cond)
[10:21:40.309]                           for (restart in restarts) {
[10:21:40.309]                             name <- restart$name
[10:21:40.309]                             if (is.null(name)) 
[10:21:40.309]                               next
[10:21:40.309]                             if (!grepl(pattern, name)) 
[10:21:40.309]                               next
[10:21:40.309]                             invokeRestart(restart)
[10:21:40.309]                             muffled <- TRUE
[10:21:40.309]                             break
[10:21:40.309]                           }
[10:21:40.309]                         }
[10:21:40.309]                       }
[10:21:40.309]                       invisible(muffled)
[10:21:40.309]                     }
[10:21:40.309]                     muffleCondition(cond, pattern = "^muffle")
[10:21:40.309]                   }
[10:21:40.309]                 }
[10:21:40.309]             }
[10:21:40.309]         }))
[10:21:40.309]     }, error = function(ex) {
[10:21:40.309]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:40.309]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:40.309]                 ...future.rng), started = ...future.startTime, 
[10:21:40.309]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:40.309]             version = "1.8"), class = "FutureResult")
[10:21:40.309]     }, finally = {
[10:21:40.309]         if (!identical(...future.workdir, getwd())) 
[10:21:40.309]             setwd(...future.workdir)
[10:21:40.309]         {
[10:21:40.309]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:40.309]                 ...future.oldOptions$nwarnings <- NULL
[10:21:40.309]             }
[10:21:40.309]             base::options(...future.oldOptions)
[10:21:40.309]             if (.Platform$OS.type == "windows") {
[10:21:40.309]                 old_names <- names(...future.oldEnvVars)
[10:21:40.309]                 envs <- base::Sys.getenv()
[10:21:40.309]                 names <- names(envs)
[10:21:40.309]                 common <- intersect(names, old_names)
[10:21:40.309]                 added <- setdiff(names, old_names)
[10:21:40.309]                 removed <- setdiff(old_names, names)
[10:21:40.309]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:40.309]                   envs[common]]
[10:21:40.309]                 NAMES <- toupper(changed)
[10:21:40.309]                 args <- list()
[10:21:40.309]                 for (kk in seq_along(NAMES)) {
[10:21:40.309]                   name <- changed[[kk]]
[10:21:40.309]                   NAME <- NAMES[[kk]]
[10:21:40.309]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:40.309]                     next
[10:21:40.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:40.309]                 }
[10:21:40.309]                 NAMES <- toupper(added)
[10:21:40.309]                 for (kk in seq_along(NAMES)) {
[10:21:40.309]                   name <- added[[kk]]
[10:21:40.309]                   NAME <- NAMES[[kk]]
[10:21:40.309]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:40.309]                     next
[10:21:40.309]                   args[[name]] <- ""
[10:21:40.309]                 }
[10:21:40.309]                 NAMES <- toupper(removed)
[10:21:40.309]                 for (kk in seq_along(NAMES)) {
[10:21:40.309]                   name <- removed[[kk]]
[10:21:40.309]                   NAME <- NAMES[[kk]]
[10:21:40.309]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:40.309]                     next
[10:21:40.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:40.309]                 }
[10:21:40.309]                 if (length(args) > 0) 
[10:21:40.309]                   base::do.call(base::Sys.setenv, args = args)
[10:21:40.309]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:40.309]             }
[10:21:40.309]             else {
[10:21:40.309]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:40.309]             }
[10:21:40.309]             {
[10:21:40.309]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:40.309]                   0L) {
[10:21:40.309]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:40.309]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:40.309]                   base::options(opts)
[10:21:40.309]                 }
[10:21:40.309]                 {
[10:21:40.309]                   {
[10:21:40.309]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:40.309]                     NULL
[10:21:40.309]                   }
[10:21:40.309]                   options(future.plan = NULL)
[10:21:40.309]                   if (is.na(NA_character_)) 
[10:21:40.309]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:40.309]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:40.309]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:40.309]                     .init = FALSE)
[10:21:40.309]                 }
[10:21:40.309]             }
[10:21:40.309]         }
[10:21:40.309]     })
[10:21:40.309]     if (TRUE) {
[10:21:40.309]         base::sink(type = "output", split = FALSE)
[10:21:40.309]         if (TRUE) {
[10:21:40.309]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:40.309]         }
[10:21:40.309]         else {
[10:21:40.309]             ...future.result["stdout"] <- base::list(NULL)
[10:21:40.309]         }
[10:21:40.309]         base::close(...future.stdout)
[10:21:40.309]         ...future.stdout <- NULL
[10:21:40.309]     }
[10:21:40.309]     ...future.result$conditions <- ...future.conditions
[10:21:40.309]     ...future.result$finished <- base::Sys.time()
[10:21:40.309]     ...future.result
[10:21:40.309] }
[10:21:40.312] Exporting 1 global objects (338 bytes) to cluster node #1 ...
[10:21:40.312] Exporting ‘x’ (31 bytes) to cluster node #1 ...
[10:21:40.312] Exporting ‘x’ (31 bytes) to cluster node #1 ... DONE
[10:21:40.312] Exporting 1 global objects (338 bytes) to cluster node #1 ... DONE
[10:21:40.313] MultisessionFuture started
[10:21:40.313] - Launch lazy future ... done
[10:21:40.313] run() for ‘MultisessionFuture’ ... done
[10:21:40.313] result() for ClusterFuture ...
[10:21:40.313] receiveMessageFromWorker() for ClusterFuture ...
[10:21:40.313] - Validating connection of MultisessionFuture
[10:21:40.355] - received message: FutureResult
[10:21:40.356] - Received FutureResult
[10:21:40.356] - Erased future from FutureRegistry
[10:21:40.356] result() for ClusterFuture ...
[10:21:40.356] - result already collected: FutureResult
[10:21:40.356] result() for ClusterFuture ... done
[10:21:40.356] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:40.356] result() for ClusterFuture ... done
[10:21:40.356] result() for ClusterFuture ...
[10:21:40.356] - result already collected: FutureResult
[10:21:40.356] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:40.357] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:40.357] Searching for globals...
[10:21:40.359] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[10:21:40.360] Searching for globals ... DONE
[10:21:40.360] Resolving globals: TRUE
[10:21:40.360] Resolving any globals that are futures ...
[10:21:40.360] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[10:21:40.360] Resolving any globals that are futures ... DONE
[10:21:40.360] Resolving futures part of globals (recursively) ...
[10:21:40.361] resolve() on list ...
[10:21:40.361]  recursive: 99
[10:21:40.361]  length: 2
[10:21:40.361]  elements: ‘x’, ‘name’
[10:21:40.361]  length: 1 (resolved future 1)
[10:21:40.361]  length: 0 (resolved future 2)
[10:21:40.361] resolve() on list ... DONE
[10:21:40.361] - globals: [2] ‘x’, ‘name’
[10:21:40.361] Resolving futures part of globals (recursively) ... DONE
[10:21:40.362] The total size of the 2 globals is 71 bytes (71 bytes)
[10:21:40.362] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 71 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (40 bytes of class ‘character’) and ‘x’ (31 bytes of class ‘list’)
[10:21:40.362] - globals: [2] ‘x’, ‘name’
[10:21:40.362] 
[10:21:40.362] getGlobalsAndPackages() ... DONE
[10:21:40.363] run() for ‘Future’ ...
[10:21:40.363] - state: ‘created’
[10:21:40.363] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:40.377] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:40.377] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:40.377]   - Field: ‘node’
[10:21:40.377]   - Field: ‘label’
[10:21:40.377]   - Field: ‘local’
[10:21:40.377]   - Field: ‘owner’
[10:21:40.377]   - Field: ‘envir’
[10:21:40.377]   - Field: ‘workers’
[10:21:40.378]   - Field: ‘packages’
[10:21:40.378]   - Field: ‘gc’
[10:21:40.378]   - Field: ‘conditions’
[10:21:40.378]   - Field: ‘persistent’
[10:21:40.378]   - Field: ‘expr’
[10:21:40.378]   - Field: ‘uuid’
[10:21:40.378]   - Field: ‘seed’
[10:21:40.378]   - Field: ‘version’
[10:21:40.378]   - Field: ‘result’
[10:21:40.378]   - Field: ‘asynchronous’
[10:21:40.378]   - Field: ‘calls’
[10:21:40.378]   - Field: ‘globals’
[10:21:40.379]   - Field: ‘stdout’
[10:21:40.379]   - Field: ‘earlySignal’
[10:21:40.379]   - Field: ‘lazy’
[10:21:40.379]   - Field: ‘state’
[10:21:40.379] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:40.379] - Launch lazy future ...
[10:21:40.379] Packages needed by the future expression (n = 0): <none>
[10:21:40.379] Packages needed by future strategies (n = 0): <none>
[10:21:40.380] {
[10:21:40.380]     {
[10:21:40.380]         {
[10:21:40.380]             ...future.startTime <- base::Sys.time()
[10:21:40.380]             {
[10:21:40.380]                 {
[10:21:40.380]                   {
[10:21:40.380]                     {
[10:21:40.380]                       base::local({
[10:21:40.380]                         has_future <- base::requireNamespace("future", 
[10:21:40.380]                           quietly = TRUE)
[10:21:40.380]                         if (has_future) {
[10:21:40.380]                           ns <- base::getNamespace("future")
[10:21:40.380]                           version <- ns[[".package"]][["version"]]
[10:21:40.380]                           if (is.null(version)) 
[10:21:40.380]                             version <- utils::packageVersion("future")
[10:21:40.380]                         }
[10:21:40.380]                         else {
[10:21:40.380]                           version <- NULL
[10:21:40.380]                         }
[10:21:40.380]                         if (!has_future || version < "1.8.0") {
[10:21:40.380]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:40.380]                             "", base::R.version$version.string), 
[10:21:40.380]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:40.380]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:40.380]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:40.380]                               "release", "version")], collapse = " "), 
[10:21:40.380]                             hostname = base::Sys.info()[["nodename"]])
[10:21:40.380]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:40.380]                             info)
[10:21:40.380]                           info <- base::paste(info, collapse = "; ")
[10:21:40.380]                           if (!has_future) {
[10:21:40.380]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:40.380]                               info)
[10:21:40.380]                           }
[10:21:40.380]                           else {
[10:21:40.380]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:40.380]                               info, version)
[10:21:40.380]                           }
[10:21:40.380]                           base::stop(msg)
[10:21:40.380]                         }
[10:21:40.380]                       })
[10:21:40.380]                     }
[10:21:40.380]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:40.380]                     base::options(mc.cores = 1L)
[10:21:40.380]                   }
[10:21:40.380]                   ...future.strategy.old <- future::plan("list")
[10:21:40.380]                   options(future.plan = NULL)
[10:21:40.380]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:40.380]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:40.380]                 }
[10:21:40.380]                 ...future.workdir <- getwd()
[10:21:40.380]             }
[10:21:40.380]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:40.380]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:40.380]         }
[10:21:40.380]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:40.380]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:40.380]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:40.380]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:40.380]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:40.380]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:40.380]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:40.380]             base::names(...future.oldOptions))
[10:21:40.380]     }
[10:21:40.380]     if (FALSE) {
[10:21:40.380]     }
[10:21:40.380]     else {
[10:21:40.380]         if (TRUE) {
[10:21:40.380]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:40.380]                 open = "w")
[10:21:40.380]         }
[10:21:40.380]         else {
[10:21:40.380]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:40.380]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:40.380]         }
[10:21:40.380]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:40.380]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:40.380]             base::sink(type = "output", split = FALSE)
[10:21:40.380]             base::close(...future.stdout)
[10:21:40.380]         }, add = TRUE)
[10:21:40.380]     }
[10:21:40.380]     ...future.frame <- base::sys.nframe()
[10:21:40.380]     ...future.conditions <- base::list()
[10:21:40.380]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:40.380]     if (FALSE) {
[10:21:40.380]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:40.380]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:40.380]     }
[10:21:40.380]     ...future.result <- base::tryCatch({
[10:21:40.380]         base::withCallingHandlers({
[10:21:40.380]             ...future.value <- base::withVisible(base::local({
[10:21:40.380]                 ...future.makeSendCondition <- base::local({
[10:21:40.380]                   sendCondition <- NULL
[10:21:40.380]                   function(frame = 1L) {
[10:21:40.380]                     if (is.function(sendCondition)) 
[10:21:40.380]                       return(sendCondition)
[10:21:40.380]                     ns <- getNamespace("parallel")
[10:21:40.380]                     if (exists("sendData", mode = "function", 
[10:21:40.380]                       envir = ns)) {
[10:21:40.380]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:40.380]                         envir = ns)
[10:21:40.380]                       envir <- sys.frame(frame)
[10:21:40.380]                       master <- NULL
[10:21:40.380]                       while (!identical(envir, .GlobalEnv) && 
[10:21:40.380]                         !identical(envir, emptyenv())) {
[10:21:40.380]                         if (exists("master", mode = "list", envir = envir, 
[10:21:40.380]                           inherits = FALSE)) {
[10:21:40.380]                           master <- get("master", mode = "list", 
[10:21:40.380]                             envir = envir, inherits = FALSE)
[10:21:40.380]                           if (inherits(master, c("SOCKnode", 
[10:21:40.380]                             "SOCK0node"))) {
[10:21:40.380]                             sendCondition <<- function(cond) {
[10:21:40.380]                               data <- list(type = "VALUE", value = cond, 
[10:21:40.380]                                 success = TRUE)
[10:21:40.380]                               parallel_sendData(master, data)
[10:21:40.380]                             }
[10:21:40.380]                             return(sendCondition)
[10:21:40.380]                           }
[10:21:40.380]                         }
[10:21:40.380]                         frame <- frame + 1L
[10:21:40.380]                         envir <- sys.frame(frame)
[10:21:40.380]                       }
[10:21:40.380]                     }
[10:21:40.380]                     sendCondition <<- function(cond) NULL
[10:21:40.380]                   }
[10:21:40.380]                 })
[10:21:40.380]                 withCallingHandlers({
[10:21:40.380]                   {
[10:21:40.380]                     x[name] <- list(1)
[10:21:40.380]                     x
[10:21:40.380]                   }
[10:21:40.380]                 }, immediateCondition = function(cond) {
[10:21:40.380]                   sendCondition <- ...future.makeSendCondition()
[10:21:40.380]                   sendCondition(cond)
[10:21:40.380]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:40.380]                   {
[10:21:40.380]                     inherits <- base::inherits
[10:21:40.380]                     invokeRestart <- base::invokeRestart
[10:21:40.380]                     is.null <- base::is.null
[10:21:40.380]                     muffled <- FALSE
[10:21:40.380]                     if (inherits(cond, "message")) {
[10:21:40.380]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:40.380]                       if (muffled) 
[10:21:40.380]                         invokeRestart("muffleMessage")
[10:21:40.380]                     }
[10:21:40.380]                     else if (inherits(cond, "warning")) {
[10:21:40.380]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:40.380]                       if (muffled) 
[10:21:40.380]                         invokeRestart("muffleWarning")
[10:21:40.380]                     }
[10:21:40.380]                     else if (inherits(cond, "condition")) {
[10:21:40.380]                       if (!is.null(pattern)) {
[10:21:40.380]                         computeRestarts <- base::computeRestarts
[10:21:40.380]                         grepl <- base::grepl
[10:21:40.380]                         restarts <- computeRestarts(cond)
[10:21:40.380]                         for (restart in restarts) {
[10:21:40.380]                           name <- restart$name
[10:21:40.380]                           if (is.null(name)) 
[10:21:40.380]                             next
[10:21:40.380]                           if (!grepl(pattern, name)) 
[10:21:40.380]                             next
[10:21:40.380]                           invokeRestart(restart)
[10:21:40.380]                           muffled <- TRUE
[10:21:40.380]                           break
[10:21:40.380]                         }
[10:21:40.380]                       }
[10:21:40.380]                     }
[10:21:40.380]                     invisible(muffled)
[10:21:40.380]                   }
[10:21:40.380]                   muffleCondition(cond)
[10:21:40.380]                 })
[10:21:40.380]             }))
[10:21:40.380]             future::FutureResult(value = ...future.value$value, 
[10:21:40.380]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:40.380]                   ...future.rng), globalenv = if (FALSE) 
[10:21:40.380]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:40.380]                     ...future.globalenv.names))
[10:21:40.380]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:40.380]         }, condition = base::local({
[10:21:40.380]             c <- base::c
[10:21:40.380]             inherits <- base::inherits
[10:21:40.380]             invokeRestart <- base::invokeRestart
[10:21:40.380]             length <- base::length
[10:21:40.380]             list <- base::list
[10:21:40.380]             seq.int <- base::seq.int
[10:21:40.380]             signalCondition <- base::signalCondition
[10:21:40.380]             sys.calls <- base::sys.calls
[10:21:40.380]             `[[` <- base::`[[`
[10:21:40.380]             `+` <- base::`+`
[10:21:40.380]             `<<-` <- base::`<<-`
[10:21:40.380]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:40.380]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:40.380]                   3L)]
[10:21:40.380]             }
[10:21:40.380]             function(cond) {
[10:21:40.380]                 is_error <- inherits(cond, "error")
[10:21:40.380]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:40.380]                   NULL)
[10:21:40.380]                 if (is_error) {
[10:21:40.380]                   sessionInformation <- function() {
[10:21:40.380]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:40.380]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:40.380]                       search = base::search(), system = base::Sys.info())
[10:21:40.380]                   }
[10:21:40.380]                   ...future.conditions[[length(...future.conditions) + 
[10:21:40.380]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:40.380]                     cond$call), session = sessionInformation(), 
[10:21:40.380]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:40.380]                   signalCondition(cond)
[10:21:40.380]                 }
[10:21:40.380]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:40.380]                 "immediateCondition"))) {
[10:21:40.380]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:40.380]                   ...future.conditions[[length(...future.conditions) + 
[10:21:40.380]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:40.380]                   if (TRUE && !signal) {
[10:21:40.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:40.380]                     {
[10:21:40.380]                       inherits <- base::inherits
[10:21:40.380]                       invokeRestart <- base::invokeRestart
[10:21:40.380]                       is.null <- base::is.null
[10:21:40.380]                       muffled <- FALSE
[10:21:40.380]                       if (inherits(cond, "message")) {
[10:21:40.380]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:40.380]                         if (muffled) 
[10:21:40.380]                           invokeRestart("muffleMessage")
[10:21:40.380]                       }
[10:21:40.380]                       else if (inherits(cond, "warning")) {
[10:21:40.380]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:40.380]                         if (muffled) 
[10:21:40.380]                           invokeRestart("muffleWarning")
[10:21:40.380]                       }
[10:21:40.380]                       else if (inherits(cond, "condition")) {
[10:21:40.380]                         if (!is.null(pattern)) {
[10:21:40.380]                           computeRestarts <- base::computeRestarts
[10:21:40.380]                           grepl <- base::grepl
[10:21:40.380]                           restarts <- computeRestarts(cond)
[10:21:40.380]                           for (restart in restarts) {
[10:21:40.380]                             name <- restart$name
[10:21:40.380]                             if (is.null(name)) 
[10:21:40.380]                               next
[10:21:40.380]                             if (!grepl(pattern, name)) 
[10:21:40.380]                               next
[10:21:40.380]                             invokeRestart(restart)
[10:21:40.380]                             muffled <- TRUE
[10:21:40.380]                             break
[10:21:40.380]                           }
[10:21:40.380]                         }
[10:21:40.380]                       }
[10:21:40.380]                       invisible(muffled)
[10:21:40.380]                     }
[10:21:40.380]                     muffleCondition(cond, pattern = "^muffle")
[10:21:40.380]                   }
[10:21:40.380]                 }
[10:21:40.380]                 else {
[10:21:40.380]                   if (TRUE) {
[10:21:40.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:40.380]                     {
[10:21:40.380]                       inherits <- base::inherits
[10:21:40.380]                       invokeRestart <- base::invokeRestart
[10:21:40.380]                       is.null <- base::is.null
[10:21:40.380]                       muffled <- FALSE
[10:21:40.380]                       if (inherits(cond, "message")) {
[10:21:40.380]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:40.380]                         if (muffled) 
[10:21:40.380]                           invokeRestart("muffleMessage")
[10:21:40.380]                       }
[10:21:40.380]                       else if (inherits(cond, "warning")) {
[10:21:40.380]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:40.380]                         if (muffled) 
[10:21:40.380]                           invokeRestart("muffleWarning")
[10:21:40.380]                       }
[10:21:40.380]                       else if (inherits(cond, "condition")) {
[10:21:40.380]                         if (!is.null(pattern)) {
[10:21:40.380]                           computeRestarts <- base::computeRestarts
[10:21:40.380]                           grepl <- base::grepl
[10:21:40.380]                           restarts <- computeRestarts(cond)
[10:21:40.380]                           for (restart in restarts) {
[10:21:40.380]                             name <- restart$name
[10:21:40.380]                             if (is.null(name)) 
[10:21:40.380]                               next
[10:21:40.380]                             if (!grepl(pattern, name)) 
[10:21:40.380]                               next
[10:21:40.380]                             invokeRestart(restart)
[10:21:40.380]                             muffled <- TRUE
[10:21:40.380]                             break
[10:21:40.380]                           }
[10:21:40.380]                         }
[10:21:40.380]                       }
[10:21:40.380]                       invisible(muffled)
[10:21:40.380]                     }
[10:21:40.380]                     muffleCondition(cond, pattern = "^muffle")
[10:21:40.380]                   }
[10:21:40.380]                 }
[10:21:40.380]             }
[10:21:40.380]         }))
[10:21:40.380]     }, error = function(ex) {
[10:21:40.380]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:40.380]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:40.380]                 ...future.rng), started = ...future.startTime, 
[10:21:40.380]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:40.380]             version = "1.8"), class = "FutureResult")
[10:21:40.380]     }, finally = {
[10:21:40.380]         if (!identical(...future.workdir, getwd())) 
[10:21:40.380]             setwd(...future.workdir)
[10:21:40.380]         {
[10:21:40.380]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:40.380]                 ...future.oldOptions$nwarnings <- NULL
[10:21:40.380]             }
[10:21:40.380]             base::options(...future.oldOptions)
[10:21:40.380]             if (.Platform$OS.type == "windows") {
[10:21:40.380]                 old_names <- names(...future.oldEnvVars)
[10:21:40.380]                 envs <- base::Sys.getenv()
[10:21:40.380]                 names <- names(envs)
[10:21:40.380]                 common <- intersect(names, old_names)
[10:21:40.380]                 added <- setdiff(names, old_names)
[10:21:40.380]                 removed <- setdiff(old_names, names)
[10:21:40.380]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:40.380]                   envs[common]]
[10:21:40.380]                 NAMES <- toupper(changed)
[10:21:40.380]                 args <- list()
[10:21:40.380]                 for (kk in seq_along(NAMES)) {
[10:21:40.380]                   name <- changed[[kk]]
[10:21:40.380]                   NAME <- NAMES[[kk]]
[10:21:40.380]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:40.380]                     next
[10:21:40.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:40.380]                 }
[10:21:40.380]                 NAMES <- toupper(added)
[10:21:40.380]                 for (kk in seq_along(NAMES)) {
[10:21:40.380]                   name <- added[[kk]]
[10:21:40.380]                   NAME <- NAMES[[kk]]
[10:21:40.380]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:40.380]                     next
[10:21:40.380]                   args[[name]] <- ""
[10:21:40.380]                 }
[10:21:40.380]                 NAMES <- toupper(removed)
[10:21:40.380]                 for (kk in seq_along(NAMES)) {
[10:21:40.380]                   name <- removed[[kk]]
[10:21:40.380]                   NAME <- NAMES[[kk]]
[10:21:40.380]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:40.380]                     next
[10:21:40.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:40.380]                 }
[10:21:40.380]                 if (length(args) > 0) 
[10:21:40.380]                   base::do.call(base::Sys.setenv, args = args)
[10:21:40.380]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:40.380]             }
[10:21:40.380]             else {
[10:21:40.380]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:40.380]             }
[10:21:40.380]             {
[10:21:40.380]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:40.380]                   0L) {
[10:21:40.380]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:40.380]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:40.380]                   base::options(opts)
[10:21:40.380]                 }
[10:21:40.380]                 {
[10:21:40.380]                   {
[10:21:40.380]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:40.380]                     NULL
[10:21:40.380]                   }
[10:21:40.380]                   options(future.plan = NULL)
[10:21:40.380]                   if (is.na(NA_character_)) 
[10:21:40.380]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:40.380]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:40.380]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:40.380]                     .init = FALSE)
[10:21:40.380]                 }
[10:21:40.380]             }
[10:21:40.380]         }
[10:21:40.380]     })
[10:21:40.380]     if (TRUE) {
[10:21:40.380]         base::sink(type = "output", split = FALSE)
[10:21:40.380]         if (TRUE) {
[10:21:40.380]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:40.380]         }
[10:21:40.380]         else {
[10:21:40.380]             ...future.result["stdout"] <- base::list(NULL)
[10:21:40.380]         }
[10:21:40.380]         base::close(...future.stdout)
[10:21:40.380]         ...future.stdout <- NULL
[10:21:40.380]     }
[10:21:40.380]     ...future.result$conditions <- ...future.conditions
[10:21:40.380]     ...future.result$finished <- base::Sys.time()
[10:21:40.380]     ...future.result
[10:21:40.380] }
[10:21:40.382] Exporting 2 global objects (383 bytes) to cluster node #1 ...
[10:21:40.383] Exporting ‘x’ (31 bytes) to cluster node #1 ...
[10:21:40.383] Exporting ‘x’ (31 bytes) to cluster node #1 ... DONE
[10:21:40.383] Exporting ‘name’ (40 bytes) to cluster node #1 ...
[10:21:40.384] Exporting ‘name’ (40 bytes) to cluster node #1 ... DONE
[10:21:40.384] Exporting 2 global objects (383 bytes) to cluster node #1 ... DONE
[10:21:40.384] MultisessionFuture started
[10:21:40.384] - Launch lazy future ... done
[10:21:40.384] run() for ‘MultisessionFuture’ ... done
[10:21:40.385] result() for ClusterFuture ...
[10:21:40.385] receiveMessageFromWorker() for ClusterFuture ...
[10:21:40.385] - Validating connection of MultisessionFuture
[10:21:40.426] - received message: FutureResult
[10:21:40.426] - Received FutureResult
[10:21:40.426] - Erased future from FutureRegistry
[10:21:40.427] result() for ClusterFuture ...
[10:21:40.427] - result already collected: FutureResult
[10:21:40.427] result() for ClusterFuture ... done
[10:21:40.427] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:40.427] result() for ClusterFuture ... done
[10:21:40.427] result() for ClusterFuture ...
[10:21:40.427] - result already collected: FutureResult
[10:21:40.427] result() for ClusterFuture ... done
$a
[1] 1

Testing with 2 cores ... DONE
> 
> message("*** Globals - subassignments w/ x$a <- value ... DONE")
*** Globals - subassignments w/ x$a <- value ... DONE
> 
> message("*** Globals - subassignments ... DONE")
*** Globals - subassignments ... DONE
> 
> source("incl/end.R")
[10:21:40.428] plan(): Setting new future strategy stack:
[10:21:40.428] List of future strategies:
[10:21:40.428] 1. FutureStrategy:
[10:21:40.428]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:40.428]    - tweaked: FALSE
[10:21:40.428]    - call: future::plan(oplan)
[10:21:40.429] plan(): nbrOfWorkers() = 1
> 
