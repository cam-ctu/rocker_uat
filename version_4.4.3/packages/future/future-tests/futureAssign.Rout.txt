
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:21:12.562] plan(): Setting new future strategy stack:
[10:21:12.562] List of future strategies:
[10:21:12.562] 1. sequential:
[10:21:12.562]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.562]    - tweaked: FALSE
[10:21:12.562]    - call: future::plan("sequential")
[10:21:12.576] plan(): nbrOfWorkers() = 1
> 
> message("*** futureAssign() ...")
*** futureAssign() ...
> 
> message("*** futureAssign() - sequential w/ lazy evaluation ...")
*** futureAssign() - sequential w/ lazy evaluation ...
> 
> delayedAssign("a", {
+   cat("Delayed assignment evaluated\n")
+   1
+ })
> 
> futureAssign("b", {
+   cat("Future assignment evaluated\n")
+   2
+ }, lazy = TRUE)
[10:21:12.592] getGlobalsAndPackages() ...
[10:21:12.592] Searching for globals...
[10:21:12.597] - globals found: [2] ‘{’, ‘cat’
[10:21:12.597] Searching for globals ... DONE
[10:21:12.598] Resolving globals: FALSE
[10:21:12.598] 
[10:21:12.598] 
[10:21:12.598] getGlobalsAndPackages() ... DONE
> 
> ## Because "lazy future" is used, the expression/value
> ## for 'b' will not be resolved at the point.  For other
> ## types of futures, it may already have been resolved
> cat(sprintf("b = %s\n", b))
[10:21:12.599] run() for ‘Future’ ...
[10:21:12.599] - state: ‘created’
[10:21:12.599] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:12.600] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:12.600] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:12.600]   - Field: ‘label’
[10:21:12.600]   - Field: ‘local’
[10:21:12.600]   - Field: ‘owner’
[10:21:12.600]   - Field: ‘envir’
[10:21:12.600]   - Field: ‘packages’
[10:21:12.600]   - Field: ‘gc’
[10:21:12.600]   - Field: ‘conditions’
[10:21:12.600]   - Field: ‘expr’
[10:21:12.601]   - Field: ‘uuid’
[10:21:12.601]   - Field: ‘seed’
[10:21:12.601]   - Field: ‘version’
[10:21:12.601]   - Field: ‘result’
[10:21:12.601]   - Field: ‘asynchronous’
[10:21:12.601]   - Field: ‘calls’
[10:21:12.601]   - Field: ‘globals’
[10:21:12.601]   - Field: ‘stdout’
[10:21:12.601]   - Field: ‘earlySignal’
[10:21:12.601]   - Field: ‘lazy’
[10:21:12.601]   - Field: ‘state’
[10:21:12.601] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:12.602] - Launch lazy future ...
[10:21:12.602] Packages needed by the future expression (n = 0): <none>
[10:21:12.602] Packages needed by future strategies (n = 0): <none>
[10:21:12.603] {
[10:21:12.603]     {
[10:21:12.603]         {
[10:21:12.603]             ...future.startTime <- base::Sys.time()
[10:21:12.603]             {
[10:21:12.603]                 {
[10:21:12.603]                   {
[10:21:12.603]                     base::local({
[10:21:12.603]                       has_future <- base::requireNamespace("future", 
[10:21:12.603]                         quietly = TRUE)
[10:21:12.603]                       if (has_future) {
[10:21:12.603]                         ns <- base::getNamespace("future")
[10:21:12.603]                         version <- ns[[".package"]][["version"]]
[10:21:12.603]                         if (is.null(version)) 
[10:21:12.603]                           version <- utils::packageVersion("future")
[10:21:12.603]                       }
[10:21:12.603]                       else {
[10:21:12.603]                         version <- NULL
[10:21:12.603]                       }
[10:21:12.603]                       if (!has_future || version < "1.8.0") {
[10:21:12.603]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:12.603]                           "", base::R.version$version.string), 
[10:21:12.603]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:12.603]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:12.603]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:12.603]                             "release", "version")], collapse = " "), 
[10:21:12.603]                           hostname = base::Sys.info()[["nodename"]])
[10:21:12.603]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:12.603]                           info)
[10:21:12.603]                         info <- base::paste(info, collapse = "; ")
[10:21:12.603]                         if (!has_future) {
[10:21:12.603]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:12.603]                             info)
[10:21:12.603]                         }
[10:21:12.603]                         else {
[10:21:12.603]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:12.603]                             info, version)
[10:21:12.603]                         }
[10:21:12.603]                         base::stop(msg)
[10:21:12.603]                       }
[10:21:12.603]                     })
[10:21:12.603]                   }
[10:21:12.603]                   ...future.strategy.old <- future::plan("list")
[10:21:12.603]                   options(future.plan = NULL)
[10:21:12.603]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.603]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:12.603]                 }
[10:21:12.603]                 ...future.workdir <- getwd()
[10:21:12.603]             }
[10:21:12.603]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:12.603]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:12.603]         }
[10:21:12.603]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:12.603]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:12.603]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:12.603]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:12.603]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:12.603]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:12.603]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:12.603]             base::names(...future.oldOptions))
[10:21:12.603]     }
[10:21:12.603]     if (FALSE) {
[10:21:12.603]     }
[10:21:12.603]     else {
[10:21:12.603]         if (TRUE) {
[10:21:12.603]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:12.603]                 open = "w")
[10:21:12.603]         }
[10:21:12.603]         else {
[10:21:12.603]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:12.603]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:12.603]         }
[10:21:12.603]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:12.603]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:12.603]             base::sink(type = "output", split = FALSE)
[10:21:12.603]             base::close(...future.stdout)
[10:21:12.603]         }, add = TRUE)
[10:21:12.603]     }
[10:21:12.603]     ...future.frame <- base::sys.nframe()
[10:21:12.603]     ...future.conditions <- base::list()
[10:21:12.603]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:12.603]     if (FALSE) {
[10:21:12.603]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:12.603]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:12.603]     }
[10:21:12.603]     ...future.result <- base::tryCatch({
[10:21:12.603]         base::withCallingHandlers({
[10:21:12.603]             ...future.value <- base::withVisible(base::local({
[10:21:12.603]                 cat("Future assignment evaluated\n")
[10:21:12.603]                 2
[10:21:12.603]             }))
[10:21:12.603]             future::FutureResult(value = ...future.value$value, 
[10:21:12.603]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.603]                   ...future.rng), globalenv = if (FALSE) 
[10:21:12.603]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:12.603]                     ...future.globalenv.names))
[10:21:12.603]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:12.603]         }, condition = base::local({
[10:21:12.603]             c <- base::c
[10:21:12.603]             inherits <- base::inherits
[10:21:12.603]             invokeRestart <- base::invokeRestart
[10:21:12.603]             length <- base::length
[10:21:12.603]             list <- base::list
[10:21:12.603]             seq.int <- base::seq.int
[10:21:12.603]             signalCondition <- base::signalCondition
[10:21:12.603]             sys.calls <- base::sys.calls
[10:21:12.603]             `[[` <- base::`[[`
[10:21:12.603]             `+` <- base::`+`
[10:21:12.603]             `<<-` <- base::`<<-`
[10:21:12.603]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:12.603]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:12.603]                   3L)]
[10:21:12.603]             }
[10:21:12.603]             function(cond) {
[10:21:12.603]                 is_error <- inherits(cond, "error")
[10:21:12.603]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:12.603]                   NULL)
[10:21:12.603]                 if (is_error) {
[10:21:12.603]                   sessionInformation <- function() {
[10:21:12.603]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:12.603]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:12.603]                       search = base::search(), system = base::Sys.info())
[10:21:12.603]                   }
[10:21:12.603]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.603]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:12.603]                     cond$call), session = sessionInformation(), 
[10:21:12.603]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:12.603]                   signalCondition(cond)
[10:21:12.603]                 }
[10:21:12.603]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:12.603]                 "immediateCondition"))) {
[10:21:12.603]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:12.603]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.603]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:12.603]                   if (TRUE && !signal) {
[10:21:12.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.603]                     {
[10:21:12.603]                       inherits <- base::inherits
[10:21:12.603]                       invokeRestart <- base::invokeRestart
[10:21:12.603]                       is.null <- base::is.null
[10:21:12.603]                       muffled <- FALSE
[10:21:12.603]                       if (inherits(cond, "message")) {
[10:21:12.603]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.603]                         if (muffled) 
[10:21:12.603]                           invokeRestart("muffleMessage")
[10:21:12.603]                       }
[10:21:12.603]                       else if (inherits(cond, "warning")) {
[10:21:12.603]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.603]                         if (muffled) 
[10:21:12.603]                           invokeRestart("muffleWarning")
[10:21:12.603]                       }
[10:21:12.603]                       else if (inherits(cond, "condition")) {
[10:21:12.603]                         if (!is.null(pattern)) {
[10:21:12.603]                           computeRestarts <- base::computeRestarts
[10:21:12.603]                           grepl <- base::grepl
[10:21:12.603]                           restarts <- computeRestarts(cond)
[10:21:12.603]                           for (restart in restarts) {
[10:21:12.603]                             name <- restart$name
[10:21:12.603]                             if (is.null(name)) 
[10:21:12.603]                               next
[10:21:12.603]                             if (!grepl(pattern, name)) 
[10:21:12.603]                               next
[10:21:12.603]                             invokeRestart(restart)
[10:21:12.603]                             muffled <- TRUE
[10:21:12.603]                             break
[10:21:12.603]                           }
[10:21:12.603]                         }
[10:21:12.603]                       }
[10:21:12.603]                       invisible(muffled)
[10:21:12.603]                     }
[10:21:12.603]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.603]                   }
[10:21:12.603]                 }
[10:21:12.603]                 else {
[10:21:12.603]                   if (TRUE) {
[10:21:12.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.603]                     {
[10:21:12.603]                       inherits <- base::inherits
[10:21:12.603]                       invokeRestart <- base::invokeRestart
[10:21:12.603]                       is.null <- base::is.null
[10:21:12.603]                       muffled <- FALSE
[10:21:12.603]                       if (inherits(cond, "message")) {
[10:21:12.603]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.603]                         if (muffled) 
[10:21:12.603]                           invokeRestart("muffleMessage")
[10:21:12.603]                       }
[10:21:12.603]                       else if (inherits(cond, "warning")) {
[10:21:12.603]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.603]                         if (muffled) 
[10:21:12.603]                           invokeRestart("muffleWarning")
[10:21:12.603]                       }
[10:21:12.603]                       else if (inherits(cond, "condition")) {
[10:21:12.603]                         if (!is.null(pattern)) {
[10:21:12.603]                           computeRestarts <- base::computeRestarts
[10:21:12.603]                           grepl <- base::grepl
[10:21:12.603]                           restarts <- computeRestarts(cond)
[10:21:12.603]                           for (restart in restarts) {
[10:21:12.603]                             name <- restart$name
[10:21:12.603]                             if (is.null(name)) 
[10:21:12.603]                               next
[10:21:12.603]                             if (!grepl(pattern, name)) 
[10:21:12.603]                               next
[10:21:12.603]                             invokeRestart(restart)
[10:21:12.603]                             muffled <- TRUE
[10:21:12.603]                             break
[10:21:12.603]                           }
[10:21:12.603]                         }
[10:21:12.603]                       }
[10:21:12.603]                       invisible(muffled)
[10:21:12.603]                     }
[10:21:12.603]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.603]                   }
[10:21:12.603]                 }
[10:21:12.603]             }
[10:21:12.603]         }))
[10:21:12.603]     }, error = function(ex) {
[10:21:12.603]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:12.603]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.603]                 ...future.rng), started = ...future.startTime, 
[10:21:12.603]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:12.603]             version = "1.8"), class = "FutureResult")
[10:21:12.603]     }, finally = {
[10:21:12.603]         if (!identical(...future.workdir, getwd())) 
[10:21:12.603]             setwd(...future.workdir)
[10:21:12.603]         {
[10:21:12.603]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:12.603]                 ...future.oldOptions$nwarnings <- NULL
[10:21:12.603]             }
[10:21:12.603]             base::options(...future.oldOptions)
[10:21:12.603]             if (.Platform$OS.type == "windows") {
[10:21:12.603]                 old_names <- names(...future.oldEnvVars)
[10:21:12.603]                 envs <- base::Sys.getenv()
[10:21:12.603]                 names <- names(envs)
[10:21:12.603]                 common <- intersect(names, old_names)
[10:21:12.603]                 added <- setdiff(names, old_names)
[10:21:12.603]                 removed <- setdiff(old_names, names)
[10:21:12.603]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:12.603]                   envs[common]]
[10:21:12.603]                 NAMES <- toupper(changed)
[10:21:12.603]                 args <- list()
[10:21:12.603]                 for (kk in seq_along(NAMES)) {
[10:21:12.603]                   name <- changed[[kk]]
[10:21:12.603]                   NAME <- NAMES[[kk]]
[10:21:12.603]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.603]                     next
[10:21:12.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.603]                 }
[10:21:12.603]                 NAMES <- toupper(added)
[10:21:12.603]                 for (kk in seq_along(NAMES)) {
[10:21:12.603]                   name <- added[[kk]]
[10:21:12.603]                   NAME <- NAMES[[kk]]
[10:21:12.603]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.603]                     next
[10:21:12.603]                   args[[name]] <- ""
[10:21:12.603]                 }
[10:21:12.603]                 NAMES <- toupper(removed)
[10:21:12.603]                 for (kk in seq_along(NAMES)) {
[10:21:12.603]                   name <- removed[[kk]]
[10:21:12.603]                   NAME <- NAMES[[kk]]
[10:21:12.603]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.603]                     next
[10:21:12.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.603]                 }
[10:21:12.603]                 if (length(args) > 0) 
[10:21:12.603]                   base::do.call(base::Sys.setenv, args = args)
[10:21:12.603]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:12.603]             }
[10:21:12.603]             else {
[10:21:12.603]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:12.603]             }
[10:21:12.603]             {
[10:21:12.603]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:12.603]                   0L) {
[10:21:12.603]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:12.603]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:12.603]                   base::options(opts)
[10:21:12.603]                 }
[10:21:12.603]                 {
[10:21:12.603]                   {
[10:21:12.603]                     NULL
[10:21:12.603]                     RNGkind("Mersenne-Twister")
[10:21:12.603]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:12.603]                       inherits = FALSE)
[10:21:12.603]                   }
[10:21:12.603]                   options(future.plan = NULL)
[10:21:12.603]                   if (is.na(NA_character_)) 
[10:21:12.603]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.603]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:12.603]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:12.603]                     .init = FALSE)
[10:21:12.603]                 }
[10:21:12.603]             }
[10:21:12.603]         }
[10:21:12.603]     })
[10:21:12.603]     if (TRUE) {
[10:21:12.603]         base::sink(type = "output", split = FALSE)
[10:21:12.603]         if (TRUE) {
[10:21:12.603]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:12.603]         }
[10:21:12.603]         else {
[10:21:12.603]             ...future.result["stdout"] <- base::list(NULL)
[10:21:12.603]         }
[10:21:12.603]         base::close(...future.stdout)
[10:21:12.603]         ...future.stdout <- NULL
[10:21:12.603]     }
[10:21:12.603]     ...future.result$conditions <- ...future.conditions
[10:21:12.603]     ...future.result$finished <- base::Sys.time()
[10:21:12.603]     ...future.result
[10:21:12.603] }
[10:21:12.605] plan(): Setting new future strategy stack:
[10:21:12.605] List of future strategies:
[10:21:12.605] 1. sequential:
[10:21:12.605]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.605]    - tweaked: FALSE
[10:21:12.605]    - call: NULL
[10:21:12.605] plan(): nbrOfWorkers() = 1
[10:21:12.607] plan(): Setting new future strategy stack:
[10:21:12.607] List of future strategies:
[10:21:12.607] 1. sequential:
[10:21:12.607]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.607]    - tweaked: FALSE
[10:21:12.607]    - call: future::plan("sequential")
[10:21:12.607] plan(): nbrOfWorkers() = 1
[10:21:12.607] SequentialFuture started (and completed)
[10:21:12.608] - Launch lazy future ... done
[10:21:12.608] run() for ‘SequentialFuture’ ... done
Future assignment evaluated
b = 2
> 
> ## The expression/value of 'a' is resolved at this point,
> ## because a delayed assignment (promise) was used.
> cat(sprintf("a = %s\n", a))
Delayed assignment evaluated
a = 1
> 
> stopifnot(identical(a, 1))
> stopifnot(identical(b, 2))
> 
> message("*** futureAssign() - sequential w/ lazy evaluation ... DONE")
*** futureAssign() - sequential w/ lazy evaluation ... DONE
> 
> 
> message("*** futureAssign() - lazy = TRUE / FALSE ...")
*** futureAssign() - lazy = TRUE / FALSE ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("*** futureAssign() with %s futures ...", sQuote(strategy)))
+     plan(strategy)
+ 
+     ## Potential task name clashes
+     u <- new.env()
+     v <- new.env()
+     futureAssign("a", { 2 }, assign.env = u)
+     futureAssign("a", { 4 }, assign.env = v)
+     
+     cat(sprintf("u$a = %s\n", u$a))
+     cat(sprintf("v$a = %s\n", v$a))
+     
+     stopifnot(identical(u$a, 2))
+     stopifnot(identical(v$a, 4))
+     
+     
+     ## Global variables
+     a <- 1
+     futureAssign("b", { 2 * a })
+     a <- 2
+     stopifnot(b == 2)
+ 
+     ## Explicit lazy evaluation
+     for (lazy in c(FALSE, TRUE)) {
+       a <- 1
+       f <- futureAssign("b", { 2 * a }, lazy = lazy)
+       a <- 2
+       stopifnot(b == 2)
+       stopifnot(f$lazy == lazy || (strategy %in% c("multisession", "multicore") && cores == 1L))
+       
+       ## Set 'lazy' via disposable option
+       options(future.disposable = list(lazy = lazy))
+       a <- 1
+       f <- futureAssign("b", { 2 * a })
+       a <- 2
+       stopifnot(b == 2)
+       stopifnot(f$lazy == lazy || (strategy %in% c("multisession", "multicore") && cores == 1L))
+     }
+ 
+     message(sprintf("*** futureAssign() with %s futures ... DONE", sQuote(strategy)))
+   } # for (strategy in ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** futureAssign() with ‘sequential’ futures ...
[10:21:12.633] plan(): Setting new future strategy stack:
[10:21:12.633] List of future strategies:
[10:21:12.633] 1. sequential:
[10:21:12.633]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.633]    - tweaked: FALSE
[10:21:12.633]    - call: plan(strategy)
[10:21:12.645] plan(): nbrOfWorkers() = 1
[10:21:12.645] getGlobalsAndPackages() ...
[10:21:12.645] Searching for globals...
[10:21:12.645] - globals found: [1] ‘{’
[10:21:12.645] Searching for globals ... DONE
[10:21:12.645] Resolving globals: FALSE
[10:21:12.646] 
[10:21:12.646] 
[10:21:12.646] getGlobalsAndPackages() ... DONE
[10:21:12.646] run() for ‘Future’ ...
[10:21:12.646] - state: ‘created’
[10:21:12.646] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:12.647] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:12.647] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:12.647]   - Field: ‘label’
[10:21:12.647]   - Field: ‘local’
[10:21:12.647]   - Field: ‘owner’
[10:21:12.647]   - Field: ‘envir’
[10:21:12.647]   - Field: ‘packages’
[10:21:12.647]   - Field: ‘gc’
[10:21:12.647]   - Field: ‘conditions’
[10:21:12.647]   - Field: ‘expr’
[10:21:12.647]   - Field: ‘uuid’
[10:21:12.648]   - Field: ‘seed’
[10:21:12.648]   - Field: ‘version’
[10:21:12.648]   - Field: ‘result’
[10:21:12.648]   - Field: ‘asynchronous’
[10:21:12.648]   - Field: ‘calls’
[10:21:12.648]   - Field: ‘globals’
[10:21:12.648]   - Field: ‘stdout’
[10:21:12.648]   - Field: ‘earlySignal’
[10:21:12.648]   - Field: ‘lazy’
[10:21:12.648]   - Field: ‘state’
[10:21:12.648] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:12.648] - Launch lazy future ...
[10:21:12.649] Packages needed by the future expression (n = 0): <none>
[10:21:12.649] Packages needed by future strategies (n = 0): <none>
[10:21:12.649] {
[10:21:12.649]     {
[10:21:12.649]         {
[10:21:12.649]             ...future.startTime <- base::Sys.time()
[10:21:12.649]             {
[10:21:12.649]                 {
[10:21:12.649]                   {
[10:21:12.649]                     base::local({
[10:21:12.649]                       has_future <- base::requireNamespace("future", 
[10:21:12.649]                         quietly = TRUE)
[10:21:12.649]                       if (has_future) {
[10:21:12.649]                         ns <- base::getNamespace("future")
[10:21:12.649]                         version <- ns[[".package"]][["version"]]
[10:21:12.649]                         if (is.null(version)) 
[10:21:12.649]                           version <- utils::packageVersion("future")
[10:21:12.649]                       }
[10:21:12.649]                       else {
[10:21:12.649]                         version <- NULL
[10:21:12.649]                       }
[10:21:12.649]                       if (!has_future || version < "1.8.0") {
[10:21:12.649]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:12.649]                           "", base::R.version$version.string), 
[10:21:12.649]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:12.649]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:12.649]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:12.649]                             "release", "version")], collapse = " "), 
[10:21:12.649]                           hostname = base::Sys.info()[["nodename"]])
[10:21:12.649]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:12.649]                           info)
[10:21:12.649]                         info <- base::paste(info, collapse = "; ")
[10:21:12.649]                         if (!has_future) {
[10:21:12.649]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:12.649]                             info)
[10:21:12.649]                         }
[10:21:12.649]                         else {
[10:21:12.649]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:12.649]                             info, version)
[10:21:12.649]                         }
[10:21:12.649]                         base::stop(msg)
[10:21:12.649]                       }
[10:21:12.649]                     })
[10:21:12.649]                   }
[10:21:12.649]                   ...future.strategy.old <- future::plan("list")
[10:21:12.649]                   options(future.plan = NULL)
[10:21:12.649]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.649]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:12.649]                 }
[10:21:12.649]                 ...future.workdir <- getwd()
[10:21:12.649]             }
[10:21:12.649]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:12.649]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:12.649]         }
[10:21:12.649]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:12.649]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:12.649]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:12.649]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:12.649]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:12.649]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:12.649]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:12.649]             base::names(...future.oldOptions))
[10:21:12.649]     }
[10:21:12.649]     if (FALSE) {
[10:21:12.649]     }
[10:21:12.649]     else {
[10:21:12.649]         if (TRUE) {
[10:21:12.649]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:12.649]                 open = "w")
[10:21:12.649]         }
[10:21:12.649]         else {
[10:21:12.649]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:12.649]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:12.649]         }
[10:21:12.649]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:12.649]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:12.649]             base::sink(type = "output", split = FALSE)
[10:21:12.649]             base::close(...future.stdout)
[10:21:12.649]         }, add = TRUE)
[10:21:12.649]     }
[10:21:12.649]     ...future.frame <- base::sys.nframe()
[10:21:12.649]     ...future.conditions <- base::list()
[10:21:12.649]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:12.649]     if (FALSE) {
[10:21:12.649]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:12.649]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:12.649]     }
[10:21:12.649]     ...future.result <- base::tryCatch({
[10:21:12.649]         base::withCallingHandlers({
[10:21:12.649]             ...future.value <- base::withVisible(base::local({
[10:21:12.649]                 2
[10:21:12.649]             }))
[10:21:12.649]             future::FutureResult(value = ...future.value$value, 
[10:21:12.649]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.649]                   ...future.rng), globalenv = if (FALSE) 
[10:21:12.649]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:12.649]                     ...future.globalenv.names))
[10:21:12.649]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:12.649]         }, condition = base::local({
[10:21:12.649]             c <- base::c
[10:21:12.649]             inherits <- base::inherits
[10:21:12.649]             invokeRestart <- base::invokeRestart
[10:21:12.649]             length <- base::length
[10:21:12.649]             list <- base::list
[10:21:12.649]             seq.int <- base::seq.int
[10:21:12.649]             signalCondition <- base::signalCondition
[10:21:12.649]             sys.calls <- base::sys.calls
[10:21:12.649]             `[[` <- base::`[[`
[10:21:12.649]             `+` <- base::`+`
[10:21:12.649]             `<<-` <- base::`<<-`
[10:21:12.649]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:12.649]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:12.649]                   3L)]
[10:21:12.649]             }
[10:21:12.649]             function(cond) {
[10:21:12.649]                 is_error <- inherits(cond, "error")
[10:21:12.649]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:12.649]                   NULL)
[10:21:12.649]                 if (is_error) {
[10:21:12.649]                   sessionInformation <- function() {
[10:21:12.649]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:12.649]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:12.649]                       search = base::search(), system = base::Sys.info())
[10:21:12.649]                   }
[10:21:12.649]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.649]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:12.649]                     cond$call), session = sessionInformation(), 
[10:21:12.649]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:12.649]                   signalCondition(cond)
[10:21:12.649]                 }
[10:21:12.649]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:12.649]                 "immediateCondition"))) {
[10:21:12.649]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:12.649]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.649]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:12.649]                   if (TRUE && !signal) {
[10:21:12.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.649]                     {
[10:21:12.649]                       inherits <- base::inherits
[10:21:12.649]                       invokeRestart <- base::invokeRestart
[10:21:12.649]                       is.null <- base::is.null
[10:21:12.649]                       muffled <- FALSE
[10:21:12.649]                       if (inherits(cond, "message")) {
[10:21:12.649]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.649]                         if (muffled) 
[10:21:12.649]                           invokeRestart("muffleMessage")
[10:21:12.649]                       }
[10:21:12.649]                       else if (inherits(cond, "warning")) {
[10:21:12.649]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.649]                         if (muffled) 
[10:21:12.649]                           invokeRestart("muffleWarning")
[10:21:12.649]                       }
[10:21:12.649]                       else if (inherits(cond, "condition")) {
[10:21:12.649]                         if (!is.null(pattern)) {
[10:21:12.649]                           computeRestarts <- base::computeRestarts
[10:21:12.649]                           grepl <- base::grepl
[10:21:12.649]                           restarts <- computeRestarts(cond)
[10:21:12.649]                           for (restart in restarts) {
[10:21:12.649]                             name <- restart$name
[10:21:12.649]                             if (is.null(name)) 
[10:21:12.649]                               next
[10:21:12.649]                             if (!grepl(pattern, name)) 
[10:21:12.649]                               next
[10:21:12.649]                             invokeRestart(restart)
[10:21:12.649]                             muffled <- TRUE
[10:21:12.649]                             break
[10:21:12.649]                           }
[10:21:12.649]                         }
[10:21:12.649]                       }
[10:21:12.649]                       invisible(muffled)
[10:21:12.649]                     }
[10:21:12.649]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.649]                   }
[10:21:12.649]                 }
[10:21:12.649]                 else {
[10:21:12.649]                   if (TRUE) {
[10:21:12.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.649]                     {
[10:21:12.649]                       inherits <- base::inherits
[10:21:12.649]                       invokeRestart <- base::invokeRestart
[10:21:12.649]                       is.null <- base::is.null
[10:21:12.649]                       muffled <- FALSE
[10:21:12.649]                       if (inherits(cond, "message")) {
[10:21:12.649]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.649]                         if (muffled) 
[10:21:12.649]                           invokeRestart("muffleMessage")
[10:21:12.649]                       }
[10:21:12.649]                       else if (inherits(cond, "warning")) {
[10:21:12.649]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.649]                         if (muffled) 
[10:21:12.649]                           invokeRestart("muffleWarning")
[10:21:12.649]                       }
[10:21:12.649]                       else if (inherits(cond, "condition")) {
[10:21:12.649]                         if (!is.null(pattern)) {
[10:21:12.649]                           computeRestarts <- base::computeRestarts
[10:21:12.649]                           grepl <- base::grepl
[10:21:12.649]                           restarts <- computeRestarts(cond)
[10:21:12.649]                           for (restart in restarts) {
[10:21:12.649]                             name <- restart$name
[10:21:12.649]                             if (is.null(name)) 
[10:21:12.649]                               next
[10:21:12.649]                             if (!grepl(pattern, name)) 
[10:21:12.649]                               next
[10:21:12.649]                             invokeRestart(restart)
[10:21:12.649]                             muffled <- TRUE
[10:21:12.649]                             break
[10:21:12.649]                           }
[10:21:12.649]                         }
[10:21:12.649]                       }
[10:21:12.649]                       invisible(muffled)
[10:21:12.649]                     }
[10:21:12.649]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.649]                   }
[10:21:12.649]                 }
[10:21:12.649]             }
[10:21:12.649]         }))
[10:21:12.649]     }, error = function(ex) {
[10:21:12.649]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:12.649]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.649]                 ...future.rng), started = ...future.startTime, 
[10:21:12.649]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:12.649]             version = "1.8"), class = "FutureResult")
[10:21:12.649]     }, finally = {
[10:21:12.649]         if (!identical(...future.workdir, getwd())) 
[10:21:12.649]             setwd(...future.workdir)
[10:21:12.649]         {
[10:21:12.649]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:12.649]                 ...future.oldOptions$nwarnings <- NULL
[10:21:12.649]             }
[10:21:12.649]             base::options(...future.oldOptions)
[10:21:12.649]             if (.Platform$OS.type == "windows") {
[10:21:12.649]                 old_names <- names(...future.oldEnvVars)
[10:21:12.649]                 envs <- base::Sys.getenv()
[10:21:12.649]                 names <- names(envs)
[10:21:12.649]                 common <- intersect(names, old_names)
[10:21:12.649]                 added <- setdiff(names, old_names)
[10:21:12.649]                 removed <- setdiff(old_names, names)
[10:21:12.649]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:12.649]                   envs[common]]
[10:21:12.649]                 NAMES <- toupper(changed)
[10:21:12.649]                 args <- list()
[10:21:12.649]                 for (kk in seq_along(NAMES)) {
[10:21:12.649]                   name <- changed[[kk]]
[10:21:12.649]                   NAME <- NAMES[[kk]]
[10:21:12.649]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.649]                     next
[10:21:12.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.649]                 }
[10:21:12.649]                 NAMES <- toupper(added)
[10:21:12.649]                 for (kk in seq_along(NAMES)) {
[10:21:12.649]                   name <- added[[kk]]
[10:21:12.649]                   NAME <- NAMES[[kk]]
[10:21:12.649]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.649]                     next
[10:21:12.649]                   args[[name]] <- ""
[10:21:12.649]                 }
[10:21:12.649]                 NAMES <- toupper(removed)
[10:21:12.649]                 for (kk in seq_along(NAMES)) {
[10:21:12.649]                   name <- removed[[kk]]
[10:21:12.649]                   NAME <- NAMES[[kk]]
[10:21:12.649]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.649]                     next
[10:21:12.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.649]                 }
[10:21:12.649]                 if (length(args) > 0) 
[10:21:12.649]                   base::do.call(base::Sys.setenv, args = args)
[10:21:12.649]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:12.649]             }
[10:21:12.649]             else {
[10:21:12.649]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:12.649]             }
[10:21:12.649]             {
[10:21:12.649]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:12.649]                   0L) {
[10:21:12.649]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:12.649]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:12.649]                   base::options(opts)
[10:21:12.649]                 }
[10:21:12.649]                 {
[10:21:12.649]                   {
[10:21:12.649]                     NULL
[10:21:12.649]                     RNGkind("Mersenne-Twister")
[10:21:12.649]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:12.649]                       inherits = FALSE)
[10:21:12.649]                   }
[10:21:12.649]                   options(future.plan = NULL)
[10:21:12.649]                   if (is.na(NA_character_)) 
[10:21:12.649]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.649]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:12.649]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:12.649]                     .init = FALSE)
[10:21:12.649]                 }
[10:21:12.649]             }
[10:21:12.649]         }
[10:21:12.649]     })
[10:21:12.649]     if (TRUE) {
[10:21:12.649]         base::sink(type = "output", split = FALSE)
[10:21:12.649]         if (TRUE) {
[10:21:12.649]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:12.649]         }
[10:21:12.649]         else {
[10:21:12.649]             ...future.result["stdout"] <- base::list(NULL)
[10:21:12.649]         }
[10:21:12.649]         base::close(...future.stdout)
[10:21:12.649]         ...future.stdout <- NULL
[10:21:12.649]     }
[10:21:12.649]     ...future.result$conditions <- ...future.conditions
[10:21:12.649]     ...future.result$finished <- base::Sys.time()
[10:21:12.649]     ...future.result
[10:21:12.649] }
[10:21:12.651] plan(): Setting new future strategy stack:
[10:21:12.651] List of future strategies:
[10:21:12.651] 1. sequential:
[10:21:12.651]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.651]    - tweaked: FALSE
[10:21:12.651]    - call: NULL
[10:21:12.651] plan(): nbrOfWorkers() = 1
[10:21:12.652] plan(): Setting new future strategy stack:
[10:21:12.652] List of future strategies:
[10:21:12.652] 1. sequential:
[10:21:12.652]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.652]    - tweaked: FALSE
[10:21:12.652]    - call: plan(strategy)
[10:21:12.652] plan(): nbrOfWorkers() = 1
[10:21:12.653] SequentialFuture started (and completed)
[10:21:12.653] - Launch lazy future ... done
[10:21:12.653] run() for ‘SequentialFuture’ ... done
[10:21:12.653] getGlobalsAndPackages() ...
[10:21:12.653] Searching for globals...
[10:21:12.654] - globals found: [1] ‘{’
[10:21:12.654] Searching for globals ... DONE
[10:21:12.654] Resolving globals: FALSE
[10:21:12.654] 
[10:21:12.654] 
[10:21:12.654] getGlobalsAndPackages() ... DONE
[10:21:12.654] run() for ‘Future’ ...
[10:21:12.654] - state: ‘created’
[10:21:12.655] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:12.655] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:12.655] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:12.655]   - Field: ‘label’
[10:21:12.655]   - Field: ‘local’
[10:21:12.655]   - Field: ‘owner’
[10:21:12.655]   - Field: ‘envir’
[10:21:12.655]   - Field: ‘packages’
[10:21:12.655]   - Field: ‘gc’
[10:21:12.655]   - Field: ‘conditions’
[10:21:12.656]   - Field: ‘expr’
[10:21:12.656]   - Field: ‘uuid’
[10:21:12.656]   - Field: ‘seed’
[10:21:12.656]   - Field: ‘version’
[10:21:12.656]   - Field: ‘result’
[10:21:12.656]   - Field: ‘asynchronous’
[10:21:12.656]   - Field: ‘calls’
[10:21:12.656]   - Field: ‘globals’
[10:21:12.656]   - Field: ‘stdout’
[10:21:12.656]   - Field: ‘earlySignal’
[10:21:12.656]   - Field: ‘lazy’
[10:21:12.656]   - Field: ‘state’
[10:21:12.656] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:12.657] - Launch lazy future ...
[10:21:12.657] Packages needed by the future expression (n = 0): <none>
[10:21:12.657] Packages needed by future strategies (n = 0): <none>
[10:21:12.657] {
[10:21:12.657]     {
[10:21:12.657]         {
[10:21:12.657]             ...future.startTime <- base::Sys.time()
[10:21:12.657]             {
[10:21:12.657]                 {
[10:21:12.657]                   {
[10:21:12.657]                     base::local({
[10:21:12.657]                       has_future <- base::requireNamespace("future", 
[10:21:12.657]                         quietly = TRUE)
[10:21:12.657]                       if (has_future) {
[10:21:12.657]                         ns <- base::getNamespace("future")
[10:21:12.657]                         version <- ns[[".package"]][["version"]]
[10:21:12.657]                         if (is.null(version)) 
[10:21:12.657]                           version <- utils::packageVersion("future")
[10:21:12.657]                       }
[10:21:12.657]                       else {
[10:21:12.657]                         version <- NULL
[10:21:12.657]                       }
[10:21:12.657]                       if (!has_future || version < "1.8.0") {
[10:21:12.657]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:12.657]                           "", base::R.version$version.string), 
[10:21:12.657]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:12.657]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:12.657]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:12.657]                             "release", "version")], collapse = " "), 
[10:21:12.657]                           hostname = base::Sys.info()[["nodename"]])
[10:21:12.657]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:12.657]                           info)
[10:21:12.657]                         info <- base::paste(info, collapse = "; ")
[10:21:12.657]                         if (!has_future) {
[10:21:12.657]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:12.657]                             info)
[10:21:12.657]                         }
[10:21:12.657]                         else {
[10:21:12.657]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:12.657]                             info, version)
[10:21:12.657]                         }
[10:21:12.657]                         base::stop(msg)
[10:21:12.657]                       }
[10:21:12.657]                     })
[10:21:12.657]                   }
[10:21:12.657]                   ...future.strategy.old <- future::plan("list")
[10:21:12.657]                   options(future.plan = NULL)
[10:21:12.657]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.657]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:12.657]                 }
[10:21:12.657]                 ...future.workdir <- getwd()
[10:21:12.657]             }
[10:21:12.657]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:12.657]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:12.657]         }
[10:21:12.657]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:12.657]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:12.657]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:12.657]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:12.657]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:12.657]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:12.657]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:12.657]             base::names(...future.oldOptions))
[10:21:12.657]     }
[10:21:12.657]     if (FALSE) {
[10:21:12.657]     }
[10:21:12.657]     else {
[10:21:12.657]         if (TRUE) {
[10:21:12.657]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:12.657]                 open = "w")
[10:21:12.657]         }
[10:21:12.657]         else {
[10:21:12.657]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:12.657]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:12.657]         }
[10:21:12.657]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:12.657]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:12.657]             base::sink(type = "output", split = FALSE)
[10:21:12.657]             base::close(...future.stdout)
[10:21:12.657]         }, add = TRUE)
[10:21:12.657]     }
[10:21:12.657]     ...future.frame <- base::sys.nframe()
[10:21:12.657]     ...future.conditions <- base::list()
[10:21:12.657]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:12.657]     if (FALSE) {
[10:21:12.657]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:12.657]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:12.657]     }
[10:21:12.657]     ...future.result <- base::tryCatch({
[10:21:12.657]         base::withCallingHandlers({
[10:21:12.657]             ...future.value <- base::withVisible(base::local({
[10:21:12.657]                 4
[10:21:12.657]             }))
[10:21:12.657]             future::FutureResult(value = ...future.value$value, 
[10:21:12.657]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.657]                   ...future.rng), globalenv = if (FALSE) 
[10:21:12.657]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:12.657]                     ...future.globalenv.names))
[10:21:12.657]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:12.657]         }, condition = base::local({
[10:21:12.657]             c <- base::c
[10:21:12.657]             inherits <- base::inherits
[10:21:12.657]             invokeRestart <- base::invokeRestart
[10:21:12.657]             length <- base::length
[10:21:12.657]             list <- base::list
[10:21:12.657]             seq.int <- base::seq.int
[10:21:12.657]             signalCondition <- base::signalCondition
[10:21:12.657]             sys.calls <- base::sys.calls
[10:21:12.657]             `[[` <- base::`[[`
[10:21:12.657]             `+` <- base::`+`
[10:21:12.657]             `<<-` <- base::`<<-`
[10:21:12.657]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:12.657]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:12.657]                   3L)]
[10:21:12.657]             }
[10:21:12.657]             function(cond) {
[10:21:12.657]                 is_error <- inherits(cond, "error")
[10:21:12.657]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:12.657]                   NULL)
[10:21:12.657]                 if (is_error) {
[10:21:12.657]                   sessionInformation <- function() {
[10:21:12.657]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:12.657]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:12.657]                       search = base::search(), system = base::Sys.info())
[10:21:12.657]                   }
[10:21:12.657]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.657]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:12.657]                     cond$call), session = sessionInformation(), 
[10:21:12.657]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:12.657]                   signalCondition(cond)
[10:21:12.657]                 }
[10:21:12.657]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:12.657]                 "immediateCondition"))) {
[10:21:12.657]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:12.657]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.657]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:12.657]                   if (TRUE && !signal) {
[10:21:12.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.657]                     {
[10:21:12.657]                       inherits <- base::inherits
[10:21:12.657]                       invokeRestart <- base::invokeRestart
[10:21:12.657]                       is.null <- base::is.null
[10:21:12.657]                       muffled <- FALSE
[10:21:12.657]                       if (inherits(cond, "message")) {
[10:21:12.657]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.657]                         if (muffled) 
[10:21:12.657]                           invokeRestart("muffleMessage")
[10:21:12.657]                       }
[10:21:12.657]                       else if (inherits(cond, "warning")) {
[10:21:12.657]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.657]                         if (muffled) 
[10:21:12.657]                           invokeRestart("muffleWarning")
[10:21:12.657]                       }
[10:21:12.657]                       else if (inherits(cond, "condition")) {
[10:21:12.657]                         if (!is.null(pattern)) {
[10:21:12.657]                           computeRestarts <- base::computeRestarts
[10:21:12.657]                           grepl <- base::grepl
[10:21:12.657]                           restarts <- computeRestarts(cond)
[10:21:12.657]                           for (restart in restarts) {
[10:21:12.657]                             name <- restart$name
[10:21:12.657]                             if (is.null(name)) 
[10:21:12.657]                               next
[10:21:12.657]                             if (!grepl(pattern, name)) 
[10:21:12.657]                               next
[10:21:12.657]                             invokeRestart(restart)
[10:21:12.657]                             muffled <- TRUE
[10:21:12.657]                             break
[10:21:12.657]                           }
[10:21:12.657]                         }
[10:21:12.657]                       }
[10:21:12.657]                       invisible(muffled)
[10:21:12.657]                     }
[10:21:12.657]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.657]                   }
[10:21:12.657]                 }
[10:21:12.657]                 else {
[10:21:12.657]                   if (TRUE) {
[10:21:12.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.657]                     {
[10:21:12.657]                       inherits <- base::inherits
[10:21:12.657]                       invokeRestart <- base::invokeRestart
[10:21:12.657]                       is.null <- base::is.null
[10:21:12.657]                       muffled <- FALSE
[10:21:12.657]                       if (inherits(cond, "message")) {
[10:21:12.657]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.657]                         if (muffled) 
[10:21:12.657]                           invokeRestart("muffleMessage")
[10:21:12.657]                       }
[10:21:12.657]                       else if (inherits(cond, "warning")) {
[10:21:12.657]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.657]                         if (muffled) 
[10:21:12.657]                           invokeRestart("muffleWarning")
[10:21:12.657]                       }
[10:21:12.657]                       else if (inherits(cond, "condition")) {
[10:21:12.657]                         if (!is.null(pattern)) {
[10:21:12.657]                           computeRestarts <- base::computeRestarts
[10:21:12.657]                           grepl <- base::grepl
[10:21:12.657]                           restarts <- computeRestarts(cond)
[10:21:12.657]                           for (restart in restarts) {
[10:21:12.657]                             name <- restart$name
[10:21:12.657]                             if (is.null(name)) 
[10:21:12.657]                               next
[10:21:12.657]                             if (!grepl(pattern, name)) 
[10:21:12.657]                               next
[10:21:12.657]                             invokeRestart(restart)
[10:21:12.657]                             muffled <- TRUE
[10:21:12.657]                             break
[10:21:12.657]                           }
[10:21:12.657]                         }
[10:21:12.657]                       }
[10:21:12.657]                       invisible(muffled)
[10:21:12.657]                     }
[10:21:12.657]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.657]                   }
[10:21:12.657]                 }
[10:21:12.657]             }
[10:21:12.657]         }))
[10:21:12.657]     }, error = function(ex) {
[10:21:12.657]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:12.657]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.657]                 ...future.rng), started = ...future.startTime, 
[10:21:12.657]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:12.657]             version = "1.8"), class = "FutureResult")
[10:21:12.657]     }, finally = {
[10:21:12.657]         if (!identical(...future.workdir, getwd())) 
[10:21:12.657]             setwd(...future.workdir)
[10:21:12.657]         {
[10:21:12.657]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:12.657]                 ...future.oldOptions$nwarnings <- NULL
[10:21:12.657]             }
[10:21:12.657]             base::options(...future.oldOptions)
[10:21:12.657]             if (.Platform$OS.type == "windows") {
[10:21:12.657]                 old_names <- names(...future.oldEnvVars)
[10:21:12.657]                 envs <- base::Sys.getenv()
[10:21:12.657]                 names <- names(envs)
[10:21:12.657]                 common <- intersect(names, old_names)
[10:21:12.657]                 added <- setdiff(names, old_names)
[10:21:12.657]                 removed <- setdiff(old_names, names)
[10:21:12.657]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:12.657]                   envs[common]]
[10:21:12.657]                 NAMES <- toupper(changed)
[10:21:12.657]                 args <- list()
[10:21:12.657]                 for (kk in seq_along(NAMES)) {
[10:21:12.657]                   name <- changed[[kk]]
[10:21:12.657]                   NAME <- NAMES[[kk]]
[10:21:12.657]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.657]                     next
[10:21:12.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.657]                 }
[10:21:12.657]                 NAMES <- toupper(added)
[10:21:12.657]                 for (kk in seq_along(NAMES)) {
[10:21:12.657]                   name <- added[[kk]]
[10:21:12.657]                   NAME <- NAMES[[kk]]
[10:21:12.657]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.657]                     next
[10:21:12.657]                   args[[name]] <- ""
[10:21:12.657]                 }
[10:21:12.657]                 NAMES <- toupper(removed)
[10:21:12.657]                 for (kk in seq_along(NAMES)) {
[10:21:12.657]                   name <- removed[[kk]]
[10:21:12.657]                   NAME <- NAMES[[kk]]
[10:21:12.657]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.657]                     next
[10:21:12.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.657]                 }
[10:21:12.657]                 if (length(args) > 0) 
[10:21:12.657]                   base::do.call(base::Sys.setenv, args = args)
[10:21:12.657]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:12.657]             }
[10:21:12.657]             else {
[10:21:12.657]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:12.657]             }
[10:21:12.657]             {
[10:21:12.657]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:12.657]                   0L) {
[10:21:12.657]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:12.657]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:12.657]                   base::options(opts)
[10:21:12.657]                 }
[10:21:12.657]                 {
[10:21:12.657]                   {
[10:21:12.657]                     NULL
[10:21:12.657]                     RNGkind("Mersenne-Twister")
[10:21:12.657]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:12.657]                       inherits = FALSE)
[10:21:12.657]                   }
[10:21:12.657]                   options(future.plan = NULL)
[10:21:12.657]                   if (is.na(NA_character_)) 
[10:21:12.657]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.657]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:12.657]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:12.657]                     .init = FALSE)
[10:21:12.657]                 }
[10:21:12.657]             }
[10:21:12.657]         }
[10:21:12.657]     })
[10:21:12.657]     if (TRUE) {
[10:21:12.657]         base::sink(type = "output", split = FALSE)
[10:21:12.657]         if (TRUE) {
[10:21:12.657]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:12.657]         }
[10:21:12.657]         else {
[10:21:12.657]             ...future.result["stdout"] <- base::list(NULL)
[10:21:12.657]         }
[10:21:12.657]         base::close(...future.stdout)
[10:21:12.657]         ...future.stdout <- NULL
[10:21:12.657]     }
[10:21:12.657]     ...future.result$conditions <- ...future.conditions
[10:21:12.657]     ...future.result$finished <- base::Sys.time()
[10:21:12.657]     ...future.result
[10:21:12.657] }
[10:21:12.659] plan(): Setting new future strategy stack:
[10:21:12.659] List of future strategies:
[10:21:12.659] 1. sequential:
[10:21:12.659]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.659]    - tweaked: FALSE
[10:21:12.659]    - call: NULL
[10:21:12.659] plan(): nbrOfWorkers() = 1
[10:21:12.660] plan(): Setting new future strategy stack:
[10:21:12.660] List of future strategies:
[10:21:12.660] 1. sequential:
[10:21:12.660]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.660]    - tweaked: FALSE
[10:21:12.660]    - call: plan(strategy)
[10:21:12.661] plan(): nbrOfWorkers() = 1
[10:21:12.661] SequentialFuture started (and completed)
[10:21:12.661] - Launch lazy future ... done
[10:21:12.661] run() for ‘SequentialFuture’ ... done
u$a = 2
v$a = 4
[10:21:12.661] getGlobalsAndPackages() ...
[10:21:12.661] Searching for globals...
[10:21:12.662] - globals found: [3] ‘{’, ‘*’, ‘a’
[10:21:12.662] Searching for globals ... DONE
[10:21:12.662] Resolving globals: FALSE
[10:21:12.663] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:12.663] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:12.663] - globals: [1] ‘a’
[10:21:12.664] 
[10:21:12.664] getGlobalsAndPackages() ... DONE
[10:21:12.664] run() for ‘Future’ ...
[10:21:12.664] - state: ‘created’
[10:21:12.664] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:12.664] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:12.664] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:12.664]   - Field: ‘label’
[10:21:12.665]   - Field: ‘local’
[10:21:12.665]   - Field: ‘owner’
[10:21:12.665]   - Field: ‘envir’
[10:21:12.665]   - Field: ‘packages’
[10:21:12.665]   - Field: ‘gc’
[10:21:12.665]   - Field: ‘conditions’
[10:21:12.665]   - Field: ‘expr’
[10:21:12.665]   - Field: ‘uuid’
[10:21:12.665]   - Field: ‘seed’
[10:21:12.665]   - Field: ‘version’
[10:21:12.665]   - Field: ‘result’
[10:21:12.665]   - Field: ‘asynchronous’
[10:21:12.666]   - Field: ‘calls’
[10:21:12.666]   - Field: ‘globals’
[10:21:12.666]   - Field: ‘stdout’
[10:21:12.666]   - Field: ‘earlySignal’
[10:21:12.666]   - Field: ‘lazy’
[10:21:12.666]   - Field: ‘state’
[10:21:12.666] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:12.666] - Launch lazy future ...
[10:21:12.666] Packages needed by the future expression (n = 0): <none>
[10:21:12.666] Packages needed by future strategies (n = 0): <none>
[10:21:12.667] {
[10:21:12.667]     {
[10:21:12.667]         {
[10:21:12.667]             ...future.startTime <- base::Sys.time()
[10:21:12.667]             {
[10:21:12.667]                 {
[10:21:12.667]                   {
[10:21:12.667]                     base::local({
[10:21:12.667]                       has_future <- base::requireNamespace("future", 
[10:21:12.667]                         quietly = TRUE)
[10:21:12.667]                       if (has_future) {
[10:21:12.667]                         ns <- base::getNamespace("future")
[10:21:12.667]                         version <- ns[[".package"]][["version"]]
[10:21:12.667]                         if (is.null(version)) 
[10:21:12.667]                           version <- utils::packageVersion("future")
[10:21:12.667]                       }
[10:21:12.667]                       else {
[10:21:12.667]                         version <- NULL
[10:21:12.667]                       }
[10:21:12.667]                       if (!has_future || version < "1.8.0") {
[10:21:12.667]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:12.667]                           "", base::R.version$version.string), 
[10:21:12.667]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:12.667]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:12.667]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:12.667]                             "release", "version")], collapse = " "), 
[10:21:12.667]                           hostname = base::Sys.info()[["nodename"]])
[10:21:12.667]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:12.667]                           info)
[10:21:12.667]                         info <- base::paste(info, collapse = "; ")
[10:21:12.667]                         if (!has_future) {
[10:21:12.667]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:12.667]                             info)
[10:21:12.667]                         }
[10:21:12.667]                         else {
[10:21:12.667]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:12.667]                             info, version)
[10:21:12.667]                         }
[10:21:12.667]                         base::stop(msg)
[10:21:12.667]                       }
[10:21:12.667]                     })
[10:21:12.667]                   }
[10:21:12.667]                   ...future.strategy.old <- future::plan("list")
[10:21:12.667]                   options(future.plan = NULL)
[10:21:12.667]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.667]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:12.667]                 }
[10:21:12.667]                 ...future.workdir <- getwd()
[10:21:12.667]             }
[10:21:12.667]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:12.667]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:12.667]         }
[10:21:12.667]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:12.667]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:12.667]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:12.667]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:12.667]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:12.667]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:12.667]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:12.667]             base::names(...future.oldOptions))
[10:21:12.667]     }
[10:21:12.667]     if (FALSE) {
[10:21:12.667]     }
[10:21:12.667]     else {
[10:21:12.667]         if (TRUE) {
[10:21:12.667]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:12.667]                 open = "w")
[10:21:12.667]         }
[10:21:12.667]         else {
[10:21:12.667]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:12.667]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:12.667]         }
[10:21:12.667]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:12.667]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:12.667]             base::sink(type = "output", split = FALSE)
[10:21:12.667]             base::close(...future.stdout)
[10:21:12.667]         }, add = TRUE)
[10:21:12.667]     }
[10:21:12.667]     ...future.frame <- base::sys.nframe()
[10:21:12.667]     ...future.conditions <- base::list()
[10:21:12.667]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:12.667]     if (FALSE) {
[10:21:12.667]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:12.667]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:12.667]     }
[10:21:12.667]     ...future.result <- base::tryCatch({
[10:21:12.667]         base::withCallingHandlers({
[10:21:12.667]             ...future.value <- base::withVisible(base::local({
[10:21:12.667]                 2 * a
[10:21:12.667]             }))
[10:21:12.667]             future::FutureResult(value = ...future.value$value, 
[10:21:12.667]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.667]                   ...future.rng), globalenv = if (FALSE) 
[10:21:12.667]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:12.667]                     ...future.globalenv.names))
[10:21:12.667]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:12.667]         }, condition = base::local({
[10:21:12.667]             c <- base::c
[10:21:12.667]             inherits <- base::inherits
[10:21:12.667]             invokeRestart <- base::invokeRestart
[10:21:12.667]             length <- base::length
[10:21:12.667]             list <- base::list
[10:21:12.667]             seq.int <- base::seq.int
[10:21:12.667]             signalCondition <- base::signalCondition
[10:21:12.667]             sys.calls <- base::sys.calls
[10:21:12.667]             `[[` <- base::`[[`
[10:21:12.667]             `+` <- base::`+`
[10:21:12.667]             `<<-` <- base::`<<-`
[10:21:12.667]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:12.667]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:12.667]                   3L)]
[10:21:12.667]             }
[10:21:12.667]             function(cond) {
[10:21:12.667]                 is_error <- inherits(cond, "error")
[10:21:12.667]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:12.667]                   NULL)
[10:21:12.667]                 if (is_error) {
[10:21:12.667]                   sessionInformation <- function() {
[10:21:12.667]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:12.667]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:12.667]                       search = base::search(), system = base::Sys.info())
[10:21:12.667]                   }
[10:21:12.667]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.667]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:12.667]                     cond$call), session = sessionInformation(), 
[10:21:12.667]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:12.667]                   signalCondition(cond)
[10:21:12.667]                 }
[10:21:12.667]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:12.667]                 "immediateCondition"))) {
[10:21:12.667]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:12.667]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.667]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:12.667]                   if (TRUE && !signal) {
[10:21:12.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.667]                     {
[10:21:12.667]                       inherits <- base::inherits
[10:21:12.667]                       invokeRestart <- base::invokeRestart
[10:21:12.667]                       is.null <- base::is.null
[10:21:12.667]                       muffled <- FALSE
[10:21:12.667]                       if (inherits(cond, "message")) {
[10:21:12.667]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.667]                         if (muffled) 
[10:21:12.667]                           invokeRestart("muffleMessage")
[10:21:12.667]                       }
[10:21:12.667]                       else if (inherits(cond, "warning")) {
[10:21:12.667]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.667]                         if (muffled) 
[10:21:12.667]                           invokeRestart("muffleWarning")
[10:21:12.667]                       }
[10:21:12.667]                       else if (inherits(cond, "condition")) {
[10:21:12.667]                         if (!is.null(pattern)) {
[10:21:12.667]                           computeRestarts <- base::computeRestarts
[10:21:12.667]                           grepl <- base::grepl
[10:21:12.667]                           restarts <- computeRestarts(cond)
[10:21:12.667]                           for (restart in restarts) {
[10:21:12.667]                             name <- restart$name
[10:21:12.667]                             if (is.null(name)) 
[10:21:12.667]                               next
[10:21:12.667]                             if (!grepl(pattern, name)) 
[10:21:12.667]                               next
[10:21:12.667]                             invokeRestart(restart)
[10:21:12.667]                             muffled <- TRUE
[10:21:12.667]                             break
[10:21:12.667]                           }
[10:21:12.667]                         }
[10:21:12.667]                       }
[10:21:12.667]                       invisible(muffled)
[10:21:12.667]                     }
[10:21:12.667]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.667]                   }
[10:21:12.667]                 }
[10:21:12.667]                 else {
[10:21:12.667]                   if (TRUE) {
[10:21:12.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.667]                     {
[10:21:12.667]                       inherits <- base::inherits
[10:21:12.667]                       invokeRestart <- base::invokeRestart
[10:21:12.667]                       is.null <- base::is.null
[10:21:12.667]                       muffled <- FALSE
[10:21:12.667]                       if (inherits(cond, "message")) {
[10:21:12.667]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.667]                         if (muffled) 
[10:21:12.667]                           invokeRestart("muffleMessage")
[10:21:12.667]                       }
[10:21:12.667]                       else if (inherits(cond, "warning")) {
[10:21:12.667]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.667]                         if (muffled) 
[10:21:12.667]                           invokeRestart("muffleWarning")
[10:21:12.667]                       }
[10:21:12.667]                       else if (inherits(cond, "condition")) {
[10:21:12.667]                         if (!is.null(pattern)) {
[10:21:12.667]                           computeRestarts <- base::computeRestarts
[10:21:12.667]                           grepl <- base::grepl
[10:21:12.667]                           restarts <- computeRestarts(cond)
[10:21:12.667]                           for (restart in restarts) {
[10:21:12.667]                             name <- restart$name
[10:21:12.667]                             if (is.null(name)) 
[10:21:12.667]                               next
[10:21:12.667]                             if (!grepl(pattern, name)) 
[10:21:12.667]                               next
[10:21:12.667]                             invokeRestart(restart)
[10:21:12.667]                             muffled <- TRUE
[10:21:12.667]                             break
[10:21:12.667]                           }
[10:21:12.667]                         }
[10:21:12.667]                       }
[10:21:12.667]                       invisible(muffled)
[10:21:12.667]                     }
[10:21:12.667]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.667]                   }
[10:21:12.667]                 }
[10:21:12.667]             }
[10:21:12.667]         }))
[10:21:12.667]     }, error = function(ex) {
[10:21:12.667]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:12.667]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.667]                 ...future.rng), started = ...future.startTime, 
[10:21:12.667]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:12.667]             version = "1.8"), class = "FutureResult")
[10:21:12.667]     }, finally = {
[10:21:12.667]         if (!identical(...future.workdir, getwd())) 
[10:21:12.667]             setwd(...future.workdir)
[10:21:12.667]         {
[10:21:12.667]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:12.667]                 ...future.oldOptions$nwarnings <- NULL
[10:21:12.667]             }
[10:21:12.667]             base::options(...future.oldOptions)
[10:21:12.667]             if (.Platform$OS.type == "windows") {
[10:21:12.667]                 old_names <- names(...future.oldEnvVars)
[10:21:12.667]                 envs <- base::Sys.getenv()
[10:21:12.667]                 names <- names(envs)
[10:21:12.667]                 common <- intersect(names, old_names)
[10:21:12.667]                 added <- setdiff(names, old_names)
[10:21:12.667]                 removed <- setdiff(old_names, names)
[10:21:12.667]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:12.667]                   envs[common]]
[10:21:12.667]                 NAMES <- toupper(changed)
[10:21:12.667]                 args <- list()
[10:21:12.667]                 for (kk in seq_along(NAMES)) {
[10:21:12.667]                   name <- changed[[kk]]
[10:21:12.667]                   NAME <- NAMES[[kk]]
[10:21:12.667]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.667]                     next
[10:21:12.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.667]                 }
[10:21:12.667]                 NAMES <- toupper(added)
[10:21:12.667]                 for (kk in seq_along(NAMES)) {
[10:21:12.667]                   name <- added[[kk]]
[10:21:12.667]                   NAME <- NAMES[[kk]]
[10:21:12.667]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.667]                     next
[10:21:12.667]                   args[[name]] <- ""
[10:21:12.667]                 }
[10:21:12.667]                 NAMES <- toupper(removed)
[10:21:12.667]                 for (kk in seq_along(NAMES)) {
[10:21:12.667]                   name <- removed[[kk]]
[10:21:12.667]                   NAME <- NAMES[[kk]]
[10:21:12.667]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.667]                     next
[10:21:12.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.667]                 }
[10:21:12.667]                 if (length(args) > 0) 
[10:21:12.667]                   base::do.call(base::Sys.setenv, args = args)
[10:21:12.667]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:12.667]             }
[10:21:12.667]             else {
[10:21:12.667]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:12.667]             }
[10:21:12.667]             {
[10:21:12.667]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:12.667]                   0L) {
[10:21:12.667]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:12.667]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:12.667]                   base::options(opts)
[10:21:12.667]                 }
[10:21:12.667]                 {
[10:21:12.667]                   {
[10:21:12.667]                     NULL
[10:21:12.667]                     RNGkind("Mersenne-Twister")
[10:21:12.667]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:12.667]                       inherits = FALSE)
[10:21:12.667]                   }
[10:21:12.667]                   options(future.plan = NULL)
[10:21:12.667]                   if (is.na(NA_character_)) 
[10:21:12.667]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.667]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:12.667]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:12.667]                     .init = FALSE)
[10:21:12.667]                 }
[10:21:12.667]             }
[10:21:12.667]         }
[10:21:12.667]     })
[10:21:12.667]     if (TRUE) {
[10:21:12.667]         base::sink(type = "output", split = FALSE)
[10:21:12.667]         if (TRUE) {
[10:21:12.667]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:12.667]         }
[10:21:12.667]         else {
[10:21:12.667]             ...future.result["stdout"] <- base::list(NULL)
[10:21:12.667]         }
[10:21:12.667]         base::close(...future.stdout)
[10:21:12.667]         ...future.stdout <- NULL
[10:21:12.667]     }
[10:21:12.667]     ...future.result$conditions <- ...future.conditions
[10:21:12.667]     ...future.result$finished <- base::Sys.time()
[10:21:12.667]     ...future.result
[10:21:12.667] }
[10:21:12.668] assign_globals() ...
[10:21:12.669] List of 1
[10:21:12.669]  $ a: num 1
[10:21:12.669]  - attr(*, "where")=List of 1
[10:21:12.669]   ..$ a:<environment: R_EmptyEnv> 
[10:21:12.669]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:12.669]  - attr(*, "resolved")= logi FALSE
[10:21:12.669]  - attr(*, "total_size")= num 39
[10:21:12.669]  - attr(*, "already-done")= logi TRUE
[10:21:12.674] - copied ‘a’ to environment
[10:21:12.674] assign_globals() ... done
[10:21:12.674] plan(): Setting new future strategy stack:
[10:21:12.674] List of future strategies:
[10:21:12.674] 1. sequential:
[10:21:12.674]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.674]    - tweaked: FALSE
[10:21:12.674]    - call: NULL
[10:21:12.675] plan(): nbrOfWorkers() = 1
[10:21:12.675] plan(): Setting new future strategy stack:
[10:21:12.675] List of future strategies:
[10:21:12.675] 1. sequential:
[10:21:12.675]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.675]    - tweaked: FALSE
[10:21:12.675]    - call: plan(strategy)
[10:21:12.676] plan(): nbrOfWorkers() = 1
[10:21:12.676] SequentialFuture started (and completed)
[10:21:12.676] - Launch lazy future ... done
[10:21:12.676] run() for ‘SequentialFuture’ ... done
[10:21:12.676] getGlobalsAndPackages() ...
[10:21:12.676] Searching for globals...
[10:21:12.677] - globals found: [3] ‘{’, ‘*’, ‘a’
[10:21:12.677] Searching for globals ... DONE
[10:21:12.677] Resolving globals: FALSE
[10:21:12.678] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:12.678] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:12.678] - globals: [1] ‘a’
[10:21:12.678] 
[10:21:12.678] getGlobalsAndPackages() ... DONE
[10:21:12.678] run() for ‘Future’ ...
[10:21:12.678] - state: ‘created’
[10:21:12.679] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:12.679] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:12.679] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:12.679]   - Field: ‘label’
[10:21:12.679]   - Field: ‘local’
[10:21:12.679]   - Field: ‘owner’
[10:21:12.679]   - Field: ‘envir’
[10:21:12.679]   - Field: ‘packages’
[10:21:12.679]   - Field: ‘gc’
[10:21:12.679]   - Field: ‘conditions’
[10:21:12.680]   - Field: ‘expr’
[10:21:12.680]   - Field: ‘uuid’
[10:21:12.680]   - Field: ‘seed’
[10:21:12.680]   - Field: ‘version’
[10:21:12.680]   - Field: ‘result’
[10:21:12.680]   - Field: ‘asynchronous’
[10:21:12.680]   - Field: ‘calls’
[10:21:12.680]   - Field: ‘globals’
[10:21:12.680]   - Field: ‘stdout’
[10:21:12.680]   - Field: ‘earlySignal’
[10:21:12.680]   - Field: ‘lazy’
[10:21:12.680]   - Field: ‘state’
[10:21:12.681] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:12.681] - Launch lazy future ...
[10:21:12.681] Packages needed by the future expression (n = 0): <none>
[10:21:12.681] Packages needed by future strategies (n = 0): <none>
[10:21:12.681] {
[10:21:12.681]     {
[10:21:12.681]         {
[10:21:12.681]             ...future.startTime <- base::Sys.time()
[10:21:12.681]             {
[10:21:12.681]                 {
[10:21:12.681]                   {
[10:21:12.681]                     base::local({
[10:21:12.681]                       has_future <- base::requireNamespace("future", 
[10:21:12.681]                         quietly = TRUE)
[10:21:12.681]                       if (has_future) {
[10:21:12.681]                         ns <- base::getNamespace("future")
[10:21:12.681]                         version <- ns[[".package"]][["version"]]
[10:21:12.681]                         if (is.null(version)) 
[10:21:12.681]                           version <- utils::packageVersion("future")
[10:21:12.681]                       }
[10:21:12.681]                       else {
[10:21:12.681]                         version <- NULL
[10:21:12.681]                       }
[10:21:12.681]                       if (!has_future || version < "1.8.0") {
[10:21:12.681]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:12.681]                           "", base::R.version$version.string), 
[10:21:12.681]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:12.681]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:12.681]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:12.681]                             "release", "version")], collapse = " "), 
[10:21:12.681]                           hostname = base::Sys.info()[["nodename"]])
[10:21:12.681]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:12.681]                           info)
[10:21:12.681]                         info <- base::paste(info, collapse = "; ")
[10:21:12.681]                         if (!has_future) {
[10:21:12.681]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:12.681]                             info)
[10:21:12.681]                         }
[10:21:12.681]                         else {
[10:21:12.681]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:12.681]                             info, version)
[10:21:12.681]                         }
[10:21:12.681]                         base::stop(msg)
[10:21:12.681]                       }
[10:21:12.681]                     })
[10:21:12.681]                   }
[10:21:12.681]                   ...future.strategy.old <- future::plan("list")
[10:21:12.681]                   options(future.plan = NULL)
[10:21:12.681]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.681]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:12.681]                 }
[10:21:12.681]                 ...future.workdir <- getwd()
[10:21:12.681]             }
[10:21:12.681]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:12.681]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:12.681]         }
[10:21:12.681]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:12.681]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:12.681]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:12.681]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:12.681]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:12.681]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:12.681]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:12.681]             base::names(...future.oldOptions))
[10:21:12.681]     }
[10:21:12.681]     if (FALSE) {
[10:21:12.681]     }
[10:21:12.681]     else {
[10:21:12.681]         if (TRUE) {
[10:21:12.681]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:12.681]                 open = "w")
[10:21:12.681]         }
[10:21:12.681]         else {
[10:21:12.681]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:12.681]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:12.681]         }
[10:21:12.681]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:12.681]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:12.681]             base::sink(type = "output", split = FALSE)
[10:21:12.681]             base::close(...future.stdout)
[10:21:12.681]         }, add = TRUE)
[10:21:12.681]     }
[10:21:12.681]     ...future.frame <- base::sys.nframe()
[10:21:12.681]     ...future.conditions <- base::list()
[10:21:12.681]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:12.681]     if (FALSE) {
[10:21:12.681]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:12.681]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:12.681]     }
[10:21:12.681]     ...future.result <- base::tryCatch({
[10:21:12.681]         base::withCallingHandlers({
[10:21:12.681]             ...future.value <- base::withVisible(base::local({
[10:21:12.681]                 2 * a
[10:21:12.681]             }))
[10:21:12.681]             future::FutureResult(value = ...future.value$value, 
[10:21:12.681]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.681]                   ...future.rng), globalenv = if (FALSE) 
[10:21:12.681]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:12.681]                     ...future.globalenv.names))
[10:21:12.681]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:12.681]         }, condition = base::local({
[10:21:12.681]             c <- base::c
[10:21:12.681]             inherits <- base::inherits
[10:21:12.681]             invokeRestart <- base::invokeRestart
[10:21:12.681]             length <- base::length
[10:21:12.681]             list <- base::list
[10:21:12.681]             seq.int <- base::seq.int
[10:21:12.681]             signalCondition <- base::signalCondition
[10:21:12.681]             sys.calls <- base::sys.calls
[10:21:12.681]             `[[` <- base::`[[`
[10:21:12.681]             `+` <- base::`+`
[10:21:12.681]             `<<-` <- base::`<<-`
[10:21:12.681]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:12.681]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:12.681]                   3L)]
[10:21:12.681]             }
[10:21:12.681]             function(cond) {
[10:21:12.681]                 is_error <- inherits(cond, "error")
[10:21:12.681]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:12.681]                   NULL)
[10:21:12.681]                 if (is_error) {
[10:21:12.681]                   sessionInformation <- function() {
[10:21:12.681]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:12.681]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:12.681]                       search = base::search(), system = base::Sys.info())
[10:21:12.681]                   }
[10:21:12.681]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.681]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:12.681]                     cond$call), session = sessionInformation(), 
[10:21:12.681]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:12.681]                   signalCondition(cond)
[10:21:12.681]                 }
[10:21:12.681]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:12.681]                 "immediateCondition"))) {
[10:21:12.681]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:12.681]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.681]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:12.681]                   if (TRUE && !signal) {
[10:21:12.681]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.681]                     {
[10:21:12.681]                       inherits <- base::inherits
[10:21:12.681]                       invokeRestart <- base::invokeRestart
[10:21:12.681]                       is.null <- base::is.null
[10:21:12.681]                       muffled <- FALSE
[10:21:12.681]                       if (inherits(cond, "message")) {
[10:21:12.681]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.681]                         if (muffled) 
[10:21:12.681]                           invokeRestart("muffleMessage")
[10:21:12.681]                       }
[10:21:12.681]                       else if (inherits(cond, "warning")) {
[10:21:12.681]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.681]                         if (muffled) 
[10:21:12.681]                           invokeRestart("muffleWarning")
[10:21:12.681]                       }
[10:21:12.681]                       else if (inherits(cond, "condition")) {
[10:21:12.681]                         if (!is.null(pattern)) {
[10:21:12.681]                           computeRestarts <- base::computeRestarts
[10:21:12.681]                           grepl <- base::grepl
[10:21:12.681]                           restarts <- computeRestarts(cond)
[10:21:12.681]                           for (restart in restarts) {
[10:21:12.681]                             name <- restart$name
[10:21:12.681]                             if (is.null(name)) 
[10:21:12.681]                               next
[10:21:12.681]                             if (!grepl(pattern, name)) 
[10:21:12.681]                               next
[10:21:12.681]                             invokeRestart(restart)
[10:21:12.681]                             muffled <- TRUE
[10:21:12.681]                             break
[10:21:12.681]                           }
[10:21:12.681]                         }
[10:21:12.681]                       }
[10:21:12.681]                       invisible(muffled)
[10:21:12.681]                     }
[10:21:12.681]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.681]                   }
[10:21:12.681]                 }
[10:21:12.681]                 else {
[10:21:12.681]                   if (TRUE) {
[10:21:12.681]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.681]                     {
[10:21:12.681]                       inherits <- base::inherits
[10:21:12.681]                       invokeRestart <- base::invokeRestart
[10:21:12.681]                       is.null <- base::is.null
[10:21:12.681]                       muffled <- FALSE
[10:21:12.681]                       if (inherits(cond, "message")) {
[10:21:12.681]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.681]                         if (muffled) 
[10:21:12.681]                           invokeRestart("muffleMessage")
[10:21:12.681]                       }
[10:21:12.681]                       else if (inherits(cond, "warning")) {
[10:21:12.681]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.681]                         if (muffled) 
[10:21:12.681]                           invokeRestart("muffleWarning")
[10:21:12.681]                       }
[10:21:12.681]                       else if (inherits(cond, "condition")) {
[10:21:12.681]                         if (!is.null(pattern)) {
[10:21:12.681]                           computeRestarts <- base::computeRestarts
[10:21:12.681]                           grepl <- base::grepl
[10:21:12.681]                           restarts <- computeRestarts(cond)
[10:21:12.681]                           for (restart in restarts) {
[10:21:12.681]                             name <- restart$name
[10:21:12.681]                             if (is.null(name)) 
[10:21:12.681]                               next
[10:21:12.681]                             if (!grepl(pattern, name)) 
[10:21:12.681]                               next
[10:21:12.681]                             invokeRestart(restart)
[10:21:12.681]                             muffled <- TRUE
[10:21:12.681]                             break
[10:21:12.681]                           }
[10:21:12.681]                         }
[10:21:12.681]                       }
[10:21:12.681]                       invisible(muffled)
[10:21:12.681]                     }
[10:21:12.681]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.681]                   }
[10:21:12.681]                 }
[10:21:12.681]             }
[10:21:12.681]         }))
[10:21:12.681]     }, error = function(ex) {
[10:21:12.681]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:12.681]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.681]                 ...future.rng), started = ...future.startTime, 
[10:21:12.681]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:12.681]             version = "1.8"), class = "FutureResult")
[10:21:12.681]     }, finally = {
[10:21:12.681]         if (!identical(...future.workdir, getwd())) 
[10:21:12.681]             setwd(...future.workdir)
[10:21:12.681]         {
[10:21:12.681]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:12.681]                 ...future.oldOptions$nwarnings <- NULL
[10:21:12.681]             }
[10:21:12.681]             base::options(...future.oldOptions)
[10:21:12.681]             if (.Platform$OS.type == "windows") {
[10:21:12.681]                 old_names <- names(...future.oldEnvVars)
[10:21:12.681]                 envs <- base::Sys.getenv()
[10:21:12.681]                 names <- names(envs)
[10:21:12.681]                 common <- intersect(names, old_names)
[10:21:12.681]                 added <- setdiff(names, old_names)
[10:21:12.681]                 removed <- setdiff(old_names, names)
[10:21:12.681]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:12.681]                   envs[common]]
[10:21:12.681]                 NAMES <- toupper(changed)
[10:21:12.681]                 args <- list()
[10:21:12.681]                 for (kk in seq_along(NAMES)) {
[10:21:12.681]                   name <- changed[[kk]]
[10:21:12.681]                   NAME <- NAMES[[kk]]
[10:21:12.681]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.681]                     next
[10:21:12.681]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.681]                 }
[10:21:12.681]                 NAMES <- toupper(added)
[10:21:12.681]                 for (kk in seq_along(NAMES)) {
[10:21:12.681]                   name <- added[[kk]]
[10:21:12.681]                   NAME <- NAMES[[kk]]
[10:21:12.681]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.681]                     next
[10:21:12.681]                   args[[name]] <- ""
[10:21:12.681]                 }
[10:21:12.681]                 NAMES <- toupper(removed)
[10:21:12.681]                 for (kk in seq_along(NAMES)) {
[10:21:12.681]                   name <- removed[[kk]]
[10:21:12.681]                   NAME <- NAMES[[kk]]
[10:21:12.681]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.681]                     next
[10:21:12.681]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.681]                 }
[10:21:12.681]                 if (length(args) > 0) 
[10:21:12.681]                   base::do.call(base::Sys.setenv, args = args)
[10:21:12.681]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:12.681]             }
[10:21:12.681]             else {
[10:21:12.681]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:12.681]             }
[10:21:12.681]             {
[10:21:12.681]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:12.681]                   0L) {
[10:21:12.681]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:12.681]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:12.681]                   base::options(opts)
[10:21:12.681]                 }
[10:21:12.681]                 {
[10:21:12.681]                   {
[10:21:12.681]                     NULL
[10:21:12.681]                     RNGkind("Mersenne-Twister")
[10:21:12.681]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:12.681]                       inherits = FALSE)
[10:21:12.681]                   }
[10:21:12.681]                   options(future.plan = NULL)
[10:21:12.681]                   if (is.na(NA_character_)) 
[10:21:12.681]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.681]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:12.681]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:12.681]                     .init = FALSE)
[10:21:12.681]                 }
[10:21:12.681]             }
[10:21:12.681]         }
[10:21:12.681]     })
[10:21:12.681]     if (TRUE) {
[10:21:12.681]         base::sink(type = "output", split = FALSE)
[10:21:12.681]         if (TRUE) {
[10:21:12.681]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:12.681]         }
[10:21:12.681]         else {
[10:21:12.681]             ...future.result["stdout"] <- base::list(NULL)
[10:21:12.681]         }
[10:21:12.681]         base::close(...future.stdout)
[10:21:12.681]         ...future.stdout <- NULL
[10:21:12.681]     }
[10:21:12.681]     ...future.result$conditions <- ...future.conditions
[10:21:12.681]     ...future.result$finished <- base::Sys.time()
[10:21:12.681]     ...future.result
[10:21:12.681] }
[10:21:12.683] assign_globals() ...
[10:21:12.683] List of 1
[10:21:12.683]  $ a: num 1
[10:21:12.683]  - attr(*, "where")=List of 1
[10:21:12.683]   ..$ a:<environment: R_EmptyEnv> 
[10:21:12.683]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:12.683]  - attr(*, "resolved")= logi FALSE
[10:21:12.683]  - attr(*, "total_size")= num 39
[10:21:12.683]  - attr(*, "already-done")= logi TRUE
[10:21:12.685] - copied ‘a’ to environment
[10:21:12.685] assign_globals() ... done
[10:21:12.685] plan(): Setting new future strategy stack:
[10:21:12.686] List of future strategies:
[10:21:12.686] 1. sequential:
[10:21:12.686]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.686]    - tweaked: FALSE
[10:21:12.686]    - call: NULL
[10:21:12.686] plan(): nbrOfWorkers() = 1
[10:21:12.687] plan(): Setting new future strategy stack:
[10:21:12.687] List of future strategies:
[10:21:12.687] 1. sequential:
[10:21:12.687]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.687]    - tweaked: FALSE
[10:21:12.687]    - call: plan(strategy)
[10:21:12.687] plan(): nbrOfWorkers() = 1
[10:21:12.687] SequentialFuture started (and completed)
[10:21:12.687] - Launch lazy future ... done
[10:21:12.687] run() for ‘SequentialFuture’ ... done
[10:21:12.688] getGlobalsAndPackages() ...
[10:21:12.688] Searching for globals...
[10:21:12.688] - globals found: [3] ‘{’, ‘*’, ‘a’
[10:21:12.689] Searching for globals ... DONE
[10:21:12.689] Resolving globals: FALSE
[10:21:12.689] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:12.689] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:12.689] - globals: [1] ‘a’
[10:21:12.689] 
[10:21:12.690] getGlobalsAndPackages() ... DONE
[10:21:12.690] run() for ‘Future’ ...
[10:21:12.690] - state: ‘created’
[10:21:12.690] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:12.690] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:12.690] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:12.690]   - Field: ‘label’
[10:21:12.690]   - Field: ‘local’
[10:21:12.691]   - Field: ‘owner’
[10:21:12.691]   - Field: ‘envir’
[10:21:12.691]   - Field: ‘packages’
[10:21:12.691]   - Field: ‘gc’
[10:21:12.691]   - Field: ‘conditions’
[10:21:12.691]   - Field: ‘expr’
[10:21:12.691]   - Field: ‘uuid’
[10:21:12.691]   - Field: ‘seed’
[10:21:12.691]   - Field: ‘version’
[10:21:12.691]   - Field: ‘result’
[10:21:12.691]   - Field: ‘asynchronous’
[10:21:12.691]   - Field: ‘calls’
[10:21:12.692]   - Field: ‘globals’
[10:21:12.692]   - Field: ‘stdout’
[10:21:12.692]   - Field: ‘earlySignal’
[10:21:12.692]   - Field: ‘lazy’
[10:21:12.692]   - Field: ‘state’
[10:21:12.692] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:12.692] - Launch lazy future ...
[10:21:12.692] Packages needed by the future expression (n = 0): <none>
[10:21:12.692] Packages needed by future strategies (n = 0): <none>
[10:21:12.693] {
[10:21:12.693]     {
[10:21:12.693]         {
[10:21:12.693]             ...future.startTime <- base::Sys.time()
[10:21:12.693]             {
[10:21:12.693]                 {
[10:21:12.693]                   {
[10:21:12.693]                     base::local({
[10:21:12.693]                       has_future <- base::requireNamespace("future", 
[10:21:12.693]                         quietly = TRUE)
[10:21:12.693]                       if (has_future) {
[10:21:12.693]                         ns <- base::getNamespace("future")
[10:21:12.693]                         version <- ns[[".package"]][["version"]]
[10:21:12.693]                         if (is.null(version)) 
[10:21:12.693]                           version <- utils::packageVersion("future")
[10:21:12.693]                       }
[10:21:12.693]                       else {
[10:21:12.693]                         version <- NULL
[10:21:12.693]                       }
[10:21:12.693]                       if (!has_future || version < "1.8.0") {
[10:21:12.693]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:12.693]                           "", base::R.version$version.string), 
[10:21:12.693]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:12.693]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:12.693]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:12.693]                             "release", "version")], collapse = " "), 
[10:21:12.693]                           hostname = base::Sys.info()[["nodename"]])
[10:21:12.693]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:12.693]                           info)
[10:21:12.693]                         info <- base::paste(info, collapse = "; ")
[10:21:12.693]                         if (!has_future) {
[10:21:12.693]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:12.693]                             info)
[10:21:12.693]                         }
[10:21:12.693]                         else {
[10:21:12.693]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:12.693]                             info, version)
[10:21:12.693]                         }
[10:21:12.693]                         base::stop(msg)
[10:21:12.693]                       }
[10:21:12.693]                     })
[10:21:12.693]                   }
[10:21:12.693]                   ...future.strategy.old <- future::plan("list")
[10:21:12.693]                   options(future.plan = NULL)
[10:21:12.693]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.693]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:12.693]                 }
[10:21:12.693]                 ...future.workdir <- getwd()
[10:21:12.693]             }
[10:21:12.693]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:12.693]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:12.693]         }
[10:21:12.693]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:12.693]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:12.693]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:12.693]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:12.693]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:12.693]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:12.693]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:12.693]             base::names(...future.oldOptions))
[10:21:12.693]     }
[10:21:12.693]     if (FALSE) {
[10:21:12.693]     }
[10:21:12.693]     else {
[10:21:12.693]         if (TRUE) {
[10:21:12.693]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:12.693]                 open = "w")
[10:21:12.693]         }
[10:21:12.693]         else {
[10:21:12.693]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:12.693]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:12.693]         }
[10:21:12.693]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:12.693]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:12.693]             base::sink(type = "output", split = FALSE)
[10:21:12.693]             base::close(...future.stdout)
[10:21:12.693]         }, add = TRUE)
[10:21:12.693]     }
[10:21:12.693]     ...future.frame <- base::sys.nframe()
[10:21:12.693]     ...future.conditions <- base::list()
[10:21:12.693]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:12.693]     if (FALSE) {
[10:21:12.693]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:12.693]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:12.693]     }
[10:21:12.693]     ...future.result <- base::tryCatch({
[10:21:12.693]         base::withCallingHandlers({
[10:21:12.693]             ...future.value <- base::withVisible(base::local({
[10:21:12.693]                 2 * a
[10:21:12.693]             }))
[10:21:12.693]             future::FutureResult(value = ...future.value$value, 
[10:21:12.693]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.693]                   ...future.rng), globalenv = if (FALSE) 
[10:21:12.693]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:12.693]                     ...future.globalenv.names))
[10:21:12.693]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:12.693]         }, condition = base::local({
[10:21:12.693]             c <- base::c
[10:21:12.693]             inherits <- base::inherits
[10:21:12.693]             invokeRestart <- base::invokeRestart
[10:21:12.693]             length <- base::length
[10:21:12.693]             list <- base::list
[10:21:12.693]             seq.int <- base::seq.int
[10:21:12.693]             signalCondition <- base::signalCondition
[10:21:12.693]             sys.calls <- base::sys.calls
[10:21:12.693]             `[[` <- base::`[[`
[10:21:12.693]             `+` <- base::`+`
[10:21:12.693]             `<<-` <- base::`<<-`
[10:21:12.693]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:12.693]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:12.693]                   3L)]
[10:21:12.693]             }
[10:21:12.693]             function(cond) {
[10:21:12.693]                 is_error <- inherits(cond, "error")
[10:21:12.693]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:12.693]                   NULL)
[10:21:12.693]                 if (is_error) {
[10:21:12.693]                   sessionInformation <- function() {
[10:21:12.693]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:12.693]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:12.693]                       search = base::search(), system = base::Sys.info())
[10:21:12.693]                   }
[10:21:12.693]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.693]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:12.693]                     cond$call), session = sessionInformation(), 
[10:21:12.693]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:12.693]                   signalCondition(cond)
[10:21:12.693]                 }
[10:21:12.693]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:12.693]                 "immediateCondition"))) {
[10:21:12.693]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:12.693]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.693]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:12.693]                   if (TRUE && !signal) {
[10:21:12.693]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.693]                     {
[10:21:12.693]                       inherits <- base::inherits
[10:21:12.693]                       invokeRestart <- base::invokeRestart
[10:21:12.693]                       is.null <- base::is.null
[10:21:12.693]                       muffled <- FALSE
[10:21:12.693]                       if (inherits(cond, "message")) {
[10:21:12.693]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.693]                         if (muffled) 
[10:21:12.693]                           invokeRestart("muffleMessage")
[10:21:12.693]                       }
[10:21:12.693]                       else if (inherits(cond, "warning")) {
[10:21:12.693]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.693]                         if (muffled) 
[10:21:12.693]                           invokeRestart("muffleWarning")
[10:21:12.693]                       }
[10:21:12.693]                       else if (inherits(cond, "condition")) {
[10:21:12.693]                         if (!is.null(pattern)) {
[10:21:12.693]                           computeRestarts <- base::computeRestarts
[10:21:12.693]                           grepl <- base::grepl
[10:21:12.693]                           restarts <- computeRestarts(cond)
[10:21:12.693]                           for (restart in restarts) {
[10:21:12.693]                             name <- restart$name
[10:21:12.693]                             if (is.null(name)) 
[10:21:12.693]                               next
[10:21:12.693]                             if (!grepl(pattern, name)) 
[10:21:12.693]                               next
[10:21:12.693]                             invokeRestart(restart)
[10:21:12.693]                             muffled <- TRUE
[10:21:12.693]                             break
[10:21:12.693]                           }
[10:21:12.693]                         }
[10:21:12.693]                       }
[10:21:12.693]                       invisible(muffled)
[10:21:12.693]                     }
[10:21:12.693]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.693]                   }
[10:21:12.693]                 }
[10:21:12.693]                 else {
[10:21:12.693]                   if (TRUE) {
[10:21:12.693]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.693]                     {
[10:21:12.693]                       inherits <- base::inherits
[10:21:12.693]                       invokeRestart <- base::invokeRestart
[10:21:12.693]                       is.null <- base::is.null
[10:21:12.693]                       muffled <- FALSE
[10:21:12.693]                       if (inherits(cond, "message")) {
[10:21:12.693]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.693]                         if (muffled) 
[10:21:12.693]                           invokeRestart("muffleMessage")
[10:21:12.693]                       }
[10:21:12.693]                       else if (inherits(cond, "warning")) {
[10:21:12.693]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.693]                         if (muffled) 
[10:21:12.693]                           invokeRestart("muffleWarning")
[10:21:12.693]                       }
[10:21:12.693]                       else if (inherits(cond, "condition")) {
[10:21:12.693]                         if (!is.null(pattern)) {
[10:21:12.693]                           computeRestarts <- base::computeRestarts
[10:21:12.693]                           grepl <- base::grepl
[10:21:12.693]                           restarts <- computeRestarts(cond)
[10:21:12.693]                           for (restart in restarts) {
[10:21:12.693]                             name <- restart$name
[10:21:12.693]                             if (is.null(name)) 
[10:21:12.693]                               next
[10:21:12.693]                             if (!grepl(pattern, name)) 
[10:21:12.693]                               next
[10:21:12.693]                             invokeRestart(restart)
[10:21:12.693]                             muffled <- TRUE
[10:21:12.693]                             break
[10:21:12.693]                           }
[10:21:12.693]                         }
[10:21:12.693]                       }
[10:21:12.693]                       invisible(muffled)
[10:21:12.693]                     }
[10:21:12.693]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.693]                   }
[10:21:12.693]                 }
[10:21:12.693]             }
[10:21:12.693]         }))
[10:21:12.693]     }, error = function(ex) {
[10:21:12.693]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:12.693]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.693]                 ...future.rng), started = ...future.startTime, 
[10:21:12.693]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:12.693]             version = "1.8"), class = "FutureResult")
[10:21:12.693]     }, finally = {
[10:21:12.693]         if (!identical(...future.workdir, getwd())) 
[10:21:12.693]             setwd(...future.workdir)
[10:21:12.693]         {
[10:21:12.693]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:12.693]                 ...future.oldOptions$nwarnings <- NULL
[10:21:12.693]             }
[10:21:12.693]             base::options(...future.oldOptions)
[10:21:12.693]             if (.Platform$OS.type == "windows") {
[10:21:12.693]                 old_names <- names(...future.oldEnvVars)
[10:21:12.693]                 envs <- base::Sys.getenv()
[10:21:12.693]                 names <- names(envs)
[10:21:12.693]                 common <- intersect(names, old_names)
[10:21:12.693]                 added <- setdiff(names, old_names)
[10:21:12.693]                 removed <- setdiff(old_names, names)
[10:21:12.693]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:12.693]                   envs[common]]
[10:21:12.693]                 NAMES <- toupper(changed)
[10:21:12.693]                 args <- list()
[10:21:12.693]                 for (kk in seq_along(NAMES)) {
[10:21:12.693]                   name <- changed[[kk]]
[10:21:12.693]                   NAME <- NAMES[[kk]]
[10:21:12.693]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.693]                     next
[10:21:12.693]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.693]                 }
[10:21:12.693]                 NAMES <- toupper(added)
[10:21:12.693]                 for (kk in seq_along(NAMES)) {
[10:21:12.693]                   name <- added[[kk]]
[10:21:12.693]                   NAME <- NAMES[[kk]]
[10:21:12.693]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.693]                     next
[10:21:12.693]                   args[[name]] <- ""
[10:21:12.693]                 }
[10:21:12.693]                 NAMES <- toupper(removed)
[10:21:12.693]                 for (kk in seq_along(NAMES)) {
[10:21:12.693]                   name <- removed[[kk]]
[10:21:12.693]                   NAME <- NAMES[[kk]]
[10:21:12.693]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.693]                     next
[10:21:12.693]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.693]                 }
[10:21:12.693]                 if (length(args) > 0) 
[10:21:12.693]                   base::do.call(base::Sys.setenv, args = args)
[10:21:12.693]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:12.693]             }
[10:21:12.693]             else {
[10:21:12.693]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:12.693]             }
[10:21:12.693]             {
[10:21:12.693]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:12.693]                   0L) {
[10:21:12.693]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:12.693]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:12.693]                   base::options(opts)
[10:21:12.693]                 }
[10:21:12.693]                 {
[10:21:12.693]                   {
[10:21:12.693]                     NULL
[10:21:12.693]                     RNGkind("Mersenne-Twister")
[10:21:12.693]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:12.693]                       inherits = FALSE)
[10:21:12.693]                   }
[10:21:12.693]                   options(future.plan = NULL)
[10:21:12.693]                   if (is.na(NA_character_)) 
[10:21:12.693]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.693]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:12.693]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:12.693]                     .init = FALSE)
[10:21:12.693]                 }
[10:21:12.693]             }
[10:21:12.693]         }
[10:21:12.693]     })
[10:21:12.693]     if (TRUE) {
[10:21:12.693]         base::sink(type = "output", split = FALSE)
[10:21:12.693]         if (TRUE) {
[10:21:12.693]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:12.693]         }
[10:21:12.693]         else {
[10:21:12.693]             ...future.result["stdout"] <- base::list(NULL)
[10:21:12.693]         }
[10:21:12.693]         base::close(...future.stdout)
[10:21:12.693]         ...future.stdout <- NULL
[10:21:12.693]     }
[10:21:12.693]     ...future.result$conditions <- ...future.conditions
[10:21:12.693]     ...future.result$finished <- base::Sys.time()
[10:21:12.693]     ...future.result
[10:21:12.693] }
[10:21:12.694] assign_globals() ...
[10:21:12.694] List of 1
[10:21:12.694]  $ a: num 1
[10:21:12.694]  - attr(*, "where")=List of 1
[10:21:12.694]   ..$ a:<environment: R_EmptyEnv> 
[10:21:12.694]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:12.694]  - attr(*, "resolved")= logi FALSE
[10:21:12.694]  - attr(*, "total_size")= num 39
[10:21:12.694]  - attr(*, "already-done")= logi TRUE
[10:21:12.697] - copied ‘a’ to environment
[10:21:12.697] assign_globals() ... done
[10:21:12.697] plan(): Setting new future strategy stack:
[10:21:12.697] List of future strategies:
[10:21:12.697] 1. sequential:
[10:21:12.697]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.697]    - tweaked: FALSE
[10:21:12.697]    - call: NULL
[10:21:12.697] plan(): nbrOfWorkers() = 1
[10:21:12.699] plan(): Setting new future strategy stack:
[10:21:12.699] List of future strategies:
[10:21:12.699] 1. sequential:
[10:21:12.699]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.699]    - tweaked: FALSE
[10:21:12.699]    - call: plan(strategy)
[10:21:12.700] plan(): nbrOfWorkers() = 1
[10:21:12.700] SequentialFuture started (and completed)
[10:21:12.700] - Launch lazy future ... done
[10:21:12.700] run() for ‘SequentialFuture’ ... done
[10:21:12.700] getGlobalsAndPackages() ...
[10:21:12.700] Searching for globals...
[10:21:12.701] - globals found: [3] ‘{’, ‘*’, ‘a’
[10:21:12.701] Searching for globals ... DONE
[10:21:12.701] Resolving globals: FALSE
[10:21:12.702] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:12.702] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:12.702] - globals: [1] ‘a’
[10:21:12.702] 
[10:21:12.702] getGlobalsAndPackages() ... DONE
[10:21:12.702] run() for ‘Future’ ...
[10:21:12.702] - state: ‘created’
[10:21:12.703] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:12.703] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:12.703] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:12.703]   - Field: ‘label’
[10:21:12.703]   - Field: ‘local’
[10:21:12.703]   - Field: ‘owner’
[10:21:12.703]   - Field: ‘envir’
[10:21:12.703]   - Field: ‘packages’
[10:21:12.703]   - Field: ‘gc’
[10:21:12.704]   - Field: ‘conditions’
[10:21:12.704]   - Field: ‘expr’
[10:21:12.704]   - Field: ‘uuid’
[10:21:12.704]   - Field: ‘seed’
[10:21:12.704]   - Field: ‘version’
[10:21:12.704]   - Field: ‘result’
[10:21:12.704]   - Field: ‘asynchronous’
[10:21:12.704]   - Field: ‘calls’
[10:21:12.704]   - Field: ‘globals’
[10:21:12.704]   - Field: ‘stdout’
[10:21:12.704]   - Field: ‘earlySignal’
[10:21:12.704]   - Field: ‘lazy’
[10:21:12.705]   - Field: ‘state’
[10:21:12.705] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:12.705] - Launch lazy future ...
[10:21:12.705] Packages needed by the future expression (n = 0): <none>
[10:21:12.705] Packages needed by future strategies (n = 0): <none>
[10:21:12.705] {
[10:21:12.705]     {
[10:21:12.705]         {
[10:21:12.705]             ...future.startTime <- base::Sys.time()
[10:21:12.705]             {
[10:21:12.705]                 {
[10:21:12.705]                   {
[10:21:12.705]                     base::local({
[10:21:12.705]                       has_future <- base::requireNamespace("future", 
[10:21:12.705]                         quietly = TRUE)
[10:21:12.705]                       if (has_future) {
[10:21:12.705]                         ns <- base::getNamespace("future")
[10:21:12.705]                         version <- ns[[".package"]][["version"]]
[10:21:12.705]                         if (is.null(version)) 
[10:21:12.705]                           version <- utils::packageVersion("future")
[10:21:12.705]                       }
[10:21:12.705]                       else {
[10:21:12.705]                         version <- NULL
[10:21:12.705]                       }
[10:21:12.705]                       if (!has_future || version < "1.8.0") {
[10:21:12.705]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:12.705]                           "", base::R.version$version.string), 
[10:21:12.705]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:12.705]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:12.705]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:12.705]                             "release", "version")], collapse = " "), 
[10:21:12.705]                           hostname = base::Sys.info()[["nodename"]])
[10:21:12.705]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:12.705]                           info)
[10:21:12.705]                         info <- base::paste(info, collapse = "; ")
[10:21:12.705]                         if (!has_future) {
[10:21:12.705]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:12.705]                             info)
[10:21:12.705]                         }
[10:21:12.705]                         else {
[10:21:12.705]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:12.705]                             info, version)
[10:21:12.705]                         }
[10:21:12.705]                         base::stop(msg)
[10:21:12.705]                       }
[10:21:12.705]                     })
[10:21:12.705]                   }
[10:21:12.705]                   ...future.strategy.old <- future::plan("list")
[10:21:12.705]                   options(future.plan = NULL)
[10:21:12.705]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.705]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:12.705]                 }
[10:21:12.705]                 ...future.workdir <- getwd()
[10:21:12.705]             }
[10:21:12.705]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:12.705]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:12.705]         }
[10:21:12.705]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:12.705]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:12.705]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:12.705]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:12.705]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:12.705]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:12.705]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:12.705]             base::names(...future.oldOptions))
[10:21:12.705]     }
[10:21:12.705]     if (FALSE) {
[10:21:12.705]     }
[10:21:12.705]     else {
[10:21:12.705]         if (TRUE) {
[10:21:12.705]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:12.705]                 open = "w")
[10:21:12.705]         }
[10:21:12.705]         else {
[10:21:12.705]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:12.705]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:12.705]         }
[10:21:12.705]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:12.705]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:12.705]             base::sink(type = "output", split = FALSE)
[10:21:12.705]             base::close(...future.stdout)
[10:21:12.705]         }, add = TRUE)
[10:21:12.705]     }
[10:21:12.705]     ...future.frame <- base::sys.nframe()
[10:21:12.705]     ...future.conditions <- base::list()
[10:21:12.705]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:12.705]     if (FALSE) {
[10:21:12.705]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:12.705]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:12.705]     }
[10:21:12.705]     ...future.result <- base::tryCatch({
[10:21:12.705]         base::withCallingHandlers({
[10:21:12.705]             ...future.value <- base::withVisible(base::local({
[10:21:12.705]                 2 * a
[10:21:12.705]             }))
[10:21:12.705]             future::FutureResult(value = ...future.value$value, 
[10:21:12.705]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.705]                   ...future.rng), globalenv = if (FALSE) 
[10:21:12.705]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:12.705]                     ...future.globalenv.names))
[10:21:12.705]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:12.705]         }, condition = base::local({
[10:21:12.705]             c <- base::c
[10:21:12.705]             inherits <- base::inherits
[10:21:12.705]             invokeRestart <- base::invokeRestart
[10:21:12.705]             length <- base::length
[10:21:12.705]             list <- base::list
[10:21:12.705]             seq.int <- base::seq.int
[10:21:12.705]             signalCondition <- base::signalCondition
[10:21:12.705]             sys.calls <- base::sys.calls
[10:21:12.705]             `[[` <- base::`[[`
[10:21:12.705]             `+` <- base::`+`
[10:21:12.705]             `<<-` <- base::`<<-`
[10:21:12.705]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:12.705]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:12.705]                   3L)]
[10:21:12.705]             }
[10:21:12.705]             function(cond) {
[10:21:12.705]                 is_error <- inherits(cond, "error")
[10:21:12.705]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:12.705]                   NULL)
[10:21:12.705]                 if (is_error) {
[10:21:12.705]                   sessionInformation <- function() {
[10:21:12.705]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:12.705]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:12.705]                       search = base::search(), system = base::Sys.info())
[10:21:12.705]                   }
[10:21:12.705]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.705]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:12.705]                     cond$call), session = sessionInformation(), 
[10:21:12.705]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:12.705]                   signalCondition(cond)
[10:21:12.705]                 }
[10:21:12.705]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:12.705]                 "immediateCondition"))) {
[10:21:12.705]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:12.705]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.705]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:12.705]                   if (TRUE && !signal) {
[10:21:12.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.705]                     {
[10:21:12.705]                       inherits <- base::inherits
[10:21:12.705]                       invokeRestart <- base::invokeRestart
[10:21:12.705]                       is.null <- base::is.null
[10:21:12.705]                       muffled <- FALSE
[10:21:12.705]                       if (inherits(cond, "message")) {
[10:21:12.705]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.705]                         if (muffled) 
[10:21:12.705]                           invokeRestart("muffleMessage")
[10:21:12.705]                       }
[10:21:12.705]                       else if (inherits(cond, "warning")) {
[10:21:12.705]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.705]                         if (muffled) 
[10:21:12.705]                           invokeRestart("muffleWarning")
[10:21:12.705]                       }
[10:21:12.705]                       else if (inherits(cond, "condition")) {
[10:21:12.705]                         if (!is.null(pattern)) {
[10:21:12.705]                           computeRestarts <- base::computeRestarts
[10:21:12.705]                           grepl <- base::grepl
[10:21:12.705]                           restarts <- computeRestarts(cond)
[10:21:12.705]                           for (restart in restarts) {
[10:21:12.705]                             name <- restart$name
[10:21:12.705]                             if (is.null(name)) 
[10:21:12.705]                               next
[10:21:12.705]                             if (!grepl(pattern, name)) 
[10:21:12.705]                               next
[10:21:12.705]                             invokeRestart(restart)
[10:21:12.705]                             muffled <- TRUE
[10:21:12.705]                             break
[10:21:12.705]                           }
[10:21:12.705]                         }
[10:21:12.705]                       }
[10:21:12.705]                       invisible(muffled)
[10:21:12.705]                     }
[10:21:12.705]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.705]                   }
[10:21:12.705]                 }
[10:21:12.705]                 else {
[10:21:12.705]                   if (TRUE) {
[10:21:12.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.705]                     {
[10:21:12.705]                       inherits <- base::inherits
[10:21:12.705]                       invokeRestart <- base::invokeRestart
[10:21:12.705]                       is.null <- base::is.null
[10:21:12.705]                       muffled <- FALSE
[10:21:12.705]                       if (inherits(cond, "message")) {
[10:21:12.705]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.705]                         if (muffled) 
[10:21:12.705]                           invokeRestart("muffleMessage")
[10:21:12.705]                       }
[10:21:12.705]                       else if (inherits(cond, "warning")) {
[10:21:12.705]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.705]                         if (muffled) 
[10:21:12.705]                           invokeRestart("muffleWarning")
[10:21:12.705]                       }
[10:21:12.705]                       else if (inherits(cond, "condition")) {
[10:21:12.705]                         if (!is.null(pattern)) {
[10:21:12.705]                           computeRestarts <- base::computeRestarts
[10:21:12.705]                           grepl <- base::grepl
[10:21:12.705]                           restarts <- computeRestarts(cond)
[10:21:12.705]                           for (restart in restarts) {
[10:21:12.705]                             name <- restart$name
[10:21:12.705]                             if (is.null(name)) 
[10:21:12.705]                               next
[10:21:12.705]                             if (!grepl(pattern, name)) 
[10:21:12.705]                               next
[10:21:12.705]                             invokeRestart(restart)
[10:21:12.705]                             muffled <- TRUE
[10:21:12.705]                             break
[10:21:12.705]                           }
[10:21:12.705]                         }
[10:21:12.705]                       }
[10:21:12.705]                       invisible(muffled)
[10:21:12.705]                     }
[10:21:12.705]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.705]                   }
[10:21:12.705]                 }
[10:21:12.705]             }
[10:21:12.705]         }))
[10:21:12.705]     }, error = function(ex) {
[10:21:12.705]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:12.705]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.705]                 ...future.rng), started = ...future.startTime, 
[10:21:12.705]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:12.705]             version = "1.8"), class = "FutureResult")
[10:21:12.705]     }, finally = {
[10:21:12.705]         if (!identical(...future.workdir, getwd())) 
[10:21:12.705]             setwd(...future.workdir)
[10:21:12.705]         {
[10:21:12.705]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:12.705]                 ...future.oldOptions$nwarnings <- NULL
[10:21:12.705]             }
[10:21:12.705]             base::options(...future.oldOptions)
[10:21:12.705]             if (.Platform$OS.type == "windows") {
[10:21:12.705]                 old_names <- names(...future.oldEnvVars)
[10:21:12.705]                 envs <- base::Sys.getenv()
[10:21:12.705]                 names <- names(envs)
[10:21:12.705]                 common <- intersect(names, old_names)
[10:21:12.705]                 added <- setdiff(names, old_names)
[10:21:12.705]                 removed <- setdiff(old_names, names)
[10:21:12.705]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:12.705]                   envs[common]]
[10:21:12.705]                 NAMES <- toupper(changed)
[10:21:12.705]                 args <- list()
[10:21:12.705]                 for (kk in seq_along(NAMES)) {
[10:21:12.705]                   name <- changed[[kk]]
[10:21:12.705]                   NAME <- NAMES[[kk]]
[10:21:12.705]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.705]                     next
[10:21:12.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.705]                 }
[10:21:12.705]                 NAMES <- toupper(added)
[10:21:12.705]                 for (kk in seq_along(NAMES)) {
[10:21:12.705]                   name <- added[[kk]]
[10:21:12.705]                   NAME <- NAMES[[kk]]
[10:21:12.705]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.705]                     next
[10:21:12.705]                   args[[name]] <- ""
[10:21:12.705]                 }
[10:21:12.705]                 NAMES <- toupper(removed)
[10:21:12.705]                 for (kk in seq_along(NAMES)) {
[10:21:12.705]                   name <- removed[[kk]]
[10:21:12.705]                   NAME <- NAMES[[kk]]
[10:21:12.705]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.705]                     next
[10:21:12.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.705]                 }
[10:21:12.705]                 if (length(args) > 0) 
[10:21:12.705]                   base::do.call(base::Sys.setenv, args = args)
[10:21:12.705]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:12.705]             }
[10:21:12.705]             else {
[10:21:12.705]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:12.705]             }
[10:21:12.705]             {
[10:21:12.705]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:12.705]                   0L) {
[10:21:12.705]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:12.705]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:12.705]                   base::options(opts)
[10:21:12.705]                 }
[10:21:12.705]                 {
[10:21:12.705]                   {
[10:21:12.705]                     NULL
[10:21:12.705]                     RNGkind("Mersenne-Twister")
[10:21:12.705]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:12.705]                       inherits = FALSE)
[10:21:12.705]                   }
[10:21:12.705]                   options(future.plan = NULL)
[10:21:12.705]                   if (is.na(NA_character_)) 
[10:21:12.705]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.705]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:12.705]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:12.705]                     .init = FALSE)
[10:21:12.705]                 }
[10:21:12.705]             }
[10:21:12.705]         }
[10:21:12.705]     })
[10:21:12.705]     if (TRUE) {
[10:21:12.705]         base::sink(type = "output", split = FALSE)
[10:21:12.705]         if (TRUE) {
[10:21:12.705]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:12.705]         }
[10:21:12.705]         else {
[10:21:12.705]             ...future.result["stdout"] <- base::list(NULL)
[10:21:12.705]         }
[10:21:12.705]         base::close(...future.stdout)
[10:21:12.705]         ...future.stdout <- NULL
[10:21:12.705]     }
[10:21:12.705]     ...future.result$conditions <- ...future.conditions
[10:21:12.705]     ...future.result$finished <- base::Sys.time()
[10:21:12.705]     ...future.result
[10:21:12.705] }
[10:21:12.707] assign_globals() ...
[10:21:12.707] List of 1
[10:21:12.707]  $ a: num 1
[10:21:12.707]  - attr(*, "where")=List of 1
[10:21:12.707]   ..$ a:<environment: R_EmptyEnv> 
[10:21:12.707]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:12.707]  - attr(*, "resolved")= logi FALSE
[10:21:12.707]  - attr(*, "total_size")= num 39
[10:21:12.707]  - attr(*, "already-done")= logi TRUE
[10:21:12.709] - copied ‘a’ to environment
[10:21:12.709] assign_globals() ... done
[10:21:12.710] plan(): Setting new future strategy stack:
[10:21:12.710] List of future strategies:
[10:21:12.710] 1. sequential:
[10:21:12.710]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.710]    - tweaked: FALSE
[10:21:12.710]    - call: NULL
[10:21:12.710] plan(): nbrOfWorkers() = 1
[10:21:12.711] plan(): Setting new future strategy stack:
[10:21:12.711] List of future strategies:
[10:21:12.711] 1. sequential:
[10:21:12.711]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.711]    - tweaked: FALSE
[10:21:12.711]    - call: plan(strategy)
[10:21:12.711] plan(): nbrOfWorkers() = 1
[10:21:12.711] SequentialFuture started (and completed)
[10:21:12.711] - Launch lazy future ... done
[10:21:12.712] run() for ‘SequentialFuture’ ... done
[10:21:12.712] getGlobalsAndPackages() ...
[10:21:12.712] Searching for globals...
[10:21:12.713] - globals found: [3] ‘{’, ‘*’, ‘a’
[10:21:12.713] Searching for globals ... DONE
[10:21:12.713] Resolving globals: FALSE
[10:21:12.713] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:12.713] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:12.713] - globals: [1] ‘a’
[10:21:12.714] 
[10:21:12.714] getGlobalsAndPackages() ... DONE
[10:21:12.714] run() for ‘Future’ ...
[10:21:12.714] - state: ‘created’
[10:21:12.714] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:12.714] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:12.714] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:12.714]   - Field: ‘label’
[10:21:12.715]   - Field: ‘local’
[10:21:12.715]   - Field: ‘owner’
[10:21:12.715]   - Field: ‘envir’
[10:21:12.715]   - Field: ‘packages’
[10:21:12.715]   - Field: ‘gc’
[10:21:12.715]   - Field: ‘conditions’
[10:21:12.715]   - Field: ‘expr’
[10:21:12.715]   - Field: ‘uuid’
[10:21:12.715]   - Field: ‘seed’
[10:21:12.715]   - Field: ‘version’
[10:21:12.715]   - Field: ‘result’
[10:21:12.715]   - Field: ‘asynchronous’
[10:21:12.716]   - Field: ‘calls’
[10:21:12.716]   - Field: ‘globals’
[10:21:12.716]   - Field: ‘stdout’
[10:21:12.716]   - Field: ‘earlySignal’
[10:21:12.716]   - Field: ‘lazy’
[10:21:12.716]   - Field: ‘state’
[10:21:12.716] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:12.716] - Launch lazy future ...
[10:21:12.716] Packages needed by the future expression (n = 0): <none>
[10:21:12.716] Packages needed by future strategies (n = 0): <none>
[10:21:12.717] {
[10:21:12.717]     {
[10:21:12.717]         {
[10:21:12.717]             ...future.startTime <- base::Sys.time()
[10:21:12.717]             {
[10:21:12.717]                 {
[10:21:12.717]                   {
[10:21:12.717]                     base::local({
[10:21:12.717]                       has_future <- base::requireNamespace("future", 
[10:21:12.717]                         quietly = TRUE)
[10:21:12.717]                       if (has_future) {
[10:21:12.717]                         ns <- base::getNamespace("future")
[10:21:12.717]                         version <- ns[[".package"]][["version"]]
[10:21:12.717]                         if (is.null(version)) 
[10:21:12.717]                           version <- utils::packageVersion("future")
[10:21:12.717]                       }
[10:21:12.717]                       else {
[10:21:12.717]                         version <- NULL
[10:21:12.717]                       }
[10:21:12.717]                       if (!has_future || version < "1.8.0") {
[10:21:12.717]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:12.717]                           "", base::R.version$version.string), 
[10:21:12.717]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:12.717]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:12.717]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:12.717]                             "release", "version")], collapse = " "), 
[10:21:12.717]                           hostname = base::Sys.info()[["nodename"]])
[10:21:12.717]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:12.717]                           info)
[10:21:12.717]                         info <- base::paste(info, collapse = "; ")
[10:21:12.717]                         if (!has_future) {
[10:21:12.717]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:12.717]                             info)
[10:21:12.717]                         }
[10:21:12.717]                         else {
[10:21:12.717]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:12.717]                             info, version)
[10:21:12.717]                         }
[10:21:12.717]                         base::stop(msg)
[10:21:12.717]                       }
[10:21:12.717]                     })
[10:21:12.717]                   }
[10:21:12.717]                   ...future.strategy.old <- future::plan("list")
[10:21:12.717]                   options(future.plan = NULL)
[10:21:12.717]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.717]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:12.717]                 }
[10:21:12.717]                 ...future.workdir <- getwd()
[10:21:12.717]             }
[10:21:12.717]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:12.717]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:12.717]         }
[10:21:12.717]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:12.717]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:12.717]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:12.717]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:12.717]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:12.717]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:12.717]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:12.717]             base::names(...future.oldOptions))
[10:21:12.717]     }
[10:21:12.717]     if (FALSE) {
[10:21:12.717]     }
[10:21:12.717]     else {
[10:21:12.717]         if (TRUE) {
[10:21:12.717]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:12.717]                 open = "w")
[10:21:12.717]         }
[10:21:12.717]         else {
[10:21:12.717]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:12.717]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:12.717]         }
[10:21:12.717]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:12.717]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:12.717]             base::sink(type = "output", split = FALSE)
[10:21:12.717]             base::close(...future.stdout)
[10:21:12.717]         }, add = TRUE)
[10:21:12.717]     }
[10:21:12.717]     ...future.frame <- base::sys.nframe()
[10:21:12.717]     ...future.conditions <- base::list()
[10:21:12.717]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:12.717]     if (FALSE) {
[10:21:12.717]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:12.717]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:12.717]     }
[10:21:12.717]     ...future.result <- base::tryCatch({
[10:21:12.717]         base::withCallingHandlers({
[10:21:12.717]             ...future.value <- base::withVisible(base::local({
[10:21:12.717]                 2 * a
[10:21:12.717]             }))
[10:21:12.717]             future::FutureResult(value = ...future.value$value, 
[10:21:12.717]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.717]                   ...future.rng), globalenv = if (FALSE) 
[10:21:12.717]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:12.717]                     ...future.globalenv.names))
[10:21:12.717]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:12.717]         }, condition = base::local({
[10:21:12.717]             c <- base::c
[10:21:12.717]             inherits <- base::inherits
[10:21:12.717]             invokeRestart <- base::invokeRestart
[10:21:12.717]             length <- base::length
[10:21:12.717]             list <- base::list
[10:21:12.717]             seq.int <- base::seq.int
[10:21:12.717]             signalCondition <- base::signalCondition
[10:21:12.717]             sys.calls <- base::sys.calls
[10:21:12.717]             `[[` <- base::`[[`
[10:21:12.717]             `+` <- base::`+`
[10:21:12.717]             `<<-` <- base::`<<-`
[10:21:12.717]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:12.717]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:12.717]                   3L)]
[10:21:12.717]             }
[10:21:12.717]             function(cond) {
[10:21:12.717]                 is_error <- inherits(cond, "error")
[10:21:12.717]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:12.717]                   NULL)
[10:21:12.717]                 if (is_error) {
[10:21:12.717]                   sessionInformation <- function() {
[10:21:12.717]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:12.717]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:12.717]                       search = base::search(), system = base::Sys.info())
[10:21:12.717]                   }
[10:21:12.717]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.717]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:12.717]                     cond$call), session = sessionInformation(), 
[10:21:12.717]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:12.717]                   signalCondition(cond)
[10:21:12.717]                 }
[10:21:12.717]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:12.717]                 "immediateCondition"))) {
[10:21:12.717]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:12.717]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.717]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:12.717]                   if (TRUE && !signal) {
[10:21:12.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.717]                     {
[10:21:12.717]                       inherits <- base::inherits
[10:21:12.717]                       invokeRestart <- base::invokeRestart
[10:21:12.717]                       is.null <- base::is.null
[10:21:12.717]                       muffled <- FALSE
[10:21:12.717]                       if (inherits(cond, "message")) {
[10:21:12.717]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.717]                         if (muffled) 
[10:21:12.717]                           invokeRestart("muffleMessage")
[10:21:12.717]                       }
[10:21:12.717]                       else if (inherits(cond, "warning")) {
[10:21:12.717]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.717]                         if (muffled) 
[10:21:12.717]                           invokeRestart("muffleWarning")
[10:21:12.717]                       }
[10:21:12.717]                       else if (inherits(cond, "condition")) {
[10:21:12.717]                         if (!is.null(pattern)) {
[10:21:12.717]                           computeRestarts <- base::computeRestarts
[10:21:12.717]                           grepl <- base::grepl
[10:21:12.717]                           restarts <- computeRestarts(cond)
[10:21:12.717]                           for (restart in restarts) {
[10:21:12.717]                             name <- restart$name
[10:21:12.717]                             if (is.null(name)) 
[10:21:12.717]                               next
[10:21:12.717]                             if (!grepl(pattern, name)) 
[10:21:12.717]                               next
[10:21:12.717]                             invokeRestart(restart)
[10:21:12.717]                             muffled <- TRUE
[10:21:12.717]                             break
[10:21:12.717]                           }
[10:21:12.717]                         }
[10:21:12.717]                       }
[10:21:12.717]                       invisible(muffled)
[10:21:12.717]                     }
[10:21:12.717]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.717]                   }
[10:21:12.717]                 }
[10:21:12.717]                 else {
[10:21:12.717]                   if (TRUE) {
[10:21:12.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.717]                     {
[10:21:12.717]                       inherits <- base::inherits
[10:21:12.717]                       invokeRestart <- base::invokeRestart
[10:21:12.717]                       is.null <- base::is.null
[10:21:12.717]                       muffled <- FALSE
[10:21:12.717]                       if (inherits(cond, "message")) {
[10:21:12.717]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.717]                         if (muffled) 
[10:21:12.717]                           invokeRestart("muffleMessage")
[10:21:12.717]                       }
[10:21:12.717]                       else if (inherits(cond, "warning")) {
[10:21:12.717]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.717]                         if (muffled) 
[10:21:12.717]                           invokeRestart("muffleWarning")
[10:21:12.717]                       }
[10:21:12.717]                       else if (inherits(cond, "condition")) {
[10:21:12.717]                         if (!is.null(pattern)) {
[10:21:12.717]                           computeRestarts <- base::computeRestarts
[10:21:12.717]                           grepl <- base::grepl
[10:21:12.717]                           restarts <- computeRestarts(cond)
[10:21:12.717]                           for (restart in restarts) {
[10:21:12.717]                             name <- restart$name
[10:21:12.717]                             if (is.null(name)) 
[10:21:12.717]                               next
[10:21:12.717]                             if (!grepl(pattern, name)) 
[10:21:12.717]                               next
[10:21:12.717]                             invokeRestart(restart)
[10:21:12.717]                             muffled <- TRUE
[10:21:12.717]                             break
[10:21:12.717]                           }
[10:21:12.717]                         }
[10:21:12.717]                       }
[10:21:12.717]                       invisible(muffled)
[10:21:12.717]                     }
[10:21:12.717]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.717]                   }
[10:21:12.717]                 }
[10:21:12.717]             }
[10:21:12.717]         }))
[10:21:12.717]     }, error = function(ex) {
[10:21:12.717]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:12.717]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.717]                 ...future.rng), started = ...future.startTime, 
[10:21:12.717]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:12.717]             version = "1.8"), class = "FutureResult")
[10:21:12.717]     }, finally = {
[10:21:12.717]         if (!identical(...future.workdir, getwd())) 
[10:21:12.717]             setwd(...future.workdir)
[10:21:12.717]         {
[10:21:12.717]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:12.717]                 ...future.oldOptions$nwarnings <- NULL
[10:21:12.717]             }
[10:21:12.717]             base::options(...future.oldOptions)
[10:21:12.717]             if (.Platform$OS.type == "windows") {
[10:21:12.717]                 old_names <- names(...future.oldEnvVars)
[10:21:12.717]                 envs <- base::Sys.getenv()
[10:21:12.717]                 names <- names(envs)
[10:21:12.717]                 common <- intersect(names, old_names)
[10:21:12.717]                 added <- setdiff(names, old_names)
[10:21:12.717]                 removed <- setdiff(old_names, names)
[10:21:12.717]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:12.717]                   envs[common]]
[10:21:12.717]                 NAMES <- toupper(changed)
[10:21:12.717]                 args <- list()
[10:21:12.717]                 for (kk in seq_along(NAMES)) {
[10:21:12.717]                   name <- changed[[kk]]
[10:21:12.717]                   NAME <- NAMES[[kk]]
[10:21:12.717]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.717]                     next
[10:21:12.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.717]                 }
[10:21:12.717]                 NAMES <- toupper(added)
[10:21:12.717]                 for (kk in seq_along(NAMES)) {
[10:21:12.717]                   name <- added[[kk]]
[10:21:12.717]                   NAME <- NAMES[[kk]]
[10:21:12.717]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.717]                     next
[10:21:12.717]                   args[[name]] <- ""
[10:21:12.717]                 }
[10:21:12.717]                 NAMES <- toupper(removed)
[10:21:12.717]                 for (kk in seq_along(NAMES)) {
[10:21:12.717]                   name <- removed[[kk]]
[10:21:12.717]                   NAME <- NAMES[[kk]]
[10:21:12.717]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.717]                     next
[10:21:12.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.717]                 }
[10:21:12.717]                 if (length(args) > 0) 
[10:21:12.717]                   base::do.call(base::Sys.setenv, args = args)
[10:21:12.717]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:12.717]             }
[10:21:12.717]             else {
[10:21:12.717]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:12.717]             }
[10:21:12.717]             {
[10:21:12.717]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:12.717]                   0L) {
[10:21:12.717]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:12.717]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:12.717]                   base::options(opts)
[10:21:12.717]                 }
[10:21:12.717]                 {
[10:21:12.717]                   {
[10:21:12.717]                     NULL
[10:21:12.717]                     RNGkind("Mersenne-Twister")
[10:21:12.717]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:12.717]                       inherits = FALSE)
[10:21:12.717]                   }
[10:21:12.717]                   options(future.plan = NULL)
[10:21:12.717]                   if (is.na(NA_character_)) 
[10:21:12.717]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.717]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:12.717]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:12.717]                     .init = FALSE)
[10:21:12.717]                 }
[10:21:12.717]             }
[10:21:12.717]         }
[10:21:12.717]     })
[10:21:12.717]     if (TRUE) {
[10:21:12.717]         base::sink(type = "output", split = FALSE)
[10:21:12.717]         if (TRUE) {
[10:21:12.717]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:12.717]         }
[10:21:12.717]         else {
[10:21:12.717]             ...future.result["stdout"] <- base::list(NULL)
[10:21:12.717]         }
[10:21:12.717]         base::close(...future.stdout)
[10:21:12.717]         ...future.stdout <- NULL
[10:21:12.717]     }
[10:21:12.717]     ...future.result$conditions <- ...future.conditions
[10:21:12.717]     ...future.result$finished <- base::Sys.time()
[10:21:12.717]     ...future.result
[10:21:12.717] }
[10:21:12.718] assign_globals() ...
[10:21:12.718] List of 1
[10:21:12.718]  $ a: num 1
[10:21:12.718]  - attr(*, "where")=List of 1
[10:21:12.718]   ..$ a:<environment: R_EmptyEnv> 
[10:21:12.718]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:12.718]  - attr(*, "resolved")= logi FALSE
[10:21:12.718]  - attr(*, "total_size")= num 39
[10:21:12.718]  - attr(*, "already-done")= logi TRUE
[10:21:12.721] - copied ‘a’ to environment
[10:21:12.721] assign_globals() ... done
[10:21:12.721] plan(): Setting new future strategy stack:
[10:21:12.721] List of future strategies:
[10:21:12.721] 1. sequential:
[10:21:12.721]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.721]    - tweaked: FALSE
[10:21:12.721]    - call: NULL
[10:21:12.722] plan(): nbrOfWorkers() = 1
[10:21:12.722] plan(): Setting new future strategy stack:
[10:21:12.722] List of future strategies:
[10:21:12.722] 1. sequential:
[10:21:12.722]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.722]    - tweaked: FALSE
[10:21:12.722]    - call: plan(strategy)
[10:21:12.723] plan(): nbrOfWorkers() = 1
[10:21:12.723] SequentialFuture started (and completed)
[10:21:12.723] - Launch lazy future ... done
[10:21:12.723] run() for ‘SequentialFuture’ ... done
*** futureAssign() with ‘sequential’ futures ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** futureAssign() with ‘multicore’ futures ...
[10:21:12.729] plan(): Setting new future strategy stack:
[10:21:12.729] List of future strategies:
[10:21:12.729] 1. multicore:
[10:21:12.729]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:12.729]    - tweaked: FALSE
[10:21:12.729]    - call: plan(strategy)
[10:21:12.731] plan(): nbrOfWorkers() = 2
[10:21:12.731] getGlobalsAndPackages() ...
[10:21:12.731] Searching for globals...
[10:21:12.732] - globals found: [1] ‘{’
[10:21:12.732] Searching for globals ... DONE
[10:21:12.732] Resolving globals: FALSE
[10:21:12.732] 
[10:21:12.732] 
[10:21:12.732] getGlobalsAndPackages() ... DONE
[10:21:12.733] run() for ‘Future’ ...
[10:21:12.733] - state: ‘created’
[10:21:12.733] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:12.734] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:12.734] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:12.735]   - Field: ‘label’
[10:21:12.735]   - Field: ‘local’
[10:21:12.735]   - Field: ‘owner’
[10:21:12.735]   - Field: ‘envir’
[10:21:12.735]   - Field: ‘workers’
[10:21:12.735]   - Field: ‘packages’
[10:21:12.735]   - Field: ‘gc’
[10:21:12.735]   - Field: ‘job’
[10:21:12.735]   - Field: ‘conditions’
[10:21:12.735]   - Field: ‘expr’
[10:21:12.735]   - Field: ‘uuid’
[10:21:12.736]   - Field: ‘seed’
[10:21:12.736]   - Field: ‘version’
[10:21:12.736]   - Field: ‘result’
[10:21:12.736]   - Field: ‘asynchronous’
[10:21:12.736]   - Field: ‘calls’
[10:21:12.736]   - Field: ‘globals’
[10:21:12.736]   - Field: ‘stdout’
[10:21:12.736]   - Field: ‘earlySignal’
[10:21:12.736]   - Field: ‘lazy’
[10:21:12.736]   - Field: ‘state’
[10:21:12.736] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:12.736] - Launch lazy future ...
[10:21:12.737] Packages needed by the future expression (n = 0): <none>
[10:21:12.737] Packages needed by future strategies (n = 0): <none>
[10:21:12.738] {
[10:21:12.738]     {
[10:21:12.738]         {
[10:21:12.738]             ...future.startTime <- base::Sys.time()
[10:21:12.738]             {
[10:21:12.738]                 {
[10:21:12.738]                   {
[10:21:12.738]                     {
[10:21:12.738]                       base::local({
[10:21:12.738]                         has_future <- base::requireNamespace("future", 
[10:21:12.738]                           quietly = TRUE)
[10:21:12.738]                         if (has_future) {
[10:21:12.738]                           ns <- base::getNamespace("future")
[10:21:12.738]                           version <- ns[[".package"]][["version"]]
[10:21:12.738]                           if (is.null(version)) 
[10:21:12.738]                             version <- utils::packageVersion("future")
[10:21:12.738]                         }
[10:21:12.738]                         else {
[10:21:12.738]                           version <- NULL
[10:21:12.738]                         }
[10:21:12.738]                         if (!has_future || version < "1.8.0") {
[10:21:12.738]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:12.738]                             "", base::R.version$version.string), 
[10:21:12.738]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:12.738]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:12.738]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:12.738]                               "release", "version")], collapse = " "), 
[10:21:12.738]                             hostname = base::Sys.info()[["nodename"]])
[10:21:12.738]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:12.738]                             info)
[10:21:12.738]                           info <- base::paste(info, collapse = "; ")
[10:21:12.738]                           if (!has_future) {
[10:21:12.738]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:12.738]                               info)
[10:21:12.738]                           }
[10:21:12.738]                           else {
[10:21:12.738]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:12.738]                               info, version)
[10:21:12.738]                           }
[10:21:12.738]                           base::stop(msg)
[10:21:12.738]                         }
[10:21:12.738]                       })
[10:21:12.738]                     }
[10:21:12.738]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:12.738]                     base::options(mc.cores = 1L)
[10:21:12.738]                   }
[10:21:12.738]                   ...future.strategy.old <- future::plan("list")
[10:21:12.738]                   options(future.plan = NULL)
[10:21:12.738]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.738]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:12.738]                 }
[10:21:12.738]                 ...future.workdir <- getwd()
[10:21:12.738]             }
[10:21:12.738]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:12.738]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:12.738]         }
[10:21:12.738]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:12.738]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:12.738]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:12.738]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:12.738]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:12.738]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:12.738]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:12.738]             base::names(...future.oldOptions))
[10:21:12.738]     }
[10:21:12.738]     if (FALSE) {
[10:21:12.738]     }
[10:21:12.738]     else {
[10:21:12.738]         if (TRUE) {
[10:21:12.738]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:12.738]                 open = "w")
[10:21:12.738]         }
[10:21:12.738]         else {
[10:21:12.738]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:12.738]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:12.738]         }
[10:21:12.738]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:12.738]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:12.738]             base::sink(type = "output", split = FALSE)
[10:21:12.738]             base::close(...future.stdout)
[10:21:12.738]         }, add = TRUE)
[10:21:12.738]     }
[10:21:12.738]     ...future.frame <- base::sys.nframe()
[10:21:12.738]     ...future.conditions <- base::list()
[10:21:12.738]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:12.738]     if (FALSE) {
[10:21:12.738]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:12.738]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:12.738]     }
[10:21:12.738]     ...future.result <- base::tryCatch({
[10:21:12.738]         base::withCallingHandlers({
[10:21:12.738]             ...future.value <- base::withVisible(base::local({
[10:21:12.738]                 withCallingHandlers({
[10:21:12.738]                   {
[10:21:12.738]                     2
[10:21:12.738]                   }
[10:21:12.738]                 }, immediateCondition = function(cond) {
[10:21:12.738]                   save_rds <- function (object, pathname, ...) 
[10:21:12.738]                   {
[10:21:12.738]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:12.738]                     if (file_test("-f", pathname_tmp)) {
[10:21:12.738]                       fi_tmp <- file.info(pathname_tmp)
[10:21:12.738]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:12.738]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:12.738]                         fi_tmp[["mtime"]])
[10:21:12.738]                     }
[10:21:12.738]                     tryCatch({
[10:21:12.738]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:12.738]                     }, error = function(ex) {
[10:21:12.738]                       msg <- conditionMessage(ex)
[10:21:12.738]                       fi_tmp <- file.info(pathname_tmp)
[10:21:12.738]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:12.738]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:12.738]                         fi_tmp[["mtime"]], msg)
[10:21:12.738]                       ex$message <- msg
[10:21:12.738]                       stop(ex)
[10:21:12.738]                     })
[10:21:12.738]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:12.738]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:12.738]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:12.738]                       fi_tmp <- file.info(pathname_tmp)
[10:21:12.738]                       fi <- file.info(pathname)
[10:21:12.738]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:12.738]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:12.738]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:12.738]                         fi[["size"]], fi[["mtime"]])
[10:21:12.738]                       stop(msg)
[10:21:12.738]                     }
[10:21:12.738]                     invisible(pathname)
[10:21:12.738]                   }
[10:21:12.738]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:12.738]                     rootPath = tempdir()) 
[10:21:12.738]                   {
[10:21:12.738]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:12.738]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:12.738]                       tmpdir = path, fileext = ".rds")
[10:21:12.738]                     save_rds(obj, file)
[10:21:12.738]                   }
[10:21:12.738]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3gePII/.future/immediateConditions")
[10:21:12.738]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.738]                   {
[10:21:12.738]                     inherits <- base::inherits
[10:21:12.738]                     invokeRestart <- base::invokeRestart
[10:21:12.738]                     is.null <- base::is.null
[10:21:12.738]                     muffled <- FALSE
[10:21:12.738]                     if (inherits(cond, "message")) {
[10:21:12.738]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:12.738]                       if (muffled) 
[10:21:12.738]                         invokeRestart("muffleMessage")
[10:21:12.738]                     }
[10:21:12.738]                     else if (inherits(cond, "warning")) {
[10:21:12.738]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:12.738]                       if (muffled) 
[10:21:12.738]                         invokeRestart("muffleWarning")
[10:21:12.738]                     }
[10:21:12.738]                     else if (inherits(cond, "condition")) {
[10:21:12.738]                       if (!is.null(pattern)) {
[10:21:12.738]                         computeRestarts <- base::computeRestarts
[10:21:12.738]                         grepl <- base::grepl
[10:21:12.738]                         restarts <- computeRestarts(cond)
[10:21:12.738]                         for (restart in restarts) {
[10:21:12.738]                           name <- restart$name
[10:21:12.738]                           if (is.null(name)) 
[10:21:12.738]                             next
[10:21:12.738]                           if (!grepl(pattern, name)) 
[10:21:12.738]                             next
[10:21:12.738]                           invokeRestart(restart)
[10:21:12.738]                           muffled <- TRUE
[10:21:12.738]                           break
[10:21:12.738]                         }
[10:21:12.738]                       }
[10:21:12.738]                     }
[10:21:12.738]                     invisible(muffled)
[10:21:12.738]                   }
[10:21:12.738]                   muffleCondition(cond)
[10:21:12.738]                 })
[10:21:12.738]             }))
[10:21:12.738]             future::FutureResult(value = ...future.value$value, 
[10:21:12.738]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.738]                   ...future.rng), globalenv = if (FALSE) 
[10:21:12.738]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:12.738]                     ...future.globalenv.names))
[10:21:12.738]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:12.738]         }, condition = base::local({
[10:21:12.738]             c <- base::c
[10:21:12.738]             inherits <- base::inherits
[10:21:12.738]             invokeRestart <- base::invokeRestart
[10:21:12.738]             length <- base::length
[10:21:12.738]             list <- base::list
[10:21:12.738]             seq.int <- base::seq.int
[10:21:12.738]             signalCondition <- base::signalCondition
[10:21:12.738]             sys.calls <- base::sys.calls
[10:21:12.738]             `[[` <- base::`[[`
[10:21:12.738]             `+` <- base::`+`
[10:21:12.738]             `<<-` <- base::`<<-`
[10:21:12.738]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:12.738]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:12.738]                   3L)]
[10:21:12.738]             }
[10:21:12.738]             function(cond) {
[10:21:12.738]                 is_error <- inherits(cond, "error")
[10:21:12.738]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:12.738]                   NULL)
[10:21:12.738]                 if (is_error) {
[10:21:12.738]                   sessionInformation <- function() {
[10:21:12.738]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:12.738]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:12.738]                       search = base::search(), system = base::Sys.info())
[10:21:12.738]                   }
[10:21:12.738]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.738]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:12.738]                     cond$call), session = sessionInformation(), 
[10:21:12.738]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:12.738]                   signalCondition(cond)
[10:21:12.738]                 }
[10:21:12.738]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:12.738]                 "immediateCondition"))) {
[10:21:12.738]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:12.738]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.738]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:12.738]                   if (TRUE && !signal) {
[10:21:12.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.738]                     {
[10:21:12.738]                       inherits <- base::inherits
[10:21:12.738]                       invokeRestart <- base::invokeRestart
[10:21:12.738]                       is.null <- base::is.null
[10:21:12.738]                       muffled <- FALSE
[10:21:12.738]                       if (inherits(cond, "message")) {
[10:21:12.738]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.738]                         if (muffled) 
[10:21:12.738]                           invokeRestart("muffleMessage")
[10:21:12.738]                       }
[10:21:12.738]                       else if (inherits(cond, "warning")) {
[10:21:12.738]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.738]                         if (muffled) 
[10:21:12.738]                           invokeRestart("muffleWarning")
[10:21:12.738]                       }
[10:21:12.738]                       else if (inherits(cond, "condition")) {
[10:21:12.738]                         if (!is.null(pattern)) {
[10:21:12.738]                           computeRestarts <- base::computeRestarts
[10:21:12.738]                           grepl <- base::grepl
[10:21:12.738]                           restarts <- computeRestarts(cond)
[10:21:12.738]                           for (restart in restarts) {
[10:21:12.738]                             name <- restart$name
[10:21:12.738]                             if (is.null(name)) 
[10:21:12.738]                               next
[10:21:12.738]                             if (!grepl(pattern, name)) 
[10:21:12.738]                               next
[10:21:12.738]                             invokeRestart(restart)
[10:21:12.738]                             muffled <- TRUE
[10:21:12.738]                             break
[10:21:12.738]                           }
[10:21:12.738]                         }
[10:21:12.738]                       }
[10:21:12.738]                       invisible(muffled)
[10:21:12.738]                     }
[10:21:12.738]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.738]                   }
[10:21:12.738]                 }
[10:21:12.738]                 else {
[10:21:12.738]                   if (TRUE) {
[10:21:12.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.738]                     {
[10:21:12.738]                       inherits <- base::inherits
[10:21:12.738]                       invokeRestart <- base::invokeRestart
[10:21:12.738]                       is.null <- base::is.null
[10:21:12.738]                       muffled <- FALSE
[10:21:12.738]                       if (inherits(cond, "message")) {
[10:21:12.738]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.738]                         if (muffled) 
[10:21:12.738]                           invokeRestart("muffleMessage")
[10:21:12.738]                       }
[10:21:12.738]                       else if (inherits(cond, "warning")) {
[10:21:12.738]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.738]                         if (muffled) 
[10:21:12.738]                           invokeRestart("muffleWarning")
[10:21:12.738]                       }
[10:21:12.738]                       else if (inherits(cond, "condition")) {
[10:21:12.738]                         if (!is.null(pattern)) {
[10:21:12.738]                           computeRestarts <- base::computeRestarts
[10:21:12.738]                           grepl <- base::grepl
[10:21:12.738]                           restarts <- computeRestarts(cond)
[10:21:12.738]                           for (restart in restarts) {
[10:21:12.738]                             name <- restart$name
[10:21:12.738]                             if (is.null(name)) 
[10:21:12.738]                               next
[10:21:12.738]                             if (!grepl(pattern, name)) 
[10:21:12.738]                               next
[10:21:12.738]                             invokeRestart(restart)
[10:21:12.738]                             muffled <- TRUE
[10:21:12.738]                             break
[10:21:12.738]                           }
[10:21:12.738]                         }
[10:21:12.738]                       }
[10:21:12.738]                       invisible(muffled)
[10:21:12.738]                     }
[10:21:12.738]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.738]                   }
[10:21:12.738]                 }
[10:21:12.738]             }
[10:21:12.738]         }))
[10:21:12.738]     }, error = function(ex) {
[10:21:12.738]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:12.738]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.738]                 ...future.rng), started = ...future.startTime, 
[10:21:12.738]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:12.738]             version = "1.8"), class = "FutureResult")
[10:21:12.738]     }, finally = {
[10:21:12.738]         if (!identical(...future.workdir, getwd())) 
[10:21:12.738]             setwd(...future.workdir)
[10:21:12.738]         {
[10:21:12.738]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:12.738]                 ...future.oldOptions$nwarnings <- NULL
[10:21:12.738]             }
[10:21:12.738]             base::options(...future.oldOptions)
[10:21:12.738]             if (.Platform$OS.type == "windows") {
[10:21:12.738]                 old_names <- names(...future.oldEnvVars)
[10:21:12.738]                 envs <- base::Sys.getenv()
[10:21:12.738]                 names <- names(envs)
[10:21:12.738]                 common <- intersect(names, old_names)
[10:21:12.738]                 added <- setdiff(names, old_names)
[10:21:12.738]                 removed <- setdiff(old_names, names)
[10:21:12.738]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:12.738]                   envs[common]]
[10:21:12.738]                 NAMES <- toupper(changed)
[10:21:12.738]                 args <- list()
[10:21:12.738]                 for (kk in seq_along(NAMES)) {
[10:21:12.738]                   name <- changed[[kk]]
[10:21:12.738]                   NAME <- NAMES[[kk]]
[10:21:12.738]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.738]                     next
[10:21:12.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.738]                 }
[10:21:12.738]                 NAMES <- toupper(added)
[10:21:12.738]                 for (kk in seq_along(NAMES)) {
[10:21:12.738]                   name <- added[[kk]]
[10:21:12.738]                   NAME <- NAMES[[kk]]
[10:21:12.738]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.738]                     next
[10:21:12.738]                   args[[name]] <- ""
[10:21:12.738]                 }
[10:21:12.738]                 NAMES <- toupper(removed)
[10:21:12.738]                 for (kk in seq_along(NAMES)) {
[10:21:12.738]                   name <- removed[[kk]]
[10:21:12.738]                   NAME <- NAMES[[kk]]
[10:21:12.738]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.738]                     next
[10:21:12.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.738]                 }
[10:21:12.738]                 if (length(args) > 0) 
[10:21:12.738]                   base::do.call(base::Sys.setenv, args = args)
[10:21:12.738]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:12.738]             }
[10:21:12.738]             else {
[10:21:12.738]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:12.738]             }
[10:21:12.738]             {
[10:21:12.738]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:12.738]                   0L) {
[10:21:12.738]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:12.738]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:12.738]                   base::options(opts)
[10:21:12.738]                 }
[10:21:12.738]                 {
[10:21:12.738]                   {
[10:21:12.738]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:12.738]                     NULL
[10:21:12.738]                   }
[10:21:12.738]                   options(future.plan = NULL)
[10:21:12.738]                   if (is.na(NA_character_)) 
[10:21:12.738]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.738]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:12.738]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:12.738]                     .init = FALSE)
[10:21:12.738]                 }
[10:21:12.738]             }
[10:21:12.738]         }
[10:21:12.738]     })
[10:21:12.738]     if (TRUE) {
[10:21:12.738]         base::sink(type = "output", split = FALSE)
[10:21:12.738]         if (TRUE) {
[10:21:12.738]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:12.738]         }
[10:21:12.738]         else {
[10:21:12.738]             ...future.result["stdout"] <- base::list(NULL)
[10:21:12.738]         }
[10:21:12.738]         base::close(...future.stdout)
[10:21:12.738]         ...future.stdout <- NULL
[10:21:12.738]     }
[10:21:12.738]     ...future.result$conditions <- ...future.conditions
[10:21:12.738]     ...future.result$finished <- base::Sys.time()
[10:21:12.738]     ...future.result
[10:21:12.738] }
[10:21:12.740] requestCore(): workers = 2
[10:21:12.743] MulticoreFuture started
[10:21:12.743] - Launch lazy future ... done
[10:21:12.744] plan(): Setting new future strategy stack:
[10:21:12.744] run() for ‘MulticoreFuture’ ... done
[10:21:12.744] getGlobalsAndPackages() ...
[10:21:12.744] Searching for globals...
[10:21:12.744] List of future strategies:
[10:21:12.744] 1. sequential:
[10:21:12.744]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.744]    - tweaked: FALSE
[10:21:12.744]    - call: NULL
[10:21:12.745] plan(): nbrOfWorkers() = 1
[10:21:12.746] - globals found: [1] ‘{’
[10:21:12.746] Searching for globals ... DONE
[10:21:12.747] Resolving globals: FALSE
[10:21:12.747] plan(): Setting new future strategy stack:
[10:21:12.747] List of future strategies:
[10:21:12.747] 1. multicore:
[10:21:12.747]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:12.747]    - tweaked: FALSE
[10:21:12.747]    - call: plan(strategy)
[10:21:12.747] 
[10:21:12.747] 
[10:21:12.747] getGlobalsAndPackages() ... DONE
[10:21:12.748] run() for ‘Future’ ...
[10:21:12.748] - state: ‘created’
[10:21:12.748] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:12.750] plan(): nbrOfWorkers() = 2
[10:21:12.751] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:12.752] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:12.752]   - Field: ‘label’
[10:21:12.752]   - Field: ‘local’
[10:21:12.752]   - Field: ‘owner’
[10:21:12.752]   - Field: ‘envir’
[10:21:12.753]   - Field: ‘workers’
[10:21:12.753]   - Field: ‘packages’
[10:21:12.753]   - Field: ‘gc’
[10:21:12.753]   - Field: ‘job’
[10:21:12.753]   - Field: ‘conditions’
[10:21:12.753]   - Field: ‘expr’
[10:21:12.754]   - Field: ‘uuid’
[10:21:12.754]   - Field: ‘seed’
[10:21:12.754]   - Field: ‘version’
[10:21:12.754]   - Field: ‘result’
[10:21:12.754]   - Field: ‘asynchronous’
[10:21:12.754]   - Field: ‘calls’
[10:21:12.755]   - Field: ‘globals’
[10:21:12.755]   - Field: ‘stdout’
[10:21:12.755]   - Field: ‘earlySignal’
[10:21:12.755]   - Field: ‘lazy’
[10:21:12.755]   - Field: ‘state’
[10:21:12.755] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:12.756] - Launch lazy future ...
[10:21:12.756] Packages needed by the future expression (n = 0): <none>
[10:21:12.756] Packages needed by future strategies (n = 0): <none>
[10:21:12.757] {
[10:21:12.757]     {
[10:21:12.757]         {
[10:21:12.757]             ...future.startTime <- base::Sys.time()
[10:21:12.757]             {
[10:21:12.757]                 {
[10:21:12.757]                   {
[10:21:12.757]                     {
[10:21:12.757]                       base::local({
[10:21:12.757]                         has_future <- base::requireNamespace("future", 
[10:21:12.757]                           quietly = TRUE)
[10:21:12.757]                         if (has_future) {
[10:21:12.757]                           ns <- base::getNamespace("future")
[10:21:12.757]                           version <- ns[[".package"]][["version"]]
[10:21:12.757]                           if (is.null(version)) 
[10:21:12.757]                             version <- utils::packageVersion("future")
[10:21:12.757]                         }
[10:21:12.757]                         else {
[10:21:12.757]                           version <- NULL
[10:21:12.757]                         }
[10:21:12.757]                         if (!has_future || version < "1.8.0") {
[10:21:12.757]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:12.757]                             "", base::R.version$version.string), 
[10:21:12.757]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:12.757]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:12.757]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:12.757]                               "release", "version")], collapse = " "), 
[10:21:12.757]                             hostname = base::Sys.info()[["nodename"]])
[10:21:12.757]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:12.757]                             info)
[10:21:12.757]                           info <- base::paste(info, collapse = "; ")
[10:21:12.757]                           if (!has_future) {
[10:21:12.757]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:12.757]                               info)
[10:21:12.757]                           }
[10:21:12.757]                           else {
[10:21:12.757]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:12.757]                               info, version)
[10:21:12.757]                           }
[10:21:12.757]                           base::stop(msg)
[10:21:12.757]                         }
[10:21:12.757]                       })
[10:21:12.757]                     }
[10:21:12.757]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:12.757]                     base::options(mc.cores = 1L)
[10:21:12.757]                   }
[10:21:12.757]                   ...future.strategy.old <- future::plan("list")
[10:21:12.757]                   options(future.plan = NULL)
[10:21:12.757]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.757]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:12.757]                 }
[10:21:12.757]                 ...future.workdir <- getwd()
[10:21:12.757]             }
[10:21:12.757]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:12.757]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:12.757]         }
[10:21:12.757]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:12.757]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:12.757]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:12.757]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:12.757]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:12.757]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:12.757]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:12.757]             base::names(...future.oldOptions))
[10:21:12.757]     }
[10:21:12.757]     if (FALSE) {
[10:21:12.757]     }
[10:21:12.757]     else {
[10:21:12.757]         if (TRUE) {
[10:21:12.757]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:12.757]                 open = "w")
[10:21:12.757]         }
[10:21:12.757]         else {
[10:21:12.757]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:12.757]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:12.757]         }
[10:21:12.757]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:12.757]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:12.757]             base::sink(type = "output", split = FALSE)
[10:21:12.757]             base::close(...future.stdout)
[10:21:12.757]         }, add = TRUE)
[10:21:12.757]     }
[10:21:12.757]     ...future.frame <- base::sys.nframe()
[10:21:12.757]     ...future.conditions <- base::list()
[10:21:12.757]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:12.757]     if (FALSE) {
[10:21:12.757]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:12.757]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:12.757]     }
[10:21:12.757]     ...future.result <- base::tryCatch({
[10:21:12.757]         base::withCallingHandlers({
[10:21:12.757]             ...future.value <- base::withVisible(base::local({
[10:21:12.757]                 withCallingHandlers({
[10:21:12.757]                   {
[10:21:12.757]                     4
[10:21:12.757]                   }
[10:21:12.757]                 }, immediateCondition = function(cond) {
[10:21:12.757]                   save_rds <- function (object, pathname, ...) 
[10:21:12.757]                   {
[10:21:12.757]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:12.757]                     if (file_test("-f", pathname_tmp)) {
[10:21:12.757]                       fi_tmp <- file.info(pathname_tmp)
[10:21:12.757]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:12.757]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:12.757]                         fi_tmp[["mtime"]])
[10:21:12.757]                     }
[10:21:12.757]                     tryCatch({
[10:21:12.757]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:12.757]                     }, error = function(ex) {
[10:21:12.757]                       msg <- conditionMessage(ex)
[10:21:12.757]                       fi_tmp <- file.info(pathname_tmp)
[10:21:12.757]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:12.757]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:12.757]                         fi_tmp[["mtime"]], msg)
[10:21:12.757]                       ex$message <- msg
[10:21:12.757]                       stop(ex)
[10:21:12.757]                     })
[10:21:12.757]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:12.757]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:12.757]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:12.757]                       fi_tmp <- file.info(pathname_tmp)
[10:21:12.757]                       fi <- file.info(pathname)
[10:21:12.757]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:12.757]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:12.757]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:12.757]                         fi[["size"]], fi[["mtime"]])
[10:21:12.757]                       stop(msg)
[10:21:12.757]                     }
[10:21:12.757]                     invisible(pathname)
[10:21:12.757]                   }
[10:21:12.757]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:12.757]                     rootPath = tempdir()) 
[10:21:12.757]                   {
[10:21:12.757]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:12.757]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:12.757]                       tmpdir = path, fileext = ".rds")
[10:21:12.757]                     save_rds(obj, file)
[10:21:12.757]                   }
[10:21:12.757]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3gePII/.future/immediateConditions")
[10:21:12.757]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.757]                   {
[10:21:12.757]                     inherits <- base::inherits
[10:21:12.757]                     invokeRestart <- base::invokeRestart
[10:21:12.757]                     is.null <- base::is.null
[10:21:12.757]                     muffled <- FALSE
[10:21:12.757]                     if (inherits(cond, "message")) {
[10:21:12.757]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:12.757]                       if (muffled) 
[10:21:12.757]                         invokeRestart("muffleMessage")
[10:21:12.757]                     }
[10:21:12.757]                     else if (inherits(cond, "warning")) {
[10:21:12.757]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:12.757]                       if (muffled) 
[10:21:12.757]                         invokeRestart("muffleWarning")
[10:21:12.757]                     }
[10:21:12.757]                     else if (inherits(cond, "condition")) {
[10:21:12.757]                       if (!is.null(pattern)) {
[10:21:12.757]                         computeRestarts <- base::computeRestarts
[10:21:12.757]                         grepl <- base::grepl
[10:21:12.757]                         restarts <- computeRestarts(cond)
[10:21:12.757]                         for (restart in restarts) {
[10:21:12.757]                           name <- restart$name
[10:21:12.757]                           if (is.null(name)) 
[10:21:12.757]                             next
[10:21:12.757]                           if (!grepl(pattern, name)) 
[10:21:12.757]                             next
[10:21:12.757]                           invokeRestart(restart)
[10:21:12.757]                           muffled <- TRUE
[10:21:12.757]                           break
[10:21:12.757]                         }
[10:21:12.757]                       }
[10:21:12.757]                     }
[10:21:12.757]                     invisible(muffled)
[10:21:12.757]                   }
[10:21:12.757]                   muffleCondition(cond)
[10:21:12.757]                 })
[10:21:12.757]             }))
[10:21:12.757]             future::FutureResult(value = ...future.value$value, 
[10:21:12.757]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.757]                   ...future.rng), globalenv = if (FALSE) 
[10:21:12.757]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:12.757]                     ...future.globalenv.names))
[10:21:12.757]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:12.757]         }, condition = base::local({
[10:21:12.757]             c <- base::c
[10:21:12.757]             inherits <- base::inherits
[10:21:12.757]             invokeRestart <- base::invokeRestart
[10:21:12.757]             length <- base::length
[10:21:12.757]             list <- base::list
[10:21:12.757]             seq.int <- base::seq.int
[10:21:12.757]             signalCondition <- base::signalCondition
[10:21:12.757]             sys.calls <- base::sys.calls
[10:21:12.757]             `[[` <- base::`[[`
[10:21:12.757]             `+` <- base::`+`
[10:21:12.757]             `<<-` <- base::`<<-`
[10:21:12.757]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:12.757]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:12.757]                   3L)]
[10:21:12.757]             }
[10:21:12.757]             function(cond) {
[10:21:12.757]                 is_error <- inherits(cond, "error")
[10:21:12.757]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:12.757]                   NULL)
[10:21:12.757]                 if (is_error) {
[10:21:12.757]                   sessionInformation <- function() {
[10:21:12.757]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:12.757]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:12.757]                       search = base::search(), system = base::Sys.info())
[10:21:12.757]                   }
[10:21:12.757]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.757]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:12.757]                     cond$call), session = sessionInformation(), 
[10:21:12.757]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:12.757]                   signalCondition(cond)
[10:21:12.757]                 }
[10:21:12.757]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:12.757]                 "immediateCondition"))) {
[10:21:12.757]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:12.757]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.757]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:12.757]                   if (TRUE && !signal) {
[10:21:12.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.757]                     {
[10:21:12.757]                       inherits <- base::inherits
[10:21:12.757]                       invokeRestart <- base::invokeRestart
[10:21:12.757]                       is.null <- base::is.null
[10:21:12.757]                       muffled <- FALSE
[10:21:12.757]                       if (inherits(cond, "message")) {
[10:21:12.757]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.757]                         if (muffled) 
[10:21:12.757]                           invokeRestart("muffleMessage")
[10:21:12.757]                       }
[10:21:12.757]                       else if (inherits(cond, "warning")) {
[10:21:12.757]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.757]                         if (muffled) 
[10:21:12.757]                           invokeRestart("muffleWarning")
[10:21:12.757]                       }
[10:21:12.757]                       else if (inherits(cond, "condition")) {
[10:21:12.757]                         if (!is.null(pattern)) {
[10:21:12.757]                           computeRestarts <- base::computeRestarts
[10:21:12.757]                           grepl <- base::grepl
[10:21:12.757]                           restarts <- computeRestarts(cond)
[10:21:12.757]                           for (restart in restarts) {
[10:21:12.757]                             name <- restart$name
[10:21:12.757]                             if (is.null(name)) 
[10:21:12.757]                               next
[10:21:12.757]                             if (!grepl(pattern, name)) 
[10:21:12.757]                               next
[10:21:12.757]                             invokeRestart(restart)
[10:21:12.757]                             muffled <- TRUE
[10:21:12.757]                             break
[10:21:12.757]                           }
[10:21:12.757]                         }
[10:21:12.757]                       }
[10:21:12.757]                       invisible(muffled)
[10:21:12.757]                     }
[10:21:12.757]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.757]                   }
[10:21:12.757]                 }
[10:21:12.757]                 else {
[10:21:12.757]                   if (TRUE) {
[10:21:12.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.757]                     {
[10:21:12.757]                       inherits <- base::inherits
[10:21:12.757]                       invokeRestart <- base::invokeRestart
[10:21:12.757]                       is.null <- base::is.null
[10:21:12.757]                       muffled <- FALSE
[10:21:12.757]                       if (inherits(cond, "message")) {
[10:21:12.757]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.757]                         if (muffled) 
[10:21:12.757]                           invokeRestart("muffleMessage")
[10:21:12.757]                       }
[10:21:12.757]                       else if (inherits(cond, "warning")) {
[10:21:12.757]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.757]                         if (muffled) 
[10:21:12.757]                           invokeRestart("muffleWarning")
[10:21:12.757]                       }
[10:21:12.757]                       else if (inherits(cond, "condition")) {
[10:21:12.757]                         if (!is.null(pattern)) {
[10:21:12.757]                           computeRestarts <- base::computeRestarts
[10:21:12.757]                           grepl <- base::grepl
[10:21:12.757]                           restarts <- computeRestarts(cond)
[10:21:12.757]                           for (restart in restarts) {
[10:21:12.757]                             name <- restart$name
[10:21:12.757]                             if (is.null(name)) 
[10:21:12.757]                               next
[10:21:12.757]                             if (!grepl(pattern, name)) 
[10:21:12.757]                               next
[10:21:12.757]                             invokeRestart(restart)
[10:21:12.757]                             muffled <- TRUE
[10:21:12.757]                             break
[10:21:12.757]                           }
[10:21:12.757]                         }
[10:21:12.757]                       }
[10:21:12.757]                       invisible(muffled)
[10:21:12.757]                     }
[10:21:12.757]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.757]                   }
[10:21:12.757]                 }
[10:21:12.757]             }
[10:21:12.757]         }))
[10:21:12.757]     }, error = function(ex) {
[10:21:12.757]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:12.757]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.757]                 ...future.rng), started = ...future.startTime, 
[10:21:12.757]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:12.757]             version = "1.8"), class = "FutureResult")
[10:21:12.757]     }, finally = {
[10:21:12.757]         if (!identical(...future.workdir, getwd())) 
[10:21:12.757]             setwd(...future.workdir)
[10:21:12.757]         {
[10:21:12.757]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:12.757]                 ...future.oldOptions$nwarnings <- NULL
[10:21:12.757]             }
[10:21:12.757]             base::options(...future.oldOptions)
[10:21:12.757]             if (.Platform$OS.type == "windows") {
[10:21:12.757]                 old_names <- names(...future.oldEnvVars)
[10:21:12.757]                 envs <- base::Sys.getenv()
[10:21:12.757]                 names <- names(envs)
[10:21:12.757]                 common <- intersect(names, old_names)
[10:21:12.757]                 added <- setdiff(names, old_names)
[10:21:12.757]                 removed <- setdiff(old_names, names)
[10:21:12.757]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:12.757]                   envs[common]]
[10:21:12.757]                 NAMES <- toupper(changed)
[10:21:12.757]                 args <- list()
[10:21:12.757]                 for (kk in seq_along(NAMES)) {
[10:21:12.757]                   name <- changed[[kk]]
[10:21:12.757]                   NAME <- NAMES[[kk]]
[10:21:12.757]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.757]                     next
[10:21:12.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.757]                 }
[10:21:12.757]                 NAMES <- toupper(added)
[10:21:12.757]                 for (kk in seq_along(NAMES)) {
[10:21:12.757]                   name <- added[[kk]]
[10:21:12.757]                   NAME <- NAMES[[kk]]
[10:21:12.757]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.757]                     next
[10:21:12.757]                   args[[name]] <- ""
[10:21:12.757]                 }
[10:21:12.757]                 NAMES <- toupper(removed)
[10:21:12.757]                 for (kk in seq_along(NAMES)) {
[10:21:12.757]                   name <- removed[[kk]]
[10:21:12.757]                   NAME <- NAMES[[kk]]
[10:21:12.757]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.757]                     next
[10:21:12.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.757]                 }
[10:21:12.757]                 if (length(args) > 0) 
[10:21:12.757]                   base::do.call(base::Sys.setenv, args = args)
[10:21:12.757]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:12.757]             }
[10:21:12.757]             else {
[10:21:12.757]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:12.757]             }
[10:21:12.757]             {
[10:21:12.757]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:12.757]                   0L) {
[10:21:12.757]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:12.757]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:12.757]                   base::options(opts)
[10:21:12.757]                 }
[10:21:12.757]                 {
[10:21:12.757]                   {
[10:21:12.757]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:12.757]                     NULL
[10:21:12.757]                   }
[10:21:12.757]                   options(future.plan = NULL)
[10:21:12.757]                   if (is.na(NA_character_)) 
[10:21:12.757]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.757]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:12.757]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:12.757]                     .init = FALSE)
[10:21:12.757]                 }
[10:21:12.757]             }
[10:21:12.757]         }
[10:21:12.757]     })
[10:21:12.757]     if (TRUE) {
[10:21:12.757]         base::sink(type = "output", split = FALSE)
[10:21:12.757]         if (TRUE) {
[10:21:12.757]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:12.757]         }
[10:21:12.757]         else {
[10:21:12.757]             ...future.result["stdout"] <- base::list(NULL)
[10:21:12.757]         }
[10:21:12.757]         base::close(...future.stdout)
[10:21:12.757]         ...future.stdout <- NULL
[10:21:12.757]     }
[10:21:12.757]     ...future.result$conditions <- ...future.conditions
[10:21:12.757]     ...future.result$finished <- base::Sys.time()
[10:21:12.757]     ...future.result
[10:21:12.757] }
[10:21:12.761] requestCore(): workers = 2
[10:21:12.769] MulticoreFuture started
[10:21:12.769] - Launch lazy future ... done
[10:21:12.769] run() for ‘MulticoreFuture’ ... done
[10:21:12.769] plan(): Setting new future strategy stack:
[10:21:12.770] List of future strategies:
[10:21:12.770] 1. sequential:
[10:21:12.770]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.770]    - tweaked: FALSE
[10:21:12.770]    - call: NULL
[10:21:12.771] result() for MulticoreFuture ...
[10:21:12.771] plan(): nbrOfWorkers() = 1
[10:21:12.773] plan(): Setting new future strategy stack:
[10:21:12.773] List of future strategies:
[10:21:12.773] 1. multicore:
[10:21:12.773]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:12.773]    - tweaked: FALSE
[10:21:12.773]    - call: plan(strategy)
[10:21:12.774] result() for MulticoreFuture ...
[10:21:12.774] result() for MulticoreFuture ... done
[10:21:12.774] result() for MulticoreFuture ... done
[10:21:12.774] result() for MulticoreFuture ...
[10:21:12.774] result() for MulticoreFuture ... done
u$a = 2
[10:21:12.774] result() for MulticoreFuture ...
[10:21:12.777] plan(): nbrOfWorkers() = 2
[10:21:12.777] result() for MulticoreFuture ...
[10:21:12.777] result() for MulticoreFuture ... done
[10:21:12.777] result() for MulticoreFuture ... done
[10:21:12.778] result() for MulticoreFuture ...
[10:21:12.778] result() for MulticoreFuture ... done
v$a = 4
[10:21:12.781] getGlobalsAndPackages() ...
[10:21:12.781] Searching for globals...
[10:21:12.783] - globals found: [3] ‘{’, ‘*’, ‘a’
[10:21:12.783] Searching for globals ... DONE
[10:21:12.783] Resolving globals: FALSE
[10:21:12.784] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:12.784] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:12.784] - globals: [1] ‘a’
[10:21:12.784] 
[10:21:12.785] getGlobalsAndPackages() ... DONE
[10:21:12.785] run() for ‘Future’ ...
[10:21:12.785] - state: ‘created’
[10:21:12.785] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:12.787] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:12.787] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:12.788]   - Field: ‘label’
[10:21:12.788]   - Field: ‘local’
[10:21:12.788]   - Field: ‘owner’
[10:21:12.788]   - Field: ‘envir’
[10:21:12.788]   - Field: ‘workers’
[10:21:12.788]   - Field: ‘packages’
[10:21:12.788]   - Field: ‘gc’
[10:21:12.788]   - Field: ‘job’
[10:21:12.788]   - Field: ‘conditions’
[10:21:12.789]   - Field: ‘expr’
[10:21:12.789]   - Field: ‘uuid’
[10:21:12.789]   - Field: ‘seed’
[10:21:12.789]   - Field: ‘version’
[10:21:12.789]   - Field: ‘result’
[10:21:12.789]   - Field: ‘asynchronous’
[10:21:12.789]   - Field: ‘calls’
[10:21:12.789]   - Field: ‘globals’
[10:21:12.790]   - Field: ‘stdout’
[10:21:12.790]   - Field: ‘earlySignal’
[10:21:12.790]   - Field: ‘lazy’
[10:21:12.790]   - Field: ‘state’
[10:21:12.790] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:12.790] - Launch lazy future ...
[10:21:12.790] Packages needed by the future expression (n = 0): <none>
[10:21:12.791] Packages needed by future strategies (n = 0): <none>
[10:21:12.791] {
[10:21:12.791]     {
[10:21:12.791]         {
[10:21:12.791]             ...future.startTime <- base::Sys.time()
[10:21:12.791]             {
[10:21:12.791]                 {
[10:21:12.791]                   {
[10:21:12.791]                     {
[10:21:12.791]                       base::local({
[10:21:12.791]                         has_future <- base::requireNamespace("future", 
[10:21:12.791]                           quietly = TRUE)
[10:21:12.791]                         if (has_future) {
[10:21:12.791]                           ns <- base::getNamespace("future")
[10:21:12.791]                           version <- ns[[".package"]][["version"]]
[10:21:12.791]                           if (is.null(version)) 
[10:21:12.791]                             version <- utils::packageVersion("future")
[10:21:12.791]                         }
[10:21:12.791]                         else {
[10:21:12.791]                           version <- NULL
[10:21:12.791]                         }
[10:21:12.791]                         if (!has_future || version < "1.8.0") {
[10:21:12.791]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:12.791]                             "", base::R.version$version.string), 
[10:21:12.791]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:12.791]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:12.791]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:12.791]                               "release", "version")], collapse = " "), 
[10:21:12.791]                             hostname = base::Sys.info()[["nodename"]])
[10:21:12.791]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:12.791]                             info)
[10:21:12.791]                           info <- base::paste(info, collapse = "; ")
[10:21:12.791]                           if (!has_future) {
[10:21:12.791]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:12.791]                               info)
[10:21:12.791]                           }
[10:21:12.791]                           else {
[10:21:12.791]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:12.791]                               info, version)
[10:21:12.791]                           }
[10:21:12.791]                           base::stop(msg)
[10:21:12.791]                         }
[10:21:12.791]                       })
[10:21:12.791]                     }
[10:21:12.791]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:12.791]                     base::options(mc.cores = 1L)
[10:21:12.791]                   }
[10:21:12.791]                   ...future.strategy.old <- future::plan("list")
[10:21:12.791]                   options(future.plan = NULL)
[10:21:12.791]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.791]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:12.791]                 }
[10:21:12.791]                 ...future.workdir <- getwd()
[10:21:12.791]             }
[10:21:12.791]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:12.791]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:12.791]         }
[10:21:12.791]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:12.791]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:12.791]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:12.791]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:12.791]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:12.791]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:12.791]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:12.791]             base::names(...future.oldOptions))
[10:21:12.791]     }
[10:21:12.791]     if (FALSE) {
[10:21:12.791]     }
[10:21:12.791]     else {
[10:21:12.791]         if (TRUE) {
[10:21:12.791]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:12.791]                 open = "w")
[10:21:12.791]         }
[10:21:12.791]         else {
[10:21:12.791]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:12.791]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:12.791]         }
[10:21:12.791]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:12.791]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:12.791]             base::sink(type = "output", split = FALSE)
[10:21:12.791]             base::close(...future.stdout)
[10:21:12.791]         }, add = TRUE)
[10:21:12.791]     }
[10:21:12.791]     ...future.frame <- base::sys.nframe()
[10:21:12.791]     ...future.conditions <- base::list()
[10:21:12.791]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:12.791]     if (FALSE) {
[10:21:12.791]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:12.791]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:12.791]     }
[10:21:12.791]     ...future.result <- base::tryCatch({
[10:21:12.791]         base::withCallingHandlers({
[10:21:12.791]             ...future.value <- base::withVisible(base::local({
[10:21:12.791]                 withCallingHandlers({
[10:21:12.791]                   {
[10:21:12.791]                     2 * a
[10:21:12.791]                   }
[10:21:12.791]                 }, immediateCondition = function(cond) {
[10:21:12.791]                   save_rds <- function (object, pathname, ...) 
[10:21:12.791]                   {
[10:21:12.791]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:12.791]                     if (file_test("-f", pathname_tmp)) {
[10:21:12.791]                       fi_tmp <- file.info(pathname_tmp)
[10:21:12.791]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:12.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:12.791]                         fi_tmp[["mtime"]])
[10:21:12.791]                     }
[10:21:12.791]                     tryCatch({
[10:21:12.791]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:12.791]                     }, error = function(ex) {
[10:21:12.791]                       msg <- conditionMessage(ex)
[10:21:12.791]                       fi_tmp <- file.info(pathname_tmp)
[10:21:12.791]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:12.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:12.791]                         fi_tmp[["mtime"]], msg)
[10:21:12.791]                       ex$message <- msg
[10:21:12.791]                       stop(ex)
[10:21:12.791]                     })
[10:21:12.791]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:12.791]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:12.791]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:12.791]                       fi_tmp <- file.info(pathname_tmp)
[10:21:12.791]                       fi <- file.info(pathname)
[10:21:12.791]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:12.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:12.791]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:12.791]                         fi[["size"]], fi[["mtime"]])
[10:21:12.791]                       stop(msg)
[10:21:12.791]                     }
[10:21:12.791]                     invisible(pathname)
[10:21:12.791]                   }
[10:21:12.791]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:12.791]                     rootPath = tempdir()) 
[10:21:12.791]                   {
[10:21:12.791]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:12.791]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:12.791]                       tmpdir = path, fileext = ".rds")
[10:21:12.791]                     save_rds(obj, file)
[10:21:12.791]                   }
[10:21:12.791]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3gePII/.future/immediateConditions")
[10:21:12.791]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.791]                   {
[10:21:12.791]                     inherits <- base::inherits
[10:21:12.791]                     invokeRestart <- base::invokeRestart
[10:21:12.791]                     is.null <- base::is.null
[10:21:12.791]                     muffled <- FALSE
[10:21:12.791]                     if (inherits(cond, "message")) {
[10:21:12.791]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:12.791]                       if (muffled) 
[10:21:12.791]                         invokeRestart("muffleMessage")
[10:21:12.791]                     }
[10:21:12.791]                     else if (inherits(cond, "warning")) {
[10:21:12.791]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:12.791]                       if (muffled) 
[10:21:12.791]                         invokeRestart("muffleWarning")
[10:21:12.791]                     }
[10:21:12.791]                     else if (inherits(cond, "condition")) {
[10:21:12.791]                       if (!is.null(pattern)) {
[10:21:12.791]                         computeRestarts <- base::computeRestarts
[10:21:12.791]                         grepl <- base::grepl
[10:21:12.791]                         restarts <- computeRestarts(cond)
[10:21:12.791]                         for (restart in restarts) {
[10:21:12.791]                           name <- restart$name
[10:21:12.791]                           if (is.null(name)) 
[10:21:12.791]                             next
[10:21:12.791]                           if (!grepl(pattern, name)) 
[10:21:12.791]                             next
[10:21:12.791]                           invokeRestart(restart)
[10:21:12.791]                           muffled <- TRUE
[10:21:12.791]                           break
[10:21:12.791]                         }
[10:21:12.791]                       }
[10:21:12.791]                     }
[10:21:12.791]                     invisible(muffled)
[10:21:12.791]                   }
[10:21:12.791]                   muffleCondition(cond)
[10:21:12.791]                 })
[10:21:12.791]             }))
[10:21:12.791]             future::FutureResult(value = ...future.value$value, 
[10:21:12.791]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.791]                   ...future.rng), globalenv = if (FALSE) 
[10:21:12.791]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:12.791]                     ...future.globalenv.names))
[10:21:12.791]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:12.791]         }, condition = base::local({
[10:21:12.791]             c <- base::c
[10:21:12.791]             inherits <- base::inherits
[10:21:12.791]             invokeRestart <- base::invokeRestart
[10:21:12.791]             length <- base::length
[10:21:12.791]             list <- base::list
[10:21:12.791]             seq.int <- base::seq.int
[10:21:12.791]             signalCondition <- base::signalCondition
[10:21:12.791]             sys.calls <- base::sys.calls
[10:21:12.791]             `[[` <- base::`[[`
[10:21:12.791]             `+` <- base::`+`
[10:21:12.791]             `<<-` <- base::`<<-`
[10:21:12.791]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:12.791]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:12.791]                   3L)]
[10:21:12.791]             }
[10:21:12.791]             function(cond) {
[10:21:12.791]                 is_error <- inherits(cond, "error")
[10:21:12.791]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:12.791]                   NULL)
[10:21:12.791]                 if (is_error) {
[10:21:12.791]                   sessionInformation <- function() {
[10:21:12.791]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:12.791]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:12.791]                       search = base::search(), system = base::Sys.info())
[10:21:12.791]                   }
[10:21:12.791]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.791]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:12.791]                     cond$call), session = sessionInformation(), 
[10:21:12.791]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:12.791]                   signalCondition(cond)
[10:21:12.791]                 }
[10:21:12.791]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:12.791]                 "immediateCondition"))) {
[10:21:12.791]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:12.791]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.791]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:12.791]                   if (TRUE && !signal) {
[10:21:12.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.791]                     {
[10:21:12.791]                       inherits <- base::inherits
[10:21:12.791]                       invokeRestart <- base::invokeRestart
[10:21:12.791]                       is.null <- base::is.null
[10:21:12.791]                       muffled <- FALSE
[10:21:12.791]                       if (inherits(cond, "message")) {
[10:21:12.791]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.791]                         if (muffled) 
[10:21:12.791]                           invokeRestart("muffleMessage")
[10:21:12.791]                       }
[10:21:12.791]                       else if (inherits(cond, "warning")) {
[10:21:12.791]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.791]                         if (muffled) 
[10:21:12.791]                           invokeRestart("muffleWarning")
[10:21:12.791]                       }
[10:21:12.791]                       else if (inherits(cond, "condition")) {
[10:21:12.791]                         if (!is.null(pattern)) {
[10:21:12.791]                           computeRestarts <- base::computeRestarts
[10:21:12.791]                           grepl <- base::grepl
[10:21:12.791]                           restarts <- computeRestarts(cond)
[10:21:12.791]                           for (restart in restarts) {
[10:21:12.791]                             name <- restart$name
[10:21:12.791]                             if (is.null(name)) 
[10:21:12.791]                               next
[10:21:12.791]                             if (!grepl(pattern, name)) 
[10:21:12.791]                               next
[10:21:12.791]                             invokeRestart(restart)
[10:21:12.791]                             muffled <- TRUE
[10:21:12.791]                             break
[10:21:12.791]                           }
[10:21:12.791]                         }
[10:21:12.791]                       }
[10:21:12.791]                       invisible(muffled)
[10:21:12.791]                     }
[10:21:12.791]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.791]                   }
[10:21:12.791]                 }
[10:21:12.791]                 else {
[10:21:12.791]                   if (TRUE) {
[10:21:12.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.791]                     {
[10:21:12.791]                       inherits <- base::inherits
[10:21:12.791]                       invokeRestart <- base::invokeRestart
[10:21:12.791]                       is.null <- base::is.null
[10:21:12.791]                       muffled <- FALSE
[10:21:12.791]                       if (inherits(cond, "message")) {
[10:21:12.791]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.791]                         if (muffled) 
[10:21:12.791]                           invokeRestart("muffleMessage")
[10:21:12.791]                       }
[10:21:12.791]                       else if (inherits(cond, "warning")) {
[10:21:12.791]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.791]                         if (muffled) 
[10:21:12.791]                           invokeRestart("muffleWarning")
[10:21:12.791]                       }
[10:21:12.791]                       else if (inherits(cond, "condition")) {
[10:21:12.791]                         if (!is.null(pattern)) {
[10:21:12.791]                           computeRestarts <- base::computeRestarts
[10:21:12.791]                           grepl <- base::grepl
[10:21:12.791]                           restarts <- computeRestarts(cond)
[10:21:12.791]                           for (restart in restarts) {
[10:21:12.791]                             name <- restart$name
[10:21:12.791]                             if (is.null(name)) 
[10:21:12.791]                               next
[10:21:12.791]                             if (!grepl(pattern, name)) 
[10:21:12.791]                               next
[10:21:12.791]                             invokeRestart(restart)
[10:21:12.791]                             muffled <- TRUE
[10:21:12.791]                             break
[10:21:12.791]                           }
[10:21:12.791]                         }
[10:21:12.791]                       }
[10:21:12.791]                       invisible(muffled)
[10:21:12.791]                     }
[10:21:12.791]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.791]                   }
[10:21:12.791]                 }
[10:21:12.791]             }
[10:21:12.791]         }))
[10:21:12.791]     }, error = function(ex) {
[10:21:12.791]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:12.791]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.791]                 ...future.rng), started = ...future.startTime, 
[10:21:12.791]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:12.791]             version = "1.8"), class = "FutureResult")
[10:21:12.791]     }, finally = {
[10:21:12.791]         if (!identical(...future.workdir, getwd())) 
[10:21:12.791]             setwd(...future.workdir)
[10:21:12.791]         {
[10:21:12.791]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:12.791]                 ...future.oldOptions$nwarnings <- NULL
[10:21:12.791]             }
[10:21:12.791]             base::options(...future.oldOptions)
[10:21:12.791]             if (.Platform$OS.type == "windows") {
[10:21:12.791]                 old_names <- names(...future.oldEnvVars)
[10:21:12.791]                 envs <- base::Sys.getenv()
[10:21:12.791]                 names <- names(envs)
[10:21:12.791]                 common <- intersect(names, old_names)
[10:21:12.791]                 added <- setdiff(names, old_names)
[10:21:12.791]                 removed <- setdiff(old_names, names)
[10:21:12.791]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:12.791]                   envs[common]]
[10:21:12.791]                 NAMES <- toupper(changed)
[10:21:12.791]                 args <- list()
[10:21:12.791]                 for (kk in seq_along(NAMES)) {
[10:21:12.791]                   name <- changed[[kk]]
[10:21:12.791]                   NAME <- NAMES[[kk]]
[10:21:12.791]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.791]                     next
[10:21:12.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.791]                 }
[10:21:12.791]                 NAMES <- toupper(added)
[10:21:12.791]                 for (kk in seq_along(NAMES)) {
[10:21:12.791]                   name <- added[[kk]]
[10:21:12.791]                   NAME <- NAMES[[kk]]
[10:21:12.791]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.791]                     next
[10:21:12.791]                   args[[name]] <- ""
[10:21:12.791]                 }
[10:21:12.791]                 NAMES <- toupper(removed)
[10:21:12.791]                 for (kk in seq_along(NAMES)) {
[10:21:12.791]                   name <- removed[[kk]]
[10:21:12.791]                   NAME <- NAMES[[kk]]
[10:21:12.791]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.791]                     next
[10:21:12.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.791]                 }
[10:21:12.791]                 if (length(args) > 0) 
[10:21:12.791]                   base::do.call(base::Sys.setenv, args = args)
[10:21:12.791]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:12.791]             }
[10:21:12.791]             else {
[10:21:12.791]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:12.791]             }
[10:21:12.791]             {
[10:21:12.791]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:12.791]                   0L) {
[10:21:12.791]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:12.791]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:12.791]                   base::options(opts)
[10:21:12.791]                 }
[10:21:12.791]                 {
[10:21:12.791]                   {
[10:21:12.791]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:12.791]                     NULL
[10:21:12.791]                   }
[10:21:12.791]                   options(future.plan = NULL)
[10:21:12.791]                   if (is.na(NA_character_)) 
[10:21:12.791]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.791]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:12.791]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:12.791]                     .init = FALSE)
[10:21:12.791]                 }
[10:21:12.791]             }
[10:21:12.791]         }
[10:21:12.791]     })
[10:21:12.791]     if (TRUE) {
[10:21:12.791]         base::sink(type = "output", split = FALSE)
[10:21:12.791]         if (TRUE) {
[10:21:12.791]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:12.791]         }
[10:21:12.791]         else {
[10:21:12.791]             ...future.result["stdout"] <- base::list(NULL)
[10:21:12.791]         }
[10:21:12.791]         base::close(...future.stdout)
[10:21:12.791]         ...future.stdout <- NULL
[10:21:12.791]     }
[10:21:12.791]     ...future.result$conditions <- ...future.conditions
[10:21:12.791]     ...future.result$finished <- base::Sys.time()
[10:21:12.791]     ...future.result
[10:21:12.791] }
[10:21:12.793] assign_globals() ...
[10:21:12.794] List of 1
[10:21:12.794]  $ a: num 1
[10:21:12.794]  - attr(*, "where")=List of 1
[10:21:12.794]   ..$ a:<environment: R_EmptyEnv> 
[10:21:12.794]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:12.794]  - attr(*, "resolved")= logi FALSE
[10:21:12.794]  - attr(*, "total_size")= num 39
[10:21:12.794]  - attr(*, "already-done")= logi TRUE
[10:21:12.797] - copied ‘a’ to environment
[10:21:12.797] assign_globals() ... done
[10:21:12.797] requestCore(): workers = 2
[10:21:12.799] MulticoreFuture started
[10:21:12.800] - Launch lazy future ... done
[10:21:12.800] run() for ‘MulticoreFuture’ ... done
[10:21:12.800] result() for MulticoreFuture ...
[10:21:12.800] plan(): Setting new future strategy stack:
[10:21:12.801] List of future strategies:
[10:21:12.801] 1. sequential:
[10:21:12.801]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.801]    - tweaked: FALSE
[10:21:12.801]    - call: NULL
[10:21:12.802] plan(): nbrOfWorkers() = 1
[10:21:12.804] plan(): Setting new future strategy stack:
[10:21:12.804] List of future strategies:
[10:21:12.804] 1. multicore:
[10:21:12.804]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:12.804]    - tweaked: FALSE
[10:21:12.804]    - call: plan(strategy)
[10:21:12.807] plan(): nbrOfWorkers() = 2
[10:21:12.808] result() for MulticoreFuture ...
[10:21:12.808] result() for MulticoreFuture ... done
[10:21:12.808] result() for MulticoreFuture ... done
[10:21:12.808] result() for MulticoreFuture ...
[10:21:12.808] result() for MulticoreFuture ... done
[10:21:12.809] getGlobalsAndPackages() ...
[10:21:12.809] Searching for globals...
[10:21:12.810] - globals found: [3] ‘{’, ‘*’, ‘a’
[10:21:12.810] Searching for globals ... DONE
[10:21:12.810] Resolving globals: FALSE
[10:21:12.811] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:12.811] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:12.812] - globals: [1] ‘a’
[10:21:12.812] 
[10:21:12.812] getGlobalsAndPackages() ... DONE
[10:21:12.812] run() for ‘Future’ ...
[10:21:12.812] - state: ‘created’
[10:21:12.812] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:12.815] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:12.815] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:12.815]   - Field: ‘label’
[10:21:12.815]   - Field: ‘local’
[10:21:12.815]   - Field: ‘owner’
[10:21:12.815]   - Field: ‘envir’
[10:21:12.815]   - Field: ‘workers’
[10:21:12.815]   - Field: ‘packages’
[10:21:12.816]   - Field: ‘gc’
[10:21:12.816]   - Field: ‘job’
[10:21:12.816]   - Field: ‘conditions’
[10:21:12.816]   - Field: ‘expr’
[10:21:12.816]   - Field: ‘uuid’
[10:21:12.816]   - Field: ‘seed’
[10:21:12.816]   - Field: ‘version’
[10:21:12.816]   - Field: ‘result’
[10:21:12.817]   - Field: ‘asynchronous’
[10:21:12.817]   - Field: ‘calls’
[10:21:12.817]   - Field: ‘globals’
[10:21:12.817]   - Field: ‘stdout’
[10:21:12.817]   - Field: ‘earlySignal’
[10:21:12.817]   - Field: ‘lazy’
[10:21:12.817]   - Field: ‘state’
[10:21:12.817] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:12.817] - Launch lazy future ...
[10:21:12.818] Packages needed by the future expression (n = 0): <none>
[10:21:12.818] Packages needed by future strategies (n = 0): <none>
[10:21:12.818] {
[10:21:12.818]     {
[10:21:12.818]         {
[10:21:12.818]             ...future.startTime <- base::Sys.time()
[10:21:12.818]             {
[10:21:12.818]                 {
[10:21:12.818]                   {
[10:21:12.818]                     {
[10:21:12.818]                       base::local({
[10:21:12.818]                         has_future <- base::requireNamespace("future", 
[10:21:12.818]                           quietly = TRUE)
[10:21:12.818]                         if (has_future) {
[10:21:12.818]                           ns <- base::getNamespace("future")
[10:21:12.818]                           version <- ns[[".package"]][["version"]]
[10:21:12.818]                           if (is.null(version)) 
[10:21:12.818]                             version <- utils::packageVersion("future")
[10:21:12.818]                         }
[10:21:12.818]                         else {
[10:21:12.818]                           version <- NULL
[10:21:12.818]                         }
[10:21:12.818]                         if (!has_future || version < "1.8.0") {
[10:21:12.818]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:12.818]                             "", base::R.version$version.string), 
[10:21:12.818]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:12.818]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:12.818]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:12.818]                               "release", "version")], collapse = " "), 
[10:21:12.818]                             hostname = base::Sys.info()[["nodename"]])
[10:21:12.818]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:12.818]                             info)
[10:21:12.818]                           info <- base::paste(info, collapse = "; ")
[10:21:12.818]                           if (!has_future) {
[10:21:12.818]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:12.818]                               info)
[10:21:12.818]                           }
[10:21:12.818]                           else {
[10:21:12.818]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:12.818]                               info, version)
[10:21:12.818]                           }
[10:21:12.818]                           base::stop(msg)
[10:21:12.818]                         }
[10:21:12.818]                       })
[10:21:12.818]                     }
[10:21:12.818]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:12.818]                     base::options(mc.cores = 1L)
[10:21:12.818]                   }
[10:21:12.818]                   ...future.strategy.old <- future::plan("list")
[10:21:12.818]                   options(future.plan = NULL)
[10:21:12.818]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.818]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:12.818]                 }
[10:21:12.818]                 ...future.workdir <- getwd()
[10:21:12.818]             }
[10:21:12.818]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:12.818]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:12.818]         }
[10:21:12.818]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:12.818]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:12.818]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:12.818]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:12.818]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:12.818]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:12.818]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:12.818]             base::names(...future.oldOptions))
[10:21:12.818]     }
[10:21:12.818]     if (FALSE) {
[10:21:12.818]     }
[10:21:12.818]     else {
[10:21:12.818]         if (TRUE) {
[10:21:12.818]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:12.818]                 open = "w")
[10:21:12.818]         }
[10:21:12.818]         else {
[10:21:12.818]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:12.818]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:12.818]         }
[10:21:12.818]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:12.818]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:12.818]             base::sink(type = "output", split = FALSE)
[10:21:12.818]             base::close(...future.stdout)
[10:21:12.818]         }, add = TRUE)
[10:21:12.818]     }
[10:21:12.818]     ...future.frame <- base::sys.nframe()
[10:21:12.818]     ...future.conditions <- base::list()
[10:21:12.818]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:12.818]     if (FALSE) {
[10:21:12.818]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:12.818]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:12.818]     }
[10:21:12.818]     ...future.result <- base::tryCatch({
[10:21:12.818]         base::withCallingHandlers({
[10:21:12.818]             ...future.value <- base::withVisible(base::local({
[10:21:12.818]                 withCallingHandlers({
[10:21:12.818]                   {
[10:21:12.818]                     2 * a
[10:21:12.818]                   }
[10:21:12.818]                 }, immediateCondition = function(cond) {
[10:21:12.818]                   save_rds <- function (object, pathname, ...) 
[10:21:12.818]                   {
[10:21:12.818]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:12.818]                     if (file_test("-f", pathname_tmp)) {
[10:21:12.818]                       fi_tmp <- file.info(pathname_tmp)
[10:21:12.818]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:12.818]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:12.818]                         fi_tmp[["mtime"]])
[10:21:12.818]                     }
[10:21:12.818]                     tryCatch({
[10:21:12.818]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:12.818]                     }, error = function(ex) {
[10:21:12.818]                       msg <- conditionMessage(ex)
[10:21:12.818]                       fi_tmp <- file.info(pathname_tmp)
[10:21:12.818]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:12.818]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:12.818]                         fi_tmp[["mtime"]], msg)
[10:21:12.818]                       ex$message <- msg
[10:21:12.818]                       stop(ex)
[10:21:12.818]                     })
[10:21:12.818]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:12.818]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:12.818]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:12.818]                       fi_tmp <- file.info(pathname_tmp)
[10:21:12.818]                       fi <- file.info(pathname)
[10:21:12.818]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:12.818]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:12.818]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:12.818]                         fi[["size"]], fi[["mtime"]])
[10:21:12.818]                       stop(msg)
[10:21:12.818]                     }
[10:21:12.818]                     invisible(pathname)
[10:21:12.818]                   }
[10:21:12.818]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:12.818]                     rootPath = tempdir()) 
[10:21:12.818]                   {
[10:21:12.818]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:12.818]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:12.818]                       tmpdir = path, fileext = ".rds")
[10:21:12.818]                     save_rds(obj, file)
[10:21:12.818]                   }
[10:21:12.818]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3gePII/.future/immediateConditions")
[10:21:12.818]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.818]                   {
[10:21:12.818]                     inherits <- base::inherits
[10:21:12.818]                     invokeRestart <- base::invokeRestart
[10:21:12.818]                     is.null <- base::is.null
[10:21:12.818]                     muffled <- FALSE
[10:21:12.818]                     if (inherits(cond, "message")) {
[10:21:12.818]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:12.818]                       if (muffled) 
[10:21:12.818]                         invokeRestart("muffleMessage")
[10:21:12.818]                     }
[10:21:12.818]                     else if (inherits(cond, "warning")) {
[10:21:12.818]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:12.818]                       if (muffled) 
[10:21:12.818]                         invokeRestart("muffleWarning")
[10:21:12.818]                     }
[10:21:12.818]                     else if (inherits(cond, "condition")) {
[10:21:12.818]                       if (!is.null(pattern)) {
[10:21:12.818]                         computeRestarts <- base::computeRestarts
[10:21:12.818]                         grepl <- base::grepl
[10:21:12.818]                         restarts <- computeRestarts(cond)
[10:21:12.818]                         for (restart in restarts) {
[10:21:12.818]                           name <- restart$name
[10:21:12.818]                           if (is.null(name)) 
[10:21:12.818]                             next
[10:21:12.818]                           if (!grepl(pattern, name)) 
[10:21:12.818]                             next
[10:21:12.818]                           invokeRestart(restart)
[10:21:12.818]                           muffled <- TRUE
[10:21:12.818]                           break
[10:21:12.818]                         }
[10:21:12.818]                       }
[10:21:12.818]                     }
[10:21:12.818]                     invisible(muffled)
[10:21:12.818]                   }
[10:21:12.818]                   muffleCondition(cond)
[10:21:12.818]                 })
[10:21:12.818]             }))
[10:21:12.818]             future::FutureResult(value = ...future.value$value, 
[10:21:12.818]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.818]                   ...future.rng), globalenv = if (FALSE) 
[10:21:12.818]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:12.818]                     ...future.globalenv.names))
[10:21:12.818]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:12.818]         }, condition = base::local({
[10:21:12.818]             c <- base::c
[10:21:12.818]             inherits <- base::inherits
[10:21:12.818]             invokeRestart <- base::invokeRestart
[10:21:12.818]             length <- base::length
[10:21:12.818]             list <- base::list
[10:21:12.818]             seq.int <- base::seq.int
[10:21:12.818]             signalCondition <- base::signalCondition
[10:21:12.818]             sys.calls <- base::sys.calls
[10:21:12.818]             `[[` <- base::`[[`
[10:21:12.818]             `+` <- base::`+`
[10:21:12.818]             `<<-` <- base::`<<-`
[10:21:12.818]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:12.818]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:12.818]                   3L)]
[10:21:12.818]             }
[10:21:12.818]             function(cond) {
[10:21:12.818]                 is_error <- inherits(cond, "error")
[10:21:12.818]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:12.818]                   NULL)
[10:21:12.818]                 if (is_error) {
[10:21:12.818]                   sessionInformation <- function() {
[10:21:12.818]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:12.818]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:12.818]                       search = base::search(), system = base::Sys.info())
[10:21:12.818]                   }
[10:21:12.818]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.818]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:12.818]                     cond$call), session = sessionInformation(), 
[10:21:12.818]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:12.818]                   signalCondition(cond)
[10:21:12.818]                 }
[10:21:12.818]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:12.818]                 "immediateCondition"))) {
[10:21:12.818]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:12.818]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.818]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:12.818]                   if (TRUE && !signal) {
[10:21:12.818]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.818]                     {
[10:21:12.818]                       inherits <- base::inherits
[10:21:12.818]                       invokeRestart <- base::invokeRestart
[10:21:12.818]                       is.null <- base::is.null
[10:21:12.818]                       muffled <- FALSE
[10:21:12.818]                       if (inherits(cond, "message")) {
[10:21:12.818]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.818]                         if (muffled) 
[10:21:12.818]                           invokeRestart("muffleMessage")
[10:21:12.818]                       }
[10:21:12.818]                       else if (inherits(cond, "warning")) {
[10:21:12.818]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.818]                         if (muffled) 
[10:21:12.818]                           invokeRestart("muffleWarning")
[10:21:12.818]                       }
[10:21:12.818]                       else if (inherits(cond, "condition")) {
[10:21:12.818]                         if (!is.null(pattern)) {
[10:21:12.818]                           computeRestarts <- base::computeRestarts
[10:21:12.818]                           grepl <- base::grepl
[10:21:12.818]                           restarts <- computeRestarts(cond)
[10:21:12.818]                           for (restart in restarts) {
[10:21:12.818]                             name <- restart$name
[10:21:12.818]                             if (is.null(name)) 
[10:21:12.818]                               next
[10:21:12.818]                             if (!grepl(pattern, name)) 
[10:21:12.818]                               next
[10:21:12.818]                             invokeRestart(restart)
[10:21:12.818]                             muffled <- TRUE
[10:21:12.818]                             break
[10:21:12.818]                           }
[10:21:12.818]                         }
[10:21:12.818]                       }
[10:21:12.818]                       invisible(muffled)
[10:21:12.818]                     }
[10:21:12.818]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.818]                   }
[10:21:12.818]                 }
[10:21:12.818]                 else {
[10:21:12.818]                   if (TRUE) {
[10:21:12.818]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.818]                     {
[10:21:12.818]                       inherits <- base::inherits
[10:21:12.818]                       invokeRestart <- base::invokeRestart
[10:21:12.818]                       is.null <- base::is.null
[10:21:12.818]                       muffled <- FALSE
[10:21:12.818]                       if (inherits(cond, "message")) {
[10:21:12.818]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.818]                         if (muffled) 
[10:21:12.818]                           invokeRestart("muffleMessage")
[10:21:12.818]                       }
[10:21:12.818]                       else if (inherits(cond, "warning")) {
[10:21:12.818]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.818]                         if (muffled) 
[10:21:12.818]                           invokeRestart("muffleWarning")
[10:21:12.818]                       }
[10:21:12.818]                       else if (inherits(cond, "condition")) {
[10:21:12.818]                         if (!is.null(pattern)) {
[10:21:12.818]                           computeRestarts <- base::computeRestarts
[10:21:12.818]                           grepl <- base::grepl
[10:21:12.818]                           restarts <- computeRestarts(cond)
[10:21:12.818]                           for (restart in restarts) {
[10:21:12.818]                             name <- restart$name
[10:21:12.818]                             if (is.null(name)) 
[10:21:12.818]                               next
[10:21:12.818]                             if (!grepl(pattern, name)) 
[10:21:12.818]                               next
[10:21:12.818]                             invokeRestart(restart)
[10:21:12.818]                             muffled <- TRUE
[10:21:12.818]                             break
[10:21:12.818]                           }
[10:21:12.818]                         }
[10:21:12.818]                       }
[10:21:12.818]                       invisible(muffled)
[10:21:12.818]                     }
[10:21:12.818]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.818]                   }
[10:21:12.818]                 }
[10:21:12.818]             }
[10:21:12.818]         }))
[10:21:12.818]     }, error = function(ex) {
[10:21:12.818]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:12.818]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.818]                 ...future.rng), started = ...future.startTime, 
[10:21:12.818]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:12.818]             version = "1.8"), class = "FutureResult")
[10:21:12.818]     }, finally = {
[10:21:12.818]         if (!identical(...future.workdir, getwd())) 
[10:21:12.818]             setwd(...future.workdir)
[10:21:12.818]         {
[10:21:12.818]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:12.818]                 ...future.oldOptions$nwarnings <- NULL
[10:21:12.818]             }
[10:21:12.818]             base::options(...future.oldOptions)
[10:21:12.818]             if (.Platform$OS.type == "windows") {
[10:21:12.818]                 old_names <- names(...future.oldEnvVars)
[10:21:12.818]                 envs <- base::Sys.getenv()
[10:21:12.818]                 names <- names(envs)
[10:21:12.818]                 common <- intersect(names, old_names)
[10:21:12.818]                 added <- setdiff(names, old_names)
[10:21:12.818]                 removed <- setdiff(old_names, names)
[10:21:12.818]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:12.818]                   envs[common]]
[10:21:12.818]                 NAMES <- toupper(changed)
[10:21:12.818]                 args <- list()
[10:21:12.818]                 for (kk in seq_along(NAMES)) {
[10:21:12.818]                   name <- changed[[kk]]
[10:21:12.818]                   NAME <- NAMES[[kk]]
[10:21:12.818]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.818]                     next
[10:21:12.818]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.818]                 }
[10:21:12.818]                 NAMES <- toupper(added)
[10:21:12.818]                 for (kk in seq_along(NAMES)) {
[10:21:12.818]                   name <- added[[kk]]
[10:21:12.818]                   NAME <- NAMES[[kk]]
[10:21:12.818]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.818]                     next
[10:21:12.818]                   args[[name]] <- ""
[10:21:12.818]                 }
[10:21:12.818]                 NAMES <- toupper(removed)
[10:21:12.818]                 for (kk in seq_along(NAMES)) {
[10:21:12.818]                   name <- removed[[kk]]
[10:21:12.818]                   NAME <- NAMES[[kk]]
[10:21:12.818]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.818]                     next
[10:21:12.818]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.818]                 }
[10:21:12.818]                 if (length(args) > 0) 
[10:21:12.818]                   base::do.call(base::Sys.setenv, args = args)
[10:21:12.818]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:12.818]             }
[10:21:12.818]             else {
[10:21:12.818]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:12.818]             }
[10:21:12.818]             {
[10:21:12.818]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:12.818]                   0L) {
[10:21:12.818]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:12.818]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:12.818]                   base::options(opts)
[10:21:12.818]                 }
[10:21:12.818]                 {
[10:21:12.818]                   {
[10:21:12.818]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:12.818]                     NULL
[10:21:12.818]                   }
[10:21:12.818]                   options(future.plan = NULL)
[10:21:12.818]                   if (is.na(NA_character_)) 
[10:21:12.818]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.818]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:12.818]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:12.818]                     .init = FALSE)
[10:21:12.818]                 }
[10:21:12.818]             }
[10:21:12.818]         }
[10:21:12.818]     })
[10:21:12.818]     if (TRUE) {
[10:21:12.818]         base::sink(type = "output", split = FALSE)
[10:21:12.818]         if (TRUE) {
[10:21:12.818]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:12.818]         }
[10:21:12.818]         else {
[10:21:12.818]             ...future.result["stdout"] <- base::list(NULL)
[10:21:12.818]         }
[10:21:12.818]         base::close(...future.stdout)
[10:21:12.818]         ...future.stdout <- NULL
[10:21:12.818]     }
[10:21:12.818]     ...future.result$conditions <- ...future.conditions
[10:21:12.818]     ...future.result$finished <- base::Sys.time()
[10:21:12.818]     ...future.result
[10:21:12.818] }
[10:21:12.821] assign_globals() ...
[10:21:12.821] List of 1
[10:21:12.821]  $ a: num 1
[10:21:12.821]  - attr(*, "where")=List of 1
[10:21:12.821]   ..$ a:<environment: R_EmptyEnv> 
[10:21:12.821]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:12.821]  - attr(*, "resolved")= logi FALSE
[10:21:12.821]  - attr(*, "total_size")= num 39
[10:21:12.821]  - attr(*, "already-done")= logi TRUE
[10:21:12.824] - copied ‘a’ to environment
[10:21:12.824] assign_globals() ... done
[10:21:12.825] requestCore(): workers = 2
[10:21:12.826] MulticoreFuture started
[10:21:12.827] - Launch lazy future ... done
[10:21:12.827] run() for ‘MulticoreFuture’ ... done
[10:21:12.827] result() for MulticoreFuture ...
[10:21:12.827] plan(): Setting new future strategy stack:
[10:21:12.828] List of future strategies:
[10:21:12.828] 1. sequential:
[10:21:12.828]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.828]    - tweaked: FALSE
[10:21:12.828]    - call: NULL
[10:21:12.829] plan(): nbrOfWorkers() = 1
[10:21:12.831] plan(): Setting new future strategy stack:
[10:21:12.831] List of future strategies:
[10:21:12.831] 1. multicore:
[10:21:12.831]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:12.831]    - tweaked: FALSE
[10:21:12.831]    - call: plan(strategy)
[10:21:12.834] plan(): nbrOfWorkers() = 2
[10:21:12.835] result() for MulticoreFuture ...
[10:21:12.835] result() for MulticoreFuture ... done
[10:21:12.835] result() for MulticoreFuture ... done
[10:21:12.835] result() for MulticoreFuture ...
[10:21:12.836] result() for MulticoreFuture ... done
[10:21:12.836] getGlobalsAndPackages() ...
[10:21:12.836] Searching for globals...
[10:21:12.837] - globals found: [3] ‘{’, ‘*’, ‘a’
[10:21:12.838] Searching for globals ... DONE
[10:21:12.838] Resolving globals: FALSE
[10:21:12.838] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:12.842] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:12.842] - globals: [1] ‘a’
[10:21:12.842] 
[10:21:12.842] getGlobalsAndPackages() ... DONE
[10:21:12.842] run() for ‘Future’ ...
[10:21:12.843] - state: ‘created’
[10:21:12.843] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:12.845] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:12.845] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:12.845]   - Field: ‘label’
[10:21:12.845]   - Field: ‘local’
[10:21:12.845]   - Field: ‘owner’
[10:21:12.846]   - Field: ‘envir’
[10:21:12.846]   - Field: ‘workers’
[10:21:12.846]   - Field: ‘packages’
[10:21:12.846]   - Field: ‘gc’
[10:21:12.846]   - Field: ‘job’
[10:21:12.846]   - Field: ‘conditions’
[10:21:12.846]   - Field: ‘expr’
[10:21:12.846]   - Field: ‘uuid’
[10:21:12.846]   - Field: ‘seed’
[10:21:12.847]   - Field: ‘version’
[10:21:12.847]   - Field: ‘result’
[10:21:12.847]   - Field: ‘asynchronous’
[10:21:12.847]   - Field: ‘calls’
[10:21:12.847]   - Field: ‘globals’
[10:21:12.847]   - Field: ‘stdout’
[10:21:12.847]   - Field: ‘earlySignal’
[10:21:12.847]   - Field: ‘lazy’
[10:21:12.848]   - Field: ‘state’
[10:21:12.848] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:12.848] - Launch lazy future ...
[10:21:12.848] Packages needed by the future expression (n = 0): <none>
[10:21:12.848] Packages needed by future strategies (n = 0): <none>
[10:21:12.849] {
[10:21:12.849]     {
[10:21:12.849]         {
[10:21:12.849]             ...future.startTime <- base::Sys.time()
[10:21:12.849]             {
[10:21:12.849]                 {
[10:21:12.849]                   {
[10:21:12.849]                     {
[10:21:12.849]                       base::local({
[10:21:12.849]                         has_future <- base::requireNamespace("future", 
[10:21:12.849]                           quietly = TRUE)
[10:21:12.849]                         if (has_future) {
[10:21:12.849]                           ns <- base::getNamespace("future")
[10:21:12.849]                           version <- ns[[".package"]][["version"]]
[10:21:12.849]                           if (is.null(version)) 
[10:21:12.849]                             version <- utils::packageVersion("future")
[10:21:12.849]                         }
[10:21:12.849]                         else {
[10:21:12.849]                           version <- NULL
[10:21:12.849]                         }
[10:21:12.849]                         if (!has_future || version < "1.8.0") {
[10:21:12.849]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:12.849]                             "", base::R.version$version.string), 
[10:21:12.849]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:12.849]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:12.849]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:12.849]                               "release", "version")], collapse = " "), 
[10:21:12.849]                             hostname = base::Sys.info()[["nodename"]])
[10:21:12.849]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:12.849]                             info)
[10:21:12.849]                           info <- base::paste(info, collapse = "; ")
[10:21:12.849]                           if (!has_future) {
[10:21:12.849]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:12.849]                               info)
[10:21:12.849]                           }
[10:21:12.849]                           else {
[10:21:12.849]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:12.849]                               info, version)
[10:21:12.849]                           }
[10:21:12.849]                           base::stop(msg)
[10:21:12.849]                         }
[10:21:12.849]                       })
[10:21:12.849]                     }
[10:21:12.849]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:12.849]                     base::options(mc.cores = 1L)
[10:21:12.849]                   }
[10:21:12.849]                   ...future.strategy.old <- future::plan("list")
[10:21:12.849]                   options(future.plan = NULL)
[10:21:12.849]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.849]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:12.849]                 }
[10:21:12.849]                 ...future.workdir <- getwd()
[10:21:12.849]             }
[10:21:12.849]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:12.849]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:12.849]         }
[10:21:12.849]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:12.849]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:12.849]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:12.849]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:12.849]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:12.849]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:12.849]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:12.849]             base::names(...future.oldOptions))
[10:21:12.849]     }
[10:21:12.849]     if (FALSE) {
[10:21:12.849]     }
[10:21:12.849]     else {
[10:21:12.849]         if (TRUE) {
[10:21:12.849]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:12.849]                 open = "w")
[10:21:12.849]         }
[10:21:12.849]         else {
[10:21:12.849]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:12.849]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:12.849]         }
[10:21:12.849]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:12.849]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:12.849]             base::sink(type = "output", split = FALSE)
[10:21:12.849]             base::close(...future.stdout)
[10:21:12.849]         }, add = TRUE)
[10:21:12.849]     }
[10:21:12.849]     ...future.frame <- base::sys.nframe()
[10:21:12.849]     ...future.conditions <- base::list()
[10:21:12.849]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:12.849]     if (FALSE) {
[10:21:12.849]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:12.849]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:12.849]     }
[10:21:12.849]     ...future.result <- base::tryCatch({
[10:21:12.849]         base::withCallingHandlers({
[10:21:12.849]             ...future.value <- base::withVisible(base::local({
[10:21:12.849]                 withCallingHandlers({
[10:21:12.849]                   {
[10:21:12.849]                     2 * a
[10:21:12.849]                   }
[10:21:12.849]                 }, immediateCondition = function(cond) {
[10:21:12.849]                   save_rds <- function (object, pathname, ...) 
[10:21:12.849]                   {
[10:21:12.849]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:12.849]                     if (file_test("-f", pathname_tmp)) {
[10:21:12.849]                       fi_tmp <- file.info(pathname_tmp)
[10:21:12.849]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:12.849]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:12.849]                         fi_tmp[["mtime"]])
[10:21:12.849]                     }
[10:21:12.849]                     tryCatch({
[10:21:12.849]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:12.849]                     }, error = function(ex) {
[10:21:12.849]                       msg <- conditionMessage(ex)
[10:21:12.849]                       fi_tmp <- file.info(pathname_tmp)
[10:21:12.849]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:12.849]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:12.849]                         fi_tmp[["mtime"]], msg)
[10:21:12.849]                       ex$message <- msg
[10:21:12.849]                       stop(ex)
[10:21:12.849]                     })
[10:21:12.849]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:12.849]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:12.849]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:12.849]                       fi_tmp <- file.info(pathname_tmp)
[10:21:12.849]                       fi <- file.info(pathname)
[10:21:12.849]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:12.849]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:12.849]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:12.849]                         fi[["size"]], fi[["mtime"]])
[10:21:12.849]                       stop(msg)
[10:21:12.849]                     }
[10:21:12.849]                     invisible(pathname)
[10:21:12.849]                   }
[10:21:12.849]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:12.849]                     rootPath = tempdir()) 
[10:21:12.849]                   {
[10:21:12.849]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:12.849]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:12.849]                       tmpdir = path, fileext = ".rds")
[10:21:12.849]                     save_rds(obj, file)
[10:21:12.849]                   }
[10:21:12.849]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3gePII/.future/immediateConditions")
[10:21:12.849]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.849]                   {
[10:21:12.849]                     inherits <- base::inherits
[10:21:12.849]                     invokeRestart <- base::invokeRestart
[10:21:12.849]                     is.null <- base::is.null
[10:21:12.849]                     muffled <- FALSE
[10:21:12.849]                     if (inherits(cond, "message")) {
[10:21:12.849]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:12.849]                       if (muffled) 
[10:21:12.849]                         invokeRestart("muffleMessage")
[10:21:12.849]                     }
[10:21:12.849]                     else if (inherits(cond, "warning")) {
[10:21:12.849]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:12.849]                       if (muffled) 
[10:21:12.849]                         invokeRestart("muffleWarning")
[10:21:12.849]                     }
[10:21:12.849]                     else if (inherits(cond, "condition")) {
[10:21:12.849]                       if (!is.null(pattern)) {
[10:21:12.849]                         computeRestarts <- base::computeRestarts
[10:21:12.849]                         grepl <- base::grepl
[10:21:12.849]                         restarts <- computeRestarts(cond)
[10:21:12.849]                         for (restart in restarts) {
[10:21:12.849]                           name <- restart$name
[10:21:12.849]                           if (is.null(name)) 
[10:21:12.849]                             next
[10:21:12.849]                           if (!grepl(pattern, name)) 
[10:21:12.849]                             next
[10:21:12.849]                           invokeRestart(restart)
[10:21:12.849]                           muffled <- TRUE
[10:21:12.849]                           break
[10:21:12.849]                         }
[10:21:12.849]                       }
[10:21:12.849]                     }
[10:21:12.849]                     invisible(muffled)
[10:21:12.849]                   }
[10:21:12.849]                   muffleCondition(cond)
[10:21:12.849]                 })
[10:21:12.849]             }))
[10:21:12.849]             future::FutureResult(value = ...future.value$value, 
[10:21:12.849]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.849]                   ...future.rng), globalenv = if (FALSE) 
[10:21:12.849]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:12.849]                     ...future.globalenv.names))
[10:21:12.849]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:12.849]         }, condition = base::local({
[10:21:12.849]             c <- base::c
[10:21:12.849]             inherits <- base::inherits
[10:21:12.849]             invokeRestart <- base::invokeRestart
[10:21:12.849]             length <- base::length
[10:21:12.849]             list <- base::list
[10:21:12.849]             seq.int <- base::seq.int
[10:21:12.849]             signalCondition <- base::signalCondition
[10:21:12.849]             sys.calls <- base::sys.calls
[10:21:12.849]             `[[` <- base::`[[`
[10:21:12.849]             `+` <- base::`+`
[10:21:12.849]             `<<-` <- base::`<<-`
[10:21:12.849]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:12.849]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:12.849]                   3L)]
[10:21:12.849]             }
[10:21:12.849]             function(cond) {
[10:21:12.849]                 is_error <- inherits(cond, "error")
[10:21:12.849]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:12.849]                   NULL)
[10:21:12.849]                 if (is_error) {
[10:21:12.849]                   sessionInformation <- function() {
[10:21:12.849]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:12.849]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:12.849]                       search = base::search(), system = base::Sys.info())
[10:21:12.849]                   }
[10:21:12.849]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.849]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:12.849]                     cond$call), session = sessionInformation(), 
[10:21:12.849]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:12.849]                   signalCondition(cond)
[10:21:12.849]                 }
[10:21:12.849]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:12.849]                 "immediateCondition"))) {
[10:21:12.849]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:12.849]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.849]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:12.849]                   if (TRUE && !signal) {
[10:21:12.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.849]                     {
[10:21:12.849]                       inherits <- base::inherits
[10:21:12.849]                       invokeRestart <- base::invokeRestart
[10:21:12.849]                       is.null <- base::is.null
[10:21:12.849]                       muffled <- FALSE
[10:21:12.849]                       if (inherits(cond, "message")) {
[10:21:12.849]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.849]                         if (muffled) 
[10:21:12.849]                           invokeRestart("muffleMessage")
[10:21:12.849]                       }
[10:21:12.849]                       else if (inherits(cond, "warning")) {
[10:21:12.849]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.849]                         if (muffled) 
[10:21:12.849]                           invokeRestart("muffleWarning")
[10:21:12.849]                       }
[10:21:12.849]                       else if (inherits(cond, "condition")) {
[10:21:12.849]                         if (!is.null(pattern)) {
[10:21:12.849]                           computeRestarts <- base::computeRestarts
[10:21:12.849]                           grepl <- base::grepl
[10:21:12.849]                           restarts <- computeRestarts(cond)
[10:21:12.849]                           for (restart in restarts) {
[10:21:12.849]                             name <- restart$name
[10:21:12.849]                             if (is.null(name)) 
[10:21:12.849]                               next
[10:21:12.849]                             if (!grepl(pattern, name)) 
[10:21:12.849]                               next
[10:21:12.849]                             invokeRestart(restart)
[10:21:12.849]                             muffled <- TRUE
[10:21:12.849]                             break
[10:21:12.849]                           }
[10:21:12.849]                         }
[10:21:12.849]                       }
[10:21:12.849]                       invisible(muffled)
[10:21:12.849]                     }
[10:21:12.849]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.849]                   }
[10:21:12.849]                 }
[10:21:12.849]                 else {
[10:21:12.849]                   if (TRUE) {
[10:21:12.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.849]                     {
[10:21:12.849]                       inherits <- base::inherits
[10:21:12.849]                       invokeRestart <- base::invokeRestart
[10:21:12.849]                       is.null <- base::is.null
[10:21:12.849]                       muffled <- FALSE
[10:21:12.849]                       if (inherits(cond, "message")) {
[10:21:12.849]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.849]                         if (muffled) 
[10:21:12.849]                           invokeRestart("muffleMessage")
[10:21:12.849]                       }
[10:21:12.849]                       else if (inherits(cond, "warning")) {
[10:21:12.849]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.849]                         if (muffled) 
[10:21:12.849]                           invokeRestart("muffleWarning")
[10:21:12.849]                       }
[10:21:12.849]                       else if (inherits(cond, "condition")) {
[10:21:12.849]                         if (!is.null(pattern)) {
[10:21:12.849]                           computeRestarts <- base::computeRestarts
[10:21:12.849]                           grepl <- base::grepl
[10:21:12.849]                           restarts <- computeRestarts(cond)
[10:21:12.849]                           for (restart in restarts) {
[10:21:12.849]                             name <- restart$name
[10:21:12.849]                             if (is.null(name)) 
[10:21:12.849]                               next
[10:21:12.849]                             if (!grepl(pattern, name)) 
[10:21:12.849]                               next
[10:21:12.849]                             invokeRestart(restart)
[10:21:12.849]                             muffled <- TRUE
[10:21:12.849]                             break
[10:21:12.849]                           }
[10:21:12.849]                         }
[10:21:12.849]                       }
[10:21:12.849]                       invisible(muffled)
[10:21:12.849]                     }
[10:21:12.849]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.849]                   }
[10:21:12.849]                 }
[10:21:12.849]             }
[10:21:12.849]         }))
[10:21:12.849]     }, error = function(ex) {
[10:21:12.849]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:12.849]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.849]                 ...future.rng), started = ...future.startTime, 
[10:21:12.849]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:12.849]             version = "1.8"), class = "FutureResult")
[10:21:12.849]     }, finally = {
[10:21:12.849]         if (!identical(...future.workdir, getwd())) 
[10:21:12.849]             setwd(...future.workdir)
[10:21:12.849]         {
[10:21:12.849]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:12.849]                 ...future.oldOptions$nwarnings <- NULL
[10:21:12.849]             }
[10:21:12.849]             base::options(...future.oldOptions)
[10:21:12.849]             if (.Platform$OS.type == "windows") {
[10:21:12.849]                 old_names <- names(...future.oldEnvVars)
[10:21:12.849]                 envs <- base::Sys.getenv()
[10:21:12.849]                 names <- names(envs)
[10:21:12.849]                 common <- intersect(names, old_names)
[10:21:12.849]                 added <- setdiff(names, old_names)
[10:21:12.849]                 removed <- setdiff(old_names, names)
[10:21:12.849]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:12.849]                   envs[common]]
[10:21:12.849]                 NAMES <- toupper(changed)
[10:21:12.849]                 args <- list()
[10:21:12.849]                 for (kk in seq_along(NAMES)) {
[10:21:12.849]                   name <- changed[[kk]]
[10:21:12.849]                   NAME <- NAMES[[kk]]
[10:21:12.849]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.849]                     next
[10:21:12.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.849]                 }
[10:21:12.849]                 NAMES <- toupper(added)
[10:21:12.849]                 for (kk in seq_along(NAMES)) {
[10:21:12.849]                   name <- added[[kk]]
[10:21:12.849]                   NAME <- NAMES[[kk]]
[10:21:12.849]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.849]                     next
[10:21:12.849]                   args[[name]] <- ""
[10:21:12.849]                 }
[10:21:12.849]                 NAMES <- toupper(removed)
[10:21:12.849]                 for (kk in seq_along(NAMES)) {
[10:21:12.849]                   name <- removed[[kk]]
[10:21:12.849]                   NAME <- NAMES[[kk]]
[10:21:12.849]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.849]                     next
[10:21:12.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.849]                 }
[10:21:12.849]                 if (length(args) > 0) 
[10:21:12.849]                   base::do.call(base::Sys.setenv, args = args)
[10:21:12.849]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:12.849]             }
[10:21:12.849]             else {
[10:21:12.849]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:12.849]             }
[10:21:12.849]             {
[10:21:12.849]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:12.849]                   0L) {
[10:21:12.849]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:12.849]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:12.849]                   base::options(opts)
[10:21:12.849]                 }
[10:21:12.849]                 {
[10:21:12.849]                   {
[10:21:12.849]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:12.849]                     NULL
[10:21:12.849]                   }
[10:21:12.849]                   options(future.plan = NULL)
[10:21:12.849]                   if (is.na(NA_character_)) 
[10:21:12.849]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.849]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:12.849]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:12.849]                     .init = FALSE)
[10:21:12.849]                 }
[10:21:12.849]             }
[10:21:12.849]         }
[10:21:12.849]     })
[10:21:12.849]     if (TRUE) {
[10:21:12.849]         base::sink(type = "output", split = FALSE)
[10:21:12.849]         if (TRUE) {
[10:21:12.849]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:12.849]         }
[10:21:12.849]         else {
[10:21:12.849]             ...future.result["stdout"] <- base::list(NULL)
[10:21:12.849]         }
[10:21:12.849]         base::close(...future.stdout)
[10:21:12.849]         ...future.stdout <- NULL
[10:21:12.849]     }
[10:21:12.849]     ...future.result$conditions <- ...future.conditions
[10:21:12.849]     ...future.result$finished <- base::Sys.time()
[10:21:12.849]     ...future.result
[10:21:12.849] }
[10:21:12.851] assign_globals() ...
[10:21:12.851] List of 1
[10:21:12.851]  $ a: num 1
[10:21:12.851]  - attr(*, "where")=List of 1
[10:21:12.851]   ..$ a:<environment: R_EmptyEnv> 
[10:21:12.851]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:12.851]  - attr(*, "resolved")= logi FALSE
[10:21:12.851]  - attr(*, "total_size")= num 39
[10:21:12.851]  - attr(*, "already-done")= logi TRUE
[10:21:12.854] - copied ‘a’ to environment
[10:21:12.855] assign_globals() ... done
[10:21:12.855] requestCore(): workers = 2
[10:21:12.857] MulticoreFuture started
[10:21:12.857] - Launch lazy future ... done
[10:21:12.857] run() for ‘MulticoreFuture’ ... done
[10:21:12.858] result() for MulticoreFuture ...
[10:21:12.858] plan(): Setting new future strategy stack:
[10:21:12.858] List of future strategies:
[10:21:12.858] 1. sequential:
[10:21:12.858]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.858]    - tweaked: FALSE
[10:21:12.858]    - call: NULL
[10:21:12.859] plan(): nbrOfWorkers() = 1
[10:21:12.861] plan(): Setting new future strategy stack:
[10:21:12.861] List of future strategies:
[10:21:12.861] 1. multicore:
[10:21:12.861]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:12.861]    - tweaked: FALSE
[10:21:12.861]    - call: plan(strategy)
[10:21:12.865] plan(): nbrOfWorkers() = 2
[10:21:12.865] result() for MulticoreFuture ...
[10:21:12.865] result() for MulticoreFuture ... done
[10:21:12.866] result() for MulticoreFuture ... done
[10:21:12.866] result() for MulticoreFuture ...
[10:21:12.866] result() for MulticoreFuture ... done
[10:21:12.866] getGlobalsAndPackages() ...
[10:21:12.866] Searching for globals...
[10:21:12.868] - globals found: [3] ‘{’, ‘*’, ‘a’
[10:21:12.868] Searching for globals ... DONE
[10:21:12.868] Resolving globals: FALSE
[10:21:12.868] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:12.869] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:12.869] - globals: [1] ‘a’
[10:21:12.869] 
[10:21:12.869] getGlobalsAndPackages() ... DONE
[10:21:12.870] run() for ‘Future’ ...
[10:21:12.870] - state: ‘created’
[10:21:12.870] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:12.872] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:12.872] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:12.873]   - Field: ‘label’
[10:21:12.873]   - Field: ‘local’
[10:21:12.873]   - Field: ‘owner’
[10:21:12.873]   - Field: ‘envir’
[10:21:12.873]   - Field: ‘workers’
[10:21:12.873]   - Field: ‘packages’
[10:21:12.873]   - Field: ‘gc’
[10:21:12.873]   - Field: ‘job’
[10:21:12.874]   - Field: ‘conditions’
[10:21:12.874]   - Field: ‘expr’
[10:21:12.874]   - Field: ‘uuid’
[10:21:12.874]   - Field: ‘seed’
[10:21:12.874]   - Field: ‘version’
[10:21:12.874]   - Field: ‘result’
[10:21:12.874]   - Field: ‘asynchronous’
[10:21:12.874]   - Field: ‘calls’
[10:21:12.874]   - Field: ‘globals’
[10:21:12.874]   - Field: ‘stdout’
[10:21:12.875]   - Field: ‘earlySignal’
[10:21:12.875]   - Field: ‘lazy’
[10:21:12.875]   - Field: ‘state’
[10:21:12.875] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:12.875] - Launch lazy future ...
[10:21:12.875] Packages needed by the future expression (n = 0): <none>
[10:21:12.875] Packages needed by future strategies (n = 0): <none>
[10:21:12.876] {
[10:21:12.876]     {
[10:21:12.876]         {
[10:21:12.876]             ...future.startTime <- base::Sys.time()
[10:21:12.876]             {
[10:21:12.876]                 {
[10:21:12.876]                   {
[10:21:12.876]                     {
[10:21:12.876]                       base::local({
[10:21:12.876]                         has_future <- base::requireNamespace("future", 
[10:21:12.876]                           quietly = TRUE)
[10:21:12.876]                         if (has_future) {
[10:21:12.876]                           ns <- base::getNamespace("future")
[10:21:12.876]                           version <- ns[[".package"]][["version"]]
[10:21:12.876]                           if (is.null(version)) 
[10:21:12.876]                             version <- utils::packageVersion("future")
[10:21:12.876]                         }
[10:21:12.876]                         else {
[10:21:12.876]                           version <- NULL
[10:21:12.876]                         }
[10:21:12.876]                         if (!has_future || version < "1.8.0") {
[10:21:12.876]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:12.876]                             "", base::R.version$version.string), 
[10:21:12.876]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:12.876]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:12.876]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:12.876]                               "release", "version")], collapse = " "), 
[10:21:12.876]                             hostname = base::Sys.info()[["nodename"]])
[10:21:12.876]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:12.876]                             info)
[10:21:12.876]                           info <- base::paste(info, collapse = "; ")
[10:21:12.876]                           if (!has_future) {
[10:21:12.876]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:12.876]                               info)
[10:21:12.876]                           }
[10:21:12.876]                           else {
[10:21:12.876]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:12.876]                               info, version)
[10:21:12.876]                           }
[10:21:12.876]                           base::stop(msg)
[10:21:12.876]                         }
[10:21:12.876]                       })
[10:21:12.876]                     }
[10:21:12.876]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:12.876]                     base::options(mc.cores = 1L)
[10:21:12.876]                   }
[10:21:12.876]                   ...future.strategy.old <- future::plan("list")
[10:21:12.876]                   options(future.plan = NULL)
[10:21:12.876]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.876]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:12.876]                 }
[10:21:12.876]                 ...future.workdir <- getwd()
[10:21:12.876]             }
[10:21:12.876]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:12.876]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:12.876]         }
[10:21:12.876]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:12.876]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:12.876]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:12.876]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:12.876]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:12.876]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:12.876]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:12.876]             base::names(...future.oldOptions))
[10:21:12.876]     }
[10:21:12.876]     if (FALSE) {
[10:21:12.876]     }
[10:21:12.876]     else {
[10:21:12.876]         if (TRUE) {
[10:21:12.876]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:12.876]                 open = "w")
[10:21:12.876]         }
[10:21:12.876]         else {
[10:21:12.876]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:12.876]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:12.876]         }
[10:21:12.876]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:12.876]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:12.876]             base::sink(type = "output", split = FALSE)
[10:21:12.876]             base::close(...future.stdout)
[10:21:12.876]         }, add = TRUE)
[10:21:12.876]     }
[10:21:12.876]     ...future.frame <- base::sys.nframe()
[10:21:12.876]     ...future.conditions <- base::list()
[10:21:12.876]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:12.876]     if (FALSE) {
[10:21:12.876]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:12.876]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:12.876]     }
[10:21:12.876]     ...future.result <- base::tryCatch({
[10:21:12.876]         base::withCallingHandlers({
[10:21:12.876]             ...future.value <- base::withVisible(base::local({
[10:21:12.876]                 withCallingHandlers({
[10:21:12.876]                   {
[10:21:12.876]                     2 * a
[10:21:12.876]                   }
[10:21:12.876]                 }, immediateCondition = function(cond) {
[10:21:12.876]                   save_rds <- function (object, pathname, ...) 
[10:21:12.876]                   {
[10:21:12.876]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:12.876]                     if (file_test("-f", pathname_tmp)) {
[10:21:12.876]                       fi_tmp <- file.info(pathname_tmp)
[10:21:12.876]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:12.876]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:12.876]                         fi_tmp[["mtime"]])
[10:21:12.876]                     }
[10:21:12.876]                     tryCatch({
[10:21:12.876]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:12.876]                     }, error = function(ex) {
[10:21:12.876]                       msg <- conditionMessage(ex)
[10:21:12.876]                       fi_tmp <- file.info(pathname_tmp)
[10:21:12.876]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:12.876]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:12.876]                         fi_tmp[["mtime"]], msg)
[10:21:12.876]                       ex$message <- msg
[10:21:12.876]                       stop(ex)
[10:21:12.876]                     })
[10:21:12.876]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:12.876]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:12.876]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:12.876]                       fi_tmp <- file.info(pathname_tmp)
[10:21:12.876]                       fi <- file.info(pathname)
[10:21:12.876]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:12.876]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:12.876]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:12.876]                         fi[["size"]], fi[["mtime"]])
[10:21:12.876]                       stop(msg)
[10:21:12.876]                     }
[10:21:12.876]                     invisible(pathname)
[10:21:12.876]                   }
[10:21:12.876]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:12.876]                     rootPath = tempdir()) 
[10:21:12.876]                   {
[10:21:12.876]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:12.876]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:12.876]                       tmpdir = path, fileext = ".rds")
[10:21:12.876]                     save_rds(obj, file)
[10:21:12.876]                   }
[10:21:12.876]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3gePII/.future/immediateConditions")
[10:21:12.876]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.876]                   {
[10:21:12.876]                     inherits <- base::inherits
[10:21:12.876]                     invokeRestart <- base::invokeRestart
[10:21:12.876]                     is.null <- base::is.null
[10:21:12.876]                     muffled <- FALSE
[10:21:12.876]                     if (inherits(cond, "message")) {
[10:21:12.876]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:12.876]                       if (muffled) 
[10:21:12.876]                         invokeRestart("muffleMessage")
[10:21:12.876]                     }
[10:21:12.876]                     else if (inherits(cond, "warning")) {
[10:21:12.876]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:12.876]                       if (muffled) 
[10:21:12.876]                         invokeRestart("muffleWarning")
[10:21:12.876]                     }
[10:21:12.876]                     else if (inherits(cond, "condition")) {
[10:21:12.876]                       if (!is.null(pattern)) {
[10:21:12.876]                         computeRestarts <- base::computeRestarts
[10:21:12.876]                         grepl <- base::grepl
[10:21:12.876]                         restarts <- computeRestarts(cond)
[10:21:12.876]                         for (restart in restarts) {
[10:21:12.876]                           name <- restart$name
[10:21:12.876]                           if (is.null(name)) 
[10:21:12.876]                             next
[10:21:12.876]                           if (!grepl(pattern, name)) 
[10:21:12.876]                             next
[10:21:12.876]                           invokeRestart(restart)
[10:21:12.876]                           muffled <- TRUE
[10:21:12.876]                           break
[10:21:12.876]                         }
[10:21:12.876]                       }
[10:21:12.876]                     }
[10:21:12.876]                     invisible(muffled)
[10:21:12.876]                   }
[10:21:12.876]                   muffleCondition(cond)
[10:21:12.876]                 })
[10:21:12.876]             }))
[10:21:12.876]             future::FutureResult(value = ...future.value$value, 
[10:21:12.876]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.876]                   ...future.rng), globalenv = if (FALSE) 
[10:21:12.876]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:12.876]                     ...future.globalenv.names))
[10:21:12.876]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:12.876]         }, condition = base::local({
[10:21:12.876]             c <- base::c
[10:21:12.876]             inherits <- base::inherits
[10:21:12.876]             invokeRestart <- base::invokeRestart
[10:21:12.876]             length <- base::length
[10:21:12.876]             list <- base::list
[10:21:12.876]             seq.int <- base::seq.int
[10:21:12.876]             signalCondition <- base::signalCondition
[10:21:12.876]             sys.calls <- base::sys.calls
[10:21:12.876]             `[[` <- base::`[[`
[10:21:12.876]             `+` <- base::`+`
[10:21:12.876]             `<<-` <- base::`<<-`
[10:21:12.876]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:12.876]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:12.876]                   3L)]
[10:21:12.876]             }
[10:21:12.876]             function(cond) {
[10:21:12.876]                 is_error <- inherits(cond, "error")
[10:21:12.876]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:12.876]                   NULL)
[10:21:12.876]                 if (is_error) {
[10:21:12.876]                   sessionInformation <- function() {
[10:21:12.876]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:12.876]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:12.876]                       search = base::search(), system = base::Sys.info())
[10:21:12.876]                   }
[10:21:12.876]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.876]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:12.876]                     cond$call), session = sessionInformation(), 
[10:21:12.876]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:12.876]                   signalCondition(cond)
[10:21:12.876]                 }
[10:21:12.876]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:12.876]                 "immediateCondition"))) {
[10:21:12.876]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:12.876]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.876]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:12.876]                   if (TRUE && !signal) {
[10:21:12.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.876]                     {
[10:21:12.876]                       inherits <- base::inherits
[10:21:12.876]                       invokeRestart <- base::invokeRestart
[10:21:12.876]                       is.null <- base::is.null
[10:21:12.876]                       muffled <- FALSE
[10:21:12.876]                       if (inherits(cond, "message")) {
[10:21:12.876]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.876]                         if (muffled) 
[10:21:12.876]                           invokeRestart("muffleMessage")
[10:21:12.876]                       }
[10:21:12.876]                       else if (inherits(cond, "warning")) {
[10:21:12.876]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.876]                         if (muffled) 
[10:21:12.876]                           invokeRestart("muffleWarning")
[10:21:12.876]                       }
[10:21:12.876]                       else if (inherits(cond, "condition")) {
[10:21:12.876]                         if (!is.null(pattern)) {
[10:21:12.876]                           computeRestarts <- base::computeRestarts
[10:21:12.876]                           grepl <- base::grepl
[10:21:12.876]                           restarts <- computeRestarts(cond)
[10:21:12.876]                           for (restart in restarts) {
[10:21:12.876]                             name <- restart$name
[10:21:12.876]                             if (is.null(name)) 
[10:21:12.876]                               next
[10:21:12.876]                             if (!grepl(pattern, name)) 
[10:21:12.876]                               next
[10:21:12.876]                             invokeRestart(restart)
[10:21:12.876]                             muffled <- TRUE
[10:21:12.876]                             break
[10:21:12.876]                           }
[10:21:12.876]                         }
[10:21:12.876]                       }
[10:21:12.876]                       invisible(muffled)
[10:21:12.876]                     }
[10:21:12.876]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.876]                   }
[10:21:12.876]                 }
[10:21:12.876]                 else {
[10:21:12.876]                   if (TRUE) {
[10:21:12.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.876]                     {
[10:21:12.876]                       inherits <- base::inherits
[10:21:12.876]                       invokeRestart <- base::invokeRestart
[10:21:12.876]                       is.null <- base::is.null
[10:21:12.876]                       muffled <- FALSE
[10:21:12.876]                       if (inherits(cond, "message")) {
[10:21:12.876]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.876]                         if (muffled) 
[10:21:12.876]                           invokeRestart("muffleMessage")
[10:21:12.876]                       }
[10:21:12.876]                       else if (inherits(cond, "warning")) {
[10:21:12.876]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.876]                         if (muffled) 
[10:21:12.876]                           invokeRestart("muffleWarning")
[10:21:12.876]                       }
[10:21:12.876]                       else if (inherits(cond, "condition")) {
[10:21:12.876]                         if (!is.null(pattern)) {
[10:21:12.876]                           computeRestarts <- base::computeRestarts
[10:21:12.876]                           grepl <- base::grepl
[10:21:12.876]                           restarts <- computeRestarts(cond)
[10:21:12.876]                           for (restart in restarts) {
[10:21:12.876]                             name <- restart$name
[10:21:12.876]                             if (is.null(name)) 
[10:21:12.876]                               next
[10:21:12.876]                             if (!grepl(pattern, name)) 
[10:21:12.876]                               next
[10:21:12.876]                             invokeRestart(restart)
[10:21:12.876]                             muffled <- TRUE
[10:21:12.876]                             break
[10:21:12.876]                           }
[10:21:12.876]                         }
[10:21:12.876]                       }
[10:21:12.876]                       invisible(muffled)
[10:21:12.876]                     }
[10:21:12.876]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.876]                   }
[10:21:12.876]                 }
[10:21:12.876]             }
[10:21:12.876]         }))
[10:21:12.876]     }, error = function(ex) {
[10:21:12.876]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:12.876]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.876]                 ...future.rng), started = ...future.startTime, 
[10:21:12.876]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:12.876]             version = "1.8"), class = "FutureResult")
[10:21:12.876]     }, finally = {
[10:21:12.876]         if (!identical(...future.workdir, getwd())) 
[10:21:12.876]             setwd(...future.workdir)
[10:21:12.876]         {
[10:21:12.876]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:12.876]                 ...future.oldOptions$nwarnings <- NULL
[10:21:12.876]             }
[10:21:12.876]             base::options(...future.oldOptions)
[10:21:12.876]             if (.Platform$OS.type == "windows") {
[10:21:12.876]                 old_names <- names(...future.oldEnvVars)
[10:21:12.876]                 envs <- base::Sys.getenv()
[10:21:12.876]                 names <- names(envs)
[10:21:12.876]                 common <- intersect(names, old_names)
[10:21:12.876]                 added <- setdiff(names, old_names)
[10:21:12.876]                 removed <- setdiff(old_names, names)
[10:21:12.876]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:12.876]                   envs[common]]
[10:21:12.876]                 NAMES <- toupper(changed)
[10:21:12.876]                 args <- list()
[10:21:12.876]                 for (kk in seq_along(NAMES)) {
[10:21:12.876]                   name <- changed[[kk]]
[10:21:12.876]                   NAME <- NAMES[[kk]]
[10:21:12.876]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.876]                     next
[10:21:12.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.876]                 }
[10:21:12.876]                 NAMES <- toupper(added)
[10:21:12.876]                 for (kk in seq_along(NAMES)) {
[10:21:12.876]                   name <- added[[kk]]
[10:21:12.876]                   NAME <- NAMES[[kk]]
[10:21:12.876]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.876]                     next
[10:21:12.876]                   args[[name]] <- ""
[10:21:12.876]                 }
[10:21:12.876]                 NAMES <- toupper(removed)
[10:21:12.876]                 for (kk in seq_along(NAMES)) {
[10:21:12.876]                   name <- removed[[kk]]
[10:21:12.876]                   NAME <- NAMES[[kk]]
[10:21:12.876]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.876]                     next
[10:21:12.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.876]                 }
[10:21:12.876]                 if (length(args) > 0) 
[10:21:12.876]                   base::do.call(base::Sys.setenv, args = args)
[10:21:12.876]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:12.876]             }
[10:21:12.876]             else {
[10:21:12.876]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:12.876]             }
[10:21:12.876]             {
[10:21:12.876]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:12.876]                   0L) {
[10:21:12.876]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:12.876]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:12.876]                   base::options(opts)
[10:21:12.876]                 }
[10:21:12.876]                 {
[10:21:12.876]                   {
[10:21:12.876]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:12.876]                     NULL
[10:21:12.876]                   }
[10:21:12.876]                   options(future.plan = NULL)
[10:21:12.876]                   if (is.na(NA_character_)) 
[10:21:12.876]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.876]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:12.876]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:12.876]                     .init = FALSE)
[10:21:12.876]                 }
[10:21:12.876]             }
[10:21:12.876]         }
[10:21:12.876]     })
[10:21:12.876]     if (TRUE) {
[10:21:12.876]         base::sink(type = "output", split = FALSE)
[10:21:12.876]         if (TRUE) {
[10:21:12.876]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:12.876]         }
[10:21:12.876]         else {
[10:21:12.876]             ...future.result["stdout"] <- base::list(NULL)
[10:21:12.876]         }
[10:21:12.876]         base::close(...future.stdout)
[10:21:12.876]         ...future.stdout <- NULL
[10:21:12.876]     }
[10:21:12.876]     ...future.result$conditions <- ...future.conditions
[10:21:12.876]     ...future.result$finished <- base::Sys.time()
[10:21:12.876]     ...future.result
[10:21:12.876] }
[10:21:12.879] assign_globals() ...
[10:21:12.879] List of 1
[10:21:12.879]  $ a: num 1
[10:21:12.879]  - attr(*, "where")=List of 1
[10:21:12.879]   ..$ a:<environment: R_EmptyEnv> 
[10:21:12.879]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:12.879]  - attr(*, "resolved")= logi FALSE
[10:21:12.879]  - attr(*, "total_size")= num 39
[10:21:12.879]  - attr(*, "already-done")= logi TRUE
[10:21:12.882] - copied ‘a’ to environment
[10:21:12.882] assign_globals() ... done
[10:21:12.882] requestCore(): workers = 2
[10:21:12.884] MulticoreFuture started
[10:21:12.885] - Launch lazy future ... done
[10:21:12.885] run() for ‘MulticoreFuture’ ... done
[10:21:12.885] result() for MulticoreFuture ...
[10:21:12.885] plan(): Setting new future strategy stack:
[10:21:12.886] List of future strategies:
[10:21:12.886] 1. sequential:
[10:21:12.886]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.886]    - tweaked: FALSE
[10:21:12.886]    - call: NULL
[10:21:12.887] plan(): nbrOfWorkers() = 1
[10:21:12.889] plan(): Setting new future strategy stack:
[10:21:12.889] List of future strategies:
[10:21:12.889] 1. multicore:
[10:21:12.889]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:12.889]    - tweaked: FALSE
[10:21:12.889]    - call: plan(strategy)
[10:21:12.892] plan(): nbrOfWorkers() = 2
[10:21:12.893] result() for MulticoreFuture ...
[10:21:12.893] result() for MulticoreFuture ... done
[10:21:12.893] result() for MulticoreFuture ... done
[10:21:12.893] result() for MulticoreFuture ...
[10:21:12.893] result() for MulticoreFuture ... done
[10:21:12.894] getGlobalsAndPackages() ...
[10:21:12.894] Searching for globals...
[10:21:12.895] - globals found: [3] ‘{’, ‘*’, ‘a’
[10:21:12.895] Searching for globals ... DONE
[10:21:12.896] Resolving globals: FALSE
[10:21:12.896] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:12.897] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:12.897] - globals: [1] ‘a’
[10:21:12.897] 
[10:21:12.897] getGlobalsAndPackages() ... DONE
[10:21:12.897] run() for ‘Future’ ...
[10:21:12.897] - state: ‘created’
[10:21:12.898] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:12.902] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:12.903] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:12.903]   - Field: ‘label’
[10:21:12.903]   - Field: ‘local’
[10:21:12.903]   - Field: ‘owner’
[10:21:12.903]   - Field: ‘envir’
[10:21:12.903]   - Field: ‘workers’
[10:21:12.903]   - Field: ‘packages’
[10:21:12.904]   - Field: ‘gc’
[10:21:12.904]   - Field: ‘job’
[10:21:12.904]   - Field: ‘conditions’
[10:21:12.904]   - Field: ‘expr’
[10:21:12.904]   - Field: ‘uuid’
[10:21:12.904]   - Field: ‘seed’
[10:21:12.904]   - Field: ‘version’
[10:21:12.904]   - Field: ‘result’
[10:21:12.904]   - Field: ‘asynchronous’
[10:21:12.905]   - Field: ‘calls’
[10:21:12.905]   - Field: ‘globals’
[10:21:12.905]   - Field: ‘stdout’
[10:21:12.905]   - Field: ‘earlySignal’
[10:21:12.905]   - Field: ‘lazy’
[10:21:12.905]   - Field: ‘state’
[10:21:12.905] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:12.905] - Launch lazy future ...
[10:21:12.906] Packages needed by the future expression (n = 0): <none>
[10:21:12.906] Packages needed by future strategies (n = 0): <none>
[10:21:12.907] {
[10:21:12.907]     {
[10:21:12.907]         {
[10:21:12.907]             ...future.startTime <- base::Sys.time()
[10:21:12.907]             {
[10:21:12.907]                 {
[10:21:12.907]                   {
[10:21:12.907]                     {
[10:21:12.907]                       base::local({
[10:21:12.907]                         has_future <- base::requireNamespace("future", 
[10:21:12.907]                           quietly = TRUE)
[10:21:12.907]                         if (has_future) {
[10:21:12.907]                           ns <- base::getNamespace("future")
[10:21:12.907]                           version <- ns[[".package"]][["version"]]
[10:21:12.907]                           if (is.null(version)) 
[10:21:12.907]                             version <- utils::packageVersion("future")
[10:21:12.907]                         }
[10:21:12.907]                         else {
[10:21:12.907]                           version <- NULL
[10:21:12.907]                         }
[10:21:12.907]                         if (!has_future || version < "1.8.0") {
[10:21:12.907]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:12.907]                             "", base::R.version$version.string), 
[10:21:12.907]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:12.907]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:12.907]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:12.907]                               "release", "version")], collapse = " "), 
[10:21:12.907]                             hostname = base::Sys.info()[["nodename"]])
[10:21:12.907]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:12.907]                             info)
[10:21:12.907]                           info <- base::paste(info, collapse = "; ")
[10:21:12.907]                           if (!has_future) {
[10:21:12.907]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:12.907]                               info)
[10:21:12.907]                           }
[10:21:12.907]                           else {
[10:21:12.907]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:12.907]                               info, version)
[10:21:12.907]                           }
[10:21:12.907]                           base::stop(msg)
[10:21:12.907]                         }
[10:21:12.907]                       })
[10:21:12.907]                     }
[10:21:12.907]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:12.907]                     base::options(mc.cores = 1L)
[10:21:12.907]                   }
[10:21:12.907]                   ...future.strategy.old <- future::plan("list")
[10:21:12.907]                   options(future.plan = NULL)
[10:21:12.907]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.907]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:12.907]                 }
[10:21:12.907]                 ...future.workdir <- getwd()
[10:21:12.907]             }
[10:21:12.907]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:12.907]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:12.907]         }
[10:21:12.907]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:12.907]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:12.907]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:12.907]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:12.907]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:12.907]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:12.907]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:12.907]             base::names(...future.oldOptions))
[10:21:12.907]     }
[10:21:12.907]     if (FALSE) {
[10:21:12.907]     }
[10:21:12.907]     else {
[10:21:12.907]         if (TRUE) {
[10:21:12.907]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:12.907]                 open = "w")
[10:21:12.907]         }
[10:21:12.907]         else {
[10:21:12.907]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:12.907]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:12.907]         }
[10:21:12.907]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:12.907]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:12.907]             base::sink(type = "output", split = FALSE)
[10:21:12.907]             base::close(...future.stdout)
[10:21:12.907]         }, add = TRUE)
[10:21:12.907]     }
[10:21:12.907]     ...future.frame <- base::sys.nframe()
[10:21:12.907]     ...future.conditions <- base::list()
[10:21:12.907]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:12.907]     if (FALSE) {
[10:21:12.907]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:12.907]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:12.907]     }
[10:21:12.907]     ...future.result <- base::tryCatch({
[10:21:12.907]         base::withCallingHandlers({
[10:21:12.907]             ...future.value <- base::withVisible(base::local({
[10:21:12.907]                 withCallingHandlers({
[10:21:12.907]                   {
[10:21:12.907]                     2 * a
[10:21:12.907]                   }
[10:21:12.907]                 }, immediateCondition = function(cond) {
[10:21:12.907]                   save_rds <- function (object, pathname, ...) 
[10:21:12.907]                   {
[10:21:12.907]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:12.907]                     if (file_test("-f", pathname_tmp)) {
[10:21:12.907]                       fi_tmp <- file.info(pathname_tmp)
[10:21:12.907]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:12.907]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:12.907]                         fi_tmp[["mtime"]])
[10:21:12.907]                     }
[10:21:12.907]                     tryCatch({
[10:21:12.907]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:12.907]                     }, error = function(ex) {
[10:21:12.907]                       msg <- conditionMessage(ex)
[10:21:12.907]                       fi_tmp <- file.info(pathname_tmp)
[10:21:12.907]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:12.907]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:12.907]                         fi_tmp[["mtime"]], msg)
[10:21:12.907]                       ex$message <- msg
[10:21:12.907]                       stop(ex)
[10:21:12.907]                     })
[10:21:12.907]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:12.907]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:12.907]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:12.907]                       fi_tmp <- file.info(pathname_tmp)
[10:21:12.907]                       fi <- file.info(pathname)
[10:21:12.907]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:12.907]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:12.907]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:12.907]                         fi[["size"]], fi[["mtime"]])
[10:21:12.907]                       stop(msg)
[10:21:12.907]                     }
[10:21:12.907]                     invisible(pathname)
[10:21:12.907]                   }
[10:21:12.907]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:12.907]                     rootPath = tempdir()) 
[10:21:12.907]                   {
[10:21:12.907]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:12.907]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:12.907]                       tmpdir = path, fileext = ".rds")
[10:21:12.907]                     save_rds(obj, file)
[10:21:12.907]                   }
[10:21:12.907]                   saveImmediateCondition(cond, path = "/tmp/Rtmp3gePII/.future/immediateConditions")
[10:21:12.907]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.907]                   {
[10:21:12.907]                     inherits <- base::inherits
[10:21:12.907]                     invokeRestart <- base::invokeRestart
[10:21:12.907]                     is.null <- base::is.null
[10:21:12.907]                     muffled <- FALSE
[10:21:12.907]                     if (inherits(cond, "message")) {
[10:21:12.907]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:12.907]                       if (muffled) 
[10:21:12.907]                         invokeRestart("muffleMessage")
[10:21:12.907]                     }
[10:21:12.907]                     else if (inherits(cond, "warning")) {
[10:21:12.907]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:12.907]                       if (muffled) 
[10:21:12.907]                         invokeRestart("muffleWarning")
[10:21:12.907]                     }
[10:21:12.907]                     else if (inherits(cond, "condition")) {
[10:21:12.907]                       if (!is.null(pattern)) {
[10:21:12.907]                         computeRestarts <- base::computeRestarts
[10:21:12.907]                         grepl <- base::grepl
[10:21:12.907]                         restarts <- computeRestarts(cond)
[10:21:12.907]                         for (restart in restarts) {
[10:21:12.907]                           name <- restart$name
[10:21:12.907]                           if (is.null(name)) 
[10:21:12.907]                             next
[10:21:12.907]                           if (!grepl(pattern, name)) 
[10:21:12.907]                             next
[10:21:12.907]                           invokeRestart(restart)
[10:21:12.907]                           muffled <- TRUE
[10:21:12.907]                           break
[10:21:12.907]                         }
[10:21:12.907]                       }
[10:21:12.907]                     }
[10:21:12.907]                     invisible(muffled)
[10:21:12.907]                   }
[10:21:12.907]                   muffleCondition(cond)
[10:21:12.907]                 })
[10:21:12.907]             }))
[10:21:12.907]             future::FutureResult(value = ...future.value$value, 
[10:21:12.907]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.907]                   ...future.rng), globalenv = if (FALSE) 
[10:21:12.907]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:12.907]                     ...future.globalenv.names))
[10:21:12.907]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:12.907]         }, condition = base::local({
[10:21:12.907]             c <- base::c
[10:21:12.907]             inherits <- base::inherits
[10:21:12.907]             invokeRestart <- base::invokeRestart
[10:21:12.907]             length <- base::length
[10:21:12.907]             list <- base::list
[10:21:12.907]             seq.int <- base::seq.int
[10:21:12.907]             signalCondition <- base::signalCondition
[10:21:12.907]             sys.calls <- base::sys.calls
[10:21:12.907]             `[[` <- base::`[[`
[10:21:12.907]             `+` <- base::`+`
[10:21:12.907]             `<<-` <- base::`<<-`
[10:21:12.907]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:12.907]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:12.907]                   3L)]
[10:21:12.907]             }
[10:21:12.907]             function(cond) {
[10:21:12.907]                 is_error <- inherits(cond, "error")
[10:21:12.907]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:12.907]                   NULL)
[10:21:12.907]                 if (is_error) {
[10:21:12.907]                   sessionInformation <- function() {
[10:21:12.907]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:12.907]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:12.907]                       search = base::search(), system = base::Sys.info())
[10:21:12.907]                   }
[10:21:12.907]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.907]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:12.907]                     cond$call), session = sessionInformation(), 
[10:21:12.907]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:12.907]                   signalCondition(cond)
[10:21:12.907]                 }
[10:21:12.907]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:12.907]                 "immediateCondition"))) {
[10:21:12.907]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:12.907]                   ...future.conditions[[length(...future.conditions) + 
[10:21:12.907]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:12.907]                   if (TRUE && !signal) {
[10:21:12.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.907]                     {
[10:21:12.907]                       inherits <- base::inherits
[10:21:12.907]                       invokeRestart <- base::invokeRestart
[10:21:12.907]                       is.null <- base::is.null
[10:21:12.907]                       muffled <- FALSE
[10:21:12.907]                       if (inherits(cond, "message")) {
[10:21:12.907]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.907]                         if (muffled) 
[10:21:12.907]                           invokeRestart("muffleMessage")
[10:21:12.907]                       }
[10:21:12.907]                       else if (inherits(cond, "warning")) {
[10:21:12.907]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.907]                         if (muffled) 
[10:21:12.907]                           invokeRestart("muffleWarning")
[10:21:12.907]                       }
[10:21:12.907]                       else if (inherits(cond, "condition")) {
[10:21:12.907]                         if (!is.null(pattern)) {
[10:21:12.907]                           computeRestarts <- base::computeRestarts
[10:21:12.907]                           grepl <- base::grepl
[10:21:12.907]                           restarts <- computeRestarts(cond)
[10:21:12.907]                           for (restart in restarts) {
[10:21:12.907]                             name <- restart$name
[10:21:12.907]                             if (is.null(name)) 
[10:21:12.907]                               next
[10:21:12.907]                             if (!grepl(pattern, name)) 
[10:21:12.907]                               next
[10:21:12.907]                             invokeRestart(restart)
[10:21:12.907]                             muffled <- TRUE
[10:21:12.907]                             break
[10:21:12.907]                           }
[10:21:12.907]                         }
[10:21:12.907]                       }
[10:21:12.907]                       invisible(muffled)
[10:21:12.907]                     }
[10:21:12.907]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.907]                   }
[10:21:12.907]                 }
[10:21:12.907]                 else {
[10:21:12.907]                   if (TRUE) {
[10:21:12.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:12.907]                     {
[10:21:12.907]                       inherits <- base::inherits
[10:21:12.907]                       invokeRestart <- base::invokeRestart
[10:21:12.907]                       is.null <- base::is.null
[10:21:12.907]                       muffled <- FALSE
[10:21:12.907]                       if (inherits(cond, "message")) {
[10:21:12.907]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:12.907]                         if (muffled) 
[10:21:12.907]                           invokeRestart("muffleMessage")
[10:21:12.907]                       }
[10:21:12.907]                       else if (inherits(cond, "warning")) {
[10:21:12.907]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:12.907]                         if (muffled) 
[10:21:12.907]                           invokeRestart("muffleWarning")
[10:21:12.907]                       }
[10:21:12.907]                       else if (inherits(cond, "condition")) {
[10:21:12.907]                         if (!is.null(pattern)) {
[10:21:12.907]                           computeRestarts <- base::computeRestarts
[10:21:12.907]                           grepl <- base::grepl
[10:21:12.907]                           restarts <- computeRestarts(cond)
[10:21:12.907]                           for (restart in restarts) {
[10:21:12.907]                             name <- restart$name
[10:21:12.907]                             if (is.null(name)) 
[10:21:12.907]                               next
[10:21:12.907]                             if (!grepl(pattern, name)) 
[10:21:12.907]                               next
[10:21:12.907]                             invokeRestart(restart)
[10:21:12.907]                             muffled <- TRUE
[10:21:12.907]                             break
[10:21:12.907]                           }
[10:21:12.907]                         }
[10:21:12.907]                       }
[10:21:12.907]                       invisible(muffled)
[10:21:12.907]                     }
[10:21:12.907]                     muffleCondition(cond, pattern = "^muffle")
[10:21:12.907]                   }
[10:21:12.907]                 }
[10:21:12.907]             }
[10:21:12.907]         }))
[10:21:12.907]     }, error = function(ex) {
[10:21:12.907]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:12.907]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:12.907]                 ...future.rng), started = ...future.startTime, 
[10:21:12.907]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:12.907]             version = "1.8"), class = "FutureResult")
[10:21:12.907]     }, finally = {
[10:21:12.907]         if (!identical(...future.workdir, getwd())) 
[10:21:12.907]             setwd(...future.workdir)
[10:21:12.907]         {
[10:21:12.907]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:12.907]                 ...future.oldOptions$nwarnings <- NULL
[10:21:12.907]             }
[10:21:12.907]             base::options(...future.oldOptions)
[10:21:12.907]             if (.Platform$OS.type == "windows") {
[10:21:12.907]                 old_names <- names(...future.oldEnvVars)
[10:21:12.907]                 envs <- base::Sys.getenv()
[10:21:12.907]                 names <- names(envs)
[10:21:12.907]                 common <- intersect(names, old_names)
[10:21:12.907]                 added <- setdiff(names, old_names)
[10:21:12.907]                 removed <- setdiff(old_names, names)
[10:21:12.907]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:12.907]                   envs[common]]
[10:21:12.907]                 NAMES <- toupper(changed)
[10:21:12.907]                 args <- list()
[10:21:12.907]                 for (kk in seq_along(NAMES)) {
[10:21:12.907]                   name <- changed[[kk]]
[10:21:12.907]                   NAME <- NAMES[[kk]]
[10:21:12.907]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.907]                     next
[10:21:12.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.907]                 }
[10:21:12.907]                 NAMES <- toupper(added)
[10:21:12.907]                 for (kk in seq_along(NAMES)) {
[10:21:12.907]                   name <- added[[kk]]
[10:21:12.907]                   NAME <- NAMES[[kk]]
[10:21:12.907]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.907]                     next
[10:21:12.907]                   args[[name]] <- ""
[10:21:12.907]                 }
[10:21:12.907]                 NAMES <- toupper(removed)
[10:21:12.907]                 for (kk in seq_along(NAMES)) {
[10:21:12.907]                   name <- removed[[kk]]
[10:21:12.907]                   NAME <- NAMES[[kk]]
[10:21:12.907]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:12.907]                     next
[10:21:12.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:12.907]                 }
[10:21:12.907]                 if (length(args) > 0) 
[10:21:12.907]                   base::do.call(base::Sys.setenv, args = args)
[10:21:12.907]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:12.907]             }
[10:21:12.907]             else {
[10:21:12.907]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:12.907]             }
[10:21:12.907]             {
[10:21:12.907]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:12.907]                   0L) {
[10:21:12.907]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:12.907]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:12.907]                   base::options(opts)
[10:21:12.907]                 }
[10:21:12.907]                 {
[10:21:12.907]                   {
[10:21:12.907]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:12.907]                     NULL
[10:21:12.907]                   }
[10:21:12.907]                   options(future.plan = NULL)
[10:21:12.907]                   if (is.na(NA_character_)) 
[10:21:12.907]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:12.907]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:12.907]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:12.907]                     .init = FALSE)
[10:21:12.907]                 }
[10:21:12.907]             }
[10:21:12.907]         }
[10:21:12.907]     })
[10:21:12.907]     if (TRUE) {
[10:21:12.907]         base::sink(type = "output", split = FALSE)
[10:21:12.907]         if (TRUE) {
[10:21:12.907]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:12.907]         }
[10:21:12.907]         else {
[10:21:12.907]             ...future.result["stdout"] <- base::list(NULL)
[10:21:12.907]         }
[10:21:12.907]         base::close(...future.stdout)
[10:21:12.907]         ...future.stdout <- NULL
[10:21:12.907]     }
[10:21:12.907]     ...future.result$conditions <- ...future.conditions
[10:21:12.907]     ...future.result$finished <- base::Sys.time()
[10:21:12.907]     ...future.result
[10:21:12.907] }
[10:21:12.909] assign_globals() ...
[10:21:12.909] List of 1
[10:21:12.909]  $ a: num 1
[10:21:12.909]  - attr(*, "where")=List of 1
[10:21:12.909]   ..$ a:<environment: R_EmptyEnv> 
[10:21:12.909]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:12.909]  - attr(*, "resolved")= logi FALSE
[10:21:12.909]  - attr(*, "total_size")= num 39
[10:21:12.909]  - attr(*, "already-done")= logi TRUE
[10:21:12.912] - copied ‘a’ to environment
[10:21:12.912] assign_globals() ... done
[10:21:12.912] requestCore(): workers = 2
[10:21:12.914] MulticoreFuture started
[10:21:12.915] - Launch lazy future ... done
[10:21:12.915] run() for ‘MulticoreFuture’ ... done
[10:21:12.915] result() for MulticoreFuture ...
[10:21:12.915] plan(): Setting new future strategy stack:
[10:21:12.916] List of future strategies:
[10:21:12.916] 1. sequential:
[10:21:12.916]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:12.916]    - tweaked: FALSE
[10:21:12.916]    - call: NULL
[10:21:12.917] plan(): nbrOfWorkers() = 1
[10:21:12.919] plan(): Setting new future strategy stack:
[10:21:12.919] List of future strategies:
[10:21:12.919] 1. multicore:
[10:21:12.919]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:12.919]    - tweaked: FALSE
[10:21:12.919]    - call: plan(strategy)
[10:21:12.922] plan(): nbrOfWorkers() = 2
[10:21:12.923] result() for MulticoreFuture ...
[10:21:12.923] result() for MulticoreFuture ... done
[10:21:12.923] result() for MulticoreFuture ... done
[10:21:12.923] result() for MulticoreFuture ...
[10:21:12.923] result() for MulticoreFuture ... done
*** futureAssign() with ‘multicore’ futures ... DONE
*** futureAssign() with ‘multisession’ futures ...
[10:21:12.924] plan(): Setting new future strategy stack:
[10:21:12.924] List of future strategies:
[10:21:12.924] 1. multisession:
[10:21:12.924]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:12.924]    - tweaked: FALSE
[10:21:12.924]    - call: plan(strategy)
[10:21:12.925] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:21:12.925] multisession:
[10:21:12.925] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:12.925] - tweaked: FALSE
[10:21:12.925] - call: plan(strategy)
[10:21:12.930] getGlobalsAndPackages() ...
[10:21:12.930] Not searching for globals
[10:21:12.930] - globals: [0] <none>
[10:21:12.930] getGlobalsAndPackages() ... DONE
[10:21:13.413] Packages needed by the future expression (n = 0): <none>
[10:21:13.414] Packages needed by future strategies (n = 0): <none>
[10:21:13.414] {
[10:21:13.414]     {
[10:21:13.414]         {
[10:21:13.414]             ...future.startTime <- base::Sys.time()
[10:21:13.414]             {
[10:21:13.414]                 {
[10:21:13.414]                   {
[10:21:13.414]                     {
[10:21:13.414]                       base::local({
[10:21:13.414]                         has_future <- base::requireNamespace("future", 
[10:21:13.414]                           quietly = TRUE)
[10:21:13.414]                         if (has_future) {
[10:21:13.414]                           ns <- base::getNamespace("future")
[10:21:13.414]                           version <- ns[[".package"]][["version"]]
[10:21:13.414]                           if (is.null(version)) 
[10:21:13.414]                             version <- utils::packageVersion("future")
[10:21:13.414]                         }
[10:21:13.414]                         else {
[10:21:13.414]                           version <- NULL
[10:21:13.414]                         }
[10:21:13.414]                         if (!has_future || version < "1.8.0") {
[10:21:13.414]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:13.414]                             "", base::R.version$version.string), 
[10:21:13.414]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:13.414]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:13.414]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:13.414]                               "release", "version")], collapse = " "), 
[10:21:13.414]                             hostname = base::Sys.info()[["nodename"]])
[10:21:13.414]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:13.414]                             info)
[10:21:13.414]                           info <- base::paste(info, collapse = "; ")
[10:21:13.414]                           if (!has_future) {
[10:21:13.414]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:13.414]                               info)
[10:21:13.414]                           }
[10:21:13.414]                           else {
[10:21:13.414]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:13.414]                               info, version)
[10:21:13.414]                           }
[10:21:13.414]                           base::stop(msg)
[10:21:13.414]                         }
[10:21:13.414]                       })
[10:21:13.414]                     }
[10:21:13.414]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:13.414]                     base::options(mc.cores = 1L)
[10:21:13.414]                   }
[10:21:13.414]                   ...future.strategy.old <- future::plan("list")
[10:21:13.414]                   options(future.plan = NULL)
[10:21:13.414]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:13.414]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:13.414]                 }
[10:21:13.414]                 ...future.workdir <- getwd()
[10:21:13.414]             }
[10:21:13.414]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:13.414]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:13.414]         }
[10:21:13.414]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:13.414]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:13.414]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:13.414]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:13.414]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:13.414]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:13.414]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:13.414]             base::names(...future.oldOptions))
[10:21:13.414]     }
[10:21:13.414]     if (FALSE) {
[10:21:13.414]     }
[10:21:13.414]     else {
[10:21:13.414]         if (TRUE) {
[10:21:13.414]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:13.414]                 open = "w")
[10:21:13.414]         }
[10:21:13.414]         else {
[10:21:13.414]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:13.414]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:13.414]         }
[10:21:13.414]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:13.414]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:13.414]             base::sink(type = "output", split = FALSE)
[10:21:13.414]             base::close(...future.stdout)
[10:21:13.414]         }, add = TRUE)
[10:21:13.414]     }
[10:21:13.414]     ...future.frame <- base::sys.nframe()
[10:21:13.414]     ...future.conditions <- base::list()
[10:21:13.414]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:13.414]     if (FALSE) {
[10:21:13.414]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:13.414]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:13.414]     }
[10:21:13.414]     ...future.result <- base::tryCatch({
[10:21:13.414]         base::withCallingHandlers({
[10:21:13.414]             ...future.value <- base::withVisible(base::local({
[10:21:13.414]                 ...future.makeSendCondition <- base::local({
[10:21:13.414]                   sendCondition <- NULL
[10:21:13.414]                   function(frame = 1L) {
[10:21:13.414]                     if (is.function(sendCondition)) 
[10:21:13.414]                       return(sendCondition)
[10:21:13.414]                     ns <- getNamespace("parallel")
[10:21:13.414]                     if (exists("sendData", mode = "function", 
[10:21:13.414]                       envir = ns)) {
[10:21:13.414]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:13.414]                         envir = ns)
[10:21:13.414]                       envir <- sys.frame(frame)
[10:21:13.414]                       master <- NULL
[10:21:13.414]                       while (!identical(envir, .GlobalEnv) && 
[10:21:13.414]                         !identical(envir, emptyenv())) {
[10:21:13.414]                         if (exists("master", mode = "list", envir = envir, 
[10:21:13.414]                           inherits = FALSE)) {
[10:21:13.414]                           master <- get("master", mode = "list", 
[10:21:13.414]                             envir = envir, inherits = FALSE)
[10:21:13.414]                           if (inherits(master, c("SOCKnode", 
[10:21:13.414]                             "SOCK0node"))) {
[10:21:13.414]                             sendCondition <<- function(cond) {
[10:21:13.414]                               data <- list(type = "VALUE", value = cond, 
[10:21:13.414]                                 success = TRUE)
[10:21:13.414]                               parallel_sendData(master, data)
[10:21:13.414]                             }
[10:21:13.414]                             return(sendCondition)
[10:21:13.414]                           }
[10:21:13.414]                         }
[10:21:13.414]                         frame <- frame + 1L
[10:21:13.414]                         envir <- sys.frame(frame)
[10:21:13.414]                       }
[10:21:13.414]                     }
[10:21:13.414]                     sendCondition <<- function(cond) NULL
[10:21:13.414]                   }
[10:21:13.414]                 })
[10:21:13.414]                 withCallingHandlers({
[10:21:13.414]                   NA
[10:21:13.414]                 }, immediateCondition = function(cond) {
[10:21:13.414]                   sendCondition <- ...future.makeSendCondition()
[10:21:13.414]                   sendCondition(cond)
[10:21:13.414]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.414]                   {
[10:21:13.414]                     inherits <- base::inherits
[10:21:13.414]                     invokeRestart <- base::invokeRestart
[10:21:13.414]                     is.null <- base::is.null
[10:21:13.414]                     muffled <- FALSE
[10:21:13.414]                     if (inherits(cond, "message")) {
[10:21:13.414]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:13.414]                       if (muffled) 
[10:21:13.414]                         invokeRestart("muffleMessage")
[10:21:13.414]                     }
[10:21:13.414]                     else if (inherits(cond, "warning")) {
[10:21:13.414]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:13.414]                       if (muffled) 
[10:21:13.414]                         invokeRestart("muffleWarning")
[10:21:13.414]                     }
[10:21:13.414]                     else if (inherits(cond, "condition")) {
[10:21:13.414]                       if (!is.null(pattern)) {
[10:21:13.414]                         computeRestarts <- base::computeRestarts
[10:21:13.414]                         grepl <- base::grepl
[10:21:13.414]                         restarts <- computeRestarts(cond)
[10:21:13.414]                         for (restart in restarts) {
[10:21:13.414]                           name <- restart$name
[10:21:13.414]                           if (is.null(name)) 
[10:21:13.414]                             next
[10:21:13.414]                           if (!grepl(pattern, name)) 
[10:21:13.414]                             next
[10:21:13.414]                           invokeRestart(restart)
[10:21:13.414]                           muffled <- TRUE
[10:21:13.414]                           break
[10:21:13.414]                         }
[10:21:13.414]                       }
[10:21:13.414]                     }
[10:21:13.414]                     invisible(muffled)
[10:21:13.414]                   }
[10:21:13.414]                   muffleCondition(cond)
[10:21:13.414]                 })
[10:21:13.414]             }))
[10:21:13.414]             future::FutureResult(value = ...future.value$value, 
[10:21:13.414]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:13.414]                   ...future.rng), globalenv = if (FALSE) 
[10:21:13.414]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:13.414]                     ...future.globalenv.names))
[10:21:13.414]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:13.414]         }, condition = base::local({
[10:21:13.414]             c <- base::c
[10:21:13.414]             inherits <- base::inherits
[10:21:13.414]             invokeRestart <- base::invokeRestart
[10:21:13.414]             length <- base::length
[10:21:13.414]             list <- base::list
[10:21:13.414]             seq.int <- base::seq.int
[10:21:13.414]             signalCondition <- base::signalCondition
[10:21:13.414]             sys.calls <- base::sys.calls
[10:21:13.414]             `[[` <- base::`[[`
[10:21:13.414]             `+` <- base::`+`
[10:21:13.414]             `<<-` <- base::`<<-`
[10:21:13.414]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:13.414]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:13.414]                   3L)]
[10:21:13.414]             }
[10:21:13.414]             function(cond) {
[10:21:13.414]                 is_error <- inherits(cond, "error")
[10:21:13.414]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:13.414]                   NULL)
[10:21:13.414]                 if (is_error) {
[10:21:13.414]                   sessionInformation <- function() {
[10:21:13.414]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:13.414]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:13.414]                       search = base::search(), system = base::Sys.info())
[10:21:13.414]                   }
[10:21:13.414]                   ...future.conditions[[length(...future.conditions) + 
[10:21:13.414]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:13.414]                     cond$call), session = sessionInformation(), 
[10:21:13.414]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:13.414]                   signalCondition(cond)
[10:21:13.414]                 }
[10:21:13.414]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:13.414]                 "immediateCondition"))) {
[10:21:13.414]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:13.414]                   ...future.conditions[[length(...future.conditions) + 
[10:21:13.414]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:13.414]                   if (TRUE && !signal) {
[10:21:13.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.414]                     {
[10:21:13.414]                       inherits <- base::inherits
[10:21:13.414]                       invokeRestart <- base::invokeRestart
[10:21:13.414]                       is.null <- base::is.null
[10:21:13.414]                       muffled <- FALSE
[10:21:13.414]                       if (inherits(cond, "message")) {
[10:21:13.414]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:13.414]                         if (muffled) 
[10:21:13.414]                           invokeRestart("muffleMessage")
[10:21:13.414]                       }
[10:21:13.414]                       else if (inherits(cond, "warning")) {
[10:21:13.414]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:13.414]                         if (muffled) 
[10:21:13.414]                           invokeRestart("muffleWarning")
[10:21:13.414]                       }
[10:21:13.414]                       else if (inherits(cond, "condition")) {
[10:21:13.414]                         if (!is.null(pattern)) {
[10:21:13.414]                           computeRestarts <- base::computeRestarts
[10:21:13.414]                           grepl <- base::grepl
[10:21:13.414]                           restarts <- computeRestarts(cond)
[10:21:13.414]                           for (restart in restarts) {
[10:21:13.414]                             name <- restart$name
[10:21:13.414]                             if (is.null(name)) 
[10:21:13.414]                               next
[10:21:13.414]                             if (!grepl(pattern, name)) 
[10:21:13.414]                               next
[10:21:13.414]                             invokeRestart(restart)
[10:21:13.414]                             muffled <- TRUE
[10:21:13.414]                             break
[10:21:13.414]                           }
[10:21:13.414]                         }
[10:21:13.414]                       }
[10:21:13.414]                       invisible(muffled)
[10:21:13.414]                     }
[10:21:13.414]                     muffleCondition(cond, pattern = "^muffle")
[10:21:13.414]                   }
[10:21:13.414]                 }
[10:21:13.414]                 else {
[10:21:13.414]                   if (TRUE) {
[10:21:13.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.414]                     {
[10:21:13.414]                       inherits <- base::inherits
[10:21:13.414]                       invokeRestart <- base::invokeRestart
[10:21:13.414]                       is.null <- base::is.null
[10:21:13.414]                       muffled <- FALSE
[10:21:13.414]                       if (inherits(cond, "message")) {
[10:21:13.414]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:13.414]                         if (muffled) 
[10:21:13.414]                           invokeRestart("muffleMessage")
[10:21:13.414]                       }
[10:21:13.414]                       else if (inherits(cond, "warning")) {
[10:21:13.414]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:13.414]                         if (muffled) 
[10:21:13.414]                           invokeRestart("muffleWarning")
[10:21:13.414]                       }
[10:21:13.414]                       else if (inherits(cond, "condition")) {
[10:21:13.414]                         if (!is.null(pattern)) {
[10:21:13.414]                           computeRestarts <- base::computeRestarts
[10:21:13.414]                           grepl <- base::grepl
[10:21:13.414]                           restarts <- computeRestarts(cond)
[10:21:13.414]                           for (restart in restarts) {
[10:21:13.414]                             name <- restart$name
[10:21:13.414]                             if (is.null(name)) 
[10:21:13.414]                               next
[10:21:13.414]                             if (!grepl(pattern, name)) 
[10:21:13.414]                               next
[10:21:13.414]                             invokeRestart(restart)
[10:21:13.414]                             muffled <- TRUE
[10:21:13.414]                             break
[10:21:13.414]                           }
[10:21:13.414]                         }
[10:21:13.414]                       }
[10:21:13.414]                       invisible(muffled)
[10:21:13.414]                     }
[10:21:13.414]                     muffleCondition(cond, pattern = "^muffle")
[10:21:13.414]                   }
[10:21:13.414]                 }
[10:21:13.414]             }
[10:21:13.414]         }))
[10:21:13.414]     }, error = function(ex) {
[10:21:13.414]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:13.414]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:13.414]                 ...future.rng), started = ...future.startTime, 
[10:21:13.414]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:13.414]             version = "1.8"), class = "FutureResult")
[10:21:13.414]     }, finally = {
[10:21:13.414]         if (!identical(...future.workdir, getwd())) 
[10:21:13.414]             setwd(...future.workdir)
[10:21:13.414]         {
[10:21:13.414]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:13.414]                 ...future.oldOptions$nwarnings <- NULL
[10:21:13.414]             }
[10:21:13.414]             base::options(...future.oldOptions)
[10:21:13.414]             if (.Platform$OS.type == "windows") {
[10:21:13.414]                 old_names <- names(...future.oldEnvVars)
[10:21:13.414]                 envs <- base::Sys.getenv()
[10:21:13.414]                 names <- names(envs)
[10:21:13.414]                 common <- intersect(names, old_names)
[10:21:13.414]                 added <- setdiff(names, old_names)
[10:21:13.414]                 removed <- setdiff(old_names, names)
[10:21:13.414]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:13.414]                   envs[common]]
[10:21:13.414]                 NAMES <- toupper(changed)
[10:21:13.414]                 args <- list()
[10:21:13.414]                 for (kk in seq_along(NAMES)) {
[10:21:13.414]                   name <- changed[[kk]]
[10:21:13.414]                   NAME <- NAMES[[kk]]
[10:21:13.414]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.414]                     next
[10:21:13.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:13.414]                 }
[10:21:13.414]                 NAMES <- toupper(added)
[10:21:13.414]                 for (kk in seq_along(NAMES)) {
[10:21:13.414]                   name <- added[[kk]]
[10:21:13.414]                   NAME <- NAMES[[kk]]
[10:21:13.414]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.414]                     next
[10:21:13.414]                   args[[name]] <- ""
[10:21:13.414]                 }
[10:21:13.414]                 NAMES <- toupper(removed)
[10:21:13.414]                 for (kk in seq_along(NAMES)) {
[10:21:13.414]                   name <- removed[[kk]]
[10:21:13.414]                   NAME <- NAMES[[kk]]
[10:21:13.414]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.414]                     next
[10:21:13.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:13.414]                 }
[10:21:13.414]                 if (length(args) > 0) 
[10:21:13.414]                   base::do.call(base::Sys.setenv, args = args)
[10:21:13.414]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:13.414]             }
[10:21:13.414]             else {
[10:21:13.414]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:13.414]             }
[10:21:13.414]             {
[10:21:13.414]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:13.414]                   0L) {
[10:21:13.414]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:13.414]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:13.414]                   base::options(opts)
[10:21:13.414]                 }
[10:21:13.414]                 {
[10:21:13.414]                   {
[10:21:13.414]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:13.414]                     NULL
[10:21:13.414]                   }
[10:21:13.414]                   options(future.plan = NULL)
[10:21:13.414]                   if (is.na(NA_character_)) 
[10:21:13.414]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:13.414]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:13.414]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:13.414]                     .init = FALSE)
[10:21:13.414]                 }
[10:21:13.414]             }
[10:21:13.414]         }
[10:21:13.414]     })
[10:21:13.414]     if (TRUE) {
[10:21:13.414]         base::sink(type = "output", split = FALSE)
[10:21:13.414]         if (TRUE) {
[10:21:13.414]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:13.414]         }
[10:21:13.414]         else {
[10:21:13.414]             ...future.result["stdout"] <- base::list(NULL)
[10:21:13.414]         }
[10:21:13.414]         base::close(...future.stdout)
[10:21:13.414]         ...future.stdout <- NULL
[10:21:13.414]     }
[10:21:13.414]     ...future.result$conditions <- ...future.conditions
[10:21:13.414]     ...future.result$finished <- base::Sys.time()
[10:21:13.414]     ...future.result
[10:21:13.414] }
[10:21:13.466] MultisessionFuture started
[10:21:13.466] result() for ClusterFuture ...
[10:21:13.467] receiveMessageFromWorker() for ClusterFuture ...
[10:21:13.467] - Validating connection of MultisessionFuture
[10:21:13.497] - received message: FutureResult
[10:21:13.497] - Received FutureResult
[10:21:13.497] - Erased future from FutureRegistry
[10:21:13.497] result() for ClusterFuture ...
[10:21:13.497] - result already collected: FutureResult
[10:21:13.497] result() for ClusterFuture ... done
[10:21:13.498] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:13.498] result() for ClusterFuture ... done
[10:21:13.498] result() for ClusterFuture ...
[10:21:13.498] - result already collected: FutureResult
[10:21:13.498] result() for ClusterFuture ... done
[10:21:13.498] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:21:13.500] plan(): nbrOfWorkers() = 2
[10:21:13.500] getGlobalsAndPackages() ...
[10:21:13.500] Searching for globals...
[10:21:13.500] - globals found: [1] ‘{’
[10:21:13.501] Searching for globals ... DONE
[10:21:13.501] Resolving globals: FALSE
[10:21:13.501] 
[10:21:13.501] 
[10:21:13.501] getGlobalsAndPackages() ... DONE
[10:21:13.501] run() for ‘Future’ ...
[10:21:13.501] - state: ‘created’
[10:21:13.502] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:13.516] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:13.516] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:13.516]   - Field: ‘node’
[10:21:13.516]   - Field: ‘label’
[10:21:13.517]   - Field: ‘local’
[10:21:13.517]   - Field: ‘owner’
[10:21:13.517]   - Field: ‘envir’
[10:21:13.517]   - Field: ‘workers’
[10:21:13.517]   - Field: ‘packages’
[10:21:13.517]   - Field: ‘gc’
[10:21:13.517]   - Field: ‘conditions’
[10:21:13.517]   - Field: ‘persistent’
[10:21:13.517]   - Field: ‘expr’
[10:21:13.517]   - Field: ‘uuid’
[10:21:13.517]   - Field: ‘seed’
[10:21:13.517]   - Field: ‘version’
[10:21:13.518]   - Field: ‘result’
[10:21:13.518]   - Field: ‘asynchronous’
[10:21:13.518]   - Field: ‘calls’
[10:21:13.518]   - Field: ‘globals’
[10:21:13.518]   - Field: ‘stdout’
[10:21:13.518]   - Field: ‘earlySignal’
[10:21:13.518]   - Field: ‘lazy’
[10:21:13.518]   - Field: ‘state’
[10:21:13.518] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:13.518] - Launch lazy future ...
[10:21:13.519] Packages needed by the future expression (n = 0): <none>
[10:21:13.519] Packages needed by future strategies (n = 0): <none>
[10:21:13.519] {
[10:21:13.519]     {
[10:21:13.519]         {
[10:21:13.519]             ...future.startTime <- base::Sys.time()
[10:21:13.519]             {
[10:21:13.519]                 {
[10:21:13.519]                   {
[10:21:13.519]                     {
[10:21:13.519]                       base::local({
[10:21:13.519]                         has_future <- base::requireNamespace("future", 
[10:21:13.519]                           quietly = TRUE)
[10:21:13.519]                         if (has_future) {
[10:21:13.519]                           ns <- base::getNamespace("future")
[10:21:13.519]                           version <- ns[[".package"]][["version"]]
[10:21:13.519]                           if (is.null(version)) 
[10:21:13.519]                             version <- utils::packageVersion("future")
[10:21:13.519]                         }
[10:21:13.519]                         else {
[10:21:13.519]                           version <- NULL
[10:21:13.519]                         }
[10:21:13.519]                         if (!has_future || version < "1.8.0") {
[10:21:13.519]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:13.519]                             "", base::R.version$version.string), 
[10:21:13.519]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:13.519]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:13.519]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:13.519]                               "release", "version")], collapse = " "), 
[10:21:13.519]                             hostname = base::Sys.info()[["nodename"]])
[10:21:13.519]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:13.519]                             info)
[10:21:13.519]                           info <- base::paste(info, collapse = "; ")
[10:21:13.519]                           if (!has_future) {
[10:21:13.519]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:13.519]                               info)
[10:21:13.519]                           }
[10:21:13.519]                           else {
[10:21:13.519]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:13.519]                               info, version)
[10:21:13.519]                           }
[10:21:13.519]                           base::stop(msg)
[10:21:13.519]                         }
[10:21:13.519]                       })
[10:21:13.519]                     }
[10:21:13.519]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:13.519]                     base::options(mc.cores = 1L)
[10:21:13.519]                   }
[10:21:13.519]                   ...future.strategy.old <- future::plan("list")
[10:21:13.519]                   options(future.plan = NULL)
[10:21:13.519]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:13.519]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:13.519]                 }
[10:21:13.519]                 ...future.workdir <- getwd()
[10:21:13.519]             }
[10:21:13.519]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:13.519]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:13.519]         }
[10:21:13.519]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:13.519]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:13.519]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:13.519]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:13.519]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:13.519]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:13.519]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:13.519]             base::names(...future.oldOptions))
[10:21:13.519]     }
[10:21:13.519]     if (FALSE) {
[10:21:13.519]     }
[10:21:13.519]     else {
[10:21:13.519]         if (TRUE) {
[10:21:13.519]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:13.519]                 open = "w")
[10:21:13.519]         }
[10:21:13.519]         else {
[10:21:13.519]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:13.519]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:13.519]         }
[10:21:13.519]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:13.519]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:13.519]             base::sink(type = "output", split = FALSE)
[10:21:13.519]             base::close(...future.stdout)
[10:21:13.519]         }, add = TRUE)
[10:21:13.519]     }
[10:21:13.519]     ...future.frame <- base::sys.nframe()
[10:21:13.519]     ...future.conditions <- base::list()
[10:21:13.519]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:13.519]     if (FALSE) {
[10:21:13.519]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:13.519]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:13.519]     }
[10:21:13.519]     ...future.result <- base::tryCatch({
[10:21:13.519]         base::withCallingHandlers({
[10:21:13.519]             ...future.value <- base::withVisible(base::local({
[10:21:13.519]                 ...future.makeSendCondition <- base::local({
[10:21:13.519]                   sendCondition <- NULL
[10:21:13.519]                   function(frame = 1L) {
[10:21:13.519]                     if (is.function(sendCondition)) 
[10:21:13.519]                       return(sendCondition)
[10:21:13.519]                     ns <- getNamespace("parallel")
[10:21:13.519]                     if (exists("sendData", mode = "function", 
[10:21:13.519]                       envir = ns)) {
[10:21:13.519]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:13.519]                         envir = ns)
[10:21:13.519]                       envir <- sys.frame(frame)
[10:21:13.519]                       master <- NULL
[10:21:13.519]                       while (!identical(envir, .GlobalEnv) && 
[10:21:13.519]                         !identical(envir, emptyenv())) {
[10:21:13.519]                         if (exists("master", mode = "list", envir = envir, 
[10:21:13.519]                           inherits = FALSE)) {
[10:21:13.519]                           master <- get("master", mode = "list", 
[10:21:13.519]                             envir = envir, inherits = FALSE)
[10:21:13.519]                           if (inherits(master, c("SOCKnode", 
[10:21:13.519]                             "SOCK0node"))) {
[10:21:13.519]                             sendCondition <<- function(cond) {
[10:21:13.519]                               data <- list(type = "VALUE", value = cond, 
[10:21:13.519]                                 success = TRUE)
[10:21:13.519]                               parallel_sendData(master, data)
[10:21:13.519]                             }
[10:21:13.519]                             return(sendCondition)
[10:21:13.519]                           }
[10:21:13.519]                         }
[10:21:13.519]                         frame <- frame + 1L
[10:21:13.519]                         envir <- sys.frame(frame)
[10:21:13.519]                       }
[10:21:13.519]                     }
[10:21:13.519]                     sendCondition <<- function(cond) NULL
[10:21:13.519]                   }
[10:21:13.519]                 })
[10:21:13.519]                 withCallingHandlers({
[10:21:13.519]                   {
[10:21:13.519]                     2
[10:21:13.519]                   }
[10:21:13.519]                 }, immediateCondition = function(cond) {
[10:21:13.519]                   sendCondition <- ...future.makeSendCondition()
[10:21:13.519]                   sendCondition(cond)
[10:21:13.519]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.519]                   {
[10:21:13.519]                     inherits <- base::inherits
[10:21:13.519]                     invokeRestart <- base::invokeRestart
[10:21:13.519]                     is.null <- base::is.null
[10:21:13.519]                     muffled <- FALSE
[10:21:13.519]                     if (inherits(cond, "message")) {
[10:21:13.519]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:13.519]                       if (muffled) 
[10:21:13.519]                         invokeRestart("muffleMessage")
[10:21:13.519]                     }
[10:21:13.519]                     else if (inherits(cond, "warning")) {
[10:21:13.519]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:13.519]                       if (muffled) 
[10:21:13.519]                         invokeRestart("muffleWarning")
[10:21:13.519]                     }
[10:21:13.519]                     else if (inherits(cond, "condition")) {
[10:21:13.519]                       if (!is.null(pattern)) {
[10:21:13.519]                         computeRestarts <- base::computeRestarts
[10:21:13.519]                         grepl <- base::grepl
[10:21:13.519]                         restarts <- computeRestarts(cond)
[10:21:13.519]                         for (restart in restarts) {
[10:21:13.519]                           name <- restart$name
[10:21:13.519]                           if (is.null(name)) 
[10:21:13.519]                             next
[10:21:13.519]                           if (!grepl(pattern, name)) 
[10:21:13.519]                             next
[10:21:13.519]                           invokeRestart(restart)
[10:21:13.519]                           muffled <- TRUE
[10:21:13.519]                           break
[10:21:13.519]                         }
[10:21:13.519]                       }
[10:21:13.519]                     }
[10:21:13.519]                     invisible(muffled)
[10:21:13.519]                   }
[10:21:13.519]                   muffleCondition(cond)
[10:21:13.519]                 })
[10:21:13.519]             }))
[10:21:13.519]             future::FutureResult(value = ...future.value$value, 
[10:21:13.519]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:13.519]                   ...future.rng), globalenv = if (FALSE) 
[10:21:13.519]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:13.519]                     ...future.globalenv.names))
[10:21:13.519]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:13.519]         }, condition = base::local({
[10:21:13.519]             c <- base::c
[10:21:13.519]             inherits <- base::inherits
[10:21:13.519]             invokeRestart <- base::invokeRestart
[10:21:13.519]             length <- base::length
[10:21:13.519]             list <- base::list
[10:21:13.519]             seq.int <- base::seq.int
[10:21:13.519]             signalCondition <- base::signalCondition
[10:21:13.519]             sys.calls <- base::sys.calls
[10:21:13.519]             `[[` <- base::`[[`
[10:21:13.519]             `+` <- base::`+`
[10:21:13.519]             `<<-` <- base::`<<-`
[10:21:13.519]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:13.519]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:13.519]                   3L)]
[10:21:13.519]             }
[10:21:13.519]             function(cond) {
[10:21:13.519]                 is_error <- inherits(cond, "error")
[10:21:13.519]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:13.519]                   NULL)
[10:21:13.519]                 if (is_error) {
[10:21:13.519]                   sessionInformation <- function() {
[10:21:13.519]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:13.519]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:13.519]                       search = base::search(), system = base::Sys.info())
[10:21:13.519]                   }
[10:21:13.519]                   ...future.conditions[[length(...future.conditions) + 
[10:21:13.519]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:13.519]                     cond$call), session = sessionInformation(), 
[10:21:13.519]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:13.519]                   signalCondition(cond)
[10:21:13.519]                 }
[10:21:13.519]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:13.519]                 "immediateCondition"))) {
[10:21:13.519]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:13.519]                   ...future.conditions[[length(...future.conditions) + 
[10:21:13.519]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:13.519]                   if (TRUE && !signal) {
[10:21:13.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.519]                     {
[10:21:13.519]                       inherits <- base::inherits
[10:21:13.519]                       invokeRestart <- base::invokeRestart
[10:21:13.519]                       is.null <- base::is.null
[10:21:13.519]                       muffled <- FALSE
[10:21:13.519]                       if (inherits(cond, "message")) {
[10:21:13.519]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:13.519]                         if (muffled) 
[10:21:13.519]                           invokeRestart("muffleMessage")
[10:21:13.519]                       }
[10:21:13.519]                       else if (inherits(cond, "warning")) {
[10:21:13.519]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:13.519]                         if (muffled) 
[10:21:13.519]                           invokeRestart("muffleWarning")
[10:21:13.519]                       }
[10:21:13.519]                       else if (inherits(cond, "condition")) {
[10:21:13.519]                         if (!is.null(pattern)) {
[10:21:13.519]                           computeRestarts <- base::computeRestarts
[10:21:13.519]                           grepl <- base::grepl
[10:21:13.519]                           restarts <- computeRestarts(cond)
[10:21:13.519]                           for (restart in restarts) {
[10:21:13.519]                             name <- restart$name
[10:21:13.519]                             if (is.null(name)) 
[10:21:13.519]                               next
[10:21:13.519]                             if (!grepl(pattern, name)) 
[10:21:13.519]                               next
[10:21:13.519]                             invokeRestart(restart)
[10:21:13.519]                             muffled <- TRUE
[10:21:13.519]                             break
[10:21:13.519]                           }
[10:21:13.519]                         }
[10:21:13.519]                       }
[10:21:13.519]                       invisible(muffled)
[10:21:13.519]                     }
[10:21:13.519]                     muffleCondition(cond, pattern = "^muffle")
[10:21:13.519]                   }
[10:21:13.519]                 }
[10:21:13.519]                 else {
[10:21:13.519]                   if (TRUE) {
[10:21:13.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.519]                     {
[10:21:13.519]                       inherits <- base::inherits
[10:21:13.519]                       invokeRestart <- base::invokeRestart
[10:21:13.519]                       is.null <- base::is.null
[10:21:13.519]                       muffled <- FALSE
[10:21:13.519]                       if (inherits(cond, "message")) {
[10:21:13.519]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:13.519]                         if (muffled) 
[10:21:13.519]                           invokeRestart("muffleMessage")
[10:21:13.519]                       }
[10:21:13.519]                       else if (inherits(cond, "warning")) {
[10:21:13.519]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:13.519]                         if (muffled) 
[10:21:13.519]                           invokeRestart("muffleWarning")
[10:21:13.519]                       }
[10:21:13.519]                       else if (inherits(cond, "condition")) {
[10:21:13.519]                         if (!is.null(pattern)) {
[10:21:13.519]                           computeRestarts <- base::computeRestarts
[10:21:13.519]                           grepl <- base::grepl
[10:21:13.519]                           restarts <- computeRestarts(cond)
[10:21:13.519]                           for (restart in restarts) {
[10:21:13.519]                             name <- restart$name
[10:21:13.519]                             if (is.null(name)) 
[10:21:13.519]                               next
[10:21:13.519]                             if (!grepl(pattern, name)) 
[10:21:13.519]                               next
[10:21:13.519]                             invokeRestart(restart)
[10:21:13.519]                             muffled <- TRUE
[10:21:13.519]                             break
[10:21:13.519]                           }
[10:21:13.519]                         }
[10:21:13.519]                       }
[10:21:13.519]                       invisible(muffled)
[10:21:13.519]                     }
[10:21:13.519]                     muffleCondition(cond, pattern = "^muffle")
[10:21:13.519]                   }
[10:21:13.519]                 }
[10:21:13.519]             }
[10:21:13.519]         }))
[10:21:13.519]     }, error = function(ex) {
[10:21:13.519]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:13.519]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:13.519]                 ...future.rng), started = ...future.startTime, 
[10:21:13.519]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:13.519]             version = "1.8"), class = "FutureResult")
[10:21:13.519]     }, finally = {
[10:21:13.519]         if (!identical(...future.workdir, getwd())) 
[10:21:13.519]             setwd(...future.workdir)
[10:21:13.519]         {
[10:21:13.519]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:13.519]                 ...future.oldOptions$nwarnings <- NULL
[10:21:13.519]             }
[10:21:13.519]             base::options(...future.oldOptions)
[10:21:13.519]             if (.Platform$OS.type == "windows") {
[10:21:13.519]                 old_names <- names(...future.oldEnvVars)
[10:21:13.519]                 envs <- base::Sys.getenv()
[10:21:13.519]                 names <- names(envs)
[10:21:13.519]                 common <- intersect(names, old_names)
[10:21:13.519]                 added <- setdiff(names, old_names)
[10:21:13.519]                 removed <- setdiff(old_names, names)
[10:21:13.519]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:13.519]                   envs[common]]
[10:21:13.519]                 NAMES <- toupper(changed)
[10:21:13.519]                 args <- list()
[10:21:13.519]                 for (kk in seq_along(NAMES)) {
[10:21:13.519]                   name <- changed[[kk]]
[10:21:13.519]                   NAME <- NAMES[[kk]]
[10:21:13.519]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.519]                     next
[10:21:13.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:13.519]                 }
[10:21:13.519]                 NAMES <- toupper(added)
[10:21:13.519]                 for (kk in seq_along(NAMES)) {
[10:21:13.519]                   name <- added[[kk]]
[10:21:13.519]                   NAME <- NAMES[[kk]]
[10:21:13.519]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.519]                     next
[10:21:13.519]                   args[[name]] <- ""
[10:21:13.519]                 }
[10:21:13.519]                 NAMES <- toupper(removed)
[10:21:13.519]                 for (kk in seq_along(NAMES)) {
[10:21:13.519]                   name <- removed[[kk]]
[10:21:13.519]                   NAME <- NAMES[[kk]]
[10:21:13.519]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.519]                     next
[10:21:13.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:13.519]                 }
[10:21:13.519]                 if (length(args) > 0) 
[10:21:13.519]                   base::do.call(base::Sys.setenv, args = args)
[10:21:13.519]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:13.519]             }
[10:21:13.519]             else {
[10:21:13.519]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:13.519]             }
[10:21:13.519]             {
[10:21:13.519]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:13.519]                   0L) {
[10:21:13.519]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:13.519]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:13.519]                   base::options(opts)
[10:21:13.519]                 }
[10:21:13.519]                 {
[10:21:13.519]                   {
[10:21:13.519]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:13.519]                     NULL
[10:21:13.519]                   }
[10:21:13.519]                   options(future.plan = NULL)
[10:21:13.519]                   if (is.na(NA_character_)) 
[10:21:13.519]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:13.519]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:13.519]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:13.519]                     .init = FALSE)
[10:21:13.519]                 }
[10:21:13.519]             }
[10:21:13.519]         }
[10:21:13.519]     })
[10:21:13.519]     if (TRUE) {
[10:21:13.519]         base::sink(type = "output", split = FALSE)
[10:21:13.519]         if (TRUE) {
[10:21:13.519]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:13.519]         }
[10:21:13.519]         else {
[10:21:13.519]             ...future.result["stdout"] <- base::list(NULL)
[10:21:13.519]         }
[10:21:13.519]         base::close(...future.stdout)
[10:21:13.519]         ...future.stdout <- NULL
[10:21:13.519]     }
[10:21:13.519]     ...future.result$conditions <- ...future.conditions
[10:21:13.519]     ...future.result$finished <- base::Sys.time()
[10:21:13.519]     ...future.result
[10:21:13.519] }
[10:21:13.522] MultisessionFuture started
[10:21:13.522] - Launch lazy future ... done
[10:21:13.522] run() for ‘MultisessionFuture’ ... done
[10:21:13.522] getGlobalsAndPackages() ...
[10:21:13.523] Searching for globals...
[10:21:13.523] - globals found: [1] ‘{’
[10:21:13.523] Searching for globals ... DONE
[10:21:13.523] Resolving globals: FALSE
[10:21:13.524] 
[10:21:13.524] 
[10:21:13.524] getGlobalsAndPackages() ... DONE
[10:21:13.524] run() for ‘Future’ ...
[10:21:13.524] - state: ‘created’
[10:21:13.524] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:13.538] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:13.538] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:13.538]   - Field: ‘node’
[10:21:13.538]   - Field: ‘label’
[10:21:13.538]   - Field: ‘local’
[10:21:13.539]   - Field: ‘owner’
[10:21:13.539]   - Field: ‘envir’
[10:21:13.539]   - Field: ‘workers’
[10:21:13.539]   - Field: ‘packages’
[10:21:13.539]   - Field: ‘gc’
[10:21:13.539]   - Field: ‘conditions’
[10:21:13.539]   - Field: ‘persistent’
[10:21:13.539]   - Field: ‘expr’
[10:21:13.539]   - Field: ‘uuid’
[10:21:13.539]   - Field: ‘seed’
[10:21:13.539]   - Field: ‘version’
[10:21:13.539]   - Field: ‘result’
[10:21:13.540]   - Field: ‘asynchronous’
[10:21:13.540]   - Field: ‘calls’
[10:21:13.540]   - Field: ‘globals’
[10:21:13.540]   - Field: ‘stdout’
[10:21:13.540]   - Field: ‘earlySignal’
[10:21:13.540]   - Field: ‘lazy’
[10:21:13.540]   - Field: ‘state’
[10:21:13.540] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:13.540] - Launch lazy future ...
[10:21:13.540] Packages needed by the future expression (n = 0): <none>
[10:21:13.541] Packages needed by future strategies (n = 0): <none>
[10:21:13.541] {
[10:21:13.541]     {
[10:21:13.541]         {
[10:21:13.541]             ...future.startTime <- base::Sys.time()
[10:21:13.541]             {
[10:21:13.541]                 {
[10:21:13.541]                   {
[10:21:13.541]                     {
[10:21:13.541]                       base::local({
[10:21:13.541]                         has_future <- base::requireNamespace("future", 
[10:21:13.541]                           quietly = TRUE)
[10:21:13.541]                         if (has_future) {
[10:21:13.541]                           ns <- base::getNamespace("future")
[10:21:13.541]                           version <- ns[[".package"]][["version"]]
[10:21:13.541]                           if (is.null(version)) 
[10:21:13.541]                             version <- utils::packageVersion("future")
[10:21:13.541]                         }
[10:21:13.541]                         else {
[10:21:13.541]                           version <- NULL
[10:21:13.541]                         }
[10:21:13.541]                         if (!has_future || version < "1.8.0") {
[10:21:13.541]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:13.541]                             "", base::R.version$version.string), 
[10:21:13.541]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:13.541]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:13.541]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:13.541]                               "release", "version")], collapse = " "), 
[10:21:13.541]                             hostname = base::Sys.info()[["nodename"]])
[10:21:13.541]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:13.541]                             info)
[10:21:13.541]                           info <- base::paste(info, collapse = "; ")
[10:21:13.541]                           if (!has_future) {
[10:21:13.541]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:13.541]                               info)
[10:21:13.541]                           }
[10:21:13.541]                           else {
[10:21:13.541]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:13.541]                               info, version)
[10:21:13.541]                           }
[10:21:13.541]                           base::stop(msg)
[10:21:13.541]                         }
[10:21:13.541]                       })
[10:21:13.541]                     }
[10:21:13.541]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:13.541]                     base::options(mc.cores = 1L)
[10:21:13.541]                   }
[10:21:13.541]                   ...future.strategy.old <- future::plan("list")
[10:21:13.541]                   options(future.plan = NULL)
[10:21:13.541]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:13.541]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:13.541]                 }
[10:21:13.541]                 ...future.workdir <- getwd()
[10:21:13.541]             }
[10:21:13.541]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:13.541]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:13.541]         }
[10:21:13.541]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:13.541]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:13.541]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:13.541]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:13.541]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:13.541]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:13.541]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:13.541]             base::names(...future.oldOptions))
[10:21:13.541]     }
[10:21:13.541]     if (FALSE) {
[10:21:13.541]     }
[10:21:13.541]     else {
[10:21:13.541]         if (TRUE) {
[10:21:13.541]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:13.541]                 open = "w")
[10:21:13.541]         }
[10:21:13.541]         else {
[10:21:13.541]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:13.541]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:13.541]         }
[10:21:13.541]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:13.541]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:13.541]             base::sink(type = "output", split = FALSE)
[10:21:13.541]             base::close(...future.stdout)
[10:21:13.541]         }, add = TRUE)
[10:21:13.541]     }
[10:21:13.541]     ...future.frame <- base::sys.nframe()
[10:21:13.541]     ...future.conditions <- base::list()
[10:21:13.541]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:13.541]     if (FALSE) {
[10:21:13.541]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:13.541]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:13.541]     }
[10:21:13.541]     ...future.result <- base::tryCatch({
[10:21:13.541]         base::withCallingHandlers({
[10:21:13.541]             ...future.value <- base::withVisible(base::local({
[10:21:13.541]                 ...future.makeSendCondition <- base::local({
[10:21:13.541]                   sendCondition <- NULL
[10:21:13.541]                   function(frame = 1L) {
[10:21:13.541]                     if (is.function(sendCondition)) 
[10:21:13.541]                       return(sendCondition)
[10:21:13.541]                     ns <- getNamespace("parallel")
[10:21:13.541]                     if (exists("sendData", mode = "function", 
[10:21:13.541]                       envir = ns)) {
[10:21:13.541]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:13.541]                         envir = ns)
[10:21:13.541]                       envir <- sys.frame(frame)
[10:21:13.541]                       master <- NULL
[10:21:13.541]                       while (!identical(envir, .GlobalEnv) && 
[10:21:13.541]                         !identical(envir, emptyenv())) {
[10:21:13.541]                         if (exists("master", mode = "list", envir = envir, 
[10:21:13.541]                           inherits = FALSE)) {
[10:21:13.541]                           master <- get("master", mode = "list", 
[10:21:13.541]                             envir = envir, inherits = FALSE)
[10:21:13.541]                           if (inherits(master, c("SOCKnode", 
[10:21:13.541]                             "SOCK0node"))) {
[10:21:13.541]                             sendCondition <<- function(cond) {
[10:21:13.541]                               data <- list(type = "VALUE", value = cond, 
[10:21:13.541]                                 success = TRUE)
[10:21:13.541]                               parallel_sendData(master, data)
[10:21:13.541]                             }
[10:21:13.541]                             return(sendCondition)
[10:21:13.541]                           }
[10:21:13.541]                         }
[10:21:13.541]                         frame <- frame + 1L
[10:21:13.541]                         envir <- sys.frame(frame)
[10:21:13.541]                       }
[10:21:13.541]                     }
[10:21:13.541]                     sendCondition <<- function(cond) NULL
[10:21:13.541]                   }
[10:21:13.541]                 })
[10:21:13.541]                 withCallingHandlers({
[10:21:13.541]                   {
[10:21:13.541]                     4
[10:21:13.541]                   }
[10:21:13.541]                 }, immediateCondition = function(cond) {
[10:21:13.541]                   sendCondition <- ...future.makeSendCondition()
[10:21:13.541]                   sendCondition(cond)
[10:21:13.541]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.541]                   {
[10:21:13.541]                     inherits <- base::inherits
[10:21:13.541]                     invokeRestart <- base::invokeRestart
[10:21:13.541]                     is.null <- base::is.null
[10:21:13.541]                     muffled <- FALSE
[10:21:13.541]                     if (inherits(cond, "message")) {
[10:21:13.541]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:13.541]                       if (muffled) 
[10:21:13.541]                         invokeRestart("muffleMessage")
[10:21:13.541]                     }
[10:21:13.541]                     else if (inherits(cond, "warning")) {
[10:21:13.541]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:13.541]                       if (muffled) 
[10:21:13.541]                         invokeRestart("muffleWarning")
[10:21:13.541]                     }
[10:21:13.541]                     else if (inherits(cond, "condition")) {
[10:21:13.541]                       if (!is.null(pattern)) {
[10:21:13.541]                         computeRestarts <- base::computeRestarts
[10:21:13.541]                         grepl <- base::grepl
[10:21:13.541]                         restarts <- computeRestarts(cond)
[10:21:13.541]                         for (restart in restarts) {
[10:21:13.541]                           name <- restart$name
[10:21:13.541]                           if (is.null(name)) 
[10:21:13.541]                             next
[10:21:13.541]                           if (!grepl(pattern, name)) 
[10:21:13.541]                             next
[10:21:13.541]                           invokeRestart(restart)
[10:21:13.541]                           muffled <- TRUE
[10:21:13.541]                           break
[10:21:13.541]                         }
[10:21:13.541]                       }
[10:21:13.541]                     }
[10:21:13.541]                     invisible(muffled)
[10:21:13.541]                   }
[10:21:13.541]                   muffleCondition(cond)
[10:21:13.541]                 })
[10:21:13.541]             }))
[10:21:13.541]             future::FutureResult(value = ...future.value$value, 
[10:21:13.541]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:13.541]                   ...future.rng), globalenv = if (FALSE) 
[10:21:13.541]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:13.541]                     ...future.globalenv.names))
[10:21:13.541]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:13.541]         }, condition = base::local({
[10:21:13.541]             c <- base::c
[10:21:13.541]             inherits <- base::inherits
[10:21:13.541]             invokeRestart <- base::invokeRestart
[10:21:13.541]             length <- base::length
[10:21:13.541]             list <- base::list
[10:21:13.541]             seq.int <- base::seq.int
[10:21:13.541]             signalCondition <- base::signalCondition
[10:21:13.541]             sys.calls <- base::sys.calls
[10:21:13.541]             `[[` <- base::`[[`
[10:21:13.541]             `+` <- base::`+`
[10:21:13.541]             `<<-` <- base::`<<-`
[10:21:13.541]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:13.541]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:13.541]                   3L)]
[10:21:13.541]             }
[10:21:13.541]             function(cond) {
[10:21:13.541]                 is_error <- inherits(cond, "error")
[10:21:13.541]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:13.541]                   NULL)
[10:21:13.541]                 if (is_error) {
[10:21:13.541]                   sessionInformation <- function() {
[10:21:13.541]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:13.541]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:13.541]                       search = base::search(), system = base::Sys.info())
[10:21:13.541]                   }
[10:21:13.541]                   ...future.conditions[[length(...future.conditions) + 
[10:21:13.541]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:13.541]                     cond$call), session = sessionInformation(), 
[10:21:13.541]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:13.541]                   signalCondition(cond)
[10:21:13.541]                 }
[10:21:13.541]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:13.541]                 "immediateCondition"))) {
[10:21:13.541]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:13.541]                   ...future.conditions[[length(...future.conditions) + 
[10:21:13.541]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:13.541]                   if (TRUE && !signal) {
[10:21:13.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.541]                     {
[10:21:13.541]                       inherits <- base::inherits
[10:21:13.541]                       invokeRestart <- base::invokeRestart
[10:21:13.541]                       is.null <- base::is.null
[10:21:13.541]                       muffled <- FALSE
[10:21:13.541]                       if (inherits(cond, "message")) {
[10:21:13.541]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:13.541]                         if (muffled) 
[10:21:13.541]                           invokeRestart("muffleMessage")
[10:21:13.541]                       }
[10:21:13.541]                       else if (inherits(cond, "warning")) {
[10:21:13.541]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:13.541]                         if (muffled) 
[10:21:13.541]                           invokeRestart("muffleWarning")
[10:21:13.541]                       }
[10:21:13.541]                       else if (inherits(cond, "condition")) {
[10:21:13.541]                         if (!is.null(pattern)) {
[10:21:13.541]                           computeRestarts <- base::computeRestarts
[10:21:13.541]                           grepl <- base::grepl
[10:21:13.541]                           restarts <- computeRestarts(cond)
[10:21:13.541]                           for (restart in restarts) {
[10:21:13.541]                             name <- restart$name
[10:21:13.541]                             if (is.null(name)) 
[10:21:13.541]                               next
[10:21:13.541]                             if (!grepl(pattern, name)) 
[10:21:13.541]                               next
[10:21:13.541]                             invokeRestart(restart)
[10:21:13.541]                             muffled <- TRUE
[10:21:13.541]                             break
[10:21:13.541]                           }
[10:21:13.541]                         }
[10:21:13.541]                       }
[10:21:13.541]                       invisible(muffled)
[10:21:13.541]                     }
[10:21:13.541]                     muffleCondition(cond, pattern = "^muffle")
[10:21:13.541]                   }
[10:21:13.541]                 }
[10:21:13.541]                 else {
[10:21:13.541]                   if (TRUE) {
[10:21:13.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.541]                     {
[10:21:13.541]                       inherits <- base::inherits
[10:21:13.541]                       invokeRestart <- base::invokeRestart
[10:21:13.541]                       is.null <- base::is.null
[10:21:13.541]                       muffled <- FALSE
[10:21:13.541]                       if (inherits(cond, "message")) {
[10:21:13.541]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:13.541]                         if (muffled) 
[10:21:13.541]                           invokeRestart("muffleMessage")
[10:21:13.541]                       }
[10:21:13.541]                       else if (inherits(cond, "warning")) {
[10:21:13.541]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:13.541]                         if (muffled) 
[10:21:13.541]                           invokeRestart("muffleWarning")
[10:21:13.541]                       }
[10:21:13.541]                       else if (inherits(cond, "condition")) {
[10:21:13.541]                         if (!is.null(pattern)) {
[10:21:13.541]                           computeRestarts <- base::computeRestarts
[10:21:13.541]                           grepl <- base::grepl
[10:21:13.541]                           restarts <- computeRestarts(cond)
[10:21:13.541]                           for (restart in restarts) {
[10:21:13.541]                             name <- restart$name
[10:21:13.541]                             if (is.null(name)) 
[10:21:13.541]                               next
[10:21:13.541]                             if (!grepl(pattern, name)) 
[10:21:13.541]                               next
[10:21:13.541]                             invokeRestart(restart)
[10:21:13.541]                             muffled <- TRUE
[10:21:13.541]                             break
[10:21:13.541]                           }
[10:21:13.541]                         }
[10:21:13.541]                       }
[10:21:13.541]                       invisible(muffled)
[10:21:13.541]                     }
[10:21:13.541]                     muffleCondition(cond, pattern = "^muffle")
[10:21:13.541]                   }
[10:21:13.541]                 }
[10:21:13.541]             }
[10:21:13.541]         }))
[10:21:13.541]     }, error = function(ex) {
[10:21:13.541]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:13.541]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:13.541]                 ...future.rng), started = ...future.startTime, 
[10:21:13.541]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:13.541]             version = "1.8"), class = "FutureResult")
[10:21:13.541]     }, finally = {
[10:21:13.541]         if (!identical(...future.workdir, getwd())) 
[10:21:13.541]             setwd(...future.workdir)
[10:21:13.541]         {
[10:21:13.541]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:13.541]                 ...future.oldOptions$nwarnings <- NULL
[10:21:13.541]             }
[10:21:13.541]             base::options(...future.oldOptions)
[10:21:13.541]             if (.Platform$OS.type == "windows") {
[10:21:13.541]                 old_names <- names(...future.oldEnvVars)
[10:21:13.541]                 envs <- base::Sys.getenv()
[10:21:13.541]                 names <- names(envs)
[10:21:13.541]                 common <- intersect(names, old_names)
[10:21:13.541]                 added <- setdiff(names, old_names)
[10:21:13.541]                 removed <- setdiff(old_names, names)
[10:21:13.541]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:13.541]                   envs[common]]
[10:21:13.541]                 NAMES <- toupper(changed)
[10:21:13.541]                 args <- list()
[10:21:13.541]                 for (kk in seq_along(NAMES)) {
[10:21:13.541]                   name <- changed[[kk]]
[10:21:13.541]                   NAME <- NAMES[[kk]]
[10:21:13.541]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.541]                     next
[10:21:13.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:13.541]                 }
[10:21:13.541]                 NAMES <- toupper(added)
[10:21:13.541]                 for (kk in seq_along(NAMES)) {
[10:21:13.541]                   name <- added[[kk]]
[10:21:13.541]                   NAME <- NAMES[[kk]]
[10:21:13.541]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.541]                     next
[10:21:13.541]                   args[[name]] <- ""
[10:21:13.541]                 }
[10:21:13.541]                 NAMES <- toupper(removed)
[10:21:13.541]                 for (kk in seq_along(NAMES)) {
[10:21:13.541]                   name <- removed[[kk]]
[10:21:13.541]                   NAME <- NAMES[[kk]]
[10:21:13.541]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.541]                     next
[10:21:13.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:13.541]                 }
[10:21:13.541]                 if (length(args) > 0) 
[10:21:13.541]                   base::do.call(base::Sys.setenv, args = args)
[10:21:13.541]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:13.541]             }
[10:21:13.541]             else {
[10:21:13.541]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:13.541]             }
[10:21:13.541]             {
[10:21:13.541]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:13.541]                   0L) {
[10:21:13.541]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:13.541]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:13.541]                   base::options(opts)
[10:21:13.541]                 }
[10:21:13.541]                 {
[10:21:13.541]                   {
[10:21:13.541]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:13.541]                     NULL
[10:21:13.541]                   }
[10:21:13.541]                   options(future.plan = NULL)
[10:21:13.541]                   if (is.na(NA_character_)) 
[10:21:13.541]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:13.541]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:13.541]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:13.541]                     .init = FALSE)
[10:21:13.541]                 }
[10:21:13.541]             }
[10:21:13.541]         }
[10:21:13.541]     })
[10:21:13.541]     if (TRUE) {
[10:21:13.541]         base::sink(type = "output", split = FALSE)
[10:21:13.541]         if (TRUE) {
[10:21:13.541]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:13.541]         }
[10:21:13.541]         else {
[10:21:13.541]             ...future.result["stdout"] <- base::list(NULL)
[10:21:13.541]         }
[10:21:13.541]         base::close(...future.stdout)
[10:21:13.541]         ...future.stdout <- NULL
[10:21:13.541]     }
[10:21:13.541]     ...future.result$conditions <- ...future.conditions
[10:21:13.541]     ...future.result$finished <- base::Sys.time()
[10:21:13.541]     ...future.result
[10:21:13.541] }
[10:21:13.593] MultisessionFuture started
[10:21:13.593] - Launch lazy future ... done
[10:21:13.593] run() for ‘MultisessionFuture’ ... done
[10:21:13.594] result() for ClusterFuture ...
[10:21:13.594] receiveMessageFromWorker() for ClusterFuture ...
[10:21:13.594] - Validating connection of MultisessionFuture
[10:21:13.594] - received message: FutureResult
[10:21:13.594] - Received FutureResult
[10:21:13.595] - Erased future from FutureRegistry
[10:21:13.595] result() for ClusterFuture ...
[10:21:13.595] - result already collected: FutureResult
[10:21:13.595] result() for ClusterFuture ... done
[10:21:13.595] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:13.595] result() for ClusterFuture ... done
[10:21:13.596] result() for ClusterFuture ...
[10:21:13.596] - result already collected: FutureResult
[10:21:13.596] result() for ClusterFuture ... done
u$a = 2
[10:21:13.596] result() for ClusterFuture ...
[10:21:13.596] receiveMessageFromWorker() for ClusterFuture ...
[10:21:13.597] - Validating connection of MultisessionFuture
[10:21:13.626] - received message: FutureResult
[10:21:13.626] - Received FutureResult
[10:21:13.626] - Erased future from FutureRegistry
[10:21:13.626] result() for ClusterFuture ...
[10:21:13.626] - result already collected: FutureResult
[10:21:13.626] result() for ClusterFuture ... done
[10:21:13.626] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:13.626] result() for ClusterFuture ... done
[10:21:13.627] result() for ClusterFuture ...
[10:21:13.627] - result already collected: FutureResult
[10:21:13.627] result() for ClusterFuture ... done
v$a = 4
[10:21:13.627] getGlobalsAndPackages() ...
[10:21:13.627] Searching for globals...
[10:21:13.628] - globals found: [3] ‘{’, ‘*’, ‘a’
[10:21:13.628] Searching for globals ... DONE
[10:21:13.629] Resolving globals: FALSE
[10:21:13.629] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:13.629] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:13.630] - globals: [1] ‘a’
[10:21:13.630] 
[10:21:13.630] getGlobalsAndPackages() ... DONE
[10:21:13.630] run() for ‘Future’ ...
[10:21:13.630] - state: ‘created’
[10:21:13.630] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:13.645] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:13.645] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:13.645]   - Field: ‘node’
[10:21:13.645]   - Field: ‘label’
[10:21:13.645]   - Field: ‘local’
[10:21:13.645]   - Field: ‘owner’
[10:21:13.645]   - Field: ‘envir’
[10:21:13.646]   - Field: ‘workers’
[10:21:13.646]   - Field: ‘packages’
[10:21:13.646]   - Field: ‘gc’
[10:21:13.646]   - Field: ‘conditions’
[10:21:13.646]   - Field: ‘persistent’
[10:21:13.646]   - Field: ‘expr’
[10:21:13.646]   - Field: ‘uuid’
[10:21:13.646]   - Field: ‘seed’
[10:21:13.646]   - Field: ‘version’
[10:21:13.646]   - Field: ‘result’
[10:21:13.647]   - Field: ‘asynchronous’
[10:21:13.647]   - Field: ‘calls’
[10:21:13.647]   - Field: ‘globals’
[10:21:13.647]   - Field: ‘stdout’
[10:21:13.647]   - Field: ‘earlySignal’
[10:21:13.647]   - Field: ‘lazy’
[10:21:13.647]   - Field: ‘state’
[10:21:13.647] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:13.647] - Launch lazy future ...
[10:21:13.648] Packages needed by the future expression (n = 0): <none>
[10:21:13.648] Packages needed by future strategies (n = 0): <none>
[10:21:13.648] {
[10:21:13.648]     {
[10:21:13.648]         {
[10:21:13.648]             ...future.startTime <- base::Sys.time()
[10:21:13.648]             {
[10:21:13.648]                 {
[10:21:13.648]                   {
[10:21:13.648]                     {
[10:21:13.648]                       base::local({
[10:21:13.648]                         has_future <- base::requireNamespace("future", 
[10:21:13.648]                           quietly = TRUE)
[10:21:13.648]                         if (has_future) {
[10:21:13.648]                           ns <- base::getNamespace("future")
[10:21:13.648]                           version <- ns[[".package"]][["version"]]
[10:21:13.648]                           if (is.null(version)) 
[10:21:13.648]                             version <- utils::packageVersion("future")
[10:21:13.648]                         }
[10:21:13.648]                         else {
[10:21:13.648]                           version <- NULL
[10:21:13.648]                         }
[10:21:13.648]                         if (!has_future || version < "1.8.0") {
[10:21:13.648]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:13.648]                             "", base::R.version$version.string), 
[10:21:13.648]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:13.648]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:13.648]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:13.648]                               "release", "version")], collapse = " "), 
[10:21:13.648]                             hostname = base::Sys.info()[["nodename"]])
[10:21:13.648]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:13.648]                             info)
[10:21:13.648]                           info <- base::paste(info, collapse = "; ")
[10:21:13.648]                           if (!has_future) {
[10:21:13.648]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:13.648]                               info)
[10:21:13.648]                           }
[10:21:13.648]                           else {
[10:21:13.648]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:13.648]                               info, version)
[10:21:13.648]                           }
[10:21:13.648]                           base::stop(msg)
[10:21:13.648]                         }
[10:21:13.648]                       })
[10:21:13.648]                     }
[10:21:13.648]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:13.648]                     base::options(mc.cores = 1L)
[10:21:13.648]                   }
[10:21:13.648]                   ...future.strategy.old <- future::plan("list")
[10:21:13.648]                   options(future.plan = NULL)
[10:21:13.648]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:13.648]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:13.648]                 }
[10:21:13.648]                 ...future.workdir <- getwd()
[10:21:13.648]             }
[10:21:13.648]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:13.648]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:13.648]         }
[10:21:13.648]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:13.648]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:13.648]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:13.648]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:13.648]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:13.648]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:13.648]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:13.648]             base::names(...future.oldOptions))
[10:21:13.648]     }
[10:21:13.648]     if (FALSE) {
[10:21:13.648]     }
[10:21:13.648]     else {
[10:21:13.648]         if (TRUE) {
[10:21:13.648]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:13.648]                 open = "w")
[10:21:13.648]         }
[10:21:13.648]         else {
[10:21:13.648]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:13.648]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:13.648]         }
[10:21:13.648]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:13.648]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:13.648]             base::sink(type = "output", split = FALSE)
[10:21:13.648]             base::close(...future.stdout)
[10:21:13.648]         }, add = TRUE)
[10:21:13.648]     }
[10:21:13.648]     ...future.frame <- base::sys.nframe()
[10:21:13.648]     ...future.conditions <- base::list()
[10:21:13.648]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:13.648]     if (FALSE) {
[10:21:13.648]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:13.648]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:13.648]     }
[10:21:13.648]     ...future.result <- base::tryCatch({
[10:21:13.648]         base::withCallingHandlers({
[10:21:13.648]             ...future.value <- base::withVisible(base::local({
[10:21:13.648]                 ...future.makeSendCondition <- base::local({
[10:21:13.648]                   sendCondition <- NULL
[10:21:13.648]                   function(frame = 1L) {
[10:21:13.648]                     if (is.function(sendCondition)) 
[10:21:13.648]                       return(sendCondition)
[10:21:13.648]                     ns <- getNamespace("parallel")
[10:21:13.648]                     if (exists("sendData", mode = "function", 
[10:21:13.648]                       envir = ns)) {
[10:21:13.648]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:13.648]                         envir = ns)
[10:21:13.648]                       envir <- sys.frame(frame)
[10:21:13.648]                       master <- NULL
[10:21:13.648]                       while (!identical(envir, .GlobalEnv) && 
[10:21:13.648]                         !identical(envir, emptyenv())) {
[10:21:13.648]                         if (exists("master", mode = "list", envir = envir, 
[10:21:13.648]                           inherits = FALSE)) {
[10:21:13.648]                           master <- get("master", mode = "list", 
[10:21:13.648]                             envir = envir, inherits = FALSE)
[10:21:13.648]                           if (inherits(master, c("SOCKnode", 
[10:21:13.648]                             "SOCK0node"))) {
[10:21:13.648]                             sendCondition <<- function(cond) {
[10:21:13.648]                               data <- list(type = "VALUE", value = cond, 
[10:21:13.648]                                 success = TRUE)
[10:21:13.648]                               parallel_sendData(master, data)
[10:21:13.648]                             }
[10:21:13.648]                             return(sendCondition)
[10:21:13.648]                           }
[10:21:13.648]                         }
[10:21:13.648]                         frame <- frame + 1L
[10:21:13.648]                         envir <- sys.frame(frame)
[10:21:13.648]                       }
[10:21:13.648]                     }
[10:21:13.648]                     sendCondition <<- function(cond) NULL
[10:21:13.648]                   }
[10:21:13.648]                 })
[10:21:13.648]                 withCallingHandlers({
[10:21:13.648]                   {
[10:21:13.648]                     2 * a
[10:21:13.648]                   }
[10:21:13.648]                 }, immediateCondition = function(cond) {
[10:21:13.648]                   sendCondition <- ...future.makeSendCondition()
[10:21:13.648]                   sendCondition(cond)
[10:21:13.648]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.648]                   {
[10:21:13.648]                     inherits <- base::inherits
[10:21:13.648]                     invokeRestart <- base::invokeRestart
[10:21:13.648]                     is.null <- base::is.null
[10:21:13.648]                     muffled <- FALSE
[10:21:13.648]                     if (inherits(cond, "message")) {
[10:21:13.648]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:13.648]                       if (muffled) 
[10:21:13.648]                         invokeRestart("muffleMessage")
[10:21:13.648]                     }
[10:21:13.648]                     else if (inherits(cond, "warning")) {
[10:21:13.648]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:13.648]                       if (muffled) 
[10:21:13.648]                         invokeRestart("muffleWarning")
[10:21:13.648]                     }
[10:21:13.648]                     else if (inherits(cond, "condition")) {
[10:21:13.648]                       if (!is.null(pattern)) {
[10:21:13.648]                         computeRestarts <- base::computeRestarts
[10:21:13.648]                         grepl <- base::grepl
[10:21:13.648]                         restarts <- computeRestarts(cond)
[10:21:13.648]                         for (restart in restarts) {
[10:21:13.648]                           name <- restart$name
[10:21:13.648]                           if (is.null(name)) 
[10:21:13.648]                             next
[10:21:13.648]                           if (!grepl(pattern, name)) 
[10:21:13.648]                             next
[10:21:13.648]                           invokeRestart(restart)
[10:21:13.648]                           muffled <- TRUE
[10:21:13.648]                           break
[10:21:13.648]                         }
[10:21:13.648]                       }
[10:21:13.648]                     }
[10:21:13.648]                     invisible(muffled)
[10:21:13.648]                   }
[10:21:13.648]                   muffleCondition(cond)
[10:21:13.648]                 })
[10:21:13.648]             }))
[10:21:13.648]             future::FutureResult(value = ...future.value$value, 
[10:21:13.648]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:13.648]                   ...future.rng), globalenv = if (FALSE) 
[10:21:13.648]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:13.648]                     ...future.globalenv.names))
[10:21:13.648]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:13.648]         }, condition = base::local({
[10:21:13.648]             c <- base::c
[10:21:13.648]             inherits <- base::inherits
[10:21:13.648]             invokeRestart <- base::invokeRestart
[10:21:13.648]             length <- base::length
[10:21:13.648]             list <- base::list
[10:21:13.648]             seq.int <- base::seq.int
[10:21:13.648]             signalCondition <- base::signalCondition
[10:21:13.648]             sys.calls <- base::sys.calls
[10:21:13.648]             `[[` <- base::`[[`
[10:21:13.648]             `+` <- base::`+`
[10:21:13.648]             `<<-` <- base::`<<-`
[10:21:13.648]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:13.648]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:13.648]                   3L)]
[10:21:13.648]             }
[10:21:13.648]             function(cond) {
[10:21:13.648]                 is_error <- inherits(cond, "error")
[10:21:13.648]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:13.648]                   NULL)
[10:21:13.648]                 if (is_error) {
[10:21:13.648]                   sessionInformation <- function() {
[10:21:13.648]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:13.648]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:13.648]                       search = base::search(), system = base::Sys.info())
[10:21:13.648]                   }
[10:21:13.648]                   ...future.conditions[[length(...future.conditions) + 
[10:21:13.648]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:13.648]                     cond$call), session = sessionInformation(), 
[10:21:13.648]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:13.648]                   signalCondition(cond)
[10:21:13.648]                 }
[10:21:13.648]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:13.648]                 "immediateCondition"))) {
[10:21:13.648]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:13.648]                   ...future.conditions[[length(...future.conditions) + 
[10:21:13.648]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:13.648]                   if (TRUE && !signal) {
[10:21:13.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.648]                     {
[10:21:13.648]                       inherits <- base::inherits
[10:21:13.648]                       invokeRestart <- base::invokeRestart
[10:21:13.648]                       is.null <- base::is.null
[10:21:13.648]                       muffled <- FALSE
[10:21:13.648]                       if (inherits(cond, "message")) {
[10:21:13.648]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:13.648]                         if (muffled) 
[10:21:13.648]                           invokeRestart("muffleMessage")
[10:21:13.648]                       }
[10:21:13.648]                       else if (inherits(cond, "warning")) {
[10:21:13.648]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:13.648]                         if (muffled) 
[10:21:13.648]                           invokeRestart("muffleWarning")
[10:21:13.648]                       }
[10:21:13.648]                       else if (inherits(cond, "condition")) {
[10:21:13.648]                         if (!is.null(pattern)) {
[10:21:13.648]                           computeRestarts <- base::computeRestarts
[10:21:13.648]                           grepl <- base::grepl
[10:21:13.648]                           restarts <- computeRestarts(cond)
[10:21:13.648]                           for (restart in restarts) {
[10:21:13.648]                             name <- restart$name
[10:21:13.648]                             if (is.null(name)) 
[10:21:13.648]                               next
[10:21:13.648]                             if (!grepl(pattern, name)) 
[10:21:13.648]                               next
[10:21:13.648]                             invokeRestart(restart)
[10:21:13.648]                             muffled <- TRUE
[10:21:13.648]                             break
[10:21:13.648]                           }
[10:21:13.648]                         }
[10:21:13.648]                       }
[10:21:13.648]                       invisible(muffled)
[10:21:13.648]                     }
[10:21:13.648]                     muffleCondition(cond, pattern = "^muffle")
[10:21:13.648]                   }
[10:21:13.648]                 }
[10:21:13.648]                 else {
[10:21:13.648]                   if (TRUE) {
[10:21:13.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.648]                     {
[10:21:13.648]                       inherits <- base::inherits
[10:21:13.648]                       invokeRestart <- base::invokeRestart
[10:21:13.648]                       is.null <- base::is.null
[10:21:13.648]                       muffled <- FALSE
[10:21:13.648]                       if (inherits(cond, "message")) {
[10:21:13.648]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:13.648]                         if (muffled) 
[10:21:13.648]                           invokeRestart("muffleMessage")
[10:21:13.648]                       }
[10:21:13.648]                       else if (inherits(cond, "warning")) {
[10:21:13.648]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:13.648]                         if (muffled) 
[10:21:13.648]                           invokeRestart("muffleWarning")
[10:21:13.648]                       }
[10:21:13.648]                       else if (inherits(cond, "condition")) {
[10:21:13.648]                         if (!is.null(pattern)) {
[10:21:13.648]                           computeRestarts <- base::computeRestarts
[10:21:13.648]                           grepl <- base::grepl
[10:21:13.648]                           restarts <- computeRestarts(cond)
[10:21:13.648]                           for (restart in restarts) {
[10:21:13.648]                             name <- restart$name
[10:21:13.648]                             if (is.null(name)) 
[10:21:13.648]                               next
[10:21:13.648]                             if (!grepl(pattern, name)) 
[10:21:13.648]                               next
[10:21:13.648]                             invokeRestart(restart)
[10:21:13.648]                             muffled <- TRUE
[10:21:13.648]                             break
[10:21:13.648]                           }
[10:21:13.648]                         }
[10:21:13.648]                       }
[10:21:13.648]                       invisible(muffled)
[10:21:13.648]                     }
[10:21:13.648]                     muffleCondition(cond, pattern = "^muffle")
[10:21:13.648]                   }
[10:21:13.648]                 }
[10:21:13.648]             }
[10:21:13.648]         }))
[10:21:13.648]     }, error = function(ex) {
[10:21:13.648]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:13.648]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:13.648]                 ...future.rng), started = ...future.startTime, 
[10:21:13.648]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:13.648]             version = "1.8"), class = "FutureResult")
[10:21:13.648]     }, finally = {
[10:21:13.648]         if (!identical(...future.workdir, getwd())) 
[10:21:13.648]             setwd(...future.workdir)
[10:21:13.648]         {
[10:21:13.648]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:13.648]                 ...future.oldOptions$nwarnings <- NULL
[10:21:13.648]             }
[10:21:13.648]             base::options(...future.oldOptions)
[10:21:13.648]             if (.Platform$OS.type == "windows") {
[10:21:13.648]                 old_names <- names(...future.oldEnvVars)
[10:21:13.648]                 envs <- base::Sys.getenv()
[10:21:13.648]                 names <- names(envs)
[10:21:13.648]                 common <- intersect(names, old_names)
[10:21:13.648]                 added <- setdiff(names, old_names)
[10:21:13.648]                 removed <- setdiff(old_names, names)
[10:21:13.648]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:13.648]                   envs[common]]
[10:21:13.648]                 NAMES <- toupper(changed)
[10:21:13.648]                 args <- list()
[10:21:13.648]                 for (kk in seq_along(NAMES)) {
[10:21:13.648]                   name <- changed[[kk]]
[10:21:13.648]                   NAME <- NAMES[[kk]]
[10:21:13.648]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.648]                     next
[10:21:13.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:13.648]                 }
[10:21:13.648]                 NAMES <- toupper(added)
[10:21:13.648]                 for (kk in seq_along(NAMES)) {
[10:21:13.648]                   name <- added[[kk]]
[10:21:13.648]                   NAME <- NAMES[[kk]]
[10:21:13.648]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.648]                     next
[10:21:13.648]                   args[[name]] <- ""
[10:21:13.648]                 }
[10:21:13.648]                 NAMES <- toupper(removed)
[10:21:13.648]                 for (kk in seq_along(NAMES)) {
[10:21:13.648]                   name <- removed[[kk]]
[10:21:13.648]                   NAME <- NAMES[[kk]]
[10:21:13.648]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.648]                     next
[10:21:13.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:13.648]                 }
[10:21:13.648]                 if (length(args) > 0) 
[10:21:13.648]                   base::do.call(base::Sys.setenv, args = args)
[10:21:13.648]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:13.648]             }
[10:21:13.648]             else {
[10:21:13.648]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:13.648]             }
[10:21:13.648]             {
[10:21:13.648]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:13.648]                   0L) {
[10:21:13.648]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:13.648]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:13.648]                   base::options(opts)
[10:21:13.648]                 }
[10:21:13.648]                 {
[10:21:13.648]                   {
[10:21:13.648]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:13.648]                     NULL
[10:21:13.648]                   }
[10:21:13.648]                   options(future.plan = NULL)
[10:21:13.648]                   if (is.na(NA_character_)) 
[10:21:13.648]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:13.648]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:13.648]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:13.648]                     .init = FALSE)
[10:21:13.648]                 }
[10:21:13.648]             }
[10:21:13.648]         }
[10:21:13.648]     })
[10:21:13.648]     if (TRUE) {
[10:21:13.648]         base::sink(type = "output", split = FALSE)
[10:21:13.648]         if (TRUE) {
[10:21:13.648]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:13.648]         }
[10:21:13.648]         else {
[10:21:13.648]             ...future.result["stdout"] <- base::list(NULL)
[10:21:13.648]         }
[10:21:13.648]         base::close(...future.stdout)
[10:21:13.648]         ...future.stdout <- NULL
[10:21:13.648]     }
[10:21:13.648]     ...future.result$conditions <- ...future.conditions
[10:21:13.648]     ...future.result$finished <- base::Sys.time()
[10:21:13.648]     ...future.result
[10:21:13.648] }
[10:21:13.651] Exporting 1 global objects (346 bytes) to cluster node #1 ...
[10:21:13.652] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[10:21:13.655] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[10:21:13.656] Exporting 1 global objects (346 bytes) to cluster node #1 ... DONE
[10:21:13.656] MultisessionFuture started
[10:21:13.656] - Launch lazy future ... done
[10:21:13.656] run() for ‘MultisessionFuture’ ... done
[10:21:13.657] result() for ClusterFuture ...
[10:21:13.657] receiveMessageFromWorker() for ClusterFuture ...
[10:21:13.657] - Validating connection of MultisessionFuture
[10:21:13.698] - received message: FutureResult
[10:21:13.698] - Received FutureResult
[10:21:13.698] - Erased future from FutureRegistry
[10:21:13.698] result() for ClusterFuture ...
[10:21:13.698] - result already collected: FutureResult
[10:21:13.698] result() for ClusterFuture ... done
[10:21:13.699] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:13.699] result() for ClusterFuture ... done
[10:21:13.699] result() for ClusterFuture ...
[10:21:13.699] - result already collected: FutureResult
[10:21:13.699] result() for ClusterFuture ... done
[10:21:13.699] getGlobalsAndPackages() ...
[10:21:13.699] Searching for globals...
[10:21:13.700] - globals found: [3] ‘{’, ‘*’, ‘a’
[10:21:13.700] Searching for globals ... DONE
[10:21:13.701] Resolving globals: FALSE
[10:21:13.701] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:13.701] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:13.702] - globals: [1] ‘a’
[10:21:13.702] 
[10:21:13.702] getGlobalsAndPackages() ... DONE
[10:21:13.702] run() for ‘Future’ ...
[10:21:13.702] - state: ‘created’
[10:21:13.702] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:13.717] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:13.717] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:13.717]   - Field: ‘node’
[10:21:13.717]   - Field: ‘label’
[10:21:13.717]   - Field: ‘local’
[10:21:13.717]   - Field: ‘owner’
[10:21:13.717]   - Field: ‘envir’
[10:21:13.717]   - Field: ‘workers’
[10:21:13.718]   - Field: ‘packages’
[10:21:13.718]   - Field: ‘gc’
[10:21:13.718]   - Field: ‘conditions’
[10:21:13.718]   - Field: ‘persistent’
[10:21:13.718]   - Field: ‘expr’
[10:21:13.718]   - Field: ‘uuid’
[10:21:13.718]   - Field: ‘seed’
[10:21:13.718]   - Field: ‘version’
[10:21:13.718]   - Field: ‘result’
[10:21:13.719]   - Field: ‘asynchronous’
[10:21:13.719]   - Field: ‘calls’
[10:21:13.719]   - Field: ‘globals’
[10:21:13.719]   - Field: ‘stdout’
[10:21:13.719]   - Field: ‘earlySignal’
[10:21:13.719]   - Field: ‘lazy’
[10:21:13.719]   - Field: ‘state’
[10:21:13.719] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:13.719] - Launch lazy future ...
[10:21:13.720] Packages needed by the future expression (n = 0): <none>
[10:21:13.720] Packages needed by future strategies (n = 0): <none>
[10:21:13.720] {
[10:21:13.720]     {
[10:21:13.720]         {
[10:21:13.720]             ...future.startTime <- base::Sys.time()
[10:21:13.720]             {
[10:21:13.720]                 {
[10:21:13.720]                   {
[10:21:13.720]                     {
[10:21:13.720]                       base::local({
[10:21:13.720]                         has_future <- base::requireNamespace("future", 
[10:21:13.720]                           quietly = TRUE)
[10:21:13.720]                         if (has_future) {
[10:21:13.720]                           ns <- base::getNamespace("future")
[10:21:13.720]                           version <- ns[[".package"]][["version"]]
[10:21:13.720]                           if (is.null(version)) 
[10:21:13.720]                             version <- utils::packageVersion("future")
[10:21:13.720]                         }
[10:21:13.720]                         else {
[10:21:13.720]                           version <- NULL
[10:21:13.720]                         }
[10:21:13.720]                         if (!has_future || version < "1.8.0") {
[10:21:13.720]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:13.720]                             "", base::R.version$version.string), 
[10:21:13.720]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:13.720]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:13.720]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:13.720]                               "release", "version")], collapse = " "), 
[10:21:13.720]                             hostname = base::Sys.info()[["nodename"]])
[10:21:13.720]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:13.720]                             info)
[10:21:13.720]                           info <- base::paste(info, collapse = "; ")
[10:21:13.720]                           if (!has_future) {
[10:21:13.720]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:13.720]                               info)
[10:21:13.720]                           }
[10:21:13.720]                           else {
[10:21:13.720]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:13.720]                               info, version)
[10:21:13.720]                           }
[10:21:13.720]                           base::stop(msg)
[10:21:13.720]                         }
[10:21:13.720]                       })
[10:21:13.720]                     }
[10:21:13.720]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:13.720]                     base::options(mc.cores = 1L)
[10:21:13.720]                   }
[10:21:13.720]                   ...future.strategy.old <- future::plan("list")
[10:21:13.720]                   options(future.plan = NULL)
[10:21:13.720]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:13.720]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:13.720]                 }
[10:21:13.720]                 ...future.workdir <- getwd()
[10:21:13.720]             }
[10:21:13.720]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:13.720]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:13.720]         }
[10:21:13.720]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:13.720]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:13.720]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:13.720]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:13.720]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:13.720]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:13.720]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:13.720]             base::names(...future.oldOptions))
[10:21:13.720]     }
[10:21:13.720]     if (FALSE) {
[10:21:13.720]     }
[10:21:13.720]     else {
[10:21:13.720]         if (TRUE) {
[10:21:13.720]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:13.720]                 open = "w")
[10:21:13.720]         }
[10:21:13.720]         else {
[10:21:13.720]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:13.720]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:13.720]         }
[10:21:13.720]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:13.720]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:13.720]             base::sink(type = "output", split = FALSE)
[10:21:13.720]             base::close(...future.stdout)
[10:21:13.720]         }, add = TRUE)
[10:21:13.720]     }
[10:21:13.720]     ...future.frame <- base::sys.nframe()
[10:21:13.720]     ...future.conditions <- base::list()
[10:21:13.720]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:13.720]     if (FALSE) {
[10:21:13.720]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:13.720]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:13.720]     }
[10:21:13.720]     ...future.result <- base::tryCatch({
[10:21:13.720]         base::withCallingHandlers({
[10:21:13.720]             ...future.value <- base::withVisible(base::local({
[10:21:13.720]                 ...future.makeSendCondition <- base::local({
[10:21:13.720]                   sendCondition <- NULL
[10:21:13.720]                   function(frame = 1L) {
[10:21:13.720]                     if (is.function(sendCondition)) 
[10:21:13.720]                       return(sendCondition)
[10:21:13.720]                     ns <- getNamespace("parallel")
[10:21:13.720]                     if (exists("sendData", mode = "function", 
[10:21:13.720]                       envir = ns)) {
[10:21:13.720]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:13.720]                         envir = ns)
[10:21:13.720]                       envir <- sys.frame(frame)
[10:21:13.720]                       master <- NULL
[10:21:13.720]                       while (!identical(envir, .GlobalEnv) && 
[10:21:13.720]                         !identical(envir, emptyenv())) {
[10:21:13.720]                         if (exists("master", mode = "list", envir = envir, 
[10:21:13.720]                           inherits = FALSE)) {
[10:21:13.720]                           master <- get("master", mode = "list", 
[10:21:13.720]                             envir = envir, inherits = FALSE)
[10:21:13.720]                           if (inherits(master, c("SOCKnode", 
[10:21:13.720]                             "SOCK0node"))) {
[10:21:13.720]                             sendCondition <<- function(cond) {
[10:21:13.720]                               data <- list(type = "VALUE", value = cond, 
[10:21:13.720]                                 success = TRUE)
[10:21:13.720]                               parallel_sendData(master, data)
[10:21:13.720]                             }
[10:21:13.720]                             return(sendCondition)
[10:21:13.720]                           }
[10:21:13.720]                         }
[10:21:13.720]                         frame <- frame + 1L
[10:21:13.720]                         envir <- sys.frame(frame)
[10:21:13.720]                       }
[10:21:13.720]                     }
[10:21:13.720]                     sendCondition <<- function(cond) NULL
[10:21:13.720]                   }
[10:21:13.720]                 })
[10:21:13.720]                 withCallingHandlers({
[10:21:13.720]                   {
[10:21:13.720]                     2 * a
[10:21:13.720]                   }
[10:21:13.720]                 }, immediateCondition = function(cond) {
[10:21:13.720]                   sendCondition <- ...future.makeSendCondition()
[10:21:13.720]                   sendCondition(cond)
[10:21:13.720]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.720]                   {
[10:21:13.720]                     inherits <- base::inherits
[10:21:13.720]                     invokeRestart <- base::invokeRestart
[10:21:13.720]                     is.null <- base::is.null
[10:21:13.720]                     muffled <- FALSE
[10:21:13.720]                     if (inherits(cond, "message")) {
[10:21:13.720]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:13.720]                       if (muffled) 
[10:21:13.720]                         invokeRestart("muffleMessage")
[10:21:13.720]                     }
[10:21:13.720]                     else if (inherits(cond, "warning")) {
[10:21:13.720]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:13.720]                       if (muffled) 
[10:21:13.720]                         invokeRestart("muffleWarning")
[10:21:13.720]                     }
[10:21:13.720]                     else if (inherits(cond, "condition")) {
[10:21:13.720]                       if (!is.null(pattern)) {
[10:21:13.720]                         computeRestarts <- base::computeRestarts
[10:21:13.720]                         grepl <- base::grepl
[10:21:13.720]                         restarts <- computeRestarts(cond)
[10:21:13.720]                         for (restart in restarts) {
[10:21:13.720]                           name <- restart$name
[10:21:13.720]                           if (is.null(name)) 
[10:21:13.720]                             next
[10:21:13.720]                           if (!grepl(pattern, name)) 
[10:21:13.720]                             next
[10:21:13.720]                           invokeRestart(restart)
[10:21:13.720]                           muffled <- TRUE
[10:21:13.720]                           break
[10:21:13.720]                         }
[10:21:13.720]                       }
[10:21:13.720]                     }
[10:21:13.720]                     invisible(muffled)
[10:21:13.720]                   }
[10:21:13.720]                   muffleCondition(cond)
[10:21:13.720]                 })
[10:21:13.720]             }))
[10:21:13.720]             future::FutureResult(value = ...future.value$value, 
[10:21:13.720]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:13.720]                   ...future.rng), globalenv = if (FALSE) 
[10:21:13.720]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:13.720]                     ...future.globalenv.names))
[10:21:13.720]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:13.720]         }, condition = base::local({
[10:21:13.720]             c <- base::c
[10:21:13.720]             inherits <- base::inherits
[10:21:13.720]             invokeRestart <- base::invokeRestart
[10:21:13.720]             length <- base::length
[10:21:13.720]             list <- base::list
[10:21:13.720]             seq.int <- base::seq.int
[10:21:13.720]             signalCondition <- base::signalCondition
[10:21:13.720]             sys.calls <- base::sys.calls
[10:21:13.720]             `[[` <- base::`[[`
[10:21:13.720]             `+` <- base::`+`
[10:21:13.720]             `<<-` <- base::`<<-`
[10:21:13.720]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:13.720]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:13.720]                   3L)]
[10:21:13.720]             }
[10:21:13.720]             function(cond) {
[10:21:13.720]                 is_error <- inherits(cond, "error")
[10:21:13.720]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:13.720]                   NULL)
[10:21:13.720]                 if (is_error) {
[10:21:13.720]                   sessionInformation <- function() {
[10:21:13.720]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:13.720]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:13.720]                       search = base::search(), system = base::Sys.info())
[10:21:13.720]                   }
[10:21:13.720]                   ...future.conditions[[length(...future.conditions) + 
[10:21:13.720]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:13.720]                     cond$call), session = sessionInformation(), 
[10:21:13.720]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:13.720]                   signalCondition(cond)
[10:21:13.720]                 }
[10:21:13.720]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:13.720]                 "immediateCondition"))) {
[10:21:13.720]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:13.720]                   ...future.conditions[[length(...future.conditions) + 
[10:21:13.720]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:13.720]                   if (TRUE && !signal) {
[10:21:13.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.720]                     {
[10:21:13.720]                       inherits <- base::inherits
[10:21:13.720]                       invokeRestart <- base::invokeRestart
[10:21:13.720]                       is.null <- base::is.null
[10:21:13.720]                       muffled <- FALSE
[10:21:13.720]                       if (inherits(cond, "message")) {
[10:21:13.720]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:13.720]                         if (muffled) 
[10:21:13.720]                           invokeRestart("muffleMessage")
[10:21:13.720]                       }
[10:21:13.720]                       else if (inherits(cond, "warning")) {
[10:21:13.720]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:13.720]                         if (muffled) 
[10:21:13.720]                           invokeRestart("muffleWarning")
[10:21:13.720]                       }
[10:21:13.720]                       else if (inherits(cond, "condition")) {
[10:21:13.720]                         if (!is.null(pattern)) {
[10:21:13.720]                           computeRestarts <- base::computeRestarts
[10:21:13.720]                           grepl <- base::grepl
[10:21:13.720]                           restarts <- computeRestarts(cond)
[10:21:13.720]                           for (restart in restarts) {
[10:21:13.720]                             name <- restart$name
[10:21:13.720]                             if (is.null(name)) 
[10:21:13.720]                               next
[10:21:13.720]                             if (!grepl(pattern, name)) 
[10:21:13.720]                               next
[10:21:13.720]                             invokeRestart(restart)
[10:21:13.720]                             muffled <- TRUE
[10:21:13.720]                             break
[10:21:13.720]                           }
[10:21:13.720]                         }
[10:21:13.720]                       }
[10:21:13.720]                       invisible(muffled)
[10:21:13.720]                     }
[10:21:13.720]                     muffleCondition(cond, pattern = "^muffle")
[10:21:13.720]                   }
[10:21:13.720]                 }
[10:21:13.720]                 else {
[10:21:13.720]                   if (TRUE) {
[10:21:13.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.720]                     {
[10:21:13.720]                       inherits <- base::inherits
[10:21:13.720]                       invokeRestart <- base::invokeRestart
[10:21:13.720]                       is.null <- base::is.null
[10:21:13.720]                       muffled <- FALSE
[10:21:13.720]                       if (inherits(cond, "message")) {
[10:21:13.720]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:13.720]                         if (muffled) 
[10:21:13.720]                           invokeRestart("muffleMessage")
[10:21:13.720]                       }
[10:21:13.720]                       else if (inherits(cond, "warning")) {
[10:21:13.720]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:13.720]                         if (muffled) 
[10:21:13.720]                           invokeRestart("muffleWarning")
[10:21:13.720]                       }
[10:21:13.720]                       else if (inherits(cond, "condition")) {
[10:21:13.720]                         if (!is.null(pattern)) {
[10:21:13.720]                           computeRestarts <- base::computeRestarts
[10:21:13.720]                           grepl <- base::grepl
[10:21:13.720]                           restarts <- computeRestarts(cond)
[10:21:13.720]                           for (restart in restarts) {
[10:21:13.720]                             name <- restart$name
[10:21:13.720]                             if (is.null(name)) 
[10:21:13.720]                               next
[10:21:13.720]                             if (!grepl(pattern, name)) 
[10:21:13.720]                               next
[10:21:13.720]                             invokeRestart(restart)
[10:21:13.720]                             muffled <- TRUE
[10:21:13.720]                             break
[10:21:13.720]                           }
[10:21:13.720]                         }
[10:21:13.720]                       }
[10:21:13.720]                       invisible(muffled)
[10:21:13.720]                     }
[10:21:13.720]                     muffleCondition(cond, pattern = "^muffle")
[10:21:13.720]                   }
[10:21:13.720]                 }
[10:21:13.720]             }
[10:21:13.720]         }))
[10:21:13.720]     }, error = function(ex) {
[10:21:13.720]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:13.720]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:13.720]                 ...future.rng), started = ...future.startTime, 
[10:21:13.720]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:13.720]             version = "1.8"), class = "FutureResult")
[10:21:13.720]     }, finally = {
[10:21:13.720]         if (!identical(...future.workdir, getwd())) 
[10:21:13.720]             setwd(...future.workdir)
[10:21:13.720]         {
[10:21:13.720]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:13.720]                 ...future.oldOptions$nwarnings <- NULL
[10:21:13.720]             }
[10:21:13.720]             base::options(...future.oldOptions)
[10:21:13.720]             if (.Platform$OS.type == "windows") {
[10:21:13.720]                 old_names <- names(...future.oldEnvVars)
[10:21:13.720]                 envs <- base::Sys.getenv()
[10:21:13.720]                 names <- names(envs)
[10:21:13.720]                 common <- intersect(names, old_names)
[10:21:13.720]                 added <- setdiff(names, old_names)
[10:21:13.720]                 removed <- setdiff(old_names, names)
[10:21:13.720]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:13.720]                   envs[common]]
[10:21:13.720]                 NAMES <- toupper(changed)
[10:21:13.720]                 args <- list()
[10:21:13.720]                 for (kk in seq_along(NAMES)) {
[10:21:13.720]                   name <- changed[[kk]]
[10:21:13.720]                   NAME <- NAMES[[kk]]
[10:21:13.720]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.720]                     next
[10:21:13.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:13.720]                 }
[10:21:13.720]                 NAMES <- toupper(added)
[10:21:13.720]                 for (kk in seq_along(NAMES)) {
[10:21:13.720]                   name <- added[[kk]]
[10:21:13.720]                   NAME <- NAMES[[kk]]
[10:21:13.720]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.720]                     next
[10:21:13.720]                   args[[name]] <- ""
[10:21:13.720]                 }
[10:21:13.720]                 NAMES <- toupper(removed)
[10:21:13.720]                 for (kk in seq_along(NAMES)) {
[10:21:13.720]                   name <- removed[[kk]]
[10:21:13.720]                   NAME <- NAMES[[kk]]
[10:21:13.720]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.720]                     next
[10:21:13.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:13.720]                 }
[10:21:13.720]                 if (length(args) > 0) 
[10:21:13.720]                   base::do.call(base::Sys.setenv, args = args)
[10:21:13.720]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:13.720]             }
[10:21:13.720]             else {
[10:21:13.720]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:13.720]             }
[10:21:13.720]             {
[10:21:13.720]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:13.720]                   0L) {
[10:21:13.720]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:13.720]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:13.720]                   base::options(opts)
[10:21:13.720]                 }
[10:21:13.720]                 {
[10:21:13.720]                   {
[10:21:13.720]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:13.720]                     NULL
[10:21:13.720]                   }
[10:21:13.720]                   options(future.plan = NULL)
[10:21:13.720]                   if (is.na(NA_character_)) 
[10:21:13.720]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:13.720]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:13.720]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:13.720]                     .init = FALSE)
[10:21:13.720]                 }
[10:21:13.720]             }
[10:21:13.720]         }
[10:21:13.720]     })
[10:21:13.720]     if (TRUE) {
[10:21:13.720]         base::sink(type = "output", split = FALSE)
[10:21:13.720]         if (TRUE) {
[10:21:13.720]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:13.720]         }
[10:21:13.720]         else {
[10:21:13.720]             ...future.result["stdout"] <- base::list(NULL)
[10:21:13.720]         }
[10:21:13.720]         base::close(...future.stdout)
[10:21:13.720]         ...future.stdout <- NULL
[10:21:13.720]     }
[10:21:13.720]     ...future.result$conditions <- ...future.conditions
[10:21:13.720]     ...future.result$finished <- base::Sys.time()
[10:21:13.720]     ...future.result
[10:21:13.720] }
[10:21:13.723] Exporting 1 global objects (346 bytes) to cluster node #1 ...
[10:21:13.723] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[10:21:13.724] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[10:21:13.724] Exporting 1 global objects (346 bytes) to cluster node #1 ... DONE
[10:21:13.724] MultisessionFuture started
[10:21:13.724] - Launch lazy future ... done
[10:21:13.725] run() for ‘MultisessionFuture’ ... done
[10:21:13.725] result() for ClusterFuture ...
[10:21:13.725] receiveMessageFromWorker() for ClusterFuture ...
[10:21:13.725] - Validating connection of MultisessionFuture
[10:21:13.766] - received message: FutureResult
[10:21:13.766] - Received FutureResult
[10:21:13.766] - Erased future from FutureRegistry
[10:21:13.766] result() for ClusterFuture ...
[10:21:13.766] - result already collected: FutureResult
[10:21:13.766] result() for ClusterFuture ... done
[10:21:13.766] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:13.767] result() for ClusterFuture ... done
[10:21:13.767] result() for ClusterFuture ...
[10:21:13.767] - result already collected: FutureResult
[10:21:13.767] result() for ClusterFuture ... done
[10:21:13.767] getGlobalsAndPackages() ...
[10:21:13.767] Searching for globals...
[10:21:13.768] - globals found: [3] ‘{’, ‘*’, ‘a’
[10:21:13.768] Searching for globals ... DONE
[10:21:13.768] Resolving globals: FALSE
[10:21:13.769] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:13.769] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:13.769] - globals: [1] ‘a’
[10:21:13.770] 
[10:21:13.770] getGlobalsAndPackages() ... DONE
[10:21:13.770] run() for ‘Future’ ...
[10:21:13.770] - state: ‘created’
[10:21:13.770] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:13.784] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:13.785] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:13.785]   - Field: ‘node’
[10:21:13.785]   - Field: ‘label’
[10:21:13.785]   - Field: ‘local’
[10:21:13.785]   - Field: ‘owner’
[10:21:13.785]   - Field: ‘envir’
[10:21:13.785]   - Field: ‘workers’
[10:21:13.785]   - Field: ‘packages’
[10:21:13.785]   - Field: ‘gc’
[10:21:13.785]   - Field: ‘conditions’
[10:21:13.786]   - Field: ‘persistent’
[10:21:13.786]   - Field: ‘expr’
[10:21:13.786]   - Field: ‘uuid’
[10:21:13.786]   - Field: ‘seed’
[10:21:13.786]   - Field: ‘version’
[10:21:13.786]   - Field: ‘result’
[10:21:13.786]   - Field: ‘asynchronous’
[10:21:13.786]   - Field: ‘calls’
[10:21:13.786]   - Field: ‘globals’
[10:21:13.787]   - Field: ‘stdout’
[10:21:13.787]   - Field: ‘earlySignal’
[10:21:13.787]   - Field: ‘lazy’
[10:21:13.787]   - Field: ‘state’
[10:21:13.787] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:13.787] - Launch lazy future ...
[10:21:13.787] Packages needed by the future expression (n = 0): <none>
[10:21:13.788] Packages needed by future strategies (n = 0): <none>
[10:21:13.788] {
[10:21:13.788]     {
[10:21:13.788]         {
[10:21:13.788]             ...future.startTime <- base::Sys.time()
[10:21:13.788]             {
[10:21:13.788]                 {
[10:21:13.788]                   {
[10:21:13.788]                     {
[10:21:13.788]                       base::local({
[10:21:13.788]                         has_future <- base::requireNamespace("future", 
[10:21:13.788]                           quietly = TRUE)
[10:21:13.788]                         if (has_future) {
[10:21:13.788]                           ns <- base::getNamespace("future")
[10:21:13.788]                           version <- ns[[".package"]][["version"]]
[10:21:13.788]                           if (is.null(version)) 
[10:21:13.788]                             version <- utils::packageVersion("future")
[10:21:13.788]                         }
[10:21:13.788]                         else {
[10:21:13.788]                           version <- NULL
[10:21:13.788]                         }
[10:21:13.788]                         if (!has_future || version < "1.8.0") {
[10:21:13.788]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:13.788]                             "", base::R.version$version.string), 
[10:21:13.788]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:13.788]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:13.788]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:13.788]                               "release", "version")], collapse = " "), 
[10:21:13.788]                             hostname = base::Sys.info()[["nodename"]])
[10:21:13.788]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:13.788]                             info)
[10:21:13.788]                           info <- base::paste(info, collapse = "; ")
[10:21:13.788]                           if (!has_future) {
[10:21:13.788]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:13.788]                               info)
[10:21:13.788]                           }
[10:21:13.788]                           else {
[10:21:13.788]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:13.788]                               info, version)
[10:21:13.788]                           }
[10:21:13.788]                           base::stop(msg)
[10:21:13.788]                         }
[10:21:13.788]                       })
[10:21:13.788]                     }
[10:21:13.788]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:13.788]                     base::options(mc.cores = 1L)
[10:21:13.788]                   }
[10:21:13.788]                   ...future.strategy.old <- future::plan("list")
[10:21:13.788]                   options(future.plan = NULL)
[10:21:13.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:13.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:13.788]                 }
[10:21:13.788]                 ...future.workdir <- getwd()
[10:21:13.788]             }
[10:21:13.788]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:13.788]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:13.788]         }
[10:21:13.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:13.788]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:13.788]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:13.788]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:13.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:13.788]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:13.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:13.788]             base::names(...future.oldOptions))
[10:21:13.788]     }
[10:21:13.788]     if (FALSE) {
[10:21:13.788]     }
[10:21:13.788]     else {
[10:21:13.788]         if (TRUE) {
[10:21:13.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:13.788]                 open = "w")
[10:21:13.788]         }
[10:21:13.788]         else {
[10:21:13.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:13.788]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:13.788]         }
[10:21:13.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:13.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:13.788]             base::sink(type = "output", split = FALSE)
[10:21:13.788]             base::close(...future.stdout)
[10:21:13.788]         }, add = TRUE)
[10:21:13.788]     }
[10:21:13.788]     ...future.frame <- base::sys.nframe()
[10:21:13.788]     ...future.conditions <- base::list()
[10:21:13.788]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:13.788]     if (FALSE) {
[10:21:13.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:13.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:13.788]     }
[10:21:13.788]     ...future.result <- base::tryCatch({
[10:21:13.788]         base::withCallingHandlers({
[10:21:13.788]             ...future.value <- base::withVisible(base::local({
[10:21:13.788]                 ...future.makeSendCondition <- base::local({
[10:21:13.788]                   sendCondition <- NULL
[10:21:13.788]                   function(frame = 1L) {
[10:21:13.788]                     if (is.function(sendCondition)) 
[10:21:13.788]                       return(sendCondition)
[10:21:13.788]                     ns <- getNamespace("parallel")
[10:21:13.788]                     if (exists("sendData", mode = "function", 
[10:21:13.788]                       envir = ns)) {
[10:21:13.788]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:13.788]                         envir = ns)
[10:21:13.788]                       envir <- sys.frame(frame)
[10:21:13.788]                       master <- NULL
[10:21:13.788]                       while (!identical(envir, .GlobalEnv) && 
[10:21:13.788]                         !identical(envir, emptyenv())) {
[10:21:13.788]                         if (exists("master", mode = "list", envir = envir, 
[10:21:13.788]                           inherits = FALSE)) {
[10:21:13.788]                           master <- get("master", mode = "list", 
[10:21:13.788]                             envir = envir, inherits = FALSE)
[10:21:13.788]                           if (inherits(master, c("SOCKnode", 
[10:21:13.788]                             "SOCK0node"))) {
[10:21:13.788]                             sendCondition <<- function(cond) {
[10:21:13.788]                               data <- list(type = "VALUE", value = cond, 
[10:21:13.788]                                 success = TRUE)
[10:21:13.788]                               parallel_sendData(master, data)
[10:21:13.788]                             }
[10:21:13.788]                             return(sendCondition)
[10:21:13.788]                           }
[10:21:13.788]                         }
[10:21:13.788]                         frame <- frame + 1L
[10:21:13.788]                         envir <- sys.frame(frame)
[10:21:13.788]                       }
[10:21:13.788]                     }
[10:21:13.788]                     sendCondition <<- function(cond) NULL
[10:21:13.788]                   }
[10:21:13.788]                 })
[10:21:13.788]                 withCallingHandlers({
[10:21:13.788]                   {
[10:21:13.788]                     2 * a
[10:21:13.788]                   }
[10:21:13.788]                 }, immediateCondition = function(cond) {
[10:21:13.788]                   sendCondition <- ...future.makeSendCondition()
[10:21:13.788]                   sendCondition(cond)
[10:21:13.788]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.788]                   {
[10:21:13.788]                     inherits <- base::inherits
[10:21:13.788]                     invokeRestart <- base::invokeRestart
[10:21:13.788]                     is.null <- base::is.null
[10:21:13.788]                     muffled <- FALSE
[10:21:13.788]                     if (inherits(cond, "message")) {
[10:21:13.788]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:13.788]                       if (muffled) 
[10:21:13.788]                         invokeRestart("muffleMessage")
[10:21:13.788]                     }
[10:21:13.788]                     else if (inherits(cond, "warning")) {
[10:21:13.788]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:13.788]                       if (muffled) 
[10:21:13.788]                         invokeRestart("muffleWarning")
[10:21:13.788]                     }
[10:21:13.788]                     else if (inherits(cond, "condition")) {
[10:21:13.788]                       if (!is.null(pattern)) {
[10:21:13.788]                         computeRestarts <- base::computeRestarts
[10:21:13.788]                         grepl <- base::grepl
[10:21:13.788]                         restarts <- computeRestarts(cond)
[10:21:13.788]                         for (restart in restarts) {
[10:21:13.788]                           name <- restart$name
[10:21:13.788]                           if (is.null(name)) 
[10:21:13.788]                             next
[10:21:13.788]                           if (!grepl(pattern, name)) 
[10:21:13.788]                             next
[10:21:13.788]                           invokeRestart(restart)
[10:21:13.788]                           muffled <- TRUE
[10:21:13.788]                           break
[10:21:13.788]                         }
[10:21:13.788]                       }
[10:21:13.788]                     }
[10:21:13.788]                     invisible(muffled)
[10:21:13.788]                   }
[10:21:13.788]                   muffleCondition(cond)
[10:21:13.788]                 })
[10:21:13.788]             }))
[10:21:13.788]             future::FutureResult(value = ...future.value$value, 
[10:21:13.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:13.788]                   ...future.rng), globalenv = if (FALSE) 
[10:21:13.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:13.788]                     ...future.globalenv.names))
[10:21:13.788]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:13.788]         }, condition = base::local({
[10:21:13.788]             c <- base::c
[10:21:13.788]             inherits <- base::inherits
[10:21:13.788]             invokeRestart <- base::invokeRestart
[10:21:13.788]             length <- base::length
[10:21:13.788]             list <- base::list
[10:21:13.788]             seq.int <- base::seq.int
[10:21:13.788]             signalCondition <- base::signalCondition
[10:21:13.788]             sys.calls <- base::sys.calls
[10:21:13.788]             `[[` <- base::`[[`
[10:21:13.788]             `+` <- base::`+`
[10:21:13.788]             `<<-` <- base::`<<-`
[10:21:13.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:13.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:13.788]                   3L)]
[10:21:13.788]             }
[10:21:13.788]             function(cond) {
[10:21:13.788]                 is_error <- inherits(cond, "error")
[10:21:13.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:13.788]                   NULL)
[10:21:13.788]                 if (is_error) {
[10:21:13.788]                   sessionInformation <- function() {
[10:21:13.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:13.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:13.788]                       search = base::search(), system = base::Sys.info())
[10:21:13.788]                   }
[10:21:13.788]                   ...future.conditions[[length(...future.conditions) + 
[10:21:13.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:13.788]                     cond$call), session = sessionInformation(), 
[10:21:13.788]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:13.788]                   signalCondition(cond)
[10:21:13.788]                 }
[10:21:13.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:13.788]                 "immediateCondition"))) {
[10:21:13.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:13.788]                   ...future.conditions[[length(...future.conditions) + 
[10:21:13.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:13.788]                   if (TRUE && !signal) {
[10:21:13.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.788]                     {
[10:21:13.788]                       inherits <- base::inherits
[10:21:13.788]                       invokeRestart <- base::invokeRestart
[10:21:13.788]                       is.null <- base::is.null
[10:21:13.788]                       muffled <- FALSE
[10:21:13.788]                       if (inherits(cond, "message")) {
[10:21:13.788]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:13.788]                         if (muffled) 
[10:21:13.788]                           invokeRestart("muffleMessage")
[10:21:13.788]                       }
[10:21:13.788]                       else if (inherits(cond, "warning")) {
[10:21:13.788]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:13.788]                         if (muffled) 
[10:21:13.788]                           invokeRestart("muffleWarning")
[10:21:13.788]                       }
[10:21:13.788]                       else if (inherits(cond, "condition")) {
[10:21:13.788]                         if (!is.null(pattern)) {
[10:21:13.788]                           computeRestarts <- base::computeRestarts
[10:21:13.788]                           grepl <- base::grepl
[10:21:13.788]                           restarts <- computeRestarts(cond)
[10:21:13.788]                           for (restart in restarts) {
[10:21:13.788]                             name <- restart$name
[10:21:13.788]                             if (is.null(name)) 
[10:21:13.788]                               next
[10:21:13.788]                             if (!grepl(pattern, name)) 
[10:21:13.788]                               next
[10:21:13.788]                             invokeRestart(restart)
[10:21:13.788]                             muffled <- TRUE
[10:21:13.788]                             break
[10:21:13.788]                           }
[10:21:13.788]                         }
[10:21:13.788]                       }
[10:21:13.788]                       invisible(muffled)
[10:21:13.788]                     }
[10:21:13.788]                     muffleCondition(cond, pattern = "^muffle")
[10:21:13.788]                   }
[10:21:13.788]                 }
[10:21:13.788]                 else {
[10:21:13.788]                   if (TRUE) {
[10:21:13.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.788]                     {
[10:21:13.788]                       inherits <- base::inherits
[10:21:13.788]                       invokeRestart <- base::invokeRestart
[10:21:13.788]                       is.null <- base::is.null
[10:21:13.788]                       muffled <- FALSE
[10:21:13.788]                       if (inherits(cond, "message")) {
[10:21:13.788]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:13.788]                         if (muffled) 
[10:21:13.788]                           invokeRestart("muffleMessage")
[10:21:13.788]                       }
[10:21:13.788]                       else if (inherits(cond, "warning")) {
[10:21:13.788]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:13.788]                         if (muffled) 
[10:21:13.788]                           invokeRestart("muffleWarning")
[10:21:13.788]                       }
[10:21:13.788]                       else if (inherits(cond, "condition")) {
[10:21:13.788]                         if (!is.null(pattern)) {
[10:21:13.788]                           computeRestarts <- base::computeRestarts
[10:21:13.788]                           grepl <- base::grepl
[10:21:13.788]                           restarts <- computeRestarts(cond)
[10:21:13.788]                           for (restart in restarts) {
[10:21:13.788]                             name <- restart$name
[10:21:13.788]                             if (is.null(name)) 
[10:21:13.788]                               next
[10:21:13.788]                             if (!grepl(pattern, name)) 
[10:21:13.788]                               next
[10:21:13.788]                             invokeRestart(restart)
[10:21:13.788]                             muffled <- TRUE
[10:21:13.788]                             break
[10:21:13.788]                           }
[10:21:13.788]                         }
[10:21:13.788]                       }
[10:21:13.788]                       invisible(muffled)
[10:21:13.788]                     }
[10:21:13.788]                     muffleCondition(cond, pattern = "^muffle")
[10:21:13.788]                   }
[10:21:13.788]                 }
[10:21:13.788]             }
[10:21:13.788]         }))
[10:21:13.788]     }, error = function(ex) {
[10:21:13.788]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:13.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:13.788]                 ...future.rng), started = ...future.startTime, 
[10:21:13.788]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:13.788]             version = "1.8"), class = "FutureResult")
[10:21:13.788]     }, finally = {
[10:21:13.788]         if (!identical(...future.workdir, getwd())) 
[10:21:13.788]             setwd(...future.workdir)
[10:21:13.788]         {
[10:21:13.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:13.788]                 ...future.oldOptions$nwarnings <- NULL
[10:21:13.788]             }
[10:21:13.788]             base::options(...future.oldOptions)
[10:21:13.788]             if (.Platform$OS.type == "windows") {
[10:21:13.788]                 old_names <- names(...future.oldEnvVars)
[10:21:13.788]                 envs <- base::Sys.getenv()
[10:21:13.788]                 names <- names(envs)
[10:21:13.788]                 common <- intersect(names, old_names)
[10:21:13.788]                 added <- setdiff(names, old_names)
[10:21:13.788]                 removed <- setdiff(old_names, names)
[10:21:13.788]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:13.788]                   envs[common]]
[10:21:13.788]                 NAMES <- toupper(changed)
[10:21:13.788]                 args <- list()
[10:21:13.788]                 for (kk in seq_along(NAMES)) {
[10:21:13.788]                   name <- changed[[kk]]
[10:21:13.788]                   NAME <- NAMES[[kk]]
[10:21:13.788]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.788]                     next
[10:21:13.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:13.788]                 }
[10:21:13.788]                 NAMES <- toupper(added)
[10:21:13.788]                 for (kk in seq_along(NAMES)) {
[10:21:13.788]                   name <- added[[kk]]
[10:21:13.788]                   NAME <- NAMES[[kk]]
[10:21:13.788]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.788]                     next
[10:21:13.788]                   args[[name]] <- ""
[10:21:13.788]                 }
[10:21:13.788]                 NAMES <- toupper(removed)
[10:21:13.788]                 for (kk in seq_along(NAMES)) {
[10:21:13.788]                   name <- removed[[kk]]
[10:21:13.788]                   NAME <- NAMES[[kk]]
[10:21:13.788]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.788]                     next
[10:21:13.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:13.788]                 }
[10:21:13.788]                 if (length(args) > 0) 
[10:21:13.788]                   base::do.call(base::Sys.setenv, args = args)
[10:21:13.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:13.788]             }
[10:21:13.788]             else {
[10:21:13.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:13.788]             }
[10:21:13.788]             {
[10:21:13.788]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:13.788]                   0L) {
[10:21:13.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:13.788]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:13.788]                   base::options(opts)
[10:21:13.788]                 }
[10:21:13.788]                 {
[10:21:13.788]                   {
[10:21:13.788]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:13.788]                     NULL
[10:21:13.788]                   }
[10:21:13.788]                   options(future.plan = NULL)
[10:21:13.788]                   if (is.na(NA_character_)) 
[10:21:13.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:13.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:13.788]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:13.788]                     .init = FALSE)
[10:21:13.788]                 }
[10:21:13.788]             }
[10:21:13.788]         }
[10:21:13.788]     })
[10:21:13.788]     if (TRUE) {
[10:21:13.788]         base::sink(type = "output", split = FALSE)
[10:21:13.788]         if (TRUE) {
[10:21:13.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:13.788]         }
[10:21:13.788]         else {
[10:21:13.788]             ...future.result["stdout"] <- base::list(NULL)
[10:21:13.788]         }
[10:21:13.788]         base::close(...future.stdout)
[10:21:13.788]         ...future.stdout <- NULL
[10:21:13.788]     }
[10:21:13.788]     ...future.result$conditions <- ...future.conditions
[10:21:13.788]     ...future.result$finished <- base::Sys.time()
[10:21:13.788]     ...future.result
[10:21:13.788] }
[10:21:13.791] Exporting 1 global objects (346 bytes) to cluster node #1 ...
[10:21:13.791] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[10:21:13.791] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[10:21:13.792] Exporting 1 global objects (346 bytes) to cluster node #1 ... DONE
[10:21:13.792] MultisessionFuture started
[10:21:13.792] - Launch lazy future ... done
[10:21:13.792] run() for ‘MultisessionFuture’ ... done
[10:21:13.793] result() for ClusterFuture ...
[10:21:13.793] receiveMessageFromWorker() for ClusterFuture ...
[10:21:13.793] - Validating connection of MultisessionFuture
[10:21:13.834] - received message: FutureResult
[10:21:13.834] - Received FutureResult
[10:21:13.834] - Erased future from FutureRegistry
[10:21:13.834] result() for ClusterFuture ...
[10:21:13.834] - result already collected: FutureResult
[10:21:13.834] result() for ClusterFuture ... done
[10:21:13.835] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:13.835] result() for ClusterFuture ... done
[10:21:13.835] result() for ClusterFuture ...
[10:21:13.835] - result already collected: FutureResult
[10:21:13.835] result() for ClusterFuture ... done
[10:21:13.835] getGlobalsAndPackages() ...
[10:21:13.835] Searching for globals...
[10:21:13.836] - globals found: [3] ‘{’, ‘*’, ‘a’
[10:21:13.836] Searching for globals ... DONE
[10:21:13.837] Resolving globals: FALSE
[10:21:13.837] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:13.837] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:13.838] - globals: [1] ‘a’
[10:21:13.838] 
[10:21:13.838] getGlobalsAndPackages() ... DONE
[10:21:13.838] run() for ‘Future’ ...
[10:21:13.838] - state: ‘created’
[10:21:13.838] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:13.855] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:13.855] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:13.855]   - Field: ‘node’
[10:21:13.855]   - Field: ‘label’
[10:21:13.855]   - Field: ‘local’
[10:21:13.855]   - Field: ‘owner’
[10:21:13.855]   - Field: ‘envir’
[10:21:13.855]   - Field: ‘workers’
[10:21:13.856]   - Field: ‘packages’
[10:21:13.856]   - Field: ‘gc’
[10:21:13.856]   - Field: ‘conditions’
[10:21:13.856]   - Field: ‘persistent’
[10:21:13.856]   - Field: ‘expr’
[10:21:13.856]   - Field: ‘uuid’
[10:21:13.856]   - Field: ‘seed’
[10:21:13.856]   - Field: ‘version’
[10:21:13.856]   - Field: ‘result’
[10:21:13.856]   - Field: ‘asynchronous’
[10:21:13.856]   - Field: ‘calls’
[10:21:13.856]   - Field: ‘globals’
[10:21:13.857]   - Field: ‘stdout’
[10:21:13.857]   - Field: ‘earlySignal’
[10:21:13.857]   - Field: ‘lazy’
[10:21:13.857]   - Field: ‘state’
[10:21:13.857] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:13.857] - Launch lazy future ...
[10:21:13.857] Packages needed by the future expression (n = 0): <none>
[10:21:13.857] Packages needed by future strategies (n = 0): <none>
[10:21:13.858] {
[10:21:13.858]     {
[10:21:13.858]         {
[10:21:13.858]             ...future.startTime <- base::Sys.time()
[10:21:13.858]             {
[10:21:13.858]                 {
[10:21:13.858]                   {
[10:21:13.858]                     {
[10:21:13.858]                       base::local({
[10:21:13.858]                         has_future <- base::requireNamespace("future", 
[10:21:13.858]                           quietly = TRUE)
[10:21:13.858]                         if (has_future) {
[10:21:13.858]                           ns <- base::getNamespace("future")
[10:21:13.858]                           version <- ns[[".package"]][["version"]]
[10:21:13.858]                           if (is.null(version)) 
[10:21:13.858]                             version <- utils::packageVersion("future")
[10:21:13.858]                         }
[10:21:13.858]                         else {
[10:21:13.858]                           version <- NULL
[10:21:13.858]                         }
[10:21:13.858]                         if (!has_future || version < "1.8.0") {
[10:21:13.858]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:13.858]                             "", base::R.version$version.string), 
[10:21:13.858]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:13.858]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:13.858]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:13.858]                               "release", "version")], collapse = " "), 
[10:21:13.858]                             hostname = base::Sys.info()[["nodename"]])
[10:21:13.858]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:13.858]                             info)
[10:21:13.858]                           info <- base::paste(info, collapse = "; ")
[10:21:13.858]                           if (!has_future) {
[10:21:13.858]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:13.858]                               info)
[10:21:13.858]                           }
[10:21:13.858]                           else {
[10:21:13.858]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:13.858]                               info, version)
[10:21:13.858]                           }
[10:21:13.858]                           base::stop(msg)
[10:21:13.858]                         }
[10:21:13.858]                       })
[10:21:13.858]                     }
[10:21:13.858]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:13.858]                     base::options(mc.cores = 1L)
[10:21:13.858]                   }
[10:21:13.858]                   ...future.strategy.old <- future::plan("list")
[10:21:13.858]                   options(future.plan = NULL)
[10:21:13.858]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:13.858]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:13.858]                 }
[10:21:13.858]                 ...future.workdir <- getwd()
[10:21:13.858]             }
[10:21:13.858]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:13.858]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:13.858]         }
[10:21:13.858]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:13.858]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:13.858]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:13.858]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:13.858]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:13.858]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:13.858]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:13.858]             base::names(...future.oldOptions))
[10:21:13.858]     }
[10:21:13.858]     if (FALSE) {
[10:21:13.858]     }
[10:21:13.858]     else {
[10:21:13.858]         if (TRUE) {
[10:21:13.858]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:13.858]                 open = "w")
[10:21:13.858]         }
[10:21:13.858]         else {
[10:21:13.858]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:13.858]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:13.858]         }
[10:21:13.858]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:13.858]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:13.858]             base::sink(type = "output", split = FALSE)
[10:21:13.858]             base::close(...future.stdout)
[10:21:13.858]         }, add = TRUE)
[10:21:13.858]     }
[10:21:13.858]     ...future.frame <- base::sys.nframe()
[10:21:13.858]     ...future.conditions <- base::list()
[10:21:13.858]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:13.858]     if (FALSE) {
[10:21:13.858]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:13.858]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:13.858]     }
[10:21:13.858]     ...future.result <- base::tryCatch({
[10:21:13.858]         base::withCallingHandlers({
[10:21:13.858]             ...future.value <- base::withVisible(base::local({
[10:21:13.858]                 ...future.makeSendCondition <- base::local({
[10:21:13.858]                   sendCondition <- NULL
[10:21:13.858]                   function(frame = 1L) {
[10:21:13.858]                     if (is.function(sendCondition)) 
[10:21:13.858]                       return(sendCondition)
[10:21:13.858]                     ns <- getNamespace("parallel")
[10:21:13.858]                     if (exists("sendData", mode = "function", 
[10:21:13.858]                       envir = ns)) {
[10:21:13.858]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:13.858]                         envir = ns)
[10:21:13.858]                       envir <- sys.frame(frame)
[10:21:13.858]                       master <- NULL
[10:21:13.858]                       while (!identical(envir, .GlobalEnv) && 
[10:21:13.858]                         !identical(envir, emptyenv())) {
[10:21:13.858]                         if (exists("master", mode = "list", envir = envir, 
[10:21:13.858]                           inherits = FALSE)) {
[10:21:13.858]                           master <- get("master", mode = "list", 
[10:21:13.858]                             envir = envir, inherits = FALSE)
[10:21:13.858]                           if (inherits(master, c("SOCKnode", 
[10:21:13.858]                             "SOCK0node"))) {
[10:21:13.858]                             sendCondition <<- function(cond) {
[10:21:13.858]                               data <- list(type = "VALUE", value = cond, 
[10:21:13.858]                                 success = TRUE)
[10:21:13.858]                               parallel_sendData(master, data)
[10:21:13.858]                             }
[10:21:13.858]                             return(sendCondition)
[10:21:13.858]                           }
[10:21:13.858]                         }
[10:21:13.858]                         frame <- frame + 1L
[10:21:13.858]                         envir <- sys.frame(frame)
[10:21:13.858]                       }
[10:21:13.858]                     }
[10:21:13.858]                     sendCondition <<- function(cond) NULL
[10:21:13.858]                   }
[10:21:13.858]                 })
[10:21:13.858]                 withCallingHandlers({
[10:21:13.858]                   {
[10:21:13.858]                     2 * a
[10:21:13.858]                   }
[10:21:13.858]                 }, immediateCondition = function(cond) {
[10:21:13.858]                   sendCondition <- ...future.makeSendCondition()
[10:21:13.858]                   sendCondition(cond)
[10:21:13.858]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.858]                   {
[10:21:13.858]                     inherits <- base::inherits
[10:21:13.858]                     invokeRestart <- base::invokeRestart
[10:21:13.858]                     is.null <- base::is.null
[10:21:13.858]                     muffled <- FALSE
[10:21:13.858]                     if (inherits(cond, "message")) {
[10:21:13.858]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:13.858]                       if (muffled) 
[10:21:13.858]                         invokeRestart("muffleMessage")
[10:21:13.858]                     }
[10:21:13.858]                     else if (inherits(cond, "warning")) {
[10:21:13.858]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:13.858]                       if (muffled) 
[10:21:13.858]                         invokeRestart("muffleWarning")
[10:21:13.858]                     }
[10:21:13.858]                     else if (inherits(cond, "condition")) {
[10:21:13.858]                       if (!is.null(pattern)) {
[10:21:13.858]                         computeRestarts <- base::computeRestarts
[10:21:13.858]                         grepl <- base::grepl
[10:21:13.858]                         restarts <- computeRestarts(cond)
[10:21:13.858]                         for (restart in restarts) {
[10:21:13.858]                           name <- restart$name
[10:21:13.858]                           if (is.null(name)) 
[10:21:13.858]                             next
[10:21:13.858]                           if (!grepl(pattern, name)) 
[10:21:13.858]                             next
[10:21:13.858]                           invokeRestart(restart)
[10:21:13.858]                           muffled <- TRUE
[10:21:13.858]                           break
[10:21:13.858]                         }
[10:21:13.858]                       }
[10:21:13.858]                     }
[10:21:13.858]                     invisible(muffled)
[10:21:13.858]                   }
[10:21:13.858]                   muffleCondition(cond)
[10:21:13.858]                 })
[10:21:13.858]             }))
[10:21:13.858]             future::FutureResult(value = ...future.value$value, 
[10:21:13.858]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:13.858]                   ...future.rng), globalenv = if (FALSE) 
[10:21:13.858]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:13.858]                     ...future.globalenv.names))
[10:21:13.858]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:13.858]         }, condition = base::local({
[10:21:13.858]             c <- base::c
[10:21:13.858]             inherits <- base::inherits
[10:21:13.858]             invokeRestart <- base::invokeRestart
[10:21:13.858]             length <- base::length
[10:21:13.858]             list <- base::list
[10:21:13.858]             seq.int <- base::seq.int
[10:21:13.858]             signalCondition <- base::signalCondition
[10:21:13.858]             sys.calls <- base::sys.calls
[10:21:13.858]             `[[` <- base::`[[`
[10:21:13.858]             `+` <- base::`+`
[10:21:13.858]             `<<-` <- base::`<<-`
[10:21:13.858]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:13.858]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:13.858]                   3L)]
[10:21:13.858]             }
[10:21:13.858]             function(cond) {
[10:21:13.858]                 is_error <- inherits(cond, "error")
[10:21:13.858]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:13.858]                   NULL)
[10:21:13.858]                 if (is_error) {
[10:21:13.858]                   sessionInformation <- function() {
[10:21:13.858]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:13.858]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:13.858]                       search = base::search(), system = base::Sys.info())
[10:21:13.858]                   }
[10:21:13.858]                   ...future.conditions[[length(...future.conditions) + 
[10:21:13.858]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:13.858]                     cond$call), session = sessionInformation(), 
[10:21:13.858]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:13.858]                   signalCondition(cond)
[10:21:13.858]                 }
[10:21:13.858]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:13.858]                 "immediateCondition"))) {
[10:21:13.858]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:13.858]                   ...future.conditions[[length(...future.conditions) + 
[10:21:13.858]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:13.858]                   if (TRUE && !signal) {
[10:21:13.858]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.858]                     {
[10:21:13.858]                       inherits <- base::inherits
[10:21:13.858]                       invokeRestart <- base::invokeRestart
[10:21:13.858]                       is.null <- base::is.null
[10:21:13.858]                       muffled <- FALSE
[10:21:13.858]                       if (inherits(cond, "message")) {
[10:21:13.858]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:13.858]                         if (muffled) 
[10:21:13.858]                           invokeRestart("muffleMessage")
[10:21:13.858]                       }
[10:21:13.858]                       else if (inherits(cond, "warning")) {
[10:21:13.858]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:13.858]                         if (muffled) 
[10:21:13.858]                           invokeRestart("muffleWarning")
[10:21:13.858]                       }
[10:21:13.858]                       else if (inherits(cond, "condition")) {
[10:21:13.858]                         if (!is.null(pattern)) {
[10:21:13.858]                           computeRestarts <- base::computeRestarts
[10:21:13.858]                           grepl <- base::grepl
[10:21:13.858]                           restarts <- computeRestarts(cond)
[10:21:13.858]                           for (restart in restarts) {
[10:21:13.858]                             name <- restart$name
[10:21:13.858]                             if (is.null(name)) 
[10:21:13.858]                               next
[10:21:13.858]                             if (!grepl(pattern, name)) 
[10:21:13.858]                               next
[10:21:13.858]                             invokeRestart(restart)
[10:21:13.858]                             muffled <- TRUE
[10:21:13.858]                             break
[10:21:13.858]                           }
[10:21:13.858]                         }
[10:21:13.858]                       }
[10:21:13.858]                       invisible(muffled)
[10:21:13.858]                     }
[10:21:13.858]                     muffleCondition(cond, pattern = "^muffle")
[10:21:13.858]                   }
[10:21:13.858]                 }
[10:21:13.858]                 else {
[10:21:13.858]                   if (TRUE) {
[10:21:13.858]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.858]                     {
[10:21:13.858]                       inherits <- base::inherits
[10:21:13.858]                       invokeRestart <- base::invokeRestart
[10:21:13.858]                       is.null <- base::is.null
[10:21:13.858]                       muffled <- FALSE
[10:21:13.858]                       if (inherits(cond, "message")) {
[10:21:13.858]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:13.858]                         if (muffled) 
[10:21:13.858]                           invokeRestart("muffleMessage")
[10:21:13.858]                       }
[10:21:13.858]                       else if (inherits(cond, "warning")) {
[10:21:13.858]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:13.858]                         if (muffled) 
[10:21:13.858]                           invokeRestart("muffleWarning")
[10:21:13.858]                       }
[10:21:13.858]                       else if (inherits(cond, "condition")) {
[10:21:13.858]                         if (!is.null(pattern)) {
[10:21:13.858]                           computeRestarts <- base::computeRestarts
[10:21:13.858]                           grepl <- base::grepl
[10:21:13.858]                           restarts <- computeRestarts(cond)
[10:21:13.858]                           for (restart in restarts) {
[10:21:13.858]                             name <- restart$name
[10:21:13.858]                             if (is.null(name)) 
[10:21:13.858]                               next
[10:21:13.858]                             if (!grepl(pattern, name)) 
[10:21:13.858]                               next
[10:21:13.858]                             invokeRestart(restart)
[10:21:13.858]                             muffled <- TRUE
[10:21:13.858]                             break
[10:21:13.858]                           }
[10:21:13.858]                         }
[10:21:13.858]                       }
[10:21:13.858]                       invisible(muffled)
[10:21:13.858]                     }
[10:21:13.858]                     muffleCondition(cond, pattern = "^muffle")
[10:21:13.858]                   }
[10:21:13.858]                 }
[10:21:13.858]             }
[10:21:13.858]         }))
[10:21:13.858]     }, error = function(ex) {
[10:21:13.858]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:13.858]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:13.858]                 ...future.rng), started = ...future.startTime, 
[10:21:13.858]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:13.858]             version = "1.8"), class = "FutureResult")
[10:21:13.858]     }, finally = {
[10:21:13.858]         if (!identical(...future.workdir, getwd())) 
[10:21:13.858]             setwd(...future.workdir)
[10:21:13.858]         {
[10:21:13.858]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:13.858]                 ...future.oldOptions$nwarnings <- NULL
[10:21:13.858]             }
[10:21:13.858]             base::options(...future.oldOptions)
[10:21:13.858]             if (.Platform$OS.type == "windows") {
[10:21:13.858]                 old_names <- names(...future.oldEnvVars)
[10:21:13.858]                 envs <- base::Sys.getenv()
[10:21:13.858]                 names <- names(envs)
[10:21:13.858]                 common <- intersect(names, old_names)
[10:21:13.858]                 added <- setdiff(names, old_names)
[10:21:13.858]                 removed <- setdiff(old_names, names)
[10:21:13.858]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:13.858]                   envs[common]]
[10:21:13.858]                 NAMES <- toupper(changed)
[10:21:13.858]                 args <- list()
[10:21:13.858]                 for (kk in seq_along(NAMES)) {
[10:21:13.858]                   name <- changed[[kk]]
[10:21:13.858]                   NAME <- NAMES[[kk]]
[10:21:13.858]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.858]                     next
[10:21:13.858]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:13.858]                 }
[10:21:13.858]                 NAMES <- toupper(added)
[10:21:13.858]                 for (kk in seq_along(NAMES)) {
[10:21:13.858]                   name <- added[[kk]]
[10:21:13.858]                   NAME <- NAMES[[kk]]
[10:21:13.858]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.858]                     next
[10:21:13.858]                   args[[name]] <- ""
[10:21:13.858]                 }
[10:21:13.858]                 NAMES <- toupper(removed)
[10:21:13.858]                 for (kk in seq_along(NAMES)) {
[10:21:13.858]                   name <- removed[[kk]]
[10:21:13.858]                   NAME <- NAMES[[kk]]
[10:21:13.858]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.858]                     next
[10:21:13.858]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:13.858]                 }
[10:21:13.858]                 if (length(args) > 0) 
[10:21:13.858]                   base::do.call(base::Sys.setenv, args = args)
[10:21:13.858]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:13.858]             }
[10:21:13.858]             else {
[10:21:13.858]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:13.858]             }
[10:21:13.858]             {
[10:21:13.858]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:13.858]                   0L) {
[10:21:13.858]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:13.858]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:13.858]                   base::options(opts)
[10:21:13.858]                 }
[10:21:13.858]                 {
[10:21:13.858]                   {
[10:21:13.858]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:13.858]                     NULL
[10:21:13.858]                   }
[10:21:13.858]                   options(future.plan = NULL)
[10:21:13.858]                   if (is.na(NA_character_)) 
[10:21:13.858]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:13.858]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:13.858]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:13.858]                     .init = FALSE)
[10:21:13.858]                 }
[10:21:13.858]             }
[10:21:13.858]         }
[10:21:13.858]     })
[10:21:13.858]     if (TRUE) {
[10:21:13.858]         base::sink(type = "output", split = FALSE)
[10:21:13.858]         if (TRUE) {
[10:21:13.858]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:13.858]         }
[10:21:13.858]         else {
[10:21:13.858]             ...future.result["stdout"] <- base::list(NULL)
[10:21:13.858]         }
[10:21:13.858]         base::close(...future.stdout)
[10:21:13.858]         ...future.stdout <- NULL
[10:21:13.858]     }
[10:21:13.858]     ...future.result$conditions <- ...future.conditions
[10:21:13.858]     ...future.result$finished <- base::Sys.time()
[10:21:13.858]     ...future.result
[10:21:13.858] }
[10:21:13.860] Exporting 1 global objects (346 bytes) to cluster node #1 ...
[10:21:13.860] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[10:21:13.861] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[10:21:13.861] Exporting 1 global objects (346 bytes) to cluster node #1 ... DONE
[10:21:13.861] MultisessionFuture started
[10:21:13.861] - Launch lazy future ... done
[10:21:13.861] run() for ‘MultisessionFuture’ ... done
[10:21:13.862] result() for ClusterFuture ...
[10:21:13.862] receiveMessageFromWorker() for ClusterFuture ...
[10:21:13.862] - Validating connection of MultisessionFuture
[10:21:13.903] - received message: FutureResult
[10:21:13.903] - Received FutureResult
[10:21:13.903] - Erased future from FutureRegistry
[10:21:13.903] result() for ClusterFuture ...
[10:21:13.903] - result already collected: FutureResult
[10:21:13.903] result() for ClusterFuture ... done
[10:21:13.903] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:13.904] result() for ClusterFuture ... done
[10:21:13.904] result() for ClusterFuture ...
[10:21:13.904] - result already collected: FutureResult
[10:21:13.904] result() for ClusterFuture ... done
[10:21:13.904] getGlobalsAndPackages() ...
[10:21:13.904] Searching for globals...
[10:21:13.905] - globals found: [3] ‘{’, ‘*’, ‘a’
[10:21:13.905] Searching for globals ... DONE
[10:21:13.905] Resolving globals: FALSE
[10:21:13.905] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:13.906] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:13.906] - globals: [1] ‘a’
[10:21:13.906] 
[10:21:13.906] getGlobalsAndPackages() ... DONE
[10:21:13.906] run() for ‘Future’ ...
[10:21:13.906] - state: ‘created’
[10:21:13.906] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:13.920] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:13.920] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:13.920]   - Field: ‘node’
[10:21:13.920]   - Field: ‘label’
[10:21:13.920]   - Field: ‘local’
[10:21:13.920]   - Field: ‘owner’
[10:21:13.920]   - Field: ‘envir’
[10:21:13.920]   - Field: ‘workers’
[10:21:13.921]   - Field: ‘packages’
[10:21:13.921]   - Field: ‘gc’
[10:21:13.921]   - Field: ‘conditions’
[10:21:13.921]   - Field: ‘persistent’
[10:21:13.921]   - Field: ‘expr’
[10:21:13.921]   - Field: ‘uuid’
[10:21:13.921]   - Field: ‘seed’
[10:21:13.921]   - Field: ‘version’
[10:21:13.921]   - Field: ‘result’
[10:21:13.921]   - Field: ‘asynchronous’
[10:21:13.921]   - Field: ‘calls’
[10:21:13.921]   - Field: ‘globals’
[10:21:13.922]   - Field: ‘stdout’
[10:21:13.922]   - Field: ‘earlySignal’
[10:21:13.922]   - Field: ‘lazy’
[10:21:13.922]   - Field: ‘state’
[10:21:13.922] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:13.922] - Launch lazy future ...
[10:21:13.922] Packages needed by the future expression (n = 0): <none>
[10:21:13.922] Packages needed by future strategies (n = 0): <none>
[10:21:13.923] {
[10:21:13.923]     {
[10:21:13.923]         {
[10:21:13.923]             ...future.startTime <- base::Sys.time()
[10:21:13.923]             {
[10:21:13.923]                 {
[10:21:13.923]                   {
[10:21:13.923]                     {
[10:21:13.923]                       base::local({
[10:21:13.923]                         has_future <- base::requireNamespace("future", 
[10:21:13.923]                           quietly = TRUE)
[10:21:13.923]                         if (has_future) {
[10:21:13.923]                           ns <- base::getNamespace("future")
[10:21:13.923]                           version <- ns[[".package"]][["version"]]
[10:21:13.923]                           if (is.null(version)) 
[10:21:13.923]                             version <- utils::packageVersion("future")
[10:21:13.923]                         }
[10:21:13.923]                         else {
[10:21:13.923]                           version <- NULL
[10:21:13.923]                         }
[10:21:13.923]                         if (!has_future || version < "1.8.0") {
[10:21:13.923]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:13.923]                             "", base::R.version$version.string), 
[10:21:13.923]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:13.923]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:13.923]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:13.923]                               "release", "version")], collapse = " "), 
[10:21:13.923]                             hostname = base::Sys.info()[["nodename"]])
[10:21:13.923]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:13.923]                             info)
[10:21:13.923]                           info <- base::paste(info, collapse = "; ")
[10:21:13.923]                           if (!has_future) {
[10:21:13.923]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:13.923]                               info)
[10:21:13.923]                           }
[10:21:13.923]                           else {
[10:21:13.923]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:13.923]                               info, version)
[10:21:13.923]                           }
[10:21:13.923]                           base::stop(msg)
[10:21:13.923]                         }
[10:21:13.923]                       })
[10:21:13.923]                     }
[10:21:13.923]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:13.923]                     base::options(mc.cores = 1L)
[10:21:13.923]                   }
[10:21:13.923]                   ...future.strategy.old <- future::plan("list")
[10:21:13.923]                   options(future.plan = NULL)
[10:21:13.923]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:13.923]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:13.923]                 }
[10:21:13.923]                 ...future.workdir <- getwd()
[10:21:13.923]             }
[10:21:13.923]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:13.923]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:13.923]         }
[10:21:13.923]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:13.923]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:13.923]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:13.923]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:13.923]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:13.923]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:13.923]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:13.923]             base::names(...future.oldOptions))
[10:21:13.923]     }
[10:21:13.923]     if (FALSE) {
[10:21:13.923]     }
[10:21:13.923]     else {
[10:21:13.923]         if (TRUE) {
[10:21:13.923]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:13.923]                 open = "w")
[10:21:13.923]         }
[10:21:13.923]         else {
[10:21:13.923]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:13.923]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:13.923]         }
[10:21:13.923]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:13.923]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:13.923]             base::sink(type = "output", split = FALSE)
[10:21:13.923]             base::close(...future.stdout)
[10:21:13.923]         }, add = TRUE)
[10:21:13.923]     }
[10:21:13.923]     ...future.frame <- base::sys.nframe()
[10:21:13.923]     ...future.conditions <- base::list()
[10:21:13.923]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:13.923]     if (FALSE) {
[10:21:13.923]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:13.923]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:13.923]     }
[10:21:13.923]     ...future.result <- base::tryCatch({
[10:21:13.923]         base::withCallingHandlers({
[10:21:13.923]             ...future.value <- base::withVisible(base::local({
[10:21:13.923]                 ...future.makeSendCondition <- base::local({
[10:21:13.923]                   sendCondition <- NULL
[10:21:13.923]                   function(frame = 1L) {
[10:21:13.923]                     if (is.function(sendCondition)) 
[10:21:13.923]                       return(sendCondition)
[10:21:13.923]                     ns <- getNamespace("parallel")
[10:21:13.923]                     if (exists("sendData", mode = "function", 
[10:21:13.923]                       envir = ns)) {
[10:21:13.923]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:13.923]                         envir = ns)
[10:21:13.923]                       envir <- sys.frame(frame)
[10:21:13.923]                       master <- NULL
[10:21:13.923]                       while (!identical(envir, .GlobalEnv) && 
[10:21:13.923]                         !identical(envir, emptyenv())) {
[10:21:13.923]                         if (exists("master", mode = "list", envir = envir, 
[10:21:13.923]                           inherits = FALSE)) {
[10:21:13.923]                           master <- get("master", mode = "list", 
[10:21:13.923]                             envir = envir, inherits = FALSE)
[10:21:13.923]                           if (inherits(master, c("SOCKnode", 
[10:21:13.923]                             "SOCK0node"))) {
[10:21:13.923]                             sendCondition <<- function(cond) {
[10:21:13.923]                               data <- list(type = "VALUE", value = cond, 
[10:21:13.923]                                 success = TRUE)
[10:21:13.923]                               parallel_sendData(master, data)
[10:21:13.923]                             }
[10:21:13.923]                             return(sendCondition)
[10:21:13.923]                           }
[10:21:13.923]                         }
[10:21:13.923]                         frame <- frame + 1L
[10:21:13.923]                         envir <- sys.frame(frame)
[10:21:13.923]                       }
[10:21:13.923]                     }
[10:21:13.923]                     sendCondition <<- function(cond) NULL
[10:21:13.923]                   }
[10:21:13.923]                 })
[10:21:13.923]                 withCallingHandlers({
[10:21:13.923]                   {
[10:21:13.923]                     2 * a
[10:21:13.923]                   }
[10:21:13.923]                 }, immediateCondition = function(cond) {
[10:21:13.923]                   sendCondition <- ...future.makeSendCondition()
[10:21:13.923]                   sendCondition(cond)
[10:21:13.923]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.923]                   {
[10:21:13.923]                     inherits <- base::inherits
[10:21:13.923]                     invokeRestart <- base::invokeRestart
[10:21:13.923]                     is.null <- base::is.null
[10:21:13.923]                     muffled <- FALSE
[10:21:13.923]                     if (inherits(cond, "message")) {
[10:21:13.923]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:13.923]                       if (muffled) 
[10:21:13.923]                         invokeRestart("muffleMessage")
[10:21:13.923]                     }
[10:21:13.923]                     else if (inherits(cond, "warning")) {
[10:21:13.923]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:13.923]                       if (muffled) 
[10:21:13.923]                         invokeRestart("muffleWarning")
[10:21:13.923]                     }
[10:21:13.923]                     else if (inherits(cond, "condition")) {
[10:21:13.923]                       if (!is.null(pattern)) {
[10:21:13.923]                         computeRestarts <- base::computeRestarts
[10:21:13.923]                         grepl <- base::grepl
[10:21:13.923]                         restarts <- computeRestarts(cond)
[10:21:13.923]                         for (restart in restarts) {
[10:21:13.923]                           name <- restart$name
[10:21:13.923]                           if (is.null(name)) 
[10:21:13.923]                             next
[10:21:13.923]                           if (!grepl(pattern, name)) 
[10:21:13.923]                             next
[10:21:13.923]                           invokeRestart(restart)
[10:21:13.923]                           muffled <- TRUE
[10:21:13.923]                           break
[10:21:13.923]                         }
[10:21:13.923]                       }
[10:21:13.923]                     }
[10:21:13.923]                     invisible(muffled)
[10:21:13.923]                   }
[10:21:13.923]                   muffleCondition(cond)
[10:21:13.923]                 })
[10:21:13.923]             }))
[10:21:13.923]             future::FutureResult(value = ...future.value$value, 
[10:21:13.923]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:13.923]                   ...future.rng), globalenv = if (FALSE) 
[10:21:13.923]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:13.923]                     ...future.globalenv.names))
[10:21:13.923]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:13.923]         }, condition = base::local({
[10:21:13.923]             c <- base::c
[10:21:13.923]             inherits <- base::inherits
[10:21:13.923]             invokeRestart <- base::invokeRestart
[10:21:13.923]             length <- base::length
[10:21:13.923]             list <- base::list
[10:21:13.923]             seq.int <- base::seq.int
[10:21:13.923]             signalCondition <- base::signalCondition
[10:21:13.923]             sys.calls <- base::sys.calls
[10:21:13.923]             `[[` <- base::`[[`
[10:21:13.923]             `+` <- base::`+`
[10:21:13.923]             `<<-` <- base::`<<-`
[10:21:13.923]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:13.923]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:13.923]                   3L)]
[10:21:13.923]             }
[10:21:13.923]             function(cond) {
[10:21:13.923]                 is_error <- inherits(cond, "error")
[10:21:13.923]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:13.923]                   NULL)
[10:21:13.923]                 if (is_error) {
[10:21:13.923]                   sessionInformation <- function() {
[10:21:13.923]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:13.923]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:13.923]                       search = base::search(), system = base::Sys.info())
[10:21:13.923]                   }
[10:21:13.923]                   ...future.conditions[[length(...future.conditions) + 
[10:21:13.923]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:13.923]                     cond$call), session = sessionInformation(), 
[10:21:13.923]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:13.923]                   signalCondition(cond)
[10:21:13.923]                 }
[10:21:13.923]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:13.923]                 "immediateCondition"))) {
[10:21:13.923]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:13.923]                   ...future.conditions[[length(...future.conditions) + 
[10:21:13.923]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:13.923]                   if (TRUE && !signal) {
[10:21:13.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.923]                     {
[10:21:13.923]                       inherits <- base::inherits
[10:21:13.923]                       invokeRestart <- base::invokeRestart
[10:21:13.923]                       is.null <- base::is.null
[10:21:13.923]                       muffled <- FALSE
[10:21:13.923]                       if (inherits(cond, "message")) {
[10:21:13.923]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:13.923]                         if (muffled) 
[10:21:13.923]                           invokeRestart("muffleMessage")
[10:21:13.923]                       }
[10:21:13.923]                       else if (inherits(cond, "warning")) {
[10:21:13.923]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:13.923]                         if (muffled) 
[10:21:13.923]                           invokeRestart("muffleWarning")
[10:21:13.923]                       }
[10:21:13.923]                       else if (inherits(cond, "condition")) {
[10:21:13.923]                         if (!is.null(pattern)) {
[10:21:13.923]                           computeRestarts <- base::computeRestarts
[10:21:13.923]                           grepl <- base::grepl
[10:21:13.923]                           restarts <- computeRestarts(cond)
[10:21:13.923]                           for (restart in restarts) {
[10:21:13.923]                             name <- restart$name
[10:21:13.923]                             if (is.null(name)) 
[10:21:13.923]                               next
[10:21:13.923]                             if (!grepl(pattern, name)) 
[10:21:13.923]                               next
[10:21:13.923]                             invokeRestart(restart)
[10:21:13.923]                             muffled <- TRUE
[10:21:13.923]                             break
[10:21:13.923]                           }
[10:21:13.923]                         }
[10:21:13.923]                       }
[10:21:13.923]                       invisible(muffled)
[10:21:13.923]                     }
[10:21:13.923]                     muffleCondition(cond, pattern = "^muffle")
[10:21:13.923]                   }
[10:21:13.923]                 }
[10:21:13.923]                 else {
[10:21:13.923]                   if (TRUE) {
[10:21:13.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:13.923]                     {
[10:21:13.923]                       inherits <- base::inherits
[10:21:13.923]                       invokeRestart <- base::invokeRestart
[10:21:13.923]                       is.null <- base::is.null
[10:21:13.923]                       muffled <- FALSE
[10:21:13.923]                       if (inherits(cond, "message")) {
[10:21:13.923]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:13.923]                         if (muffled) 
[10:21:13.923]                           invokeRestart("muffleMessage")
[10:21:13.923]                       }
[10:21:13.923]                       else if (inherits(cond, "warning")) {
[10:21:13.923]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:13.923]                         if (muffled) 
[10:21:13.923]                           invokeRestart("muffleWarning")
[10:21:13.923]                       }
[10:21:13.923]                       else if (inherits(cond, "condition")) {
[10:21:13.923]                         if (!is.null(pattern)) {
[10:21:13.923]                           computeRestarts <- base::computeRestarts
[10:21:13.923]                           grepl <- base::grepl
[10:21:13.923]                           restarts <- computeRestarts(cond)
[10:21:13.923]                           for (restart in restarts) {
[10:21:13.923]                             name <- restart$name
[10:21:13.923]                             if (is.null(name)) 
[10:21:13.923]                               next
[10:21:13.923]                             if (!grepl(pattern, name)) 
[10:21:13.923]                               next
[10:21:13.923]                             invokeRestart(restart)
[10:21:13.923]                             muffled <- TRUE
[10:21:13.923]                             break
[10:21:13.923]                           }
[10:21:13.923]                         }
[10:21:13.923]                       }
[10:21:13.923]                       invisible(muffled)
[10:21:13.923]                     }
[10:21:13.923]                     muffleCondition(cond, pattern = "^muffle")
[10:21:13.923]                   }
[10:21:13.923]                 }
[10:21:13.923]             }
[10:21:13.923]         }))
[10:21:13.923]     }, error = function(ex) {
[10:21:13.923]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:13.923]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:13.923]                 ...future.rng), started = ...future.startTime, 
[10:21:13.923]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:13.923]             version = "1.8"), class = "FutureResult")
[10:21:13.923]     }, finally = {
[10:21:13.923]         if (!identical(...future.workdir, getwd())) 
[10:21:13.923]             setwd(...future.workdir)
[10:21:13.923]         {
[10:21:13.923]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:13.923]                 ...future.oldOptions$nwarnings <- NULL
[10:21:13.923]             }
[10:21:13.923]             base::options(...future.oldOptions)
[10:21:13.923]             if (.Platform$OS.type == "windows") {
[10:21:13.923]                 old_names <- names(...future.oldEnvVars)
[10:21:13.923]                 envs <- base::Sys.getenv()
[10:21:13.923]                 names <- names(envs)
[10:21:13.923]                 common <- intersect(names, old_names)
[10:21:13.923]                 added <- setdiff(names, old_names)
[10:21:13.923]                 removed <- setdiff(old_names, names)
[10:21:13.923]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:13.923]                   envs[common]]
[10:21:13.923]                 NAMES <- toupper(changed)
[10:21:13.923]                 args <- list()
[10:21:13.923]                 for (kk in seq_along(NAMES)) {
[10:21:13.923]                   name <- changed[[kk]]
[10:21:13.923]                   NAME <- NAMES[[kk]]
[10:21:13.923]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.923]                     next
[10:21:13.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:13.923]                 }
[10:21:13.923]                 NAMES <- toupper(added)
[10:21:13.923]                 for (kk in seq_along(NAMES)) {
[10:21:13.923]                   name <- added[[kk]]
[10:21:13.923]                   NAME <- NAMES[[kk]]
[10:21:13.923]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.923]                     next
[10:21:13.923]                   args[[name]] <- ""
[10:21:13.923]                 }
[10:21:13.923]                 NAMES <- toupper(removed)
[10:21:13.923]                 for (kk in seq_along(NAMES)) {
[10:21:13.923]                   name <- removed[[kk]]
[10:21:13.923]                   NAME <- NAMES[[kk]]
[10:21:13.923]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:13.923]                     next
[10:21:13.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:13.923]                 }
[10:21:13.923]                 if (length(args) > 0) 
[10:21:13.923]                   base::do.call(base::Sys.setenv, args = args)
[10:21:13.923]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:13.923]             }
[10:21:13.923]             else {
[10:21:13.923]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:13.923]             }
[10:21:13.923]             {
[10:21:13.923]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:13.923]                   0L) {
[10:21:13.923]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:13.923]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:13.923]                   base::options(opts)
[10:21:13.923]                 }
[10:21:13.923]                 {
[10:21:13.923]                   {
[10:21:13.923]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:13.923]                     NULL
[10:21:13.923]                   }
[10:21:13.923]                   options(future.plan = NULL)
[10:21:13.923]                   if (is.na(NA_character_)) 
[10:21:13.923]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:13.923]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:13.923]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:13.923]                     .init = FALSE)
[10:21:13.923]                 }
[10:21:13.923]             }
[10:21:13.923]         }
[10:21:13.923]     })
[10:21:13.923]     if (TRUE) {
[10:21:13.923]         base::sink(type = "output", split = FALSE)
[10:21:13.923]         if (TRUE) {
[10:21:13.923]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:13.923]         }
[10:21:13.923]         else {
[10:21:13.923]             ...future.result["stdout"] <- base::list(NULL)
[10:21:13.923]         }
[10:21:13.923]         base::close(...future.stdout)
[10:21:13.923]         ...future.stdout <- NULL
[10:21:13.923]     }
[10:21:13.923]     ...future.result$conditions <- ...future.conditions
[10:21:13.923]     ...future.result$finished <- base::Sys.time()
[10:21:13.923]     ...future.result
[10:21:13.923] }
[10:21:13.925] Exporting 1 global objects (346 bytes) to cluster node #1 ...
[10:21:13.925] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[10:21:13.926] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[10:21:13.926] Exporting 1 global objects (346 bytes) to cluster node #1 ... DONE
[10:21:13.926] MultisessionFuture started
[10:21:13.926] - Launch lazy future ... done
[10:21:13.926] run() for ‘MultisessionFuture’ ... done
[10:21:13.927] result() for ClusterFuture ...
[10:21:13.927] receiveMessageFromWorker() for ClusterFuture ...
[10:21:13.927] - Validating connection of MultisessionFuture
[10:21:13.968] - received message: FutureResult
[10:21:13.968] - Received FutureResult
[10:21:13.968] - Erased future from FutureRegistry
[10:21:13.968] result() for ClusterFuture ...
[10:21:13.968] - result already collected: FutureResult
[10:21:13.968] result() for ClusterFuture ... done
[10:21:13.968] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:13.969] result() for ClusterFuture ... done
[10:21:13.969] result() for ClusterFuture ...
[10:21:13.969] - result already collected: FutureResult
[10:21:13.969] result() for ClusterFuture ... done
*** futureAssign() with ‘multisession’ futures ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futureAssign() - lazy = TRUE / FALSE ... DONE")
*** futureAssign() - lazy = TRUE / FALSE ... DONE
> 
> message("*** futureAssign() ... DONE")
*** futureAssign() ... DONE
> 
> source("incl/end.R")
[10:21:13.970] plan(): Setting new future strategy stack:
[10:21:13.970] List of future strategies:
[10:21:13.970] 1. FutureStrategy:
[10:21:13.970]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:13.970]    - tweaked: FALSE
[10:21:13.970]    - call: future::plan(oplan)
[10:21:13.970] plan(): nbrOfWorkers() = 1
> 
