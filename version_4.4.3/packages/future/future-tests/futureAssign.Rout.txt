
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[11:01:22.119] plan(): Setting new future strategy stack:
[11:01:22.119] List of future strategies:
[11:01:22.119] 1. sequential:
[11:01:22.119]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.119]    - tweaked: FALSE
[11:01:22.119]    - call: future::plan("sequential")
[11:01:22.132] plan(): nbrOfWorkers() = 1
> 
> message("*** futureAssign() ...")
*** futureAssign() ...
> 
> message("*** futureAssign() - sequential w/ lazy evaluation ...")
*** futureAssign() - sequential w/ lazy evaluation ...
> 
> delayedAssign("a", {
+   cat("Delayed assignment evaluated\n")
+   1
+ })
> 
> futureAssign("b", {
+   cat("Future assignment evaluated\n")
+   2
+ }, lazy = TRUE)
[11:01:22.148] getGlobalsAndPackages() ...
[11:01:22.148] Searching for globals...
[11:01:22.154] - globals found: [2] ‘{’, ‘cat’
[11:01:22.154] Searching for globals ... DONE
[11:01:22.154] Resolving globals: FALSE
[11:01:22.155] 
[11:01:22.155] 
[11:01:22.155] getGlobalsAndPackages() ... DONE
> 
> ## Because "lazy future" is used, the expression/value
> ## for 'b' will not be resolved at the point.  For other
> ## types of futures, it may already have been resolved
> cat(sprintf("b = %s\n", b))
[11:01:22.156] run() for ‘Future’ ...
[11:01:22.156] - state: ‘created’
[11:01:22.156] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:22.156] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:22.156] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:22.157]   - Field: ‘label’
[11:01:22.157]   - Field: ‘local’
[11:01:22.157]   - Field: ‘owner’
[11:01:22.157]   - Field: ‘envir’
[11:01:22.157]   - Field: ‘packages’
[11:01:22.157]   - Field: ‘gc’
[11:01:22.157]   - Field: ‘conditions’
[11:01:22.157]   - Field: ‘expr’
[11:01:22.157]   - Field: ‘uuid’
[11:01:22.157]   - Field: ‘seed’
[11:01:22.157]   - Field: ‘version’
[11:01:22.157]   - Field: ‘result’
[11:01:22.158]   - Field: ‘asynchronous’
[11:01:22.158]   - Field: ‘calls’
[11:01:22.158]   - Field: ‘globals’
[11:01:22.158]   - Field: ‘stdout’
[11:01:22.158]   - Field: ‘earlySignal’
[11:01:22.158]   - Field: ‘lazy’
[11:01:22.158]   - Field: ‘state’
[11:01:22.158] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:22.158] - Launch lazy future ...
[11:01:22.159] Packages needed by the future expression (n = 0): <none>
[11:01:22.159] Packages needed by future strategies (n = 0): <none>
[11:01:22.160] {
[11:01:22.160]     {
[11:01:22.160]         {
[11:01:22.160]             ...future.startTime <- base::Sys.time()
[11:01:22.160]             {
[11:01:22.160]                 {
[11:01:22.160]                   {
[11:01:22.160]                     base::local({
[11:01:22.160]                       has_future <- base::requireNamespace("future", 
[11:01:22.160]                         quietly = TRUE)
[11:01:22.160]                       if (has_future) {
[11:01:22.160]                         ns <- base::getNamespace("future")
[11:01:22.160]                         version <- ns[[".package"]][["version"]]
[11:01:22.160]                         if (is.null(version)) 
[11:01:22.160]                           version <- utils::packageVersion("future")
[11:01:22.160]                       }
[11:01:22.160]                       else {
[11:01:22.160]                         version <- NULL
[11:01:22.160]                       }
[11:01:22.160]                       if (!has_future || version < "1.8.0") {
[11:01:22.160]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:22.160]                           "", base::R.version$version.string), 
[11:01:22.160]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:22.160]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:22.160]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:22.160]                             "release", "version")], collapse = " "), 
[11:01:22.160]                           hostname = base::Sys.info()[["nodename"]])
[11:01:22.160]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:22.160]                           info)
[11:01:22.160]                         info <- base::paste(info, collapse = "; ")
[11:01:22.160]                         if (!has_future) {
[11:01:22.160]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:22.160]                             info)
[11:01:22.160]                         }
[11:01:22.160]                         else {
[11:01:22.160]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:22.160]                             info, version)
[11:01:22.160]                         }
[11:01:22.160]                         base::stop(msg)
[11:01:22.160]                       }
[11:01:22.160]                     })
[11:01:22.160]                   }
[11:01:22.160]                   ...future.strategy.old <- future::plan("list")
[11:01:22.160]                   options(future.plan = NULL)
[11:01:22.160]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.160]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:22.160]                 }
[11:01:22.160]                 ...future.workdir <- getwd()
[11:01:22.160]             }
[11:01:22.160]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:22.160]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:22.160]         }
[11:01:22.160]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:22.160]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:22.160]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:22.160]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:22.160]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:22.160]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:22.160]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:22.160]             base::names(...future.oldOptions))
[11:01:22.160]     }
[11:01:22.160]     if (FALSE) {
[11:01:22.160]     }
[11:01:22.160]     else {
[11:01:22.160]         if (TRUE) {
[11:01:22.160]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:22.160]                 open = "w")
[11:01:22.160]         }
[11:01:22.160]         else {
[11:01:22.160]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:22.160]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:22.160]         }
[11:01:22.160]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:22.160]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:22.160]             base::sink(type = "output", split = FALSE)
[11:01:22.160]             base::close(...future.stdout)
[11:01:22.160]         }, add = TRUE)
[11:01:22.160]     }
[11:01:22.160]     ...future.frame <- base::sys.nframe()
[11:01:22.160]     ...future.conditions <- base::list()
[11:01:22.160]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:22.160]     if (FALSE) {
[11:01:22.160]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:22.160]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:22.160]     }
[11:01:22.160]     ...future.result <- base::tryCatch({
[11:01:22.160]         base::withCallingHandlers({
[11:01:22.160]             ...future.value <- base::withVisible(base::local({
[11:01:22.160]                 cat("Future assignment evaluated\n")
[11:01:22.160]                 2
[11:01:22.160]             }))
[11:01:22.160]             future::FutureResult(value = ...future.value$value, 
[11:01:22.160]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.160]                   ...future.rng), globalenv = if (FALSE) 
[11:01:22.160]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:22.160]                     ...future.globalenv.names))
[11:01:22.160]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:22.160]         }, condition = base::local({
[11:01:22.160]             c <- base::c
[11:01:22.160]             inherits <- base::inherits
[11:01:22.160]             invokeRestart <- base::invokeRestart
[11:01:22.160]             length <- base::length
[11:01:22.160]             list <- base::list
[11:01:22.160]             seq.int <- base::seq.int
[11:01:22.160]             signalCondition <- base::signalCondition
[11:01:22.160]             sys.calls <- base::sys.calls
[11:01:22.160]             `[[` <- base::`[[`
[11:01:22.160]             `+` <- base::`+`
[11:01:22.160]             `<<-` <- base::`<<-`
[11:01:22.160]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:22.160]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:22.160]                   3L)]
[11:01:22.160]             }
[11:01:22.160]             function(cond) {
[11:01:22.160]                 is_error <- inherits(cond, "error")
[11:01:22.160]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:22.160]                   NULL)
[11:01:22.160]                 if (is_error) {
[11:01:22.160]                   sessionInformation <- function() {
[11:01:22.160]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:22.160]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:22.160]                       search = base::search(), system = base::Sys.info())
[11:01:22.160]                   }
[11:01:22.160]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.160]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:22.160]                     cond$call), session = sessionInformation(), 
[11:01:22.160]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:22.160]                   signalCondition(cond)
[11:01:22.160]                 }
[11:01:22.160]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:22.160]                 "immediateCondition"))) {
[11:01:22.160]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:22.160]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.160]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:22.160]                   if (TRUE && !signal) {
[11:01:22.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.160]                     {
[11:01:22.160]                       inherits <- base::inherits
[11:01:22.160]                       invokeRestart <- base::invokeRestart
[11:01:22.160]                       is.null <- base::is.null
[11:01:22.160]                       muffled <- FALSE
[11:01:22.160]                       if (inherits(cond, "message")) {
[11:01:22.160]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.160]                         if (muffled) 
[11:01:22.160]                           invokeRestart("muffleMessage")
[11:01:22.160]                       }
[11:01:22.160]                       else if (inherits(cond, "warning")) {
[11:01:22.160]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.160]                         if (muffled) 
[11:01:22.160]                           invokeRestart("muffleWarning")
[11:01:22.160]                       }
[11:01:22.160]                       else if (inherits(cond, "condition")) {
[11:01:22.160]                         if (!is.null(pattern)) {
[11:01:22.160]                           computeRestarts <- base::computeRestarts
[11:01:22.160]                           grepl <- base::grepl
[11:01:22.160]                           restarts <- computeRestarts(cond)
[11:01:22.160]                           for (restart in restarts) {
[11:01:22.160]                             name <- restart$name
[11:01:22.160]                             if (is.null(name)) 
[11:01:22.160]                               next
[11:01:22.160]                             if (!grepl(pattern, name)) 
[11:01:22.160]                               next
[11:01:22.160]                             invokeRestart(restart)
[11:01:22.160]                             muffled <- TRUE
[11:01:22.160]                             break
[11:01:22.160]                           }
[11:01:22.160]                         }
[11:01:22.160]                       }
[11:01:22.160]                       invisible(muffled)
[11:01:22.160]                     }
[11:01:22.160]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.160]                   }
[11:01:22.160]                 }
[11:01:22.160]                 else {
[11:01:22.160]                   if (TRUE) {
[11:01:22.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.160]                     {
[11:01:22.160]                       inherits <- base::inherits
[11:01:22.160]                       invokeRestart <- base::invokeRestart
[11:01:22.160]                       is.null <- base::is.null
[11:01:22.160]                       muffled <- FALSE
[11:01:22.160]                       if (inherits(cond, "message")) {
[11:01:22.160]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.160]                         if (muffled) 
[11:01:22.160]                           invokeRestart("muffleMessage")
[11:01:22.160]                       }
[11:01:22.160]                       else if (inherits(cond, "warning")) {
[11:01:22.160]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.160]                         if (muffled) 
[11:01:22.160]                           invokeRestart("muffleWarning")
[11:01:22.160]                       }
[11:01:22.160]                       else if (inherits(cond, "condition")) {
[11:01:22.160]                         if (!is.null(pattern)) {
[11:01:22.160]                           computeRestarts <- base::computeRestarts
[11:01:22.160]                           grepl <- base::grepl
[11:01:22.160]                           restarts <- computeRestarts(cond)
[11:01:22.160]                           for (restart in restarts) {
[11:01:22.160]                             name <- restart$name
[11:01:22.160]                             if (is.null(name)) 
[11:01:22.160]                               next
[11:01:22.160]                             if (!grepl(pattern, name)) 
[11:01:22.160]                               next
[11:01:22.160]                             invokeRestart(restart)
[11:01:22.160]                             muffled <- TRUE
[11:01:22.160]                             break
[11:01:22.160]                           }
[11:01:22.160]                         }
[11:01:22.160]                       }
[11:01:22.160]                       invisible(muffled)
[11:01:22.160]                     }
[11:01:22.160]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.160]                   }
[11:01:22.160]                 }
[11:01:22.160]             }
[11:01:22.160]         }))
[11:01:22.160]     }, error = function(ex) {
[11:01:22.160]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:22.160]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.160]                 ...future.rng), started = ...future.startTime, 
[11:01:22.160]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:22.160]             version = "1.8"), class = "FutureResult")
[11:01:22.160]     }, finally = {
[11:01:22.160]         if (!identical(...future.workdir, getwd())) 
[11:01:22.160]             setwd(...future.workdir)
[11:01:22.160]         {
[11:01:22.160]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:22.160]                 ...future.oldOptions$nwarnings <- NULL
[11:01:22.160]             }
[11:01:22.160]             base::options(...future.oldOptions)
[11:01:22.160]             if (.Platform$OS.type == "windows") {
[11:01:22.160]                 old_names <- names(...future.oldEnvVars)
[11:01:22.160]                 envs <- base::Sys.getenv()
[11:01:22.160]                 names <- names(envs)
[11:01:22.160]                 common <- intersect(names, old_names)
[11:01:22.160]                 added <- setdiff(names, old_names)
[11:01:22.160]                 removed <- setdiff(old_names, names)
[11:01:22.160]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:22.160]                   envs[common]]
[11:01:22.160]                 NAMES <- toupper(changed)
[11:01:22.160]                 args <- list()
[11:01:22.160]                 for (kk in seq_along(NAMES)) {
[11:01:22.160]                   name <- changed[[kk]]
[11:01:22.160]                   NAME <- NAMES[[kk]]
[11:01:22.160]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.160]                     next
[11:01:22.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.160]                 }
[11:01:22.160]                 NAMES <- toupper(added)
[11:01:22.160]                 for (kk in seq_along(NAMES)) {
[11:01:22.160]                   name <- added[[kk]]
[11:01:22.160]                   NAME <- NAMES[[kk]]
[11:01:22.160]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.160]                     next
[11:01:22.160]                   args[[name]] <- ""
[11:01:22.160]                 }
[11:01:22.160]                 NAMES <- toupper(removed)
[11:01:22.160]                 for (kk in seq_along(NAMES)) {
[11:01:22.160]                   name <- removed[[kk]]
[11:01:22.160]                   NAME <- NAMES[[kk]]
[11:01:22.160]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.160]                     next
[11:01:22.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.160]                 }
[11:01:22.160]                 if (length(args) > 0) 
[11:01:22.160]                   base::do.call(base::Sys.setenv, args = args)
[11:01:22.160]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:22.160]             }
[11:01:22.160]             else {
[11:01:22.160]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:22.160]             }
[11:01:22.160]             {
[11:01:22.160]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:22.160]                   0L) {
[11:01:22.160]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:22.160]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:22.160]                   base::options(opts)
[11:01:22.160]                 }
[11:01:22.160]                 {
[11:01:22.160]                   {
[11:01:22.160]                     NULL
[11:01:22.160]                     RNGkind("Mersenne-Twister")
[11:01:22.160]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:22.160]                       inherits = FALSE)
[11:01:22.160]                   }
[11:01:22.160]                   options(future.plan = NULL)
[11:01:22.160]                   if (is.na(NA_character_)) 
[11:01:22.160]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.160]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:22.160]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:22.160]                     .init = FALSE)
[11:01:22.160]                 }
[11:01:22.160]             }
[11:01:22.160]         }
[11:01:22.160]     })
[11:01:22.160]     if (TRUE) {
[11:01:22.160]         base::sink(type = "output", split = FALSE)
[11:01:22.160]         if (TRUE) {
[11:01:22.160]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:22.160]         }
[11:01:22.160]         else {
[11:01:22.160]             ...future.result["stdout"] <- base::list(NULL)
[11:01:22.160]         }
[11:01:22.160]         base::close(...future.stdout)
[11:01:22.160]         ...future.stdout <- NULL
[11:01:22.160]     }
[11:01:22.160]     ...future.result$conditions <- ...future.conditions
[11:01:22.160]     ...future.result$finished <- base::Sys.time()
[11:01:22.160]     ...future.result
[11:01:22.160] }
[11:01:22.162] plan(): Setting new future strategy stack:
[11:01:22.162] List of future strategies:
[11:01:22.162] 1. sequential:
[11:01:22.162]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.162]    - tweaked: FALSE
[11:01:22.162]    - call: NULL
[11:01:22.162] plan(): nbrOfWorkers() = 1
[11:01:22.163] plan(): Setting new future strategy stack:
[11:01:22.163] List of future strategies:
[11:01:22.163] 1. sequential:
[11:01:22.163]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.163]    - tweaked: FALSE
[11:01:22.163]    - call: future::plan("sequential")
[11:01:22.164] plan(): nbrOfWorkers() = 1
[11:01:22.164] SequentialFuture started (and completed)
[11:01:22.164] - Launch lazy future ... done
[11:01:22.164] run() for ‘SequentialFuture’ ... done
Future assignment evaluated
b = 2
> 
> ## The expression/value of 'a' is resolved at this point,
> ## because a delayed assignment (promise) was used.
> cat(sprintf("a = %s\n", a))
Delayed assignment evaluated
a = 1
> 
> stopifnot(identical(a, 1))
> stopifnot(identical(b, 2))
> 
> message("*** futureAssign() - sequential w/ lazy evaluation ... DONE")
*** futureAssign() - sequential w/ lazy evaluation ... DONE
> 
> 
> message("*** futureAssign() - lazy = TRUE / FALSE ...")
*** futureAssign() - lazy = TRUE / FALSE ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("*** futureAssign() with %s futures ...", sQuote(strategy)))
+     plan(strategy)
+ 
+     ## Potential task name clashes
+     u <- new.env()
+     v <- new.env()
+     futureAssign("a", { 2 }, assign.env = u)
+     futureAssign("a", { 4 }, assign.env = v)
+     
+     cat(sprintf("u$a = %s\n", u$a))
+     cat(sprintf("v$a = %s\n", v$a))
+     
+     stopifnot(identical(u$a, 2))
+     stopifnot(identical(v$a, 4))
+     
+     
+     ## Global variables
+     a <- 1
+     futureAssign("b", { 2 * a })
+     a <- 2
+     stopifnot(b == 2)
+ 
+     ## Explicit lazy evaluation
+     for (lazy in c(FALSE, TRUE)) {
+       a <- 1
+       f <- futureAssign("b", { 2 * a }, lazy = lazy)
+       a <- 2
+       stopifnot(b == 2)
+       stopifnot(f$lazy == lazy || (strategy %in% c("multisession", "multicore") && cores == 1L))
+       
+       ## Set 'lazy' via disposable option
+       options(future.disposable = list(lazy = lazy))
+       a <- 1
+       f <- futureAssign("b", { 2 * a })
+       a <- 2
+       stopifnot(b == 2)
+       stopifnot(f$lazy == lazy || (strategy %in% c("multisession", "multicore") && cores == 1L))
+     }
+ 
+     message(sprintf("*** futureAssign() with %s futures ... DONE", sQuote(strategy)))
+   } # for (strategy in ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
*** futureAssign() with ‘sequential’ futures ...
[11:01:22.189] plan(): Setting new future strategy stack:
[11:01:22.189] List of future strategies:
[11:01:22.189] 1. sequential:
[11:01:22.189]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.189]    - tweaked: FALSE
[11:01:22.189]    - call: plan(strategy)
[11:01:22.201] plan(): nbrOfWorkers() = 1
[11:01:22.201] getGlobalsAndPackages() ...
[11:01:22.201] Searching for globals...
[11:01:22.201] - globals found: [1] ‘{’
[11:01:22.201] Searching for globals ... DONE
[11:01:22.202] Resolving globals: FALSE
[11:01:22.202] 
[11:01:22.202] 
[11:01:22.202] getGlobalsAndPackages() ... DONE
[11:01:22.202] run() for ‘Future’ ...
[11:01:22.202] - state: ‘created’
[11:01:22.202] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:22.203] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:22.203] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:22.203]   - Field: ‘label’
[11:01:22.203]   - Field: ‘local’
[11:01:22.203]   - Field: ‘owner’
[11:01:22.203]   - Field: ‘envir’
[11:01:22.203]   - Field: ‘packages’
[11:01:22.203]   - Field: ‘gc’
[11:01:22.203]   - Field: ‘conditions’
[11:01:22.203]   - Field: ‘expr’
[11:01:22.203]   - Field: ‘uuid’
[11:01:22.204]   - Field: ‘seed’
[11:01:22.204]   - Field: ‘version’
[11:01:22.204]   - Field: ‘result’
[11:01:22.204]   - Field: ‘asynchronous’
[11:01:22.204]   - Field: ‘calls’
[11:01:22.204]   - Field: ‘globals’
[11:01:22.204]   - Field: ‘stdout’
[11:01:22.204]   - Field: ‘earlySignal’
[11:01:22.204]   - Field: ‘lazy’
[11:01:22.204]   - Field: ‘state’
[11:01:22.204] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:22.204] - Launch lazy future ...
[11:01:22.205] Packages needed by the future expression (n = 0): <none>
[11:01:22.205] Packages needed by future strategies (n = 0): <none>
[11:01:22.205] {
[11:01:22.205]     {
[11:01:22.205]         {
[11:01:22.205]             ...future.startTime <- base::Sys.time()
[11:01:22.205]             {
[11:01:22.205]                 {
[11:01:22.205]                   {
[11:01:22.205]                     base::local({
[11:01:22.205]                       has_future <- base::requireNamespace("future", 
[11:01:22.205]                         quietly = TRUE)
[11:01:22.205]                       if (has_future) {
[11:01:22.205]                         ns <- base::getNamespace("future")
[11:01:22.205]                         version <- ns[[".package"]][["version"]]
[11:01:22.205]                         if (is.null(version)) 
[11:01:22.205]                           version <- utils::packageVersion("future")
[11:01:22.205]                       }
[11:01:22.205]                       else {
[11:01:22.205]                         version <- NULL
[11:01:22.205]                       }
[11:01:22.205]                       if (!has_future || version < "1.8.0") {
[11:01:22.205]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:22.205]                           "", base::R.version$version.string), 
[11:01:22.205]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:22.205]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:22.205]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:22.205]                             "release", "version")], collapse = " "), 
[11:01:22.205]                           hostname = base::Sys.info()[["nodename"]])
[11:01:22.205]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:22.205]                           info)
[11:01:22.205]                         info <- base::paste(info, collapse = "; ")
[11:01:22.205]                         if (!has_future) {
[11:01:22.205]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:22.205]                             info)
[11:01:22.205]                         }
[11:01:22.205]                         else {
[11:01:22.205]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:22.205]                             info, version)
[11:01:22.205]                         }
[11:01:22.205]                         base::stop(msg)
[11:01:22.205]                       }
[11:01:22.205]                     })
[11:01:22.205]                   }
[11:01:22.205]                   ...future.strategy.old <- future::plan("list")
[11:01:22.205]                   options(future.plan = NULL)
[11:01:22.205]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.205]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:22.205]                 }
[11:01:22.205]                 ...future.workdir <- getwd()
[11:01:22.205]             }
[11:01:22.205]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:22.205]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:22.205]         }
[11:01:22.205]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:22.205]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:22.205]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:22.205]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:22.205]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:22.205]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:22.205]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:22.205]             base::names(...future.oldOptions))
[11:01:22.205]     }
[11:01:22.205]     if (FALSE) {
[11:01:22.205]     }
[11:01:22.205]     else {
[11:01:22.205]         if (TRUE) {
[11:01:22.205]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:22.205]                 open = "w")
[11:01:22.205]         }
[11:01:22.205]         else {
[11:01:22.205]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:22.205]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:22.205]         }
[11:01:22.205]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:22.205]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:22.205]             base::sink(type = "output", split = FALSE)
[11:01:22.205]             base::close(...future.stdout)
[11:01:22.205]         }, add = TRUE)
[11:01:22.205]     }
[11:01:22.205]     ...future.frame <- base::sys.nframe()
[11:01:22.205]     ...future.conditions <- base::list()
[11:01:22.205]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:22.205]     if (FALSE) {
[11:01:22.205]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:22.205]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:22.205]     }
[11:01:22.205]     ...future.result <- base::tryCatch({
[11:01:22.205]         base::withCallingHandlers({
[11:01:22.205]             ...future.value <- base::withVisible(base::local({
[11:01:22.205]                 2
[11:01:22.205]             }))
[11:01:22.205]             future::FutureResult(value = ...future.value$value, 
[11:01:22.205]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.205]                   ...future.rng), globalenv = if (FALSE) 
[11:01:22.205]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:22.205]                     ...future.globalenv.names))
[11:01:22.205]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:22.205]         }, condition = base::local({
[11:01:22.205]             c <- base::c
[11:01:22.205]             inherits <- base::inherits
[11:01:22.205]             invokeRestart <- base::invokeRestart
[11:01:22.205]             length <- base::length
[11:01:22.205]             list <- base::list
[11:01:22.205]             seq.int <- base::seq.int
[11:01:22.205]             signalCondition <- base::signalCondition
[11:01:22.205]             sys.calls <- base::sys.calls
[11:01:22.205]             `[[` <- base::`[[`
[11:01:22.205]             `+` <- base::`+`
[11:01:22.205]             `<<-` <- base::`<<-`
[11:01:22.205]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:22.205]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:22.205]                   3L)]
[11:01:22.205]             }
[11:01:22.205]             function(cond) {
[11:01:22.205]                 is_error <- inherits(cond, "error")
[11:01:22.205]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:22.205]                   NULL)
[11:01:22.205]                 if (is_error) {
[11:01:22.205]                   sessionInformation <- function() {
[11:01:22.205]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:22.205]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:22.205]                       search = base::search(), system = base::Sys.info())
[11:01:22.205]                   }
[11:01:22.205]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.205]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:22.205]                     cond$call), session = sessionInformation(), 
[11:01:22.205]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:22.205]                   signalCondition(cond)
[11:01:22.205]                 }
[11:01:22.205]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:22.205]                 "immediateCondition"))) {
[11:01:22.205]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:22.205]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.205]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:22.205]                   if (TRUE && !signal) {
[11:01:22.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.205]                     {
[11:01:22.205]                       inherits <- base::inherits
[11:01:22.205]                       invokeRestart <- base::invokeRestart
[11:01:22.205]                       is.null <- base::is.null
[11:01:22.205]                       muffled <- FALSE
[11:01:22.205]                       if (inherits(cond, "message")) {
[11:01:22.205]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.205]                         if (muffled) 
[11:01:22.205]                           invokeRestart("muffleMessage")
[11:01:22.205]                       }
[11:01:22.205]                       else if (inherits(cond, "warning")) {
[11:01:22.205]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.205]                         if (muffled) 
[11:01:22.205]                           invokeRestart("muffleWarning")
[11:01:22.205]                       }
[11:01:22.205]                       else if (inherits(cond, "condition")) {
[11:01:22.205]                         if (!is.null(pattern)) {
[11:01:22.205]                           computeRestarts <- base::computeRestarts
[11:01:22.205]                           grepl <- base::grepl
[11:01:22.205]                           restarts <- computeRestarts(cond)
[11:01:22.205]                           for (restart in restarts) {
[11:01:22.205]                             name <- restart$name
[11:01:22.205]                             if (is.null(name)) 
[11:01:22.205]                               next
[11:01:22.205]                             if (!grepl(pattern, name)) 
[11:01:22.205]                               next
[11:01:22.205]                             invokeRestart(restart)
[11:01:22.205]                             muffled <- TRUE
[11:01:22.205]                             break
[11:01:22.205]                           }
[11:01:22.205]                         }
[11:01:22.205]                       }
[11:01:22.205]                       invisible(muffled)
[11:01:22.205]                     }
[11:01:22.205]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.205]                   }
[11:01:22.205]                 }
[11:01:22.205]                 else {
[11:01:22.205]                   if (TRUE) {
[11:01:22.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.205]                     {
[11:01:22.205]                       inherits <- base::inherits
[11:01:22.205]                       invokeRestart <- base::invokeRestart
[11:01:22.205]                       is.null <- base::is.null
[11:01:22.205]                       muffled <- FALSE
[11:01:22.205]                       if (inherits(cond, "message")) {
[11:01:22.205]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.205]                         if (muffled) 
[11:01:22.205]                           invokeRestart("muffleMessage")
[11:01:22.205]                       }
[11:01:22.205]                       else if (inherits(cond, "warning")) {
[11:01:22.205]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.205]                         if (muffled) 
[11:01:22.205]                           invokeRestart("muffleWarning")
[11:01:22.205]                       }
[11:01:22.205]                       else if (inherits(cond, "condition")) {
[11:01:22.205]                         if (!is.null(pattern)) {
[11:01:22.205]                           computeRestarts <- base::computeRestarts
[11:01:22.205]                           grepl <- base::grepl
[11:01:22.205]                           restarts <- computeRestarts(cond)
[11:01:22.205]                           for (restart in restarts) {
[11:01:22.205]                             name <- restart$name
[11:01:22.205]                             if (is.null(name)) 
[11:01:22.205]                               next
[11:01:22.205]                             if (!grepl(pattern, name)) 
[11:01:22.205]                               next
[11:01:22.205]                             invokeRestart(restart)
[11:01:22.205]                             muffled <- TRUE
[11:01:22.205]                             break
[11:01:22.205]                           }
[11:01:22.205]                         }
[11:01:22.205]                       }
[11:01:22.205]                       invisible(muffled)
[11:01:22.205]                     }
[11:01:22.205]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.205]                   }
[11:01:22.205]                 }
[11:01:22.205]             }
[11:01:22.205]         }))
[11:01:22.205]     }, error = function(ex) {
[11:01:22.205]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:22.205]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.205]                 ...future.rng), started = ...future.startTime, 
[11:01:22.205]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:22.205]             version = "1.8"), class = "FutureResult")
[11:01:22.205]     }, finally = {
[11:01:22.205]         if (!identical(...future.workdir, getwd())) 
[11:01:22.205]             setwd(...future.workdir)
[11:01:22.205]         {
[11:01:22.205]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:22.205]                 ...future.oldOptions$nwarnings <- NULL
[11:01:22.205]             }
[11:01:22.205]             base::options(...future.oldOptions)
[11:01:22.205]             if (.Platform$OS.type == "windows") {
[11:01:22.205]                 old_names <- names(...future.oldEnvVars)
[11:01:22.205]                 envs <- base::Sys.getenv()
[11:01:22.205]                 names <- names(envs)
[11:01:22.205]                 common <- intersect(names, old_names)
[11:01:22.205]                 added <- setdiff(names, old_names)
[11:01:22.205]                 removed <- setdiff(old_names, names)
[11:01:22.205]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:22.205]                   envs[common]]
[11:01:22.205]                 NAMES <- toupper(changed)
[11:01:22.205]                 args <- list()
[11:01:22.205]                 for (kk in seq_along(NAMES)) {
[11:01:22.205]                   name <- changed[[kk]]
[11:01:22.205]                   NAME <- NAMES[[kk]]
[11:01:22.205]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.205]                     next
[11:01:22.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.205]                 }
[11:01:22.205]                 NAMES <- toupper(added)
[11:01:22.205]                 for (kk in seq_along(NAMES)) {
[11:01:22.205]                   name <- added[[kk]]
[11:01:22.205]                   NAME <- NAMES[[kk]]
[11:01:22.205]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.205]                     next
[11:01:22.205]                   args[[name]] <- ""
[11:01:22.205]                 }
[11:01:22.205]                 NAMES <- toupper(removed)
[11:01:22.205]                 for (kk in seq_along(NAMES)) {
[11:01:22.205]                   name <- removed[[kk]]
[11:01:22.205]                   NAME <- NAMES[[kk]]
[11:01:22.205]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.205]                     next
[11:01:22.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.205]                 }
[11:01:22.205]                 if (length(args) > 0) 
[11:01:22.205]                   base::do.call(base::Sys.setenv, args = args)
[11:01:22.205]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:22.205]             }
[11:01:22.205]             else {
[11:01:22.205]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:22.205]             }
[11:01:22.205]             {
[11:01:22.205]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:22.205]                   0L) {
[11:01:22.205]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:22.205]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:22.205]                   base::options(opts)
[11:01:22.205]                 }
[11:01:22.205]                 {
[11:01:22.205]                   {
[11:01:22.205]                     NULL
[11:01:22.205]                     RNGkind("Mersenne-Twister")
[11:01:22.205]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:22.205]                       inherits = FALSE)
[11:01:22.205]                   }
[11:01:22.205]                   options(future.plan = NULL)
[11:01:22.205]                   if (is.na(NA_character_)) 
[11:01:22.205]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.205]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:22.205]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:22.205]                     .init = FALSE)
[11:01:22.205]                 }
[11:01:22.205]             }
[11:01:22.205]         }
[11:01:22.205]     })
[11:01:22.205]     if (TRUE) {
[11:01:22.205]         base::sink(type = "output", split = FALSE)
[11:01:22.205]         if (TRUE) {
[11:01:22.205]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:22.205]         }
[11:01:22.205]         else {
[11:01:22.205]             ...future.result["stdout"] <- base::list(NULL)
[11:01:22.205]         }
[11:01:22.205]         base::close(...future.stdout)
[11:01:22.205]         ...future.stdout <- NULL
[11:01:22.205]     }
[11:01:22.205]     ...future.result$conditions <- ...future.conditions
[11:01:22.205]     ...future.result$finished <- base::Sys.time()
[11:01:22.205]     ...future.result
[11:01:22.205] }
[11:01:22.207] plan(): Setting new future strategy stack:
[11:01:22.207] List of future strategies:
[11:01:22.207] 1. sequential:
[11:01:22.207]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.207]    - tweaked: FALSE
[11:01:22.207]    - call: NULL
[11:01:22.207] plan(): nbrOfWorkers() = 1
[11:01:22.208] plan(): Setting new future strategy stack:
[11:01:22.208] List of future strategies:
[11:01:22.208] 1. sequential:
[11:01:22.208]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.208]    - tweaked: FALSE
[11:01:22.208]    - call: plan(strategy)
[11:01:22.209] plan(): nbrOfWorkers() = 1
[11:01:22.209] SequentialFuture started (and completed)
[11:01:22.209] - Launch lazy future ... done
[11:01:22.209] run() for ‘SequentialFuture’ ... done
[11:01:22.209] getGlobalsAndPackages() ...
[11:01:22.209] Searching for globals...
[11:01:22.210] - globals found: [1] ‘{’
[11:01:22.210] Searching for globals ... DONE
[11:01:22.210] Resolving globals: FALSE
[11:01:22.210] 
[11:01:22.210] 
[11:01:22.210] getGlobalsAndPackages() ... DONE
[11:01:22.210] run() for ‘Future’ ...
[11:01:22.210] - state: ‘created’
[11:01:22.211] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:22.211] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:22.211] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:22.211]   - Field: ‘label’
[11:01:22.211]   - Field: ‘local’
[11:01:22.211]   - Field: ‘owner’
[11:01:22.211]   - Field: ‘envir’
[11:01:22.211]   - Field: ‘packages’
[11:01:22.211]   - Field: ‘gc’
[11:01:22.212]   - Field: ‘conditions’
[11:01:22.212]   - Field: ‘expr’
[11:01:22.212]   - Field: ‘uuid’
[11:01:22.212]   - Field: ‘seed’
[11:01:22.212]   - Field: ‘version’
[11:01:22.212]   - Field: ‘result’
[11:01:22.212]   - Field: ‘asynchronous’
[11:01:22.212]   - Field: ‘calls’
[11:01:22.212]   - Field: ‘globals’
[11:01:22.212]   - Field: ‘stdout’
[11:01:22.212]   - Field: ‘earlySignal’
[11:01:22.212]   - Field: ‘lazy’
[11:01:22.212]   - Field: ‘state’
[11:01:22.213] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:22.213] - Launch lazy future ...
[11:01:22.213] Packages needed by the future expression (n = 0): <none>
[11:01:22.213] Packages needed by future strategies (n = 0): <none>
[11:01:22.213] {
[11:01:22.213]     {
[11:01:22.213]         {
[11:01:22.213]             ...future.startTime <- base::Sys.time()
[11:01:22.213]             {
[11:01:22.213]                 {
[11:01:22.213]                   {
[11:01:22.213]                     base::local({
[11:01:22.213]                       has_future <- base::requireNamespace("future", 
[11:01:22.213]                         quietly = TRUE)
[11:01:22.213]                       if (has_future) {
[11:01:22.213]                         ns <- base::getNamespace("future")
[11:01:22.213]                         version <- ns[[".package"]][["version"]]
[11:01:22.213]                         if (is.null(version)) 
[11:01:22.213]                           version <- utils::packageVersion("future")
[11:01:22.213]                       }
[11:01:22.213]                       else {
[11:01:22.213]                         version <- NULL
[11:01:22.213]                       }
[11:01:22.213]                       if (!has_future || version < "1.8.0") {
[11:01:22.213]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:22.213]                           "", base::R.version$version.string), 
[11:01:22.213]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:22.213]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:22.213]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:22.213]                             "release", "version")], collapse = " "), 
[11:01:22.213]                           hostname = base::Sys.info()[["nodename"]])
[11:01:22.213]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:22.213]                           info)
[11:01:22.213]                         info <- base::paste(info, collapse = "; ")
[11:01:22.213]                         if (!has_future) {
[11:01:22.213]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:22.213]                             info)
[11:01:22.213]                         }
[11:01:22.213]                         else {
[11:01:22.213]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:22.213]                             info, version)
[11:01:22.213]                         }
[11:01:22.213]                         base::stop(msg)
[11:01:22.213]                       }
[11:01:22.213]                     })
[11:01:22.213]                   }
[11:01:22.213]                   ...future.strategy.old <- future::plan("list")
[11:01:22.213]                   options(future.plan = NULL)
[11:01:22.213]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.213]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:22.213]                 }
[11:01:22.213]                 ...future.workdir <- getwd()
[11:01:22.213]             }
[11:01:22.213]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:22.213]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:22.213]         }
[11:01:22.213]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:22.213]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:22.213]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:22.213]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:22.213]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:22.213]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:22.213]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:22.213]             base::names(...future.oldOptions))
[11:01:22.213]     }
[11:01:22.213]     if (FALSE) {
[11:01:22.213]     }
[11:01:22.213]     else {
[11:01:22.213]         if (TRUE) {
[11:01:22.213]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:22.213]                 open = "w")
[11:01:22.213]         }
[11:01:22.213]         else {
[11:01:22.213]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:22.213]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:22.213]         }
[11:01:22.213]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:22.213]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:22.213]             base::sink(type = "output", split = FALSE)
[11:01:22.213]             base::close(...future.stdout)
[11:01:22.213]         }, add = TRUE)
[11:01:22.213]     }
[11:01:22.213]     ...future.frame <- base::sys.nframe()
[11:01:22.213]     ...future.conditions <- base::list()
[11:01:22.213]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:22.213]     if (FALSE) {
[11:01:22.213]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:22.213]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:22.213]     }
[11:01:22.213]     ...future.result <- base::tryCatch({
[11:01:22.213]         base::withCallingHandlers({
[11:01:22.213]             ...future.value <- base::withVisible(base::local({
[11:01:22.213]                 4
[11:01:22.213]             }))
[11:01:22.213]             future::FutureResult(value = ...future.value$value, 
[11:01:22.213]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.213]                   ...future.rng), globalenv = if (FALSE) 
[11:01:22.213]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:22.213]                     ...future.globalenv.names))
[11:01:22.213]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:22.213]         }, condition = base::local({
[11:01:22.213]             c <- base::c
[11:01:22.213]             inherits <- base::inherits
[11:01:22.213]             invokeRestart <- base::invokeRestart
[11:01:22.213]             length <- base::length
[11:01:22.213]             list <- base::list
[11:01:22.213]             seq.int <- base::seq.int
[11:01:22.213]             signalCondition <- base::signalCondition
[11:01:22.213]             sys.calls <- base::sys.calls
[11:01:22.213]             `[[` <- base::`[[`
[11:01:22.213]             `+` <- base::`+`
[11:01:22.213]             `<<-` <- base::`<<-`
[11:01:22.213]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:22.213]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:22.213]                   3L)]
[11:01:22.213]             }
[11:01:22.213]             function(cond) {
[11:01:22.213]                 is_error <- inherits(cond, "error")
[11:01:22.213]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:22.213]                   NULL)
[11:01:22.213]                 if (is_error) {
[11:01:22.213]                   sessionInformation <- function() {
[11:01:22.213]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:22.213]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:22.213]                       search = base::search(), system = base::Sys.info())
[11:01:22.213]                   }
[11:01:22.213]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.213]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:22.213]                     cond$call), session = sessionInformation(), 
[11:01:22.213]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:22.213]                   signalCondition(cond)
[11:01:22.213]                 }
[11:01:22.213]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:22.213]                 "immediateCondition"))) {
[11:01:22.213]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:22.213]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.213]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:22.213]                   if (TRUE && !signal) {
[11:01:22.213]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.213]                     {
[11:01:22.213]                       inherits <- base::inherits
[11:01:22.213]                       invokeRestart <- base::invokeRestart
[11:01:22.213]                       is.null <- base::is.null
[11:01:22.213]                       muffled <- FALSE
[11:01:22.213]                       if (inherits(cond, "message")) {
[11:01:22.213]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.213]                         if (muffled) 
[11:01:22.213]                           invokeRestart("muffleMessage")
[11:01:22.213]                       }
[11:01:22.213]                       else if (inherits(cond, "warning")) {
[11:01:22.213]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.213]                         if (muffled) 
[11:01:22.213]                           invokeRestart("muffleWarning")
[11:01:22.213]                       }
[11:01:22.213]                       else if (inherits(cond, "condition")) {
[11:01:22.213]                         if (!is.null(pattern)) {
[11:01:22.213]                           computeRestarts <- base::computeRestarts
[11:01:22.213]                           grepl <- base::grepl
[11:01:22.213]                           restarts <- computeRestarts(cond)
[11:01:22.213]                           for (restart in restarts) {
[11:01:22.213]                             name <- restart$name
[11:01:22.213]                             if (is.null(name)) 
[11:01:22.213]                               next
[11:01:22.213]                             if (!grepl(pattern, name)) 
[11:01:22.213]                               next
[11:01:22.213]                             invokeRestart(restart)
[11:01:22.213]                             muffled <- TRUE
[11:01:22.213]                             break
[11:01:22.213]                           }
[11:01:22.213]                         }
[11:01:22.213]                       }
[11:01:22.213]                       invisible(muffled)
[11:01:22.213]                     }
[11:01:22.213]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.213]                   }
[11:01:22.213]                 }
[11:01:22.213]                 else {
[11:01:22.213]                   if (TRUE) {
[11:01:22.213]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.213]                     {
[11:01:22.213]                       inherits <- base::inherits
[11:01:22.213]                       invokeRestart <- base::invokeRestart
[11:01:22.213]                       is.null <- base::is.null
[11:01:22.213]                       muffled <- FALSE
[11:01:22.213]                       if (inherits(cond, "message")) {
[11:01:22.213]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.213]                         if (muffled) 
[11:01:22.213]                           invokeRestart("muffleMessage")
[11:01:22.213]                       }
[11:01:22.213]                       else if (inherits(cond, "warning")) {
[11:01:22.213]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.213]                         if (muffled) 
[11:01:22.213]                           invokeRestart("muffleWarning")
[11:01:22.213]                       }
[11:01:22.213]                       else if (inherits(cond, "condition")) {
[11:01:22.213]                         if (!is.null(pattern)) {
[11:01:22.213]                           computeRestarts <- base::computeRestarts
[11:01:22.213]                           grepl <- base::grepl
[11:01:22.213]                           restarts <- computeRestarts(cond)
[11:01:22.213]                           for (restart in restarts) {
[11:01:22.213]                             name <- restart$name
[11:01:22.213]                             if (is.null(name)) 
[11:01:22.213]                               next
[11:01:22.213]                             if (!grepl(pattern, name)) 
[11:01:22.213]                               next
[11:01:22.213]                             invokeRestart(restart)
[11:01:22.213]                             muffled <- TRUE
[11:01:22.213]                             break
[11:01:22.213]                           }
[11:01:22.213]                         }
[11:01:22.213]                       }
[11:01:22.213]                       invisible(muffled)
[11:01:22.213]                     }
[11:01:22.213]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.213]                   }
[11:01:22.213]                 }
[11:01:22.213]             }
[11:01:22.213]         }))
[11:01:22.213]     }, error = function(ex) {
[11:01:22.213]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:22.213]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.213]                 ...future.rng), started = ...future.startTime, 
[11:01:22.213]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:22.213]             version = "1.8"), class = "FutureResult")
[11:01:22.213]     }, finally = {
[11:01:22.213]         if (!identical(...future.workdir, getwd())) 
[11:01:22.213]             setwd(...future.workdir)
[11:01:22.213]         {
[11:01:22.213]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:22.213]                 ...future.oldOptions$nwarnings <- NULL
[11:01:22.213]             }
[11:01:22.213]             base::options(...future.oldOptions)
[11:01:22.213]             if (.Platform$OS.type == "windows") {
[11:01:22.213]                 old_names <- names(...future.oldEnvVars)
[11:01:22.213]                 envs <- base::Sys.getenv()
[11:01:22.213]                 names <- names(envs)
[11:01:22.213]                 common <- intersect(names, old_names)
[11:01:22.213]                 added <- setdiff(names, old_names)
[11:01:22.213]                 removed <- setdiff(old_names, names)
[11:01:22.213]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:22.213]                   envs[common]]
[11:01:22.213]                 NAMES <- toupper(changed)
[11:01:22.213]                 args <- list()
[11:01:22.213]                 for (kk in seq_along(NAMES)) {
[11:01:22.213]                   name <- changed[[kk]]
[11:01:22.213]                   NAME <- NAMES[[kk]]
[11:01:22.213]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.213]                     next
[11:01:22.213]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.213]                 }
[11:01:22.213]                 NAMES <- toupper(added)
[11:01:22.213]                 for (kk in seq_along(NAMES)) {
[11:01:22.213]                   name <- added[[kk]]
[11:01:22.213]                   NAME <- NAMES[[kk]]
[11:01:22.213]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.213]                     next
[11:01:22.213]                   args[[name]] <- ""
[11:01:22.213]                 }
[11:01:22.213]                 NAMES <- toupper(removed)
[11:01:22.213]                 for (kk in seq_along(NAMES)) {
[11:01:22.213]                   name <- removed[[kk]]
[11:01:22.213]                   NAME <- NAMES[[kk]]
[11:01:22.213]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.213]                     next
[11:01:22.213]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.213]                 }
[11:01:22.213]                 if (length(args) > 0) 
[11:01:22.213]                   base::do.call(base::Sys.setenv, args = args)
[11:01:22.213]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:22.213]             }
[11:01:22.213]             else {
[11:01:22.213]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:22.213]             }
[11:01:22.213]             {
[11:01:22.213]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:22.213]                   0L) {
[11:01:22.213]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:22.213]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:22.213]                   base::options(opts)
[11:01:22.213]                 }
[11:01:22.213]                 {
[11:01:22.213]                   {
[11:01:22.213]                     NULL
[11:01:22.213]                     RNGkind("Mersenne-Twister")
[11:01:22.213]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:22.213]                       inherits = FALSE)
[11:01:22.213]                   }
[11:01:22.213]                   options(future.plan = NULL)
[11:01:22.213]                   if (is.na(NA_character_)) 
[11:01:22.213]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.213]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:22.213]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:22.213]                     .init = FALSE)
[11:01:22.213]                 }
[11:01:22.213]             }
[11:01:22.213]         }
[11:01:22.213]     })
[11:01:22.213]     if (TRUE) {
[11:01:22.213]         base::sink(type = "output", split = FALSE)
[11:01:22.213]         if (TRUE) {
[11:01:22.213]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:22.213]         }
[11:01:22.213]         else {
[11:01:22.213]             ...future.result["stdout"] <- base::list(NULL)
[11:01:22.213]         }
[11:01:22.213]         base::close(...future.stdout)
[11:01:22.213]         ...future.stdout <- NULL
[11:01:22.213]     }
[11:01:22.213]     ...future.result$conditions <- ...future.conditions
[11:01:22.213]     ...future.result$finished <- base::Sys.time()
[11:01:22.213]     ...future.result
[11:01:22.213] }
[11:01:22.215] plan(): Setting new future strategy stack:
[11:01:22.215] List of future strategies:
[11:01:22.215] 1. sequential:
[11:01:22.215]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.215]    - tweaked: FALSE
[11:01:22.215]    - call: NULL
[11:01:22.215] plan(): nbrOfWorkers() = 1
[11:01:22.216] plan(): Setting new future strategy stack:
[11:01:22.216] List of future strategies:
[11:01:22.216] 1. sequential:
[11:01:22.216]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.216]    - tweaked: FALSE
[11:01:22.216]    - call: plan(strategy)
[11:01:22.217] plan(): nbrOfWorkers() = 1
[11:01:22.217] SequentialFuture started (and completed)
[11:01:22.217] - Launch lazy future ... done
[11:01:22.217] run() for ‘SequentialFuture’ ... done
u$a = 2
v$a = 4
[11:01:22.217] getGlobalsAndPackages() ...
[11:01:22.217] Searching for globals...
[11:01:22.218] - globals found: [3] ‘{’, ‘*’, ‘a’
[11:01:22.218] Searching for globals ... DONE
[11:01:22.218] Resolving globals: FALSE
[11:01:22.219] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:22.219] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:22.219] - globals: [1] ‘a’
[11:01:22.220] 
[11:01:22.220] getGlobalsAndPackages() ... DONE
[11:01:22.220] run() for ‘Future’ ...
[11:01:22.220] - state: ‘created’
[11:01:22.220] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:22.220] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:22.220] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:22.220]   - Field: ‘label’
[11:01:22.221]   - Field: ‘local’
[11:01:22.221]   - Field: ‘owner’
[11:01:22.221]   - Field: ‘envir’
[11:01:22.221]   - Field: ‘packages’
[11:01:22.221]   - Field: ‘gc’
[11:01:22.221]   - Field: ‘conditions’
[11:01:22.221]   - Field: ‘expr’
[11:01:22.221]   - Field: ‘uuid’
[11:01:22.221]   - Field: ‘seed’
[11:01:22.221]   - Field: ‘version’
[11:01:22.221]   - Field: ‘result’
[11:01:22.221]   - Field: ‘asynchronous’
[11:01:22.222]   - Field: ‘calls’
[11:01:22.222]   - Field: ‘globals’
[11:01:22.222]   - Field: ‘stdout’
[11:01:22.222]   - Field: ‘earlySignal’
[11:01:22.222]   - Field: ‘lazy’
[11:01:22.222]   - Field: ‘state’
[11:01:22.222] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:22.222] - Launch lazy future ...
[11:01:22.222] Packages needed by the future expression (n = 0): <none>
[11:01:22.222] Packages needed by future strategies (n = 0): <none>
[11:01:22.223] {
[11:01:22.223]     {
[11:01:22.223]         {
[11:01:22.223]             ...future.startTime <- base::Sys.time()
[11:01:22.223]             {
[11:01:22.223]                 {
[11:01:22.223]                   {
[11:01:22.223]                     base::local({
[11:01:22.223]                       has_future <- base::requireNamespace("future", 
[11:01:22.223]                         quietly = TRUE)
[11:01:22.223]                       if (has_future) {
[11:01:22.223]                         ns <- base::getNamespace("future")
[11:01:22.223]                         version <- ns[[".package"]][["version"]]
[11:01:22.223]                         if (is.null(version)) 
[11:01:22.223]                           version <- utils::packageVersion("future")
[11:01:22.223]                       }
[11:01:22.223]                       else {
[11:01:22.223]                         version <- NULL
[11:01:22.223]                       }
[11:01:22.223]                       if (!has_future || version < "1.8.0") {
[11:01:22.223]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:22.223]                           "", base::R.version$version.string), 
[11:01:22.223]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:22.223]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:22.223]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:22.223]                             "release", "version")], collapse = " "), 
[11:01:22.223]                           hostname = base::Sys.info()[["nodename"]])
[11:01:22.223]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:22.223]                           info)
[11:01:22.223]                         info <- base::paste(info, collapse = "; ")
[11:01:22.223]                         if (!has_future) {
[11:01:22.223]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:22.223]                             info)
[11:01:22.223]                         }
[11:01:22.223]                         else {
[11:01:22.223]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:22.223]                             info, version)
[11:01:22.223]                         }
[11:01:22.223]                         base::stop(msg)
[11:01:22.223]                       }
[11:01:22.223]                     })
[11:01:22.223]                   }
[11:01:22.223]                   ...future.strategy.old <- future::plan("list")
[11:01:22.223]                   options(future.plan = NULL)
[11:01:22.223]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.223]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:22.223]                 }
[11:01:22.223]                 ...future.workdir <- getwd()
[11:01:22.223]             }
[11:01:22.223]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:22.223]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:22.223]         }
[11:01:22.223]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:22.223]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:22.223]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:22.223]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:22.223]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:22.223]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:22.223]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:22.223]             base::names(...future.oldOptions))
[11:01:22.223]     }
[11:01:22.223]     if (FALSE) {
[11:01:22.223]     }
[11:01:22.223]     else {
[11:01:22.223]         if (TRUE) {
[11:01:22.223]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:22.223]                 open = "w")
[11:01:22.223]         }
[11:01:22.223]         else {
[11:01:22.223]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:22.223]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:22.223]         }
[11:01:22.223]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:22.223]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:22.223]             base::sink(type = "output", split = FALSE)
[11:01:22.223]             base::close(...future.stdout)
[11:01:22.223]         }, add = TRUE)
[11:01:22.223]     }
[11:01:22.223]     ...future.frame <- base::sys.nframe()
[11:01:22.223]     ...future.conditions <- base::list()
[11:01:22.223]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:22.223]     if (FALSE) {
[11:01:22.223]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:22.223]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:22.223]     }
[11:01:22.223]     ...future.result <- base::tryCatch({
[11:01:22.223]         base::withCallingHandlers({
[11:01:22.223]             ...future.value <- base::withVisible(base::local({
[11:01:22.223]                 2 * a
[11:01:22.223]             }))
[11:01:22.223]             future::FutureResult(value = ...future.value$value, 
[11:01:22.223]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.223]                   ...future.rng), globalenv = if (FALSE) 
[11:01:22.223]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:22.223]                     ...future.globalenv.names))
[11:01:22.223]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:22.223]         }, condition = base::local({
[11:01:22.223]             c <- base::c
[11:01:22.223]             inherits <- base::inherits
[11:01:22.223]             invokeRestart <- base::invokeRestart
[11:01:22.223]             length <- base::length
[11:01:22.223]             list <- base::list
[11:01:22.223]             seq.int <- base::seq.int
[11:01:22.223]             signalCondition <- base::signalCondition
[11:01:22.223]             sys.calls <- base::sys.calls
[11:01:22.223]             `[[` <- base::`[[`
[11:01:22.223]             `+` <- base::`+`
[11:01:22.223]             `<<-` <- base::`<<-`
[11:01:22.223]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:22.223]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:22.223]                   3L)]
[11:01:22.223]             }
[11:01:22.223]             function(cond) {
[11:01:22.223]                 is_error <- inherits(cond, "error")
[11:01:22.223]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:22.223]                   NULL)
[11:01:22.223]                 if (is_error) {
[11:01:22.223]                   sessionInformation <- function() {
[11:01:22.223]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:22.223]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:22.223]                       search = base::search(), system = base::Sys.info())
[11:01:22.223]                   }
[11:01:22.223]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.223]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:22.223]                     cond$call), session = sessionInformation(), 
[11:01:22.223]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:22.223]                   signalCondition(cond)
[11:01:22.223]                 }
[11:01:22.223]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:22.223]                 "immediateCondition"))) {
[11:01:22.223]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:22.223]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.223]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:22.223]                   if (TRUE && !signal) {
[11:01:22.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.223]                     {
[11:01:22.223]                       inherits <- base::inherits
[11:01:22.223]                       invokeRestart <- base::invokeRestart
[11:01:22.223]                       is.null <- base::is.null
[11:01:22.223]                       muffled <- FALSE
[11:01:22.223]                       if (inherits(cond, "message")) {
[11:01:22.223]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.223]                         if (muffled) 
[11:01:22.223]                           invokeRestart("muffleMessage")
[11:01:22.223]                       }
[11:01:22.223]                       else if (inherits(cond, "warning")) {
[11:01:22.223]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.223]                         if (muffled) 
[11:01:22.223]                           invokeRestart("muffleWarning")
[11:01:22.223]                       }
[11:01:22.223]                       else if (inherits(cond, "condition")) {
[11:01:22.223]                         if (!is.null(pattern)) {
[11:01:22.223]                           computeRestarts <- base::computeRestarts
[11:01:22.223]                           grepl <- base::grepl
[11:01:22.223]                           restarts <- computeRestarts(cond)
[11:01:22.223]                           for (restart in restarts) {
[11:01:22.223]                             name <- restart$name
[11:01:22.223]                             if (is.null(name)) 
[11:01:22.223]                               next
[11:01:22.223]                             if (!grepl(pattern, name)) 
[11:01:22.223]                               next
[11:01:22.223]                             invokeRestart(restart)
[11:01:22.223]                             muffled <- TRUE
[11:01:22.223]                             break
[11:01:22.223]                           }
[11:01:22.223]                         }
[11:01:22.223]                       }
[11:01:22.223]                       invisible(muffled)
[11:01:22.223]                     }
[11:01:22.223]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.223]                   }
[11:01:22.223]                 }
[11:01:22.223]                 else {
[11:01:22.223]                   if (TRUE) {
[11:01:22.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.223]                     {
[11:01:22.223]                       inherits <- base::inherits
[11:01:22.223]                       invokeRestart <- base::invokeRestart
[11:01:22.223]                       is.null <- base::is.null
[11:01:22.223]                       muffled <- FALSE
[11:01:22.223]                       if (inherits(cond, "message")) {
[11:01:22.223]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.223]                         if (muffled) 
[11:01:22.223]                           invokeRestart("muffleMessage")
[11:01:22.223]                       }
[11:01:22.223]                       else if (inherits(cond, "warning")) {
[11:01:22.223]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.223]                         if (muffled) 
[11:01:22.223]                           invokeRestart("muffleWarning")
[11:01:22.223]                       }
[11:01:22.223]                       else if (inherits(cond, "condition")) {
[11:01:22.223]                         if (!is.null(pattern)) {
[11:01:22.223]                           computeRestarts <- base::computeRestarts
[11:01:22.223]                           grepl <- base::grepl
[11:01:22.223]                           restarts <- computeRestarts(cond)
[11:01:22.223]                           for (restart in restarts) {
[11:01:22.223]                             name <- restart$name
[11:01:22.223]                             if (is.null(name)) 
[11:01:22.223]                               next
[11:01:22.223]                             if (!grepl(pattern, name)) 
[11:01:22.223]                               next
[11:01:22.223]                             invokeRestart(restart)
[11:01:22.223]                             muffled <- TRUE
[11:01:22.223]                             break
[11:01:22.223]                           }
[11:01:22.223]                         }
[11:01:22.223]                       }
[11:01:22.223]                       invisible(muffled)
[11:01:22.223]                     }
[11:01:22.223]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.223]                   }
[11:01:22.223]                 }
[11:01:22.223]             }
[11:01:22.223]         }))
[11:01:22.223]     }, error = function(ex) {
[11:01:22.223]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:22.223]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.223]                 ...future.rng), started = ...future.startTime, 
[11:01:22.223]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:22.223]             version = "1.8"), class = "FutureResult")
[11:01:22.223]     }, finally = {
[11:01:22.223]         if (!identical(...future.workdir, getwd())) 
[11:01:22.223]             setwd(...future.workdir)
[11:01:22.223]         {
[11:01:22.223]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:22.223]                 ...future.oldOptions$nwarnings <- NULL
[11:01:22.223]             }
[11:01:22.223]             base::options(...future.oldOptions)
[11:01:22.223]             if (.Platform$OS.type == "windows") {
[11:01:22.223]                 old_names <- names(...future.oldEnvVars)
[11:01:22.223]                 envs <- base::Sys.getenv()
[11:01:22.223]                 names <- names(envs)
[11:01:22.223]                 common <- intersect(names, old_names)
[11:01:22.223]                 added <- setdiff(names, old_names)
[11:01:22.223]                 removed <- setdiff(old_names, names)
[11:01:22.223]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:22.223]                   envs[common]]
[11:01:22.223]                 NAMES <- toupper(changed)
[11:01:22.223]                 args <- list()
[11:01:22.223]                 for (kk in seq_along(NAMES)) {
[11:01:22.223]                   name <- changed[[kk]]
[11:01:22.223]                   NAME <- NAMES[[kk]]
[11:01:22.223]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.223]                     next
[11:01:22.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.223]                 }
[11:01:22.223]                 NAMES <- toupper(added)
[11:01:22.223]                 for (kk in seq_along(NAMES)) {
[11:01:22.223]                   name <- added[[kk]]
[11:01:22.223]                   NAME <- NAMES[[kk]]
[11:01:22.223]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.223]                     next
[11:01:22.223]                   args[[name]] <- ""
[11:01:22.223]                 }
[11:01:22.223]                 NAMES <- toupper(removed)
[11:01:22.223]                 for (kk in seq_along(NAMES)) {
[11:01:22.223]                   name <- removed[[kk]]
[11:01:22.223]                   NAME <- NAMES[[kk]]
[11:01:22.223]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.223]                     next
[11:01:22.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.223]                 }
[11:01:22.223]                 if (length(args) > 0) 
[11:01:22.223]                   base::do.call(base::Sys.setenv, args = args)
[11:01:22.223]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:22.223]             }
[11:01:22.223]             else {
[11:01:22.223]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:22.223]             }
[11:01:22.223]             {
[11:01:22.223]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:22.223]                   0L) {
[11:01:22.223]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:22.223]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:22.223]                   base::options(opts)
[11:01:22.223]                 }
[11:01:22.223]                 {
[11:01:22.223]                   {
[11:01:22.223]                     NULL
[11:01:22.223]                     RNGkind("Mersenne-Twister")
[11:01:22.223]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:22.223]                       inherits = FALSE)
[11:01:22.223]                   }
[11:01:22.223]                   options(future.plan = NULL)
[11:01:22.223]                   if (is.na(NA_character_)) 
[11:01:22.223]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.223]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:22.223]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:22.223]                     .init = FALSE)
[11:01:22.223]                 }
[11:01:22.223]             }
[11:01:22.223]         }
[11:01:22.223]     })
[11:01:22.223]     if (TRUE) {
[11:01:22.223]         base::sink(type = "output", split = FALSE)
[11:01:22.223]         if (TRUE) {
[11:01:22.223]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:22.223]         }
[11:01:22.223]         else {
[11:01:22.223]             ...future.result["stdout"] <- base::list(NULL)
[11:01:22.223]         }
[11:01:22.223]         base::close(...future.stdout)
[11:01:22.223]         ...future.stdout <- NULL
[11:01:22.223]     }
[11:01:22.223]     ...future.result$conditions <- ...future.conditions
[11:01:22.223]     ...future.result$finished <- base::Sys.time()
[11:01:22.223]     ...future.result
[11:01:22.223] }
[11:01:22.224] assign_globals() ...
[11:01:22.224] List of 1
[11:01:22.224]  $ a: num 1
[11:01:22.224]  - attr(*, "where")=List of 1
[11:01:22.224]   ..$ a:<environment: R_EmptyEnv> 
[11:01:22.224]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:22.224]  - attr(*, "resolved")= logi FALSE
[11:01:22.224]  - attr(*, "total_size")= num 39
[11:01:22.224]  - attr(*, "already-done")= logi TRUE
[11:01:22.230] - copied ‘a’ to environment
[11:01:22.230] assign_globals() ... done
[11:01:22.230] plan(): Setting new future strategy stack:
[11:01:22.230] List of future strategies:
[11:01:22.230] 1. sequential:
[11:01:22.230]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.230]    - tweaked: FALSE
[11:01:22.230]    - call: NULL
[11:01:22.230] plan(): nbrOfWorkers() = 1
[11:01:22.231] plan(): Setting new future strategy stack:
[11:01:22.231] List of future strategies:
[11:01:22.231] 1. sequential:
[11:01:22.231]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.231]    - tweaked: FALSE
[11:01:22.231]    - call: plan(strategy)
[11:01:22.232] plan(): nbrOfWorkers() = 1
[11:01:22.232] SequentialFuture started (and completed)
[11:01:22.232] - Launch lazy future ... done
[11:01:22.232] run() for ‘SequentialFuture’ ... done
[11:01:22.232] getGlobalsAndPackages() ...
[11:01:22.232] Searching for globals...
[11:01:22.233] - globals found: [3] ‘{’, ‘*’, ‘a’
[11:01:22.233] Searching for globals ... DONE
[11:01:22.233] Resolving globals: FALSE
[11:01:22.233] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:22.234] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:22.234] - globals: [1] ‘a’
[11:01:22.234] 
[11:01:22.234] getGlobalsAndPackages() ... DONE
[11:01:22.234] run() for ‘Future’ ...
[11:01:22.234] - state: ‘created’
[11:01:22.234] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:22.235] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:22.235] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:22.235]   - Field: ‘label’
[11:01:22.235]   - Field: ‘local’
[11:01:22.235]   - Field: ‘owner’
[11:01:22.235]   - Field: ‘envir’
[11:01:22.235]   - Field: ‘packages’
[11:01:22.235]   - Field: ‘gc’
[11:01:22.235]   - Field: ‘conditions’
[11:01:22.235]   - Field: ‘expr’
[11:01:22.235]   - Field: ‘uuid’
[11:01:22.236]   - Field: ‘seed’
[11:01:22.236]   - Field: ‘version’
[11:01:22.236]   - Field: ‘result’
[11:01:22.236]   - Field: ‘asynchronous’
[11:01:22.236]   - Field: ‘calls’
[11:01:22.236]   - Field: ‘globals’
[11:01:22.236]   - Field: ‘stdout’
[11:01:22.236]   - Field: ‘earlySignal’
[11:01:22.236]   - Field: ‘lazy’
[11:01:22.236]   - Field: ‘state’
[11:01:22.236] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:22.236] - Launch lazy future ...
[11:01:22.237] Packages needed by the future expression (n = 0): <none>
[11:01:22.237] Packages needed by future strategies (n = 0): <none>
[11:01:22.237] {
[11:01:22.237]     {
[11:01:22.237]         {
[11:01:22.237]             ...future.startTime <- base::Sys.time()
[11:01:22.237]             {
[11:01:22.237]                 {
[11:01:22.237]                   {
[11:01:22.237]                     base::local({
[11:01:22.237]                       has_future <- base::requireNamespace("future", 
[11:01:22.237]                         quietly = TRUE)
[11:01:22.237]                       if (has_future) {
[11:01:22.237]                         ns <- base::getNamespace("future")
[11:01:22.237]                         version <- ns[[".package"]][["version"]]
[11:01:22.237]                         if (is.null(version)) 
[11:01:22.237]                           version <- utils::packageVersion("future")
[11:01:22.237]                       }
[11:01:22.237]                       else {
[11:01:22.237]                         version <- NULL
[11:01:22.237]                       }
[11:01:22.237]                       if (!has_future || version < "1.8.0") {
[11:01:22.237]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:22.237]                           "", base::R.version$version.string), 
[11:01:22.237]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:22.237]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:22.237]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:22.237]                             "release", "version")], collapse = " "), 
[11:01:22.237]                           hostname = base::Sys.info()[["nodename"]])
[11:01:22.237]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:22.237]                           info)
[11:01:22.237]                         info <- base::paste(info, collapse = "; ")
[11:01:22.237]                         if (!has_future) {
[11:01:22.237]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:22.237]                             info)
[11:01:22.237]                         }
[11:01:22.237]                         else {
[11:01:22.237]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:22.237]                             info, version)
[11:01:22.237]                         }
[11:01:22.237]                         base::stop(msg)
[11:01:22.237]                       }
[11:01:22.237]                     })
[11:01:22.237]                   }
[11:01:22.237]                   ...future.strategy.old <- future::plan("list")
[11:01:22.237]                   options(future.plan = NULL)
[11:01:22.237]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.237]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:22.237]                 }
[11:01:22.237]                 ...future.workdir <- getwd()
[11:01:22.237]             }
[11:01:22.237]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:22.237]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:22.237]         }
[11:01:22.237]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:22.237]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:22.237]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:22.237]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:22.237]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:22.237]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:22.237]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:22.237]             base::names(...future.oldOptions))
[11:01:22.237]     }
[11:01:22.237]     if (FALSE) {
[11:01:22.237]     }
[11:01:22.237]     else {
[11:01:22.237]         if (TRUE) {
[11:01:22.237]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:22.237]                 open = "w")
[11:01:22.237]         }
[11:01:22.237]         else {
[11:01:22.237]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:22.237]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:22.237]         }
[11:01:22.237]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:22.237]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:22.237]             base::sink(type = "output", split = FALSE)
[11:01:22.237]             base::close(...future.stdout)
[11:01:22.237]         }, add = TRUE)
[11:01:22.237]     }
[11:01:22.237]     ...future.frame <- base::sys.nframe()
[11:01:22.237]     ...future.conditions <- base::list()
[11:01:22.237]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:22.237]     if (FALSE) {
[11:01:22.237]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:22.237]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:22.237]     }
[11:01:22.237]     ...future.result <- base::tryCatch({
[11:01:22.237]         base::withCallingHandlers({
[11:01:22.237]             ...future.value <- base::withVisible(base::local({
[11:01:22.237]                 2 * a
[11:01:22.237]             }))
[11:01:22.237]             future::FutureResult(value = ...future.value$value, 
[11:01:22.237]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.237]                   ...future.rng), globalenv = if (FALSE) 
[11:01:22.237]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:22.237]                     ...future.globalenv.names))
[11:01:22.237]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:22.237]         }, condition = base::local({
[11:01:22.237]             c <- base::c
[11:01:22.237]             inherits <- base::inherits
[11:01:22.237]             invokeRestart <- base::invokeRestart
[11:01:22.237]             length <- base::length
[11:01:22.237]             list <- base::list
[11:01:22.237]             seq.int <- base::seq.int
[11:01:22.237]             signalCondition <- base::signalCondition
[11:01:22.237]             sys.calls <- base::sys.calls
[11:01:22.237]             `[[` <- base::`[[`
[11:01:22.237]             `+` <- base::`+`
[11:01:22.237]             `<<-` <- base::`<<-`
[11:01:22.237]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:22.237]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:22.237]                   3L)]
[11:01:22.237]             }
[11:01:22.237]             function(cond) {
[11:01:22.237]                 is_error <- inherits(cond, "error")
[11:01:22.237]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:22.237]                   NULL)
[11:01:22.237]                 if (is_error) {
[11:01:22.237]                   sessionInformation <- function() {
[11:01:22.237]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:22.237]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:22.237]                       search = base::search(), system = base::Sys.info())
[11:01:22.237]                   }
[11:01:22.237]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.237]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:22.237]                     cond$call), session = sessionInformation(), 
[11:01:22.237]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:22.237]                   signalCondition(cond)
[11:01:22.237]                 }
[11:01:22.237]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:22.237]                 "immediateCondition"))) {
[11:01:22.237]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:22.237]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.237]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:22.237]                   if (TRUE && !signal) {
[11:01:22.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.237]                     {
[11:01:22.237]                       inherits <- base::inherits
[11:01:22.237]                       invokeRestart <- base::invokeRestart
[11:01:22.237]                       is.null <- base::is.null
[11:01:22.237]                       muffled <- FALSE
[11:01:22.237]                       if (inherits(cond, "message")) {
[11:01:22.237]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.237]                         if (muffled) 
[11:01:22.237]                           invokeRestart("muffleMessage")
[11:01:22.237]                       }
[11:01:22.237]                       else if (inherits(cond, "warning")) {
[11:01:22.237]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.237]                         if (muffled) 
[11:01:22.237]                           invokeRestart("muffleWarning")
[11:01:22.237]                       }
[11:01:22.237]                       else if (inherits(cond, "condition")) {
[11:01:22.237]                         if (!is.null(pattern)) {
[11:01:22.237]                           computeRestarts <- base::computeRestarts
[11:01:22.237]                           grepl <- base::grepl
[11:01:22.237]                           restarts <- computeRestarts(cond)
[11:01:22.237]                           for (restart in restarts) {
[11:01:22.237]                             name <- restart$name
[11:01:22.237]                             if (is.null(name)) 
[11:01:22.237]                               next
[11:01:22.237]                             if (!grepl(pattern, name)) 
[11:01:22.237]                               next
[11:01:22.237]                             invokeRestart(restart)
[11:01:22.237]                             muffled <- TRUE
[11:01:22.237]                             break
[11:01:22.237]                           }
[11:01:22.237]                         }
[11:01:22.237]                       }
[11:01:22.237]                       invisible(muffled)
[11:01:22.237]                     }
[11:01:22.237]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.237]                   }
[11:01:22.237]                 }
[11:01:22.237]                 else {
[11:01:22.237]                   if (TRUE) {
[11:01:22.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.237]                     {
[11:01:22.237]                       inherits <- base::inherits
[11:01:22.237]                       invokeRestart <- base::invokeRestart
[11:01:22.237]                       is.null <- base::is.null
[11:01:22.237]                       muffled <- FALSE
[11:01:22.237]                       if (inherits(cond, "message")) {
[11:01:22.237]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.237]                         if (muffled) 
[11:01:22.237]                           invokeRestart("muffleMessage")
[11:01:22.237]                       }
[11:01:22.237]                       else if (inherits(cond, "warning")) {
[11:01:22.237]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.237]                         if (muffled) 
[11:01:22.237]                           invokeRestart("muffleWarning")
[11:01:22.237]                       }
[11:01:22.237]                       else if (inherits(cond, "condition")) {
[11:01:22.237]                         if (!is.null(pattern)) {
[11:01:22.237]                           computeRestarts <- base::computeRestarts
[11:01:22.237]                           grepl <- base::grepl
[11:01:22.237]                           restarts <- computeRestarts(cond)
[11:01:22.237]                           for (restart in restarts) {
[11:01:22.237]                             name <- restart$name
[11:01:22.237]                             if (is.null(name)) 
[11:01:22.237]                               next
[11:01:22.237]                             if (!grepl(pattern, name)) 
[11:01:22.237]                               next
[11:01:22.237]                             invokeRestart(restart)
[11:01:22.237]                             muffled <- TRUE
[11:01:22.237]                             break
[11:01:22.237]                           }
[11:01:22.237]                         }
[11:01:22.237]                       }
[11:01:22.237]                       invisible(muffled)
[11:01:22.237]                     }
[11:01:22.237]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.237]                   }
[11:01:22.237]                 }
[11:01:22.237]             }
[11:01:22.237]         }))
[11:01:22.237]     }, error = function(ex) {
[11:01:22.237]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:22.237]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.237]                 ...future.rng), started = ...future.startTime, 
[11:01:22.237]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:22.237]             version = "1.8"), class = "FutureResult")
[11:01:22.237]     }, finally = {
[11:01:22.237]         if (!identical(...future.workdir, getwd())) 
[11:01:22.237]             setwd(...future.workdir)
[11:01:22.237]         {
[11:01:22.237]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:22.237]                 ...future.oldOptions$nwarnings <- NULL
[11:01:22.237]             }
[11:01:22.237]             base::options(...future.oldOptions)
[11:01:22.237]             if (.Platform$OS.type == "windows") {
[11:01:22.237]                 old_names <- names(...future.oldEnvVars)
[11:01:22.237]                 envs <- base::Sys.getenv()
[11:01:22.237]                 names <- names(envs)
[11:01:22.237]                 common <- intersect(names, old_names)
[11:01:22.237]                 added <- setdiff(names, old_names)
[11:01:22.237]                 removed <- setdiff(old_names, names)
[11:01:22.237]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:22.237]                   envs[common]]
[11:01:22.237]                 NAMES <- toupper(changed)
[11:01:22.237]                 args <- list()
[11:01:22.237]                 for (kk in seq_along(NAMES)) {
[11:01:22.237]                   name <- changed[[kk]]
[11:01:22.237]                   NAME <- NAMES[[kk]]
[11:01:22.237]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.237]                     next
[11:01:22.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.237]                 }
[11:01:22.237]                 NAMES <- toupper(added)
[11:01:22.237]                 for (kk in seq_along(NAMES)) {
[11:01:22.237]                   name <- added[[kk]]
[11:01:22.237]                   NAME <- NAMES[[kk]]
[11:01:22.237]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.237]                     next
[11:01:22.237]                   args[[name]] <- ""
[11:01:22.237]                 }
[11:01:22.237]                 NAMES <- toupper(removed)
[11:01:22.237]                 for (kk in seq_along(NAMES)) {
[11:01:22.237]                   name <- removed[[kk]]
[11:01:22.237]                   NAME <- NAMES[[kk]]
[11:01:22.237]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.237]                     next
[11:01:22.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.237]                 }
[11:01:22.237]                 if (length(args) > 0) 
[11:01:22.237]                   base::do.call(base::Sys.setenv, args = args)
[11:01:22.237]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:22.237]             }
[11:01:22.237]             else {
[11:01:22.237]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:22.237]             }
[11:01:22.237]             {
[11:01:22.237]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:22.237]                   0L) {
[11:01:22.237]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:22.237]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:22.237]                   base::options(opts)
[11:01:22.237]                 }
[11:01:22.237]                 {
[11:01:22.237]                   {
[11:01:22.237]                     NULL
[11:01:22.237]                     RNGkind("Mersenne-Twister")
[11:01:22.237]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:22.237]                       inherits = FALSE)
[11:01:22.237]                   }
[11:01:22.237]                   options(future.plan = NULL)
[11:01:22.237]                   if (is.na(NA_character_)) 
[11:01:22.237]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.237]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:22.237]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:22.237]                     .init = FALSE)
[11:01:22.237]                 }
[11:01:22.237]             }
[11:01:22.237]         }
[11:01:22.237]     })
[11:01:22.237]     if (TRUE) {
[11:01:22.237]         base::sink(type = "output", split = FALSE)
[11:01:22.237]         if (TRUE) {
[11:01:22.237]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:22.237]         }
[11:01:22.237]         else {
[11:01:22.237]             ...future.result["stdout"] <- base::list(NULL)
[11:01:22.237]         }
[11:01:22.237]         base::close(...future.stdout)
[11:01:22.237]         ...future.stdout <- NULL
[11:01:22.237]     }
[11:01:22.237]     ...future.result$conditions <- ...future.conditions
[11:01:22.237]     ...future.result$finished <- base::Sys.time()
[11:01:22.237]     ...future.result
[11:01:22.237] }
[11:01:22.239] assign_globals() ...
[11:01:22.239] List of 1
[11:01:22.239]  $ a: num 1
[11:01:22.239]  - attr(*, "where")=List of 1
[11:01:22.239]   ..$ a:<environment: R_EmptyEnv> 
[11:01:22.239]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:22.239]  - attr(*, "resolved")= logi FALSE
[11:01:22.239]  - attr(*, "total_size")= num 39
[11:01:22.239]  - attr(*, "already-done")= logi TRUE
[11:01:22.241] - copied ‘a’ to environment
[11:01:22.241] assign_globals() ... done
[11:01:22.241] plan(): Setting new future strategy stack:
[11:01:22.241] List of future strategies:
[11:01:22.241] 1. sequential:
[11:01:22.241]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.241]    - tweaked: FALSE
[11:01:22.241]    - call: NULL
[11:01:22.242] plan(): nbrOfWorkers() = 1
[11:01:22.242] plan(): Setting new future strategy stack:
[11:01:22.243] List of future strategies:
[11:01:22.243] 1. sequential:
[11:01:22.243]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.243]    - tweaked: FALSE
[11:01:22.243]    - call: plan(strategy)
[11:01:22.243] plan(): nbrOfWorkers() = 1
[11:01:22.243] SequentialFuture started (and completed)
[11:01:22.243] - Launch lazy future ... done
[11:01:22.243] run() for ‘SequentialFuture’ ... done
[11:01:22.244] getGlobalsAndPackages() ...
[11:01:22.244] Searching for globals...
[11:01:22.244] - globals found: [3] ‘{’, ‘*’, ‘a’
[11:01:22.245] Searching for globals ... DONE
[11:01:22.245] Resolving globals: FALSE
[11:01:22.245] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:22.245] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:22.245] - globals: [1] ‘a’
[11:01:22.245] 
[11:01:22.246] getGlobalsAndPackages() ... DONE
[11:01:22.246] run() for ‘Future’ ...
[11:01:22.246] - state: ‘created’
[11:01:22.246] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:22.246] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:22.246] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:22.246]   - Field: ‘label’
[11:01:22.246]   - Field: ‘local’
[11:01:22.247]   - Field: ‘owner’
[11:01:22.247]   - Field: ‘envir’
[11:01:22.247]   - Field: ‘packages’
[11:01:22.247]   - Field: ‘gc’
[11:01:22.247]   - Field: ‘conditions’
[11:01:22.247]   - Field: ‘expr’
[11:01:22.247]   - Field: ‘uuid’
[11:01:22.247]   - Field: ‘seed’
[11:01:22.247]   - Field: ‘version’
[11:01:22.247]   - Field: ‘result’
[11:01:22.247]   - Field: ‘asynchronous’
[11:01:22.247]   - Field: ‘calls’
[11:01:22.247]   - Field: ‘globals’
[11:01:22.248]   - Field: ‘stdout’
[11:01:22.248]   - Field: ‘earlySignal’
[11:01:22.248]   - Field: ‘lazy’
[11:01:22.248]   - Field: ‘state’
[11:01:22.248] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:22.248] - Launch lazy future ...
[11:01:22.248] Packages needed by the future expression (n = 0): <none>
[11:01:22.248] Packages needed by future strategies (n = 0): <none>
[11:01:22.249] {
[11:01:22.249]     {
[11:01:22.249]         {
[11:01:22.249]             ...future.startTime <- base::Sys.time()
[11:01:22.249]             {
[11:01:22.249]                 {
[11:01:22.249]                   {
[11:01:22.249]                     base::local({
[11:01:22.249]                       has_future <- base::requireNamespace("future", 
[11:01:22.249]                         quietly = TRUE)
[11:01:22.249]                       if (has_future) {
[11:01:22.249]                         ns <- base::getNamespace("future")
[11:01:22.249]                         version <- ns[[".package"]][["version"]]
[11:01:22.249]                         if (is.null(version)) 
[11:01:22.249]                           version <- utils::packageVersion("future")
[11:01:22.249]                       }
[11:01:22.249]                       else {
[11:01:22.249]                         version <- NULL
[11:01:22.249]                       }
[11:01:22.249]                       if (!has_future || version < "1.8.0") {
[11:01:22.249]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:22.249]                           "", base::R.version$version.string), 
[11:01:22.249]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:22.249]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:22.249]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:22.249]                             "release", "version")], collapse = " "), 
[11:01:22.249]                           hostname = base::Sys.info()[["nodename"]])
[11:01:22.249]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:22.249]                           info)
[11:01:22.249]                         info <- base::paste(info, collapse = "; ")
[11:01:22.249]                         if (!has_future) {
[11:01:22.249]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:22.249]                             info)
[11:01:22.249]                         }
[11:01:22.249]                         else {
[11:01:22.249]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:22.249]                             info, version)
[11:01:22.249]                         }
[11:01:22.249]                         base::stop(msg)
[11:01:22.249]                       }
[11:01:22.249]                     })
[11:01:22.249]                   }
[11:01:22.249]                   ...future.strategy.old <- future::plan("list")
[11:01:22.249]                   options(future.plan = NULL)
[11:01:22.249]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.249]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:22.249]                 }
[11:01:22.249]                 ...future.workdir <- getwd()
[11:01:22.249]             }
[11:01:22.249]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:22.249]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:22.249]         }
[11:01:22.249]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:22.249]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:22.249]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:22.249]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:22.249]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:22.249]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:22.249]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:22.249]             base::names(...future.oldOptions))
[11:01:22.249]     }
[11:01:22.249]     if (FALSE) {
[11:01:22.249]     }
[11:01:22.249]     else {
[11:01:22.249]         if (TRUE) {
[11:01:22.249]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:22.249]                 open = "w")
[11:01:22.249]         }
[11:01:22.249]         else {
[11:01:22.249]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:22.249]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:22.249]         }
[11:01:22.249]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:22.249]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:22.249]             base::sink(type = "output", split = FALSE)
[11:01:22.249]             base::close(...future.stdout)
[11:01:22.249]         }, add = TRUE)
[11:01:22.249]     }
[11:01:22.249]     ...future.frame <- base::sys.nframe()
[11:01:22.249]     ...future.conditions <- base::list()
[11:01:22.249]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:22.249]     if (FALSE) {
[11:01:22.249]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:22.249]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:22.249]     }
[11:01:22.249]     ...future.result <- base::tryCatch({
[11:01:22.249]         base::withCallingHandlers({
[11:01:22.249]             ...future.value <- base::withVisible(base::local({
[11:01:22.249]                 2 * a
[11:01:22.249]             }))
[11:01:22.249]             future::FutureResult(value = ...future.value$value, 
[11:01:22.249]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.249]                   ...future.rng), globalenv = if (FALSE) 
[11:01:22.249]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:22.249]                     ...future.globalenv.names))
[11:01:22.249]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:22.249]         }, condition = base::local({
[11:01:22.249]             c <- base::c
[11:01:22.249]             inherits <- base::inherits
[11:01:22.249]             invokeRestart <- base::invokeRestart
[11:01:22.249]             length <- base::length
[11:01:22.249]             list <- base::list
[11:01:22.249]             seq.int <- base::seq.int
[11:01:22.249]             signalCondition <- base::signalCondition
[11:01:22.249]             sys.calls <- base::sys.calls
[11:01:22.249]             `[[` <- base::`[[`
[11:01:22.249]             `+` <- base::`+`
[11:01:22.249]             `<<-` <- base::`<<-`
[11:01:22.249]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:22.249]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:22.249]                   3L)]
[11:01:22.249]             }
[11:01:22.249]             function(cond) {
[11:01:22.249]                 is_error <- inherits(cond, "error")
[11:01:22.249]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:22.249]                   NULL)
[11:01:22.249]                 if (is_error) {
[11:01:22.249]                   sessionInformation <- function() {
[11:01:22.249]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:22.249]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:22.249]                       search = base::search(), system = base::Sys.info())
[11:01:22.249]                   }
[11:01:22.249]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.249]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:22.249]                     cond$call), session = sessionInformation(), 
[11:01:22.249]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:22.249]                   signalCondition(cond)
[11:01:22.249]                 }
[11:01:22.249]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:22.249]                 "immediateCondition"))) {
[11:01:22.249]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:22.249]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.249]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:22.249]                   if (TRUE && !signal) {
[11:01:22.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.249]                     {
[11:01:22.249]                       inherits <- base::inherits
[11:01:22.249]                       invokeRestart <- base::invokeRestart
[11:01:22.249]                       is.null <- base::is.null
[11:01:22.249]                       muffled <- FALSE
[11:01:22.249]                       if (inherits(cond, "message")) {
[11:01:22.249]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.249]                         if (muffled) 
[11:01:22.249]                           invokeRestart("muffleMessage")
[11:01:22.249]                       }
[11:01:22.249]                       else if (inherits(cond, "warning")) {
[11:01:22.249]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.249]                         if (muffled) 
[11:01:22.249]                           invokeRestart("muffleWarning")
[11:01:22.249]                       }
[11:01:22.249]                       else if (inherits(cond, "condition")) {
[11:01:22.249]                         if (!is.null(pattern)) {
[11:01:22.249]                           computeRestarts <- base::computeRestarts
[11:01:22.249]                           grepl <- base::grepl
[11:01:22.249]                           restarts <- computeRestarts(cond)
[11:01:22.249]                           for (restart in restarts) {
[11:01:22.249]                             name <- restart$name
[11:01:22.249]                             if (is.null(name)) 
[11:01:22.249]                               next
[11:01:22.249]                             if (!grepl(pattern, name)) 
[11:01:22.249]                               next
[11:01:22.249]                             invokeRestart(restart)
[11:01:22.249]                             muffled <- TRUE
[11:01:22.249]                             break
[11:01:22.249]                           }
[11:01:22.249]                         }
[11:01:22.249]                       }
[11:01:22.249]                       invisible(muffled)
[11:01:22.249]                     }
[11:01:22.249]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.249]                   }
[11:01:22.249]                 }
[11:01:22.249]                 else {
[11:01:22.249]                   if (TRUE) {
[11:01:22.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.249]                     {
[11:01:22.249]                       inherits <- base::inherits
[11:01:22.249]                       invokeRestart <- base::invokeRestart
[11:01:22.249]                       is.null <- base::is.null
[11:01:22.249]                       muffled <- FALSE
[11:01:22.249]                       if (inherits(cond, "message")) {
[11:01:22.249]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.249]                         if (muffled) 
[11:01:22.249]                           invokeRestart("muffleMessage")
[11:01:22.249]                       }
[11:01:22.249]                       else if (inherits(cond, "warning")) {
[11:01:22.249]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.249]                         if (muffled) 
[11:01:22.249]                           invokeRestart("muffleWarning")
[11:01:22.249]                       }
[11:01:22.249]                       else if (inherits(cond, "condition")) {
[11:01:22.249]                         if (!is.null(pattern)) {
[11:01:22.249]                           computeRestarts <- base::computeRestarts
[11:01:22.249]                           grepl <- base::grepl
[11:01:22.249]                           restarts <- computeRestarts(cond)
[11:01:22.249]                           for (restart in restarts) {
[11:01:22.249]                             name <- restart$name
[11:01:22.249]                             if (is.null(name)) 
[11:01:22.249]                               next
[11:01:22.249]                             if (!grepl(pattern, name)) 
[11:01:22.249]                               next
[11:01:22.249]                             invokeRestart(restart)
[11:01:22.249]                             muffled <- TRUE
[11:01:22.249]                             break
[11:01:22.249]                           }
[11:01:22.249]                         }
[11:01:22.249]                       }
[11:01:22.249]                       invisible(muffled)
[11:01:22.249]                     }
[11:01:22.249]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.249]                   }
[11:01:22.249]                 }
[11:01:22.249]             }
[11:01:22.249]         }))
[11:01:22.249]     }, error = function(ex) {
[11:01:22.249]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:22.249]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.249]                 ...future.rng), started = ...future.startTime, 
[11:01:22.249]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:22.249]             version = "1.8"), class = "FutureResult")
[11:01:22.249]     }, finally = {
[11:01:22.249]         if (!identical(...future.workdir, getwd())) 
[11:01:22.249]             setwd(...future.workdir)
[11:01:22.249]         {
[11:01:22.249]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:22.249]                 ...future.oldOptions$nwarnings <- NULL
[11:01:22.249]             }
[11:01:22.249]             base::options(...future.oldOptions)
[11:01:22.249]             if (.Platform$OS.type == "windows") {
[11:01:22.249]                 old_names <- names(...future.oldEnvVars)
[11:01:22.249]                 envs <- base::Sys.getenv()
[11:01:22.249]                 names <- names(envs)
[11:01:22.249]                 common <- intersect(names, old_names)
[11:01:22.249]                 added <- setdiff(names, old_names)
[11:01:22.249]                 removed <- setdiff(old_names, names)
[11:01:22.249]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:22.249]                   envs[common]]
[11:01:22.249]                 NAMES <- toupper(changed)
[11:01:22.249]                 args <- list()
[11:01:22.249]                 for (kk in seq_along(NAMES)) {
[11:01:22.249]                   name <- changed[[kk]]
[11:01:22.249]                   NAME <- NAMES[[kk]]
[11:01:22.249]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.249]                     next
[11:01:22.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.249]                 }
[11:01:22.249]                 NAMES <- toupper(added)
[11:01:22.249]                 for (kk in seq_along(NAMES)) {
[11:01:22.249]                   name <- added[[kk]]
[11:01:22.249]                   NAME <- NAMES[[kk]]
[11:01:22.249]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.249]                     next
[11:01:22.249]                   args[[name]] <- ""
[11:01:22.249]                 }
[11:01:22.249]                 NAMES <- toupper(removed)
[11:01:22.249]                 for (kk in seq_along(NAMES)) {
[11:01:22.249]                   name <- removed[[kk]]
[11:01:22.249]                   NAME <- NAMES[[kk]]
[11:01:22.249]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.249]                     next
[11:01:22.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.249]                 }
[11:01:22.249]                 if (length(args) > 0) 
[11:01:22.249]                   base::do.call(base::Sys.setenv, args = args)
[11:01:22.249]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:22.249]             }
[11:01:22.249]             else {
[11:01:22.249]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:22.249]             }
[11:01:22.249]             {
[11:01:22.249]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:22.249]                   0L) {
[11:01:22.249]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:22.249]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:22.249]                   base::options(opts)
[11:01:22.249]                 }
[11:01:22.249]                 {
[11:01:22.249]                   {
[11:01:22.249]                     NULL
[11:01:22.249]                     RNGkind("Mersenne-Twister")
[11:01:22.249]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:22.249]                       inherits = FALSE)
[11:01:22.249]                   }
[11:01:22.249]                   options(future.plan = NULL)
[11:01:22.249]                   if (is.na(NA_character_)) 
[11:01:22.249]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.249]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:22.249]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:22.249]                     .init = FALSE)
[11:01:22.249]                 }
[11:01:22.249]             }
[11:01:22.249]         }
[11:01:22.249]     })
[11:01:22.249]     if (TRUE) {
[11:01:22.249]         base::sink(type = "output", split = FALSE)
[11:01:22.249]         if (TRUE) {
[11:01:22.249]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:22.249]         }
[11:01:22.249]         else {
[11:01:22.249]             ...future.result["stdout"] <- base::list(NULL)
[11:01:22.249]         }
[11:01:22.249]         base::close(...future.stdout)
[11:01:22.249]         ...future.stdout <- NULL
[11:01:22.249]     }
[11:01:22.249]     ...future.result$conditions <- ...future.conditions
[11:01:22.249]     ...future.result$finished <- base::Sys.time()
[11:01:22.249]     ...future.result
[11:01:22.249] }
[11:01:22.250] assign_globals() ...
[11:01:22.250] List of 1
[11:01:22.250]  $ a: num 1
[11:01:22.250]  - attr(*, "where")=List of 1
[11:01:22.250]   ..$ a:<environment: R_EmptyEnv> 
[11:01:22.250]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:22.250]  - attr(*, "resolved")= logi FALSE
[11:01:22.250]  - attr(*, "total_size")= num 39
[11:01:22.250]  - attr(*, "already-done")= logi TRUE
[11:01:22.253] - copied ‘a’ to environment
[11:01:22.253] assign_globals() ... done
[11:01:22.253] plan(): Setting new future strategy stack:
[11:01:22.253] List of future strategies:
[11:01:22.253] 1. sequential:
[11:01:22.253]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.253]    - tweaked: FALSE
[11:01:22.253]    - call: NULL
[11:01:22.253] plan(): nbrOfWorkers() = 1
[11:01:22.255] plan(): Setting new future strategy stack:
[11:01:22.255] List of future strategies:
[11:01:22.255] 1. sequential:
[11:01:22.255]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.255]    - tweaked: FALSE
[11:01:22.255]    - call: plan(strategy)
[11:01:22.256] plan(): nbrOfWorkers() = 1
[11:01:22.256] SequentialFuture started (and completed)
[11:01:22.256] - Launch lazy future ... done
[11:01:22.256] run() for ‘SequentialFuture’ ... done
[11:01:22.256] getGlobalsAndPackages() ...
[11:01:22.256] Searching for globals...
[11:01:22.257] - globals found: [3] ‘{’, ‘*’, ‘a’
[11:01:22.257] Searching for globals ... DONE
[11:01:22.257] Resolving globals: FALSE
[11:01:22.258] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:22.258] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:22.258] - globals: [1] ‘a’
[11:01:22.258] 
[11:01:22.258] getGlobalsAndPackages() ... DONE
[11:01:22.258] run() for ‘Future’ ...
[11:01:22.259] - state: ‘created’
[11:01:22.259] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:22.259] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:22.259] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:22.259]   - Field: ‘label’
[11:01:22.259]   - Field: ‘local’
[11:01:22.259]   - Field: ‘owner’
[11:01:22.259]   - Field: ‘envir’
[11:01:22.259]   - Field: ‘packages’
[11:01:22.260]   - Field: ‘gc’
[11:01:22.260]   - Field: ‘conditions’
[11:01:22.260]   - Field: ‘expr’
[11:01:22.260]   - Field: ‘uuid’
[11:01:22.260]   - Field: ‘seed’
[11:01:22.260]   - Field: ‘version’
[11:01:22.260]   - Field: ‘result’
[11:01:22.260]   - Field: ‘asynchronous’
[11:01:22.260]   - Field: ‘calls’
[11:01:22.260]   - Field: ‘globals’
[11:01:22.260]   - Field: ‘stdout’
[11:01:22.260]   - Field: ‘earlySignal’
[11:01:22.261]   - Field: ‘lazy’
[11:01:22.261]   - Field: ‘state’
[11:01:22.261] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:22.261] - Launch lazy future ...
[11:01:22.261] Packages needed by the future expression (n = 0): <none>
[11:01:22.261] Packages needed by future strategies (n = 0): <none>
[11:01:22.261] {
[11:01:22.261]     {
[11:01:22.261]         {
[11:01:22.261]             ...future.startTime <- base::Sys.time()
[11:01:22.261]             {
[11:01:22.261]                 {
[11:01:22.261]                   {
[11:01:22.261]                     base::local({
[11:01:22.261]                       has_future <- base::requireNamespace("future", 
[11:01:22.261]                         quietly = TRUE)
[11:01:22.261]                       if (has_future) {
[11:01:22.261]                         ns <- base::getNamespace("future")
[11:01:22.261]                         version <- ns[[".package"]][["version"]]
[11:01:22.261]                         if (is.null(version)) 
[11:01:22.261]                           version <- utils::packageVersion("future")
[11:01:22.261]                       }
[11:01:22.261]                       else {
[11:01:22.261]                         version <- NULL
[11:01:22.261]                       }
[11:01:22.261]                       if (!has_future || version < "1.8.0") {
[11:01:22.261]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:22.261]                           "", base::R.version$version.string), 
[11:01:22.261]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:22.261]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:22.261]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:22.261]                             "release", "version")], collapse = " "), 
[11:01:22.261]                           hostname = base::Sys.info()[["nodename"]])
[11:01:22.261]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:22.261]                           info)
[11:01:22.261]                         info <- base::paste(info, collapse = "; ")
[11:01:22.261]                         if (!has_future) {
[11:01:22.261]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:22.261]                             info)
[11:01:22.261]                         }
[11:01:22.261]                         else {
[11:01:22.261]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:22.261]                             info, version)
[11:01:22.261]                         }
[11:01:22.261]                         base::stop(msg)
[11:01:22.261]                       }
[11:01:22.261]                     })
[11:01:22.261]                   }
[11:01:22.261]                   ...future.strategy.old <- future::plan("list")
[11:01:22.261]                   options(future.plan = NULL)
[11:01:22.261]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.261]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:22.261]                 }
[11:01:22.261]                 ...future.workdir <- getwd()
[11:01:22.261]             }
[11:01:22.261]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:22.261]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:22.261]         }
[11:01:22.261]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:22.261]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:22.261]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:22.261]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:22.261]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:22.261]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:22.261]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:22.261]             base::names(...future.oldOptions))
[11:01:22.261]     }
[11:01:22.261]     if (FALSE) {
[11:01:22.261]     }
[11:01:22.261]     else {
[11:01:22.261]         if (TRUE) {
[11:01:22.261]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:22.261]                 open = "w")
[11:01:22.261]         }
[11:01:22.261]         else {
[11:01:22.261]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:22.261]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:22.261]         }
[11:01:22.261]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:22.261]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:22.261]             base::sink(type = "output", split = FALSE)
[11:01:22.261]             base::close(...future.stdout)
[11:01:22.261]         }, add = TRUE)
[11:01:22.261]     }
[11:01:22.261]     ...future.frame <- base::sys.nframe()
[11:01:22.261]     ...future.conditions <- base::list()
[11:01:22.261]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:22.261]     if (FALSE) {
[11:01:22.261]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:22.261]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:22.261]     }
[11:01:22.261]     ...future.result <- base::tryCatch({
[11:01:22.261]         base::withCallingHandlers({
[11:01:22.261]             ...future.value <- base::withVisible(base::local({
[11:01:22.261]                 2 * a
[11:01:22.261]             }))
[11:01:22.261]             future::FutureResult(value = ...future.value$value, 
[11:01:22.261]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.261]                   ...future.rng), globalenv = if (FALSE) 
[11:01:22.261]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:22.261]                     ...future.globalenv.names))
[11:01:22.261]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:22.261]         }, condition = base::local({
[11:01:22.261]             c <- base::c
[11:01:22.261]             inherits <- base::inherits
[11:01:22.261]             invokeRestart <- base::invokeRestart
[11:01:22.261]             length <- base::length
[11:01:22.261]             list <- base::list
[11:01:22.261]             seq.int <- base::seq.int
[11:01:22.261]             signalCondition <- base::signalCondition
[11:01:22.261]             sys.calls <- base::sys.calls
[11:01:22.261]             `[[` <- base::`[[`
[11:01:22.261]             `+` <- base::`+`
[11:01:22.261]             `<<-` <- base::`<<-`
[11:01:22.261]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:22.261]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:22.261]                   3L)]
[11:01:22.261]             }
[11:01:22.261]             function(cond) {
[11:01:22.261]                 is_error <- inherits(cond, "error")
[11:01:22.261]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:22.261]                   NULL)
[11:01:22.261]                 if (is_error) {
[11:01:22.261]                   sessionInformation <- function() {
[11:01:22.261]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:22.261]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:22.261]                       search = base::search(), system = base::Sys.info())
[11:01:22.261]                   }
[11:01:22.261]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.261]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:22.261]                     cond$call), session = sessionInformation(), 
[11:01:22.261]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:22.261]                   signalCondition(cond)
[11:01:22.261]                 }
[11:01:22.261]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:22.261]                 "immediateCondition"))) {
[11:01:22.261]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:22.261]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.261]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:22.261]                   if (TRUE && !signal) {
[11:01:22.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.261]                     {
[11:01:22.261]                       inherits <- base::inherits
[11:01:22.261]                       invokeRestart <- base::invokeRestart
[11:01:22.261]                       is.null <- base::is.null
[11:01:22.261]                       muffled <- FALSE
[11:01:22.261]                       if (inherits(cond, "message")) {
[11:01:22.261]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.261]                         if (muffled) 
[11:01:22.261]                           invokeRestart("muffleMessage")
[11:01:22.261]                       }
[11:01:22.261]                       else if (inherits(cond, "warning")) {
[11:01:22.261]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.261]                         if (muffled) 
[11:01:22.261]                           invokeRestart("muffleWarning")
[11:01:22.261]                       }
[11:01:22.261]                       else if (inherits(cond, "condition")) {
[11:01:22.261]                         if (!is.null(pattern)) {
[11:01:22.261]                           computeRestarts <- base::computeRestarts
[11:01:22.261]                           grepl <- base::grepl
[11:01:22.261]                           restarts <- computeRestarts(cond)
[11:01:22.261]                           for (restart in restarts) {
[11:01:22.261]                             name <- restart$name
[11:01:22.261]                             if (is.null(name)) 
[11:01:22.261]                               next
[11:01:22.261]                             if (!grepl(pattern, name)) 
[11:01:22.261]                               next
[11:01:22.261]                             invokeRestart(restart)
[11:01:22.261]                             muffled <- TRUE
[11:01:22.261]                             break
[11:01:22.261]                           }
[11:01:22.261]                         }
[11:01:22.261]                       }
[11:01:22.261]                       invisible(muffled)
[11:01:22.261]                     }
[11:01:22.261]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.261]                   }
[11:01:22.261]                 }
[11:01:22.261]                 else {
[11:01:22.261]                   if (TRUE) {
[11:01:22.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.261]                     {
[11:01:22.261]                       inherits <- base::inherits
[11:01:22.261]                       invokeRestart <- base::invokeRestart
[11:01:22.261]                       is.null <- base::is.null
[11:01:22.261]                       muffled <- FALSE
[11:01:22.261]                       if (inherits(cond, "message")) {
[11:01:22.261]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.261]                         if (muffled) 
[11:01:22.261]                           invokeRestart("muffleMessage")
[11:01:22.261]                       }
[11:01:22.261]                       else if (inherits(cond, "warning")) {
[11:01:22.261]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.261]                         if (muffled) 
[11:01:22.261]                           invokeRestart("muffleWarning")
[11:01:22.261]                       }
[11:01:22.261]                       else if (inherits(cond, "condition")) {
[11:01:22.261]                         if (!is.null(pattern)) {
[11:01:22.261]                           computeRestarts <- base::computeRestarts
[11:01:22.261]                           grepl <- base::grepl
[11:01:22.261]                           restarts <- computeRestarts(cond)
[11:01:22.261]                           for (restart in restarts) {
[11:01:22.261]                             name <- restart$name
[11:01:22.261]                             if (is.null(name)) 
[11:01:22.261]                               next
[11:01:22.261]                             if (!grepl(pattern, name)) 
[11:01:22.261]                               next
[11:01:22.261]                             invokeRestart(restart)
[11:01:22.261]                             muffled <- TRUE
[11:01:22.261]                             break
[11:01:22.261]                           }
[11:01:22.261]                         }
[11:01:22.261]                       }
[11:01:22.261]                       invisible(muffled)
[11:01:22.261]                     }
[11:01:22.261]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.261]                   }
[11:01:22.261]                 }
[11:01:22.261]             }
[11:01:22.261]         }))
[11:01:22.261]     }, error = function(ex) {
[11:01:22.261]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:22.261]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.261]                 ...future.rng), started = ...future.startTime, 
[11:01:22.261]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:22.261]             version = "1.8"), class = "FutureResult")
[11:01:22.261]     }, finally = {
[11:01:22.261]         if (!identical(...future.workdir, getwd())) 
[11:01:22.261]             setwd(...future.workdir)
[11:01:22.261]         {
[11:01:22.261]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:22.261]                 ...future.oldOptions$nwarnings <- NULL
[11:01:22.261]             }
[11:01:22.261]             base::options(...future.oldOptions)
[11:01:22.261]             if (.Platform$OS.type == "windows") {
[11:01:22.261]                 old_names <- names(...future.oldEnvVars)
[11:01:22.261]                 envs <- base::Sys.getenv()
[11:01:22.261]                 names <- names(envs)
[11:01:22.261]                 common <- intersect(names, old_names)
[11:01:22.261]                 added <- setdiff(names, old_names)
[11:01:22.261]                 removed <- setdiff(old_names, names)
[11:01:22.261]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:22.261]                   envs[common]]
[11:01:22.261]                 NAMES <- toupper(changed)
[11:01:22.261]                 args <- list()
[11:01:22.261]                 for (kk in seq_along(NAMES)) {
[11:01:22.261]                   name <- changed[[kk]]
[11:01:22.261]                   NAME <- NAMES[[kk]]
[11:01:22.261]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.261]                     next
[11:01:22.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.261]                 }
[11:01:22.261]                 NAMES <- toupper(added)
[11:01:22.261]                 for (kk in seq_along(NAMES)) {
[11:01:22.261]                   name <- added[[kk]]
[11:01:22.261]                   NAME <- NAMES[[kk]]
[11:01:22.261]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.261]                     next
[11:01:22.261]                   args[[name]] <- ""
[11:01:22.261]                 }
[11:01:22.261]                 NAMES <- toupper(removed)
[11:01:22.261]                 for (kk in seq_along(NAMES)) {
[11:01:22.261]                   name <- removed[[kk]]
[11:01:22.261]                   NAME <- NAMES[[kk]]
[11:01:22.261]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.261]                     next
[11:01:22.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.261]                 }
[11:01:22.261]                 if (length(args) > 0) 
[11:01:22.261]                   base::do.call(base::Sys.setenv, args = args)
[11:01:22.261]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:22.261]             }
[11:01:22.261]             else {
[11:01:22.261]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:22.261]             }
[11:01:22.261]             {
[11:01:22.261]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:22.261]                   0L) {
[11:01:22.261]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:22.261]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:22.261]                   base::options(opts)
[11:01:22.261]                 }
[11:01:22.261]                 {
[11:01:22.261]                   {
[11:01:22.261]                     NULL
[11:01:22.261]                     RNGkind("Mersenne-Twister")
[11:01:22.261]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:22.261]                       inherits = FALSE)
[11:01:22.261]                   }
[11:01:22.261]                   options(future.plan = NULL)
[11:01:22.261]                   if (is.na(NA_character_)) 
[11:01:22.261]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.261]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:22.261]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:22.261]                     .init = FALSE)
[11:01:22.261]                 }
[11:01:22.261]             }
[11:01:22.261]         }
[11:01:22.261]     })
[11:01:22.261]     if (TRUE) {
[11:01:22.261]         base::sink(type = "output", split = FALSE)
[11:01:22.261]         if (TRUE) {
[11:01:22.261]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:22.261]         }
[11:01:22.261]         else {
[11:01:22.261]             ...future.result["stdout"] <- base::list(NULL)
[11:01:22.261]         }
[11:01:22.261]         base::close(...future.stdout)
[11:01:22.261]         ...future.stdout <- NULL
[11:01:22.261]     }
[11:01:22.261]     ...future.result$conditions <- ...future.conditions
[11:01:22.261]     ...future.result$finished <- base::Sys.time()
[11:01:22.261]     ...future.result
[11:01:22.261] }
[11:01:22.263] assign_globals() ...
[11:01:22.263] List of 1
[11:01:22.263]  $ a: num 1
[11:01:22.263]  - attr(*, "where")=List of 1
[11:01:22.263]   ..$ a:<environment: R_EmptyEnv> 
[11:01:22.263]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:22.263]  - attr(*, "resolved")= logi FALSE
[11:01:22.263]  - attr(*, "total_size")= num 39
[11:01:22.263]  - attr(*, "already-done")= logi TRUE
[11:01:22.265] - copied ‘a’ to environment
[11:01:22.266] assign_globals() ... done
[11:01:22.266] plan(): Setting new future strategy stack:
[11:01:22.266] List of future strategies:
[11:01:22.266] 1. sequential:
[11:01:22.266]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.266]    - tweaked: FALSE
[11:01:22.266]    - call: NULL
[11:01:22.266] plan(): nbrOfWorkers() = 1
[11:01:22.267] plan(): Setting new future strategy stack:
[11:01:22.267] List of future strategies:
[11:01:22.267] 1. sequential:
[11:01:22.267]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.267]    - tweaked: FALSE
[11:01:22.267]    - call: plan(strategy)
[11:01:22.267] plan(): nbrOfWorkers() = 1
[11:01:22.268] SequentialFuture started (and completed)
[11:01:22.268] - Launch lazy future ... done
[11:01:22.268] run() for ‘SequentialFuture’ ... done
[11:01:22.268] getGlobalsAndPackages() ...
[11:01:22.268] Searching for globals...
[11:01:22.269] - globals found: [3] ‘{’, ‘*’, ‘a’
[11:01:22.269] Searching for globals ... DONE
[11:01:22.269] Resolving globals: FALSE
[11:01:22.269] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:22.270] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:22.270] - globals: [1] ‘a’
[11:01:22.270] 
[11:01:22.270] getGlobalsAndPackages() ... DONE
[11:01:22.270] run() for ‘Future’ ...
[11:01:22.270] - state: ‘created’
[11:01:22.270] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:22.271] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:22.271] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:22.271]   - Field: ‘label’
[11:01:22.271]   - Field: ‘local’
[11:01:22.271]   - Field: ‘owner’
[11:01:22.271]   - Field: ‘envir’
[11:01:22.271]   - Field: ‘packages’
[11:01:22.271]   - Field: ‘gc’
[11:01:22.271]   - Field: ‘conditions’
[11:01:22.271]   - Field: ‘expr’
[11:01:22.271]   - Field: ‘uuid’
[11:01:22.271]   - Field: ‘seed’
[11:01:22.272]   - Field: ‘version’
[11:01:22.272]   - Field: ‘result’
[11:01:22.272]   - Field: ‘asynchronous’
[11:01:22.272]   - Field: ‘calls’
[11:01:22.272]   - Field: ‘globals’
[11:01:22.272]   - Field: ‘stdout’
[11:01:22.272]   - Field: ‘earlySignal’
[11:01:22.272]   - Field: ‘lazy’
[11:01:22.272]   - Field: ‘state’
[11:01:22.272] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:22.272] - Launch lazy future ...
[11:01:22.273] Packages needed by the future expression (n = 0): <none>
[11:01:22.273] Packages needed by future strategies (n = 0): <none>
[11:01:22.273] {
[11:01:22.273]     {
[11:01:22.273]         {
[11:01:22.273]             ...future.startTime <- base::Sys.time()
[11:01:22.273]             {
[11:01:22.273]                 {
[11:01:22.273]                   {
[11:01:22.273]                     base::local({
[11:01:22.273]                       has_future <- base::requireNamespace("future", 
[11:01:22.273]                         quietly = TRUE)
[11:01:22.273]                       if (has_future) {
[11:01:22.273]                         ns <- base::getNamespace("future")
[11:01:22.273]                         version <- ns[[".package"]][["version"]]
[11:01:22.273]                         if (is.null(version)) 
[11:01:22.273]                           version <- utils::packageVersion("future")
[11:01:22.273]                       }
[11:01:22.273]                       else {
[11:01:22.273]                         version <- NULL
[11:01:22.273]                       }
[11:01:22.273]                       if (!has_future || version < "1.8.0") {
[11:01:22.273]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:22.273]                           "", base::R.version$version.string), 
[11:01:22.273]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:22.273]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:22.273]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:22.273]                             "release", "version")], collapse = " "), 
[11:01:22.273]                           hostname = base::Sys.info()[["nodename"]])
[11:01:22.273]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:22.273]                           info)
[11:01:22.273]                         info <- base::paste(info, collapse = "; ")
[11:01:22.273]                         if (!has_future) {
[11:01:22.273]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:22.273]                             info)
[11:01:22.273]                         }
[11:01:22.273]                         else {
[11:01:22.273]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:22.273]                             info, version)
[11:01:22.273]                         }
[11:01:22.273]                         base::stop(msg)
[11:01:22.273]                       }
[11:01:22.273]                     })
[11:01:22.273]                   }
[11:01:22.273]                   ...future.strategy.old <- future::plan("list")
[11:01:22.273]                   options(future.plan = NULL)
[11:01:22.273]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.273]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:22.273]                 }
[11:01:22.273]                 ...future.workdir <- getwd()
[11:01:22.273]             }
[11:01:22.273]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:22.273]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:22.273]         }
[11:01:22.273]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:22.273]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:22.273]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:22.273]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:22.273]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:22.273]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:22.273]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:22.273]             base::names(...future.oldOptions))
[11:01:22.273]     }
[11:01:22.273]     if (FALSE) {
[11:01:22.273]     }
[11:01:22.273]     else {
[11:01:22.273]         if (TRUE) {
[11:01:22.273]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:22.273]                 open = "w")
[11:01:22.273]         }
[11:01:22.273]         else {
[11:01:22.273]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:22.273]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:22.273]         }
[11:01:22.273]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:22.273]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:22.273]             base::sink(type = "output", split = FALSE)
[11:01:22.273]             base::close(...future.stdout)
[11:01:22.273]         }, add = TRUE)
[11:01:22.273]     }
[11:01:22.273]     ...future.frame <- base::sys.nframe()
[11:01:22.273]     ...future.conditions <- base::list()
[11:01:22.273]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:22.273]     if (FALSE) {
[11:01:22.273]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:22.273]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:22.273]     }
[11:01:22.273]     ...future.result <- base::tryCatch({
[11:01:22.273]         base::withCallingHandlers({
[11:01:22.273]             ...future.value <- base::withVisible(base::local({
[11:01:22.273]                 2 * a
[11:01:22.273]             }))
[11:01:22.273]             future::FutureResult(value = ...future.value$value, 
[11:01:22.273]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.273]                   ...future.rng), globalenv = if (FALSE) 
[11:01:22.273]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:22.273]                     ...future.globalenv.names))
[11:01:22.273]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:22.273]         }, condition = base::local({
[11:01:22.273]             c <- base::c
[11:01:22.273]             inherits <- base::inherits
[11:01:22.273]             invokeRestart <- base::invokeRestart
[11:01:22.273]             length <- base::length
[11:01:22.273]             list <- base::list
[11:01:22.273]             seq.int <- base::seq.int
[11:01:22.273]             signalCondition <- base::signalCondition
[11:01:22.273]             sys.calls <- base::sys.calls
[11:01:22.273]             `[[` <- base::`[[`
[11:01:22.273]             `+` <- base::`+`
[11:01:22.273]             `<<-` <- base::`<<-`
[11:01:22.273]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:22.273]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:22.273]                   3L)]
[11:01:22.273]             }
[11:01:22.273]             function(cond) {
[11:01:22.273]                 is_error <- inherits(cond, "error")
[11:01:22.273]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:22.273]                   NULL)
[11:01:22.273]                 if (is_error) {
[11:01:22.273]                   sessionInformation <- function() {
[11:01:22.273]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:22.273]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:22.273]                       search = base::search(), system = base::Sys.info())
[11:01:22.273]                   }
[11:01:22.273]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.273]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:22.273]                     cond$call), session = sessionInformation(), 
[11:01:22.273]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:22.273]                   signalCondition(cond)
[11:01:22.273]                 }
[11:01:22.273]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:22.273]                 "immediateCondition"))) {
[11:01:22.273]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:22.273]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.273]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:22.273]                   if (TRUE && !signal) {
[11:01:22.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.273]                     {
[11:01:22.273]                       inherits <- base::inherits
[11:01:22.273]                       invokeRestart <- base::invokeRestart
[11:01:22.273]                       is.null <- base::is.null
[11:01:22.273]                       muffled <- FALSE
[11:01:22.273]                       if (inherits(cond, "message")) {
[11:01:22.273]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.273]                         if (muffled) 
[11:01:22.273]                           invokeRestart("muffleMessage")
[11:01:22.273]                       }
[11:01:22.273]                       else if (inherits(cond, "warning")) {
[11:01:22.273]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.273]                         if (muffled) 
[11:01:22.273]                           invokeRestart("muffleWarning")
[11:01:22.273]                       }
[11:01:22.273]                       else if (inherits(cond, "condition")) {
[11:01:22.273]                         if (!is.null(pattern)) {
[11:01:22.273]                           computeRestarts <- base::computeRestarts
[11:01:22.273]                           grepl <- base::grepl
[11:01:22.273]                           restarts <- computeRestarts(cond)
[11:01:22.273]                           for (restart in restarts) {
[11:01:22.273]                             name <- restart$name
[11:01:22.273]                             if (is.null(name)) 
[11:01:22.273]                               next
[11:01:22.273]                             if (!grepl(pattern, name)) 
[11:01:22.273]                               next
[11:01:22.273]                             invokeRestart(restart)
[11:01:22.273]                             muffled <- TRUE
[11:01:22.273]                             break
[11:01:22.273]                           }
[11:01:22.273]                         }
[11:01:22.273]                       }
[11:01:22.273]                       invisible(muffled)
[11:01:22.273]                     }
[11:01:22.273]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.273]                   }
[11:01:22.273]                 }
[11:01:22.273]                 else {
[11:01:22.273]                   if (TRUE) {
[11:01:22.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.273]                     {
[11:01:22.273]                       inherits <- base::inherits
[11:01:22.273]                       invokeRestart <- base::invokeRestart
[11:01:22.273]                       is.null <- base::is.null
[11:01:22.273]                       muffled <- FALSE
[11:01:22.273]                       if (inherits(cond, "message")) {
[11:01:22.273]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.273]                         if (muffled) 
[11:01:22.273]                           invokeRestart("muffleMessage")
[11:01:22.273]                       }
[11:01:22.273]                       else if (inherits(cond, "warning")) {
[11:01:22.273]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.273]                         if (muffled) 
[11:01:22.273]                           invokeRestart("muffleWarning")
[11:01:22.273]                       }
[11:01:22.273]                       else if (inherits(cond, "condition")) {
[11:01:22.273]                         if (!is.null(pattern)) {
[11:01:22.273]                           computeRestarts <- base::computeRestarts
[11:01:22.273]                           grepl <- base::grepl
[11:01:22.273]                           restarts <- computeRestarts(cond)
[11:01:22.273]                           for (restart in restarts) {
[11:01:22.273]                             name <- restart$name
[11:01:22.273]                             if (is.null(name)) 
[11:01:22.273]                               next
[11:01:22.273]                             if (!grepl(pattern, name)) 
[11:01:22.273]                               next
[11:01:22.273]                             invokeRestart(restart)
[11:01:22.273]                             muffled <- TRUE
[11:01:22.273]                             break
[11:01:22.273]                           }
[11:01:22.273]                         }
[11:01:22.273]                       }
[11:01:22.273]                       invisible(muffled)
[11:01:22.273]                     }
[11:01:22.273]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.273]                   }
[11:01:22.273]                 }
[11:01:22.273]             }
[11:01:22.273]         }))
[11:01:22.273]     }, error = function(ex) {
[11:01:22.273]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:22.273]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.273]                 ...future.rng), started = ...future.startTime, 
[11:01:22.273]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:22.273]             version = "1.8"), class = "FutureResult")
[11:01:22.273]     }, finally = {
[11:01:22.273]         if (!identical(...future.workdir, getwd())) 
[11:01:22.273]             setwd(...future.workdir)
[11:01:22.273]         {
[11:01:22.273]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:22.273]                 ...future.oldOptions$nwarnings <- NULL
[11:01:22.273]             }
[11:01:22.273]             base::options(...future.oldOptions)
[11:01:22.273]             if (.Platform$OS.type == "windows") {
[11:01:22.273]                 old_names <- names(...future.oldEnvVars)
[11:01:22.273]                 envs <- base::Sys.getenv()
[11:01:22.273]                 names <- names(envs)
[11:01:22.273]                 common <- intersect(names, old_names)
[11:01:22.273]                 added <- setdiff(names, old_names)
[11:01:22.273]                 removed <- setdiff(old_names, names)
[11:01:22.273]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:22.273]                   envs[common]]
[11:01:22.273]                 NAMES <- toupper(changed)
[11:01:22.273]                 args <- list()
[11:01:22.273]                 for (kk in seq_along(NAMES)) {
[11:01:22.273]                   name <- changed[[kk]]
[11:01:22.273]                   NAME <- NAMES[[kk]]
[11:01:22.273]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.273]                     next
[11:01:22.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.273]                 }
[11:01:22.273]                 NAMES <- toupper(added)
[11:01:22.273]                 for (kk in seq_along(NAMES)) {
[11:01:22.273]                   name <- added[[kk]]
[11:01:22.273]                   NAME <- NAMES[[kk]]
[11:01:22.273]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.273]                     next
[11:01:22.273]                   args[[name]] <- ""
[11:01:22.273]                 }
[11:01:22.273]                 NAMES <- toupper(removed)
[11:01:22.273]                 for (kk in seq_along(NAMES)) {
[11:01:22.273]                   name <- removed[[kk]]
[11:01:22.273]                   NAME <- NAMES[[kk]]
[11:01:22.273]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.273]                     next
[11:01:22.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.273]                 }
[11:01:22.273]                 if (length(args) > 0) 
[11:01:22.273]                   base::do.call(base::Sys.setenv, args = args)
[11:01:22.273]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:22.273]             }
[11:01:22.273]             else {
[11:01:22.273]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:22.273]             }
[11:01:22.273]             {
[11:01:22.273]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:22.273]                   0L) {
[11:01:22.273]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:22.273]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:22.273]                   base::options(opts)
[11:01:22.273]                 }
[11:01:22.273]                 {
[11:01:22.273]                   {
[11:01:22.273]                     NULL
[11:01:22.273]                     RNGkind("Mersenne-Twister")
[11:01:22.273]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:22.273]                       inherits = FALSE)
[11:01:22.273]                   }
[11:01:22.273]                   options(future.plan = NULL)
[11:01:22.273]                   if (is.na(NA_character_)) 
[11:01:22.273]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.273]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:22.273]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:22.273]                     .init = FALSE)
[11:01:22.273]                 }
[11:01:22.273]             }
[11:01:22.273]         }
[11:01:22.273]     })
[11:01:22.273]     if (TRUE) {
[11:01:22.273]         base::sink(type = "output", split = FALSE)
[11:01:22.273]         if (TRUE) {
[11:01:22.273]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:22.273]         }
[11:01:22.273]         else {
[11:01:22.273]             ...future.result["stdout"] <- base::list(NULL)
[11:01:22.273]         }
[11:01:22.273]         base::close(...future.stdout)
[11:01:22.273]         ...future.stdout <- NULL
[11:01:22.273]     }
[11:01:22.273]     ...future.result$conditions <- ...future.conditions
[11:01:22.273]     ...future.result$finished <- base::Sys.time()
[11:01:22.273]     ...future.result
[11:01:22.273] }
[11:01:22.275] assign_globals() ...
[11:01:22.275] List of 1
[11:01:22.275]  $ a: num 1
[11:01:22.275]  - attr(*, "where")=List of 1
[11:01:22.275]   ..$ a:<environment: R_EmptyEnv> 
[11:01:22.275]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:22.275]  - attr(*, "resolved")= logi FALSE
[11:01:22.275]  - attr(*, "total_size")= num 39
[11:01:22.275]  - attr(*, "already-done")= logi TRUE
[11:01:22.277] - copied ‘a’ to environment
[11:01:22.277] assign_globals() ... done
[11:01:22.277] plan(): Setting new future strategy stack:
[11:01:22.277] List of future strategies:
[11:01:22.277] 1. sequential:
[11:01:22.277]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.277]    - tweaked: FALSE
[11:01:22.277]    - call: NULL
[11:01:22.278] plan(): nbrOfWorkers() = 1
[11:01:22.278] plan(): Setting new future strategy stack:
[11:01:22.279] List of future strategies:
[11:01:22.279] 1. sequential:
[11:01:22.279]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.279]    - tweaked: FALSE
[11:01:22.279]    - call: plan(strategy)
[11:01:22.279] plan(): nbrOfWorkers() = 1
[11:01:22.279] SequentialFuture started (and completed)
[11:01:22.279] - Launch lazy future ... done
[11:01:22.279] run() for ‘SequentialFuture’ ... done
*** futureAssign() with ‘sequential’ futures ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
*** futureAssign() with ‘multicore’ futures ...
[11:01:22.285] plan(): Setting new future strategy stack:
[11:01:22.285] List of future strategies:
[11:01:22.285] 1. multicore:
[11:01:22.285]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:22.285]    - tweaked: FALSE
[11:01:22.285]    - call: plan(strategy)
[11:01:22.287] plan(): nbrOfWorkers() = 2
[11:01:22.287] getGlobalsAndPackages() ...
[11:01:22.287] Searching for globals...
[11:01:22.288] - globals found: [1] ‘{’
[11:01:22.288] Searching for globals ... DONE
[11:01:22.288] Resolving globals: FALSE
[11:01:22.288] 
[11:01:22.288] 
[11:01:22.288] getGlobalsAndPackages() ... DONE
[11:01:22.289] run() for ‘Future’ ...
[11:01:22.289] - state: ‘created’
[11:01:22.289] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:22.290] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:22.291] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:22.291]   - Field: ‘label’
[11:01:22.291]   - Field: ‘local’
[11:01:22.291]   - Field: ‘owner’
[11:01:22.291]   - Field: ‘envir’
[11:01:22.291]   - Field: ‘workers’
[11:01:22.291]   - Field: ‘packages’
[11:01:22.291]   - Field: ‘gc’
[11:01:22.291]   - Field: ‘job’
[11:01:22.291]   - Field: ‘conditions’
[11:01:22.291]   - Field: ‘expr’
[11:01:22.291]   - Field: ‘uuid’
[11:01:22.292]   - Field: ‘seed’
[11:01:22.292]   - Field: ‘version’
[11:01:22.292]   - Field: ‘result’
[11:01:22.292]   - Field: ‘asynchronous’
[11:01:22.292]   - Field: ‘calls’
[11:01:22.292]   - Field: ‘globals’
[11:01:22.292]   - Field: ‘stdout’
[11:01:22.292]   - Field: ‘earlySignal’
[11:01:22.292]   - Field: ‘lazy’
[11:01:22.292]   - Field: ‘state’
[11:01:22.292] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:22.292] - Launch lazy future ...
[11:01:22.293] Packages needed by the future expression (n = 0): <none>
[11:01:22.293] Packages needed by future strategies (n = 0): <none>
[11:01:22.294] {
[11:01:22.294]     {
[11:01:22.294]         {
[11:01:22.294]             ...future.startTime <- base::Sys.time()
[11:01:22.294]             {
[11:01:22.294]                 {
[11:01:22.294]                   {
[11:01:22.294]                     {
[11:01:22.294]                       base::local({
[11:01:22.294]                         has_future <- base::requireNamespace("future", 
[11:01:22.294]                           quietly = TRUE)
[11:01:22.294]                         if (has_future) {
[11:01:22.294]                           ns <- base::getNamespace("future")
[11:01:22.294]                           version <- ns[[".package"]][["version"]]
[11:01:22.294]                           if (is.null(version)) 
[11:01:22.294]                             version <- utils::packageVersion("future")
[11:01:22.294]                         }
[11:01:22.294]                         else {
[11:01:22.294]                           version <- NULL
[11:01:22.294]                         }
[11:01:22.294]                         if (!has_future || version < "1.8.0") {
[11:01:22.294]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:22.294]                             "", base::R.version$version.string), 
[11:01:22.294]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:22.294]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:22.294]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:22.294]                               "release", "version")], collapse = " "), 
[11:01:22.294]                             hostname = base::Sys.info()[["nodename"]])
[11:01:22.294]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:22.294]                             info)
[11:01:22.294]                           info <- base::paste(info, collapse = "; ")
[11:01:22.294]                           if (!has_future) {
[11:01:22.294]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:22.294]                               info)
[11:01:22.294]                           }
[11:01:22.294]                           else {
[11:01:22.294]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:22.294]                               info, version)
[11:01:22.294]                           }
[11:01:22.294]                           base::stop(msg)
[11:01:22.294]                         }
[11:01:22.294]                       })
[11:01:22.294]                     }
[11:01:22.294]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:22.294]                     base::options(mc.cores = 1L)
[11:01:22.294]                   }
[11:01:22.294]                   ...future.strategy.old <- future::plan("list")
[11:01:22.294]                   options(future.plan = NULL)
[11:01:22.294]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.294]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:22.294]                 }
[11:01:22.294]                 ...future.workdir <- getwd()
[11:01:22.294]             }
[11:01:22.294]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:22.294]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:22.294]         }
[11:01:22.294]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:22.294]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:22.294]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:22.294]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:22.294]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:22.294]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:22.294]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:22.294]             base::names(...future.oldOptions))
[11:01:22.294]     }
[11:01:22.294]     if (FALSE) {
[11:01:22.294]     }
[11:01:22.294]     else {
[11:01:22.294]         if (TRUE) {
[11:01:22.294]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:22.294]                 open = "w")
[11:01:22.294]         }
[11:01:22.294]         else {
[11:01:22.294]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:22.294]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:22.294]         }
[11:01:22.294]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:22.294]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:22.294]             base::sink(type = "output", split = FALSE)
[11:01:22.294]             base::close(...future.stdout)
[11:01:22.294]         }, add = TRUE)
[11:01:22.294]     }
[11:01:22.294]     ...future.frame <- base::sys.nframe()
[11:01:22.294]     ...future.conditions <- base::list()
[11:01:22.294]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:22.294]     if (FALSE) {
[11:01:22.294]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:22.294]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:22.294]     }
[11:01:22.294]     ...future.result <- base::tryCatch({
[11:01:22.294]         base::withCallingHandlers({
[11:01:22.294]             ...future.value <- base::withVisible(base::local({
[11:01:22.294]                 withCallingHandlers({
[11:01:22.294]                   {
[11:01:22.294]                     2
[11:01:22.294]                   }
[11:01:22.294]                 }, immediateCondition = function(cond) {
[11:01:22.294]                   save_rds <- function (object, pathname, ...) 
[11:01:22.294]                   {
[11:01:22.294]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:22.294]                     if (file_test("-f", pathname_tmp)) {
[11:01:22.294]                       fi_tmp <- file.info(pathname_tmp)
[11:01:22.294]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:22.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:22.294]                         fi_tmp[["mtime"]])
[11:01:22.294]                     }
[11:01:22.294]                     tryCatch({
[11:01:22.294]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:22.294]                     }, error = function(ex) {
[11:01:22.294]                       msg <- conditionMessage(ex)
[11:01:22.294]                       fi_tmp <- file.info(pathname_tmp)
[11:01:22.294]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:22.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:22.294]                         fi_tmp[["mtime"]], msg)
[11:01:22.294]                       ex$message <- msg
[11:01:22.294]                       stop(ex)
[11:01:22.294]                     })
[11:01:22.294]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:22.294]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:22.294]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:22.294]                       fi_tmp <- file.info(pathname_tmp)
[11:01:22.294]                       fi <- file.info(pathname)
[11:01:22.294]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:22.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:22.294]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:22.294]                         fi[["size"]], fi[["mtime"]])
[11:01:22.294]                       stop(msg)
[11:01:22.294]                     }
[11:01:22.294]                     invisible(pathname)
[11:01:22.294]                   }
[11:01:22.294]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:22.294]                     rootPath = tempdir()) 
[11:01:22.294]                   {
[11:01:22.294]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:22.294]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:22.294]                       tmpdir = path, fileext = ".rds")
[11:01:22.294]                     save_rds(obj, file)
[11:01:22.294]                   }
[11:01:22.294]                   saveImmediateCondition(cond, path = "/tmp/RtmpdJVX0r/.future/immediateConditions")
[11:01:22.294]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.294]                   {
[11:01:22.294]                     inherits <- base::inherits
[11:01:22.294]                     invokeRestart <- base::invokeRestart
[11:01:22.294]                     is.null <- base::is.null
[11:01:22.294]                     muffled <- FALSE
[11:01:22.294]                     if (inherits(cond, "message")) {
[11:01:22.294]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:22.294]                       if (muffled) 
[11:01:22.294]                         invokeRestart("muffleMessage")
[11:01:22.294]                     }
[11:01:22.294]                     else if (inherits(cond, "warning")) {
[11:01:22.294]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:22.294]                       if (muffled) 
[11:01:22.294]                         invokeRestart("muffleWarning")
[11:01:22.294]                     }
[11:01:22.294]                     else if (inherits(cond, "condition")) {
[11:01:22.294]                       if (!is.null(pattern)) {
[11:01:22.294]                         computeRestarts <- base::computeRestarts
[11:01:22.294]                         grepl <- base::grepl
[11:01:22.294]                         restarts <- computeRestarts(cond)
[11:01:22.294]                         for (restart in restarts) {
[11:01:22.294]                           name <- restart$name
[11:01:22.294]                           if (is.null(name)) 
[11:01:22.294]                             next
[11:01:22.294]                           if (!grepl(pattern, name)) 
[11:01:22.294]                             next
[11:01:22.294]                           invokeRestart(restart)
[11:01:22.294]                           muffled <- TRUE
[11:01:22.294]                           break
[11:01:22.294]                         }
[11:01:22.294]                       }
[11:01:22.294]                     }
[11:01:22.294]                     invisible(muffled)
[11:01:22.294]                   }
[11:01:22.294]                   muffleCondition(cond)
[11:01:22.294]                 })
[11:01:22.294]             }))
[11:01:22.294]             future::FutureResult(value = ...future.value$value, 
[11:01:22.294]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.294]                   ...future.rng), globalenv = if (FALSE) 
[11:01:22.294]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:22.294]                     ...future.globalenv.names))
[11:01:22.294]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:22.294]         }, condition = base::local({
[11:01:22.294]             c <- base::c
[11:01:22.294]             inherits <- base::inherits
[11:01:22.294]             invokeRestart <- base::invokeRestart
[11:01:22.294]             length <- base::length
[11:01:22.294]             list <- base::list
[11:01:22.294]             seq.int <- base::seq.int
[11:01:22.294]             signalCondition <- base::signalCondition
[11:01:22.294]             sys.calls <- base::sys.calls
[11:01:22.294]             `[[` <- base::`[[`
[11:01:22.294]             `+` <- base::`+`
[11:01:22.294]             `<<-` <- base::`<<-`
[11:01:22.294]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:22.294]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:22.294]                   3L)]
[11:01:22.294]             }
[11:01:22.294]             function(cond) {
[11:01:22.294]                 is_error <- inherits(cond, "error")
[11:01:22.294]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:22.294]                   NULL)
[11:01:22.294]                 if (is_error) {
[11:01:22.294]                   sessionInformation <- function() {
[11:01:22.294]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:22.294]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:22.294]                       search = base::search(), system = base::Sys.info())
[11:01:22.294]                   }
[11:01:22.294]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.294]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:22.294]                     cond$call), session = sessionInformation(), 
[11:01:22.294]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:22.294]                   signalCondition(cond)
[11:01:22.294]                 }
[11:01:22.294]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:22.294]                 "immediateCondition"))) {
[11:01:22.294]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:22.294]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.294]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:22.294]                   if (TRUE && !signal) {
[11:01:22.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.294]                     {
[11:01:22.294]                       inherits <- base::inherits
[11:01:22.294]                       invokeRestart <- base::invokeRestart
[11:01:22.294]                       is.null <- base::is.null
[11:01:22.294]                       muffled <- FALSE
[11:01:22.294]                       if (inherits(cond, "message")) {
[11:01:22.294]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.294]                         if (muffled) 
[11:01:22.294]                           invokeRestart("muffleMessage")
[11:01:22.294]                       }
[11:01:22.294]                       else if (inherits(cond, "warning")) {
[11:01:22.294]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.294]                         if (muffled) 
[11:01:22.294]                           invokeRestart("muffleWarning")
[11:01:22.294]                       }
[11:01:22.294]                       else if (inherits(cond, "condition")) {
[11:01:22.294]                         if (!is.null(pattern)) {
[11:01:22.294]                           computeRestarts <- base::computeRestarts
[11:01:22.294]                           grepl <- base::grepl
[11:01:22.294]                           restarts <- computeRestarts(cond)
[11:01:22.294]                           for (restart in restarts) {
[11:01:22.294]                             name <- restart$name
[11:01:22.294]                             if (is.null(name)) 
[11:01:22.294]                               next
[11:01:22.294]                             if (!grepl(pattern, name)) 
[11:01:22.294]                               next
[11:01:22.294]                             invokeRestart(restart)
[11:01:22.294]                             muffled <- TRUE
[11:01:22.294]                             break
[11:01:22.294]                           }
[11:01:22.294]                         }
[11:01:22.294]                       }
[11:01:22.294]                       invisible(muffled)
[11:01:22.294]                     }
[11:01:22.294]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.294]                   }
[11:01:22.294]                 }
[11:01:22.294]                 else {
[11:01:22.294]                   if (TRUE) {
[11:01:22.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.294]                     {
[11:01:22.294]                       inherits <- base::inherits
[11:01:22.294]                       invokeRestart <- base::invokeRestart
[11:01:22.294]                       is.null <- base::is.null
[11:01:22.294]                       muffled <- FALSE
[11:01:22.294]                       if (inherits(cond, "message")) {
[11:01:22.294]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.294]                         if (muffled) 
[11:01:22.294]                           invokeRestart("muffleMessage")
[11:01:22.294]                       }
[11:01:22.294]                       else if (inherits(cond, "warning")) {
[11:01:22.294]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.294]                         if (muffled) 
[11:01:22.294]                           invokeRestart("muffleWarning")
[11:01:22.294]                       }
[11:01:22.294]                       else if (inherits(cond, "condition")) {
[11:01:22.294]                         if (!is.null(pattern)) {
[11:01:22.294]                           computeRestarts <- base::computeRestarts
[11:01:22.294]                           grepl <- base::grepl
[11:01:22.294]                           restarts <- computeRestarts(cond)
[11:01:22.294]                           for (restart in restarts) {
[11:01:22.294]                             name <- restart$name
[11:01:22.294]                             if (is.null(name)) 
[11:01:22.294]                               next
[11:01:22.294]                             if (!grepl(pattern, name)) 
[11:01:22.294]                               next
[11:01:22.294]                             invokeRestart(restart)
[11:01:22.294]                             muffled <- TRUE
[11:01:22.294]                             break
[11:01:22.294]                           }
[11:01:22.294]                         }
[11:01:22.294]                       }
[11:01:22.294]                       invisible(muffled)
[11:01:22.294]                     }
[11:01:22.294]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.294]                   }
[11:01:22.294]                 }
[11:01:22.294]             }
[11:01:22.294]         }))
[11:01:22.294]     }, error = function(ex) {
[11:01:22.294]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:22.294]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.294]                 ...future.rng), started = ...future.startTime, 
[11:01:22.294]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:22.294]             version = "1.8"), class = "FutureResult")
[11:01:22.294]     }, finally = {
[11:01:22.294]         if (!identical(...future.workdir, getwd())) 
[11:01:22.294]             setwd(...future.workdir)
[11:01:22.294]         {
[11:01:22.294]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:22.294]                 ...future.oldOptions$nwarnings <- NULL
[11:01:22.294]             }
[11:01:22.294]             base::options(...future.oldOptions)
[11:01:22.294]             if (.Platform$OS.type == "windows") {
[11:01:22.294]                 old_names <- names(...future.oldEnvVars)
[11:01:22.294]                 envs <- base::Sys.getenv()
[11:01:22.294]                 names <- names(envs)
[11:01:22.294]                 common <- intersect(names, old_names)
[11:01:22.294]                 added <- setdiff(names, old_names)
[11:01:22.294]                 removed <- setdiff(old_names, names)
[11:01:22.294]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:22.294]                   envs[common]]
[11:01:22.294]                 NAMES <- toupper(changed)
[11:01:22.294]                 args <- list()
[11:01:22.294]                 for (kk in seq_along(NAMES)) {
[11:01:22.294]                   name <- changed[[kk]]
[11:01:22.294]                   NAME <- NAMES[[kk]]
[11:01:22.294]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.294]                     next
[11:01:22.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.294]                 }
[11:01:22.294]                 NAMES <- toupper(added)
[11:01:22.294]                 for (kk in seq_along(NAMES)) {
[11:01:22.294]                   name <- added[[kk]]
[11:01:22.294]                   NAME <- NAMES[[kk]]
[11:01:22.294]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.294]                     next
[11:01:22.294]                   args[[name]] <- ""
[11:01:22.294]                 }
[11:01:22.294]                 NAMES <- toupper(removed)
[11:01:22.294]                 for (kk in seq_along(NAMES)) {
[11:01:22.294]                   name <- removed[[kk]]
[11:01:22.294]                   NAME <- NAMES[[kk]]
[11:01:22.294]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.294]                     next
[11:01:22.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.294]                 }
[11:01:22.294]                 if (length(args) > 0) 
[11:01:22.294]                   base::do.call(base::Sys.setenv, args = args)
[11:01:22.294]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:22.294]             }
[11:01:22.294]             else {
[11:01:22.294]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:22.294]             }
[11:01:22.294]             {
[11:01:22.294]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:22.294]                   0L) {
[11:01:22.294]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:22.294]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:22.294]                   base::options(opts)
[11:01:22.294]                 }
[11:01:22.294]                 {
[11:01:22.294]                   {
[11:01:22.294]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:22.294]                     NULL
[11:01:22.294]                   }
[11:01:22.294]                   options(future.plan = NULL)
[11:01:22.294]                   if (is.na(NA_character_)) 
[11:01:22.294]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.294]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:22.294]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:22.294]                     .init = FALSE)
[11:01:22.294]                 }
[11:01:22.294]             }
[11:01:22.294]         }
[11:01:22.294]     })
[11:01:22.294]     if (TRUE) {
[11:01:22.294]         base::sink(type = "output", split = FALSE)
[11:01:22.294]         if (TRUE) {
[11:01:22.294]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:22.294]         }
[11:01:22.294]         else {
[11:01:22.294]             ...future.result["stdout"] <- base::list(NULL)
[11:01:22.294]         }
[11:01:22.294]         base::close(...future.stdout)
[11:01:22.294]         ...future.stdout <- NULL
[11:01:22.294]     }
[11:01:22.294]     ...future.result$conditions <- ...future.conditions
[11:01:22.294]     ...future.result$finished <- base::Sys.time()
[11:01:22.294]     ...future.result
[11:01:22.294] }
[11:01:22.296] requestCore(): workers = 2
[11:01:22.299] MulticoreFuture started
[11:01:22.299] - Launch lazy future ... done
[11:01:22.299] run() for ‘MulticoreFuture’ ... done
[11:01:22.299] plan(): Setting new future strategy stack:
[11:01:22.300] getGlobalsAndPackages() ...
[11:01:22.300] Searching for globals...
[11:01:22.300] List of future strategies:
[11:01:22.300] 1. sequential:
[11:01:22.300]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.300]    - tweaked: FALSE
[11:01:22.300]    - call: NULL
[11:01:22.301] plan(): nbrOfWorkers() = 1
[11:01:22.301] - globals found: [1] ‘{’
[11:01:22.301] Searching for globals ... DONE
[11:01:22.301] Resolving globals: FALSE
[11:01:22.302] 
[11:01:22.302] 
[11:01:22.302] getGlobalsAndPackages() ... DONE
[11:01:22.302] plan(): Setting new future strategy stack:
[11:01:22.303] run() for ‘Future’ ...
[11:01:22.303] - state: ‘created’
[11:01:22.303] List of future strategies:
[11:01:22.303] 1. multicore:
[11:01:22.303]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:22.303]    - tweaked: FALSE
[11:01:22.303]    - call: plan(strategy)
[11:01:22.303] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:22.305] plan(): nbrOfWorkers() = 2
[11:01:22.306] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:22.306] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:22.306]   - Field: ‘label’
[11:01:22.306]   - Field: ‘local’
[11:01:22.306]   - Field: ‘owner’
[11:01:22.307]   - Field: ‘envir’
[11:01:22.307]   - Field: ‘workers’
[11:01:22.307]   - Field: ‘packages’
[11:01:22.307]   - Field: ‘gc’
[11:01:22.307]   - Field: ‘job’
[11:01:22.307]   - Field: ‘conditions’
[11:01:22.307]   - Field: ‘expr’
[11:01:22.308]   - Field: ‘uuid’
[11:01:22.308]   - Field: ‘seed’
[11:01:22.308]   - Field: ‘version’
[11:01:22.308]   - Field: ‘result’
[11:01:22.308]   - Field: ‘asynchronous’
[11:01:22.308]   - Field: ‘calls’
[11:01:22.308]   - Field: ‘globals’
[11:01:22.308]   - Field: ‘stdout’
[11:01:22.309]   - Field: ‘earlySignal’
[11:01:22.309]   - Field: ‘lazy’
[11:01:22.309]   - Field: ‘state’
[11:01:22.309] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:22.309] - Launch lazy future ...
[11:01:22.310] Packages needed by the future expression (n = 0): <none>
[11:01:22.310] Packages needed by future strategies (n = 0): <none>
[11:01:22.310] {
[11:01:22.310]     {
[11:01:22.310]         {
[11:01:22.310]             ...future.startTime <- base::Sys.time()
[11:01:22.310]             {
[11:01:22.310]                 {
[11:01:22.310]                   {
[11:01:22.310]                     {
[11:01:22.310]                       base::local({
[11:01:22.310]                         has_future <- base::requireNamespace("future", 
[11:01:22.310]                           quietly = TRUE)
[11:01:22.310]                         if (has_future) {
[11:01:22.310]                           ns <- base::getNamespace("future")
[11:01:22.310]                           version <- ns[[".package"]][["version"]]
[11:01:22.310]                           if (is.null(version)) 
[11:01:22.310]                             version <- utils::packageVersion("future")
[11:01:22.310]                         }
[11:01:22.310]                         else {
[11:01:22.310]                           version <- NULL
[11:01:22.310]                         }
[11:01:22.310]                         if (!has_future || version < "1.8.0") {
[11:01:22.310]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:22.310]                             "", base::R.version$version.string), 
[11:01:22.310]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:22.310]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:22.310]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:22.310]                               "release", "version")], collapse = " "), 
[11:01:22.310]                             hostname = base::Sys.info()[["nodename"]])
[11:01:22.310]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:22.310]                             info)
[11:01:22.310]                           info <- base::paste(info, collapse = "; ")
[11:01:22.310]                           if (!has_future) {
[11:01:22.310]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:22.310]                               info)
[11:01:22.310]                           }
[11:01:22.310]                           else {
[11:01:22.310]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:22.310]                               info, version)
[11:01:22.310]                           }
[11:01:22.310]                           base::stop(msg)
[11:01:22.310]                         }
[11:01:22.310]                       })
[11:01:22.310]                     }
[11:01:22.310]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:22.310]                     base::options(mc.cores = 1L)
[11:01:22.310]                   }
[11:01:22.310]                   ...future.strategy.old <- future::plan("list")
[11:01:22.310]                   options(future.plan = NULL)
[11:01:22.310]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.310]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:22.310]                 }
[11:01:22.310]                 ...future.workdir <- getwd()
[11:01:22.310]             }
[11:01:22.310]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:22.310]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:22.310]         }
[11:01:22.310]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:22.310]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:22.310]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:22.310]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:22.310]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:22.310]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:22.310]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:22.310]             base::names(...future.oldOptions))
[11:01:22.310]     }
[11:01:22.310]     if (FALSE) {
[11:01:22.310]     }
[11:01:22.310]     else {
[11:01:22.310]         if (TRUE) {
[11:01:22.310]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:22.310]                 open = "w")
[11:01:22.310]         }
[11:01:22.310]         else {
[11:01:22.310]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:22.310]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:22.310]         }
[11:01:22.310]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:22.310]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:22.310]             base::sink(type = "output", split = FALSE)
[11:01:22.310]             base::close(...future.stdout)
[11:01:22.310]         }, add = TRUE)
[11:01:22.310]     }
[11:01:22.310]     ...future.frame <- base::sys.nframe()
[11:01:22.310]     ...future.conditions <- base::list()
[11:01:22.310]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:22.310]     if (FALSE) {
[11:01:22.310]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:22.310]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:22.310]     }
[11:01:22.310]     ...future.result <- base::tryCatch({
[11:01:22.310]         base::withCallingHandlers({
[11:01:22.310]             ...future.value <- base::withVisible(base::local({
[11:01:22.310]                 withCallingHandlers({
[11:01:22.310]                   {
[11:01:22.310]                     4
[11:01:22.310]                   }
[11:01:22.310]                 }, immediateCondition = function(cond) {
[11:01:22.310]                   save_rds <- function (object, pathname, ...) 
[11:01:22.310]                   {
[11:01:22.310]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:22.310]                     if (file_test("-f", pathname_tmp)) {
[11:01:22.310]                       fi_tmp <- file.info(pathname_tmp)
[11:01:22.310]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:22.310]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:22.310]                         fi_tmp[["mtime"]])
[11:01:22.310]                     }
[11:01:22.310]                     tryCatch({
[11:01:22.310]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:22.310]                     }, error = function(ex) {
[11:01:22.310]                       msg <- conditionMessage(ex)
[11:01:22.310]                       fi_tmp <- file.info(pathname_tmp)
[11:01:22.310]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:22.310]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:22.310]                         fi_tmp[["mtime"]], msg)
[11:01:22.310]                       ex$message <- msg
[11:01:22.310]                       stop(ex)
[11:01:22.310]                     })
[11:01:22.310]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:22.310]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:22.310]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:22.310]                       fi_tmp <- file.info(pathname_tmp)
[11:01:22.310]                       fi <- file.info(pathname)
[11:01:22.310]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:22.310]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:22.310]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:22.310]                         fi[["size"]], fi[["mtime"]])
[11:01:22.310]                       stop(msg)
[11:01:22.310]                     }
[11:01:22.310]                     invisible(pathname)
[11:01:22.310]                   }
[11:01:22.310]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:22.310]                     rootPath = tempdir()) 
[11:01:22.310]                   {
[11:01:22.310]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:22.310]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:22.310]                       tmpdir = path, fileext = ".rds")
[11:01:22.310]                     save_rds(obj, file)
[11:01:22.310]                   }
[11:01:22.310]                   saveImmediateCondition(cond, path = "/tmp/RtmpdJVX0r/.future/immediateConditions")
[11:01:22.310]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.310]                   {
[11:01:22.310]                     inherits <- base::inherits
[11:01:22.310]                     invokeRestart <- base::invokeRestart
[11:01:22.310]                     is.null <- base::is.null
[11:01:22.310]                     muffled <- FALSE
[11:01:22.310]                     if (inherits(cond, "message")) {
[11:01:22.310]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:22.310]                       if (muffled) 
[11:01:22.310]                         invokeRestart("muffleMessage")
[11:01:22.310]                     }
[11:01:22.310]                     else if (inherits(cond, "warning")) {
[11:01:22.310]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:22.310]                       if (muffled) 
[11:01:22.310]                         invokeRestart("muffleWarning")
[11:01:22.310]                     }
[11:01:22.310]                     else if (inherits(cond, "condition")) {
[11:01:22.310]                       if (!is.null(pattern)) {
[11:01:22.310]                         computeRestarts <- base::computeRestarts
[11:01:22.310]                         grepl <- base::grepl
[11:01:22.310]                         restarts <- computeRestarts(cond)
[11:01:22.310]                         for (restart in restarts) {
[11:01:22.310]                           name <- restart$name
[11:01:22.310]                           if (is.null(name)) 
[11:01:22.310]                             next
[11:01:22.310]                           if (!grepl(pattern, name)) 
[11:01:22.310]                             next
[11:01:22.310]                           invokeRestart(restart)
[11:01:22.310]                           muffled <- TRUE
[11:01:22.310]                           break
[11:01:22.310]                         }
[11:01:22.310]                       }
[11:01:22.310]                     }
[11:01:22.310]                     invisible(muffled)
[11:01:22.310]                   }
[11:01:22.310]                   muffleCondition(cond)
[11:01:22.310]                 })
[11:01:22.310]             }))
[11:01:22.310]             future::FutureResult(value = ...future.value$value, 
[11:01:22.310]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.310]                   ...future.rng), globalenv = if (FALSE) 
[11:01:22.310]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:22.310]                     ...future.globalenv.names))
[11:01:22.310]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:22.310]         }, condition = base::local({
[11:01:22.310]             c <- base::c
[11:01:22.310]             inherits <- base::inherits
[11:01:22.310]             invokeRestart <- base::invokeRestart
[11:01:22.310]             length <- base::length
[11:01:22.310]             list <- base::list
[11:01:22.310]             seq.int <- base::seq.int
[11:01:22.310]             signalCondition <- base::signalCondition
[11:01:22.310]             sys.calls <- base::sys.calls
[11:01:22.310]             `[[` <- base::`[[`
[11:01:22.310]             `+` <- base::`+`
[11:01:22.310]             `<<-` <- base::`<<-`
[11:01:22.310]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:22.310]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:22.310]                   3L)]
[11:01:22.310]             }
[11:01:22.310]             function(cond) {
[11:01:22.310]                 is_error <- inherits(cond, "error")
[11:01:22.310]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:22.310]                   NULL)
[11:01:22.310]                 if (is_error) {
[11:01:22.310]                   sessionInformation <- function() {
[11:01:22.310]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:22.310]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:22.310]                       search = base::search(), system = base::Sys.info())
[11:01:22.310]                   }
[11:01:22.310]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.310]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:22.310]                     cond$call), session = sessionInformation(), 
[11:01:22.310]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:22.310]                   signalCondition(cond)
[11:01:22.310]                 }
[11:01:22.310]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:22.310]                 "immediateCondition"))) {
[11:01:22.310]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:22.310]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.310]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:22.310]                   if (TRUE && !signal) {
[11:01:22.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.310]                     {
[11:01:22.310]                       inherits <- base::inherits
[11:01:22.310]                       invokeRestart <- base::invokeRestart
[11:01:22.310]                       is.null <- base::is.null
[11:01:22.310]                       muffled <- FALSE
[11:01:22.310]                       if (inherits(cond, "message")) {
[11:01:22.310]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.310]                         if (muffled) 
[11:01:22.310]                           invokeRestart("muffleMessage")
[11:01:22.310]                       }
[11:01:22.310]                       else if (inherits(cond, "warning")) {
[11:01:22.310]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.310]                         if (muffled) 
[11:01:22.310]                           invokeRestart("muffleWarning")
[11:01:22.310]                       }
[11:01:22.310]                       else if (inherits(cond, "condition")) {
[11:01:22.310]                         if (!is.null(pattern)) {
[11:01:22.310]                           computeRestarts <- base::computeRestarts
[11:01:22.310]                           grepl <- base::grepl
[11:01:22.310]                           restarts <- computeRestarts(cond)
[11:01:22.310]                           for (restart in restarts) {
[11:01:22.310]                             name <- restart$name
[11:01:22.310]                             if (is.null(name)) 
[11:01:22.310]                               next
[11:01:22.310]                             if (!grepl(pattern, name)) 
[11:01:22.310]                               next
[11:01:22.310]                             invokeRestart(restart)
[11:01:22.310]                             muffled <- TRUE
[11:01:22.310]                             break
[11:01:22.310]                           }
[11:01:22.310]                         }
[11:01:22.310]                       }
[11:01:22.310]                       invisible(muffled)
[11:01:22.310]                     }
[11:01:22.310]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.310]                   }
[11:01:22.310]                 }
[11:01:22.310]                 else {
[11:01:22.310]                   if (TRUE) {
[11:01:22.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.310]                     {
[11:01:22.310]                       inherits <- base::inherits
[11:01:22.310]                       invokeRestart <- base::invokeRestart
[11:01:22.310]                       is.null <- base::is.null
[11:01:22.310]                       muffled <- FALSE
[11:01:22.310]                       if (inherits(cond, "message")) {
[11:01:22.310]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.310]                         if (muffled) 
[11:01:22.310]                           invokeRestart("muffleMessage")
[11:01:22.310]                       }
[11:01:22.310]                       else if (inherits(cond, "warning")) {
[11:01:22.310]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.310]                         if (muffled) 
[11:01:22.310]                           invokeRestart("muffleWarning")
[11:01:22.310]                       }
[11:01:22.310]                       else if (inherits(cond, "condition")) {
[11:01:22.310]                         if (!is.null(pattern)) {
[11:01:22.310]                           computeRestarts <- base::computeRestarts
[11:01:22.310]                           grepl <- base::grepl
[11:01:22.310]                           restarts <- computeRestarts(cond)
[11:01:22.310]                           for (restart in restarts) {
[11:01:22.310]                             name <- restart$name
[11:01:22.310]                             if (is.null(name)) 
[11:01:22.310]                               next
[11:01:22.310]                             if (!grepl(pattern, name)) 
[11:01:22.310]                               next
[11:01:22.310]                             invokeRestart(restart)
[11:01:22.310]                             muffled <- TRUE
[11:01:22.310]                             break
[11:01:22.310]                           }
[11:01:22.310]                         }
[11:01:22.310]                       }
[11:01:22.310]                       invisible(muffled)
[11:01:22.310]                     }
[11:01:22.310]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.310]                   }
[11:01:22.310]                 }
[11:01:22.310]             }
[11:01:22.310]         }))
[11:01:22.310]     }, error = function(ex) {
[11:01:22.310]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:22.310]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.310]                 ...future.rng), started = ...future.startTime, 
[11:01:22.310]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:22.310]             version = "1.8"), class = "FutureResult")
[11:01:22.310]     }, finally = {
[11:01:22.310]         if (!identical(...future.workdir, getwd())) 
[11:01:22.310]             setwd(...future.workdir)
[11:01:22.310]         {
[11:01:22.310]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:22.310]                 ...future.oldOptions$nwarnings <- NULL
[11:01:22.310]             }
[11:01:22.310]             base::options(...future.oldOptions)
[11:01:22.310]             if (.Platform$OS.type == "windows") {
[11:01:22.310]                 old_names <- names(...future.oldEnvVars)
[11:01:22.310]                 envs <- base::Sys.getenv()
[11:01:22.310]                 names <- names(envs)
[11:01:22.310]                 common <- intersect(names, old_names)
[11:01:22.310]                 added <- setdiff(names, old_names)
[11:01:22.310]                 removed <- setdiff(old_names, names)
[11:01:22.310]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:22.310]                   envs[common]]
[11:01:22.310]                 NAMES <- toupper(changed)
[11:01:22.310]                 args <- list()
[11:01:22.310]                 for (kk in seq_along(NAMES)) {
[11:01:22.310]                   name <- changed[[kk]]
[11:01:22.310]                   NAME <- NAMES[[kk]]
[11:01:22.310]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.310]                     next
[11:01:22.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.310]                 }
[11:01:22.310]                 NAMES <- toupper(added)
[11:01:22.310]                 for (kk in seq_along(NAMES)) {
[11:01:22.310]                   name <- added[[kk]]
[11:01:22.310]                   NAME <- NAMES[[kk]]
[11:01:22.310]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.310]                     next
[11:01:22.310]                   args[[name]] <- ""
[11:01:22.310]                 }
[11:01:22.310]                 NAMES <- toupper(removed)
[11:01:22.310]                 for (kk in seq_along(NAMES)) {
[11:01:22.310]                   name <- removed[[kk]]
[11:01:22.310]                   NAME <- NAMES[[kk]]
[11:01:22.310]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.310]                     next
[11:01:22.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.310]                 }
[11:01:22.310]                 if (length(args) > 0) 
[11:01:22.310]                   base::do.call(base::Sys.setenv, args = args)
[11:01:22.310]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:22.310]             }
[11:01:22.310]             else {
[11:01:22.310]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:22.310]             }
[11:01:22.310]             {
[11:01:22.310]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:22.310]                   0L) {
[11:01:22.310]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:22.310]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:22.310]                   base::options(opts)
[11:01:22.310]                 }
[11:01:22.310]                 {
[11:01:22.310]                   {
[11:01:22.310]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:22.310]                     NULL
[11:01:22.310]                   }
[11:01:22.310]                   options(future.plan = NULL)
[11:01:22.310]                   if (is.na(NA_character_)) 
[11:01:22.310]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.310]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:22.310]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:22.310]                     .init = FALSE)
[11:01:22.310]                 }
[11:01:22.310]             }
[11:01:22.310]         }
[11:01:22.310]     })
[11:01:22.310]     if (TRUE) {
[11:01:22.310]         base::sink(type = "output", split = FALSE)
[11:01:22.310]         if (TRUE) {
[11:01:22.310]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:22.310]         }
[11:01:22.310]         else {
[11:01:22.310]             ...future.result["stdout"] <- base::list(NULL)
[11:01:22.310]         }
[11:01:22.310]         base::close(...future.stdout)
[11:01:22.310]         ...future.stdout <- NULL
[11:01:22.310]     }
[11:01:22.310]     ...future.result$conditions <- ...future.conditions
[11:01:22.310]     ...future.result$finished <- base::Sys.time()
[11:01:22.310]     ...future.result
[11:01:22.310] }
[11:01:22.314] requestCore(): workers = 2
[11:01:22.321] MulticoreFuture started
[11:01:22.321] - Launch lazy future ... done
[11:01:22.321] run() for ‘MulticoreFuture’ ... done
[11:01:22.322] plan(): Setting new future strategy stack:
[11:01:22.323] result() for MulticoreFuture ...
[11:01:22.322] List of future strategies:
[11:01:22.322] 1. sequential:
[11:01:22.322]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.322]    - tweaked: FALSE
[11:01:22.322]    - call: NULL
[11:01:22.323] plan(): nbrOfWorkers() = 1
[11:01:22.325] plan(): Setting new future strategy stack:
[11:01:22.325] List of future strategies:
[11:01:22.325] 1. multicore:
[11:01:22.325]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:22.325]    - tweaked: FALSE
[11:01:22.325]    - call: plan(strategy)
[11:01:22.326] result() for MulticoreFuture ...
[11:01:22.326] result() for MulticoreFuture ... done
[11:01:22.326] result() for MulticoreFuture ... done
[11:01:22.326] result() for MulticoreFuture ...
[11:01:22.326] result() for MulticoreFuture ... done
u$a = 2
[11:01:22.326] result() for MulticoreFuture ...
[11:01:22.329] plan(): nbrOfWorkers() = 2
[11:01:22.329] result() for MulticoreFuture ...
[11:01:22.329] result() for MulticoreFuture ... done
[11:01:22.330] result() for MulticoreFuture ... done
[11:01:22.330] result() for MulticoreFuture ...
[11:01:22.330] result() for MulticoreFuture ... done
v$a = 4
[11:01:22.333] getGlobalsAndPackages() ...
[11:01:22.333] Searching for globals...
[11:01:22.334] - globals found: [3] ‘{’, ‘*’, ‘a’
[11:01:22.335] Searching for globals ... DONE
[11:01:22.335] Resolving globals: FALSE
[11:01:22.335] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:22.336] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:22.336] - globals: [1] ‘a’
[11:01:22.336] 
[11:01:22.336] getGlobalsAndPackages() ... DONE
[11:01:22.336] run() for ‘Future’ ...
[11:01:22.336] - state: ‘created’
[11:01:22.337] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:22.339] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:22.339] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:22.339]   - Field: ‘label’
[11:01:22.339]   - Field: ‘local’
[11:01:22.339]   - Field: ‘owner’
[11:01:22.339]   - Field: ‘envir’
[11:01:22.339]   - Field: ‘workers’
[11:01:22.339]   - Field: ‘packages’
[11:01:22.340]   - Field: ‘gc’
[11:01:22.340]   - Field: ‘job’
[11:01:22.340]   - Field: ‘conditions’
[11:01:22.340]   - Field: ‘expr’
[11:01:22.340]   - Field: ‘uuid’
[11:01:22.340]   - Field: ‘seed’
[11:01:22.340]   - Field: ‘version’
[11:01:22.340]   - Field: ‘result’
[11:01:22.340]   - Field: ‘asynchronous’
[11:01:22.341]   - Field: ‘calls’
[11:01:22.341]   - Field: ‘globals’
[11:01:22.341]   - Field: ‘stdout’
[11:01:22.341]   - Field: ‘earlySignal’
[11:01:22.341]   - Field: ‘lazy’
[11:01:22.341]   - Field: ‘state’
[11:01:22.341] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:22.341] - Launch lazy future ...
[11:01:22.342] Packages needed by the future expression (n = 0): <none>
[11:01:22.342] Packages needed by future strategies (n = 0): <none>
[11:01:22.342] {
[11:01:22.342]     {
[11:01:22.342]         {
[11:01:22.342]             ...future.startTime <- base::Sys.time()
[11:01:22.342]             {
[11:01:22.342]                 {
[11:01:22.342]                   {
[11:01:22.342]                     {
[11:01:22.342]                       base::local({
[11:01:22.342]                         has_future <- base::requireNamespace("future", 
[11:01:22.342]                           quietly = TRUE)
[11:01:22.342]                         if (has_future) {
[11:01:22.342]                           ns <- base::getNamespace("future")
[11:01:22.342]                           version <- ns[[".package"]][["version"]]
[11:01:22.342]                           if (is.null(version)) 
[11:01:22.342]                             version <- utils::packageVersion("future")
[11:01:22.342]                         }
[11:01:22.342]                         else {
[11:01:22.342]                           version <- NULL
[11:01:22.342]                         }
[11:01:22.342]                         if (!has_future || version < "1.8.0") {
[11:01:22.342]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:22.342]                             "", base::R.version$version.string), 
[11:01:22.342]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:22.342]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:22.342]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:22.342]                               "release", "version")], collapse = " "), 
[11:01:22.342]                             hostname = base::Sys.info()[["nodename"]])
[11:01:22.342]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:22.342]                             info)
[11:01:22.342]                           info <- base::paste(info, collapse = "; ")
[11:01:22.342]                           if (!has_future) {
[11:01:22.342]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:22.342]                               info)
[11:01:22.342]                           }
[11:01:22.342]                           else {
[11:01:22.342]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:22.342]                               info, version)
[11:01:22.342]                           }
[11:01:22.342]                           base::stop(msg)
[11:01:22.342]                         }
[11:01:22.342]                       })
[11:01:22.342]                     }
[11:01:22.342]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:22.342]                     base::options(mc.cores = 1L)
[11:01:22.342]                   }
[11:01:22.342]                   ...future.strategy.old <- future::plan("list")
[11:01:22.342]                   options(future.plan = NULL)
[11:01:22.342]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.342]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:22.342]                 }
[11:01:22.342]                 ...future.workdir <- getwd()
[11:01:22.342]             }
[11:01:22.342]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:22.342]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:22.342]         }
[11:01:22.342]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:22.342]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:22.342]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:22.342]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:22.342]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:22.342]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:22.342]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:22.342]             base::names(...future.oldOptions))
[11:01:22.342]     }
[11:01:22.342]     if (FALSE) {
[11:01:22.342]     }
[11:01:22.342]     else {
[11:01:22.342]         if (TRUE) {
[11:01:22.342]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:22.342]                 open = "w")
[11:01:22.342]         }
[11:01:22.342]         else {
[11:01:22.342]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:22.342]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:22.342]         }
[11:01:22.342]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:22.342]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:22.342]             base::sink(type = "output", split = FALSE)
[11:01:22.342]             base::close(...future.stdout)
[11:01:22.342]         }, add = TRUE)
[11:01:22.342]     }
[11:01:22.342]     ...future.frame <- base::sys.nframe()
[11:01:22.342]     ...future.conditions <- base::list()
[11:01:22.342]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:22.342]     if (FALSE) {
[11:01:22.342]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:22.342]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:22.342]     }
[11:01:22.342]     ...future.result <- base::tryCatch({
[11:01:22.342]         base::withCallingHandlers({
[11:01:22.342]             ...future.value <- base::withVisible(base::local({
[11:01:22.342]                 withCallingHandlers({
[11:01:22.342]                   {
[11:01:22.342]                     2 * a
[11:01:22.342]                   }
[11:01:22.342]                 }, immediateCondition = function(cond) {
[11:01:22.342]                   save_rds <- function (object, pathname, ...) 
[11:01:22.342]                   {
[11:01:22.342]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:22.342]                     if (file_test("-f", pathname_tmp)) {
[11:01:22.342]                       fi_tmp <- file.info(pathname_tmp)
[11:01:22.342]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:22.342]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:22.342]                         fi_tmp[["mtime"]])
[11:01:22.342]                     }
[11:01:22.342]                     tryCatch({
[11:01:22.342]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:22.342]                     }, error = function(ex) {
[11:01:22.342]                       msg <- conditionMessage(ex)
[11:01:22.342]                       fi_tmp <- file.info(pathname_tmp)
[11:01:22.342]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:22.342]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:22.342]                         fi_tmp[["mtime"]], msg)
[11:01:22.342]                       ex$message <- msg
[11:01:22.342]                       stop(ex)
[11:01:22.342]                     })
[11:01:22.342]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:22.342]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:22.342]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:22.342]                       fi_tmp <- file.info(pathname_tmp)
[11:01:22.342]                       fi <- file.info(pathname)
[11:01:22.342]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:22.342]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:22.342]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:22.342]                         fi[["size"]], fi[["mtime"]])
[11:01:22.342]                       stop(msg)
[11:01:22.342]                     }
[11:01:22.342]                     invisible(pathname)
[11:01:22.342]                   }
[11:01:22.342]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:22.342]                     rootPath = tempdir()) 
[11:01:22.342]                   {
[11:01:22.342]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:22.342]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:22.342]                       tmpdir = path, fileext = ".rds")
[11:01:22.342]                     save_rds(obj, file)
[11:01:22.342]                   }
[11:01:22.342]                   saveImmediateCondition(cond, path = "/tmp/RtmpdJVX0r/.future/immediateConditions")
[11:01:22.342]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.342]                   {
[11:01:22.342]                     inherits <- base::inherits
[11:01:22.342]                     invokeRestart <- base::invokeRestart
[11:01:22.342]                     is.null <- base::is.null
[11:01:22.342]                     muffled <- FALSE
[11:01:22.342]                     if (inherits(cond, "message")) {
[11:01:22.342]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:22.342]                       if (muffled) 
[11:01:22.342]                         invokeRestart("muffleMessage")
[11:01:22.342]                     }
[11:01:22.342]                     else if (inherits(cond, "warning")) {
[11:01:22.342]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:22.342]                       if (muffled) 
[11:01:22.342]                         invokeRestart("muffleWarning")
[11:01:22.342]                     }
[11:01:22.342]                     else if (inherits(cond, "condition")) {
[11:01:22.342]                       if (!is.null(pattern)) {
[11:01:22.342]                         computeRestarts <- base::computeRestarts
[11:01:22.342]                         grepl <- base::grepl
[11:01:22.342]                         restarts <- computeRestarts(cond)
[11:01:22.342]                         for (restart in restarts) {
[11:01:22.342]                           name <- restart$name
[11:01:22.342]                           if (is.null(name)) 
[11:01:22.342]                             next
[11:01:22.342]                           if (!grepl(pattern, name)) 
[11:01:22.342]                             next
[11:01:22.342]                           invokeRestart(restart)
[11:01:22.342]                           muffled <- TRUE
[11:01:22.342]                           break
[11:01:22.342]                         }
[11:01:22.342]                       }
[11:01:22.342]                     }
[11:01:22.342]                     invisible(muffled)
[11:01:22.342]                   }
[11:01:22.342]                   muffleCondition(cond)
[11:01:22.342]                 })
[11:01:22.342]             }))
[11:01:22.342]             future::FutureResult(value = ...future.value$value, 
[11:01:22.342]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.342]                   ...future.rng), globalenv = if (FALSE) 
[11:01:22.342]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:22.342]                     ...future.globalenv.names))
[11:01:22.342]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:22.342]         }, condition = base::local({
[11:01:22.342]             c <- base::c
[11:01:22.342]             inherits <- base::inherits
[11:01:22.342]             invokeRestart <- base::invokeRestart
[11:01:22.342]             length <- base::length
[11:01:22.342]             list <- base::list
[11:01:22.342]             seq.int <- base::seq.int
[11:01:22.342]             signalCondition <- base::signalCondition
[11:01:22.342]             sys.calls <- base::sys.calls
[11:01:22.342]             `[[` <- base::`[[`
[11:01:22.342]             `+` <- base::`+`
[11:01:22.342]             `<<-` <- base::`<<-`
[11:01:22.342]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:22.342]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:22.342]                   3L)]
[11:01:22.342]             }
[11:01:22.342]             function(cond) {
[11:01:22.342]                 is_error <- inherits(cond, "error")
[11:01:22.342]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:22.342]                   NULL)
[11:01:22.342]                 if (is_error) {
[11:01:22.342]                   sessionInformation <- function() {
[11:01:22.342]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:22.342]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:22.342]                       search = base::search(), system = base::Sys.info())
[11:01:22.342]                   }
[11:01:22.342]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.342]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:22.342]                     cond$call), session = sessionInformation(), 
[11:01:22.342]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:22.342]                   signalCondition(cond)
[11:01:22.342]                 }
[11:01:22.342]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:22.342]                 "immediateCondition"))) {
[11:01:22.342]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:22.342]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.342]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:22.342]                   if (TRUE && !signal) {
[11:01:22.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.342]                     {
[11:01:22.342]                       inherits <- base::inherits
[11:01:22.342]                       invokeRestart <- base::invokeRestart
[11:01:22.342]                       is.null <- base::is.null
[11:01:22.342]                       muffled <- FALSE
[11:01:22.342]                       if (inherits(cond, "message")) {
[11:01:22.342]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.342]                         if (muffled) 
[11:01:22.342]                           invokeRestart("muffleMessage")
[11:01:22.342]                       }
[11:01:22.342]                       else if (inherits(cond, "warning")) {
[11:01:22.342]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.342]                         if (muffled) 
[11:01:22.342]                           invokeRestart("muffleWarning")
[11:01:22.342]                       }
[11:01:22.342]                       else if (inherits(cond, "condition")) {
[11:01:22.342]                         if (!is.null(pattern)) {
[11:01:22.342]                           computeRestarts <- base::computeRestarts
[11:01:22.342]                           grepl <- base::grepl
[11:01:22.342]                           restarts <- computeRestarts(cond)
[11:01:22.342]                           for (restart in restarts) {
[11:01:22.342]                             name <- restart$name
[11:01:22.342]                             if (is.null(name)) 
[11:01:22.342]                               next
[11:01:22.342]                             if (!grepl(pattern, name)) 
[11:01:22.342]                               next
[11:01:22.342]                             invokeRestart(restart)
[11:01:22.342]                             muffled <- TRUE
[11:01:22.342]                             break
[11:01:22.342]                           }
[11:01:22.342]                         }
[11:01:22.342]                       }
[11:01:22.342]                       invisible(muffled)
[11:01:22.342]                     }
[11:01:22.342]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.342]                   }
[11:01:22.342]                 }
[11:01:22.342]                 else {
[11:01:22.342]                   if (TRUE) {
[11:01:22.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.342]                     {
[11:01:22.342]                       inherits <- base::inherits
[11:01:22.342]                       invokeRestart <- base::invokeRestart
[11:01:22.342]                       is.null <- base::is.null
[11:01:22.342]                       muffled <- FALSE
[11:01:22.342]                       if (inherits(cond, "message")) {
[11:01:22.342]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.342]                         if (muffled) 
[11:01:22.342]                           invokeRestart("muffleMessage")
[11:01:22.342]                       }
[11:01:22.342]                       else if (inherits(cond, "warning")) {
[11:01:22.342]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.342]                         if (muffled) 
[11:01:22.342]                           invokeRestart("muffleWarning")
[11:01:22.342]                       }
[11:01:22.342]                       else if (inherits(cond, "condition")) {
[11:01:22.342]                         if (!is.null(pattern)) {
[11:01:22.342]                           computeRestarts <- base::computeRestarts
[11:01:22.342]                           grepl <- base::grepl
[11:01:22.342]                           restarts <- computeRestarts(cond)
[11:01:22.342]                           for (restart in restarts) {
[11:01:22.342]                             name <- restart$name
[11:01:22.342]                             if (is.null(name)) 
[11:01:22.342]                               next
[11:01:22.342]                             if (!grepl(pattern, name)) 
[11:01:22.342]                               next
[11:01:22.342]                             invokeRestart(restart)
[11:01:22.342]                             muffled <- TRUE
[11:01:22.342]                             break
[11:01:22.342]                           }
[11:01:22.342]                         }
[11:01:22.342]                       }
[11:01:22.342]                       invisible(muffled)
[11:01:22.342]                     }
[11:01:22.342]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.342]                   }
[11:01:22.342]                 }
[11:01:22.342]             }
[11:01:22.342]         }))
[11:01:22.342]     }, error = function(ex) {
[11:01:22.342]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:22.342]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.342]                 ...future.rng), started = ...future.startTime, 
[11:01:22.342]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:22.342]             version = "1.8"), class = "FutureResult")
[11:01:22.342]     }, finally = {
[11:01:22.342]         if (!identical(...future.workdir, getwd())) 
[11:01:22.342]             setwd(...future.workdir)
[11:01:22.342]         {
[11:01:22.342]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:22.342]                 ...future.oldOptions$nwarnings <- NULL
[11:01:22.342]             }
[11:01:22.342]             base::options(...future.oldOptions)
[11:01:22.342]             if (.Platform$OS.type == "windows") {
[11:01:22.342]                 old_names <- names(...future.oldEnvVars)
[11:01:22.342]                 envs <- base::Sys.getenv()
[11:01:22.342]                 names <- names(envs)
[11:01:22.342]                 common <- intersect(names, old_names)
[11:01:22.342]                 added <- setdiff(names, old_names)
[11:01:22.342]                 removed <- setdiff(old_names, names)
[11:01:22.342]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:22.342]                   envs[common]]
[11:01:22.342]                 NAMES <- toupper(changed)
[11:01:22.342]                 args <- list()
[11:01:22.342]                 for (kk in seq_along(NAMES)) {
[11:01:22.342]                   name <- changed[[kk]]
[11:01:22.342]                   NAME <- NAMES[[kk]]
[11:01:22.342]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.342]                     next
[11:01:22.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.342]                 }
[11:01:22.342]                 NAMES <- toupper(added)
[11:01:22.342]                 for (kk in seq_along(NAMES)) {
[11:01:22.342]                   name <- added[[kk]]
[11:01:22.342]                   NAME <- NAMES[[kk]]
[11:01:22.342]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.342]                     next
[11:01:22.342]                   args[[name]] <- ""
[11:01:22.342]                 }
[11:01:22.342]                 NAMES <- toupper(removed)
[11:01:22.342]                 for (kk in seq_along(NAMES)) {
[11:01:22.342]                   name <- removed[[kk]]
[11:01:22.342]                   NAME <- NAMES[[kk]]
[11:01:22.342]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.342]                     next
[11:01:22.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.342]                 }
[11:01:22.342]                 if (length(args) > 0) 
[11:01:22.342]                   base::do.call(base::Sys.setenv, args = args)
[11:01:22.342]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:22.342]             }
[11:01:22.342]             else {
[11:01:22.342]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:22.342]             }
[11:01:22.342]             {
[11:01:22.342]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:22.342]                   0L) {
[11:01:22.342]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:22.342]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:22.342]                   base::options(opts)
[11:01:22.342]                 }
[11:01:22.342]                 {
[11:01:22.342]                   {
[11:01:22.342]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:22.342]                     NULL
[11:01:22.342]                   }
[11:01:22.342]                   options(future.plan = NULL)
[11:01:22.342]                   if (is.na(NA_character_)) 
[11:01:22.342]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.342]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:22.342]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:22.342]                     .init = FALSE)
[11:01:22.342]                 }
[11:01:22.342]             }
[11:01:22.342]         }
[11:01:22.342]     })
[11:01:22.342]     if (TRUE) {
[11:01:22.342]         base::sink(type = "output", split = FALSE)
[11:01:22.342]         if (TRUE) {
[11:01:22.342]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:22.342]         }
[11:01:22.342]         else {
[11:01:22.342]             ...future.result["stdout"] <- base::list(NULL)
[11:01:22.342]         }
[11:01:22.342]         base::close(...future.stdout)
[11:01:22.342]         ...future.stdout <- NULL
[11:01:22.342]     }
[11:01:22.342]     ...future.result$conditions <- ...future.conditions
[11:01:22.342]     ...future.result$finished <- base::Sys.time()
[11:01:22.342]     ...future.result
[11:01:22.342] }
[11:01:22.344] assign_globals() ...
[11:01:22.345] List of 1
[11:01:22.345]  $ a: num 1
[11:01:22.345]  - attr(*, "where")=List of 1
[11:01:22.345]   ..$ a:<environment: R_EmptyEnv> 
[11:01:22.345]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:22.345]  - attr(*, "resolved")= logi FALSE
[11:01:22.345]  - attr(*, "total_size")= num 39
[11:01:22.345]  - attr(*, "already-done")= logi TRUE
[11:01:22.348] - copied ‘a’ to environment
[11:01:22.348] assign_globals() ... done
[11:01:22.348] requestCore(): workers = 2
[11:01:22.349] MulticoreFuture started
[11:01:22.350] - Launch lazy future ... done
[11:01:22.350] run() for ‘MulticoreFuture’ ... done
[11:01:22.350] result() for MulticoreFuture ...
[11:01:22.350] plan(): Setting new future strategy stack:
[11:01:22.351] List of future strategies:
[11:01:22.351] 1. sequential:
[11:01:22.351]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.351]    - tweaked: FALSE
[11:01:22.351]    - call: NULL
[11:01:22.352] plan(): nbrOfWorkers() = 1
[11:01:22.353] plan(): Setting new future strategy stack:
[11:01:22.354] List of future strategies:
[11:01:22.354] 1. multicore:
[11:01:22.354]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:22.354]    - tweaked: FALSE
[11:01:22.354]    - call: plan(strategy)
[11:01:22.356] plan(): nbrOfWorkers() = 2
[11:01:22.357] result() for MulticoreFuture ...
[11:01:22.357] result() for MulticoreFuture ... done
[11:01:22.358] result() for MulticoreFuture ... done
[11:01:22.358] result() for MulticoreFuture ...
[11:01:22.358] result() for MulticoreFuture ... done
[11:01:22.358] getGlobalsAndPackages() ...
[11:01:22.358] Searching for globals...
[11:01:22.359] - globals found: [3] ‘{’, ‘*’, ‘a’
[11:01:22.359] Searching for globals ... DONE
[11:01:22.360] Resolving globals: FALSE
[11:01:22.360] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:22.361] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:22.361] - globals: [1] ‘a’
[11:01:22.361] 
[11:01:22.361] getGlobalsAndPackages() ... DONE
[11:01:22.361] run() for ‘Future’ ...
[11:01:22.361] - state: ‘created’
[11:01:22.362] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:22.364] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:22.364] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:22.364]   - Field: ‘label’
[11:01:22.364]   - Field: ‘local’
[11:01:22.364]   - Field: ‘owner’
[11:01:22.364]   - Field: ‘envir’
[11:01:22.364]   - Field: ‘workers’
[11:01:22.364]   - Field: ‘packages’
[11:01:22.364]   - Field: ‘gc’
[11:01:22.365]   - Field: ‘job’
[11:01:22.365]   - Field: ‘conditions’
[11:01:22.365]   - Field: ‘expr’
[11:01:22.365]   - Field: ‘uuid’
[11:01:22.365]   - Field: ‘seed’
[11:01:22.365]   - Field: ‘version’
[11:01:22.365]   - Field: ‘result’
[11:01:22.365]   - Field: ‘asynchronous’
[11:01:22.365]   - Field: ‘calls’
[11:01:22.366]   - Field: ‘globals’
[11:01:22.366]   - Field: ‘stdout’
[11:01:22.366]   - Field: ‘earlySignal’
[11:01:22.366]   - Field: ‘lazy’
[11:01:22.366]   - Field: ‘state’
[11:01:22.366] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:22.366] - Launch lazy future ...
[11:01:22.366] Packages needed by the future expression (n = 0): <none>
[11:01:22.367] Packages needed by future strategies (n = 0): <none>
[11:01:22.367] {
[11:01:22.367]     {
[11:01:22.367]         {
[11:01:22.367]             ...future.startTime <- base::Sys.time()
[11:01:22.367]             {
[11:01:22.367]                 {
[11:01:22.367]                   {
[11:01:22.367]                     {
[11:01:22.367]                       base::local({
[11:01:22.367]                         has_future <- base::requireNamespace("future", 
[11:01:22.367]                           quietly = TRUE)
[11:01:22.367]                         if (has_future) {
[11:01:22.367]                           ns <- base::getNamespace("future")
[11:01:22.367]                           version <- ns[[".package"]][["version"]]
[11:01:22.367]                           if (is.null(version)) 
[11:01:22.367]                             version <- utils::packageVersion("future")
[11:01:22.367]                         }
[11:01:22.367]                         else {
[11:01:22.367]                           version <- NULL
[11:01:22.367]                         }
[11:01:22.367]                         if (!has_future || version < "1.8.0") {
[11:01:22.367]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:22.367]                             "", base::R.version$version.string), 
[11:01:22.367]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:22.367]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:22.367]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:22.367]                               "release", "version")], collapse = " "), 
[11:01:22.367]                             hostname = base::Sys.info()[["nodename"]])
[11:01:22.367]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:22.367]                             info)
[11:01:22.367]                           info <- base::paste(info, collapse = "; ")
[11:01:22.367]                           if (!has_future) {
[11:01:22.367]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:22.367]                               info)
[11:01:22.367]                           }
[11:01:22.367]                           else {
[11:01:22.367]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:22.367]                               info, version)
[11:01:22.367]                           }
[11:01:22.367]                           base::stop(msg)
[11:01:22.367]                         }
[11:01:22.367]                       })
[11:01:22.367]                     }
[11:01:22.367]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:22.367]                     base::options(mc.cores = 1L)
[11:01:22.367]                   }
[11:01:22.367]                   ...future.strategy.old <- future::plan("list")
[11:01:22.367]                   options(future.plan = NULL)
[11:01:22.367]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.367]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:22.367]                 }
[11:01:22.367]                 ...future.workdir <- getwd()
[11:01:22.367]             }
[11:01:22.367]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:22.367]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:22.367]         }
[11:01:22.367]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:22.367]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:22.367]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:22.367]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:22.367]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:22.367]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:22.367]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:22.367]             base::names(...future.oldOptions))
[11:01:22.367]     }
[11:01:22.367]     if (FALSE) {
[11:01:22.367]     }
[11:01:22.367]     else {
[11:01:22.367]         if (TRUE) {
[11:01:22.367]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:22.367]                 open = "w")
[11:01:22.367]         }
[11:01:22.367]         else {
[11:01:22.367]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:22.367]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:22.367]         }
[11:01:22.367]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:22.367]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:22.367]             base::sink(type = "output", split = FALSE)
[11:01:22.367]             base::close(...future.stdout)
[11:01:22.367]         }, add = TRUE)
[11:01:22.367]     }
[11:01:22.367]     ...future.frame <- base::sys.nframe()
[11:01:22.367]     ...future.conditions <- base::list()
[11:01:22.367]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:22.367]     if (FALSE) {
[11:01:22.367]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:22.367]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:22.367]     }
[11:01:22.367]     ...future.result <- base::tryCatch({
[11:01:22.367]         base::withCallingHandlers({
[11:01:22.367]             ...future.value <- base::withVisible(base::local({
[11:01:22.367]                 withCallingHandlers({
[11:01:22.367]                   {
[11:01:22.367]                     2 * a
[11:01:22.367]                   }
[11:01:22.367]                 }, immediateCondition = function(cond) {
[11:01:22.367]                   save_rds <- function (object, pathname, ...) 
[11:01:22.367]                   {
[11:01:22.367]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:22.367]                     if (file_test("-f", pathname_tmp)) {
[11:01:22.367]                       fi_tmp <- file.info(pathname_tmp)
[11:01:22.367]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:22.367]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:22.367]                         fi_tmp[["mtime"]])
[11:01:22.367]                     }
[11:01:22.367]                     tryCatch({
[11:01:22.367]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:22.367]                     }, error = function(ex) {
[11:01:22.367]                       msg <- conditionMessage(ex)
[11:01:22.367]                       fi_tmp <- file.info(pathname_tmp)
[11:01:22.367]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:22.367]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:22.367]                         fi_tmp[["mtime"]], msg)
[11:01:22.367]                       ex$message <- msg
[11:01:22.367]                       stop(ex)
[11:01:22.367]                     })
[11:01:22.367]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:22.367]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:22.367]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:22.367]                       fi_tmp <- file.info(pathname_tmp)
[11:01:22.367]                       fi <- file.info(pathname)
[11:01:22.367]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:22.367]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:22.367]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:22.367]                         fi[["size"]], fi[["mtime"]])
[11:01:22.367]                       stop(msg)
[11:01:22.367]                     }
[11:01:22.367]                     invisible(pathname)
[11:01:22.367]                   }
[11:01:22.367]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:22.367]                     rootPath = tempdir()) 
[11:01:22.367]                   {
[11:01:22.367]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:22.367]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:22.367]                       tmpdir = path, fileext = ".rds")
[11:01:22.367]                     save_rds(obj, file)
[11:01:22.367]                   }
[11:01:22.367]                   saveImmediateCondition(cond, path = "/tmp/RtmpdJVX0r/.future/immediateConditions")
[11:01:22.367]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.367]                   {
[11:01:22.367]                     inherits <- base::inherits
[11:01:22.367]                     invokeRestart <- base::invokeRestart
[11:01:22.367]                     is.null <- base::is.null
[11:01:22.367]                     muffled <- FALSE
[11:01:22.367]                     if (inherits(cond, "message")) {
[11:01:22.367]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:22.367]                       if (muffled) 
[11:01:22.367]                         invokeRestart("muffleMessage")
[11:01:22.367]                     }
[11:01:22.367]                     else if (inherits(cond, "warning")) {
[11:01:22.367]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:22.367]                       if (muffled) 
[11:01:22.367]                         invokeRestart("muffleWarning")
[11:01:22.367]                     }
[11:01:22.367]                     else if (inherits(cond, "condition")) {
[11:01:22.367]                       if (!is.null(pattern)) {
[11:01:22.367]                         computeRestarts <- base::computeRestarts
[11:01:22.367]                         grepl <- base::grepl
[11:01:22.367]                         restarts <- computeRestarts(cond)
[11:01:22.367]                         for (restart in restarts) {
[11:01:22.367]                           name <- restart$name
[11:01:22.367]                           if (is.null(name)) 
[11:01:22.367]                             next
[11:01:22.367]                           if (!grepl(pattern, name)) 
[11:01:22.367]                             next
[11:01:22.367]                           invokeRestart(restart)
[11:01:22.367]                           muffled <- TRUE
[11:01:22.367]                           break
[11:01:22.367]                         }
[11:01:22.367]                       }
[11:01:22.367]                     }
[11:01:22.367]                     invisible(muffled)
[11:01:22.367]                   }
[11:01:22.367]                   muffleCondition(cond)
[11:01:22.367]                 })
[11:01:22.367]             }))
[11:01:22.367]             future::FutureResult(value = ...future.value$value, 
[11:01:22.367]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.367]                   ...future.rng), globalenv = if (FALSE) 
[11:01:22.367]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:22.367]                     ...future.globalenv.names))
[11:01:22.367]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:22.367]         }, condition = base::local({
[11:01:22.367]             c <- base::c
[11:01:22.367]             inherits <- base::inherits
[11:01:22.367]             invokeRestart <- base::invokeRestart
[11:01:22.367]             length <- base::length
[11:01:22.367]             list <- base::list
[11:01:22.367]             seq.int <- base::seq.int
[11:01:22.367]             signalCondition <- base::signalCondition
[11:01:22.367]             sys.calls <- base::sys.calls
[11:01:22.367]             `[[` <- base::`[[`
[11:01:22.367]             `+` <- base::`+`
[11:01:22.367]             `<<-` <- base::`<<-`
[11:01:22.367]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:22.367]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:22.367]                   3L)]
[11:01:22.367]             }
[11:01:22.367]             function(cond) {
[11:01:22.367]                 is_error <- inherits(cond, "error")
[11:01:22.367]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:22.367]                   NULL)
[11:01:22.367]                 if (is_error) {
[11:01:22.367]                   sessionInformation <- function() {
[11:01:22.367]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:22.367]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:22.367]                       search = base::search(), system = base::Sys.info())
[11:01:22.367]                   }
[11:01:22.367]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.367]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:22.367]                     cond$call), session = sessionInformation(), 
[11:01:22.367]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:22.367]                   signalCondition(cond)
[11:01:22.367]                 }
[11:01:22.367]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:22.367]                 "immediateCondition"))) {
[11:01:22.367]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:22.367]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.367]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:22.367]                   if (TRUE && !signal) {
[11:01:22.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.367]                     {
[11:01:22.367]                       inherits <- base::inherits
[11:01:22.367]                       invokeRestart <- base::invokeRestart
[11:01:22.367]                       is.null <- base::is.null
[11:01:22.367]                       muffled <- FALSE
[11:01:22.367]                       if (inherits(cond, "message")) {
[11:01:22.367]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.367]                         if (muffled) 
[11:01:22.367]                           invokeRestart("muffleMessage")
[11:01:22.367]                       }
[11:01:22.367]                       else if (inherits(cond, "warning")) {
[11:01:22.367]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.367]                         if (muffled) 
[11:01:22.367]                           invokeRestart("muffleWarning")
[11:01:22.367]                       }
[11:01:22.367]                       else if (inherits(cond, "condition")) {
[11:01:22.367]                         if (!is.null(pattern)) {
[11:01:22.367]                           computeRestarts <- base::computeRestarts
[11:01:22.367]                           grepl <- base::grepl
[11:01:22.367]                           restarts <- computeRestarts(cond)
[11:01:22.367]                           for (restart in restarts) {
[11:01:22.367]                             name <- restart$name
[11:01:22.367]                             if (is.null(name)) 
[11:01:22.367]                               next
[11:01:22.367]                             if (!grepl(pattern, name)) 
[11:01:22.367]                               next
[11:01:22.367]                             invokeRestart(restart)
[11:01:22.367]                             muffled <- TRUE
[11:01:22.367]                             break
[11:01:22.367]                           }
[11:01:22.367]                         }
[11:01:22.367]                       }
[11:01:22.367]                       invisible(muffled)
[11:01:22.367]                     }
[11:01:22.367]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.367]                   }
[11:01:22.367]                 }
[11:01:22.367]                 else {
[11:01:22.367]                   if (TRUE) {
[11:01:22.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.367]                     {
[11:01:22.367]                       inherits <- base::inherits
[11:01:22.367]                       invokeRestart <- base::invokeRestart
[11:01:22.367]                       is.null <- base::is.null
[11:01:22.367]                       muffled <- FALSE
[11:01:22.367]                       if (inherits(cond, "message")) {
[11:01:22.367]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.367]                         if (muffled) 
[11:01:22.367]                           invokeRestart("muffleMessage")
[11:01:22.367]                       }
[11:01:22.367]                       else if (inherits(cond, "warning")) {
[11:01:22.367]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.367]                         if (muffled) 
[11:01:22.367]                           invokeRestart("muffleWarning")
[11:01:22.367]                       }
[11:01:22.367]                       else if (inherits(cond, "condition")) {
[11:01:22.367]                         if (!is.null(pattern)) {
[11:01:22.367]                           computeRestarts <- base::computeRestarts
[11:01:22.367]                           grepl <- base::grepl
[11:01:22.367]                           restarts <- computeRestarts(cond)
[11:01:22.367]                           for (restart in restarts) {
[11:01:22.367]                             name <- restart$name
[11:01:22.367]                             if (is.null(name)) 
[11:01:22.367]                               next
[11:01:22.367]                             if (!grepl(pattern, name)) 
[11:01:22.367]                               next
[11:01:22.367]                             invokeRestart(restart)
[11:01:22.367]                             muffled <- TRUE
[11:01:22.367]                             break
[11:01:22.367]                           }
[11:01:22.367]                         }
[11:01:22.367]                       }
[11:01:22.367]                       invisible(muffled)
[11:01:22.367]                     }
[11:01:22.367]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.367]                   }
[11:01:22.367]                 }
[11:01:22.367]             }
[11:01:22.367]         }))
[11:01:22.367]     }, error = function(ex) {
[11:01:22.367]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:22.367]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.367]                 ...future.rng), started = ...future.startTime, 
[11:01:22.367]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:22.367]             version = "1.8"), class = "FutureResult")
[11:01:22.367]     }, finally = {
[11:01:22.367]         if (!identical(...future.workdir, getwd())) 
[11:01:22.367]             setwd(...future.workdir)
[11:01:22.367]         {
[11:01:22.367]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:22.367]                 ...future.oldOptions$nwarnings <- NULL
[11:01:22.367]             }
[11:01:22.367]             base::options(...future.oldOptions)
[11:01:22.367]             if (.Platform$OS.type == "windows") {
[11:01:22.367]                 old_names <- names(...future.oldEnvVars)
[11:01:22.367]                 envs <- base::Sys.getenv()
[11:01:22.367]                 names <- names(envs)
[11:01:22.367]                 common <- intersect(names, old_names)
[11:01:22.367]                 added <- setdiff(names, old_names)
[11:01:22.367]                 removed <- setdiff(old_names, names)
[11:01:22.367]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:22.367]                   envs[common]]
[11:01:22.367]                 NAMES <- toupper(changed)
[11:01:22.367]                 args <- list()
[11:01:22.367]                 for (kk in seq_along(NAMES)) {
[11:01:22.367]                   name <- changed[[kk]]
[11:01:22.367]                   NAME <- NAMES[[kk]]
[11:01:22.367]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.367]                     next
[11:01:22.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.367]                 }
[11:01:22.367]                 NAMES <- toupper(added)
[11:01:22.367]                 for (kk in seq_along(NAMES)) {
[11:01:22.367]                   name <- added[[kk]]
[11:01:22.367]                   NAME <- NAMES[[kk]]
[11:01:22.367]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.367]                     next
[11:01:22.367]                   args[[name]] <- ""
[11:01:22.367]                 }
[11:01:22.367]                 NAMES <- toupper(removed)
[11:01:22.367]                 for (kk in seq_along(NAMES)) {
[11:01:22.367]                   name <- removed[[kk]]
[11:01:22.367]                   NAME <- NAMES[[kk]]
[11:01:22.367]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.367]                     next
[11:01:22.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.367]                 }
[11:01:22.367]                 if (length(args) > 0) 
[11:01:22.367]                   base::do.call(base::Sys.setenv, args = args)
[11:01:22.367]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:22.367]             }
[11:01:22.367]             else {
[11:01:22.367]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:22.367]             }
[11:01:22.367]             {
[11:01:22.367]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:22.367]                   0L) {
[11:01:22.367]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:22.367]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:22.367]                   base::options(opts)
[11:01:22.367]                 }
[11:01:22.367]                 {
[11:01:22.367]                   {
[11:01:22.367]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:22.367]                     NULL
[11:01:22.367]                   }
[11:01:22.367]                   options(future.plan = NULL)
[11:01:22.367]                   if (is.na(NA_character_)) 
[11:01:22.367]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.367]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:22.367]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:22.367]                     .init = FALSE)
[11:01:22.367]                 }
[11:01:22.367]             }
[11:01:22.367]         }
[11:01:22.367]     })
[11:01:22.367]     if (TRUE) {
[11:01:22.367]         base::sink(type = "output", split = FALSE)
[11:01:22.367]         if (TRUE) {
[11:01:22.367]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:22.367]         }
[11:01:22.367]         else {
[11:01:22.367]             ...future.result["stdout"] <- base::list(NULL)
[11:01:22.367]         }
[11:01:22.367]         base::close(...future.stdout)
[11:01:22.367]         ...future.stdout <- NULL
[11:01:22.367]     }
[11:01:22.367]     ...future.result$conditions <- ...future.conditions
[11:01:22.367]     ...future.result$finished <- base::Sys.time()
[11:01:22.367]     ...future.result
[11:01:22.367] }
[11:01:22.370] assign_globals() ...
[11:01:22.370] List of 1
[11:01:22.370]  $ a: num 1
[11:01:22.370]  - attr(*, "where")=List of 1
[11:01:22.370]   ..$ a:<environment: R_EmptyEnv> 
[11:01:22.370]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:22.370]  - attr(*, "resolved")= logi FALSE
[11:01:22.370]  - attr(*, "total_size")= num 39
[11:01:22.370]  - attr(*, "already-done")= logi TRUE
[11:01:22.373] - copied ‘a’ to environment
[11:01:22.373] assign_globals() ... done
[11:01:22.373] requestCore(): workers = 2
[11:01:22.374] MulticoreFuture started
[11:01:22.375] - Launch lazy future ... done
[11:01:22.375] run() for ‘MulticoreFuture’ ... done
[11:01:22.375] plan(): Setting new future strategy stack:
[11:01:22.375] result() for MulticoreFuture ...
[11:01:22.376] List of future strategies:
[11:01:22.376] 1. sequential:
[11:01:22.376]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.376]    - tweaked: FALSE
[11:01:22.376]    - call: NULL
[11:01:22.376] plan(): nbrOfWorkers() = 1
[11:01:22.379] plan(): Setting new future strategy stack:
[11:01:22.379] List of future strategies:
[11:01:22.379] 1. multicore:
[11:01:22.379]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:22.379]    - tweaked: FALSE
[11:01:22.379]    - call: plan(strategy)
[11:01:22.383] plan(): nbrOfWorkers() = 2
[11:01:22.384] result() for MulticoreFuture ...
[11:01:22.384] result() for MulticoreFuture ... done
[11:01:22.384] result() for MulticoreFuture ... done
[11:01:22.384] result() for MulticoreFuture ...
[11:01:22.384] result() for MulticoreFuture ... done
[11:01:22.384] getGlobalsAndPackages() ...
[11:01:22.384] Searching for globals...
[11:01:22.386] - globals found: [3] ‘{’, ‘*’, ‘a’
[11:01:22.386] Searching for globals ... DONE
[11:01:22.386] Resolving globals: FALSE
[11:01:22.386] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:22.389] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:22.389] - globals: [1] ‘a’
[11:01:22.389] 
[11:01:22.390] getGlobalsAndPackages() ... DONE
[11:01:22.390] run() for ‘Future’ ...
[11:01:22.390] - state: ‘created’
[11:01:22.390] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:22.392] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:22.392] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:22.393]   - Field: ‘label’
[11:01:22.393]   - Field: ‘local’
[11:01:22.393]   - Field: ‘owner’
[11:01:22.393]   - Field: ‘envir’
[11:01:22.393]   - Field: ‘workers’
[11:01:22.393]   - Field: ‘packages’
[11:01:22.393]   - Field: ‘gc’
[11:01:22.393]   - Field: ‘job’
[11:01:22.393]   - Field: ‘conditions’
[11:01:22.394]   - Field: ‘expr’
[11:01:22.394]   - Field: ‘uuid’
[11:01:22.394]   - Field: ‘seed’
[11:01:22.394]   - Field: ‘version’
[11:01:22.394]   - Field: ‘result’
[11:01:22.394]   - Field: ‘asynchronous’
[11:01:22.394]   - Field: ‘calls’
[11:01:22.394]   - Field: ‘globals’
[11:01:22.394]   - Field: ‘stdout’
[11:01:22.395]   - Field: ‘earlySignal’
[11:01:22.395]   - Field: ‘lazy’
[11:01:22.395]   - Field: ‘state’
[11:01:22.395] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:22.395] - Launch lazy future ...
[11:01:22.395] Packages needed by the future expression (n = 0): <none>
[11:01:22.395] Packages needed by future strategies (n = 0): <none>
[11:01:22.396] {
[11:01:22.396]     {
[11:01:22.396]         {
[11:01:22.396]             ...future.startTime <- base::Sys.time()
[11:01:22.396]             {
[11:01:22.396]                 {
[11:01:22.396]                   {
[11:01:22.396]                     {
[11:01:22.396]                       base::local({
[11:01:22.396]                         has_future <- base::requireNamespace("future", 
[11:01:22.396]                           quietly = TRUE)
[11:01:22.396]                         if (has_future) {
[11:01:22.396]                           ns <- base::getNamespace("future")
[11:01:22.396]                           version <- ns[[".package"]][["version"]]
[11:01:22.396]                           if (is.null(version)) 
[11:01:22.396]                             version <- utils::packageVersion("future")
[11:01:22.396]                         }
[11:01:22.396]                         else {
[11:01:22.396]                           version <- NULL
[11:01:22.396]                         }
[11:01:22.396]                         if (!has_future || version < "1.8.0") {
[11:01:22.396]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:22.396]                             "", base::R.version$version.string), 
[11:01:22.396]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:22.396]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:22.396]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:22.396]                               "release", "version")], collapse = " "), 
[11:01:22.396]                             hostname = base::Sys.info()[["nodename"]])
[11:01:22.396]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:22.396]                             info)
[11:01:22.396]                           info <- base::paste(info, collapse = "; ")
[11:01:22.396]                           if (!has_future) {
[11:01:22.396]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:22.396]                               info)
[11:01:22.396]                           }
[11:01:22.396]                           else {
[11:01:22.396]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:22.396]                               info, version)
[11:01:22.396]                           }
[11:01:22.396]                           base::stop(msg)
[11:01:22.396]                         }
[11:01:22.396]                       })
[11:01:22.396]                     }
[11:01:22.396]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:22.396]                     base::options(mc.cores = 1L)
[11:01:22.396]                   }
[11:01:22.396]                   ...future.strategy.old <- future::plan("list")
[11:01:22.396]                   options(future.plan = NULL)
[11:01:22.396]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.396]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:22.396]                 }
[11:01:22.396]                 ...future.workdir <- getwd()
[11:01:22.396]             }
[11:01:22.396]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:22.396]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:22.396]         }
[11:01:22.396]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:22.396]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:22.396]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:22.396]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:22.396]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:22.396]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:22.396]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:22.396]             base::names(...future.oldOptions))
[11:01:22.396]     }
[11:01:22.396]     if (FALSE) {
[11:01:22.396]     }
[11:01:22.396]     else {
[11:01:22.396]         if (TRUE) {
[11:01:22.396]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:22.396]                 open = "w")
[11:01:22.396]         }
[11:01:22.396]         else {
[11:01:22.396]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:22.396]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:22.396]         }
[11:01:22.396]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:22.396]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:22.396]             base::sink(type = "output", split = FALSE)
[11:01:22.396]             base::close(...future.stdout)
[11:01:22.396]         }, add = TRUE)
[11:01:22.396]     }
[11:01:22.396]     ...future.frame <- base::sys.nframe()
[11:01:22.396]     ...future.conditions <- base::list()
[11:01:22.396]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:22.396]     if (FALSE) {
[11:01:22.396]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:22.396]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:22.396]     }
[11:01:22.396]     ...future.result <- base::tryCatch({
[11:01:22.396]         base::withCallingHandlers({
[11:01:22.396]             ...future.value <- base::withVisible(base::local({
[11:01:22.396]                 withCallingHandlers({
[11:01:22.396]                   {
[11:01:22.396]                     2 * a
[11:01:22.396]                   }
[11:01:22.396]                 }, immediateCondition = function(cond) {
[11:01:22.396]                   save_rds <- function (object, pathname, ...) 
[11:01:22.396]                   {
[11:01:22.396]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:22.396]                     if (file_test("-f", pathname_tmp)) {
[11:01:22.396]                       fi_tmp <- file.info(pathname_tmp)
[11:01:22.396]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:22.396]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:22.396]                         fi_tmp[["mtime"]])
[11:01:22.396]                     }
[11:01:22.396]                     tryCatch({
[11:01:22.396]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:22.396]                     }, error = function(ex) {
[11:01:22.396]                       msg <- conditionMessage(ex)
[11:01:22.396]                       fi_tmp <- file.info(pathname_tmp)
[11:01:22.396]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:22.396]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:22.396]                         fi_tmp[["mtime"]], msg)
[11:01:22.396]                       ex$message <- msg
[11:01:22.396]                       stop(ex)
[11:01:22.396]                     })
[11:01:22.396]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:22.396]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:22.396]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:22.396]                       fi_tmp <- file.info(pathname_tmp)
[11:01:22.396]                       fi <- file.info(pathname)
[11:01:22.396]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:22.396]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:22.396]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:22.396]                         fi[["size"]], fi[["mtime"]])
[11:01:22.396]                       stop(msg)
[11:01:22.396]                     }
[11:01:22.396]                     invisible(pathname)
[11:01:22.396]                   }
[11:01:22.396]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:22.396]                     rootPath = tempdir()) 
[11:01:22.396]                   {
[11:01:22.396]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:22.396]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:22.396]                       tmpdir = path, fileext = ".rds")
[11:01:22.396]                     save_rds(obj, file)
[11:01:22.396]                   }
[11:01:22.396]                   saveImmediateCondition(cond, path = "/tmp/RtmpdJVX0r/.future/immediateConditions")
[11:01:22.396]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.396]                   {
[11:01:22.396]                     inherits <- base::inherits
[11:01:22.396]                     invokeRestart <- base::invokeRestart
[11:01:22.396]                     is.null <- base::is.null
[11:01:22.396]                     muffled <- FALSE
[11:01:22.396]                     if (inherits(cond, "message")) {
[11:01:22.396]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:22.396]                       if (muffled) 
[11:01:22.396]                         invokeRestart("muffleMessage")
[11:01:22.396]                     }
[11:01:22.396]                     else if (inherits(cond, "warning")) {
[11:01:22.396]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:22.396]                       if (muffled) 
[11:01:22.396]                         invokeRestart("muffleWarning")
[11:01:22.396]                     }
[11:01:22.396]                     else if (inherits(cond, "condition")) {
[11:01:22.396]                       if (!is.null(pattern)) {
[11:01:22.396]                         computeRestarts <- base::computeRestarts
[11:01:22.396]                         grepl <- base::grepl
[11:01:22.396]                         restarts <- computeRestarts(cond)
[11:01:22.396]                         for (restart in restarts) {
[11:01:22.396]                           name <- restart$name
[11:01:22.396]                           if (is.null(name)) 
[11:01:22.396]                             next
[11:01:22.396]                           if (!grepl(pattern, name)) 
[11:01:22.396]                             next
[11:01:22.396]                           invokeRestart(restart)
[11:01:22.396]                           muffled <- TRUE
[11:01:22.396]                           break
[11:01:22.396]                         }
[11:01:22.396]                       }
[11:01:22.396]                     }
[11:01:22.396]                     invisible(muffled)
[11:01:22.396]                   }
[11:01:22.396]                   muffleCondition(cond)
[11:01:22.396]                 })
[11:01:22.396]             }))
[11:01:22.396]             future::FutureResult(value = ...future.value$value, 
[11:01:22.396]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.396]                   ...future.rng), globalenv = if (FALSE) 
[11:01:22.396]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:22.396]                     ...future.globalenv.names))
[11:01:22.396]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:22.396]         }, condition = base::local({
[11:01:22.396]             c <- base::c
[11:01:22.396]             inherits <- base::inherits
[11:01:22.396]             invokeRestart <- base::invokeRestart
[11:01:22.396]             length <- base::length
[11:01:22.396]             list <- base::list
[11:01:22.396]             seq.int <- base::seq.int
[11:01:22.396]             signalCondition <- base::signalCondition
[11:01:22.396]             sys.calls <- base::sys.calls
[11:01:22.396]             `[[` <- base::`[[`
[11:01:22.396]             `+` <- base::`+`
[11:01:22.396]             `<<-` <- base::`<<-`
[11:01:22.396]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:22.396]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:22.396]                   3L)]
[11:01:22.396]             }
[11:01:22.396]             function(cond) {
[11:01:22.396]                 is_error <- inherits(cond, "error")
[11:01:22.396]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:22.396]                   NULL)
[11:01:22.396]                 if (is_error) {
[11:01:22.396]                   sessionInformation <- function() {
[11:01:22.396]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:22.396]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:22.396]                       search = base::search(), system = base::Sys.info())
[11:01:22.396]                   }
[11:01:22.396]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.396]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:22.396]                     cond$call), session = sessionInformation(), 
[11:01:22.396]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:22.396]                   signalCondition(cond)
[11:01:22.396]                 }
[11:01:22.396]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:22.396]                 "immediateCondition"))) {
[11:01:22.396]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:22.396]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.396]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:22.396]                   if (TRUE && !signal) {
[11:01:22.396]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.396]                     {
[11:01:22.396]                       inherits <- base::inherits
[11:01:22.396]                       invokeRestart <- base::invokeRestart
[11:01:22.396]                       is.null <- base::is.null
[11:01:22.396]                       muffled <- FALSE
[11:01:22.396]                       if (inherits(cond, "message")) {
[11:01:22.396]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.396]                         if (muffled) 
[11:01:22.396]                           invokeRestart("muffleMessage")
[11:01:22.396]                       }
[11:01:22.396]                       else if (inherits(cond, "warning")) {
[11:01:22.396]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.396]                         if (muffled) 
[11:01:22.396]                           invokeRestart("muffleWarning")
[11:01:22.396]                       }
[11:01:22.396]                       else if (inherits(cond, "condition")) {
[11:01:22.396]                         if (!is.null(pattern)) {
[11:01:22.396]                           computeRestarts <- base::computeRestarts
[11:01:22.396]                           grepl <- base::grepl
[11:01:22.396]                           restarts <- computeRestarts(cond)
[11:01:22.396]                           for (restart in restarts) {
[11:01:22.396]                             name <- restart$name
[11:01:22.396]                             if (is.null(name)) 
[11:01:22.396]                               next
[11:01:22.396]                             if (!grepl(pattern, name)) 
[11:01:22.396]                               next
[11:01:22.396]                             invokeRestart(restart)
[11:01:22.396]                             muffled <- TRUE
[11:01:22.396]                             break
[11:01:22.396]                           }
[11:01:22.396]                         }
[11:01:22.396]                       }
[11:01:22.396]                       invisible(muffled)
[11:01:22.396]                     }
[11:01:22.396]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.396]                   }
[11:01:22.396]                 }
[11:01:22.396]                 else {
[11:01:22.396]                   if (TRUE) {
[11:01:22.396]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.396]                     {
[11:01:22.396]                       inherits <- base::inherits
[11:01:22.396]                       invokeRestart <- base::invokeRestart
[11:01:22.396]                       is.null <- base::is.null
[11:01:22.396]                       muffled <- FALSE
[11:01:22.396]                       if (inherits(cond, "message")) {
[11:01:22.396]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.396]                         if (muffled) 
[11:01:22.396]                           invokeRestart("muffleMessage")
[11:01:22.396]                       }
[11:01:22.396]                       else if (inherits(cond, "warning")) {
[11:01:22.396]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.396]                         if (muffled) 
[11:01:22.396]                           invokeRestart("muffleWarning")
[11:01:22.396]                       }
[11:01:22.396]                       else if (inherits(cond, "condition")) {
[11:01:22.396]                         if (!is.null(pattern)) {
[11:01:22.396]                           computeRestarts <- base::computeRestarts
[11:01:22.396]                           grepl <- base::grepl
[11:01:22.396]                           restarts <- computeRestarts(cond)
[11:01:22.396]                           for (restart in restarts) {
[11:01:22.396]                             name <- restart$name
[11:01:22.396]                             if (is.null(name)) 
[11:01:22.396]                               next
[11:01:22.396]                             if (!grepl(pattern, name)) 
[11:01:22.396]                               next
[11:01:22.396]                             invokeRestart(restart)
[11:01:22.396]                             muffled <- TRUE
[11:01:22.396]                             break
[11:01:22.396]                           }
[11:01:22.396]                         }
[11:01:22.396]                       }
[11:01:22.396]                       invisible(muffled)
[11:01:22.396]                     }
[11:01:22.396]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.396]                   }
[11:01:22.396]                 }
[11:01:22.396]             }
[11:01:22.396]         }))
[11:01:22.396]     }, error = function(ex) {
[11:01:22.396]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:22.396]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.396]                 ...future.rng), started = ...future.startTime, 
[11:01:22.396]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:22.396]             version = "1.8"), class = "FutureResult")
[11:01:22.396]     }, finally = {
[11:01:22.396]         if (!identical(...future.workdir, getwd())) 
[11:01:22.396]             setwd(...future.workdir)
[11:01:22.396]         {
[11:01:22.396]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:22.396]                 ...future.oldOptions$nwarnings <- NULL
[11:01:22.396]             }
[11:01:22.396]             base::options(...future.oldOptions)
[11:01:22.396]             if (.Platform$OS.type == "windows") {
[11:01:22.396]                 old_names <- names(...future.oldEnvVars)
[11:01:22.396]                 envs <- base::Sys.getenv()
[11:01:22.396]                 names <- names(envs)
[11:01:22.396]                 common <- intersect(names, old_names)
[11:01:22.396]                 added <- setdiff(names, old_names)
[11:01:22.396]                 removed <- setdiff(old_names, names)
[11:01:22.396]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:22.396]                   envs[common]]
[11:01:22.396]                 NAMES <- toupper(changed)
[11:01:22.396]                 args <- list()
[11:01:22.396]                 for (kk in seq_along(NAMES)) {
[11:01:22.396]                   name <- changed[[kk]]
[11:01:22.396]                   NAME <- NAMES[[kk]]
[11:01:22.396]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.396]                     next
[11:01:22.396]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.396]                 }
[11:01:22.396]                 NAMES <- toupper(added)
[11:01:22.396]                 for (kk in seq_along(NAMES)) {
[11:01:22.396]                   name <- added[[kk]]
[11:01:22.396]                   NAME <- NAMES[[kk]]
[11:01:22.396]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.396]                     next
[11:01:22.396]                   args[[name]] <- ""
[11:01:22.396]                 }
[11:01:22.396]                 NAMES <- toupper(removed)
[11:01:22.396]                 for (kk in seq_along(NAMES)) {
[11:01:22.396]                   name <- removed[[kk]]
[11:01:22.396]                   NAME <- NAMES[[kk]]
[11:01:22.396]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.396]                     next
[11:01:22.396]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.396]                 }
[11:01:22.396]                 if (length(args) > 0) 
[11:01:22.396]                   base::do.call(base::Sys.setenv, args = args)
[11:01:22.396]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:22.396]             }
[11:01:22.396]             else {
[11:01:22.396]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:22.396]             }
[11:01:22.396]             {
[11:01:22.396]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:22.396]                   0L) {
[11:01:22.396]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:22.396]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:22.396]                   base::options(opts)
[11:01:22.396]                 }
[11:01:22.396]                 {
[11:01:22.396]                   {
[11:01:22.396]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:22.396]                     NULL
[11:01:22.396]                   }
[11:01:22.396]                   options(future.plan = NULL)
[11:01:22.396]                   if (is.na(NA_character_)) 
[11:01:22.396]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.396]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:22.396]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:22.396]                     .init = FALSE)
[11:01:22.396]                 }
[11:01:22.396]             }
[11:01:22.396]         }
[11:01:22.396]     })
[11:01:22.396]     if (TRUE) {
[11:01:22.396]         base::sink(type = "output", split = FALSE)
[11:01:22.396]         if (TRUE) {
[11:01:22.396]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:22.396]         }
[11:01:22.396]         else {
[11:01:22.396]             ...future.result["stdout"] <- base::list(NULL)
[11:01:22.396]         }
[11:01:22.396]         base::close(...future.stdout)
[11:01:22.396]         ...future.stdout <- NULL
[11:01:22.396]     }
[11:01:22.396]     ...future.result$conditions <- ...future.conditions
[11:01:22.396]     ...future.result$finished <- base::Sys.time()
[11:01:22.396]     ...future.result
[11:01:22.396] }
[11:01:22.398] assign_globals() ...
[11:01:22.398] List of 1
[11:01:22.398]  $ a: num 1
[11:01:22.398]  - attr(*, "where")=List of 1
[11:01:22.398]   ..$ a:<environment: R_EmptyEnv> 
[11:01:22.398]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:22.398]  - attr(*, "resolved")= logi FALSE
[11:01:22.398]  - attr(*, "total_size")= num 39
[11:01:22.398]  - attr(*, "already-done")= logi TRUE
[11:01:22.401] - copied ‘a’ to environment
[11:01:22.401] assign_globals() ... done
[11:01:22.402] requestCore(): workers = 2
[11:01:22.403] MulticoreFuture started
[11:01:22.404] - Launch lazy future ... done
[11:01:22.404] run() for ‘MulticoreFuture’ ... done
[11:01:22.404] plan(): Setting new future strategy stack:
[11:01:22.405] result() for MulticoreFuture ...
[11:01:22.404] List of future strategies:
[11:01:22.404] 1. sequential:
[11:01:22.404]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.404]    - tweaked: FALSE
[11:01:22.404]    - call: NULL
[11:01:22.405] plan(): nbrOfWorkers() = 1
[11:01:22.407] plan(): Setting new future strategy stack:
[11:01:22.407] List of future strategies:
[11:01:22.407] 1. multicore:
[11:01:22.407]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:22.407]    - tweaked: FALSE
[11:01:22.407]    - call: plan(strategy)
[11:01:22.410] plan(): nbrOfWorkers() = 2
[11:01:22.411] result() for MulticoreFuture ...
[11:01:22.412] result() for MulticoreFuture ... done
[11:01:22.412] result() for MulticoreFuture ... done
[11:01:22.412] result() for MulticoreFuture ...
[11:01:22.412] result() for MulticoreFuture ... done
[11:01:22.412] getGlobalsAndPackages() ...
[11:01:22.412] Searching for globals...
[11:01:22.414] - globals found: [3] ‘{’, ‘*’, ‘a’
[11:01:22.414] Searching for globals ... DONE
[11:01:22.414] Resolving globals: FALSE
[11:01:22.414] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:22.415] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:22.415] - globals: [1] ‘a’
[11:01:22.415] 
[11:01:22.415] getGlobalsAndPackages() ... DONE
[11:01:22.415] run() for ‘Future’ ...
[11:01:22.416] - state: ‘created’
[11:01:22.416] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:22.418] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:22.418] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:22.418]   - Field: ‘label’
[11:01:22.418]   - Field: ‘local’
[11:01:22.418]   - Field: ‘owner’
[11:01:22.418]   - Field: ‘envir’
[11:01:22.419]   - Field: ‘workers’
[11:01:22.419]   - Field: ‘packages’
[11:01:22.419]   - Field: ‘gc’
[11:01:22.419]   - Field: ‘job’
[11:01:22.419]   - Field: ‘conditions’
[11:01:22.419]   - Field: ‘expr’
[11:01:22.419]   - Field: ‘uuid’
[11:01:22.419]   - Field: ‘seed’
[11:01:22.419]   - Field: ‘version’
[11:01:22.419]   - Field: ‘result’
[11:01:22.420]   - Field: ‘asynchronous’
[11:01:22.420]   - Field: ‘calls’
[11:01:22.420]   - Field: ‘globals’
[11:01:22.420]   - Field: ‘stdout’
[11:01:22.420]   - Field: ‘earlySignal’
[11:01:22.420]   - Field: ‘lazy’
[11:01:22.420]   - Field: ‘state’
[11:01:22.420] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:22.420] - Launch lazy future ...
[11:01:22.421] Packages needed by the future expression (n = 0): <none>
[11:01:22.421] Packages needed by future strategies (n = 0): <none>
[11:01:22.421] {
[11:01:22.421]     {
[11:01:22.421]         {
[11:01:22.421]             ...future.startTime <- base::Sys.time()
[11:01:22.421]             {
[11:01:22.421]                 {
[11:01:22.421]                   {
[11:01:22.421]                     {
[11:01:22.421]                       base::local({
[11:01:22.421]                         has_future <- base::requireNamespace("future", 
[11:01:22.421]                           quietly = TRUE)
[11:01:22.421]                         if (has_future) {
[11:01:22.421]                           ns <- base::getNamespace("future")
[11:01:22.421]                           version <- ns[[".package"]][["version"]]
[11:01:22.421]                           if (is.null(version)) 
[11:01:22.421]                             version <- utils::packageVersion("future")
[11:01:22.421]                         }
[11:01:22.421]                         else {
[11:01:22.421]                           version <- NULL
[11:01:22.421]                         }
[11:01:22.421]                         if (!has_future || version < "1.8.0") {
[11:01:22.421]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:22.421]                             "", base::R.version$version.string), 
[11:01:22.421]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:22.421]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:22.421]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:22.421]                               "release", "version")], collapse = " "), 
[11:01:22.421]                             hostname = base::Sys.info()[["nodename"]])
[11:01:22.421]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:22.421]                             info)
[11:01:22.421]                           info <- base::paste(info, collapse = "; ")
[11:01:22.421]                           if (!has_future) {
[11:01:22.421]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:22.421]                               info)
[11:01:22.421]                           }
[11:01:22.421]                           else {
[11:01:22.421]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:22.421]                               info, version)
[11:01:22.421]                           }
[11:01:22.421]                           base::stop(msg)
[11:01:22.421]                         }
[11:01:22.421]                       })
[11:01:22.421]                     }
[11:01:22.421]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:22.421]                     base::options(mc.cores = 1L)
[11:01:22.421]                   }
[11:01:22.421]                   ...future.strategy.old <- future::plan("list")
[11:01:22.421]                   options(future.plan = NULL)
[11:01:22.421]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.421]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:22.421]                 }
[11:01:22.421]                 ...future.workdir <- getwd()
[11:01:22.421]             }
[11:01:22.421]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:22.421]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:22.421]         }
[11:01:22.421]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:22.421]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:22.421]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:22.421]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:22.421]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:22.421]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:22.421]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:22.421]             base::names(...future.oldOptions))
[11:01:22.421]     }
[11:01:22.421]     if (FALSE) {
[11:01:22.421]     }
[11:01:22.421]     else {
[11:01:22.421]         if (TRUE) {
[11:01:22.421]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:22.421]                 open = "w")
[11:01:22.421]         }
[11:01:22.421]         else {
[11:01:22.421]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:22.421]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:22.421]         }
[11:01:22.421]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:22.421]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:22.421]             base::sink(type = "output", split = FALSE)
[11:01:22.421]             base::close(...future.stdout)
[11:01:22.421]         }, add = TRUE)
[11:01:22.421]     }
[11:01:22.421]     ...future.frame <- base::sys.nframe()
[11:01:22.421]     ...future.conditions <- base::list()
[11:01:22.421]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:22.421]     if (FALSE) {
[11:01:22.421]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:22.421]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:22.421]     }
[11:01:22.421]     ...future.result <- base::tryCatch({
[11:01:22.421]         base::withCallingHandlers({
[11:01:22.421]             ...future.value <- base::withVisible(base::local({
[11:01:22.421]                 withCallingHandlers({
[11:01:22.421]                   {
[11:01:22.421]                     2 * a
[11:01:22.421]                   }
[11:01:22.421]                 }, immediateCondition = function(cond) {
[11:01:22.421]                   save_rds <- function (object, pathname, ...) 
[11:01:22.421]                   {
[11:01:22.421]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:22.421]                     if (file_test("-f", pathname_tmp)) {
[11:01:22.421]                       fi_tmp <- file.info(pathname_tmp)
[11:01:22.421]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:22.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:22.421]                         fi_tmp[["mtime"]])
[11:01:22.421]                     }
[11:01:22.421]                     tryCatch({
[11:01:22.421]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:22.421]                     }, error = function(ex) {
[11:01:22.421]                       msg <- conditionMessage(ex)
[11:01:22.421]                       fi_tmp <- file.info(pathname_tmp)
[11:01:22.421]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:22.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:22.421]                         fi_tmp[["mtime"]], msg)
[11:01:22.421]                       ex$message <- msg
[11:01:22.421]                       stop(ex)
[11:01:22.421]                     })
[11:01:22.421]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:22.421]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:22.421]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:22.421]                       fi_tmp <- file.info(pathname_tmp)
[11:01:22.421]                       fi <- file.info(pathname)
[11:01:22.421]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:22.421]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:22.421]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:22.421]                         fi[["size"]], fi[["mtime"]])
[11:01:22.421]                       stop(msg)
[11:01:22.421]                     }
[11:01:22.421]                     invisible(pathname)
[11:01:22.421]                   }
[11:01:22.421]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:22.421]                     rootPath = tempdir()) 
[11:01:22.421]                   {
[11:01:22.421]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:22.421]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:22.421]                       tmpdir = path, fileext = ".rds")
[11:01:22.421]                     save_rds(obj, file)
[11:01:22.421]                   }
[11:01:22.421]                   saveImmediateCondition(cond, path = "/tmp/RtmpdJVX0r/.future/immediateConditions")
[11:01:22.421]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.421]                   {
[11:01:22.421]                     inherits <- base::inherits
[11:01:22.421]                     invokeRestart <- base::invokeRestart
[11:01:22.421]                     is.null <- base::is.null
[11:01:22.421]                     muffled <- FALSE
[11:01:22.421]                     if (inherits(cond, "message")) {
[11:01:22.421]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:22.421]                       if (muffled) 
[11:01:22.421]                         invokeRestart("muffleMessage")
[11:01:22.421]                     }
[11:01:22.421]                     else if (inherits(cond, "warning")) {
[11:01:22.421]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:22.421]                       if (muffled) 
[11:01:22.421]                         invokeRestart("muffleWarning")
[11:01:22.421]                     }
[11:01:22.421]                     else if (inherits(cond, "condition")) {
[11:01:22.421]                       if (!is.null(pattern)) {
[11:01:22.421]                         computeRestarts <- base::computeRestarts
[11:01:22.421]                         grepl <- base::grepl
[11:01:22.421]                         restarts <- computeRestarts(cond)
[11:01:22.421]                         for (restart in restarts) {
[11:01:22.421]                           name <- restart$name
[11:01:22.421]                           if (is.null(name)) 
[11:01:22.421]                             next
[11:01:22.421]                           if (!grepl(pattern, name)) 
[11:01:22.421]                             next
[11:01:22.421]                           invokeRestart(restart)
[11:01:22.421]                           muffled <- TRUE
[11:01:22.421]                           break
[11:01:22.421]                         }
[11:01:22.421]                       }
[11:01:22.421]                     }
[11:01:22.421]                     invisible(muffled)
[11:01:22.421]                   }
[11:01:22.421]                   muffleCondition(cond)
[11:01:22.421]                 })
[11:01:22.421]             }))
[11:01:22.421]             future::FutureResult(value = ...future.value$value, 
[11:01:22.421]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.421]                   ...future.rng), globalenv = if (FALSE) 
[11:01:22.421]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:22.421]                     ...future.globalenv.names))
[11:01:22.421]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:22.421]         }, condition = base::local({
[11:01:22.421]             c <- base::c
[11:01:22.421]             inherits <- base::inherits
[11:01:22.421]             invokeRestart <- base::invokeRestart
[11:01:22.421]             length <- base::length
[11:01:22.421]             list <- base::list
[11:01:22.421]             seq.int <- base::seq.int
[11:01:22.421]             signalCondition <- base::signalCondition
[11:01:22.421]             sys.calls <- base::sys.calls
[11:01:22.421]             `[[` <- base::`[[`
[11:01:22.421]             `+` <- base::`+`
[11:01:22.421]             `<<-` <- base::`<<-`
[11:01:22.421]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:22.421]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:22.421]                   3L)]
[11:01:22.421]             }
[11:01:22.421]             function(cond) {
[11:01:22.421]                 is_error <- inherits(cond, "error")
[11:01:22.421]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:22.421]                   NULL)
[11:01:22.421]                 if (is_error) {
[11:01:22.421]                   sessionInformation <- function() {
[11:01:22.421]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:22.421]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:22.421]                       search = base::search(), system = base::Sys.info())
[11:01:22.421]                   }
[11:01:22.421]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.421]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:22.421]                     cond$call), session = sessionInformation(), 
[11:01:22.421]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:22.421]                   signalCondition(cond)
[11:01:22.421]                 }
[11:01:22.421]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:22.421]                 "immediateCondition"))) {
[11:01:22.421]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:22.421]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.421]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:22.421]                   if (TRUE && !signal) {
[11:01:22.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.421]                     {
[11:01:22.421]                       inherits <- base::inherits
[11:01:22.421]                       invokeRestart <- base::invokeRestart
[11:01:22.421]                       is.null <- base::is.null
[11:01:22.421]                       muffled <- FALSE
[11:01:22.421]                       if (inherits(cond, "message")) {
[11:01:22.421]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.421]                         if (muffled) 
[11:01:22.421]                           invokeRestart("muffleMessage")
[11:01:22.421]                       }
[11:01:22.421]                       else if (inherits(cond, "warning")) {
[11:01:22.421]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.421]                         if (muffled) 
[11:01:22.421]                           invokeRestart("muffleWarning")
[11:01:22.421]                       }
[11:01:22.421]                       else if (inherits(cond, "condition")) {
[11:01:22.421]                         if (!is.null(pattern)) {
[11:01:22.421]                           computeRestarts <- base::computeRestarts
[11:01:22.421]                           grepl <- base::grepl
[11:01:22.421]                           restarts <- computeRestarts(cond)
[11:01:22.421]                           for (restart in restarts) {
[11:01:22.421]                             name <- restart$name
[11:01:22.421]                             if (is.null(name)) 
[11:01:22.421]                               next
[11:01:22.421]                             if (!grepl(pattern, name)) 
[11:01:22.421]                               next
[11:01:22.421]                             invokeRestart(restart)
[11:01:22.421]                             muffled <- TRUE
[11:01:22.421]                             break
[11:01:22.421]                           }
[11:01:22.421]                         }
[11:01:22.421]                       }
[11:01:22.421]                       invisible(muffled)
[11:01:22.421]                     }
[11:01:22.421]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.421]                   }
[11:01:22.421]                 }
[11:01:22.421]                 else {
[11:01:22.421]                   if (TRUE) {
[11:01:22.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.421]                     {
[11:01:22.421]                       inherits <- base::inherits
[11:01:22.421]                       invokeRestart <- base::invokeRestart
[11:01:22.421]                       is.null <- base::is.null
[11:01:22.421]                       muffled <- FALSE
[11:01:22.421]                       if (inherits(cond, "message")) {
[11:01:22.421]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.421]                         if (muffled) 
[11:01:22.421]                           invokeRestart("muffleMessage")
[11:01:22.421]                       }
[11:01:22.421]                       else if (inherits(cond, "warning")) {
[11:01:22.421]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.421]                         if (muffled) 
[11:01:22.421]                           invokeRestart("muffleWarning")
[11:01:22.421]                       }
[11:01:22.421]                       else if (inherits(cond, "condition")) {
[11:01:22.421]                         if (!is.null(pattern)) {
[11:01:22.421]                           computeRestarts <- base::computeRestarts
[11:01:22.421]                           grepl <- base::grepl
[11:01:22.421]                           restarts <- computeRestarts(cond)
[11:01:22.421]                           for (restart in restarts) {
[11:01:22.421]                             name <- restart$name
[11:01:22.421]                             if (is.null(name)) 
[11:01:22.421]                               next
[11:01:22.421]                             if (!grepl(pattern, name)) 
[11:01:22.421]                               next
[11:01:22.421]                             invokeRestart(restart)
[11:01:22.421]                             muffled <- TRUE
[11:01:22.421]                             break
[11:01:22.421]                           }
[11:01:22.421]                         }
[11:01:22.421]                       }
[11:01:22.421]                       invisible(muffled)
[11:01:22.421]                     }
[11:01:22.421]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.421]                   }
[11:01:22.421]                 }
[11:01:22.421]             }
[11:01:22.421]         }))
[11:01:22.421]     }, error = function(ex) {
[11:01:22.421]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:22.421]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.421]                 ...future.rng), started = ...future.startTime, 
[11:01:22.421]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:22.421]             version = "1.8"), class = "FutureResult")
[11:01:22.421]     }, finally = {
[11:01:22.421]         if (!identical(...future.workdir, getwd())) 
[11:01:22.421]             setwd(...future.workdir)
[11:01:22.421]         {
[11:01:22.421]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:22.421]                 ...future.oldOptions$nwarnings <- NULL
[11:01:22.421]             }
[11:01:22.421]             base::options(...future.oldOptions)
[11:01:22.421]             if (.Platform$OS.type == "windows") {
[11:01:22.421]                 old_names <- names(...future.oldEnvVars)
[11:01:22.421]                 envs <- base::Sys.getenv()
[11:01:22.421]                 names <- names(envs)
[11:01:22.421]                 common <- intersect(names, old_names)
[11:01:22.421]                 added <- setdiff(names, old_names)
[11:01:22.421]                 removed <- setdiff(old_names, names)
[11:01:22.421]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:22.421]                   envs[common]]
[11:01:22.421]                 NAMES <- toupper(changed)
[11:01:22.421]                 args <- list()
[11:01:22.421]                 for (kk in seq_along(NAMES)) {
[11:01:22.421]                   name <- changed[[kk]]
[11:01:22.421]                   NAME <- NAMES[[kk]]
[11:01:22.421]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.421]                     next
[11:01:22.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.421]                 }
[11:01:22.421]                 NAMES <- toupper(added)
[11:01:22.421]                 for (kk in seq_along(NAMES)) {
[11:01:22.421]                   name <- added[[kk]]
[11:01:22.421]                   NAME <- NAMES[[kk]]
[11:01:22.421]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.421]                     next
[11:01:22.421]                   args[[name]] <- ""
[11:01:22.421]                 }
[11:01:22.421]                 NAMES <- toupper(removed)
[11:01:22.421]                 for (kk in seq_along(NAMES)) {
[11:01:22.421]                   name <- removed[[kk]]
[11:01:22.421]                   NAME <- NAMES[[kk]]
[11:01:22.421]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.421]                     next
[11:01:22.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.421]                 }
[11:01:22.421]                 if (length(args) > 0) 
[11:01:22.421]                   base::do.call(base::Sys.setenv, args = args)
[11:01:22.421]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:22.421]             }
[11:01:22.421]             else {
[11:01:22.421]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:22.421]             }
[11:01:22.421]             {
[11:01:22.421]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:22.421]                   0L) {
[11:01:22.421]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:22.421]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:22.421]                   base::options(opts)
[11:01:22.421]                 }
[11:01:22.421]                 {
[11:01:22.421]                   {
[11:01:22.421]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:22.421]                     NULL
[11:01:22.421]                   }
[11:01:22.421]                   options(future.plan = NULL)
[11:01:22.421]                   if (is.na(NA_character_)) 
[11:01:22.421]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.421]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:22.421]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:22.421]                     .init = FALSE)
[11:01:22.421]                 }
[11:01:22.421]             }
[11:01:22.421]         }
[11:01:22.421]     })
[11:01:22.421]     if (TRUE) {
[11:01:22.421]         base::sink(type = "output", split = FALSE)
[11:01:22.421]         if (TRUE) {
[11:01:22.421]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:22.421]         }
[11:01:22.421]         else {
[11:01:22.421]             ...future.result["stdout"] <- base::list(NULL)
[11:01:22.421]         }
[11:01:22.421]         base::close(...future.stdout)
[11:01:22.421]         ...future.stdout <- NULL
[11:01:22.421]     }
[11:01:22.421]     ...future.result$conditions <- ...future.conditions
[11:01:22.421]     ...future.result$finished <- base::Sys.time()
[11:01:22.421]     ...future.result
[11:01:22.421] }
[11:01:22.424] assign_globals() ...
[11:01:22.424] List of 1
[11:01:22.424]  $ a: num 1
[11:01:22.424]  - attr(*, "where")=List of 1
[11:01:22.424]   ..$ a:<environment: R_EmptyEnv> 
[11:01:22.424]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:22.424]  - attr(*, "resolved")= logi FALSE
[11:01:22.424]  - attr(*, "total_size")= num 39
[11:01:22.424]  - attr(*, "already-done")= logi TRUE
[11:01:22.427] - copied ‘a’ to environment
[11:01:22.427] assign_globals() ... done
[11:01:22.427] requestCore(): workers = 2
[11:01:22.429] MulticoreFuture started
[11:01:22.429] - Launch lazy future ... done
[11:01:22.430] plan(): Setting new future strategy stack:
[11:01:22.430] run() for ‘MulticoreFuture’ ... done
[11:01:22.430] result() for MulticoreFuture ...
[11:01:22.430] List of future strategies:
[11:01:22.430] 1. sequential:
[11:01:22.430]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.430]    - tweaked: FALSE
[11:01:22.430]    - call: NULL
[11:01:22.431] plan(): nbrOfWorkers() = 1
[11:01:22.433] plan(): Setting new future strategy stack:
[11:01:22.433] List of future strategies:
[11:01:22.433] 1. multicore:
[11:01:22.433]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:22.433]    - tweaked: FALSE
[11:01:22.433]    - call: plan(strategy)
[11:01:22.436] plan(): nbrOfWorkers() = 2
[11:01:22.437] result() for MulticoreFuture ...
[11:01:22.437] result() for MulticoreFuture ... done
[11:01:22.437] result() for MulticoreFuture ... done
[11:01:22.437] result() for MulticoreFuture ...
[11:01:22.437] result() for MulticoreFuture ... done
[11:01:22.438] getGlobalsAndPackages() ...
[11:01:22.438] Searching for globals...
[11:01:22.439] - globals found: [3] ‘{’, ‘*’, ‘a’
[11:01:22.439] Searching for globals ... DONE
[11:01:22.439] Resolving globals: FALSE
[11:01:22.440] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:22.440] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:22.440] - globals: [1] ‘a’
[11:01:22.440] 
[11:01:22.441] getGlobalsAndPackages() ... DONE
[11:01:22.441] run() for ‘Future’ ...
[11:01:22.441] - state: ‘created’
[11:01:22.441] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:22.445] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:22.446] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:22.446]   - Field: ‘label’
[11:01:22.446]   - Field: ‘local’
[11:01:22.446]   - Field: ‘owner’
[11:01:22.446]   - Field: ‘envir’
[11:01:22.446]   - Field: ‘workers’
[11:01:22.446]   - Field: ‘packages’
[11:01:22.446]   - Field: ‘gc’
[11:01:22.447]   - Field: ‘job’
[11:01:22.447]   - Field: ‘conditions’
[11:01:22.447]   - Field: ‘expr’
[11:01:22.447]   - Field: ‘uuid’
[11:01:22.447]   - Field: ‘seed’
[11:01:22.447]   - Field: ‘version’
[11:01:22.447]   - Field: ‘result’
[11:01:22.447]   - Field: ‘asynchronous’
[11:01:22.447]   - Field: ‘calls’
[11:01:22.448]   - Field: ‘globals’
[11:01:22.448]   - Field: ‘stdout’
[11:01:22.448]   - Field: ‘earlySignal’
[11:01:22.448]   - Field: ‘lazy’
[11:01:22.448]   - Field: ‘state’
[11:01:22.448] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:22.448] - Launch lazy future ...
[11:01:22.449] Packages needed by the future expression (n = 0): <none>
[11:01:22.449] Packages needed by future strategies (n = 0): <none>
[11:01:22.449] {
[11:01:22.449]     {
[11:01:22.449]         {
[11:01:22.449]             ...future.startTime <- base::Sys.time()
[11:01:22.449]             {
[11:01:22.449]                 {
[11:01:22.449]                   {
[11:01:22.449]                     {
[11:01:22.449]                       base::local({
[11:01:22.449]                         has_future <- base::requireNamespace("future", 
[11:01:22.449]                           quietly = TRUE)
[11:01:22.449]                         if (has_future) {
[11:01:22.449]                           ns <- base::getNamespace("future")
[11:01:22.449]                           version <- ns[[".package"]][["version"]]
[11:01:22.449]                           if (is.null(version)) 
[11:01:22.449]                             version <- utils::packageVersion("future")
[11:01:22.449]                         }
[11:01:22.449]                         else {
[11:01:22.449]                           version <- NULL
[11:01:22.449]                         }
[11:01:22.449]                         if (!has_future || version < "1.8.0") {
[11:01:22.449]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:22.449]                             "", base::R.version$version.string), 
[11:01:22.449]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:22.449]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:22.449]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:22.449]                               "release", "version")], collapse = " "), 
[11:01:22.449]                             hostname = base::Sys.info()[["nodename"]])
[11:01:22.449]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:22.449]                             info)
[11:01:22.449]                           info <- base::paste(info, collapse = "; ")
[11:01:22.449]                           if (!has_future) {
[11:01:22.449]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:22.449]                               info)
[11:01:22.449]                           }
[11:01:22.449]                           else {
[11:01:22.449]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:22.449]                               info, version)
[11:01:22.449]                           }
[11:01:22.449]                           base::stop(msg)
[11:01:22.449]                         }
[11:01:22.449]                       })
[11:01:22.449]                     }
[11:01:22.449]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:22.449]                     base::options(mc.cores = 1L)
[11:01:22.449]                   }
[11:01:22.449]                   ...future.strategy.old <- future::plan("list")
[11:01:22.449]                   options(future.plan = NULL)
[11:01:22.449]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.449]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:22.449]                 }
[11:01:22.449]                 ...future.workdir <- getwd()
[11:01:22.449]             }
[11:01:22.449]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:22.449]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:22.449]         }
[11:01:22.449]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:22.449]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:22.449]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:22.449]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:22.449]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:22.449]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:22.449]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:22.449]             base::names(...future.oldOptions))
[11:01:22.449]     }
[11:01:22.449]     if (FALSE) {
[11:01:22.449]     }
[11:01:22.449]     else {
[11:01:22.449]         if (TRUE) {
[11:01:22.449]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:22.449]                 open = "w")
[11:01:22.449]         }
[11:01:22.449]         else {
[11:01:22.449]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:22.449]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:22.449]         }
[11:01:22.449]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:22.449]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:22.449]             base::sink(type = "output", split = FALSE)
[11:01:22.449]             base::close(...future.stdout)
[11:01:22.449]         }, add = TRUE)
[11:01:22.449]     }
[11:01:22.449]     ...future.frame <- base::sys.nframe()
[11:01:22.449]     ...future.conditions <- base::list()
[11:01:22.449]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:22.449]     if (FALSE) {
[11:01:22.449]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:22.449]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:22.449]     }
[11:01:22.449]     ...future.result <- base::tryCatch({
[11:01:22.449]         base::withCallingHandlers({
[11:01:22.449]             ...future.value <- base::withVisible(base::local({
[11:01:22.449]                 withCallingHandlers({
[11:01:22.449]                   {
[11:01:22.449]                     2 * a
[11:01:22.449]                   }
[11:01:22.449]                 }, immediateCondition = function(cond) {
[11:01:22.449]                   save_rds <- function (object, pathname, ...) 
[11:01:22.449]                   {
[11:01:22.449]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:22.449]                     if (file_test("-f", pathname_tmp)) {
[11:01:22.449]                       fi_tmp <- file.info(pathname_tmp)
[11:01:22.449]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:22.449]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:22.449]                         fi_tmp[["mtime"]])
[11:01:22.449]                     }
[11:01:22.449]                     tryCatch({
[11:01:22.449]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:22.449]                     }, error = function(ex) {
[11:01:22.449]                       msg <- conditionMessage(ex)
[11:01:22.449]                       fi_tmp <- file.info(pathname_tmp)
[11:01:22.449]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:22.449]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:22.449]                         fi_tmp[["mtime"]], msg)
[11:01:22.449]                       ex$message <- msg
[11:01:22.449]                       stop(ex)
[11:01:22.449]                     })
[11:01:22.449]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:22.449]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:22.449]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:22.449]                       fi_tmp <- file.info(pathname_tmp)
[11:01:22.449]                       fi <- file.info(pathname)
[11:01:22.449]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:22.449]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:22.449]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:22.449]                         fi[["size"]], fi[["mtime"]])
[11:01:22.449]                       stop(msg)
[11:01:22.449]                     }
[11:01:22.449]                     invisible(pathname)
[11:01:22.449]                   }
[11:01:22.449]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:22.449]                     rootPath = tempdir()) 
[11:01:22.449]                   {
[11:01:22.449]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:22.449]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:22.449]                       tmpdir = path, fileext = ".rds")
[11:01:22.449]                     save_rds(obj, file)
[11:01:22.449]                   }
[11:01:22.449]                   saveImmediateCondition(cond, path = "/tmp/RtmpdJVX0r/.future/immediateConditions")
[11:01:22.449]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.449]                   {
[11:01:22.449]                     inherits <- base::inherits
[11:01:22.449]                     invokeRestart <- base::invokeRestart
[11:01:22.449]                     is.null <- base::is.null
[11:01:22.449]                     muffled <- FALSE
[11:01:22.449]                     if (inherits(cond, "message")) {
[11:01:22.449]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:22.449]                       if (muffled) 
[11:01:22.449]                         invokeRestart("muffleMessage")
[11:01:22.449]                     }
[11:01:22.449]                     else if (inherits(cond, "warning")) {
[11:01:22.449]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:22.449]                       if (muffled) 
[11:01:22.449]                         invokeRestart("muffleWarning")
[11:01:22.449]                     }
[11:01:22.449]                     else if (inherits(cond, "condition")) {
[11:01:22.449]                       if (!is.null(pattern)) {
[11:01:22.449]                         computeRestarts <- base::computeRestarts
[11:01:22.449]                         grepl <- base::grepl
[11:01:22.449]                         restarts <- computeRestarts(cond)
[11:01:22.449]                         for (restart in restarts) {
[11:01:22.449]                           name <- restart$name
[11:01:22.449]                           if (is.null(name)) 
[11:01:22.449]                             next
[11:01:22.449]                           if (!grepl(pattern, name)) 
[11:01:22.449]                             next
[11:01:22.449]                           invokeRestart(restart)
[11:01:22.449]                           muffled <- TRUE
[11:01:22.449]                           break
[11:01:22.449]                         }
[11:01:22.449]                       }
[11:01:22.449]                     }
[11:01:22.449]                     invisible(muffled)
[11:01:22.449]                   }
[11:01:22.449]                   muffleCondition(cond)
[11:01:22.449]                 })
[11:01:22.449]             }))
[11:01:22.449]             future::FutureResult(value = ...future.value$value, 
[11:01:22.449]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.449]                   ...future.rng), globalenv = if (FALSE) 
[11:01:22.449]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:22.449]                     ...future.globalenv.names))
[11:01:22.449]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:22.449]         }, condition = base::local({
[11:01:22.449]             c <- base::c
[11:01:22.449]             inherits <- base::inherits
[11:01:22.449]             invokeRestart <- base::invokeRestart
[11:01:22.449]             length <- base::length
[11:01:22.449]             list <- base::list
[11:01:22.449]             seq.int <- base::seq.int
[11:01:22.449]             signalCondition <- base::signalCondition
[11:01:22.449]             sys.calls <- base::sys.calls
[11:01:22.449]             `[[` <- base::`[[`
[11:01:22.449]             `+` <- base::`+`
[11:01:22.449]             `<<-` <- base::`<<-`
[11:01:22.449]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:22.449]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:22.449]                   3L)]
[11:01:22.449]             }
[11:01:22.449]             function(cond) {
[11:01:22.449]                 is_error <- inherits(cond, "error")
[11:01:22.449]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:22.449]                   NULL)
[11:01:22.449]                 if (is_error) {
[11:01:22.449]                   sessionInformation <- function() {
[11:01:22.449]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:22.449]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:22.449]                       search = base::search(), system = base::Sys.info())
[11:01:22.449]                   }
[11:01:22.449]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.449]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:22.449]                     cond$call), session = sessionInformation(), 
[11:01:22.449]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:22.449]                   signalCondition(cond)
[11:01:22.449]                 }
[11:01:22.449]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:22.449]                 "immediateCondition"))) {
[11:01:22.449]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:22.449]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.449]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:22.449]                   if (TRUE && !signal) {
[11:01:22.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.449]                     {
[11:01:22.449]                       inherits <- base::inherits
[11:01:22.449]                       invokeRestart <- base::invokeRestart
[11:01:22.449]                       is.null <- base::is.null
[11:01:22.449]                       muffled <- FALSE
[11:01:22.449]                       if (inherits(cond, "message")) {
[11:01:22.449]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.449]                         if (muffled) 
[11:01:22.449]                           invokeRestart("muffleMessage")
[11:01:22.449]                       }
[11:01:22.449]                       else if (inherits(cond, "warning")) {
[11:01:22.449]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.449]                         if (muffled) 
[11:01:22.449]                           invokeRestart("muffleWarning")
[11:01:22.449]                       }
[11:01:22.449]                       else if (inherits(cond, "condition")) {
[11:01:22.449]                         if (!is.null(pattern)) {
[11:01:22.449]                           computeRestarts <- base::computeRestarts
[11:01:22.449]                           grepl <- base::grepl
[11:01:22.449]                           restarts <- computeRestarts(cond)
[11:01:22.449]                           for (restart in restarts) {
[11:01:22.449]                             name <- restart$name
[11:01:22.449]                             if (is.null(name)) 
[11:01:22.449]                               next
[11:01:22.449]                             if (!grepl(pattern, name)) 
[11:01:22.449]                               next
[11:01:22.449]                             invokeRestart(restart)
[11:01:22.449]                             muffled <- TRUE
[11:01:22.449]                             break
[11:01:22.449]                           }
[11:01:22.449]                         }
[11:01:22.449]                       }
[11:01:22.449]                       invisible(muffled)
[11:01:22.449]                     }
[11:01:22.449]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.449]                   }
[11:01:22.449]                 }
[11:01:22.449]                 else {
[11:01:22.449]                   if (TRUE) {
[11:01:22.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.449]                     {
[11:01:22.449]                       inherits <- base::inherits
[11:01:22.449]                       invokeRestart <- base::invokeRestart
[11:01:22.449]                       is.null <- base::is.null
[11:01:22.449]                       muffled <- FALSE
[11:01:22.449]                       if (inherits(cond, "message")) {
[11:01:22.449]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.449]                         if (muffled) 
[11:01:22.449]                           invokeRestart("muffleMessage")
[11:01:22.449]                       }
[11:01:22.449]                       else if (inherits(cond, "warning")) {
[11:01:22.449]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.449]                         if (muffled) 
[11:01:22.449]                           invokeRestart("muffleWarning")
[11:01:22.449]                       }
[11:01:22.449]                       else if (inherits(cond, "condition")) {
[11:01:22.449]                         if (!is.null(pattern)) {
[11:01:22.449]                           computeRestarts <- base::computeRestarts
[11:01:22.449]                           grepl <- base::grepl
[11:01:22.449]                           restarts <- computeRestarts(cond)
[11:01:22.449]                           for (restart in restarts) {
[11:01:22.449]                             name <- restart$name
[11:01:22.449]                             if (is.null(name)) 
[11:01:22.449]                               next
[11:01:22.449]                             if (!grepl(pattern, name)) 
[11:01:22.449]                               next
[11:01:22.449]                             invokeRestart(restart)
[11:01:22.449]                             muffled <- TRUE
[11:01:22.449]                             break
[11:01:22.449]                           }
[11:01:22.449]                         }
[11:01:22.449]                       }
[11:01:22.449]                       invisible(muffled)
[11:01:22.449]                     }
[11:01:22.449]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.449]                   }
[11:01:22.449]                 }
[11:01:22.449]             }
[11:01:22.449]         }))
[11:01:22.449]     }, error = function(ex) {
[11:01:22.449]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:22.449]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.449]                 ...future.rng), started = ...future.startTime, 
[11:01:22.449]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:22.449]             version = "1.8"), class = "FutureResult")
[11:01:22.449]     }, finally = {
[11:01:22.449]         if (!identical(...future.workdir, getwd())) 
[11:01:22.449]             setwd(...future.workdir)
[11:01:22.449]         {
[11:01:22.449]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:22.449]                 ...future.oldOptions$nwarnings <- NULL
[11:01:22.449]             }
[11:01:22.449]             base::options(...future.oldOptions)
[11:01:22.449]             if (.Platform$OS.type == "windows") {
[11:01:22.449]                 old_names <- names(...future.oldEnvVars)
[11:01:22.449]                 envs <- base::Sys.getenv()
[11:01:22.449]                 names <- names(envs)
[11:01:22.449]                 common <- intersect(names, old_names)
[11:01:22.449]                 added <- setdiff(names, old_names)
[11:01:22.449]                 removed <- setdiff(old_names, names)
[11:01:22.449]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:22.449]                   envs[common]]
[11:01:22.449]                 NAMES <- toupper(changed)
[11:01:22.449]                 args <- list()
[11:01:22.449]                 for (kk in seq_along(NAMES)) {
[11:01:22.449]                   name <- changed[[kk]]
[11:01:22.449]                   NAME <- NAMES[[kk]]
[11:01:22.449]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.449]                     next
[11:01:22.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.449]                 }
[11:01:22.449]                 NAMES <- toupper(added)
[11:01:22.449]                 for (kk in seq_along(NAMES)) {
[11:01:22.449]                   name <- added[[kk]]
[11:01:22.449]                   NAME <- NAMES[[kk]]
[11:01:22.449]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.449]                     next
[11:01:22.449]                   args[[name]] <- ""
[11:01:22.449]                 }
[11:01:22.449]                 NAMES <- toupper(removed)
[11:01:22.449]                 for (kk in seq_along(NAMES)) {
[11:01:22.449]                   name <- removed[[kk]]
[11:01:22.449]                   NAME <- NAMES[[kk]]
[11:01:22.449]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.449]                     next
[11:01:22.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.449]                 }
[11:01:22.449]                 if (length(args) > 0) 
[11:01:22.449]                   base::do.call(base::Sys.setenv, args = args)
[11:01:22.449]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:22.449]             }
[11:01:22.449]             else {
[11:01:22.449]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:22.449]             }
[11:01:22.449]             {
[11:01:22.449]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:22.449]                   0L) {
[11:01:22.449]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:22.449]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:22.449]                   base::options(opts)
[11:01:22.449]                 }
[11:01:22.449]                 {
[11:01:22.449]                   {
[11:01:22.449]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:22.449]                     NULL
[11:01:22.449]                   }
[11:01:22.449]                   options(future.plan = NULL)
[11:01:22.449]                   if (is.na(NA_character_)) 
[11:01:22.449]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.449]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:22.449]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:22.449]                     .init = FALSE)
[11:01:22.449]                 }
[11:01:22.449]             }
[11:01:22.449]         }
[11:01:22.449]     })
[11:01:22.449]     if (TRUE) {
[11:01:22.449]         base::sink(type = "output", split = FALSE)
[11:01:22.449]         if (TRUE) {
[11:01:22.449]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:22.449]         }
[11:01:22.449]         else {
[11:01:22.449]             ...future.result["stdout"] <- base::list(NULL)
[11:01:22.449]         }
[11:01:22.449]         base::close(...future.stdout)
[11:01:22.449]         ...future.stdout <- NULL
[11:01:22.449]     }
[11:01:22.449]     ...future.result$conditions <- ...future.conditions
[11:01:22.449]     ...future.result$finished <- base::Sys.time()
[11:01:22.449]     ...future.result
[11:01:22.449] }
[11:01:22.452] assign_globals() ...
[11:01:22.452] List of 1
[11:01:22.452]  $ a: num 1
[11:01:22.452]  - attr(*, "where")=List of 1
[11:01:22.452]   ..$ a:<environment: R_EmptyEnv> 
[11:01:22.452]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:22.452]  - attr(*, "resolved")= logi FALSE
[11:01:22.452]  - attr(*, "total_size")= num 39
[11:01:22.452]  - attr(*, "already-done")= logi TRUE
[11:01:22.455] - copied ‘a’ to environment
[11:01:22.455] assign_globals() ... done
[11:01:22.455] requestCore(): workers = 2
[11:01:22.457] MulticoreFuture started
[11:01:22.457] - Launch lazy future ... done
[11:01:22.457] run() for ‘MulticoreFuture’ ... done
[11:01:22.457] plan(): Setting new future strategy stack:
[11:01:22.458] result() for MulticoreFuture ...
[11:01:22.458] List of future strategies:
[11:01:22.458] 1. sequential:
[11:01:22.458]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:22.458]    - tweaked: FALSE
[11:01:22.458]    - call: NULL
[11:01:22.459] plan(): nbrOfWorkers() = 1
[11:01:22.460] plan(): Setting new future strategy stack:
[11:01:22.461] List of future strategies:
[11:01:22.461] 1. multicore:
[11:01:22.461]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:22.461]    - tweaked: FALSE
[11:01:22.461]    - call: plan(strategy)
[11:01:22.464] plan(): nbrOfWorkers() = 2
[11:01:22.464] result() for MulticoreFuture ...
[11:01:22.465] result() for MulticoreFuture ... done
[11:01:22.465] result() for MulticoreFuture ... done
[11:01:22.465] result() for MulticoreFuture ...
[11:01:22.465] result() for MulticoreFuture ... done
*** futureAssign() with ‘multicore’ futures ... DONE
*** futureAssign() with ‘multisession’ futures ...
[11:01:22.466] plan(): Setting new future strategy stack:
[11:01:22.466] List of future strategies:
[11:01:22.466] 1. multisession:
[11:01:22.466]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:22.466]    - tweaked: FALSE
[11:01:22.466]    - call: plan(strategy)
[11:01:22.466] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[11:01:22.467] multisession:
[11:01:22.467] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:22.467] - tweaked: FALSE
[11:01:22.467] - call: plan(strategy)
[11:01:22.471] getGlobalsAndPackages() ...
[11:01:22.471] Not searching for globals
[11:01:22.471] - globals: [0] <none>
[11:01:22.472] getGlobalsAndPackages() ... DONE
[11:01:22.945] Packages needed by the future expression (n = 0): <none>
[11:01:22.945] Packages needed by future strategies (n = 0): <none>
[11:01:22.945] {
[11:01:22.945]     {
[11:01:22.945]         {
[11:01:22.945]             ...future.startTime <- base::Sys.time()
[11:01:22.945]             {
[11:01:22.945]                 {
[11:01:22.945]                   {
[11:01:22.945]                     {
[11:01:22.945]                       base::local({
[11:01:22.945]                         has_future <- base::requireNamespace("future", 
[11:01:22.945]                           quietly = TRUE)
[11:01:22.945]                         if (has_future) {
[11:01:22.945]                           ns <- base::getNamespace("future")
[11:01:22.945]                           version <- ns[[".package"]][["version"]]
[11:01:22.945]                           if (is.null(version)) 
[11:01:22.945]                             version <- utils::packageVersion("future")
[11:01:22.945]                         }
[11:01:22.945]                         else {
[11:01:22.945]                           version <- NULL
[11:01:22.945]                         }
[11:01:22.945]                         if (!has_future || version < "1.8.0") {
[11:01:22.945]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:22.945]                             "", base::R.version$version.string), 
[11:01:22.945]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:22.945]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:22.945]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:22.945]                               "release", "version")], collapse = " "), 
[11:01:22.945]                             hostname = base::Sys.info()[["nodename"]])
[11:01:22.945]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:22.945]                             info)
[11:01:22.945]                           info <- base::paste(info, collapse = "; ")
[11:01:22.945]                           if (!has_future) {
[11:01:22.945]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:22.945]                               info)
[11:01:22.945]                           }
[11:01:22.945]                           else {
[11:01:22.945]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:22.945]                               info, version)
[11:01:22.945]                           }
[11:01:22.945]                           base::stop(msg)
[11:01:22.945]                         }
[11:01:22.945]                       })
[11:01:22.945]                     }
[11:01:22.945]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:22.945]                     base::options(mc.cores = 1L)
[11:01:22.945]                   }
[11:01:22.945]                   ...future.strategy.old <- future::plan("list")
[11:01:22.945]                   options(future.plan = NULL)
[11:01:22.945]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.945]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:22.945]                 }
[11:01:22.945]                 ...future.workdir <- getwd()
[11:01:22.945]             }
[11:01:22.945]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:22.945]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:22.945]         }
[11:01:22.945]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:22.945]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:22.945]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:22.945]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:22.945]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:22.945]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:22.945]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:22.945]             base::names(...future.oldOptions))
[11:01:22.945]     }
[11:01:22.945]     if (FALSE) {
[11:01:22.945]     }
[11:01:22.945]     else {
[11:01:22.945]         if (TRUE) {
[11:01:22.945]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:22.945]                 open = "w")
[11:01:22.945]         }
[11:01:22.945]         else {
[11:01:22.945]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:22.945]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:22.945]         }
[11:01:22.945]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:22.945]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:22.945]             base::sink(type = "output", split = FALSE)
[11:01:22.945]             base::close(...future.stdout)
[11:01:22.945]         }, add = TRUE)
[11:01:22.945]     }
[11:01:22.945]     ...future.frame <- base::sys.nframe()
[11:01:22.945]     ...future.conditions <- base::list()
[11:01:22.945]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:22.945]     if (FALSE) {
[11:01:22.945]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:22.945]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:22.945]     }
[11:01:22.945]     ...future.result <- base::tryCatch({
[11:01:22.945]         base::withCallingHandlers({
[11:01:22.945]             ...future.value <- base::withVisible(base::local({
[11:01:22.945]                 ...future.makeSendCondition <- base::local({
[11:01:22.945]                   sendCondition <- NULL
[11:01:22.945]                   function(frame = 1L) {
[11:01:22.945]                     if (is.function(sendCondition)) 
[11:01:22.945]                       return(sendCondition)
[11:01:22.945]                     ns <- getNamespace("parallel")
[11:01:22.945]                     if (exists("sendData", mode = "function", 
[11:01:22.945]                       envir = ns)) {
[11:01:22.945]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:22.945]                         envir = ns)
[11:01:22.945]                       envir <- sys.frame(frame)
[11:01:22.945]                       master <- NULL
[11:01:22.945]                       while (!identical(envir, .GlobalEnv) && 
[11:01:22.945]                         !identical(envir, emptyenv())) {
[11:01:22.945]                         if (exists("master", mode = "list", envir = envir, 
[11:01:22.945]                           inherits = FALSE)) {
[11:01:22.945]                           master <- get("master", mode = "list", 
[11:01:22.945]                             envir = envir, inherits = FALSE)
[11:01:22.945]                           if (inherits(master, c("SOCKnode", 
[11:01:22.945]                             "SOCK0node"))) {
[11:01:22.945]                             sendCondition <<- function(cond) {
[11:01:22.945]                               data <- list(type = "VALUE", value = cond, 
[11:01:22.945]                                 success = TRUE)
[11:01:22.945]                               parallel_sendData(master, data)
[11:01:22.945]                             }
[11:01:22.945]                             return(sendCondition)
[11:01:22.945]                           }
[11:01:22.945]                         }
[11:01:22.945]                         frame <- frame + 1L
[11:01:22.945]                         envir <- sys.frame(frame)
[11:01:22.945]                       }
[11:01:22.945]                     }
[11:01:22.945]                     sendCondition <<- function(cond) NULL
[11:01:22.945]                   }
[11:01:22.945]                 })
[11:01:22.945]                 withCallingHandlers({
[11:01:22.945]                   NA
[11:01:22.945]                 }, immediateCondition = function(cond) {
[11:01:22.945]                   sendCondition <- ...future.makeSendCondition()
[11:01:22.945]                   sendCondition(cond)
[11:01:22.945]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.945]                   {
[11:01:22.945]                     inherits <- base::inherits
[11:01:22.945]                     invokeRestart <- base::invokeRestart
[11:01:22.945]                     is.null <- base::is.null
[11:01:22.945]                     muffled <- FALSE
[11:01:22.945]                     if (inherits(cond, "message")) {
[11:01:22.945]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:22.945]                       if (muffled) 
[11:01:22.945]                         invokeRestart("muffleMessage")
[11:01:22.945]                     }
[11:01:22.945]                     else if (inherits(cond, "warning")) {
[11:01:22.945]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:22.945]                       if (muffled) 
[11:01:22.945]                         invokeRestart("muffleWarning")
[11:01:22.945]                     }
[11:01:22.945]                     else if (inherits(cond, "condition")) {
[11:01:22.945]                       if (!is.null(pattern)) {
[11:01:22.945]                         computeRestarts <- base::computeRestarts
[11:01:22.945]                         grepl <- base::grepl
[11:01:22.945]                         restarts <- computeRestarts(cond)
[11:01:22.945]                         for (restart in restarts) {
[11:01:22.945]                           name <- restart$name
[11:01:22.945]                           if (is.null(name)) 
[11:01:22.945]                             next
[11:01:22.945]                           if (!grepl(pattern, name)) 
[11:01:22.945]                             next
[11:01:22.945]                           invokeRestart(restart)
[11:01:22.945]                           muffled <- TRUE
[11:01:22.945]                           break
[11:01:22.945]                         }
[11:01:22.945]                       }
[11:01:22.945]                     }
[11:01:22.945]                     invisible(muffled)
[11:01:22.945]                   }
[11:01:22.945]                   muffleCondition(cond)
[11:01:22.945]                 })
[11:01:22.945]             }))
[11:01:22.945]             future::FutureResult(value = ...future.value$value, 
[11:01:22.945]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.945]                   ...future.rng), globalenv = if (FALSE) 
[11:01:22.945]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:22.945]                     ...future.globalenv.names))
[11:01:22.945]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:22.945]         }, condition = base::local({
[11:01:22.945]             c <- base::c
[11:01:22.945]             inherits <- base::inherits
[11:01:22.945]             invokeRestart <- base::invokeRestart
[11:01:22.945]             length <- base::length
[11:01:22.945]             list <- base::list
[11:01:22.945]             seq.int <- base::seq.int
[11:01:22.945]             signalCondition <- base::signalCondition
[11:01:22.945]             sys.calls <- base::sys.calls
[11:01:22.945]             `[[` <- base::`[[`
[11:01:22.945]             `+` <- base::`+`
[11:01:22.945]             `<<-` <- base::`<<-`
[11:01:22.945]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:22.945]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:22.945]                   3L)]
[11:01:22.945]             }
[11:01:22.945]             function(cond) {
[11:01:22.945]                 is_error <- inherits(cond, "error")
[11:01:22.945]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:22.945]                   NULL)
[11:01:22.945]                 if (is_error) {
[11:01:22.945]                   sessionInformation <- function() {
[11:01:22.945]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:22.945]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:22.945]                       search = base::search(), system = base::Sys.info())
[11:01:22.945]                   }
[11:01:22.945]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.945]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:22.945]                     cond$call), session = sessionInformation(), 
[11:01:22.945]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:22.945]                   signalCondition(cond)
[11:01:22.945]                 }
[11:01:22.945]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:22.945]                 "immediateCondition"))) {
[11:01:22.945]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:22.945]                   ...future.conditions[[length(...future.conditions) + 
[11:01:22.945]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:22.945]                   if (TRUE && !signal) {
[11:01:22.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.945]                     {
[11:01:22.945]                       inherits <- base::inherits
[11:01:22.945]                       invokeRestart <- base::invokeRestart
[11:01:22.945]                       is.null <- base::is.null
[11:01:22.945]                       muffled <- FALSE
[11:01:22.945]                       if (inherits(cond, "message")) {
[11:01:22.945]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.945]                         if (muffled) 
[11:01:22.945]                           invokeRestart("muffleMessage")
[11:01:22.945]                       }
[11:01:22.945]                       else if (inherits(cond, "warning")) {
[11:01:22.945]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.945]                         if (muffled) 
[11:01:22.945]                           invokeRestart("muffleWarning")
[11:01:22.945]                       }
[11:01:22.945]                       else if (inherits(cond, "condition")) {
[11:01:22.945]                         if (!is.null(pattern)) {
[11:01:22.945]                           computeRestarts <- base::computeRestarts
[11:01:22.945]                           grepl <- base::grepl
[11:01:22.945]                           restarts <- computeRestarts(cond)
[11:01:22.945]                           for (restart in restarts) {
[11:01:22.945]                             name <- restart$name
[11:01:22.945]                             if (is.null(name)) 
[11:01:22.945]                               next
[11:01:22.945]                             if (!grepl(pattern, name)) 
[11:01:22.945]                               next
[11:01:22.945]                             invokeRestart(restart)
[11:01:22.945]                             muffled <- TRUE
[11:01:22.945]                             break
[11:01:22.945]                           }
[11:01:22.945]                         }
[11:01:22.945]                       }
[11:01:22.945]                       invisible(muffled)
[11:01:22.945]                     }
[11:01:22.945]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.945]                   }
[11:01:22.945]                 }
[11:01:22.945]                 else {
[11:01:22.945]                   if (TRUE) {
[11:01:22.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:22.945]                     {
[11:01:22.945]                       inherits <- base::inherits
[11:01:22.945]                       invokeRestart <- base::invokeRestart
[11:01:22.945]                       is.null <- base::is.null
[11:01:22.945]                       muffled <- FALSE
[11:01:22.945]                       if (inherits(cond, "message")) {
[11:01:22.945]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:22.945]                         if (muffled) 
[11:01:22.945]                           invokeRestart("muffleMessage")
[11:01:22.945]                       }
[11:01:22.945]                       else if (inherits(cond, "warning")) {
[11:01:22.945]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:22.945]                         if (muffled) 
[11:01:22.945]                           invokeRestart("muffleWarning")
[11:01:22.945]                       }
[11:01:22.945]                       else if (inherits(cond, "condition")) {
[11:01:22.945]                         if (!is.null(pattern)) {
[11:01:22.945]                           computeRestarts <- base::computeRestarts
[11:01:22.945]                           grepl <- base::grepl
[11:01:22.945]                           restarts <- computeRestarts(cond)
[11:01:22.945]                           for (restart in restarts) {
[11:01:22.945]                             name <- restart$name
[11:01:22.945]                             if (is.null(name)) 
[11:01:22.945]                               next
[11:01:22.945]                             if (!grepl(pattern, name)) 
[11:01:22.945]                               next
[11:01:22.945]                             invokeRestart(restart)
[11:01:22.945]                             muffled <- TRUE
[11:01:22.945]                             break
[11:01:22.945]                           }
[11:01:22.945]                         }
[11:01:22.945]                       }
[11:01:22.945]                       invisible(muffled)
[11:01:22.945]                     }
[11:01:22.945]                     muffleCondition(cond, pattern = "^muffle")
[11:01:22.945]                   }
[11:01:22.945]                 }
[11:01:22.945]             }
[11:01:22.945]         }))
[11:01:22.945]     }, error = function(ex) {
[11:01:22.945]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:22.945]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:22.945]                 ...future.rng), started = ...future.startTime, 
[11:01:22.945]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:22.945]             version = "1.8"), class = "FutureResult")
[11:01:22.945]     }, finally = {
[11:01:22.945]         if (!identical(...future.workdir, getwd())) 
[11:01:22.945]             setwd(...future.workdir)
[11:01:22.945]         {
[11:01:22.945]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:22.945]                 ...future.oldOptions$nwarnings <- NULL
[11:01:22.945]             }
[11:01:22.945]             base::options(...future.oldOptions)
[11:01:22.945]             if (.Platform$OS.type == "windows") {
[11:01:22.945]                 old_names <- names(...future.oldEnvVars)
[11:01:22.945]                 envs <- base::Sys.getenv()
[11:01:22.945]                 names <- names(envs)
[11:01:22.945]                 common <- intersect(names, old_names)
[11:01:22.945]                 added <- setdiff(names, old_names)
[11:01:22.945]                 removed <- setdiff(old_names, names)
[11:01:22.945]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:22.945]                   envs[common]]
[11:01:22.945]                 NAMES <- toupper(changed)
[11:01:22.945]                 args <- list()
[11:01:22.945]                 for (kk in seq_along(NAMES)) {
[11:01:22.945]                   name <- changed[[kk]]
[11:01:22.945]                   NAME <- NAMES[[kk]]
[11:01:22.945]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.945]                     next
[11:01:22.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.945]                 }
[11:01:22.945]                 NAMES <- toupper(added)
[11:01:22.945]                 for (kk in seq_along(NAMES)) {
[11:01:22.945]                   name <- added[[kk]]
[11:01:22.945]                   NAME <- NAMES[[kk]]
[11:01:22.945]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.945]                     next
[11:01:22.945]                   args[[name]] <- ""
[11:01:22.945]                 }
[11:01:22.945]                 NAMES <- toupper(removed)
[11:01:22.945]                 for (kk in seq_along(NAMES)) {
[11:01:22.945]                   name <- removed[[kk]]
[11:01:22.945]                   NAME <- NAMES[[kk]]
[11:01:22.945]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:22.945]                     next
[11:01:22.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:22.945]                 }
[11:01:22.945]                 if (length(args) > 0) 
[11:01:22.945]                   base::do.call(base::Sys.setenv, args = args)
[11:01:22.945]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:22.945]             }
[11:01:22.945]             else {
[11:01:22.945]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:22.945]             }
[11:01:22.945]             {
[11:01:22.945]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:22.945]                   0L) {
[11:01:22.945]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:22.945]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:22.945]                   base::options(opts)
[11:01:22.945]                 }
[11:01:22.945]                 {
[11:01:22.945]                   {
[11:01:22.945]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:22.945]                     NULL
[11:01:22.945]                   }
[11:01:22.945]                   options(future.plan = NULL)
[11:01:22.945]                   if (is.na(NA_character_)) 
[11:01:22.945]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:22.945]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:22.945]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:22.945]                     .init = FALSE)
[11:01:22.945]                 }
[11:01:22.945]             }
[11:01:22.945]         }
[11:01:22.945]     })
[11:01:22.945]     if (TRUE) {
[11:01:22.945]         base::sink(type = "output", split = FALSE)
[11:01:22.945]         if (TRUE) {
[11:01:22.945]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:22.945]         }
[11:01:22.945]         else {
[11:01:22.945]             ...future.result["stdout"] <- base::list(NULL)
[11:01:22.945]         }
[11:01:22.945]         base::close(...future.stdout)
[11:01:22.945]         ...future.stdout <- NULL
[11:01:22.945]     }
[11:01:22.945]     ...future.result$conditions <- ...future.conditions
[11:01:22.945]     ...future.result$finished <- base::Sys.time()
[11:01:22.945]     ...future.result
[11:01:22.945] }
[11:01:22.997] MultisessionFuture started
[11:01:22.997] result() for ClusterFuture ...
[11:01:22.998] receiveMessageFromWorker() for ClusterFuture ...
[11:01:22.998] - Validating connection of MultisessionFuture
[11:01:23.028] - received message: FutureResult
[11:01:23.028] - Received FutureResult
[11:01:23.028] - Erased future from FutureRegistry
[11:01:23.028] result() for ClusterFuture ...
[11:01:23.028] - result already collected: FutureResult
[11:01:23.028] result() for ClusterFuture ... done
[11:01:23.028] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:23.028] result() for ClusterFuture ... done
[11:01:23.028] result() for ClusterFuture ...
[11:01:23.028] - result already collected: FutureResult
[11:01:23.029] result() for ClusterFuture ... done
[11:01:23.029] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[11:01:23.030] plan(): nbrOfWorkers() = 2
[11:01:23.030] getGlobalsAndPackages() ...
[11:01:23.031] Searching for globals...
[11:01:23.031] - globals found: [1] ‘{’
[11:01:23.031] Searching for globals ... DONE
[11:01:23.031] Resolving globals: FALSE
[11:01:23.032] 
[11:01:23.032] 
[11:01:23.032] getGlobalsAndPackages() ... DONE
[11:01:23.032] run() for ‘Future’ ...
[11:01:23.032] - state: ‘created’
[11:01:23.032] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:23.047] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:23.047] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:23.047]   - Field: ‘node’
[11:01:23.047]   - Field: ‘label’
[11:01:23.047]   - Field: ‘local’
[11:01:23.047]   - Field: ‘owner’
[11:01:23.047]   - Field: ‘envir’
[11:01:23.048]   - Field: ‘workers’
[11:01:23.048]   - Field: ‘packages’
[11:01:23.048]   - Field: ‘gc’
[11:01:23.048]   - Field: ‘conditions’
[11:01:23.048]   - Field: ‘persistent’
[11:01:23.048]   - Field: ‘expr’
[11:01:23.048]   - Field: ‘uuid’
[11:01:23.048]   - Field: ‘seed’
[11:01:23.048]   - Field: ‘version’
[11:01:23.048]   - Field: ‘result’
[11:01:23.048]   - Field: ‘asynchronous’
[11:01:23.048]   - Field: ‘calls’
[11:01:23.048]   - Field: ‘globals’
[11:01:23.049]   - Field: ‘stdout’
[11:01:23.049]   - Field: ‘earlySignal’
[11:01:23.049]   - Field: ‘lazy’
[11:01:23.049]   - Field: ‘state’
[11:01:23.049] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:23.049] - Launch lazy future ...
[11:01:23.049] Packages needed by the future expression (n = 0): <none>
[11:01:23.049] Packages needed by future strategies (n = 0): <none>
[11:01:23.050] {
[11:01:23.050]     {
[11:01:23.050]         {
[11:01:23.050]             ...future.startTime <- base::Sys.time()
[11:01:23.050]             {
[11:01:23.050]                 {
[11:01:23.050]                   {
[11:01:23.050]                     {
[11:01:23.050]                       base::local({
[11:01:23.050]                         has_future <- base::requireNamespace("future", 
[11:01:23.050]                           quietly = TRUE)
[11:01:23.050]                         if (has_future) {
[11:01:23.050]                           ns <- base::getNamespace("future")
[11:01:23.050]                           version <- ns[[".package"]][["version"]]
[11:01:23.050]                           if (is.null(version)) 
[11:01:23.050]                             version <- utils::packageVersion("future")
[11:01:23.050]                         }
[11:01:23.050]                         else {
[11:01:23.050]                           version <- NULL
[11:01:23.050]                         }
[11:01:23.050]                         if (!has_future || version < "1.8.0") {
[11:01:23.050]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:23.050]                             "", base::R.version$version.string), 
[11:01:23.050]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:23.050]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:23.050]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:23.050]                               "release", "version")], collapse = " "), 
[11:01:23.050]                             hostname = base::Sys.info()[["nodename"]])
[11:01:23.050]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:23.050]                             info)
[11:01:23.050]                           info <- base::paste(info, collapse = "; ")
[11:01:23.050]                           if (!has_future) {
[11:01:23.050]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:23.050]                               info)
[11:01:23.050]                           }
[11:01:23.050]                           else {
[11:01:23.050]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:23.050]                               info, version)
[11:01:23.050]                           }
[11:01:23.050]                           base::stop(msg)
[11:01:23.050]                         }
[11:01:23.050]                       })
[11:01:23.050]                     }
[11:01:23.050]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:23.050]                     base::options(mc.cores = 1L)
[11:01:23.050]                   }
[11:01:23.050]                   ...future.strategy.old <- future::plan("list")
[11:01:23.050]                   options(future.plan = NULL)
[11:01:23.050]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:23.050]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:23.050]                 }
[11:01:23.050]                 ...future.workdir <- getwd()
[11:01:23.050]             }
[11:01:23.050]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:23.050]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:23.050]         }
[11:01:23.050]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:23.050]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:23.050]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:23.050]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:23.050]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:23.050]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:23.050]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:23.050]             base::names(...future.oldOptions))
[11:01:23.050]     }
[11:01:23.050]     if (FALSE) {
[11:01:23.050]     }
[11:01:23.050]     else {
[11:01:23.050]         if (TRUE) {
[11:01:23.050]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:23.050]                 open = "w")
[11:01:23.050]         }
[11:01:23.050]         else {
[11:01:23.050]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:23.050]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:23.050]         }
[11:01:23.050]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:23.050]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:23.050]             base::sink(type = "output", split = FALSE)
[11:01:23.050]             base::close(...future.stdout)
[11:01:23.050]         }, add = TRUE)
[11:01:23.050]     }
[11:01:23.050]     ...future.frame <- base::sys.nframe()
[11:01:23.050]     ...future.conditions <- base::list()
[11:01:23.050]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:23.050]     if (FALSE) {
[11:01:23.050]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:23.050]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:23.050]     }
[11:01:23.050]     ...future.result <- base::tryCatch({
[11:01:23.050]         base::withCallingHandlers({
[11:01:23.050]             ...future.value <- base::withVisible(base::local({
[11:01:23.050]                 ...future.makeSendCondition <- base::local({
[11:01:23.050]                   sendCondition <- NULL
[11:01:23.050]                   function(frame = 1L) {
[11:01:23.050]                     if (is.function(sendCondition)) 
[11:01:23.050]                       return(sendCondition)
[11:01:23.050]                     ns <- getNamespace("parallel")
[11:01:23.050]                     if (exists("sendData", mode = "function", 
[11:01:23.050]                       envir = ns)) {
[11:01:23.050]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:23.050]                         envir = ns)
[11:01:23.050]                       envir <- sys.frame(frame)
[11:01:23.050]                       master <- NULL
[11:01:23.050]                       while (!identical(envir, .GlobalEnv) && 
[11:01:23.050]                         !identical(envir, emptyenv())) {
[11:01:23.050]                         if (exists("master", mode = "list", envir = envir, 
[11:01:23.050]                           inherits = FALSE)) {
[11:01:23.050]                           master <- get("master", mode = "list", 
[11:01:23.050]                             envir = envir, inherits = FALSE)
[11:01:23.050]                           if (inherits(master, c("SOCKnode", 
[11:01:23.050]                             "SOCK0node"))) {
[11:01:23.050]                             sendCondition <<- function(cond) {
[11:01:23.050]                               data <- list(type = "VALUE", value = cond, 
[11:01:23.050]                                 success = TRUE)
[11:01:23.050]                               parallel_sendData(master, data)
[11:01:23.050]                             }
[11:01:23.050]                             return(sendCondition)
[11:01:23.050]                           }
[11:01:23.050]                         }
[11:01:23.050]                         frame <- frame + 1L
[11:01:23.050]                         envir <- sys.frame(frame)
[11:01:23.050]                       }
[11:01:23.050]                     }
[11:01:23.050]                     sendCondition <<- function(cond) NULL
[11:01:23.050]                   }
[11:01:23.050]                 })
[11:01:23.050]                 withCallingHandlers({
[11:01:23.050]                   {
[11:01:23.050]                     2
[11:01:23.050]                   }
[11:01:23.050]                 }, immediateCondition = function(cond) {
[11:01:23.050]                   sendCondition <- ...future.makeSendCondition()
[11:01:23.050]                   sendCondition(cond)
[11:01:23.050]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:23.050]                   {
[11:01:23.050]                     inherits <- base::inherits
[11:01:23.050]                     invokeRestart <- base::invokeRestart
[11:01:23.050]                     is.null <- base::is.null
[11:01:23.050]                     muffled <- FALSE
[11:01:23.050]                     if (inherits(cond, "message")) {
[11:01:23.050]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:23.050]                       if (muffled) 
[11:01:23.050]                         invokeRestart("muffleMessage")
[11:01:23.050]                     }
[11:01:23.050]                     else if (inherits(cond, "warning")) {
[11:01:23.050]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:23.050]                       if (muffled) 
[11:01:23.050]                         invokeRestart("muffleWarning")
[11:01:23.050]                     }
[11:01:23.050]                     else if (inherits(cond, "condition")) {
[11:01:23.050]                       if (!is.null(pattern)) {
[11:01:23.050]                         computeRestarts <- base::computeRestarts
[11:01:23.050]                         grepl <- base::grepl
[11:01:23.050]                         restarts <- computeRestarts(cond)
[11:01:23.050]                         for (restart in restarts) {
[11:01:23.050]                           name <- restart$name
[11:01:23.050]                           if (is.null(name)) 
[11:01:23.050]                             next
[11:01:23.050]                           if (!grepl(pattern, name)) 
[11:01:23.050]                             next
[11:01:23.050]                           invokeRestart(restart)
[11:01:23.050]                           muffled <- TRUE
[11:01:23.050]                           break
[11:01:23.050]                         }
[11:01:23.050]                       }
[11:01:23.050]                     }
[11:01:23.050]                     invisible(muffled)
[11:01:23.050]                   }
[11:01:23.050]                   muffleCondition(cond)
[11:01:23.050]                 })
[11:01:23.050]             }))
[11:01:23.050]             future::FutureResult(value = ...future.value$value, 
[11:01:23.050]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:23.050]                   ...future.rng), globalenv = if (FALSE) 
[11:01:23.050]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:23.050]                     ...future.globalenv.names))
[11:01:23.050]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:23.050]         }, condition = base::local({
[11:01:23.050]             c <- base::c
[11:01:23.050]             inherits <- base::inherits
[11:01:23.050]             invokeRestart <- base::invokeRestart
[11:01:23.050]             length <- base::length
[11:01:23.050]             list <- base::list
[11:01:23.050]             seq.int <- base::seq.int
[11:01:23.050]             signalCondition <- base::signalCondition
[11:01:23.050]             sys.calls <- base::sys.calls
[11:01:23.050]             `[[` <- base::`[[`
[11:01:23.050]             `+` <- base::`+`
[11:01:23.050]             `<<-` <- base::`<<-`
[11:01:23.050]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:23.050]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:23.050]                   3L)]
[11:01:23.050]             }
[11:01:23.050]             function(cond) {
[11:01:23.050]                 is_error <- inherits(cond, "error")
[11:01:23.050]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:23.050]                   NULL)
[11:01:23.050]                 if (is_error) {
[11:01:23.050]                   sessionInformation <- function() {
[11:01:23.050]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:23.050]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:23.050]                       search = base::search(), system = base::Sys.info())
[11:01:23.050]                   }
[11:01:23.050]                   ...future.conditions[[length(...future.conditions) + 
[11:01:23.050]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:23.050]                     cond$call), session = sessionInformation(), 
[11:01:23.050]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:23.050]                   signalCondition(cond)
[11:01:23.050]                 }
[11:01:23.050]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:23.050]                 "immediateCondition"))) {
[11:01:23.050]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:23.050]                   ...future.conditions[[length(...future.conditions) + 
[11:01:23.050]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:23.050]                   if (TRUE && !signal) {
[11:01:23.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:23.050]                     {
[11:01:23.050]                       inherits <- base::inherits
[11:01:23.050]                       invokeRestart <- base::invokeRestart
[11:01:23.050]                       is.null <- base::is.null
[11:01:23.050]                       muffled <- FALSE
[11:01:23.050]                       if (inherits(cond, "message")) {
[11:01:23.050]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:23.050]                         if (muffled) 
[11:01:23.050]                           invokeRestart("muffleMessage")
[11:01:23.050]                       }
[11:01:23.050]                       else if (inherits(cond, "warning")) {
[11:01:23.050]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:23.050]                         if (muffled) 
[11:01:23.050]                           invokeRestart("muffleWarning")
[11:01:23.050]                       }
[11:01:23.050]                       else if (inherits(cond, "condition")) {
[11:01:23.050]                         if (!is.null(pattern)) {
[11:01:23.050]                           computeRestarts <- base::computeRestarts
[11:01:23.050]                           grepl <- base::grepl
[11:01:23.050]                           restarts <- computeRestarts(cond)
[11:01:23.050]                           for (restart in restarts) {
[11:01:23.050]                             name <- restart$name
[11:01:23.050]                             if (is.null(name)) 
[11:01:23.050]                               next
[11:01:23.050]                             if (!grepl(pattern, name)) 
[11:01:23.050]                               next
[11:01:23.050]                             invokeRestart(restart)
[11:01:23.050]                             muffled <- TRUE
[11:01:23.050]                             break
[11:01:23.050]                           }
[11:01:23.050]                         }
[11:01:23.050]                       }
[11:01:23.050]                       invisible(muffled)
[11:01:23.050]                     }
[11:01:23.050]                     muffleCondition(cond, pattern = "^muffle")
[11:01:23.050]                   }
[11:01:23.050]                 }
[11:01:23.050]                 else {
[11:01:23.050]                   if (TRUE) {
[11:01:23.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:23.050]                     {
[11:01:23.050]                       inherits <- base::inherits
[11:01:23.050]                       invokeRestart <- base::invokeRestart
[11:01:23.050]                       is.null <- base::is.null
[11:01:23.050]                       muffled <- FALSE
[11:01:23.050]                       if (inherits(cond, "message")) {
[11:01:23.050]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:23.050]                         if (muffled) 
[11:01:23.050]                           invokeRestart("muffleMessage")
[11:01:23.050]                       }
[11:01:23.050]                       else if (inherits(cond, "warning")) {
[11:01:23.050]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:23.050]                         if (muffled) 
[11:01:23.050]                           invokeRestart("muffleWarning")
[11:01:23.050]                       }
[11:01:23.050]                       else if (inherits(cond, "condition")) {
[11:01:23.050]                         if (!is.null(pattern)) {
[11:01:23.050]                           computeRestarts <- base::computeRestarts
[11:01:23.050]                           grepl <- base::grepl
[11:01:23.050]                           restarts <- computeRestarts(cond)
[11:01:23.050]                           for (restart in restarts) {
[11:01:23.050]                             name <- restart$name
[11:01:23.050]                             if (is.null(name)) 
[11:01:23.050]                               next
[11:01:23.050]                             if (!grepl(pattern, name)) 
[11:01:23.050]                               next
[11:01:23.050]                             invokeRestart(restart)
[11:01:23.050]                             muffled <- TRUE
[11:01:23.050]                             break
[11:01:23.050]                           }
[11:01:23.050]                         }
[11:01:23.050]                       }
[11:01:23.050]                       invisible(muffled)
[11:01:23.050]                     }
[11:01:23.050]                     muffleCondition(cond, pattern = "^muffle")
[11:01:23.050]                   }
[11:01:23.050]                 }
[11:01:23.050]             }
[11:01:23.050]         }))
[11:01:23.050]     }, error = function(ex) {
[11:01:23.050]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:23.050]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:23.050]                 ...future.rng), started = ...future.startTime, 
[11:01:23.050]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:23.050]             version = "1.8"), class = "FutureResult")
[11:01:23.050]     }, finally = {
[11:01:23.050]         if (!identical(...future.workdir, getwd())) 
[11:01:23.050]             setwd(...future.workdir)
[11:01:23.050]         {
[11:01:23.050]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:23.050]                 ...future.oldOptions$nwarnings <- NULL
[11:01:23.050]             }
[11:01:23.050]             base::options(...future.oldOptions)
[11:01:23.050]             if (.Platform$OS.type == "windows") {
[11:01:23.050]                 old_names <- names(...future.oldEnvVars)
[11:01:23.050]                 envs <- base::Sys.getenv()
[11:01:23.050]                 names <- names(envs)
[11:01:23.050]                 common <- intersect(names, old_names)
[11:01:23.050]                 added <- setdiff(names, old_names)
[11:01:23.050]                 removed <- setdiff(old_names, names)
[11:01:23.050]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:23.050]                   envs[common]]
[11:01:23.050]                 NAMES <- toupper(changed)
[11:01:23.050]                 args <- list()
[11:01:23.050]                 for (kk in seq_along(NAMES)) {
[11:01:23.050]                   name <- changed[[kk]]
[11:01:23.050]                   NAME <- NAMES[[kk]]
[11:01:23.050]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:23.050]                     next
[11:01:23.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:23.050]                 }
[11:01:23.050]                 NAMES <- toupper(added)
[11:01:23.050]                 for (kk in seq_along(NAMES)) {
[11:01:23.050]                   name <- added[[kk]]
[11:01:23.050]                   NAME <- NAMES[[kk]]
[11:01:23.050]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:23.050]                     next
[11:01:23.050]                   args[[name]] <- ""
[11:01:23.050]                 }
[11:01:23.050]                 NAMES <- toupper(removed)
[11:01:23.050]                 for (kk in seq_along(NAMES)) {
[11:01:23.050]                   name <- removed[[kk]]
[11:01:23.050]                   NAME <- NAMES[[kk]]
[11:01:23.050]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:23.050]                     next
[11:01:23.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:23.050]                 }
[11:01:23.050]                 if (length(args) > 0) 
[11:01:23.050]                   base::do.call(base::Sys.setenv, args = args)
[11:01:23.050]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:23.050]             }
[11:01:23.050]             else {
[11:01:23.050]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:23.050]             }
[11:01:23.050]             {
[11:01:23.050]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:23.050]                   0L) {
[11:01:23.050]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:23.050]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:23.050]                   base::options(opts)
[11:01:23.050]                 }
[11:01:23.050]                 {
[11:01:23.050]                   {
[11:01:23.050]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:23.050]                     NULL
[11:01:23.050]                   }
[11:01:23.050]                   options(future.plan = NULL)
[11:01:23.050]                   if (is.na(NA_character_)) 
[11:01:23.050]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:23.050]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:23.050]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:23.050]                     .init = FALSE)
[11:01:23.050]                 }
[11:01:23.050]             }
[11:01:23.050]         }
[11:01:23.050]     })
[11:01:23.050]     if (TRUE) {
[11:01:23.050]         base::sink(type = "output", split = FALSE)
[11:01:23.050]         if (TRUE) {
[11:01:23.050]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:23.050]         }
[11:01:23.050]         else {
[11:01:23.050]             ...future.result["stdout"] <- base::list(NULL)
[11:01:23.050]         }
[11:01:23.050]         base::close(...future.stdout)
[11:01:23.050]         ...future.stdout <- NULL
[11:01:23.050]     }
[11:01:23.050]     ...future.result$conditions <- ...future.conditions
[11:01:23.050]     ...future.result$finished <- base::Sys.time()
[11:01:23.050]     ...future.result
[11:01:23.050] }
[11:01:23.053] MultisessionFuture started
[11:01:23.053] - Launch lazy future ... done
[11:01:23.053] run() for ‘MultisessionFuture’ ... done
[11:01:23.053] getGlobalsAndPackages() ...
[11:01:23.053] Searching for globals...
[11:01:23.054] - globals found: [1] ‘{’
[11:01:23.054] Searching for globals ... DONE
[11:01:23.054] Resolving globals: FALSE
[11:01:23.054] 
[11:01:23.054] 
[11:01:23.054] getGlobalsAndPackages() ... DONE
[11:01:23.055] run() for ‘Future’ ...
[11:01:23.055] - state: ‘created’
[11:01:23.055] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:23.069] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:23.069] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:23.069]   - Field: ‘node’
[11:01:23.069]   - Field: ‘label’
[11:01:23.069]   - Field: ‘local’
[11:01:23.069]   - Field: ‘owner’
[11:01:23.069]   - Field: ‘envir’
[11:01:23.070]   - Field: ‘workers’
[11:01:23.070]   - Field: ‘packages’
[11:01:23.070]   - Field: ‘gc’
[11:01:23.070]   - Field: ‘conditions’
[11:01:23.070]   - Field: ‘persistent’
[11:01:23.070]   - Field: ‘expr’
[11:01:23.070]   - Field: ‘uuid’
[11:01:23.070]   - Field: ‘seed’
[11:01:23.070]   - Field: ‘version’
[11:01:23.070]   - Field: ‘result’
[11:01:23.070]   - Field: ‘asynchronous’
[11:01:23.071]   - Field: ‘calls’
[11:01:23.071]   - Field: ‘globals’
[11:01:23.071]   - Field: ‘stdout’
[11:01:23.071]   - Field: ‘earlySignal’
[11:01:23.071]   - Field: ‘lazy’
[11:01:23.071]   - Field: ‘state’
[11:01:23.071] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:23.071] - Launch lazy future ...
[11:01:23.071] Packages needed by the future expression (n = 0): <none>
[11:01:23.071] Packages needed by future strategies (n = 0): <none>
[11:01:23.072] {
[11:01:23.072]     {
[11:01:23.072]         {
[11:01:23.072]             ...future.startTime <- base::Sys.time()
[11:01:23.072]             {
[11:01:23.072]                 {
[11:01:23.072]                   {
[11:01:23.072]                     {
[11:01:23.072]                       base::local({
[11:01:23.072]                         has_future <- base::requireNamespace("future", 
[11:01:23.072]                           quietly = TRUE)
[11:01:23.072]                         if (has_future) {
[11:01:23.072]                           ns <- base::getNamespace("future")
[11:01:23.072]                           version <- ns[[".package"]][["version"]]
[11:01:23.072]                           if (is.null(version)) 
[11:01:23.072]                             version <- utils::packageVersion("future")
[11:01:23.072]                         }
[11:01:23.072]                         else {
[11:01:23.072]                           version <- NULL
[11:01:23.072]                         }
[11:01:23.072]                         if (!has_future || version < "1.8.0") {
[11:01:23.072]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:23.072]                             "", base::R.version$version.string), 
[11:01:23.072]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:23.072]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:23.072]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:23.072]                               "release", "version")], collapse = " "), 
[11:01:23.072]                             hostname = base::Sys.info()[["nodename"]])
[11:01:23.072]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:23.072]                             info)
[11:01:23.072]                           info <- base::paste(info, collapse = "; ")
[11:01:23.072]                           if (!has_future) {
[11:01:23.072]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:23.072]                               info)
[11:01:23.072]                           }
[11:01:23.072]                           else {
[11:01:23.072]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:23.072]                               info, version)
[11:01:23.072]                           }
[11:01:23.072]                           base::stop(msg)
[11:01:23.072]                         }
[11:01:23.072]                       })
[11:01:23.072]                     }
[11:01:23.072]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:23.072]                     base::options(mc.cores = 1L)
[11:01:23.072]                   }
[11:01:23.072]                   ...future.strategy.old <- future::plan("list")
[11:01:23.072]                   options(future.plan = NULL)
[11:01:23.072]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:23.072]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:23.072]                 }
[11:01:23.072]                 ...future.workdir <- getwd()
[11:01:23.072]             }
[11:01:23.072]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:23.072]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:23.072]         }
[11:01:23.072]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:23.072]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:23.072]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:23.072]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:23.072]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:23.072]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:23.072]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:23.072]             base::names(...future.oldOptions))
[11:01:23.072]     }
[11:01:23.072]     if (FALSE) {
[11:01:23.072]     }
[11:01:23.072]     else {
[11:01:23.072]         if (TRUE) {
[11:01:23.072]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:23.072]                 open = "w")
[11:01:23.072]         }
[11:01:23.072]         else {
[11:01:23.072]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:23.072]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:23.072]         }
[11:01:23.072]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:23.072]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:23.072]             base::sink(type = "output", split = FALSE)
[11:01:23.072]             base::close(...future.stdout)
[11:01:23.072]         }, add = TRUE)
[11:01:23.072]     }
[11:01:23.072]     ...future.frame <- base::sys.nframe()
[11:01:23.072]     ...future.conditions <- base::list()
[11:01:23.072]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:23.072]     if (FALSE) {
[11:01:23.072]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:23.072]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:23.072]     }
[11:01:23.072]     ...future.result <- base::tryCatch({
[11:01:23.072]         base::withCallingHandlers({
[11:01:23.072]             ...future.value <- base::withVisible(base::local({
[11:01:23.072]                 ...future.makeSendCondition <- base::local({
[11:01:23.072]                   sendCondition <- NULL
[11:01:23.072]                   function(frame = 1L) {
[11:01:23.072]                     if (is.function(sendCondition)) 
[11:01:23.072]                       return(sendCondition)
[11:01:23.072]                     ns <- getNamespace("parallel")
[11:01:23.072]                     if (exists("sendData", mode = "function", 
[11:01:23.072]                       envir = ns)) {
[11:01:23.072]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:23.072]                         envir = ns)
[11:01:23.072]                       envir <- sys.frame(frame)
[11:01:23.072]                       master <- NULL
[11:01:23.072]                       while (!identical(envir, .GlobalEnv) && 
[11:01:23.072]                         !identical(envir, emptyenv())) {
[11:01:23.072]                         if (exists("master", mode = "list", envir = envir, 
[11:01:23.072]                           inherits = FALSE)) {
[11:01:23.072]                           master <- get("master", mode = "list", 
[11:01:23.072]                             envir = envir, inherits = FALSE)
[11:01:23.072]                           if (inherits(master, c("SOCKnode", 
[11:01:23.072]                             "SOCK0node"))) {
[11:01:23.072]                             sendCondition <<- function(cond) {
[11:01:23.072]                               data <- list(type = "VALUE", value = cond, 
[11:01:23.072]                                 success = TRUE)
[11:01:23.072]                               parallel_sendData(master, data)
[11:01:23.072]                             }
[11:01:23.072]                             return(sendCondition)
[11:01:23.072]                           }
[11:01:23.072]                         }
[11:01:23.072]                         frame <- frame + 1L
[11:01:23.072]                         envir <- sys.frame(frame)
[11:01:23.072]                       }
[11:01:23.072]                     }
[11:01:23.072]                     sendCondition <<- function(cond) NULL
[11:01:23.072]                   }
[11:01:23.072]                 })
[11:01:23.072]                 withCallingHandlers({
[11:01:23.072]                   {
[11:01:23.072]                     4
[11:01:23.072]                   }
[11:01:23.072]                 }, immediateCondition = function(cond) {
[11:01:23.072]                   sendCondition <- ...future.makeSendCondition()
[11:01:23.072]                   sendCondition(cond)
[11:01:23.072]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:23.072]                   {
[11:01:23.072]                     inherits <- base::inherits
[11:01:23.072]                     invokeRestart <- base::invokeRestart
[11:01:23.072]                     is.null <- base::is.null
[11:01:23.072]                     muffled <- FALSE
[11:01:23.072]                     if (inherits(cond, "message")) {
[11:01:23.072]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:23.072]                       if (muffled) 
[11:01:23.072]                         invokeRestart("muffleMessage")
[11:01:23.072]                     }
[11:01:23.072]                     else if (inherits(cond, "warning")) {
[11:01:23.072]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:23.072]                       if (muffled) 
[11:01:23.072]                         invokeRestart("muffleWarning")
[11:01:23.072]                     }
[11:01:23.072]                     else if (inherits(cond, "condition")) {
[11:01:23.072]                       if (!is.null(pattern)) {
[11:01:23.072]                         computeRestarts <- base::computeRestarts
[11:01:23.072]                         grepl <- base::grepl
[11:01:23.072]                         restarts <- computeRestarts(cond)
[11:01:23.072]                         for (restart in restarts) {
[11:01:23.072]                           name <- restart$name
[11:01:23.072]                           if (is.null(name)) 
[11:01:23.072]                             next
[11:01:23.072]                           if (!grepl(pattern, name)) 
[11:01:23.072]                             next
[11:01:23.072]                           invokeRestart(restart)
[11:01:23.072]                           muffled <- TRUE
[11:01:23.072]                           break
[11:01:23.072]                         }
[11:01:23.072]                       }
[11:01:23.072]                     }
[11:01:23.072]                     invisible(muffled)
[11:01:23.072]                   }
[11:01:23.072]                   muffleCondition(cond)
[11:01:23.072]                 })
[11:01:23.072]             }))
[11:01:23.072]             future::FutureResult(value = ...future.value$value, 
[11:01:23.072]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:23.072]                   ...future.rng), globalenv = if (FALSE) 
[11:01:23.072]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:23.072]                     ...future.globalenv.names))
[11:01:23.072]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:23.072]         }, condition = base::local({
[11:01:23.072]             c <- base::c
[11:01:23.072]             inherits <- base::inherits
[11:01:23.072]             invokeRestart <- base::invokeRestart
[11:01:23.072]             length <- base::length
[11:01:23.072]             list <- base::list
[11:01:23.072]             seq.int <- base::seq.int
[11:01:23.072]             signalCondition <- base::signalCondition
[11:01:23.072]             sys.calls <- base::sys.calls
[11:01:23.072]             `[[` <- base::`[[`
[11:01:23.072]             `+` <- base::`+`
[11:01:23.072]             `<<-` <- base::`<<-`
[11:01:23.072]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:23.072]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:23.072]                   3L)]
[11:01:23.072]             }
[11:01:23.072]             function(cond) {
[11:01:23.072]                 is_error <- inherits(cond, "error")
[11:01:23.072]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:23.072]                   NULL)
[11:01:23.072]                 if (is_error) {
[11:01:23.072]                   sessionInformation <- function() {
[11:01:23.072]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:23.072]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:23.072]                       search = base::search(), system = base::Sys.info())
[11:01:23.072]                   }
[11:01:23.072]                   ...future.conditions[[length(...future.conditions) + 
[11:01:23.072]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:23.072]                     cond$call), session = sessionInformation(), 
[11:01:23.072]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:23.072]                   signalCondition(cond)
[11:01:23.072]                 }
[11:01:23.072]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:23.072]                 "immediateCondition"))) {
[11:01:23.072]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:23.072]                   ...future.conditions[[length(...future.conditions) + 
[11:01:23.072]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:23.072]                   if (TRUE && !signal) {
[11:01:23.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:23.072]                     {
[11:01:23.072]                       inherits <- base::inherits
[11:01:23.072]                       invokeRestart <- base::invokeRestart
[11:01:23.072]                       is.null <- base::is.null
[11:01:23.072]                       muffled <- FALSE
[11:01:23.072]                       if (inherits(cond, "message")) {
[11:01:23.072]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:23.072]                         if (muffled) 
[11:01:23.072]                           invokeRestart("muffleMessage")
[11:01:23.072]                       }
[11:01:23.072]                       else if (inherits(cond, "warning")) {
[11:01:23.072]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:23.072]                         if (muffled) 
[11:01:23.072]                           invokeRestart("muffleWarning")
[11:01:23.072]                       }
[11:01:23.072]                       else if (inherits(cond, "condition")) {
[11:01:23.072]                         if (!is.null(pattern)) {
[11:01:23.072]                           computeRestarts <- base::computeRestarts
[11:01:23.072]                           grepl <- base::grepl
[11:01:23.072]                           restarts <- computeRestarts(cond)
[11:01:23.072]                           for (restart in restarts) {
[11:01:23.072]                             name <- restart$name
[11:01:23.072]                             if (is.null(name)) 
[11:01:23.072]                               next
[11:01:23.072]                             if (!grepl(pattern, name)) 
[11:01:23.072]                               next
[11:01:23.072]                             invokeRestart(restart)
[11:01:23.072]                             muffled <- TRUE
[11:01:23.072]                             break
[11:01:23.072]                           }
[11:01:23.072]                         }
[11:01:23.072]                       }
[11:01:23.072]                       invisible(muffled)
[11:01:23.072]                     }
[11:01:23.072]                     muffleCondition(cond, pattern = "^muffle")
[11:01:23.072]                   }
[11:01:23.072]                 }
[11:01:23.072]                 else {
[11:01:23.072]                   if (TRUE) {
[11:01:23.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:23.072]                     {
[11:01:23.072]                       inherits <- base::inherits
[11:01:23.072]                       invokeRestart <- base::invokeRestart
[11:01:23.072]                       is.null <- base::is.null
[11:01:23.072]                       muffled <- FALSE
[11:01:23.072]                       if (inherits(cond, "message")) {
[11:01:23.072]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:23.072]                         if (muffled) 
[11:01:23.072]                           invokeRestart("muffleMessage")
[11:01:23.072]                       }
[11:01:23.072]                       else if (inherits(cond, "warning")) {
[11:01:23.072]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:23.072]                         if (muffled) 
[11:01:23.072]                           invokeRestart("muffleWarning")
[11:01:23.072]                       }
[11:01:23.072]                       else if (inherits(cond, "condition")) {
[11:01:23.072]                         if (!is.null(pattern)) {
[11:01:23.072]                           computeRestarts <- base::computeRestarts
[11:01:23.072]                           grepl <- base::grepl
[11:01:23.072]                           restarts <- computeRestarts(cond)
[11:01:23.072]                           for (restart in restarts) {
[11:01:23.072]                             name <- restart$name
[11:01:23.072]                             if (is.null(name)) 
[11:01:23.072]                               next
[11:01:23.072]                             if (!grepl(pattern, name)) 
[11:01:23.072]                               next
[11:01:23.072]                             invokeRestart(restart)
[11:01:23.072]                             muffled <- TRUE
[11:01:23.072]                             break
[11:01:23.072]                           }
[11:01:23.072]                         }
[11:01:23.072]                       }
[11:01:23.072]                       invisible(muffled)
[11:01:23.072]                     }
[11:01:23.072]                     muffleCondition(cond, pattern = "^muffle")
[11:01:23.072]                   }
[11:01:23.072]                 }
[11:01:23.072]             }
[11:01:23.072]         }))
[11:01:23.072]     }, error = function(ex) {
[11:01:23.072]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:23.072]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:23.072]                 ...future.rng), started = ...future.startTime, 
[11:01:23.072]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:23.072]             version = "1.8"), class = "FutureResult")
[11:01:23.072]     }, finally = {
[11:01:23.072]         if (!identical(...future.workdir, getwd())) 
[11:01:23.072]             setwd(...future.workdir)
[11:01:23.072]         {
[11:01:23.072]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:23.072]                 ...future.oldOptions$nwarnings <- NULL
[11:01:23.072]             }
[11:01:23.072]             base::options(...future.oldOptions)
[11:01:23.072]             if (.Platform$OS.type == "windows") {
[11:01:23.072]                 old_names <- names(...future.oldEnvVars)
[11:01:23.072]                 envs <- base::Sys.getenv()
[11:01:23.072]                 names <- names(envs)
[11:01:23.072]                 common <- intersect(names, old_names)
[11:01:23.072]                 added <- setdiff(names, old_names)
[11:01:23.072]                 removed <- setdiff(old_names, names)
[11:01:23.072]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:23.072]                   envs[common]]
[11:01:23.072]                 NAMES <- toupper(changed)
[11:01:23.072]                 args <- list()
[11:01:23.072]                 for (kk in seq_along(NAMES)) {
[11:01:23.072]                   name <- changed[[kk]]
[11:01:23.072]                   NAME <- NAMES[[kk]]
[11:01:23.072]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:23.072]                     next
[11:01:23.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:23.072]                 }
[11:01:23.072]                 NAMES <- toupper(added)
[11:01:23.072]                 for (kk in seq_along(NAMES)) {
[11:01:23.072]                   name <- added[[kk]]
[11:01:23.072]                   NAME <- NAMES[[kk]]
[11:01:23.072]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:23.072]                     next
[11:01:23.072]                   args[[name]] <- ""
[11:01:23.072]                 }
[11:01:23.072]                 NAMES <- toupper(removed)
[11:01:23.072]                 for (kk in seq_along(NAMES)) {
[11:01:23.072]                   name <- removed[[kk]]
[11:01:23.072]                   NAME <- NAMES[[kk]]
[11:01:23.072]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:23.072]                     next
[11:01:23.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:23.072]                 }
[11:01:23.072]                 if (length(args) > 0) 
[11:01:23.072]                   base::do.call(base::Sys.setenv, args = args)
[11:01:23.072]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:23.072]             }
[11:01:23.072]             else {
[11:01:23.072]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:23.072]             }
[11:01:23.072]             {
[11:01:23.072]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:23.072]                   0L) {
[11:01:23.072]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:23.072]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:23.072]                   base::options(opts)
[11:01:23.072]                 }
[11:01:23.072]                 {
[11:01:23.072]                   {
[11:01:23.072]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:23.072]                     NULL
[11:01:23.072]                   }
[11:01:23.072]                   options(future.plan = NULL)
[11:01:23.072]                   if (is.na(NA_character_)) 
[11:01:23.072]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:23.072]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:23.072]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:23.072]                     .init = FALSE)
[11:01:23.072]                 }
[11:01:23.072]             }
[11:01:23.072]         }
[11:01:23.072]     })
[11:01:23.072]     if (TRUE) {
[11:01:23.072]         base::sink(type = "output", split = FALSE)
[11:01:23.072]         if (TRUE) {
[11:01:23.072]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:23.072]         }
[11:01:23.072]         else {
[11:01:23.072]             ...future.result["stdout"] <- base::list(NULL)
[11:01:23.072]         }
[11:01:23.072]         base::close(...future.stdout)
[11:01:23.072]         ...future.stdout <- NULL
[11:01:23.072]     }
[11:01:23.072]     ...future.result$conditions <- ...future.conditions
[11:01:23.072]     ...future.result$finished <- base::Sys.time()
[11:01:23.072]     ...future.result
[11:01:23.072] }
[11:01:23.124] MultisessionFuture started
[11:01:23.124] - Launch lazy future ... done
[11:01:23.124] run() for ‘MultisessionFuture’ ... done
[11:01:23.124] result() for ClusterFuture ...
[11:01:23.124] receiveMessageFromWorker() for ClusterFuture ...
[11:01:23.124] - Validating connection of MultisessionFuture
[11:01:23.125] - received message: FutureResult
[11:01:23.125] - Received FutureResult
[11:01:23.125] - Erased future from FutureRegistry
[11:01:23.125] result() for ClusterFuture ...
[11:01:23.125] - result already collected: FutureResult
[11:01:23.125] result() for ClusterFuture ... done
[11:01:23.125] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:23.125] result() for ClusterFuture ... done
[11:01:23.125] result() for ClusterFuture ...
[11:01:23.125] - result already collected: FutureResult
[11:01:23.126] result() for ClusterFuture ... done
u$a = 2
[11:01:23.126] result() for ClusterFuture ...
[11:01:23.126] receiveMessageFromWorker() for ClusterFuture ...
[11:01:23.126] - Validating connection of MultisessionFuture
[11:01:23.154] - received message: FutureResult
[11:01:23.155] - Received FutureResult
[11:01:23.155] - Erased future from FutureRegistry
[11:01:23.155] result() for ClusterFuture ...
[11:01:23.155] - result already collected: FutureResult
[11:01:23.155] result() for ClusterFuture ... done
[11:01:23.155] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:23.155] result() for ClusterFuture ... done
[11:01:23.155] result() for ClusterFuture ...
[11:01:23.156] - result already collected: FutureResult
[11:01:23.156] result() for ClusterFuture ... done
v$a = 4
[11:01:23.156] getGlobalsAndPackages() ...
[11:01:23.156] Searching for globals...
[11:01:23.157] - globals found: [3] ‘{’, ‘*’, ‘a’
[11:01:23.157] Searching for globals ... DONE
[11:01:23.157] Resolving globals: FALSE
[11:01:23.158] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:23.158] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:23.158] - globals: [1] ‘a’
[11:01:23.159] 
[11:01:23.159] getGlobalsAndPackages() ... DONE
[11:01:23.159] run() for ‘Future’ ...
[11:01:23.159] - state: ‘created’
[11:01:23.159] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:23.174] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:23.174] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:23.174]   - Field: ‘node’
[11:01:23.174]   - Field: ‘label’
[11:01:23.174]   - Field: ‘local’
[11:01:23.174]   - Field: ‘owner’
[11:01:23.174]   - Field: ‘envir’
[11:01:23.175]   - Field: ‘workers’
[11:01:23.175]   - Field: ‘packages’
[11:01:23.175]   - Field: ‘gc’
[11:01:23.175]   - Field: ‘conditions’
[11:01:23.175]   - Field: ‘persistent’
[11:01:23.175]   - Field: ‘expr’
[11:01:23.175]   - Field: ‘uuid’
[11:01:23.175]   - Field: ‘seed’
[11:01:23.175]   - Field: ‘version’
[11:01:23.175]   - Field: ‘result’
[11:01:23.176]   - Field: ‘asynchronous’
[11:01:23.176]   - Field: ‘calls’
[11:01:23.176]   - Field: ‘globals’
[11:01:23.176]   - Field: ‘stdout’
[11:01:23.176]   - Field: ‘earlySignal’
[11:01:23.176]   - Field: ‘lazy’
[11:01:23.176]   - Field: ‘state’
[11:01:23.176] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:23.176] - Launch lazy future ...
[11:01:23.177] Packages needed by the future expression (n = 0): <none>
[11:01:23.177] Packages needed by future strategies (n = 0): <none>
[11:01:23.177] {
[11:01:23.177]     {
[11:01:23.177]         {
[11:01:23.177]             ...future.startTime <- base::Sys.time()
[11:01:23.177]             {
[11:01:23.177]                 {
[11:01:23.177]                   {
[11:01:23.177]                     {
[11:01:23.177]                       base::local({
[11:01:23.177]                         has_future <- base::requireNamespace("future", 
[11:01:23.177]                           quietly = TRUE)
[11:01:23.177]                         if (has_future) {
[11:01:23.177]                           ns <- base::getNamespace("future")
[11:01:23.177]                           version <- ns[[".package"]][["version"]]
[11:01:23.177]                           if (is.null(version)) 
[11:01:23.177]                             version <- utils::packageVersion("future")
[11:01:23.177]                         }
[11:01:23.177]                         else {
[11:01:23.177]                           version <- NULL
[11:01:23.177]                         }
[11:01:23.177]                         if (!has_future || version < "1.8.0") {
[11:01:23.177]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:23.177]                             "", base::R.version$version.string), 
[11:01:23.177]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:23.177]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:23.177]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:23.177]                               "release", "version")], collapse = " "), 
[11:01:23.177]                             hostname = base::Sys.info()[["nodename"]])
[11:01:23.177]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:23.177]                             info)
[11:01:23.177]                           info <- base::paste(info, collapse = "; ")
[11:01:23.177]                           if (!has_future) {
[11:01:23.177]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:23.177]                               info)
[11:01:23.177]                           }
[11:01:23.177]                           else {
[11:01:23.177]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:23.177]                               info, version)
[11:01:23.177]                           }
[11:01:23.177]                           base::stop(msg)
[11:01:23.177]                         }
[11:01:23.177]                       })
[11:01:23.177]                     }
[11:01:23.177]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:23.177]                     base::options(mc.cores = 1L)
[11:01:23.177]                   }
[11:01:23.177]                   ...future.strategy.old <- future::plan("list")
[11:01:23.177]                   options(future.plan = NULL)
[11:01:23.177]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:23.177]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:23.177]                 }
[11:01:23.177]                 ...future.workdir <- getwd()
[11:01:23.177]             }
[11:01:23.177]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:23.177]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:23.177]         }
[11:01:23.177]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:23.177]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:23.177]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:23.177]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:23.177]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:23.177]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:23.177]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:23.177]             base::names(...future.oldOptions))
[11:01:23.177]     }
[11:01:23.177]     if (FALSE) {
[11:01:23.177]     }
[11:01:23.177]     else {
[11:01:23.177]         if (TRUE) {
[11:01:23.177]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:23.177]                 open = "w")
[11:01:23.177]         }
[11:01:23.177]         else {
[11:01:23.177]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:23.177]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:23.177]         }
[11:01:23.177]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:23.177]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:23.177]             base::sink(type = "output", split = FALSE)
[11:01:23.177]             base::close(...future.stdout)
[11:01:23.177]         }, add = TRUE)
[11:01:23.177]     }
[11:01:23.177]     ...future.frame <- base::sys.nframe()
[11:01:23.177]     ...future.conditions <- base::list()
[11:01:23.177]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:23.177]     if (FALSE) {
[11:01:23.177]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:23.177]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:23.177]     }
[11:01:23.177]     ...future.result <- base::tryCatch({
[11:01:23.177]         base::withCallingHandlers({
[11:01:23.177]             ...future.value <- base::withVisible(base::local({
[11:01:23.177]                 ...future.makeSendCondition <- base::local({
[11:01:23.177]                   sendCondition <- NULL
[11:01:23.177]                   function(frame = 1L) {
[11:01:23.177]                     if (is.function(sendCondition)) 
[11:01:23.177]                       return(sendCondition)
[11:01:23.177]                     ns <- getNamespace("parallel")
[11:01:23.177]                     if (exists("sendData", mode = "function", 
[11:01:23.177]                       envir = ns)) {
[11:01:23.177]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:23.177]                         envir = ns)
[11:01:23.177]                       envir <- sys.frame(frame)
[11:01:23.177]                       master <- NULL
[11:01:23.177]                       while (!identical(envir, .GlobalEnv) && 
[11:01:23.177]                         !identical(envir, emptyenv())) {
[11:01:23.177]                         if (exists("master", mode = "list", envir = envir, 
[11:01:23.177]                           inherits = FALSE)) {
[11:01:23.177]                           master <- get("master", mode = "list", 
[11:01:23.177]                             envir = envir, inherits = FALSE)
[11:01:23.177]                           if (inherits(master, c("SOCKnode", 
[11:01:23.177]                             "SOCK0node"))) {
[11:01:23.177]                             sendCondition <<- function(cond) {
[11:01:23.177]                               data <- list(type = "VALUE", value = cond, 
[11:01:23.177]                                 success = TRUE)
[11:01:23.177]                               parallel_sendData(master, data)
[11:01:23.177]                             }
[11:01:23.177]                             return(sendCondition)
[11:01:23.177]                           }
[11:01:23.177]                         }
[11:01:23.177]                         frame <- frame + 1L
[11:01:23.177]                         envir <- sys.frame(frame)
[11:01:23.177]                       }
[11:01:23.177]                     }
[11:01:23.177]                     sendCondition <<- function(cond) NULL
[11:01:23.177]                   }
[11:01:23.177]                 })
[11:01:23.177]                 withCallingHandlers({
[11:01:23.177]                   {
[11:01:23.177]                     2 * a
[11:01:23.177]                   }
[11:01:23.177]                 }, immediateCondition = function(cond) {
[11:01:23.177]                   sendCondition <- ...future.makeSendCondition()
[11:01:23.177]                   sendCondition(cond)
[11:01:23.177]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:23.177]                   {
[11:01:23.177]                     inherits <- base::inherits
[11:01:23.177]                     invokeRestart <- base::invokeRestart
[11:01:23.177]                     is.null <- base::is.null
[11:01:23.177]                     muffled <- FALSE
[11:01:23.177]                     if (inherits(cond, "message")) {
[11:01:23.177]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:23.177]                       if (muffled) 
[11:01:23.177]                         invokeRestart("muffleMessage")
[11:01:23.177]                     }
[11:01:23.177]                     else if (inherits(cond, "warning")) {
[11:01:23.177]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:23.177]                       if (muffled) 
[11:01:23.177]                         invokeRestart("muffleWarning")
[11:01:23.177]                     }
[11:01:23.177]                     else if (inherits(cond, "condition")) {
[11:01:23.177]                       if (!is.null(pattern)) {
[11:01:23.177]                         computeRestarts <- base::computeRestarts
[11:01:23.177]                         grepl <- base::grepl
[11:01:23.177]                         restarts <- computeRestarts(cond)
[11:01:23.177]                         for (restart in restarts) {
[11:01:23.177]                           name <- restart$name
[11:01:23.177]                           if (is.null(name)) 
[11:01:23.177]                             next
[11:01:23.177]                           if (!grepl(pattern, name)) 
[11:01:23.177]                             next
[11:01:23.177]                           invokeRestart(restart)
[11:01:23.177]                           muffled <- TRUE
[11:01:23.177]                           break
[11:01:23.177]                         }
[11:01:23.177]                       }
[11:01:23.177]                     }
[11:01:23.177]                     invisible(muffled)
[11:01:23.177]                   }
[11:01:23.177]                   muffleCondition(cond)
[11:01:23.177]                 })
[11:01:23.177]             }))
[11:01:23.177]             future::FutureResult(value = ...future.value$value, 
[11:01:23.177]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:23.177]                   ...future.rng), globalenv = if (FALSE) 
[11:01:23.177]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:23.177]                     ...future.globalenv.names))
[11:01:23.177]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:23.177]         }, condition = base::local({
[11:01:23.177]             c <- base::c
[11:01:23.177]             inherits <- base::inherits
[11:01:23.177]             invokeRestart <- base::invokeRestart
[11:01:23.177]             length <- base::length
[11:01:23.177]             list <- base::list
[11:01:23.177]             seq.int <- base::seq.int
[11:01:23.177]             signalCondition <- base::signalCondition
[11:01:23.177]             sys.calls <- base::sys.calls
[11:01:23.177]             `[[` <- base::`[[`
[11:01:23.177]             `+` <- base::`+`
[11:01:23.177]             `<<-` <- base::`<<-`
[11:01:23.177]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:23.177]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:23.177]                   3L)]
[11:01:23.177]             }
[11:01:23.177]             function(cond) {
[11:01:23.177]                 is_error <- inherits(cond, "error")
[11:01:23.177]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:23.177]                   NULL)
[11:01:23.177]                 if (is_error) {
[11:01:23.177]                   sessionInformation <- function() {
[11:01:23.177]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:23.177]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:23.177]                       search = base::search(), system = base::Sys.info())
[11:01:23.177]                   }
[11:01:23.177]                   ...future.conditions[[length(...future.conditions) + 
[11:01:23.177]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:23.177]                     cond$call), session = sessionInformation(), 
[11:01:23.177]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:23.177]                   signalCondition(cond)
[11:01:23.177]                 }
[11:01:23.177]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:23.177]                 "immediateCondition"))) {
[11:01:23.177]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:23.177]                   ...future.conditions[[length(...future.conditions) + 
[11:01:23.177]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:23.177]                   if (TRUE && !signal) {
[11:01:23.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:23.177]                     {
[11:01:23.177]                       inherits <- base::inherits
[11:01:23.177]                       invokeRestart <- base::invokeRestart
[11:01:23.177]                       is.null <- base::is.null
[11:01:23.177]                       muffled <- FALSE
[11:01:23.177]                       if (inherits(cond, "message")) {
[11:01:23.177]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:23.177]                         if (muffled) 
[11:01:23.177]                           invokeRestart("muffleMessage")
[11:01:23.177]                       }
[11:01:23.177]                       else if (inherits(cond, "warning")) {
[11:01:23.177]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:23.177]                         if (muffled) 
[11:01:23.177]                           invokeRestart("muffleWarning")
[11:01:23.177]                       }
[11:01:23.177]                       else if (inherits(cond, "condition")) {
[11:01:23.177]                         if (!is.null(pattern)) {
[11:01:23.177]                           computeRestarts <- base::computeRestarts
[11:01:23.177]                           grepl <- base::grepl
[11:01:23.177]                           restarts <- computeRestarts(cond)
[11:01:23.177]                           for (restart in restarts) {
[11:01:23.177]                             name <- restart$name
[11:01:23.177]                             if (is.null(name)) 
[11:01:23.177]                               next
[11:01:23.177]                             if (!grepl(pattern, name)) 
[11:01:23.177]                               next
[11:01:23.177]                             invokeRestart(restart)
[11:01:23.177]                             muffled <- TRUE
[11:01:23.177]                             break
[11:01:23.177]                           }
[11:01:23.177]                         }
[11:01:23.177]                       }
[11:01:23.177]                       invisible(muffled)
[11:01:23.177]                     }
[11:01:23.177]                     muffleCondition(cond, pattern = "^muffle")
[11:01:23.177]                   }
[11:01:23.177]                 }
[11:01:23.177]                 else {
[11:01:23.177]                   if (TRUE) {
[11:01:23.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:23.177]                     {
[11:01:23.177]                       inherits <- base::inherits
[11:01:23.177]                       invokeRestart <- base::invokeRestart
[11:01:23.177]                       is.null <- base::is.null
[11:01:23.177]                       muffled <- FALSE
[11:01:23.177]                       if (inherits(cond, "message")) {
[11:01:23.177]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:23.177]                         if (muffled) 
[11:01:23.177]                           invokeRestart("muffleMessage")
[11:01:23.177]                       }
[11:01:23.177]                       else if (inherits(cond, "warning")) {
[11:01:23.177]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:23.177]                         if (muffled) 
[11:01:23.177]                           invokeRestart("muffleWarning")
[11:01:23.177]                       }
[11:01:23.177]                       else if (inherits(cond, "condition")) {
[11:01:23.177]                         if (!is.null(pattern)) {
[11:01:23.177]                           computeRestarts <- base::computeRestarts
[11:01:23.177]                           grepl <- base::grepl
[11:01:23.177]                           restarts <- computeRestarts(cond)
[11:01:23.177]                           for (restart in restarts) {
[11:01:23.177]                             name <- restart$name
[11:01:23.177]                             if (is.null(name)) 
[11:01:23.177]                               next
[11:01:23.177]                             if (!grepl(pattern, name)) 
[11:01:23.177]                               next
[11:01:23.177]                             invokeRestart(restart)
[11:01:23.177]                             muffled <- TRUE
[11:01:23.177]                             break
[11:01:23.177]                           }
[11:01:23.177]                         }
[11:01:23.177]                       }
[11:01:23.177]                       invisible(muffled)
[11:01:23.177]                     }
[11:01:23.177]                     muffleCondition(cond, pattern = "^muffle")
[11:01:23.177]                   }
[11:01:23.177]                 }
[11:01:23.177]             }
[11:01:23.177]         }))
[11:01:23.177]     }, error = function(ex) {
[11:01:23.177]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:23.177]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:23.177]                 ...future.rng), started = ...future.startTime, 
[11:01:23.177]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:23.177]             version = "1.8"), class = "FutureResult")
[11:01:23.177]     }, finally = {
[11:01:23.177]         if (!identical(...future.workdir, getwd())) 
[11:01:23.177]             setwd(...future.workdir)
[11:01:23.177]         {
[11:01:23.177]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:23.177]                 ...future.oldOptions$nwarnings <- NULL
[11:01:23.177]             }
[11:01:23.177]             base::options(...future.oldOptions)
[11:01:23.177]             if (.Platform$OS.type == "windows") {
[11:01:23.177]                 old_names <- names(...future.oldEnvVars)
[11:01:23.177]                 envs <- base::Sys.getenv()
[11:01:23.177]                 names <- names(envs)
[11:01:23.177]                 common <- intersect(names, old_names)
[11:01:23.177]                 added <- setdiff(names, old_names)
[11:01:23.177]                 removed <- setdiff(old_names, names)
[11:01:23.177]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:23.177]                   envs[common]]
[11:01:23.177]                 NAMES <- toupper(changed)
[11:01:23.177]                 args <- list()
[11:01:23.177]                 for (kk in seq_along(NAMES)) {
[11:01:23.177]                   name <- changed[[kk]]
[11:01:23.177]                   NAME <- NAMES[[kk]]
[11:01:23.177]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:23.177]                     next
[11:01:23.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:23.177]                 }
[11:01:23.177]                 NAMES <- toupper(added)
[11:01:23.177]                 for (kk in seq_along(NAMES)) {
[11:01:23.177]                   name <- added[[kk]]
[11:01:23.177]                   NAME <- NAMES[[kk]]
[11:01:23.177]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:23.177]                     next
[11:01:23.177]                   args[[name]] <- ""
[11:01:23.177]                 }
[11:01:23.177]                 NAMES <- toupper(removed)
[11:01:23.177]                 for (kk in seq_along(NAMES)) {
[11:01:23.177]                   name <- removed[[kk]]
[11:01:23.177]                   NAME <- NAMES[[kk]]
[11:01:23.177]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:23.177]                     next
[11:01:23.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:23.177]                 }
[11:01:23.177]                 if (length(args) > 0) 
[11:01:23.177]                   base::do.call(base::Sys.setenv, args = args)
[11:01:23.177]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:23.177]             }
[11:01:23.177]             else {
[11:01:23.177]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:23.177]             }
[11:01:23.177]             {
[11:01:23.177]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:23.177]                   0L) {
[11:01:23.177]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:23.177]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:23.177]                   base::options(opts)
[11:01:23.177]                 }
[11:01:23.177]                 {
[11:01:23.177]                   {
[11:01:23.177]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:23.177]                     NULL
[11:01:23.177]                   }
[11:01:23.177]                   options(future.plan = NULL)
[11:01:23.177]                   if (is.na(NA_character_)) 
[11:01:23.177]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:23.177]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:23.177]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:23.177]                     .init = FALSE)
[11:01:23.177]                 }
[11:01:23.177]             }
[11:01:23.177]         }
[11:01:23.177]     })
[11:01:23.177]     if (TRUE) {
[11:01:23.177]         base::sink(type = "output", split = FALSE)
[11:01:23.177]         if (TRUE) {
[11:01:23.177]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:23.177]         }
[11:01:23.177]         else {
[11:01:23.177]             ...future.result["stdout"] <- base::list(NULL)
[11:01:23.177]         }
[11:01:23.177]         base::close(...future.stdout)
[11:01:23.177]         ...future.stdout <- NULL
[11:01:23.177]     }
[11:01:23.177]     ...future.result$conditions <- ...future.conditions
[11:01:23.177]     ...future.result$finished <- base::Sys.time()
[11:01:23.177]     ...future.result
[11:01:23.177] }
[11:01:23.180] Exporting 1 global objects (346 bytes) to cluster node #1 ...
[11:01:23.181] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[11:01:23.184] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[11:01:23.184] Exporting 1 global objects (346 bytes) to cluster node #1 ... DONE
[11:01:23.185] MultisessionFuture started
[11:01:23.185] - Launch lazy future ... done
[11:01:23.185] run() for ‘MultisessionFuture’ ... done
[11:01:23.186] result() for ClusterFuture ...
[11:01:23.186] receiveMessageFromWorker() for ClusterFuture ...
[11:01:23.186] - Validating connection of MultisessionFuture
[11:01:23.227] - received message: FutureResult
[11:01:23.227] - Received FutureResult
[11:01:23.227] - Erased future from FutureRegistry
[11:01:23.227] result() for ClusterFuture ...
[11:01:23.227] - result already collected: FutureResult
[11:01:23.228] result() for ClusterFuture ... done
[11:01:23.228] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:23.228] result() for ClusterFuture ... done
[11:01:23.228] result() for ClusterFuture ...
[11:01:23.228] - result already collected: FutureResult
[11:01:23.228] result() for ClusterFuture ... done
[11:01:23.228] getGlobalsAndPackages() ...
[11:01:23.228] Searching for globals...
[11:01:23.229] - globals found: [3] ‘{’, ‘*’, ‘a’
[11:01:23.230] Searching for globals ... DONE
[11:01:23.230] Resolving globals: FALSE
[11:01:23.230] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:23.231] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:23.231] - globals: [1] ‘a’
[11:01:23.231] 
[11:01:23.231] getGlobalsAndPackages() ... DONE
[11:01:23.231] run() for ‘Future’ ...
[11:01:23.231] - state: ‘created’
[11:01:23.231] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:23.246] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:23.246] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:23.246]   - Field: ‘node’
[11:01:23.246]   - Field: ‘label’
[11:01:23.246]   - Field: ‘local’
[11:01:23.246]   - Field: ‘owner’
[11:01:23.246]   - Field: ‘envir’
[11:01:23.247]   - Field: ‘workers’
[11:01:23.247]   - Field: ‘packages’
[11:01:23.247]   - Field: ‘gc’
[11:01:23.247]   - Field: ‘conditions’
[11:01:23.247]   - Field: ‘persistent’
[11:01:23.247]   - Field: ‘expr’
[11:01:23.247]   - Field: ‘uuid’
[11:01:23.247]   - Field: ‘seed’
[11:01:23.247]   - Field: ‘version’
[11:01:23.247]   - Field: ‘result’
[11:01:23.248]   - Field: ‘asynchronous’
[11:01:23.248]   - Field: ‘calls’
[11:01:23.248]   - Field: ‘globals’
[11:01:23.248]   - Field: ‘stdout’
[11:01:23.248]   - Field: ‘earlySignal’
[11:01:23.248]   - Field: ‘lazy’
[11:01:23.248]   - Field: ‘state’
[11:01:23.248] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:23.248] - Launch lazy future ...
[11:01:23.249] Packages needed by the future expression (n = 0): <none>
[11:01:23.249] Packages needed by future strategies (n = 0): <none>
[11:01:23.249] {
[11:01:23.249]     {
[11:01:23.249]         {
[11:01:23.249]             ...future.startTime <- base::Sys.time()
[11:01:23.249]             {
[11:01:23.249]                 {
[11:01:23.249]                   {
[11:01:23.249]                     {
[11:01:23.249]                       base::local({
[11:01:23.249]                         has_future <- base::requireNamespace("future", 
[11:01:23.249]                           quietly = TRUE)
[11:01:23.249]                         if (has_future) {
[11:01:23.249]                           ns <- base::getNamespace("future")
[11:01:23.249]                           version <- ns[[".package"]][["version"]]
[11:01:23.249]                           if (is.null(version)) 
[11:01:23.249]                             version <- utils::packageVersion("future")
[11:01:23.249]                         }
[11:01:23.249]                         else {
[11:01:23.249]                           version <- NULL
[11:01:23.249]                         }
[11:01:23.249]                         if (!has_future || version < "1.8.0") {
[11:01:23.249]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:23.249]                             "", base::R.version$version.string), 
[11:01:23.249]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:23.249]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:23.249]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:23.249]                               "release", "version")], collapse = " "), 
[11:01:23.249]                             hostname = base::Sys.info()[["nodename"]])
[11:01:23.249]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:23.249]                             info)
[11:01:23.249]                           info <- base::paste(info, collapse = "; ")
[11:01:23.249]                           if (!has_future) {
[11:01:23.249]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:23.249]                               info)
[11:01:23.249]                           }
[11:01:23.249]                           else {
[11:01:23.249]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:23.249]                               info, version)
[11:01:23.249]                           }
[11:01:23.249]                           base::stop(msg)
[11:01:23.249]                         }
[11:01:23.249]                       })
[11:01:23.249]                     }
[11:01:23.249]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:23.249]                     base::options(mc.cores = 1L)
[11:01:23.249]                   }
[11:01:23.249]                   ...future.strategy.old <- future::plan("list")
[11:01:23.249]                   options(future.plan = NULL)
[11:01:23.249]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:23.249]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:23.249]                 }
[11:01:23.249]                 ...future.workdir <- getwd()
[11:01:23.249]             }
[11:01:23.249]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:23.249]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:23.249]         }
[11:01:23.249]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:23.249]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:23.249]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:23.249]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:23.249]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:23.249]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:23.249]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:23.249]             base::names(...future.oldOptions))
[11:01:23.249]     }
[11:01:23.249]     if (FALSE) {
[11:01:23.249]     }
[11:01:23.249]     else {
[11:01:23.249]         if (TRUE) {
[11:01:23.249]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:23.249]                 open = "w")
[11:01:23.249]         }
[11:01:23.249]         else {
[11:01:23.249]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:23.249]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:23.249]         }
[11:01:23.249]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:23.249]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:23.249]             base::sink(type = "output", split = FALSE)
[11:01:23.249]             base::close(...future.stdout)
[11:01:23.249]         }, add = TRUE)
[11:01:23.249]     }
[11:01:23.249]     ...future.frame <- base::sys.nframe()
[11:01:23.249]     ...future.conditions <- base::list()
[11:01:23.249]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:23.249]     if (FALSE) {
[11:01:23.249]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:23.249]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:23.249]     }
[11:01:23.249]     ...future.result <- base::tryCatch({
[11:01:23.249]         base::withCallingHandlers({
[11:01:23.249]             ...future.value <- base::withVisible(base::local({
[11:01:23.249]                 ...future.makeSendCondition <- base::local({
[11:01:23.249]                   sendCondition <- NULL
[11:01:23.249]                   function(frame = 1L) {
[11:01:23.249]                     if (is.function(sendCondition)) 
[11:01:23.249]                       return(sendCondition)
[11:01:23.249]                     ns <- getNamespace("parallel")
[11:01:23.249]                     if (exists("sendData", mode = "function", 
[11:01:23.249]                       envir = ns)) {
[11:01:23.249]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:23.249]                         envir = ns)
[11:01:23.249]                       envir <- sys.frame(frame)
[11:01:23.249]                       master <- NULL
[11:01:23.249]                       while (!identical(envir, .GlobalEnv) && 
[11:01:23.249]                         !identical(envir, emptyenv())) {
[11:01:23.249]                         if (exists("master", mode = "list", envir = envir, 
[11:01:23.249]                           inherits = FALSE)) {
[11:01:23.249]                           master <- get("master", mode = "list", 
[11:01:23.249]                             envir = envir, inherits = FALSE)
[11:01:23.249]                           if (inherits(master, c("SOCKnode", 
[11:01:23.249]                             "SOCK0node"))) {
[11:01:23.249]                             sendCondition <<- function(cond) {
[11:01:23.249]                               data <- list(type = "VALUE", value = cond, 
[11:01:23.249]                                 success = TRUE)
[11:01:23.249]                               parallel_sendData(master, data)
[11:01:23.249]                             }
[11:01:23.249]                             return(sendCondition)
[11:01:23.249]                           }
[11:01:23.249]                         }
[11:01:23.249]                         frame <- frame + 1L
[11:01:23.249]                         envir <- sys.frame(frame)
[11:01:23.249]                       }
[11:01:23.249]                     }
[11:01:23.249]                     sendCondition <<- function(cond) NULL
[11:01:23.249]                   }
[11:01:23.249]                 })
[11:01:23.249]                 withCallingHandlers({
[11:01:23.249]                   {
[11:01:23.249]                     2 * a
[11:01:23.249]                   }
[11:01:23.249]                 }, immediateCondition = function(cond) {
[11:01:23.249]                   sendCondition <- ...future.makeSendCondition()
[11:01:23.249]                   sendCondition(cond)
[11:01:23.249]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:23.249]                   {
[11:01:23.249]                     inherits <- base::inherits
[11:01:23.249]                     invokeRestart <- base::invokeRestart
[11:01:23.249]                     is.null <- base::is.null
[11:01:23.249]                     muffled <- FALSE
[11:01:23.249]                     if (inherits(cond, "message")) {
[11:01:23.249]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:23.249]                       if (muffled) 
[11:01:23.249]                         invokeRestart("muffleMessage")
[11:01:23.249]                     }
[11:01:23.249]                     else if (inherits(cond, "warning")) {
[11:01:23.249]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:23.249]                       if (muffled) 
[11:01:23.249]                         invokeRestart("muffleWarning")
[11:01:23.249]                     }
[11:01:23.249]                     else if (inherits(cond, "condition")) {
[11:01:23.249]                       if (!is.null(pattern)) {
[11:01:23.249]                         computeRestarts <- base::computeRestarts
[11:01:23.249]                         grepl <- base::grepl
[11:01:23.249]                         restarts <- computeRestarts(cond)
[11:01:23.249]                         for (restart in restarts) {
[11:01:23.249]                           name <- restart$name
[11:01:23.249]                           if (is.null(name)) 
[11:01:23.249]                             next
[11:01:23.249]                           if (!grepl(pattern, name)) 
[11:01:23.249]                             next
[11:01:23.249]                           invokeRestart(restart)
[11:01:23.249]                           muffled <- TRUE
[11:01:23.249]                           break
[11:01:23.249]                         }
[11:01:23.249]                       }
[11:01:23.249]                     }
[11:01:23.249]                     invisible(muffled)
[11:01:23.249]                   }
[11:01:23.249]                   muffleCondition(cond)
[11:01:23.249]                 })
[11:01:23.249]             }))
[11:01:23.249]             future::FutureResult(value = ...future.value$value, 
[11:01:23.249]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:23.249]                   ...future.rng), globalenv = if (FALSE) 
[11:01:23.249]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:23.249]                     ...future.globalenv.names))
[11:01:23.249]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:23.249]         }, condition = base::local({
[11:01:23.249]             c <- base::c
[11:01:23.249]             inherits <- base::inherits
[11:01:23.249]             invokeRestart <- base::invokeRestart
[11:01:23.249]             length <- base::length
[11:01:23.249]             list <- base::list
[11:01:23.249]             seq.int <- base::seq.int
[11:01:23.249]             signalCondition <- base::signalCondition
[11:01:23.249]             sys.calls <- base::sys.calls
[11:01:23.249]             `[[` <- base::`[[`
[11:01:23.249]             `+` <- base::`+`
[11:01:23.249]             `<<-` <- base::`<<-`
[11:01:23.249]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:23.249]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:23.249]                   3L)]
[11:01:23.249]             }
[11:01:23.249]             function(cond) {
[11:01:23.249]                 is_error <- inherits(cond, "error")
[11:01:23.249]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:23.249]                   NULL)
[11:01:23.249]                 if (is_error) {
[11:01:23.249]                   sessionInformation <- function() {
[11:01:23.249]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:23.249]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:23.249]                       search = base::search(), system = base::Sys.info())
[11:01:23.249]                   }
[11:01:23.249]                   ...future.conditions[[length(...future.conditions) + 
[11:01:23.249]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:23.249]                     cond$call), session = sessionInformation(), 
[11:01:23.249]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:23.249]                   signalCondition(cond)
[11:01:23.249]                 }
[11:01:23.249]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:23.249]                 "immediateCondition"))) {
[11:01:23.249]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:23.249]                   ...future.conditions[[length(...future.conditions) + 
[11:01:23.249]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:23.249]                   if (TRUE && !signal) {
[11:01:23.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:23.249]                     {
[11:01:23.249]                       inherits <- base::inherits
[11:01:23.249]                       invokeRestart <- base::invokeRestart
[11:01:23.249]                       is.null <- base::is.null
[11:01:23.249]                       muffled <- FALSE
[11:01:23.249]                       if (inherits(cond, "message")) {
[11:01:23.249]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:23.249]                         if (muffled) 
[11:01:23.249]                           invokeRestart("muffleMessage")
[11:01:23.249]                       }
[11:01:23.249]                       else if (inherits(cond, "warning")) {
[11:01:23.249]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:23.249]                         if (muffled) 
[11:01:23.249]                           invokeRestart("muffleWarning")
[11:01:23.249]                       }
[11:01:23.249]                       else if (inherits(cond, "condition")) {
[11:01:23.249]                         if (!is.null(pattern)) {
[11:01:23.249]                           computeRestarts <- base::computeRestarts
[11:01:23.249]                           grepl <- base::grepl
[11:01:23.249]                           restarts <- computeRestarts(cond)
[11:01:23.249]                           for (restart in restarts) {
[11:01:23.249]                             name <- restart$name
[11:01:23.249]                             if (is.null(name)) 
[11:01:23.249]                               next
[11:01:23.249]                             if (!grepl(pattern, name)) 
[11:01:23.249]                               next
[11:01:23.249]                             invokeRestart(restart)
[11:01:23.249]                             muffled <- TRUE
[11:01:23.249]                             break
[11:01:23.249]                           }
[11:01:23.249]                         }
[11:01:23.249]                       }
[11:01:23.249]                       invisible(muffled)
[11:01:23.249]                     }
[11:01:23.249]                     muffleCondition(cond, pattern = "^muffle")
[11:01:23.249]                   }
[11:01:23.249]                 }
[11:01:23.249]                 else {
[11:01:23.249]                   if (TRUE) {
[11:01:23.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:23.249]                     {
[11:01:23.249]                       inherits <- base::inherits
[11:01:23.249]                       invokeRestart <- base::invokeRestart
[11:01:23.249]                       is.null <- base::is.null
[11:01:23.249]                       muffled <- FALSE
[11:01:23.249]                       if (inherits(cond, "message")) {
[11:01:23.249]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:23.249]                         if (muffled) 
[11:01:23.249]                           invokeRestart("muffleMessage")
[11:01:23.249]                       }
[11:01:23.249]                       else if (inherits(cond, "warning")) {
[11:01:23.249]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:23.249]                         if (muffled) 
[11:01:23.249]                           invokeRestart("muffleWarning")
[11:01:23.249]                       }
[11:01:23.249]                       else if (inherits(cond, "condition")) {
[11:01:23.249]                         if (!is.null(pattern)) {
[11:01:23.249]                           computeRestarts <- base::computeRestarts
[11:01:23.249]                           grepl <- base::grepl
[11:01:23.249]                           restarts <- computeRestarts(cond)
[11:01:23.249]                           for (restart in restarts) {
[11:01:23.249]                             name <- restart$name
[11:01:23.249]                             if (is.null(name)) 
[11:01:23.249]                               next
[11:01:23.249]                             if (!grepl(pattern, name)) 
[11:01:23.249]                               next
[11:01:23.249]                             invokeRestart(restart)
[11:01:23.249]                             muffled <- TRUE
[11:01:23.249]                             break
[11:01:23.249]                           }
[11:01:23.249]                         }
[11:01:23.249]                       }
[11:01:23.249]                       invisible(muffled)
[11:01:23.249]                     }
[11:01:23.249]                     muffleCondition(cond, pattern = "^muffle")
[11:01:23.249]                   }
[11:01:23.249]                 }
[11:01:23.249]             }
[11:01:23.249]         }))
[11:01:23.249]     }, error = function(ex) {
[11:01:23.249]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:23.249]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:23.249]                 ...future.rng), started = ...future.startTime, 
[11:01:23.249]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:23.249]             version = "1.8"), class = "FutureResult")
[11:01:23.249]     }, finally = {
[11:01:23.249]         if (!identical(...future.workdir, getwd())) 
[11:01:23.249]             setwd(...future.workdir)
[11:01:23.249]         {
[11:01:23.249]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:23.249]                 ...future.oldOptions$nwarnings <- NULL
[11:01:23.249]             }
[11:01:23.249]             base::options(...future.oldOptions)
[11:01:23.249]             if (.Platform$OS.type == "windows") {
[11:01:23.249]                 old_names <- names(...future.oldEnvVars)
[11:01:23.249]                 envs <- base::Sys.getenv()
[11:01:23.249]                 names <- names(envs)
[11:01:23.249]                 common <- intersect(names, old_names)
[11:01:23.249]                 added <- setdiff(names, old_names)
[11:01:23.249]                 removed <- setdiff(old_names, names)
[11:01:23.249]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:23.249]                   envs[common]]
[11:01:23.249]                 NAMES <- toupper(changed)
[11:01:23.249]                 args <- list()
[11:01:23.249]                 for (kk in seq_along(NAMES)) {
[11:01:23.249]                   name <- changed[[kk]]
[11:01:23.249]                   NAME <- NAMES[[kk]]
[11:01:23.249]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:23.249]                     next
[11:01:23.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:23.249]                 }
[11:01:23.249]                 NAMES <- toupper(added)
[11:01:23.249]                 for (kk in seq_along(NAMES)) {
[11:01:23.249]                   name <- added[[kk]]
[11:01:23.249]                   NAME <- NAMES[[kk]]
[11:01:23.249]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:23.249]                     next
[11:01:23.249]                   args[[name]] <- ""
[11:01:23.249]                 }
[11:01:23.249]                 NAMES <- toupper(removed)
[11:01:23.249]                 for (kk in seq_along(NAMES)) {
[11:01:23.249]                   name <- removed[[kk]]
[11:01:23.249]                   NAME <- NAMES[[kk]]
[11:01:23.249]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:23.249]                     next
[11:01:23.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:23.249]                 }
[11:01:23.249]                 if (length(args) > 0) 
[11:01:23.249]                   base::do.call(base::Sys.setenv, args = args)
[11:01:23.249]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:23.249]             }
[11:01:23.249]             else {
[11:01:23.249]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:23.249]             }
[11:01:23.249]             {
[11:01:23.249]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:23.249]                   0L) {
[11:01:23.249]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:23.249]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:23.249]                   base::options(opts)
[11:01:23.249]                 }
[11:01:23.249]                 {
[11:01:23.249]                   {
[11:01:23.249]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:23.249]                     NULL
[11:01:23.249]                   }
[11:01:23.249]                   options(future.plan = NULL)
[11:01:23.249]                   if (is.na(NA_character_)) 
[11:01:23.249]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:23.249]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:23.249]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:23.249]                     .init = FALSE)
[11:01:23.249]                 }
[11:01:23.249]             }
[11:01:23.249]         }
[11:01:23.249]     })
[11:01:23.249]     if (TRUE) {
[11:01:23.249]         base::sink(type = "output", split = FALSE)
[11:01:23.249]         if (TRUE) {
[11:01:23.249]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:23.249]         }
[11:01:23.249]         else {
[11:01:23.249]             ...future.result["stdout"] <- base::list(NULL)
[11:01:23.249]         }
[11:01:23.249]         base::close(...future.stdout)
[11:01:23.249]         ...future.stdout <- NULL
[11:01:23.249]     }
[11:01:23.249]     ...future.result$conditions <- ...future.conditions
[11:01:23.249]     ...future.result$finished <- base::Sys.time()
[11:01:23.249]     ...future.result
[11:01:23.249] }
[11:01:23.252] Exporting 1 global objects (346 bytes) to cluster node #1 ...
[11:01:23.252] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[11:01:23.253] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[11:01:23.253] Exporting 1 global objects (346 bytes) to cluster node #1 ... DONE
[11:01:23.254] MultisessionFuture started
[11:01:23.254] - Launch lazy future ... done
[11:01:23.254] run() for ‘MultisessionFuture’ ... done
[11:01:23.254] result() for ClusterFuture ...
[11:01:23.254] receiveMessageFromWorker() for ClusterFuture ...
[11:01:23.254] - Validating connection of MultisessionFuture
[11:01:23.295] - received message: FutureResult
[11:01:23.295] - Received FutureResult
[11:01:23.295] - Erased future from FutureRegistry
[11:01:23.295] result() for ClusterFuture ...
[11:01:23.295] - result already collected: FutureResult
[11:01:23.296] result() for ClusterFuture ... done
[11:01:23.296] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:23.296] result() for ClusterFuture ... done
[11:01:23.296] result() for ClusterFuture ...
[11:01:23.296] - result already collected: FutureResult
[11:01:23.296] result() for ClusterFuture ... done
[11:01:23.296] getGlobalsAndPackages() ...
[11:01:23.296] Searching for globals...
[11:01:23.297] - globals found: [3] ‘{’, ‘*’, ‘a’
[11:01:23.298] Searching for globals ... DONE
[11:01:23.298] Resolving globals: FALSE
[11:01:23.298] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:23.298] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:23.299] - globals: [1] ‘a’
[11:01:23.299] 
[11:01:23.299] getGlobalsAndPackages() ... DONE
[11:01:23.299] run() for ‘Future’ ...
[11:01:23.299] - state: ‘created’
[11:01:23.299] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:23.314] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:23.314] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:23.314]   - Field: ‘node’
[11:01:23.314]   - Field: ‘label’
[11:01:23.314]   - Field: ‘local’
[11:01:23.314]   - Field: ‘owner’
[11:01:23.314]   - Field: ‘envir’
[11:01:23.314]   - Field: ‘workers’
[11:01:23.314]   - Field: ‘packages’
[11:01:23.315]   - Field: ‘gc’
[11:01:23.315]   - Field: ‘conditions’
[11:01:23.315]   - Field: ‘persistent’
[11:01:23.315]   - Field: ‘expr’
[11:01:23.315]   - Field: ‘uuid’
[11:01:23.315]   - Field: ‘seed’
[11:01:23.315]   - Field: ‘version’
[11:01:23.315]   - Field: ‘result’
[11:01:23.315]   - Field: ‘asynchronous’
[11:01:23.316]   - Field: ‘calls’
[11:01:23.316]   - Field: ‘globals’
[11:01:23.316]   - Field: ‘stdout’
[11:01:23.316]   - Field: ‘earlySignal’
[11:01:23.316]   - Field: ‘lazy’
[11:01:23.316]   - Field: ‘state’
[11:01:23.316] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:23.316] - Launch lazy future ...
[11:01:23.317] Packages needed by the future expression (n = 0): <none>
[11:01:23.317] Packages needed by future strategies (n = 0): <none>
[11:01:23.317] {
[11:01:23.317]     {
[11:01:23.317]         {
[11:01:23.317]             ...future.startTime <- base::Sys.time()
[11:01:23.317]             {
[11:01:23.317]                 {
[11:01:23.317]                   {
[11:01:23.317]                     {
[11:01:23.317]                       base::local({
[11:01:23.317]                         has_future <- base::requireNamespace("future", 
[11:01:23.317]                           quietly = TRUE)
[11:01:23.317]                         if (has_future) {
[11:01:23.317]                           ns <- base::getNamespace("future")
[11:01:23.317]                           version <- ns[[".package"]][["version"]]
[11:01:23.317]                           if (is.null(version)) 
[11:01:23.317]                             version <- utils::packageVersion("future")
[11:01:23.317]                         }
[11:01:23.317]                         else {
[11:01:23.317]                           version <- NULL
[11:01:23.317]                         }
[11:01:23.317]                         if (!has_future || version < "1.8.0") {
[11:01:23.317]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:23.317]                             "", base::R.version$version.string), 
[11:01:23.317]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:23.317]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:23.317]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:23.317]                               "release", "version")], collapse = " "), 
[11:01:23.317]                             hostname = base::Sys.info()[["nodename"]])
[11:01:23.317]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:23.317]                             info)
[11:01:23.317]                           info <- base::paste(info, collapse = "; ")
[11:01:23.317]                           if (!has_future) {
[11:01:23.317]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:23.317]                               info)
[11:01:23.317]                           }
[11:01:23.317]                           else {
[11:01:23.317]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:23.317]                               info, version)
[11:01:23.317]                           }
[11:01:23.317]                           base::stop(msg)
[11:01:23.317]                         }
[11:01:23.317]                       })
[11:01:23.317]                     }
[11:01:23.317]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:23.317]                     base::options(mc.cores = 1L)
[11:01:23.317]                   }
[11:01:23.317]                   ...future.strategy.old <- future::plan("list")
[11:01:23.317]                   options(future.plan = NULL)
[11:01:23.317]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:23.317]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:23.317]                 }
[11:01:23.317]                 ...future.workdir <- getwd()
[11:01:23.317]             }
[11:01:23.317]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:23.317]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:23.317]         }
[11:01:23.317]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:23.317]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:23.317]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:23.317]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:23.317]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:23.317]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:23.317]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:23.317]             base::names(...future.oldOptions))
[11:01:23.317]     }
[11:01:23.317]     if (FALSE) {
[11:01:23.317]     }
[11:01:23.317]     else {
[11:01:23.317]         if (TRUE) {
[11:01:23.317]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:23.317]                 open = "w")
[11:01:23.317]         }
[11:01:23.317]         else {
[11:01:23.317]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:23.317]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:23.317]         }
[11:01:23.317]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:23.317]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:23.317]             base::sink(type = "output", split = FALSE)
[11:01:23.317]             base::close(...future.stdout)
[11:01:23.317]         }, add = TRUE)
[11:01:23.317]     }
[11:01:23.317]     ...future.frame <- base::sys.nframe()
[11:01:23.317]     ...future.conditions <- base::list()
[11:01:23.317]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:23.317]     if (FALSE) {
[11:01:23.317]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:23.317]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:23.317]     }
[11:01:23.317]     ...future.result <- base::tryCatch({
[11:01:23.317]         base::withCallingHandlers({
[11:01:23.317]             ...future.value <- base::withVisible(base::local({
[11:01:23.317]                 ...future.makeSendCondition <- base::local({
[11:01:23.317]                   sendCondition <- NULL
[11:01:23.317]                   function(frame = 1L) {
[11:01:23.317]                     if (is.function(sendCondition)) 
[11:01:23.317]                       return(sendCondition)
[11:01:23.317]                     ns <- getNamespace("parallel")
[11:01:23.317]                     if (exists("sendData", mode = "function", 
[11:01:23.317]                       envir = ns)) {
[11:01:23.317]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:23.317]                         envir = ns)
[11:01:23.317]                       envir <- sys.frame(frame)
[11:01:23.317]                       master <- NULL
[11:01:23.317]                       while (!identical(envir, .GlobalEnv) && 
[11:01:23.317]                         !identical(envir, emptyenv())) {
[11:01:23.317]                         if (exists("master", mode = "list", envir = envir, 
[11:01:23.317]                           inherits = FALSE)) {
[11:01:23.317]                           master <- get("master", mode = "list", 
[11:01:23.317]                             envir = envir, inherits = FALSE)
[11:01:23.317]                           if (inherits(master, c("SOCKnode", 
[11:01:23.317]                             "SOCK0node"))) {
[11:01:23.317]                             sendCondition <<- function(cond) {
[11:01:23.317]                               data <- list(type = "VALUE", value = cond, 
[11:01:23.317]                                 success = TRUE)
[11:01:23.317]                               parallel_sendData(master, data)
[11:01:23.317]                             }
[11:01:23.317]                             return(sendCondition)
[11:01:23.317]                           }
[11:01:23.317]                         }
[11:01:23.317]                         frame <- frame + 1L
[11:01:23.317]                         envir <- sys.frame(frame)
[11:01:23.317]                       }
[11:01:23.317]                     }
[11:01:23.317]                     sendCondition <<- function(cond) NULL
[11:01:23.317]                   }
[11:01:23.317]                 })
[11:01:23.317]                 withCallingHandlers({
[11:01:23.317]                   {
[11:01:23.317]                     2 * a
[11:01:23.317]                   }
[11:01:23.317]                 }, immediateCondition = function(cond) {
[11:01:23.317]                   sendCondition <- ...future.makeSendCondition()
[11:01:23.317]                   sendCondition(cond)
[11:01:23.317]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:23.317]                   {
[11:01:23.317]                     inherits <- base::inherits
[11:01:23.317]                     invokeRestart <- base::invokeRestart
[11:01:23.317]                     is.null <- base::is.null
[11:01:23.317]                     muffled <- FALSE
[11:01:23.317]                     if (inherits(cond, "message")) {
[11:01:23.317]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:23.317]                       if (muffled) 
[11:01:23.317]                         invokeRestart("muffleMessage")
[11:01:23.317]                     }
[11:01:23.317]                     else if (inherits(cond, "warning")) {
[11:01:23.317]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:23.317]                       if (muffled) 
[11:01:23.317]                         invokeRestart("muffleWarning")
[11:01:23.317]                     }
[11:01:23.317]                     else if (inherits(cond, "condition")) {
[11:01:23.317]                       if (!is.null(pattern)) {
[11:01:23.317]                         computeRestarts <- base::computeRestarts
[11:01:23.317]                         grepl <- base::grepl
[11:01:23.317]                         restarts <- computeRestarts(cond)
[11:01:23.317]                         for (restart in restarts) {
[11:01:23.317]                           name <- restart$name
[11:01:23.317]                           if (is.null(name)) 
[11:01:23.317]                             next
[11:01:23.317]                           if (!grepl(pattern, name)) 
[11:01:23.317]                             next
[11:01:23.317]                           invokeRestart(restart)
[11:01:23.317]                           muffled <- TRUE
[11:01:23.317]                           break
[11:01:23.317]                         }
[11:01:23.317]                       }
[11:01:23.317]                     }
[11:01:23.317]                     invisible(muffled)
[11:01:23.317]                   }
[11:01:23.317]                   muffleCondition(cond)
[11:01:23.317]                 })
[11:01:23.317]             }))
[11:01:23.317]             future::FutureResult(value = ...future.value$value, 
[11:01:23.317]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:23.317]                   ...future.rng), globalenv = if (FALSE) 
[11:01:23.317]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:23.317]                     ...future.globalenv.names))
[11:01:23.317]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:23.317]         }, condition = base::local({
[11:01:23.317]             c <- base::c
[11:01:23.317]             inherits <- base::inherits
[11:01:23.317]             invokeRestart <- base::invokeRestart
[11:01:23.317]             length <- base::length
[11:01:23.317]             list <- base::list
[11:01:23.317]             seq.int <- base::seq.int
[11:01:23.317]             signalCondition <- base::signalCondition
[11:01:23.317]             sys.calls <- base::sys.calls
[11:01:23.317]             `[[` <- base::`[[`
[11:01:23.317]             `+` <- base::`+`
[11:01:23.317]             `<<-` <- base::`<<-`
[11:01:23.317]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:23.317]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:23.317]                   3L)]
[11:01:23.317]             }
[11:01:23.317]             function(cond) {
[11:01:23.317]                 is_error <- inherits(cond, "error")
[11:01:23.317]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:23.317]                   NULL)
[11:01:23.317]                 if (is_error) {
[11:01:23.317]                   sessionInformation <- function() {
[11:01:23.317]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:23.317]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:23.317]                       search = base::search(), system = base::Sys.info())
[11:01:23.317]                   }
[11:01:23.317]                   ...future.conditions[[length(...future.conditions) + 
[11:01:23.317]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:23.317]                     cond$call), session = sessionInformation(), 
[11:01:23.317]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:23.317]                   signalCondition(cond)
[11:01:23.317]                 }
[11:01:23.317]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:23.317]                 "immediateCondition"))) {
[11:01:23.317]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:23.317]                   ...future.conditions[[length(...future.conditions) + 
[11:01:23.317]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:23.317]                   if (TRUE && !signal) {
[11:01:23.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:23.317]                     {
[11:01:23.317]                       inherits <- base::inherits
[11:01:23.317]                       invokeRestart <- base::invokeRestart
[11:01:23.317]                       is.null <- base::is.null
[11:01:23.317]                       muffled <- FALSE
[11:01:23.317]                       if (inherits(cond, "message")) {
[11:01:23.317]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:23.317]                         if (muffled) 
[11:01:23.317]                           invokeRestart("muffleMessage")
[11:01:23.317]                       }
[11:01:23.317]                       else if (inherits(cond, "warning")) {
[11:01:23.317]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:23.317]                         if (muffled) 
[11:01:23.317]                           invokeRestart("muffleWarning")
[11:01:23.317]                       }
[11:01:23.317]                       else if (inherits(cond, "condition")) {
[11:01:23.317]                         if (!is.null(pattern)) {
[11:01:23.317]                           computeRestarts <- base::computeRestarts
[11:01:23.317]                           grepl <- base::grepl
[11:01:23.317]                           restarts <- computeRestarts(cond)
[11:01:23.317]                           for (restart in restarts) {
[11:01:23.317]                             name <- restart$name
[11:01:23.317]                             if (is.null(name)) 
[11:01:23.317]                               next
[11:01:23.317]                             if (!grepl(pattern, name)) 
[11:01:23.317]                               next
[11:01:23.317]                             invokeRestart(restart)
[11:01:23.317]                             muffled <- TRUE
[11:01:23.317]                             break
[11:01:23.317]                           }
[11:01:23.317]                         }
[11:01:23.317]                       }
[11:01:23.317]                       invisible(muffled)
[11:01:23.317]                     }
[11:01:23.317]                     muffleCondition(cond, pattern = "^muffle")
[11:01:23.317]                   }
[11:01:23.317]                 }
[11:01:23.317]                 else {
[11:01:23.317]                   if (TRUE) {
[11:01:23.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:23.317]                     {
[11:01:23.317]                       inherits <- base::inherits
[11:01:23.317]                       invokeRestart <- base::invokeRestart
[11:01:23.317]                       is.null <- base::is.null
[11:01:23.317]                       muffled <- FALSE
[11:01:23.317]                       if (inherits(cond, "message")) {
[11:01:23.317]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:23.317]                         if (muffled) 
[11:01:23.317]                           invokeRestart("muffleMessage")
[11:01:23.317]                       }
[11:01:23.317]                       else if (inherits(cond, "warning")) {
[11:01:23.317]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:23.317]                         if (muffled) 
[11:01:23.317]                           invokeRestart("muffleWarning")
[11:01:23.317]                       }
[11:01:23.317]                       else if (inherits(cond, "condition")) {
[11:01:23.317]                         if (!is.null(pattern)) {
[11:01:23.317]                           computeRestarts <- base::computeRestarts
[11:01:23.317]                           grepl <- base::grepl
[11:01:23.317]                           restarts <- computeRestarts(cond)
[11:01:23.317]                           for (restart in restarts) {
[11:01:23.317]                             name <- restart$name
[11:01:23.317]                             if (is.null(name)) 
[11:01:23.317]                               next
[11:01:23.317]                             if (!grepl(pattern, name)) 
[11:01:23.317]                               next
[11:01:23.317]                             invokeRestart(restart)
[11:01:23.317]                             muffled <- TRUE
[11:01:23.317]                             break
[11:01:23.317]                           }
[11:01:23.317]                         }
[11:01:23.317]                       }
[11:01:23.317]                       invisible(muffled)
[11:01:23.317]                     }
[11:01:23.317]                     muffleCondition(cond, pattern = "^muffle")
[11:01:23.317]                   }
[11:01:23.317]                 }
[11:01:23.317]             }
[11:01:23.317]         }))
[11:01:23.317]     }, error = function(ex) {
[11:01:23.317]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:23.317]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:23.317]                 ...future.rng), started = ...future.startTime, 
[11:01:23.317]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:23.317]             version = "1.8"), class = "FutureResult")
[11:01:23.317]     }, finally = {
[11:01:23.317]         if (!identical(...future.workdir, getwd())) 
[11:01:23.317]             setwd(...future.workdir)
[11:01:23.317]         {
[11:01:23.317]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:23.317]                 ...future.oldOptions$nwarnings <- NULL
[11:01:23.317]             }
[11:01:23.317]             base::options(...future.oldOptions)
[11:01:23.317]             if (.Platform$OS.type == "windows") {
[11:01:23.317]                 old_names <- names(...future.oldEnvVars)
[11:01:23.317]                 envs <- base::Sys.getenv()
[11:01:23.317]                 names <- names(envs)
[11:01:23.317]                 common <- intersect(names, old_names)
[11:01:23.317]                 added <- setdiff(names, old_names)
[11:01:23.317]                 removed <- setdiff(old_names, names)
[11:01:23.317]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:23.317]                   envs[common]]
[11:01:23.317]                 NAMES <- toupper(changed)
[11:01:23.317]                 args <- list()
[11:01:23.317]                 for (kk in seq_along(NAMES)) {
[11:01:23.317]                   name <- changed[[kk]]
[11:01:23.317]                   NAME <- NAMES[[kk]]
[11:01:23.317]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:23.317]                     next
[11:01:23.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:23.317]                 }
[11:01:23.317]                 NAMES <- toupper(added)
[11:01:23.317]                 for (kk in seq_along(NAMES)) {
[11:01:23.317]                   name <- added[[kk]]
[11:01:23.317]                   NAME <- NAMES[[kk]]
[11:01:23.317]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:23.317]                     next
[11:01:23.317]                   args[[name]] <- ""
[11:01:23.317]                 }
[11:01:23.317]                 NAMES <- toupper(removed)
[11:01:23.317]                 for (kk in seq_along(NAMES)) {
[11:01:23.317]                   name <- removed[[kk]]
[11:01:23.317]                   NAME <- NAMES[[kk]]
[11:01:23.317]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:23.317]                     next
[11:01:23.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:23.317]                 }
[11:01:23.317]                 if (length(args) > 0) 
[11:01:23.317]                   base::do.call(base::Sys.setenv, args = args)
[11:01:23.317]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:23.317]             }
[11:01:23.317]             else {
[11:01:23.317]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:23.317]             }
[11:01:23.317]             {
[11:01:23.317]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:23.317]                   0L) {
[11:01:23.317]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:23.317]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:23.317]                   base::options(opts)
[11:01:23.317]                 }
[11:01:23.317]                 {
[11:01:23.317]                   {
[11:01:23.317]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:23.317]                     NULL
[11:01:23.317]                   }
[11:01:23.317]                   options(future.plan = NULL)
[11:01:23.317]                   if (is.na(NA_character_)) 
[11:01:23.317]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:23.317]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:23.317]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:23.317]                     .init = FALSE)
[11:01:23.317]                 }
[11:01:23.317]             }
[11:01:23.317]         }
[11:01:23.317]     })
[11:01:23.317]     if (TRUE) {
[11:01:23.317]         base::sink(type = "output", split = FALSE)
[11:01:23.317]         if (TRUE) {
[11:01:23.317]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:23.317]         }
[11:01:23.317]         else {
[11:01:23.317]             ...future.result["stdout"] <- base::list(NULL)
[11:01:23.317]         }
[11:01:23.317]         base::close(...future.stdout)
[11:01:23.317]         ...future.stdout <- NULL
[11:01:23.317]     }
[11:01:23.317]     ...future.result$conditions <- ...future.conditions
[11:01:23.317]     ...future.result$finished <- base::Sys.time()
[11:01:23.317]     ...future.result
[11:01:23.317] }
[11:01:23.320] Exporting 1 global objects (346 bytes) to cluster node #1 ...
[11:01:23.320] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[11:01:23.321] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[11:01:23.321] Exporting 1 global objects (346 bytes) to cluster node #1 ... DONE
[11:01:23.321] MultisessionFuture started
[11:01:23.322] - Launch lazy future ... done
[11:01:23.322] run() for ‘MultisessionFuture’ ... done
[11:01:23.322] result() for ClusterFuture ...
[11:01:23.322] receiveMessageFromWorker() for ClusterFuture ...
[11:01:23.322] - Validating connection of MultisessionFuture
[11:01:23.363] - received message: FutureResult
[11:01:23.363] - Received FutureResult
[11:01:23.363] - Erased future from FutureRegistry
[11:01:23.363] result() for ClusterFuture ...
[11:01:23.364] - result already collected: FutureResult
[11:01:23.364] result() for ClusterFuture ... done
[11:01:23.364] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:23.364] result() for ClusterFuture ... done
[11:01:23.364] result() for ClusterFuture ...
[11:01:23.364] - result already collected: FutureResult
[11:01:23.364] result() for ClusterFuture ... done
[11:01:23.364] getGlobalsAndPackages() ...
[11:01:23.365] Searching for globals...
[11:01:23.366] - globals found: [3] ‘{’, ‘*’, ‘a’
[11:01:23.366] Searching for globals ... DONE
[11:01:23.366] Resolving globals: FALSE
[11:01:23.366] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:23.367] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:23.367] - globals: [1] ‘a’
[11:01:23.367] 
[11:01:23.367] getGlobalsAndPackages() ... DONE
[11:01:23.367] run() for ‘Future’ ...
[11:01:23.367] - state: ‘created’
[11:01:23.368] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:23.384] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:23.384] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:23.384]   - Field: ‘node’
[11:01:23.384]   - Field: ‘label’
[11:01:23.384]   - Field: ‘local’
[11:01:23.384]   - Field: ‘owner’
[11:01:23.384]   - Field: ‘envir’
[11:01:23.385]   - Field: ‘workers’
[11:01:23.385]   - Field: ‘packages’
[11:01:23.385]   - Field: ‘gc’
[11:01:23.385]   - Field: ‘conditions’
[11:01:23.385]   - Field: ‘persistent’
[11:01:23.385]   - Field: ‘expr’
[11:01:23.385]   - Field: ‘uuid’
[11:01:23.385]   - Field: ‘seed’
[11:01:23.385]   - Field: ‘version’
[11:01:23.385]   - Field: ‘result’
[11:01:23.385]   - Field: ‘asynchronous’
[11:01:23.385]   - Field: ‘calls’
[11:01:23.386]   - Field: ‘globals’
[11:01:23.386]   - Field: ‘stdout’
[11:01:23.386]   - Field: ‘earlySignal’
[11:01:23.386]   - Field: ‘lazy’
[11:01:23.386]   - Field: ‘state’
[11:01:23.386] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:23.386] - Launch lazy future ...
[11:01:23.386] Packages needed by the future expression (n = 0): <none>
[11:01:23.386] Packages needed by future strategies (n = 0): <none>
[11:01:23.387] {
[11:01:23.387]     {
[11:01:23.387]         {
[11:01:23.387]             ...future.startTime <- base::Sys.time()
[11:01:23.387]             {
[11:01:23.387]                 {
[11:01:23.387]                   {
[11:01:23.387]                     {
[11:01:23.387]                       base::local({
[11:01:23.387]                         has_future <- base::requireNamespace("future", 
[11:01:23.387]                           quietly = TRUE)
[11:01:23.387]                         if (has_future) {
[11:01:23.387]                           ns <- base::getNamespace("future")
[11:01:23.387]                           version <- ns[[".package"]][["version"]]
[11:01:23.387]                           if (is.null(version)) 
[11:01:23.387]                             version <- utils::packageVersion("future")
[11:01:23.387]                         }
[11:01:23.387]                         else {
[11:01:23.387]                           version <- NULL
[11:01:23.387]                         }
[11:01:23.387]                         if (!has_future || version < "1.8.0") {
[11:01:23.387]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:23.387]                             "", base::R.version$version.string), 
[11:01:23.387]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:23.387]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:23.387]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:23.387]                               "release", "version")], collapse = " "), 
[11:01:23.387]                             hostname = base::Sys.info()[["nodename"]])
[11:01:23.387]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:23.387]                             info)
[11:01:23.387]                           info <- base::paste(info, collapse = "; ")
[11:01:23.387]                           if (!has_future) {
[11:01:23.387]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:23.387]                               info)
[11:01:23.387]                           }
[11:01:23.387]                           else {
[11:01:23.387]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:23.387]                               info, version)
[11:01:23.387]                           }
[11:01:23.387]                           base::stop(msg)
[11:01:23.387]                         }
[11:01:23.387]                       })
[11:01:23.387]                     }
[11:01:23.387]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:23.387]                     base::options(mc.cores = 1L)
[11:01:23.387]                   }
[11:01:23.387]                   ...future.strategy.old <- future::plan("list")
[11:01:23.387]                   options(future.plan = NULL)
[11:01:23.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:23.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:23.387]                 }
[11:01:23.387]                 ...future.workdir <- getwd()
[11:01:23.387]             }
[11:01:23.387]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:23.387]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:23.387]         }
[11:01:23.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:23.387]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:23.387]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:23.387]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:23.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:23.387]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:23.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:23.387]             base::names(...future.oldOptions))
[11:01:23.387]     }
[11:01:23.387]     if (FALSE) {
[11:01:23.387]     }
[11:01:23.387]     else {
[11:01:23.387]         if (TRUE) {
[11:01:23.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:23.387]                 open = "w")
[11:01:23.387]         }
[11:01:23.387]         else {
[11:01:23.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:23.387]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:23.387]         }
[11:01:23.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:23.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:23.387]             base::sink(type = "output", split = FALSE)
[11:01:23.387]             base::close(...future.stdout)
[11:01:23.387]         }, add = TRUE)
[11:01:23.387]     }
[11:01:23.387]     ...future.frame <- base::sys.nframe()
[11:01:23.387]     ...future.conditions <- base::list()
[11:01:23.387]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:23.387]     if (FALSE) {
[11:01:23.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:23.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:23.387]     }
[11:01:23.387]     ...future.result <- base::tryCatch({
[11:01:23.387]         base::withCallingHandlers({
[11:01:23.387]             ...future.value <- base::withVisible(base::local({
[11:01:23.387]                 ...future.makeSendCondition <- base::local({
[11:01:23.387]                   sendCondition <- NULL
[11:01:23.387]                   function(frame = 1L) {
[11:01:23.387]                     if (is.function(sendCondition)) 
[11:01:23.387]                       return(sendCondition)
[11:01:23.387]                     ns <- getNamespace("parallel")
[11:01:23.387]                     if (exists("sendData", mode = "function", 
[11:01:23.387]                       envir = ns)) {
[11:01:23.387]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:23.387]                         envir = ns)
[11:01:23.387]                       envir <- sys.frame(frame)
[11:01:23.387]                       master <- NULL
[11:01:23.387]                       while (!identical(envir, .GlobalEnv) && 
[11:01:23.387]                         !identical(envir, emptyenv())) {
[11:01:23.387]                         if (exists("master", mode = "list", envir = envir, 
[11:01:23.387]                           inherits = FALSE)) {
[11:01:23.387]                           master <- get("master", mode = "list", 
[11:01:23.387]                             envir = envir, inherits = FALSE)
[11:01:23.387]                           if (inherits(master, c("SOCKnode", 
[11:01:23.387]                             "SOCK0node"))) {
[11:01:23.387]                             sendCondition <<- function(cond) {
[11:01:23.387]                               data <- list(type = "VALUE", value = cond, 
[11:01:23.387]                                 success = TRUE)
[11:01:23.387]                               parallel_sendData(master, data)
[11:01:23.387]                             }
[11:01:23.387]                             return(sendCondition)
[11:01:23.387]                           }
[11:01:23.387]                         }
[11:01:23.387]                         frame <- frame + 1L
[11:01:23.387]                         envir <- sys.frame(frame)
[11:01:23.387]                       }
[11:01:23.387]                     }
[11:01:23.387]                     sendCondition <<- function(cond) NULL
[11:01:23.387]                   }
[11:01:23.387]                 })
[11:01:23.387]                 withCallingHandlers({
[11:01:23.387]                   {
[11:01:23.387]                     2 * a
[11:01:23.387]                   }
[11:01:23.387]                 }, immediateCondition = function(cond) {
[11:01:23.387]                   sendCondition <- ...future.makeSendCondition()
[11:01:23.387]                   sendCondition(cond)
[11:01:23.387]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:23.387]                   {
[11:01:23.387]                     inherits <- base::inherits
[11:01:23.387]                     invokeRestart <- base::invokeRestart
[11:01:23.387]                     is.null <- base::is.null
[11:01:23.387]                     muffled <- FALSE
[11:01:23.387]                     if (inherits(cond, "message")) {
[11:01:23.387]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:23.387]                       if (muffled) 
[11:01:23.387]                         invokeRestart("muffleMessage")
[11:01:23.387]                     }
[11:01:23.387]                     else if (inherits(cond, "warning")) {
[11:01:23.387]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:23.387]                       if (muffled) 
[11:01:23.387]                         invokeRestart("muffleWarning")
[11:01:23.387]                     }
[11:01:23.387]                     else if (inherits(cond, "condition")) {
[11:01:23.387]                       if (!is.null(pattern)) {
[11:01:23.387]                         computeRestarts <- base::computeRestarts
[11:01:23.387]                         grepl <- base::grepl
[11:01:23.387]                         restarts <- computeRestarts(cond)
[11:01:23.387]                         for (restart in restarts) {
[11:01:23.387]                           name <- restart$name
[11:01:23.387]                           if (is.null(name)) 
[11:01:23.387]                             next
[11:01:23.387]                           if (!grepl(pattern, name)) 
[11:01:23.387]                             next
[11:01:23.387]                           invokeRestart(restart)
[11:01:23.387]                           muffled <- TRUE
[11:01:23.387]                           break
[11:01:23.387]                         }
[11:01:23.387]                       }
[11:01:23.387]                     }
[11:01:23.387]                     invisible(muffled)
[11:01:23.387]                   }
[11:01:23.387]                   muffleCondition(cond)
[11:01:23.387]                 })
[11:01:23.387]             }))
[11:01:23.387]             future::FutureResult(value = ...future.value$value, 
[11:01:23.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:23.387]                   ...future.rng), globalenv = if (FALSE) 
[11:01:23.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:23.387]                     ...future.globalenv.names))
[11:01:23.387]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:23.387]         }, condition = base::local({
[11:01:23.387]             c <- base::c
[11:01:23.387]             inherits <- base::inherits
[11:01:23.387]             invokeRestart <- base::invokeRestart
[11:01:23.387]             length <- base::length
[11:01:23.387]             list <- base::list
[11:01:23.387]             seq.int <- base::seq.int
[11:01:23.387]             signalCondition <- base::signalCondition
[11:01:23.387]             sys.calls <- base::sys.calls
[11:01:23.387]             `[[` <- base::`[[`
[11:01:23.387]             `+` <- base::`+`
[11:01:23.387]             `<<-` <- base::`<<-`
[11:01:23.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:23.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:23.387]                   3L)]
[11:01:23.387]             }
[11:01:23.387]             function(cond) {
[11:01:23.387]                 is_error <- inherits(cond, "error")
[11:01:23.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:23.387]                   NULL)
[11:01:23.387]                 if (is_error) {
[11:01:23.387]                   sessionInformation <- function() {
[11:01:23.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:23.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:23.387]                       search = base::search(), system = base::Sys.info())
[11:01:23.387]                   }
[11:01:23.387]                   ...future.conditions[[length(...future.conditions) + 
[11:01:23.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:23.387]                     cond$call), session = sessionInformation(), 
[11:01:23.387]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:23.387]                   signalCondition(cond)
[11:01:23.387]                 }
[11:01:23.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:23.387]                 "immediateCondition"))) {
[11:01:23.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:23.387]                   ...future.conditions[[length(...future.conditions) + 
[11:01:23.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:23.387]                   if (TRUE && !signal) {
[11:01:23.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:23.387]                     {
[11:01:23.387]                       inherits <- base::inherits
[11:01:23.387]                       invokeRestart <- base::invokeRestart
[11:01:23.387]                       is.null <- base::is.null
[11:01:23.387]                       muffled <- FALSE
[11:01:23.387]                       if (inherits(cond, "message")) {
[11:01:23.387]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:23.387]                         if (muffled) 
[11:01:23.387]                           invokeRestart("muffleMessage")
[11:01:23.387]                       }
[11:01:23.387]                       else if (inherits(cond, "warning")) {
[11:01:23.387]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:23.387]                         if (muffled) 
[11:01:23.387]                           invokeRestart("muffleWarning")
[11:01:23.387]                       }
[11:01:23.387]                       else if (inherits(cond, "condition")) {
[11:01:23.387]                         if (!is.null(pattern)) {
[11:01:23.387]                           computeRestarts <- base::computeRestarts
[11:01:23.387]                           grepl <- base::grepl
[11:01:23.387]                           restarts <- computeRestarts(cond)
[11:01:23.387]                           for (restart in restarts) {
[11:01:23.387]                             name <- restart$name
[11:01:23.387]                             if (is.null(name)) 
[11:01:23.387]                               next
[11:01:23.387]                             if (!grepl(pattern, name)) 
[11:01:23.387]                               next
[11:01:23.387]                             invokeRestart(restart)
[11:01:23.387]                             muffled <- TRUE
[11:01:23.387]                             break
[11:01:23.387]                           }
[11:01:23.387]                         }
[11:01:23.387]                       }
[11:01:23.387]                       invisible(muffled)
[11:01:23.387]                     }
[11:01:23.387]                     muffleCondition(cond, pattern = "^muffle")
[11:01:23.387]                   }
[11:01:23.387]                 }
[11:01:23.387]                 else {
[11:01:23.387]                   if (TRUE) {
[11:01:23.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:23.387]                     {
[11:01:23.387]                       inherits <- base::inherits
[11:01:23.387]                       invokeRestart <- base::invokeRestart
[11:01:23.387]                       is.null <- base::is.null
[11:01:23.387]                       muffled <- FALSE
[11:01:23.387]                       if (inherits(cond, "message")) {
[11:01:23.387]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:23.387]                         if (muffled) 
[11:01:23.387]                           invokeRestart("muffleMessage")
[11:01:23.387]                       }
[11:01:23.387]                       else if (inherits(cond, "warning")) {
[11:01:23.387]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:23.387]                         if (muffled) 
[11:01:23.387]                           invokeRestart("muffleWarning")
[11:01:23.387]                       }
[11:01:23.387]                       else if (inherits(cond, "condition")) {
[11:01:23.387]                         if (!is.null(pattern)) {
[11:01:23.387]                           computeRestarts <- base::computeRestarts
[11:01:23.387]                           grepl <- base::grepl
[11:01:23.387]                           restarts <- computeRestarts(cond)
[11:01:23.387]                           for (restart in restarts) {
[11:01:23.387]                             name <- restart$name
[11:01:23.387]                             if (is.null(name)) 
[11:01:23.387]                               next
[11:01:23.387]                             if (!grepl(pattern, name)) 
[11:01:23.387]                               next
[11:01:23.387]                             invokeRestart(restart)
[11:01:23.387]                             muffled <- TRUE
[11:01:23.387]                             break
[11:01:23.387]                           }
[11:01:23.387]                         }
[11:01:23.387]                       }
[11:01:23.387]                       invisible(muffled)
[11:01:23.387]                     }
[11:01:23.387]                     muffleCondition(cond, pattern = "^muffle")
[11:01:23.387]                   }
[11:01:23.387]                 }
[11:01:23.387]             }
[11:01:23.387]         }))
[11:01:23.387]     }, error = function(ex) {
[11:01:23.387]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:23.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:23.387]                 ...future.rng), started = ...future.startTime, 
[11:01:23.387]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:23.387]             version = "1.8"), class = "FutureResult")
[11:01:23.387]     }, finally = {
[11:01:23.387]         if (!identical(...future.workdir, getwd())) 
[11:01:23.387]             setwd(...future.workdir)
[11:01:23.387]         {
[11:01:23.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:23.387]                 ...future.oldOptions$nwarnings <- NULL
[11:01:23.387]             }
[11:01:23.387]             base::options(...future.oldOptions)
[11:01:23.387]             if (.Platform$OS.type == "windows") {
[11:01:23.387]                 old_names <- names(...future.oldEnvVars)
[11:01:23.387]                 envs <- base::Sys.getenv()
[11:01:23.387]                 names <- names(envs)
[11:01:23.387]                 common <- intersect(names, old_names)
[11:01:23.387]                 added <- setdiff(names, old_names)
[11:01:23.387]                 removed <- setdiff(old_names, names)
[11:01:23.387]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:23.387]                   envs[common]]
[11:01:23.387]                 NAMES <- toupper(changed)
[11:01:23.387]                 args <- list()
[11:01:23.387]                 for (kk in seq_along(NAMES)) {
[11:01:23.387]                   name <- changed[[kk]]
[11:01:23.387]                   NAME <- NAMES[[kk]]
[11:01:23.387]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:23.387]                     next
[11:01:23.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:23.387]                 }
[11:01:23.387]                 NAMES <- toupper(added)
[11:01:23.387]                 for (kk in seq_along(NAMES)) {
[11:01:23.387]                   name <- added[[kk]]
[11:01:23.387]                   NAME <- NAMES[[kk]]
[11:01:23.387]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:23.387]                     next
[11:01:23.387]                   args[[name]] <- ""
[11:01:23.387]                 }
[11:01:23.387]                 NAMES <- toupper(removed)
[11:01:23.387]                 for (kk in seq_along(NAMES)) {
[11:01:23.387]                   name <- removed[[kk]]
[11:01:23.387]                   NAME <- NAMES[[kk]]
[11:01:23.387]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:23.387]                     next
[11:01:23.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:23.387]                 }
[11:01:23.387]                 if (length(args) > 0) 
[11:01:23.387]                   base::do.call(base::Sys.setenv, args = args)
[11:01:23.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:23.387]             }
[11:01:23.387]             else {
[11:01:23.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:23.387]             }
[11:01:23.387]             {
[11:01:23.387]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:23.387]                   0L) {
[11:01:23.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:23.387]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:23.387]                   base::options(opts)
[11:01:23.387]                 }
[11:01:23.387]                 {
[11:01:23.387]                   {
[11:01:23.387]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:23.387]                     NULL
[11:01:23.387]                   }
[11:01:23.387]                   options(future.plan = NULL)
[11:01:23.387]                   if (is.na(NA_character_)) 
[11:01:23.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:23.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:23.387]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:23.387]                     .init = FALSE)
[11:01:23.387]                 }
[11:01:23.387]             }
[11:01:23.387]         }
[11:01:23.387]     })
[11:01:23.387]     if (TRUE) {
[11:01:23.387]         base::sink(type = "output", split = FALSE)
[11:01:23.387]         if (TRUE) {
[11:01:23.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:23.387]         }
[11:01:23.387]         else {
[11:01:23.387]             ...future.result["stdout"] <- base::list(NULL)
[11:01:23.387]         }
[11:01:23.387]         base::close(...future.stdout)
[11:01:23.387]         ...future.stdout <- NULL
[11:01:23.387]     }
[11:01:23.387]     ...future.result$conditions <- ...future.conditions
[11:01:23.387]     ...future.result$finished <- base::Sys.time()
[11:01:23.387]     ...future.result
[11:01:23.387] }
[11:01:23.389] Exporting 1 global objects (346 bytes) to cluster node #1 ...
[11:01:23.389] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[11:01:23.390] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[11:01:23.390] Exporting 1 global objects (346 bytes) to cluster node #1 ... DONE
[11:01:23.390] MultisessionFuture started
[11:01:23.390] - Launch lazy future ... done
[11:01:23.391] run() for ‘MultisessionFuture’ ... done
[11:01:23.391] result() for ClusterFuture ...
[11:01:23.391] receiveMessageFromWorker() for ClusterFuture ...
[11:01:23.391] - Validating connection of MultisessionFuture
[11:01:23.432] - received message: FutureResult
[11:01:23.432] - Received FutureResult
[11:01:23.432] - Erased future from FutureRegistry
[11:01:23.432] result() for ClusterFuture ...
[11:01:23.432] - result already collected: FutureResult
[11:01:23.432] result() for ClusterFuture ... done
[11:01:23.433] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:23.433] result() for ClusterFuture ... done
[11:01:23.433] result() for ClusterFuture ...
[11:01:23.433] - result already collected: FutureResult
[11:01:23.433] result() for ClusterFuture ... done
[11:01:23.433] getGlobalsAndPackages() ...
[11:01:23.433] Searching for globals...
[11:01:23.434] - globals found: [3] ‘{’, ‘*’, ‘a’
[11:01:23.434] Searching for globals ... DONE
[11:01:23.434] Resolving globals: FALSE
[11:01:23.434] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:23.435] The total size of the 1 globals exported for future expression (‘{; 2 * a; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:23.435] - globals: [1] ‘a’
[11:01:23.435] 
[11:01:23.435] getGlobalsAndPackages() ... DONE
[11:01:23.435] run() for ‘Future’ ...
[11:01:23.435] - state: ‘created’
[11:01:23.436] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:23.449] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:23.449] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:23.449]   - Field: ‘node’
[11:01:23.449]   - Field: ‘label’
[11:01:23.449]   - Field: ‘local’
[11:01:23.450]   - Field: ‘owner’
[11:01:23.450]   - Field: ‘envir’
[11:01:23.450]   - Field: ‘workers’
[11:01:23.450]   - Field: ‘packages’
[11:01:23.450]   - Field: ‘gc’
[11:01:23.450]   - Field: ‘conditions’
[11:01:23.450]   - Field: ‘persistent’
[11:01:23.450]   - Field: ‘expr’
[11:01:23.450]   - Field: ‘uuid’
[11:01:23.450]   - Field: ‘seed’
[11:01:23.450]   - Field: ‘version’
[11:01:23.450]   - Field: ‘result’
[11:01:23.450]   - Field: ‘asynchronous’
[11:01:23.451]   - Field: ‘calls’
[11:01:23.451]   - Field: ‘globals’
[11:01:23.451]   - Field: ‘stdout’
[11:01:23.451]   - Field: ‘earlySignal’
[11:01:23.451]   - Field: ‘lazy’
[11:01:23.451]   - Field: ‘state’
[11:01:23.451] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:23.451] - Launch lazy future ...
[11:01:23.451] Packages needed by the future expression (n = 0): <none>
[11:01:23.451] Packages needed by future strategies (n = 0): <none>
[11:01:23.452] {
[11:01:23.452]     {
[11:01:23.452]         {
[11:01:23.452]             ...future.startTime <- base::Sys.time()
[11:01:23.452]             {
[11:01:23.452]                 {
[11:01:23.452]                   {
[11:01:23.452]                     {
[11:01:23.452]                       base::local({
[11:01:23.452]                         has_future <- base::requireNamespace("future", 
[11:01:23.452]                           quietly = TRUE)
[11:01:23.452]                         if (has_future) {
[11:01:23.452]                           ns <- base::getNamespace("future")
[11:01:23.452]                           version <- ns[[".package"]][["version"]]
[11:01:23.452]                           if (is.null(version)) 
[11:01:23.452]                             version <- utils::packageVersion("future")
[11:01:23.452]                         }
[11:01:23.452]                         else {
[11:01:23.452]                           version <- NULL
[11:01:23.452]                         }
[11:01:23.452]                         if (!has_future || version < "1.8.0") {
[11:01:23.452]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:23.452]                             "", base::R.version$version.string), 
[11:01:23.452]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:23.452]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:23.452]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:23.452]                               "release", "version")], collapse = " "), 
[11:01:23.452]                             hostname = base::Sys.info()[["nodename"]])
[11:01:23.452]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:23.452]                             info)
[11:01:23.452]                           info <- base::paste(info, collapse = "; ")
[11:01:23.452]                           if (!has_future) {
[11:01:23.452]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:23.452]                               info)
[11:01:23.452]                           }
[11:01:23.452]                           else {
[11:01:23.452]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:23.452]                               info, version)
[11:01:23.452]                           }
[11:01:23.452]                           base::stop(msg)
[11:01:23.452]                         }
[11:01:23.452]                       })
[11:01:23.452]                     }
[11:01:23.452]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:23.452]                     base::options(mc.cores = 1L)
[11:01:23.452]                   }
[11:01:23.452]                   ...future.strategy.old <- future::plan("list")
[11:01:23.452]                   options(future.plan = NULL)
[11:01:23.452]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:23.452]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:23.452]                 }
[11:01:23.452]                 ...future.workdir <- getwd()
[11:01:23.452]             }
[11:01:23.452]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:23.452]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:23.452]         }
[11:01:23.452]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:23.452]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:23.452]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:23.452]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:23.452]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:23.452]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:23.452]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:23.452]             base::names(...future.oldOptions))
[11:01:23.452]     }
[11:01:23.452]     if (FALSE) {
[11:01:23.452]     }
[11:01:23.452]     else {
[11:01:23.452]         if (TRUE) {
[11:01:23.452]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:23.452]                 open = "w")
[11:01:23.452]         }
[11:01:23.452]         else {
[11:01:23.452]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:23.452]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:23.452]         }
[11:01:23.452]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:23.452]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:23.452]             base::sink(type = "output", split = FALSE)
[11:01:23.452]             base::close(...future.stdout)
[11:01:23.452]         }, add = TRUE)
[11:01:23.452]     }
[11:01:23.452]     ...future.frame <- base::sys.nframe()
[11:01:23.452]     ...future.conditions <- base::list()
[11:01:23.452]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:23.452]     if (FALSE) {
[11:01:23.452]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:23.452]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:23.452]     }
[11:01:23.452]     ...future.result <- base::tryCatch({
[11:01:23.452]         base::withCallingHandlers({
[11:01:23.452]             ...future.value <- base::withVisible(base::local({
[11:01:23.452]                 ...future.makeSendCondition <- base::local({
[11:01:23.452]                   sendCondition <- NULL
[11:01:23.452]                   function(frame = 1L) {
[11:01:23.452]                     if (is.function(sendCondition)) 
[11:01:23.452]                       return(sendCondition)
[11:01:23.452]                     ns <- getNamespace("parallel")
[11:01:23.452]                     if (exists("sendData", mode = "function", 
[11:01:23.452]                       envir = ns)) {
[11:01:23.452]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:23.452]                         envir = ns)
[11:01:23.452]                       envir <- sys.frame(frame)
[11:01:23.452]                       master <- NULL
[11:01:23.452]                       while (!identical(envir, .GlobalEnv) && 
[11:01:23.452]                         !identical(envir, emptyenv())) {
[11:01:23.452]                         if (exists("master", mode = "list", envir = envir, 
[11:01:23.452]                           inherits = FALSE)) {
[11:01:23.452]                           master <- get("master", mode = "list", 
[11:01:23.452]                             envir = envir, inherits = FALSE)
[11:01:23.452]                           if (inherits(master, c("SOCKnode", 
[11:01:23.452]                             "SOCK0node"))) {
[11:01:23.452]                             sendCondition <<- function(cond) {
[11:01:23.452]                               data <- list(type = "VALUE", value = cond, 
[11:01:23.452]                                 success = TRUE)
[11:01:23.452]                               parallel_sendData(master, data)
[11:01:23.452]                             }
[11:01:23.452]                             return(sendCondition)
[11:01:23.452]                           }
[11:01:23.452]                         }
[11:01:23.452]                         frame <- frame + 1L
[11:01:23.452]                         envir <- sys.frame(frame)
[11:01:23.452]                       }
[11:01:23.452]                     }
[11:01:23.452]                     sendCondition <<- function(cond) NULL
[11:01:23.452]                   }
[11:01:23.452]                 })
[11:01:23.452]                 withCallingHandlers({
[11:01:23.452]                   {
[11:01:23.452]                     2 * a
[11:01:23.452]                   }
[11:01:23.452]                 }, immediateCondition = function(cond) {
[11:01:23.452]                   sendCondition <- ...future.makeSendCondition()
[11:01:23.452]                   sendCondition(cond)
[11:01:23.452]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:23.452]                   {
[11:01:23.452]                     inherits <- base::inherits
[11:01:23.452]                     invokeRestart <- base::invokeRestart
[11:01:23.452]                     is.null <- base::is.null
[11:01:23.452]                     muffled <- FALSE
[11:01:23.452]                     if (inherits(cond, "message")) {
[11:01:23.452]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:23.452]                       if (muffled) 
[11:01:23.452]                         invokeRestart("muffleMessage")
[11:01:23.452]                     }
[11:01:23.452]                     else if (inherits(cond, "warning")) {
[11:01:23.452]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:23.452]                       if (muffled) 
[11:01:23.452]                         invokeRestart("muffleWarning")
[11:01:23.452]                     }
[11:01:23.452]                     else if (inherits(cond, "condition")) {
[11:01:23.452]                       if (!is.null(pattern)) {
[11:01:23.452]                         computeRestarts <- base::computeRestarts
[11:01:23.452]                         grepl <- base::grepl
[11:01:23.452]                         restarts <- computeRestarts(cond)
[11:01:23.452]                         for (restart in restarts) {
[11:01:23.452]                           name <- restart$name
[11:01:23.452]                           if (is.null(name)) 
[11:01:23.452]                             next
[11:01:23.452]                           if (!grepl(pattern, name)) 
[11:01:23.452]                             next
[11:01:23.452]                           invokeRestart(restart)
[11:01:23.452]                           muffled <- TRUE
[11:01:23.452]                           break
[11:01:23.452]                         }
[11:01:23.452]                       }
[11:01:23.452]                     }
[11:01:23.452]                     invisible(muffled)
[11:01:23.452]                   }
[11:01:23.452]                   muffleCondition(cond)
[11:01:23.452]                 })
[11:01:23.452]             }))
[11:01:23.452]             future::FutureResult(value = ...future.value$value, 
[11:01:23.452]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:23.452]                   ...future.rng), globalenv = if (FALSE) 
[11:01:23.452]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:23.452]                     ...future.globalenv.names))
[11:01:23.452]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:23.452]         }, condition = base::local({
[11:01:23.452]             c <- base::c
[11:01:23.452]             inherits <- base::inherits
[11:01:23.452]             invokeRestart <- base::invokeRestart
[11:01:23.452]             length <- base::length
[11:01:23.452]             list <- base::list
[11:01:23.452]             seq.int <- base::seq.int
[11:01:23.452]             signalCondition <- base::signalCondition
[11:01:23.452]             sys.calls <- base::sys.calls
[11:01:23.452]             `[[` <- base::`[[`
[11:01:23.452]             `+` <- base::`+`
[11:01:23.452]             `<<-` <- base::`<<-`
[11:01:23.452]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:23.452]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:23.452]                   3L)]
[11:01:23.452]             }
[11:01:23.452]             function(cond) {
[11:01:23.452]                 is_error <- inherits(cond, "error")
[11:01:23.452]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:23.452]                   NULL)
[11:01:23.452]                 if (is_error) {
[11:01:23.452]                   sessionInformation <- function() {
[11:01:23.452]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:23.452]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:23.452]                       search = base::search(), system = base::Sys.info())
[11:01:23.452]                   }
[11:01:23.452]                   ...future.conditions[[length(...future.conditions) + 
[11:01:23.452]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:23.452]                     cond$call), session = sessionInformation(), 
[11:01:23.452]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:23.452]                   signalCondition(cond)
[11:01:23.452]                 }
[11:01:23.452]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:23.452]                 "immediateCondition"))) {
[11:01:23.452]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:23.452]                   ...future.conditions[[length(...future.conditions) + 
[11:01:23.452]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:23.452]                   if (TRUE && !signal) {
[11:01:23.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:23.452]                     {
[11:01:23.452]                       inherits <- base::inherits
[11:01:23.452]                       invokeRestart <- base::invokeRestart
[11:01:23.452]                       is.null <- base::is.null
[11:01:23.452]                       muffled <- FALSE
[11:01:23.452]                       if (inherits(cond, "message")) {
[11:01:23.452]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:23.452]                         if (muffled) 
[11:01:23.452]                           invokeRestart("muffleMessage")
[11:01:23.452]                       }
[11:01:23.452]                       else if (inherits(cond, "warning")) {
[11:01:23.452]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:23.452]                         if (muffled) 
[11:01:23.452]                           invokeRestart("muffleWarning")
[11:01:23.452]                       }
[11:01:23.452]                       else if (inherits(cond, "condition")) {
[11:01:23.452]                         if (!is.null(pattern)) {
[11:01:23.452]                           computeRestarts <- base::computeRestarts
[11:01:23.452]                           grepl <- base::grepl
[11:01:23.452]                           restarts <- computeRestarts(cond)
[11:01:23.452]                           for (restart in restarts) {
[11:01:23.452]                             name <- restart$name
[11:01:23.452]                             if (is.null(name)) 
[11:01:23.452]                               next
[11:01:23.452]                             if (!grepl(pattern, name)) 
[11:01:23.452]                               next
[11:01:23.452]                             invokeRestart(restart)
[11:01:23.452]                             muffled <- TRUE
[11:01:23.452]                             break
[11:01:23.452]                           }
[11:01:23.452]                         }
[11:01:23.452]                       }
[11:01:23.452]                       invisible(muffled)
[11:01:23.452]                     }
[11:01:23.452]                     muffleCondition(cond, pattern = "^muffle")
[11:01:23.452]                   }
[11:01:23.452]                 }
[11:01:23.452]                 else {
[11:01:23.452]                   if (TRUE) {
[11:01:23.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:23.452]                     {
[11:01:23.452]                       inherits <- base::inherits
[11:01:23.452]                       invokeRestart <- base::invokeRestart
[11:01:23.452]                       is.null <- base::is.null
[11:01:23.452]                       muffled <- FALSE
[11:01:23.452]                       if (inherits(cond, "message")) {
[11:01:23.452]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:23.452]                         if (muffled) 
[11:01:23.452]                           invokeRestart("muffleMessage")
[11:01:23.452]                       }
[11:01:23.452]                       else if (inherits(cond, "warning")) {
[11:01:23.452]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:23.452]                         if (muffled) 
[11:01:23.452]                           invokeRestart("muffleWarning")
[11:01:23.452]                       }
[11:01:23.452]                       else if (inherits(cond, "condition")) {
[11:01:23.452]                         if (!is.null(pattern)) {
[11:01:23.452]                           computeRestarts <- base::computeRestarts
[11:01:23.452]                           grepl <- base::grepl
[11:01:23.452]                           restarts <- computeRestarts(cond)
[11:01:23.452]                           for (restart in restarts) {
[11:01:23.452]                             name <- restart$name
[11:01:23.452]                             if (is.null(name)) 
[11:01:23.452]                               next
[11:01:23.452]                             if (!grepl(pattern, name)) 
[11:01:23.452]                               next
[11:01:23.452]                             invokeRestart(restart)
[11:01:23.452]                             muffled <- TRUE
[11:01:23.452]                             break
[11:01:23.452]                           }
[11:01:23.452]                         }
[11:01:23.452]                       }
[11:01:23.452]                       invisible(muffled)
[11:01:23.452]                     }
[11:01:23.452]                     muffleCondition(cond, pattern = "^muffle")
[11:01:23.452]                   }
[11:01:23.452]                 }
[11:01:23.452]             }
[11:01:23.452]         }))
[11:01:23.452]     }, error = function(ex) {
[11:01:23.452]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:23.452]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:23.452]                 ...future.rng), started = ...future.startTime, 
[11:01:23.452]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:23.452]             version = "1.8"), class = "FutureResult")
[11:01:23.452]     }, finally = {
[11:01:23.452]         if (!identical(...future.workdir, getwd())) 
[11:01:23.452]             setwd(...future.workdir)
[11:01:23.452]         {
[11:01:23.452]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:23.452]                 ...future.oldOptions$nwarnings <- NULL
[11:01:23.452]             }
[11:01:23.452]             base::options(...future.oldOptions)
[11:01:23.452]             if (.Platform$OS.type == "windows") {
[11:01:23.452]                 old_names <- names(...future.oldEnvVars)
[11:01:23.452]                 envs <- base::Sys.getenv()
[11:01:23.452]                 names <- names(envs)
[11:01:23.452]                 common <- intersect(names, old_names)
[11:01:23.452]                 added <- setdiff(names, old_names)
[11:01:23.452]                 removed <- setdiff(old_names, names)
[11:01:23.452]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:23.452]                   envs[common]]
[11:01:23.452]                 NAMES <- toupper(changed)
[11:01:23.452]                 args <- list()
[11:01:23.452]                 for (kk in seq_along(NAMES)) {
[11:01:23.452]                   name <- changed[[kk]]
[11:01:23.452]                   NAME <- NAMES[[kk]]
[11:01:23.452]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:23.452]                     next
[11:01:23.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:23.452]                 }
[11:01:23.452]                 NAMES <- toupper(added)
[11:01:23.452]                 for (kk in seq_along(NAMES)) {
[11:01:23.452]                   name <- added[[kk]]
[11:01:23.452]                   NAME <- NAMES[[kk]]
[11:01:23.452]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:23.452]                     next
[11:01:23.452]                   args[[name]] <- ""
[11:01:23.452]                 }
[11:01:23.452]                 NAMES <- toupper(removed)
[11:01:23.452]                 for (kk in seq_along(NAMES)) {
[11:01:23.452]                   name <- removed[[kk]]
[11:01:23.452]                   NAME <- NAMES[[kk]]
[11:01:23.452]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:23.452]                     next
[11:01:23.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:23.452]                 }
[11:01:23.452]                 if (length(args) > 0) 
[11:01:23.452]                   base::do.call(base::Sys.setenv, args = args)
[11:01:23.452]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:23.452]             }
[11:01:23.452]             else {
[11:01:23.452]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:23.452]             }
[11:01:23.452]             {
[11:01:23.452]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:23.452]                   0L) {
[11:01:23.452]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:23.452]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:23.452]                   base::options(opts)
[11:01:23.452]                 }
[11:01:23.452]                 {
[11:01:23.452]                   {
[11:01:23.452]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:23.452]                     NULL
[11:01:23.452]                   }
[11:01:23.452]                   options(future.plan = NULL)
[11:01:23.452]                   if (is.na(NA_character_)) 
[11:01:23.452]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:23.452]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:23.452]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:23.452]                     .init = FALSE)
[11:01:23.452]                 }
[11:01:23.452]             }
[11:01:23.452]         }
[11:01:23.452]     })
[11:01:23.452]     if (TRUE) {
[11:01:23.452]         base::sink(type = "output", split = FALSE)
[11:01:23.452]         if (TRUE) {
[11:01:23.452]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:23.452]         }
[11:01:23.452]         else {
[11:01:23.452]             ...future.result["stdout"] <- base::list(NULL)
[11:01:23.452]         }
[11:01:23.452]         base::close(...future.stdout)
[11:01:23.452]         ...future.stdout <- NULL
[11:01:23.452]     }
[11:01:23.452]     ...future.result$conditions <- ...future.conditions
[11:01:23.452]     ...future.result$finished <- base::Sys.time()
[11:01:23.452]     ...future.result
[11:01:23.452] }
[11:01:23.454] Exporting 1 global objects (346 bytes) to cluster node #1 ...
[11:01:23.454] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[11:01:23.455] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[11:01:23.455] Exporting 1 global objects (346 bytes) to cluster node #1 ... DONE
[11:01:23.455] MultisessionFuture started
[11:01:23.456] - Launch lazy future ... done
[11:01:23.456] run() for ‘MultisessionFuture’ ... done
[11:01:23.456] result() for ClusterFuture ...
[11:01:23.456] receiveMessageFromWorker() for ClusterFuture ...
[11:01:23.456] - Validating connection of MultisessionFuture
[11:01:23.497] - received message: FutureResult
[11:01:23.497] - Received FutureResult
[11:01:23.497] - Erased future from FutureRegistry
[11:01:23.497] result() for ClusterFuture ...
[11:01:23.497] - result already collected: FutureResult
[11:01:23.498] result() for ClusterFuture ... done
[11:01:23.498] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:23.498] result() for ClusterFuture ... done
[11:01:23.498] result() for ClusterFuture ...
[11:01:23.498] - result already collected: FutureResult
[11:01:23.498] result() for ClusterFuture ... done
*** futureAssign() with ‘multisession’ futures ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futureAssign() - lazy = TRUE / FALSE ... DONE")
*** futureAssign() - lazy = TRUE / FALSE ... DONE
> 
> message("*** futureAssign() ... DONE")
*** futureAssign() ... DONE
> 
> source("incl/end.R")
[11:01:23.499] plan(): Setting new future strategy stack:
[11:01:23.499] List of future strategies:
[11:01:23.499] 1. FutureStrategy:
[11:01:23.499]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:23.499]    - tweaked: FALSE
[11:01:23.499]    - call: future::plan(oplan)
[11:01:23.500] plan(): nbrOfWorkers() = 1
> 
