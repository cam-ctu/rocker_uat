
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[11:01:00.914] plan(): Setting new future strategy stack:
[11:01:00.914] List of future strategies:
[11:01:00.914] 1. sequential:
[11:01:00.914]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:00.914]    - tweaked: FALSE
[11:01:00.914]    - call: future::plan("sequential")
[11:01:00.927] plan(): nbrOfWorkers() = 1
> 
> message("*** Demos ...")
*** Demos ...
> 
> message("*** Fibonacci demo of the 'future' package ...")
*** Fibonacci demo of the 'future' package ...
> demo("fibonacci", package = "future", ask = FALSE)


	demo(fibonacci)
	---- ~~~~~~~~~

> library("future")

> library("listenv")

> ## IMPORTANT:
> ## 1. The below usage of lazy futures will only work when they are
> ##    all evaluated in the same process.
> ## 2. We disable the capturing of standard output (stdout=NA) to avoid
> ##    'sink stack is full' errors
> ## 3. We disable the capturing of most conditions (condition="error") to
> ##    avoid stacking up too many conditions
> oplan <- plan(sequential)
[11:01:00.946] plan(): Setting new future strategy stack:
[11:01:00.947] List of future strategies:
[11:01:00.947] 1. sequential:
[11:01:00.947]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:00.947]    - tweaked: FALSE
[11:01:00.947]    - call: plan(sequential)
[11:01:00.957] plan(): nbrOfWorkers() = 1

> ## Defines the first 100 Fibonacci numbers
> ## (0, 1, 1, 2, 3, 5, 8, ...)
> ## but calculate only the ones need when
> ## a number is actually requested.
> 
> x <- listenv()

> x[[1]] <- 0

> x[[2]] <- 1

> for (i in 3:100) {
+   x[[i]] %<-% { x[[i - 2]] + x[[i - 1]] } %lazy% TRUE %stdout% NA %conditions% "error"
+ }
[11:01:00.963] getGlobalsAndPackages() ...
[11:01:00.963] Searching for globals...
[11:01:00.971] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:00.972] Searching for globals ... DONE
[11:01:00.972] Resolving globals: FALSE
[11:01:00.973] The total size of the 2 globals is 721 bytes (721 bytes)
[11:01:00.973] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 721 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (686 bytes of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:00.973] - globals: [2] ‘x’, ‘i’
[11:01:00.973] 
[11:01:00.973] getGlobalsAndPackages() ... DONE
[11:01:00.974] getGlobalsAndPackages() ...
[11:01:00.974] Searching for globals...
[11:01:00.976] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:00.976] Searching for globals ... DONE
[11:01:00.976] Resolving globals: FALSE
[11:01:00.976] The total size of the 2 globals is 33.37 KiB (34170 bytes)
[11:01:00.977] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 33.37 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (33.33 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:00.977] - globals: [2] ‘x’, ‘i’
[11:01:00.977] 
[11:01:00.977] getGlobalsAndPackages() ... DONE
[11:01:00.977] getGlobalsAndPackages() ...
[11:01:00.977] Searching for globals...
[11:01:00.979] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:00.979] Searching for globals ... DONE
[11:01:00.979] Resolving globals: FALSE
[11:01:00.980] The total size of the 2 globals is 52.40 KiB (53658 bytes)
[11:01:00.980] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 52.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (52.37 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:00.980] - globals: [2] ‘x’, ‘i’
[11:01:00.980] 
[11:01:00.980] getGlobalsAndPackages() ... DONE
[11:01:00.981] getGlobalsAndPackages() ...
[11:01:00.981] Searching for globals...
[11:01:00.982] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:00.982] Searching for globals ... DONE
[11:01:00.982] Resolving globals: FALSE
[11:01:00.983] The total size of the 2 globals is 71.43 KiB (73146 bytes)
[11:01:00.983] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 71.43 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (71.40 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:00.984] - globals: [2] ‘x’, ‘i’
[11:01:00.984] 
[11:01:00.984] getGlobalsAndPackages() ... DONE
[11:01:00.984] getGlobalsAndPackages() ...
[11:01:00.984] Searching for globals...
[11:01:00.986] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:00.986] Searching for globals ... DONE
[11:01:00.986] Resolving globals: FALSE
[11:01:00.987] The total size of the 2 globals is 90.46 KiB (92634 bytes)
[11:01:00.987] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 90.46 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (90.43 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:00.987] - globals: [2] ‘x’, ‘i’
[11:01:00.987] 
[11:01:00.987] getGlobalsAndPackages() ... DONE
[11:01:00.988] getGlobalsAndPackages() ...
[11:01:00.988] Searching for globals...
[11:01:00.989] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:00.989] Searching for globals ... DONE
[11:01:00.989] Resolving globals: FALSE
[11:01:00.990] The total size of the 2 globals is 109.49 KiB (112122 bytes)
[11:01:00.990] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 109.49 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (109.46 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:00.991] - globals: [2] ‘x’, ‘i’
[11:01:00.991] 
[11:01:00.991] getGlobalsAndPackages() ... DONE
[11:01:00.991] getGlobalsAndPackages() ...
[11:01:00.991] Searching for globals...
[11:01:00.993] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:00.993] Searching for globals ... DONE
[11:01:00.993] Resolving globals: FALSE
[11:01:00.995] The total size of the 2 globals is 128.53 KiB (131610 bytes)
[11:01:00.995] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 128.53 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (128.49 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:00.995] - globals: [2] ‘x’, ‘i’
[11:01:00.995] 
[11:01:00.995] getGlobalsAndPackages() ... DONE
[11:01:00.996] getGlobalsAndPackages() ...
[11:01:00.996] Searching for globals...
[11:01:00.997] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:00.997] Searching for globals ... DONE
[11:01:00.997] Resolving globals: FALSE
[11:01:00.998] The total size of the 2 globals is 147.56 KiB (151100 bytes)
[11:01:00.999] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 147.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (147.52 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:00.999] - globals: [2] ‘x’, ‘i’
[11:01:00.999] 
[11:01:00.999] getGlobalsAndPackages() ... DONE
[11:01:00.999] getGlobalsAndPackages() ...
[11:01:00.999] Searching for globals...
[11:01:01.001] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.001] Searching for globals ... DONE
[11:01:01.001] Resolving globals: FALSE
[11:01:01.002] The total size of the 2 globals is 166.59 KiB (170593 bytes)
[11:01:01.002] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 166.59 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (166.56 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.002] - globals: [2] ‘x’, ‘i’
[11:01:01.003] 
[11:01:01.003] getGlobalsAndPackages() ... DONE
[11:01:01.003] getGlobalsAndPackages() ...
[11:01:01.003] Searching for globals...
[11:01:01.005] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.005] Searching for globals ... DONE
[11:01:01.005] Resolving globals: FALSE
[11:01:01.006] The total size of the 2 globals is 185.63 KiB (190086 bytes)
[11:01:01.006] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 185.63 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (185.60 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.006] - globals: [2] ‘x’, ‘i’
[11:01:01.006] 
[11:01:01.006] getGlobalsAndPackages() ... DONE
[11:01:01.007] getGlobalsAndPackages() ...
[11:01:01.007] Searching for globals...
[11:01:01.008] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.008] Searching for globals ... DONE
[11:01:01.009] Resolving globals: FALSE
[11:01:01.010] The total size of the 2 globals is 204.67 KiB (209579 bytes)
[11:01:01.010] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 204.67 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (204.63 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.010] - globals: [2] ‘x’, ‘i’
[11:01:01.010] 
[11:01:01.010] getGlobalsAndPackages() ... DONE
[11:01:01.011] getGlobalsAndPackages() ...
[11:01:01.011] Searching for globals...
[11:01:01.012] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.012] Searching for globals ... DONE
[11:01:01.012] Resolving globals: FALSE
[11:01:01.014] The total size of the 2 globals is 223.73 KiB (229096 bytes)
[11:01:01.014] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 223.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (223.69 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.014] - globals: [2] ‘x’, ‘i’
[11:01:01.014] 
[11:01:01.014] getGlobalsAndPackages() ... DONE
[11:01:01.015] getGlobalsAndPackages() ...
[11:01:01.015] Searching for globals...
[11:01:01.016] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.016] Searching for globals ... DONE
[11:01:01.017] Resolving globals: FALSE
[11:01:01.018] The total size of the 2 globals is 242.76 KiB (248589 bytes)
[11:01:01.018] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 242.76 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (242.73 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.018] - globals: [2] ‘x’, ‘i’
[11:01:01.019] 
[11:01:01.019] getGlobalsAndPackages() ... DONE
[11:01:01.020] getGlobalsAndPackages() ...
[11:01:01.020] Searching for globals...
[11:01:01.021] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.021] Searching for globals ... DONE
[11:01:01.022] Resolving globals: FALSE
[11:01:01.023] The total size of the 2 globals is 261.80 KiB (268082 bytes)
[11:01:01.023] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 261.80 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (261.76 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.023] - globals: [2] ‘x’, ‘i’
[11:01:01.023] 
[11:01:01.024] getGlobalsAndPackages() ... DONE
[11:01:01.024] getGlobalsAndPackages() ...
[11:01:01.024] Searching for globals...
[11:01:01.025] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.026] Searching for globals ... DONE
[11:01:01.026] Resolving globals: FALSE
[11:01:01.027] The total size of the 2 globals is 280.83 KiB (287575 bytes)
[11:01:01.027] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 280.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (280.80 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.027] - globals: [2] ‘x’, ‘i’
[11:01:01.028] 
[11:01:01.028] getGlobalsAndPackages() ... DONE
[11:01:01.028] getGlobalsAndPackages() ...
[11:01:01.028] Searching for globals...
[11:01:01.029] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.030] Searching for globals ... DONE
[11:01:01.030] Resolving globals: FALSE
[11:01:01.031] The total size of the 2 globals is 299.87 KiB (307068 bytes)
[11:01:01.031] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 299.87 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (299.84 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.032] - globals: [2] ‘x’, ‘i’
[11:01:01.032] 
[11:01:01.032] getGlobalsAndPackages() ... DONE
[11:01:01.032] getGlobalsAndPackages() ...
[11:01:01.032] Searching for globals...
[11:01:01.034] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.034] Searching for globals ... DONE
[11:01:01.034] Resolving globals: FALSE
[11:01:01.035] The total size of the 2 globals is 318.91 KiB (326561 bytes)
[11:01:01.036] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 318.91 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (318.87 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.036] - globals: [2] ‘x’, ‘i’
[11:01:01.036] 
[11:01:01.036] getGlobalsAndPackages() ... DONE
[11:01:01.036] getGlobalsAndPackages() ...
[11:01:01.036] Searching for globals...
[11:01:01.038] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.038] Searching for globals ... DONE
[11:01:01.038] Resolving globals: FALSE
[11:01:01.040] The total size of the 2 globals is 337.97 KiB (346086 bytes)
[11:01:01.040] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 337.97 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (337.94 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.040] - globals: [2] ‘x’, ‘i’
[11:01:01.040] 
[11:01:01.040] getGlobalsAndPackages() ... DONE
[11:01:01.041] getGlobalsAndPackages() ...
[11:01:01.041] Searching for globals...
[11:01:01.042] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.042] Searching for globals ... DONE
[11:01:01.043] Resolving globals: FALSE
[11:01:01.044] The total size of the 2 globals is 357.01 KiB (365579 bytes)
[11:01:01.046] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 357.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (356.98 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.046] - globals: [2] ‘x’, ‘i’
[11:01:01.046] 
[11:01:01.046] getGlobalsAndPackages() ... DONE
[11:01:01.046] getGlobalsAndPackages() ...
[11:01:01.046] Searching for globals...
[11:01:01.048] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.048] Searching for globals ... DONE
[11:01:01.048] Resolving globals: FALSE
[11:01:01.050] The total size of the 2 globals is 376.05 KiB (385072 bytes)
[11:01:01.050] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 376.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (376.01 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.050] - globals: [2] ‘x’, ‘i’
[11:01:01.050] 
[11:01:01.050] getGlobalsAndPackages() ... DONE
[11:01:01.051] getGlobalsAndPackages() ...
[11:01:01.051] Searching for globals...
[11:01:01.052] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.052] Searching for globals ... DONE
[11:01:01.053] Resolving globals: FALSE
[11:01:01.054] The total size of the 2 globals is 395.08 KiB (404565 bytes)
[11:01:01.055] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 395.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (395.05 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.055] - globals: [2] ‘x’, ‘i’
[11:01:01.055] 
[11:01:01.055] getGlobalsAndPackages() ... DONE
[11:01:01.055] getGlobalsAndPackages() ...
[11:01:01.055] Searching for globals...
[11:01:01.057] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.057] Searching for globals ... DONE
[11:01:01.057] Resolving globals: FALSE
[11:01:01.059] The total size of the 2 globals is 414.12 KiB (424058 bytes)
[11:01:01.059] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 414.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (414.08 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.059] - globals: [2] ‘x’, ‘i’
[11:01:01.059] 
[11:01:01.060] getGlobalsAndPackages() ... DONE
[11:01:01.060] getGlobalsAndPackages() ...
[11:01:01.060] Searching for globals...
[11:01:01.061] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.062] Searching for globals ... DONE
[11:01:01.062] Resolving globals: FALSE
[11:01:01.064] The total size of the 2 globals is 433.19 KiB (443587 bytes)
[11:01:01.064] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 433.19 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (433.16 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.064] - globals: [2] ‘x’, ‘i’
[11:01:01.064] 
[11:01:01.064] getGlobalsAndPackages() ... DONE
[11:01:01.065] getGlobalsAndPackages() ...
[11:01:01.065] Searching for globals...
[11:01:01.066] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.066] Searching for globals ... DONE
[11:01:01.066] Resolving globals: FALSE
[11:01:01.069] The total size of the 2 globals is 452.23 KiB (463080 bytes)
[11:01:01.069] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 452.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (452.19 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.069] - globals: [2] ‘x’, ‘i’
[11:01:01.069] 
[11:01:01.069] getGlobalsAndPackages() ... DONE
[11:01:01.070] getGlobalsAndPackages() ...
[11:01:01.070] Searching for globals...
[11:01:01.072] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.072] Searching for globals ... DONE
[11:01:01.072] Resolving globals: FALSE
[11:01:01.074] The total size of the 2 globals is 471.26 KiB (482573 bytes)
[11:01:01.075] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 471.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (471.23 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.075] - globals: [2] ‘x’, ‘i’
[11:01:01.075] 
[11:01:01.075] getGlobalsAndPackages() ... DONE
[11:01:01.076] getGlobalsAndPackages() ...
[11:01:01.076] Searching for globals...
[11:01:01.077] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.077] Searching for globals ... DONE
[11:01:01.077] Resolving globals: FALSE
[11:01:01.079] The total size of the 2 globals is 490.30 KiB (502066 bytes)
[11:01:01.080] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 490.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (490.26 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.080] - globals: [2] ‘x’, ‘i’
[11:01:01.080] 
[11:01:01.080] getGlobalsAndPackages() ... DONE
[11:01:01.080] getGlobalsAndPackages() ...
[11:01:01.081] Searching for globals...
[11:01:01.082] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.082] Searching for globals ... DONE
[11:01:01.082] Resolving globals: FALSE
[11:01:01.084] The total size of the 2 globals is 509.33 KiB (521559 bytes)
[11:01:01.085] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 509.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (509.30 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.085] - globals: [2] ‘x’, ‘i’
[11:01:01.085] 
[11:01:01.085] getGlobalsAndPackages() ... DONE
[11:01:01.085] getGlobalsAndPackages() ...
[11:01:01.085] Searching for globals...
[11:01:01.087] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.087] Searching for globals ... DONE
[11:01:01.087] Resolving globals: FALSE
[11:01:01.089] The total size of the 2 globals is 528.37 KiB (541052 bytes)
[11:01:01.090] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 528.37 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (528.34 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.090] - globals: [2] ‘x’, ‘i’
[11:01:01.090] 
[11:01:01.090] getGlobalsAndPackages() ... DONE
[11:01:01.090] getGlobalsAndPackages() ...
[11:01:01.090] Searching for globals...
[11:01:01.092] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.092] Searching for globals ... DONE
[11:01:01.092] Resolving globals: FALSE
[11:01:01.095] The total size of the 2 globals is 547.41 KiB (560545 bytes)
[11:01:01.095] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 547.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (547.37 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.095] - globals: [2] ‘x’, ‘i’
[11:01:01.095] 
[11:01:01.095] getGlobalsAndPackages() ... DONE
[11:01:01.096] getGlobalsAndPackages() ...
[11:01:01.096] Searching for globals...
[11:01:01.097] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.098] Searching for globals ... DONE
[11:01:01.098] Resolving globals: FALSE
[11:01:01.101] The total size of the 2 globals is 566.44 KiB (580038 bytes)
[11:01:01.101] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 566.44 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (566.41 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.102] - globals: [2] ‘x’, ‘i’
[11:01:01.102] 
[11:01:01.102] getGlobalsAndPackages() ... DONE
[11:01:01.102] getGlobalsAndPackages() ...
[11:01:01.102] Searching for globals...
[11:01:01.104] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.104] Searching for globals ... DONE
[11:01:01.104] Resolving globals: FALSE
[11:01:01.106] The total size of the 2 globals is 585.48 KiB (599531 bytes)
[11:01:01.107] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 585.48 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (585.45 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.107] - globals: [2] ‘x’, ‘i’
[11:01:01.107] 
[11:01:01.107] getGlobalsAndPackages() ... DONE
[11:01:01.107] getGlobalsAndPackages() ...
[11:01:01.107] Searching for globals...
[11:01:01.109] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.109] Searching for globals ... DONE
[11:01:01.109] Resolving globals: FALSE
[11:01:01.112] The total size of the 2 globals is 604.52 KiB (619024 bytes)
[11:01:01.112] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 604.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (604.48 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.112] - globals: [2] ‘x’, ‘i’
[11:01:01.112] 
[11:01:01.112] getGlobalsAndPackages() ... DONE
[11:01:01.113] getGlobalsAndPackages() ...
[11:01:01.113] Searching for globals...
[11:01:01.114] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.114] Searching for globals ... DONE
[11:01:01.114] Resolving globals: FALSE
[11:01:01.117] The total size of the 2 globals is 623.55 KiB (638517 bytes)
[11:01:01.117] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 623.55 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (623.52 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.117] - globals: [2] ‘x’, ‘i’
[11:01:01.117] 
[11:01:01.117] getGlobalsAndPackages() ... DONE
[11:01:01.118] getGlobalsAndPackages() ...
[11:01:01.118] Searching for globals...
[11:01:01.119] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.119] Searching for globals ... DONE
[11:01:01.120] Resolving globals: FALSE
[11:01:01.122] The total size of the 2 globals is 642.59 KiB (658010 bytes)
[11:01:01.123] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 642.59 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (642.55 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.123] - globals: [2] ‘x’, ‘i’
[11:01:01.123] 
[11:01:01.123] getGlobalsAndPackages() ... DONE
[11:01:01.124] getGlobalsAndPackages() ...
[11:01:01.124] Searching for globals...
[11:01:01.125] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.125] Searching for globals ... DONE
[11:01:01.125] Resolving globals: FALSE
[11:01:01.129] The total size of the 2 globals is 661.62 KiB (677503 bytes)
[11:01:01.129] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 661.62 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (661.59 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.129] - globals: [2] ‘x’, ‘i’
[11:01:01.130] 
[11:01:01.130] getGlobalsAndPackages() ... DONE
[11:01:01.130] getGlobalsAndPackages() ...
[11:01:01.130] Searching for globals...
[11:01:01.132] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.132] Searching for globals ... DONE
[11:01:01.132] Resolving globals: FALSE
[11:01:01.134] The total size of the 2 globals is 680.66 KiB (696996 bytes)
[11:01:01.135] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 680.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (680.63 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.135] - globals: [2] ‘x’, ‘i’
[11:01:01.135] 
[11:01:01.135] getGlobalsAndPackages() ... DONE
[11:01:01.136] getGlobalsAndPackages() ...
[11:01:01.136] Searching for globals...
[11:01:01.137] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.137] Searching for globals ... DONE
[11:01:01.137] Resolving globals: FALSE
[11:01:01.140] The total size of the 2 globals is 699.70 KiB (716489 bytes)
[11:01:01.140] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 699.70 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (699.66 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.140] - globals: [2] ‘x’, ‘i’
[11:01:01.141] 
[11:01:01.141] getGlobalsAndPackages() ... DONE
[11:01:01.141] getGlobalsAndPackages() ...
[11:01:01.141] Searching for globals...
[11:01:01.143] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.143] Searching for globals ... DONE
[11:01:01.143] Resolving globals: FALSE
[11:01:01.146] The total size of the 2 globals is 718.73 KiB (735982 bytes)
[11:01:01.146] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 718.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (718.70 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.146] - globals: [2] ‘x’, ‘i’
[11:01:01.146] 
[11:01:01.146] getGlobalsAndPackages() ... DONE
[11:01:01.147] getGlobalsAndPackages() ...
[11:01:01.147] Searching for globals...
[11:01:01.148] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.148] Searching for globals ... DONE
[11:01:01.148] Resolving globals: FALSE
[11:01:01.152] The total size of the 2 globals is 737.81 KiB (755519 bytes)
[11:01:01.152] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 737.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (737.78 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.152] - globals: [2] ‘x’, ‘i’
[11:01:01.152] 
[11:01:01.152] getGlobalsAndPackages() ... DONE
[11:01:01.153] getGlobalsAndPackages() ...
[11:01:01.153] Searching for globals...
[11:01:01.155] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.155] Searching for globals ... DONE
[11:01:01.155] Resolving globals: FALSE
[11:01:01.160] The total size of the 2 globals is 756.85 KiB (775012 bytes)
[11:01:01.161] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 756.85 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (756.81 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.161] - globals: [2] ‘x’, ‘i’
[11:01:01.161] 
[11:01:01.161] getGlobalsAndPackages() ... DONE
[11:01:01.162] getGlobalsAndPackages() ...
[11:01:01.162] Searching for globals...
[11:01:01.164] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.164] Searching for globals ... DONE
[11:01:01.164] Resolving globals: FALSE
[11:01:01.167] The total size of the 2 globals is 775.88 KiB (794505 bytes)
[11:01:01.168] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 775.88 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (775.85 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.168] - globals: [2] ‘x’, ‘i’
[11:01:01.168] 
[11:01:01.168] getGlobalsAndPackages() ... DONE
[11:01:01.168] getGlobalsAndPackages() ...
[11:01:01.168] Searching for globals...
[11:01:01.170] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.170] Searching for globals ... DONE
[11:01:01.170] Resolving globals: FALSE
[11:01:01.173] The total size of the 2 globals is 794.97 KiB (814050 bytes)
[11:01:01.174] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 794.97 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (794.94 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.174] - globals: [2] ‘x’, ‘i’
[11:01:01.174] 
[11:01:01.174] getGlobalsAndPackages() ... DONE
[11:01:01.174] getGlobalsAndPackages() ...
[11:01:01.174] Searching for globals...
[11:01:01.176] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.176] Searching for globals ... DONE
[11:01:01.176] Resolving globals: FALSE
[11:01:01.179] The total size of the 2 globals is 814.01 KiB (833543 bytes)
[11:01:01.180] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 814.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (813.97 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.180] - globals: [2] ‘x’, ‘i’
[11:01:01.180] 
[11:01:01.180] getGlobalsAndPackages() ... DONE
[11:01:01.180] getGlobalsAndPackages() ...
[11:01:01.180] Searching for globals...
[11:01:01.182] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.182] Searching for globals ... DONE
[11:01:01.182] Resolving globals: FALSE
[11:01:01.186] The total size of the 2 globals is 833.04 KiB (853036 bytes)
[11:01:01.188] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 833.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (833.01 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.188] - globals: [2] ‘x’, ‘i’
[11:01:01.189] 
[11:01:01.189] getGlobalsAndPackages() ... DONE
[11:01:01.189] getGlobalsAndPackages() ...
[11:01:01.189] Searching for globals...
[11:01:01.192] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.192] Searching for globals ... DONE
[11:01:01.192] Resolving globals: FALSE
[11:01:01.197] The total size of the 2 globals is 852.08 KiB (872529 bytes)
[11:01:01.197] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 852.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (852.04 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.197] - globals: [2] ‘x’, ‘i’
[11:01:01.198] 
[11:01:01.198] getGlobalsAndPackages() ... DONE
[11:01:01.198] getGlobalsAndPackages() ...
[11:01:01.199] Searching for globals...
[11:01:01.201] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.201] Searching for globals ... DONE
[11:01:01.201] Resolving globals: FALSE
[11:01:01.206] The total size of the 2 globals is 871.12 KiB (892022 bytes)
[11:01:01.207] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 871.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (871.08 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.207] - globals: [2] ‘x’, ‘i’
[11:01:01.207] 
[11:01:01.207] getGlobalsAndPackages() ... DONE
[11:01:01.208] getGlobalsAndPackages() ...
[11:01:01.208] Searching for globals...
[11:01:01.210] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.210] Searching for globals ... DONE
[11:01:01.210] Resolving globals: FALSE
[11:01:01.216] The total size of the 2 globals is 890.15 KiB (911515 bytes)
[11:01:01.216] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 890.15 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (890.12 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.216] - globals: [2] ‘x’, ‘i’
[11:01:01.216] 
[11:01:01.216] getGlobalsAndPackages() ... DONE
[11:01:01.217] getGlobalsAndPackages() ...
[11:01:01.217] Searching for globals...
[11:01:01.219] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.219] Searching for globals ... DONE
[11:01:01.219] Resolving globals: FALSE
[11:01:01.225] The total size of the 2 globals is 909.19 KiB (931008 bytes)
[11:01:01.225] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 909.19 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (909.15 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.225] - globals: [2] ‘x’, ‘i’
[11:01:01.226] 
[11:01:01.226] getGlobalsAndPackages() ... DONE
[11:01:01.226] getGlobalsAndPackages() ...
[11:01:01.227] Searching for globals...
[11:01:01.231] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.231] Searching for globals ... DONE
[11:01:01.231] Resolving globals: FALSE
[11:01:01.238] The total size of the 2 globals is 928.22 KiB (950501 bytes)
[11:01:01.238] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 928.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (928.19 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.238] - globals: [2] ‘x’, ‘i’
[11:01:01.238] 
[11:01:01.239] getGlobalsAndPackages() ... DONE
[11:01:01.239] getGlobalsAndPackages() ...
[11:01:01.239] Searching for globals...
[11:01:01.242] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.242] Searching for globals ... DONE
[11:01:01.242] Resolving globals: FALSE
[11:01:01.248] The total size of the 2 globals is 947.26 KiB (969994 bytes)
[11:01:01.249] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 947.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (947.23 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.249] - globals: [2] ‘x’, ‘i’
[11:01:01.250] 
[11:01:01.250] getGlobalsAndPackages() ... DONE
[11:01:01.251] getGlobalsAndPackages() ...
[11:01:01.251] Searching for globals...
[11:01:01.254] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.254] Searching for globals ... DONE
[11:01:01.254] Resolving globals: FALSE
[11:01:01.258] The total size of the 2 globals is 966.30 KiB (989487 bytes)
[11:01:01.258] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 966.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (966.26 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.258] - globals: [2] ‘x’, ‘i’
[11:01:01.258] 
[11:01:01.258] getGlobalsAndPackages() ... DONE
[11:01:01.259] getGlobalsAndPackages() ...
[11:01:01.259] Searching for globals...
[11:01:01.260] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.261] Searching for globals ... DONE
[11:01:01.261] Resolving globals: FALSE
[11:01:01.265] The total size of the 2 globals is 985.33 KiB (1008980 bytes)
[11:01:01.265] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 985.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (985.30 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.265] - globals: [2] ‘x’, ‘i’
[11:01:01.265] 
[11:01:01.265] getGlobalsAndPackages() ... DONE
[11:01:01.266] getGlobalsAndPackages() ...
[11:01:01.266] Searching for globals...
[11:01:01.269] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.269] Searching for globals ... DONE
[11:01:01.269] Resolving globals: FALSE
[11:01:01.273] The total size of the 2 globals is 0.98 MiB (1028473 bytes)
[11:01:01.274] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 0.98 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (0.98 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.274] - globals: [2] ‘x’, ‘i’
[11:01:01.274] 
[11:01:01.274] getGlobalsAndPackages() ... DONE
[11:01:01.275] getGlobalsAndPackages() ...
[11:01:01.275] Searching for globals...
[11:01:01.276] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.276] Searching for globals ... DONE
[11:01:01.276] Resolving globals: FALSE
[11:01:01.280] The total size of the 2 globals is 1.00 MiB (1047966 bytes)
[11:01:01.281] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.00 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.00 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.281] - globals: [2] ‘x’, ‘i’
[11:01:01.281] 
[11:01:01.281] getGlobalsAndPackages() ... DONE
[11:01:01.282] getGlobalsAndPackages() ...
[11:01:01.282] Searching for globals...
[11:01:01.283] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.283] Searching for globals ... DONE
[11:01:01.283] Resolving globals: FALSE
[11:01:01.287] The total size of the 2 globals is 1.02 MiB (1067459 bytes)
[11:01:01.288] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.02 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.02 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.288] - globals: [2] ‘x’, ‘i’
[11:01:01.288] 
[11:01:01.288] getGlobalsAndPackages() ... DONE
[11:01:01.289] getGlobalsAndPackages() ...
[11:01:01.289] Searching for globals...
[11:01:01.290] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.290] Searching for globals ... DONE
[11:01:01.290] Resolving globals: FALSE
[11:01:01.295] The total size of the 2 globals is 1.04 MiB (1086952 bytes)
[11:01:01.295] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.04 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.04 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.295] - globals: [2] ‘x’, ‘i’
[11:01:01.295] 
[11:01:01.295] getGlobalsAndPackages() ... DONE
[11:01:01.296] getGlobalsAndPackages() ...
[11:01:01.296] Searching for globals...
[11:01:01.297] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.299] Searching for globals ... DONE
[11:01:01.299] Resolving globals: FALSE
[11:01:01.303] The total size of the 2 globals is 1.06 MiB (1106445 bytes)
[11:01:01.304] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.06 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.06 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.304] - globals: [2] ‘x’, ‘i’
[11:01:01.304] 
[11:01:01.304] getGlobalsAndPackages() ... DONE
[11:01:01.304] getGlobalsAndPackages() ...
[11:01:01.304] Searching for globals...
[11:01:01.306] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.306] Searching for globals ... DONE
[11:01:01.306] Resolving globals: FALSE
[11:01:01.310] The total size of the 2 globals is 1.07 MiB (1125938 bytes)
[11:01:01.311] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.07 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.07 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.311] - globals: [2] ‘x’, ‘i’
[11:01:01.311] 
[11:01:01.311] getGlobalsAndPackages() ... DONE
[11:01:01.311] getGlobalsAndPackages() ...
[11:01:01.312] Searching for globals...
[11:01:01.313] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.313] Searching for globals ... DONE
[11:01:01.313] Resolving globals: FALSE
[11:01:01.317] The total size of the 2 globals is 1.09 MiB (1145431 bytes)
[11:01:01.318] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.09 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.09 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.318] - globals: [2] ‘x’, ‘i’
[11:01:01.318] 
[11:01:01.318] getGlobalsAndPackages() ... DONE
[11:01:01.319] getGlobalsAndPackages() ...
[11:01:01.319] Searching for globals...
[11:01:01.320] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.320] Searching for globals ... DONE
[11:01:01.320] Resolving globals: FALSE
[11:01:01.325] The total size of the 2 globals is 1.11 MiB (1164924 bytes)
[11:01:01.325] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.11 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.11 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.325] - globals: [2] ‘x’, ‘i’
[11:01:01.325] 
[11:01:01.326] getGlobalsAndPackages() ... DONE
[11:01:01.326] getGlobalsAndPackages() ...
[11:01:01.326] Searching for globals...
[11:01:01.329] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.329] Searching for globals ... DONE
[11:01:01.329] Resolving globals: FALSE
[11:01:01.334] The total size of the 2 globals is 1.13 MiB (1184417 bytes)
[11:01:01.334] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.13 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.13 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.334] - globals: [2] ‘x’, ‘i’
[11:01:01.334] 
[11:01:01.334] getGlobalsAndPackages() ... DONE
[11:01:01.335] getGlobalsAndPackages() ...
[11:01:01.335] Searching for globals...
[11:01:01.336] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.336] Searching for globals ... DONE
[11:01:01.336] Resolving globals: FALSE
[11:01:01.341] The total size of the 2 globals is 1.15 MiB (1203910 bytes)
[11:01:01.341] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.15 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.15 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.341] - globals: [2] ‘x’, ‘i’
[11:01:01.341] 
[11:01:01.342] getGlobalsAndPackages() ... DONE
[11:01:01.342] getGlobalsAndPackages() ...
[11:01:01.342] Searching for globals...
[11:01:01.344] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.344] Searching for globals ... DONE
[11:01:01.344] Resolving globals: FALSE
[11:01:01.348] The total size of the 2 globals is 1.17 MiB (1223403 bytes)
[11:01:01.349] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.17 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.17 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.349] - globals: [2] ‘x’, ‘i’
[11:01:01.349] 
[11:01:01.349] getGlobalsAndPackages() ... DONE
[11:01:01.349] getGlobalsAndPackages() ...
[11:01:01.349] Searching for globals...
[11:01:01.351] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.351] Searching for globals ... DONE
[11:01:01.351] Resolving globals: FALSE
[11:01:01.356] The total size of the 2 globals is 1.19 MiB (1242896 bytes)
[11:01:01.356] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.19 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.19 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.356] - globals: [2] ‘x’, ‘i’
[11:01:01.357] 
[11:01:01.357] getGlobalsAndPackages() ... DONE
[11:01:01.358] getGlobalsAndPackages() ...
[11:01:01.358] Searching for globals...
[11:01:01.360] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.360] Searching for globals ... DONE
[11:01:01.360] Resolving globals: FALSE
[11:01:01.365] The total size of the 2 globals is 1.20 MiB (1262453 bytes)
[11:01:01.365] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.20 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.20 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.365] - globals: [2] ‘x’, ‘i’
[11:01:01.365] 
[11:01:01.365] getGlobalsAndPackages() ... DONE
[11:01:01.366] getGlobalsAndPackages() ...
[11:01:01.366] Searching for globals...
[11:01:01.367] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.367] Searching for globals ... DONE
[11:01:01.368] Resolving globals: FALSE
[11:01:01.372] The total size of the 2 globals is 1.22 MiB (1281946 bytes)
[11:01:01.373] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.22 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.22 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.373] - globals: [2] ‘x’, ‘i’
[11:01:01.373] 
[11:01:01.373] getGlobalsAndPackages() ... DONE
[11:01:01.373] getGlobalsAndPackages() ...
[11:01:01.373] Searching for globals...
[11:01:01.375] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.375] Searching for globals ... DONE
[11:01:01.375] Resolving globals: FALSE
[11:01:01.380] The total size of the 2 globals is 1.24 MiB (1301439 bytes)
[11:01:01.380] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.24 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.24 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.380] - globals: [2] ‘x’, ‘i’
[11:01:01.380] 
[11:01:01.380] getGlobalsAndPackages() ... DONE
[11:01:01.381] getGlobalsAndPackages() ...
[11:01:01.381] Searching for globals...
[11:01:01.382] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.382] Searching for globals ... DONE
[11:01:01.382] Resolving globals: FALSE
[11:01:01.388] The total size of the 2 globals is 1.26 MiB (1320932 bytes)
[11:01:01.389] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.26 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.26 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.389] - globals: [2] ‘x’, ‘i’
[11:01:01.389] 
[11:01:01.389] getGlobalsAndPackages() ... DONE
[11:01:01.389] getGlobalsAndPackages() ...
[11:01:01.390] Searching for globals...
[11:01:01.391] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.391] Searching for globals ... DONE
[11:01:01.391] Resolving globals: FALSE
[11:01:01.396] The total size of the 2 globals is 1.28 MiB (1340425 bytes)
[11:01:01.396] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.28 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.28 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.396] - globals: [2] ‘x’, ‘i’
[11:01:01.397] 
[11:01:01.397] getGlobalsAndPackages() ... DONE
[11:01:01.397] getGlobalsAndPackages() ...
[11:01:01.397] Searching for globals...
[11:01:01.399] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.399] Searching for globals ... DONE
[11:01:01.399] Resolving globals: FALSE
[11:01:01.404] The total size of the 2 globals is 1.30 MiB (1359918 bytes)
[11:01:01.404] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.30 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.30 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.404] - globals: [2] ‘x’, ‘i’
[11:01:01.404] 
[11:01:01.404] getGlobalsAndPackages() ... DONE
[11:01:01.405] getGlobalsAndPackages() ...
[11:01:01.405] Searching for globals...
[11:01:01.406] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.406] Searching for globals ... DONE
[11:01:01.407] Resolving globals: FALSE
[11:01:01.412] The total size of the 2 globals is 1.32 MiB (1379411 bytes)
[11:01:01.412] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.32 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.32 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.412] - globals: [2] ‘x’, ‘i’
[11:01:01.412] 
[11:01:01.412] getGlobalsAndPackages() ... DONE
[11:01:01.413] getGlobalsAndPackages() ...
[11:01:01.413] Searching for globals...
[11:01:01.415] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.415] Searching for globals ... DONE
[11:01:01.416] Resolving globals: FALSE
[11:01:01.421] The total size of the 2 globals is 1.33 MiB (1398904 bytes)
[11:01:01.421] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.33 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.33 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.421] - globals: [2] ‘x’, ‘i’
[11:01:01.421] 
[11:01:01.421] getGlobalsAndPackages() ... DONE
[11:01:01.422] getGlobalsAndPackages() ...
[11:01:01.422] Searching for globals...
[11:01:01.423] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.423] Searching for globals ... DONE
[11:01:01.423] Resolving globals: FALSE
[11:01:01.429] The total size of the 2 globals is 1.35 MiB (1418397 bytes)
[11:01:01.429] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.35 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.35 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.429] - globals: [2] ‘x’, ‘i’
[11:01:01.429] 
[11:01:01.429] getGlobalsAndPackages() ... DONE
[11:01:01.430] getGlobalsAndPackages() ...
[11:01:01.430] Searching for globals...
[11:01:01.431] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.431] Searching for globals ... DONE
[11:01:01.431] Resolving globals: FALSE
[11:01:01.437] The total size of the 2 globals is 1.37 MiB (1437890 bytes)
[11:01:01.437] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.37 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.37 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.437] - globals: [2] ‘x’, ‘i’
[11:01:01.437] 
[11:01:01.437] getGlobalsAndPackages() ... DONE
[11:01:01.438] getGlobalsAndPackages() ...
[11:01:01.438] Searching for globals...
[11:01:01.439] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.439] Searching for globals ... DONE
[11:01:01.439] Resolving globals: FALSE
[11:01:01.446] The total size of the 2 globals is 1.39 MiB (1457383 bytes)
[11:01:01.446] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.39 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.39 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.446] - globals: [2] ‘x’, ‘i’
[11:01:01.446] 
[11:01:01.446] getGlobalsAndPackages() ... DONE
[11:01:01.447] getGlobalsAndPackages() ...
[11:01:01.447] Searching for globals...
[11:01:01.448] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.449] Searching for globals ... DONE
[11:01:01.449] Resolving globals: FALSE
[11:01:01.454] The total size of the 2 globals is 1.41 MiB (1476876 bytes)
[11:01:01.454] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.41 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.41 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.454] - globals: [2] ‘x’, ‘i’
[11:01:01.455] 
[11:01:01.455] getGlobalsAndPackages() ... DONE
[11:01:01.455] getGlobalsAndPackages() ...
[11:01:01.455] Searching for globals...
[11:01:01.457] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.457] Searching for globals ... DONE
[11:01:01.457] Resolving globals: FALSE
[11:01:01.462] The total size of the 2 globals is 1.43 MiB (1496369 bytes)
[11:01:01.462] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.43 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.43 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.463] - globals: [2] ‘x’, ‘i’
[11:01:01.463] 
[11:01:01.463] getGlobalsAndPackages() ... DONE
[11:01:01.463] getGlobalsAndPackages() ...
[11:01:01.463] Searching for globals...
[11:01:01.465] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.465] Searching for globals ... DONE
[11:01:01.465] Resolving globals: FALSE
[11:01:01.471] The total size of the 2 globals is 1.45 MiB (1515862 bytes)
[11:01:01.472] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.45 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.45 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.472] - globals: [2] ‘x’, ‘i’
[11:01:01.473] 
[11:01:01.473] getGlobalsAndPackages() ... DONE
[11:01:01.474] getGlobalsAndPackages() ...
[11:01:01.474] Searching for globals...
[11:01:01.475] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.475] Searching for globals ... DONE
[11:01:01.475] Resolving globals: FALSE
[11:01:01.481] The total size of the 2 globals is 1.46 MiB (1535355 bytes)
[11:01:01.482] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.46 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.46 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.482] - globals: [2] ‘x’, ‘i’
[11:01:01.482] 
[11:01:01.482] getGlobalsAndPackages() ... DONE
[11:01:01.482] getGlobalsAndPackages() ...
[11:01:01.482] Searching for globals...
[11:01:01.484] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.484] Searching for globals ... DONE
[11:01:01.484] Resolving globals: FALSE
[11:01:01.490] The total size of the 2 globals is 1.48 MiB (1554848 bytes)
[11:01:01.490] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.48 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.48 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.490] - globals: [2] ‘x’, ‘i’
[11:01:01.490] 
[11:01:01.490] getGlobalsAndPackages() ... DONE
[11:01:01.491] getGlobalsAndPackages() ...
[11:01:01.491] Searching for globals...
[11:01:01.492] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.492] Searching for globals ... DONE
[11:01:01.493] Resolving globals: FALSE
[11:01:01.498] The total size of the 2 globals is 1.50 MiB (1574341 bytes)
[11:01:01.499] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.50 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.50 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.499] - globals: [2] ‘x’, ‘i’
[11:01:01.499] 
[11:01:01.499] getGlobalsAndPackages() ... DONE
[11:01:01.499] getGlobalsAndPackages() ...
[11:01:01.499] Searching for globals...
[11:01:01.523] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.524] Searching for globals ... DONE
[11:01:01.524] Resolving globals: FALSE
[11:01:01.530] The total size of the 2 globals is 1.52 MiB (1593834 bytes)
[11:01:01.530] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.52 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.52 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.530] - globals: [2] ‘x’, ‘i’
[11:01:01.530] 
[11:01:01.530] getGlobalsAndPackages() ... DONE
[11:01:01.531] getGlobalsAndPackages() ...
[11:01:01.531] Searching for globals...
[11:01:01.532] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.533] Searching for globals ... DONE
[11:01:01.533] Resolving globals: FALSE
[11:01:01.539] The total size of the 2 globals is 1.54 MiB (1613327 bytes)
[11:01:01.539] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.54 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.54 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.539] - globals: [2] ‘x’, ‘i’
[11:01:01.539] 
[11:01:01.539] getGlobalsAndPackages() ... DONE
[11:01:01.540] getGlobalsAndPackages() ...
[11:01:01.540] Searching for globals...
[11:01:01.541] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.541] Searching for globals ... DONE
[11:01:01.542] Resolving globals: FALSE
[11:01:01.547] The total size of the 2 globals is 1.56 MiB (1632820 bytes)
[11:01:01.548] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.56 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.56 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.548] - globals: [2] ‘x’, ‘i’
[11:01:01.548] 
[11:01:01.548] getGlobalsAndPackages() ... DONE
[11:01:01.549] getGlobalsAndPackages() ...
[11:01:01.549] Searching for globals...
[11:01:01.550] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.550] Searching for globals ... DONE
[11:01:01.550] Resolving globals: FALSE
[11:01:01.558] The total size of the 2 globals is 1.58 MiB (1652313 bytes)
[11:01:01.558] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.58 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.58 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.558] - globals: [2] ‘x’, ‘i’
[11:01:01.558] 
[11:01:01.558] getGlobalsAndPackages() ... DONE
[11:01:01.559] getGlobalsAndPackages() ...
[11:01:01.559] Searching for globals...
[11:01:01.560] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.561] Searching for globals ... DONE
[11:01:01.561] Resolving globals: FALSE
[11:01:01.567] The total size of the 2 globals is 1.59 MiB (1671806 bytes)
[11:01:01.567] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.59 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.59 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.567] - globals: [2] ‘x’, ‘i’
[11:01:01.567] 
[11:01:01.567] getGlobalsAndPackages() ... DONE
[11:01:01.568] getGlobalsAndPackages() ...
[11:01:01.568] Searching for globals...
[11:01:01.569] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.569] Searching for globals ... DONE
[11:01:01.570] Resolving globals: FALSE
[11:01:01.576] The total size of the 2 globals is 1.61 MiB (1691299 bytes)
[11:01:01.576] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.61 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.61 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.576] - globals: [2] ‘x’, ‘i’
[11:01:01.576] 
[11:01:01.576] getGlobalsAndPackages() ... DONE
[11:01:01.577] getGlobalsAndPackages() ...
[11:01:01.577] Searching for globals...
[11:01:01.578] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.579] Searching for globals ... DONE
[11:01:01.579] Resolving globals: FALSE
[11:01:01.586] The total size of the 2 globals is 1.63 MiB (1710792 bytes)
[11:01:01.587] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.63 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.63 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.587] - globals: [2] ‘x’, ‘i’
[11:01:01.587] 
[11:01:01.587] getGlobalsAndPackages() ... DONE
[11:01:01.588] getGlobalsAndPackages() ...
[11:01:01.588] Searching for globals...
[11:01:01.589] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.589] Searching for globals ... DONE
[11:01:01.589] Resolving globals: FALSE
[11:01:01.596] The total size of the 2 globals is 1.65 MiB (1730285 bytes)
[11:01:01.596] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.65 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.65 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.596] - globals: [2] ‘x’, ‘i’
[11:01:01.596] 
[11:01:01.597] getGlobalsAndPackages() ... DONE
[11:01:01.597] getGlobalsAndPackages() ...
[11:01:01.597] Searching for globals...
[11:01:01.598] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.599] Searching for globals ... DONE
[11:01:01.599] Resolving globals: FALSE
[11:01:01.605] The total size of the 2 globals is 1.67 MiB (1749778 bytes)
[11:01:01.605] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.67 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.67 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.606] - globals: [2] ‘x’, ‘i’
[11:01:01.606] 
[11:01:01.606] getGlobalsAndPackages() ... DONE
[11:01:01.606] getGlobalsAndPackages() ...
[11:01:01.606] Searching for globals...
[11:01:01.608] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.608] Searching for globals ... DONE
[11:01:01.608] Resolving globals: FALSE
[11:01:01.614] The total size of the 2 globals is 1.69 MiB (1769271 bytes)
[11:01:01.615] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.69 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.69 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.615] - globals: [2] ‘x’, ‘i’
[11:01:01.615] 
[11:01:01.615] getGlobalsAndPackages() ... DONE
[11:01:01.615] getGlobalsAndPackages() ...
[11:01:01.615] Searching for globals...
[11:01:01.618] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.618] Searching for globals ... DONE
[11:01:01.618] Resolving globals: FALSE
[11:01:01.624] The total size of the 2 globals is 1.71 MiB (1788764 bytes)
[11:01:01.625] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.71 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.71 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.625] - globals: [2] ‘x’, ‘i’
[11:01:01.625] 
[11:01:01.625] getGlobalsAndPackages() ... DONE
[11:01:01.626] getGlobalsAndPackages() ...
[11:01:01.626] Searching for globals...
[11:01:01.627] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.627] Searching for globals ... DONE
[11:01:01.627] Resolving globals: FALSE
[11:01:01.634] The total size of the 2 globals is 1.72 MiB (1808425 bytes)
[11:01:01.634] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.72 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.72 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.634] - globals: [2] ‘x’, ‘i’
[11:01:01.635] 
[11:01:01.635] getGlobalsAndPackages() ... DONE
[11:01:01.635] getGlobalsAndPackages() ...
[11:01:01.635] Searching for globals...
[11:01:01.637] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.637] Searching for globals ... DONE
[11:01:01.637] Resolving globals: FALSE
[11:01:01.643] The total size of the 2 globals is 1.74 MiB (1827918 bytes)
[11:01:01.644] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.74 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.74 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.644] - globals: [2] ‘x’, ‘i’
[11:01:01.644] 
[11:01:01.644] getGlobalsAndPackages() ... DONE
[11:01:01.644] getGlobalsAndPackages() ...
[11:01:01.645] Searching for globals...
[11:01:01.646] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.647] Searching for globals ... DONE
[11:01:01.647] Resolving globals: FALSE
[11:01:01.654] The total size of the 2 globals is 1.76 MiB (1847411 bytes)
[11:01:01.654] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.76 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.76 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.654] - globals: [2] ‘x’, ‘i’
[11:01:01.654] 
[11:01:01.655] getGlobalsAndPackages() ... DONE
[11:01:01.655] getGlobalsAndPackages() ...
[11:01:01.655] Searching for globals...
[11:01:01.657] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.657] Searching for globals ... DONE
[11:01:01.657] Resolving globals: FALSE
[11:01:01.663] The total size of the 2 globals is 1.78 MiB (1866904 bytes)
[11:01:01.664] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.78 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.78 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.664] - globals: [2] ‘x’, ‘i’
[11:01:01.664] 
[11:01:01.664] getGlobalsAndPackages() ... DONE
[11:01:01.665] getGlobalsAndPackages() ...
[11:01:01.665] Searching for globals...
[11:01:01.666] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.666] Searching for globals ... DONE
[11:01:01.666] Resolving globals: FALSE
[11:01:01.673] The total size of the 2 globals is 1.80 MiB (1886397 bytes)
[11:01:01.674] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.80 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.80 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.674] - globals: [2] ‘x’, ‘i’
[11:01:01.674] 
[11:01:01.674] getGlobalsAndPackages() ... DONE
[11:01:01.674] getGlobalsAndPackages() ...
[11:01:01.675] Searching for globals...
[11:01:01.676] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[11:01:01.676] Searching for globals ... DONE
[11:01:01.676] Resolving globals: FALSE
[11:01:01.684] The total size of the 2 globals is 1.82 MiB (1905892 bytes)
[11:01:01.684] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.82 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.82 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[11:01:01.685] - globals: [2] ‘x’, ‘i’
[11:01:01.685] 
[11:01:01.685] getGlobalsAndPackages() ... DONE

> ## At this point nothing has been calculated,
> ## because lazy evaluation is in place.
> 
> ## Get the 7:th Fibonnaci numbers (should be 8)
> print(x[[7]])
[11:01:01.686] run() for ‘Future’ ...
[11:01:01.686] - state: ‘created’
[11:01:01.686] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:01.686] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:01.686] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:01.686]   - Field: ‘label’
[11:01:01.687]   - Field: ‘local’
[11:01:01.687]   - Field: ‘owner’
[11:01:01.687]   - Field: ‘envir’
[11:01:01.687]   - Field: ‘packages’
[11:01:01.687]   - Field: ‘gc’
[11:01:01.687]   - Field: ‘conditions’
[11:01:01.687]   - Field: ‘expr’
[11:01:01.687]   - Field: ‘uuid’
[11:01:01.687]   - Field: ‘seed’
[11:01:01.687]   - Field: ‘version’
[11:01:01.687]   - Field: ‘result’
[11:01:01.687]   - Field: ‘asynchronous’
[11:01:01.687]   - Field: ‘calls’
[11:01:01.688]   - Field: ‘globals’
[11:01:01.688]   - Field: ‘stdout’
[11:01:01.688]   - Field: ‘earlySignal’
[11:01:01.688]   - Field: ‘lazy’
[11:01:01.688]   - Field: ‘state’
[11:01:01.688] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:01.688] - Launch lazy future ...
[11:01:01.689] Packages needed by the future expression (n = 0): <none>
[11:01:01.689] Packages needed by future strategies (n = 0): <none>
[11:01:01.690] {
[11:01:01.690]     {
[11:01:01.690]         {
[11:01:01.690]             ...future.startTime <- base::Sys.time()
[11:01:01.690]             {
[11:01:01.690]                 {
[11:01:01.690]                   {
[11:01:01.690]                     base::local({
[11:01:01.690]                       has_future <- base::requireNamespace("future", 
[11:01:01.690]                         quietly = TRUE)
[11:01:01.690]                       if (has_future) {
[11:01:01.690]                         ns <- base::getNamespace("future")
[11:01:01.690]                         version <- ns[[".package"]][["version"]]
[11:01:01.690]                         if (is.null(version)) 
[11:01:01.690]                           version <- utils::packageVersion("future")
[11:01:01.690]                       }
[11:01:01.690]                       else {
[11:01:01.690]                         version <- NULL
[11:01:01.690]                       }
[11:01:01.690]                       if (!has_future || version < "1.8.0") {
[11:01:01.690]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:01.690]                           "", base::R.version$version.string), 
[11:01:01.690]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:01.690]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:01.690]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:01.690]                             "release", "version")], collapse = " "), 
[11:01:01.690]                           hostname = base::Sys.info()[["nodename"]])
[11:01:01.690]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:01.690]                           info)
[11:01:01.690]                         info <- base::paste(info, collapse = "; ")
[11:01:01.690]                         if (!has_future) {
[11:01:01.690]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:01.690]                             info)
[11:01:01.690]                         }
[11:01:01.690]                         else {
[11:01:01.690]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:01.690]                             info, version)
[11:01:01.690]                         }
[11:01:01.690]                         base::stop(msg)
[11:01:01.690]                       }
[11:01:01.690]                     })
[11:01:01.690]                   }
[11:01:01.690]                   ...future.strategy.old <- future::plan("list")
[11:01:01.690]                   options(future.plan = NULL)
[11:01:01.690]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:01.690]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:01.690]                 }
[11:01:01.690]                 ...future.workdir <- getwd()
[11:01:01.690]             }
[11:01:01.690]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:01.690]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:01.690]         }
[11:01:01.690]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:01.690]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:01.690]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:01.690]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:01.690]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:01.690]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:01.690]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:01.690]             base::names(...future.oldOptions))
[11:01:01.690]     }
[11:01:01.690]     if (TRUE) {
[11:01:01.690]     }
[11:01:01.690]     else {
[11:01:01.690]         if (NA) {
[11:01:01.690]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:01.690]                 open = "w")
[11:01:01.690]         }
[11:01:01.690]         else {
[11:01:01.690]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:01.690]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:01.690]         }
[11:01:01.690]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:01.690]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:01.690]             base::sink(type = "output", split = FALSE)
[11:01:01.690]             base::close(...future.stdout)
[11:01:01.690]         }, add = TRUE)
[11:01:01.690]     }
[11:01:01.690]     ...future.frame <- base::sys.nframe()
[11:01:01.690]     ...future.conditions <- base::list()
[11:01:01.690]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:01.690]     if (FALSE) {
[11:01:01.690]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:01.690]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:01.690]     }
[11:01:01.690]     ...future.result <- base::tryCatch({
[11:01:01.690]         base::withCallingHandlers({
[11:01:01.690]             ...future.value <- base::withVisible(base::local({
[11:01:01.690]                 x[[i - 2]] + x[[i - 1]]
[11:01:01.690]             }))
[11:01:01.690]             future::FutureResult(value = ...future.value$value, 
[11:01:01.690]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:01.690]                   ...future.rng), globalenv = if (FALSE) 
[11:01:01.690]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:01.690]                     ...future.globalenv.names))
[11:01:01.690]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:01.690]         }, condition = base::local({
[11:01:01.690]             c <- base::c
[11:01:01.690]             inherits <- base::inherits
[11:01:01.690]             invokeRestart <- base::invokeRestart
[11:01:01.690]             length <- base::length
[11:01:01.690]             list <- base::list
[11:01:01.690]             seq.int <- base::seq.int
[11:01:01.690]             signalCondition <- base::signalCondition
[11:01:01.690]             sys.calls <- base::sys.calls
[11:01:01.690]             `[[` <- base::`[[`
[11:01:01.690]             `+` <- base::`+`
[11:01:01.690]             `<<-` <- base::`<<-`
[11:01:01.690]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:01.690]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:01.690]                   3L)]
[11:01:01.690]             }
[11:01:01.690]             function(cond) {
[11:01:01.690]                 is_error <- inherits(cond, "error")
[11:01:01.690]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:01.690]                   NULL)
[11:01:01.690]                 if (is_error) {
[11:01:01.690]                   sessionInformation <- function() {
[11:01:01.690]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:01.690]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:01.690]                       search = base::search(), system = base::Sys.info())
[11:01:01.690]                   }
[11:01:01.690]                   ...future.conditions[[length(...future.conditions) + 
[11:01:01.690]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:01.690]                     cond$call), session = sessionInformation(), 
[11:01:01.690]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:01.690]                   signalCondition(cond)
[11:01:01.690]                 }
[11:01:01.690]                 else if (!ignore && TRUE && inherits(cond, c("error", 
[11:01:01.690]                 "immediateCondition"))) {
[11:01:01.690]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:01.690]                   ...future.conditions[[length(...future.conditions) + 
[11:01:01.690]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:01.690]                   if (TRUE && !signal) {
[11:01:01.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:01.690]                     {
[11:01:01.690]                       inherits <- base::inherits
[11:01:01.690]                       invokeRestart <- base::invokeRestart
[11:01:01.690]                       is.null <- base::is.null
[11:01:01.690]                       muffled <- FALSE
[11:01:01.690]                       if (inherits(cond, "message")) {
[11:01:01.690]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:01.690]                         if (muffled) 
[11:01:01.690]                           invokeRestart("muffleMessage")
[11:01:01.690]                       }
[11:01:01.690]                       else if (inherits(cond, "warning")) {
[11:01:01.690]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:01.690]                         if (muffled) 
[11:01:01.690]                           invokeRestart("muffleWarning")
[11:01:01.690]                       }
[11:01:01.690]                       else if (inherits(cond, "condition")) {
[11:01:01.690]                         if (!is.null(pattern)) {
[11:01:01.690]                           computeRestarts <- base::computeRestarts
[11:01:01.690]                           grepl <- base::grepl
[11:01:01.690]                           restarts <- computeRestarts(cond)
[11:01:01.690]                           for (restart in restarts) {
[11:01:01.690]                             name <- restart$name
[11:01:01.690]                             if (is.null(name)) 
[11:01:01.690]                               next
[11:01:01.690]                             if (!grepl(pattern, name)) 
[11:01:01.690]                               next
[11:01:01.690]                             invokeRestart(restart)
[11:01:01.690]                             muffled <- TRUE
[11:01:01.690]                             break
[11:01:01.690]                           }
[11:01:01.690]                         }
[11:01:01.690]                       }
[11:01:01.690]                       invisible(muffled)
[11:01:01.690]                     }
[11:01:01.690]                     muffleCondition(cond, pattern = "^muffle")
[11:01:01.690]                   }
[11:01:01.690]                 }
[11:01:01.690]                 else {
[11:01:01.690]                   if (TRUE) {
[11:01:01.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:01.690]                     {
[11:01:01.690]                       inherits <- base::inherits
[11:01:01.690]                       invokeRestart <- base::invokeRestart
[11:01:01.690]                       is.null <- base::is.null
[11:01:01.690]                       muffled <- FALSE
[11:01:01.690]                       if (inherits(cond, "message")) {
[11:01:01.690]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:01.690]                         if (muffled) 
[11:01:01.690]                           invokeRestart("muffleMessage")
[11:01:01.690]                       }
[11:01:01.690]                       else if (inherits(cond, "warning")) {
[11:01:01.690]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:01.690]                         if (muffled) 
[11:01:01.690]                           invokeRestart("muffleWarning")
[11:01:01.690]                       }
[11:01:01.690]                       else if (inherits(cond, "condition")) {
[11:01:01.690]                         if (!is.null(pattern)) {
[11:01:01.690]                           computeRestarts <- base::computeRestarts
[11:01:01.690]                           grepl <- base::grepl
[11:01:01.690]                           restarts <- computeRestarts(cond)
[11:01:01.690]                           for (restart in restarts) {
[11:01:01.690]                             name <- restart$name
[11:01:01.690]                             if (is.null(name)) 
[11:01:01.690]                               next
[11:01:01.690]                             if (!grepl(pattern, name)) 
[11:01:01.690]                               next
[11:01:01.690]                             invokeRestart(restart)
[11:01:01.690]                             muffled <- TRUE
[11:01:01.690]                             break
[11:01:01.690]                           }
[11:01:01.690]                         }
[11:01:01.690]                       }
[11:01:01.690]                       invisible(muffled)
[11:01:01.690]                     }
[11:01:01.690]                     muffleCondition(cond, pattern = "^muffle")
[11:01:01.690]                   }
[11:01:01.690]                 }
[11:01:01.690]             }
[11:01:01.690]         }))
[11:01:01.690]     }, error = function(ex) {
[11:01:01.690]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:01.690]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:01.690]                 ...future.rng), started = ...future.startTime, 
[11:01:01.690]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:01.690]             version = "1.8"), class = "FutureResult")
[11:01:01.690]     }, finally = {
[11:01:01.690]         if (!identical(...future.workdir, getwd())) 
[11:01:01.690]             setwd(...future.workdir)
[11:01:01.690]         {
[11:01:01.690]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:01.690]                 ...future.oldOptions$nwarnings <- NULL
[11:01:01.690]             }
[11:01:01.690]             base::options(...future.oldOptions)
[11:01:01.690]             if (.Platform$OS.type == "windows") {
[11:01:01.690]                 old_names <- names(...future.oldEnvVars)
[11:01:01.690]                 envs <- base::Sys.getenv()
[11:01:01.690]                 names <- names(envs)
[11:01:01.690]                 common <- intersect(names, old_names)
[11:01:01.690]                 added <- setdiff(names, old_names)
[11:01:01.690]                 removed <- setdiff(old_names, names)
[11:01:01.690]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:01.690]                   envs[common]]
[11:01:01.690]                 NAMES <- toupper(changed)
[11:01:01.690]                 args <- list()
[11:01:01.690]                 for (kk in seq_along(NAMES)) {
[11:01:01.690]                   name <- changed[[kk]]
[11:01:01.690]                   NAME <- NAMES[[kk]]
[11:01:01.690]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:01.690]                     next
[11:01:01.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:01.690]                 }
[11:01:01.690]                 NAMES <- toupper(added)
[11:01:01.690]                 for (kk in seq_along(NAMES)) {
[11:01:01.690]                   name <- added[[kk]]
[11:01:01.690]                   NAME <- NAMES[[kk]]
[11:01:01.690]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:01.690]                     next
[11:01:01.690]                   args[[name]] <- ""
[11:01:01.690]                 }
[11:01:01.690]                 NAMES <- toupper(removed)
[11:01:01.690]                 for (kk in seq_along(NAMES)) {
[11:01:01.690]                   name <- removed[[kk]]
[11:01:01.690]                   NAME <- NAMES[[kk]]
[11:01:01.690]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:01.690]                     next
[11:01:01.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:01.690]                 }
[11:01:01.690]                 if (length(args) > 0) 
[11:01:01.690]                   base::do.call(base::Sys.setenv, args = args)
[11:01:01.690]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:01.690]             }
[11:01:01.690]             else {
[11:01:01.690]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:01.690]             }
[11:01:01.690]             {
[11:01:01.690]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:01.690]                   0L) {
[11:01:01.690]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:01.690]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:01.690]                   base::options(opts)
[11:01:01.690]                 }
[11:01:01.690]                 {
[11:01:01.690]                   {
[11:01:01.690]                     NULL
[11:01:01.690]                     RNGkind("Mersenne-Twister")
[11:01:01.690]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:01.690]                       inherits = FALSE)
[11:01:01.690]                   }
[11:01:01.690]                   options(future.plan = NULL)
[11:01:01.690]                   if (is.na(NA_character_)) 
[11:01:01.690]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:01.690]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:01.690]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:01.690]                     .init = FALSE)
[11:01:01.690]                 }
[11:01:01.690]             }
[11:01:01.690]         }
[11:01:01.690]     })
[11:01:01.690]     if (FALSE) {
[11:01:01.690]         base::sink(type = "output", split = FALSE)
[11:01:01.690]         if (NA) {
[11:01:01.690]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:01.690]         }
[11:01:01.690]         else {
[11:01:01.690]             ...future.result["stdout"] <- base::list(NULL)
[11:01:01.690]         }
[11:01:01.690]         base::close(...future.stdout)
[11:01:01.690]         ...future.stdout <- NULL
[11:01:01.690]     }
[11:01:01.690]     ...future.result$conditions <- ...future.conditions
[11:01:01.690]     ...future.result$finished <- base::Sys.time()
[11:01:01.690]     ...future.result
[11:01:01.690] }
[11:01:01.691] assign_globals() ...
[11:01:01.691] List of 2
[11:01:01.691]  $ x:Classes 'listenv', 'environment' <environment: 0x564916259180> 
[11:01:01.691]  $ i: int 7
[11:01:01.691]  - attr(*, "where")=List of 2
[11:01:01.691]   ..$ x:<environment: R_EmptyEnv> 
[11:01:01.691]   ..$ i:<environment: R_EmptyEnv> 
[11:01:01.691]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:01.691]  - attr(*, "resolved")= logi FALSE
[11:01:01.691]  - attr(*, "total_size")= num 92634
[11:01:01.691]  - attr(*, "already-done")= logi TRUE
[11:01:01.696] - copied ‘x’ to environment
[11:01:01.696] - copied ‘i’ to environment
[11:01:01.696] assign_globals() ... done
[11:01:01.697] plan(): Setting new future strategy stack:
[11:01:01.697] List of future strategies:
[11:01:01.697] 1. sequential:
[11:01:01.697]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:01.697]    - tweaked: FALSE
[11:01:01.697]    - call: NULL
[11:01:01.697] plan(): nbrOfWorkers() = 1
[11:01:01.769] plan(): Setting new future strategy stack:
[11:01:01.769] List of future strategies:
[11:01:01.769] 1. sequential:
[11:01:01.769]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:01.769]    - tweaked: FALSE
[11:01:01.769]    - call: plan(sequential)
[11:01:01.770] plan(): nbrOfWorkers() = 1
[11:01:01.770] SequentialFuture started (and completed)
[11:01:01.770] - Launch lazy future ... done
[11:01:01.770] run() for ‘SequentialFuture’ ... done
[1] 8

> ## At this point x[1:7] have been calculated,
> ## but nothing beyond.
> 
> ## Let's get the 50:th number.
> print(x[[50]])
[11:01:01.770] run() for ‘Future’ ...
[11:01:01.770] - state: ‘created’
[11:01:01.770] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:01.771] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:01.771] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:01.771]   - Field: ‘label’
[11:01:01.771]   - Field: ‘local’
[11:01:01.771]   - Field: ‘owner’
[11:01:01.771]   - Field: ‘envir’
[11:01:01.771]   - Field: ‘packages’
[11:01:01.771]   - Field: ‘gc’
[11:01:01.771]   - Field: ‘conditions’
[11:01:01.771]   - Field: ‘expr’
[11:01:01.772]   - Field: ‘uuid’
[11:01:01.772]   - Field: ‘seed’
[11:01:01.772]   - Field: ‘version’
[11:01:01.772]   - Field: ‘result’
[11:01:01.772]   - Field: ‘asynchronous’
[11:01:01.772]   - Field: ‘calls’
[11:01:01.772]   - Field: ‘globals’
[11:01:01.772]   - Field: ‘stdout’
[11:01:01.772]   - Field: ‘earlySignal’
[11:01:01.772]   - Field: ‘lazy’
[11:01:01.772]   - Field: ‘state’
[11:01:01.772] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:01.772] - Launch lazy future ...
[11:01:01.773] Packages needed by the future expression (n = 0): <none>
[11:01:01.773] Packages needed by future strategies (n = 0): <none>
[11:01:01.773] {
[11:01:01.773]     {
[11:01:01.773]         {
[11:01:01.773]             ...future.startTime <- base::Sys.time()
[11:01:01.773]             {
[11:01:01.773]                 {
[11:01:01.773]                   {
[11:01:01.773]                     base::local({
[11:01:01.773]                       has_future <- base::requireNamespace("future", 
[11:01:01.773]                         quietly = TRUE)
[11:01:01.773]                       if (has_future) {
[11:01:01.773]                         ns <- base::getNamespace("future")
[11:01:01.773]                         version <- ns[[".package"]][["version"]]
[11:01:01.773]                         if (is.null(version)) 
[11:01:01.773]                           version <- utils::packageVersion("future")
[11:01:01.773]                       }
[11:01:01.773]                       else {
[11:01:01.773]                         version <- NULL
[11:01:01.773]                       }
[11:01:01.773]                       if (!has_future || version < "1.8.0") {
[11:01:01.773]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:01.773]                           "", base::R.version$version.string), 
[11:01:01.773]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:01.773]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:01.773]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:01.773]                             "release", "version")], collapse = " "), 
[11:01:01.773]                           hostname = base::Sys.info()[["nodename"]])
[11:01:01.773]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:01.773]                           info)
[11:01:01.773]                         info <- base::paste(info, collapse = "; ")
[11:01:01.773]                         if (!has_future) {
[11:01:01.773]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:01.773]                             info)
[11:01:01.773]                         }
[11:01:01.773]                         else {
[11:01:01.773]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:01.773]                             info, version)
[11:01:01.773]                         }
[11:01:01.773]                         base::stop(msg)
[11:01:01.773]                       }
[11:01:01.773]                     })
[11:01:01.773]                   }
[11:01:01.773]                   ...future.strategy.old <- future::plan("list")
[11:01:01.773]                   options(future.plan = NULL)
[11:01:01.773]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:01.773]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:01.773]                 }
[11:01:01.773]                 ...future.workdir <- getwd()
[11:01:01.773]             }
[11:01:01.773]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:01.773]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:01.773]         }
[11:01:01.773]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:01.773]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:01.773]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:01.773]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:01.773]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:01.773]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:01.773]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:01.773]             base::names(...future.oldOptions))
[11:01:01.773]     }
[11:01:01.773]     if (TRUE) {
[11:01:01.773]     }
[11:01:01.773]     else {
[11:01:01.773]         if (NA) {
[11:01:01.773]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:01.773]                 open = "w")
[11:01:01.773]         }
[11:01:01.773]         else {
[11:01:01.773]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:01.773]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:01.773]         }
[11:01:01.773]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:01.773]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:01.773]             base::sink(type = "output", split = FALSE)
[11:01:01.773]             base::close(...future.stdout)
[11:01:01.773]         }, add = TRUE)
[11:01:01.773]     }
[11:01:01.773]     ...future.frame <- base::sys.nframe()
[11:01:01.773]     ...future.conditions <- base::list()
[11:01:01.773]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:01.773]     if (FALSE) {
[11:01:01.773]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:01.773]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:01.773]     }
[11:01:01.773]     ...future.result <- base::tryCatch({
[11:01:01.773]         base::withCallingHandlers({
[11:01:01.773]             ...future.value <- base::withVisible(base::local({
[11:01:01.773]                 x[[i - 2]] + x[[i - 1]]
[11:01:01.773]             }))
[11:01:01.773]             future::FutureResult(value = ...future.value$value, 
[11:01:01.773]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:01.773]                   ...future.rng), globalenv = if (FALSE) 
[11:01:01.773]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:01.773]                     ...future.globalenv.names))
[11:01:01.773]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:01.773]         }, condition = base::local({
[11:01:01.773]             c <- base::c
[11:01:01.773]             inherits <- base::inherits
[11:01:01.773]             invokeRestart <- base::invokeRestart
[11:01:01.773]             length <- base::length
[11:01:01.773]             list <- base::list
[11:01:01.773]             seq.int <- base::seq.int
[11:01:01.773]             signalCondition <- base::signalCondition
[11:01:01.773]             sys.calls <- base::sys.calls
[11:01:01.773]             `[[` <- base::`[[`
[11:01:01.773]             `+` <- base::`+`
[11:01:01.773]             `<<-` <- base::`<<-`
[11:01:01.773]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:01.773]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:01.773]                   3L)]
[11:01:01.773]             }
[11:01:01.773]             function(cond) {
[11:01:01.773]                 is_error <- inherits(cond, "error")
[11:01:01.773]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:01.773]                   NULL)
[11:01:01.773]                 if (is_error) {
[11:01:01.773]                   sessionInformation <- function() {
[11:01:01.773]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:01.773]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:01.773]                       search = base::search(), system = base::Sys.info())
[11:01:01.773]                   }
[11:01:01.773]                   ...future.conditions[[length(...future.conditions) + 
[11:01:01.773]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:01.773]                     cond$call), session = sessionInformation(), 
[11:01:01.773]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:01.773]                   signalCondition(cond)
[11:01:01.773]                 }
[11:01:01.773]                 else if (!ignore && TRUE && inherits(cond, c("error", 
[11:01:01.773]                 "immediateCondition"))) {
[11:01:01.773]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:01.773]                   ...future.conditions[[length(...future.conditions) + 
[11:01:01.773]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:01.773]                   if (TRUE && !signal) {
[11:01:01.773]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:01.773]                     {
[11:01:01.773]                       inherits <- base::inherits
[11:01:01.773]                       invokeRestart <- base::invokeRestart
[11:01:01.773]                       is.null <- base::is.null
[11:01:01.773]                       muffled <- FALSE
[11:01:01.773]                       if (inherits(cond, "message")) {
[11:01:01.773]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:01.773]                         if (muffled) 
[11:01:01.773]                           invokeRestart("muffleMessage")
[11:01:01.773]                       }
[11:01:01.773]                       else if (inherits(cond, "warning")) {
[11:01:01.773]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:01.773]                         if (muffled) 
[11:01:01.773]                           invokeRestart("muffleWarning")
[11:01:01.773]                       }
[11:01:01.773]                       else if (inherits(cond, "condition")) {
[11:01:01.773]                         if (!is.null(pattern)) {
[11:01:01.773]                           computeRestarts <- base::computeRestarts
[11:01:01.773]                           grepl <- base::grepl
[11:01:01.773]                           restarts <- computeRestarts(cond)
[11:01:01.773]                           for (restart in restarts) {
[11:01:01.773]                             name <- restart$name
[11:01:01.773]                             if (is.null(name)) 
[11:01:01.773]                               next
[11:01:01.773]                             if (!grepl(pattern, name)) 
[11:01:01.773]                               next
[11:01:01.773]                             invokeRestart(restart)
[11:01:01.773]                             muffled <- TRUE
[11:01:01.773]                             break
[11:01:01.773]                           }
[11:01:01.773]                         }
[11:01:01.773]                       }
[11:01:01.773]                       invisible(muffled)
[11:01:01.773]                     }
[11:01:01.773]                     muffleCondition(cond, pattern = "^muffle")
[11:01:01.773]                   }
[11:01:01.773]                 }
[11:01:01.773]                 else {
[11:01:01.773]                   if (TRUE) {
[11:01:01.773]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:01.773]                     {
[11:01:01.773]                       inherits <- base::inherits
[11:01:01.773]                       invokeRestart <- base::invokeRestart
[11:01:01.773]                       is.null <- base::is.null
[11:01:01.773]                       muffled <- FALSE
[11:01:01.773]                       if (inherits(cond, "message")) {
[11:01:01.773]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:01.773]                         if (muffled) 
[11:01:01.773]                           invokeRestart("muffleMessage")
[11:01:01.773]                       }
[11:01:01.773]                       else if (inherits(cond, "warning")) {
[11:01:01.773]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:01.773]                         if (muffled) 
[11:01:01.773]                           invokeRestart("muffleWarning")
[11:01:01.773]                       }
[11:01:01.773]                       else if (inherits(cond, "condition")) {
[11:01:01.773]                         if (!is.null(pattern)) {
[11:01:01.773]                           computeRestarts <- base::computeRestarts
[11:01:01.773]                           grepl <- base::grepl
[11:01:01.773]                           restarts <- computeRestarts(cond)
[11:01:01.773]                           for (restart in restarts) {
[11:01:01.773]                             name <- restart$name
[11:01:01.773]                             if (is.null(name)) 
[11:01:01.773]                               next
[11:01:01.773]                             if (!grepl(pattern, name)) 
[11:01:01.773]                               next
[11:01:01.773]                             invokeRestart(restart)
[11:01:01.773]                             muffled <- TRUE
[11:01:01.773]                             break
[11:01:01.773]                           }
[11:01:01.773]                         }
[11:01:01.773]                       }
[11:01:01.773]                       invisible(muffled)
[11:01:01.773]                     }
[11:01:01.773]                     muffleCondition(cond, pattern = "^muffle")
[11:01:01.773]                   }
[11:01:01.773]                 }
[11:01:01.773]             }
[11:01:01.773]         }))
[11:01:01.773]     }, error = function(ex) {
[11:01:01.773]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:01.773]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:01.773]                 ...future.rng), started = ...future.startTime, 
[11:01:01.773]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:01.773]             version = "1.8"), class = "FutureResult")
[11:01:01.773]     }, finally = {
[11:01:01.773]         if (!identical(...future.workdir, getwd())) 
[11:01:01.773]             setwd(...future.workdir)
[11:01:01.773]         {
[11:01:01.773]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:01.773]                 ...future.oldOptions$nwarnings <- NULL
[11:01:01.773]             }
[11:01:01.773]             base::options(...future.oldOptions)
[11:01:01.773]             if (.Platform$OS.type == "windows") {
[11:01:01.773]                 old_names <- names(...future.oldEnvVars)
[11:01:01.773]                 envs <- base::Sys.getenv()
[11:01:01.773]                 names <- names(envs)
[11:01:01.773]                 common <- intersect(names, old_names)
[11:01:01.773]                 added <- setdiff(names, old_names)
[11:01:01.773]                 removed <- setdiff(old_names, names)
[11:01:01.773]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:01.773]                   envs[common]]
[11:01:01.773]                 NAMES <- toupper(changed)
[11:01:01.773]                 args <- list()
[11:01:01.773]                 for (kk in seq_along(NAMES)) {
[11:01:01.773]                   name <- changed[[kk]]
[11:01:01.773]                   NAME <- NAMES[[kk]]
[11:01:01.773]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:01.773]                     next
[11:01:01.773]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:01.773]                 }
[11:01:01.773]                 NAMES <- toupper(added)
[11:01:01.773]                 for (kk in seq_along(NAMES)) {
[11:01:01.773]                   name <- added[[kk]]
[11:01:01.773]                   NAME <- NAMES[[kk]]
[11:01:01.773]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:01.773]                     next
[11:01:01.773]                   args[[name]] <- ""
[11:01:01.773]                 }
[11:01:01.773]                 NAMES <- toupper(removed)
[11:01:01.773]                 for (kk in seq_along(NAMES)) {
[11:01:01.773]                   name <- removed[[kk]]
[11:01:01.773]                   NAME <- NAMES[[kk]]
[11:01:01.773]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:01.773]                     next
[11:01:01.773]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:01.773]                 }
[11:01:01.773]                 if (length(args) > 0) 
[11:01:01.773]                   base::do.call(base::Sys.setenv, args = args)
[11:01:01.773]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:01.773]             }
[11:01:01.773]             else {
[11:01:01.773]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:01.773]             }
[11:01:01.773]             {
[11:01:01.773]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:01.773]                   0L) {
[11:01:01.773]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:01.773]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:01.773]                   base::options(opts)
[11:01:01.773]                 }
[11:01:01.773]                 {
[11:01:01.773]                   {
[11:01:01.773]                     NULL
[11:01:01.773]                     RNGkind("Mersenne-Twister")
[11:01:01.773]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:01.773]                       inherits = FALSE)
[11:01:01.773]                   }
[11:01:01.773]                   options(future.plan = NULL)
[11:01:01.773]                   if (is.na(NA_character_)) 
[11:01:01.773]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:01.773]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:01.773]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:01.773]                     .init = FALSE)
[11:01:01.773]                 }
[11:01:01.773]             }
[11:01:01.773]         }
[11:01:01.773]     })
[11:01:01.773]     if (FALSE) {
[11:01:01.773]         base::sink(type = "output", split = FALSE)
[11:01:01.773]         if (NA) {
[11:01:01.773]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:01.773]         }
[11:01:01.773]         else {
[11:01:01.773]             ...future.result["stdout"] <- base::list(NULL)
[11:01:01.773]         }
[11:01:01.773]         base::close(...future.stdout)
[11:01:01.773]         ...future.stdout <- NULL
[11:01:01.773]     }
[11:01:01.773]     ...future.result$conditions <- ...future.conditions
[11:01:01.773]     ...future.result$finished <- base::Sys.time()
[11:01:01.773]     ...future.result
[11:01:01.773] }
[11:01:01.775] assign_globals() ...
[11:01:01.775] List of 2
[11:01:01.775]  $ x:Classes 'listenv', 'environment' <environment: 0x564916259180> 
[11:01:01.775]  $ i: int 50
[11:01:01.775]  - attr(*, "where")=List of 2
[11:01:01.775]   ..$ x:<environment: R_EmptyEnv> 
[11:01:01.775]   ..$ i:<environment: R_EmptyEnv> 
[11:01:01.775]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:01.775]  - attr(*, "resolved")= logi FALSE
[11:01:01.775]  - attr(*, "total_size")= num 931008
[11:01:01.775]  - attr(*, "already-done")= logi TRUE
[11:01:01.777] - copied ‘x’ to environment
[11:01:01.778] - copied ‘i’ to environment
[11:01:01.778] assign_globals() ... done
[11:01:01.778] plan(): Setting new future strategy stack:
[11:01:01.778] List of future strategies:
[11:01:01.778] 1. sequential:
[11:01:01.778]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:01.778]    - tweaked: FALSE
[11:01:01.778]    - call: NULL
[11:01:01.778] plan(): nbrOfWorkers() = 1
[11:01:02.586] plan(): Setting new future strategy stack:
[11:01:02.587] List of future strategies:
[11:01:02.587] 1. sequential:
[11:01:02.587]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:02.587]    - tweaked: FALSE
[11:01:02.587]    - call: plan(sequential)
[11:01:02.587] plan(): nbrOfWorkers() = 1
[11:01:02.587] SequentialFuture started (and completed)
[11:01:02.587] - Launch lazy future ... done
[11:01:02.587] run() for ‘SequentialFuture’ ... done
[1] 7778742049

> ## Reset plan
> plan(oplan)
[11:01:02.588] plan(): Setting new future strategy stack:
[11:01:02.588] List of future strategies:
[11:01:02.588] 1. sequential:
[11:01:02.588]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:02.588]    - tweaked: FALSE
[11:01:02.588]    - call: future::plan("sequential")
[11:01:02.588] plan(): nbrOfWorkers() = 1
> message("*** Fibonacci demo of the 'future' package ... DONE")
*** Fibonacci demo of the 'future' package ... DONE
> 
> 
> message("*** Mandelbrot demo of the 'future' package ...")
*** Mandelbrot demo of the 'future' package ...
> if (getRversion() >= "3.2.0" && !isWin32) {
+   options(future.demo.mandelbrot.nrow = 2L)
+   options(future.demo.mandelbrot.resolution = 50L)
+   options(future.demo.mandelbrot.delay = FALSE)
+   
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+   
+     for (strategy in supportedStrategies(cores)) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+       demo("mandelbrot", package = "future", ask = FALSE)
+       message(sprintf("- plan('%s') ... DONE", strategy))
+     }
+   
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } else {
+   message(" - This demo requires R (>= 3.2.0). Skipping test. (Skipping also on Win32 i386 for speed)")
+ }
Testing with 1 cores ...
- plan('sequential') ...
[11:01:02.596] plan(): Setting new future strategy stack:
[11:01:02.596] List of future strategies:
[11:01:02.596] 1. sequential:
[11:01:02.596]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:02.596]    - tweaked: FALSE
[11:01:02.596]    - call: plan(strategy)
[11:01:02.596] plan(): nbrOfWorkers() = 1


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1] 1 2 3 4

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[11:01:02.626] getGlobalsAndPackages() ...
[11:01:02.626] Searching for globals...
[11:01:02.629] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[11:01:02.630] Searching for globals ... DONE
[11:01:02.630] Resolving globals: FALSE
[11:01:02.630] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[11:01:02.631] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:02.631] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[11:01:02.631] - packages: [1] ‘future’
[11:01:02.631] getGlobalsAndPackages() ... DONE
 2[11:01:02.636] getGlobalsAndPackages() ...
[11:01:02.636] Searching for globals...
[11:01:02.639] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[11:01:02.640] Searching for globals ... DONE
[11:01:02.640] Resolving globals: FALSE
[11:01:02.640] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[11:01:02.641] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:02.641] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[11:01:02.641] - packages: [1] ‘future’
[11:01:02.641] getGlobalsAndPackages() ... DONE
 3[11:01:02.641] getGlobalsAndPackages() ...
[11:01:02.641] Searching for globals...
[11:01:02.644] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[11:01:02.644] Searching for globals ... DONE
[11:01:02.645] Resolving globals: FALSE
[11:01:02.645] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[11:01:02.645] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:02.647] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[11:01:02.647] - packages: [1] ‘future’
[11:01:02.648] getGlobalsAndPackages() ... DONE
 4[11:01:02.648] getGlobalsAndPackages() ...
[11:01:02.648] Searching for globals...
[11:01:02.651] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[11:01:02.651] Searching for globals ... DONE
[11:01:02.651] Resolving globals: FALSE
[11:01:02.652] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[11:01:02.652] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:02.652] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[11:01:02.652] - packages: [1] ‘future’
[11:01:02.653] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[11:01:02.662] resolved() for ‘Future’ ...
[11:01:02.662] - state: ‘created’
[11:01:02.662] - run: TRUE
[11:01:02.663] - run() ...
[11:01:02.663] run() for ‘Future’ ...
[11:01:02.663] - state: ‘created’
[11:01:02.663] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:02.663] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:02.663] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:02.663]   - Field: ‘label’
[11:01:02.664]   - Field: ‘local’
[11:01:02.664]   - Field: ‘owner’
[11:01:02.664]   - Field: ‘envir’
[11:01:02.664]   - Field: ‘packages’
[11:01:02.664]   - Field: ‘gc’
[11:01:02.664]   - Field: ‘conditions’
[11:01:02.664]   - Field: ‘expr’
[11:01:02.664]   - Field: ‘uuid’
[11:01:02.664]   - Field: ‘seed’
[11:01:02.664]   - Field: ‘version’
[11:01:02.664]   - Field: ‘result’
[11:01:02.665]   - Field: ‘asynchronous’
[11:01:02.665]   - Field: ‘calls’
[11:01:02.665]   - Field: ‘globals’
[11:01:02.665]   - Field: ‘stdout’
[11:01:02.665]   - Field: ‘earlySignal’
[11:01:02.665]   - Field: ‘lazy’
[11:01:02.665]   - Field: ‘state’
[11:01:02.665] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:02.665] - Launch lazy future ...
[11:01:02.665] Packages needed by the future expression (n = 1): ‘future’
[11:01:02.666] Packages needed by future strategies (n = 0): <none>
[11:01:02.666] {
[11:01:02.666]     {
[11:01:02.666]         {
[11:01:02.666]             ...future.startTime <- base::Sys.time()
[11:01:02.666]             {
[11:01:02.666]                 {
[11:01:02.666]                   {
[11:01:02.666]                     {
[11:01:02.666]                       base::local({
[11:01:02.666]                         has_future <- base::requireNamespace("future", 
[11:01:02.666]                           quietly = TRUE)
[11:01:02.666]                         if (has_future) {
[11:01:02.666]                           ns <- base::getNamespace("future")
[11:01:02.666]                           version <- ns[[".package"]][["version"]]
[11:01:02.666]                           if (is.null(version)) 
[11:01:02.666]                             version <- utils::packageVersion("future")
[11:01:02.666]                         }
[11:01:02.666]                         else {
[11:01:02.666]                           version <- NULL
[11:01:02.666]                         }
[11:01:02.666]                         if (!has_future || version < "1.8.0") {
[11:01:02.666]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:02.666]                             "", base::R.version$version.string), 
[11:01:02.666]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:02.666]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:02.666]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:02.666]                               "release", "version")], collapse = " "), 
[11:01:02.666]                             hostname = base::Sys.info()[["nodename"]])
[11:01:02.666]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:02.666]                             info)
[11:01:02.666]                           info <- base::paste(info, collapse = "; ")
[11:01:02.666]                           if (!has_future) {
[11:01:02.666]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:02.666]                               info)
[11:01:02.666]                           }
[11:01:02.666]                           else {
[11:01:02.666]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:02.666]                               info, version)
[11:01:02.666]                           }
[11:01:02.666]                           base::stop(msg)
[11:01:02.666]                         }
[11:01:02.666]                       })
[11:01:02.666]                     }
[11:01:02.666]                     base::local({
[11:01:02.666]                       for (pkg in "future") {
[11:01:02.666]                         base::loadNamespace(pkg)
[11:01:02.666]                         base::library(pkg, character.only = TRUE)
[11:01:02.666]                       }
[11:01:02.666]                     })
[11:01:02.666]                   }
[11:01:02.666]                   ...future.strategy.old <- future::plan("list")
[11:01:02.666]                   options(future.plan = NULL)
[11:01:02.666]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:02.666]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:02.666]                 }
[11:01:02.666]                 ...future.workdir <- getwd()
[11:01:02.666]             }
[11:01:02.666]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:02.666]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:02.666]         }
[11:01:02.666]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:02.666]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:02.666]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:02.666]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:02.666]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:02.666]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:02.666]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:02.666]             base::names(...future.oldOptions))
[11:01:02.666]     }
[11:01:02.666]     if (FALSE) {
[11:01:02.666]     }
[11:01:02.666]     else {
[11:01:02.666]         if (TRUE) {
[11:01:02.666]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:02.666]                 open = "w")
[11:01:02.666]         }
[11:01:02.666]         else {
[11:01:02.666]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:02.666]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:02.666]         }
[11:01:02.666]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:02.666]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:02.666]             base::sink(type = "output", split = FALSE)
[11:01:02.666]             base::close(...future.stdout)
[11:01:02.666]         }, add = TRUE)
[11:01:02.666]     }
[11:01:02.666]     ...future.frame <- base::sys.nframe()
[11:01:02.666]     ...future.conditions <- base::list()
[11:01:02.666]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:02.666]     if (FALSE) {
[11:01:02.666]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:02.666]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:02.666]     }
[11:01:02.666]     ...future.result <- base::tryCatch({
[11:01:02.666]         base::withCallingHandlers({
[11:01:02.666]             ...future.value <- base::withVisible(base::local({
[11:01:02.666]                 message(sprintf("Calculating tile #%d of %d ...", 
[11:01:02.666]                   ii, n), appendLF = FALSE)
[11:01:02.666]                 fit <- mandelbrot(C)
[11:01:02.666]                 delay(fit)
[11:01:02.666]                 message(" done")
[11:01:02.666]                 fit
[11:01:02.666]             }))
[11:01:02.666]             future::FutureResult(value = ...future.value$value, 
[11:01:02.666]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:02.666]                   ...future.rng), globalenv = if (FALSE) 
[11:01:02.666]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:02.666]                     ...future.globalenv.names))
[11:01:02.666]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:02.666]         }, condition = base::local({
[11:01:02.666]             c <- base::c
[11:01:02.666]             inherits <- base::inherits
[11:01:02.666]             invokeRestart <- base::invokeRestart
[11:01:02.666]             length <- base::length
[11:01:02.666]             list <- base::list
[11:01:02.666]             seq.int <- base::seq.int
[11:01:02.666]             signalCondition <- base::signalCondition
[11:01:02.666]             sys.calls <- base::sys.calls
[11:01:02.666]             `[[` <- base::`[[`
[11:01:02.666]             `+` <- base::`+`
[11:01:02.666]             `<<-` <- base::`<<-`
[11:01:02.666]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:02.666]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:02.666]                   3L)]
[11:01:02.666]             }
[11:01:02.666]             function(cond) {
[11:01:02.666]                 is_error <- inherits(cond, "error")
[11:01:02.666]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:02.666]                   NULL)
[11:01:02.666]                 if (is_error) {
[11:01:02.666]                   sessionInformation <- function() {
[11:01:02.666]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:02.666]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:02.666]                       search = base::search(), system = base::Sys.info())
[11:01:02.666]                   }
[11:01:02.666]                   ...future.conditions[[length(...future.conditions) + 
[11:01:02.666]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:02.666]                     cond$call), session = sessionInformation(), 
[11:01:02.666]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:02.666]                   signalCondition(cond)
[11:01:02.666]                 }
[11:01:02.666]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:02.666]                 "immediateCondition"))) {
[11:01:02.666]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:02.666]                   ...future.conditions[[length(...future.conditions) + 
[11:01:02.666]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:02.666]                   if (TRUE && !signal) {
[11:01:02.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:02.666]                     {
[11:01:02.666]                       inherits <- base::inherits
[11:01:02.666]                       invokeRestart <- base::invokeRestart
[11:01:02.666]                       is.null <- base::is.null
[11:01:02.666]                       muffled <- FALSE
[11:01:02.666]                       if (inherits(cond, "message")) {
[11:01:02.666]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:02.666]                         if (muffled) 
[11:01:02.666]                           invokeRestart("muffleMessage")
[11:01:02.666]                       }
[11:01:02.666]                       else if (inherits(cond, "warning")) {
[11:01:02.666]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:02.666]                         if (muffled) 
[11:01:02.666]                           invokeRestart("muffleWarning")
[11:01:02.666]                       }
[11:01:02.666]                       else if (inherits(cond, "condition")) {
[11:01:02.666]                         if (!is.null(pattern)) {
[11:01:02.666]                           computeRestarts <- base::computeRestarts
[11:01:02.666]                           grepl <- base::grepl
[11:01:02.666]                           restarts <- computeRestarts(cond)
[11:01:02.666]                           for (restart in restarts) {
[11:01:02.666]                             name <- restart$name
[11:01:02.666]                             if (is.null(name)) 
[11:01:02.666]                               next
[11:01:02.666]                             if (!grepl(pattern, name)) 
[11:01:02.666]                               next
[11:01:02.666]                             invokeRestart(restart)
[11:01:02.666]                             muffled <- TRUE
[11:01:02.666]                             break
[11:01:02.666]                           }
[11:01:02.666]                         }
[11:01:02.666]                       }
[11:01:02.666]                       invisible(muffled)
[11:01:02.666]                     }
[11:01:02.666]                     muffleCondition(cond, pattern = "^muffle")
[11:01:02.666]                   }
[11:01:02.666]                 }
[11:01:02.666]                 else {
[11:01:02.666]                   if (TRUE) {
[11:01:02.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:02.666]                     {
[11:01:02.666]                       inherits <- base::inherits
[11:01:02.666]                       invokeRestart <- base::invokeRestart
[11:01:02.666]                       is.null <- base::is.null
[11:01:02.666]                       muffled <- FALSE
[11:01:02.666]                       if (inherits(cond, "message")) {
[11:01:02.666]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:02.666]                         if (muffled) 
[11:01:02.666]                           invokeRestart("muffleMessage")
[11:01:02.666]                       }
[11:01:02.666]                       else if (inherits(cond, "warning")) {
[11:01:02.666]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:02.666]                         if (muffled) 
[11:01:02.666]                           invokeRestart("muffleWarning")
[11:01:02.666]                       }
[11:01:02.666]                       else if (inherits(cond, "condition")) {
[11:01:02.666]                         if (!is.null(pattern)) {
[11:01:02.666]                           computeRestarts <- base::computeRestarts
[11:01:02.666]                           grepl <- base::grepl
[11:01:02.666]                           restarts <- computeRestarts(cond)
[11:01:02.666]                           for (restart in restarts) {
[11:01:02.666]                             name <- restart$name
[11:01:02.666]                             if (is.null(name)) 
[11:01:02.666]                               next
[11:01:02.666]                             if (!grepl(pattern, name)) 
[11:01:02.666]                               next
[11:01:02.666]                             invokeRestart(restart)
[11:01:02.666]                             muffled <- TRUE
[11:01:02.666]                             break
[11:01:02.666]                           }
[11:01:02.666]                         }
[11:01:02.666]                       }
[11:01:02.666]                       invisible(muffled)
[11:01:02.666]                     }
[11:01:02.666]                     muffleCondition(cond, pattern = "^muffle")
[11:01:02.666]                   }
[11:01:02.666]                 }
[11:01:02.666]             }
[11:01:02.666]         }))
[11:01:02.666]     }, error = function(ex) {
[11:01:02.666]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:02.666]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:02.666]                 ...future.rng), started = ...future.startTime, 
[11:01:02.666]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:02.666]             version = "1.8"), class = "FutureResult")
[11:01:02.666]     }, finally = {
[11:01:02.666]         if (!identical(...future.workdir, getwd())) 
[11:01:02.666]             setwd(...future.workdir)
[11:01:02.666]         {
[11:01:02.666]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:02.666]                 ...future.oldOptions$nwarnings <- NULL
[11:01:02.666]             }
[11:01:02.666]             base::options(...future.oldOptions)
[11:01:02.666]             if (.Platform$OS.type == "windows") {
[11:01:02.666]                 old_names <- names(...future.oldEnvVars)
[11:01:02.666]                 envs <- base::Sys.getenv()
[11:01:02.666]                 names <- names(envs)
[11:01:02.666]                 common <- intersect(names, old_names)
[11:01:02.666]                 added <- setdiff(names, old_names)
[11:01:02.666]                 removed <- setdiff(old_names, names)
[11:01:02.666]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:02.666]                   envs[common]]
[11:01:02.666]                 NAMES <- toupper(changed)
[11:01:02.666]                 args <- list()
[11:01:02.666]                 for (kk in seq_along(NAMES)) {
[11:01:02.666]                   name <- changed[[kk]]
[11:01:02.666]                   NAME <- NAMES[[kk]]
[11:01:02.666]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.666]                     next
[11:01:02.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:02.666]                 }
[11:01:02.666]                 NAMES <- toupper(added)
[11:01:02.666]                 for (kk in seq_along(NAMES)) {
[11:01:02.666]                   name <- added[[kk]]
[11:01:02.666]                   NAME <- NAMES[[kk]]
[11:01:02.666]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.666]                     next
[11:01:02.666]                   args[[name]] <- ""
[11:01:02.666]                 }
[11:01:02.666]                 NAMES <- toupper(removed)
[11:01:02.666]                 for (kk in seq_along(NAMES)) {
[11:01:02.666]                   name <- removed[[kk]]
[11:01:02.666]                   NAME <- NAMES[[kk]]
[11:01:02.666]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.666]                     next
[11:01:02.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:02.666]                 }
[11:01:02.666]                 if (length(args) > 0) 
[11:01:02.666]                   base::do.call(base::Sys.setenv, args = args)
[11:01:02.666]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:02.666]             }
[11:01:02.666]             else {
[11:01:02.666]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:02.666]             }
[11:01:02.666]             {
[11:01:02.666]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:02.666]                   0L) {
[11:01:02.666]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:02.666]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:02.666]                   base::options(opts)
[11:01:02.666]                 }
[11:01:02.666]                 {
[11:01:02.666]                   {
[11:01:02.666]                     NULL
[11:01:02.666]                     RNGkind("Mersenne-Twister")
[11:01:02.666]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:02.666]                       inherits = FALSE)
[11:01:02.666]                   }
[11:01:02.666]                   options(future.plan = NULL)
[11:01:02.666]                   if (is.na(NA_character_)) 
[11:01:02.666]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:02.666]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:02.666]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:02.666]                     .init = FALSE)
[11:01:02.666]                 }
[11:01:02.666]             }
[11:01:02.666]         }
[11:01:02.666]     })
[11:01:02.666]     if (TRUE) {
[11:01:02.666]         base::sink(type = "output", split = FALSE)
[11:01:02.666]         if (TRUE) {
[11:01:02.666]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:02.666]         }
[11:01:02.666]         else {
[11:01:02.666]             ...future.result["stdout"] <- base::list(NULL)
[11:01:02.666]         }
[11:01:02.666]         base::close(...future.stdout)
[11:01:02.666]         ...future.stdout <- NULL
[11:01:02.666]     }
[11:01:02.666]     ...future.result$conditions <- ...future.conditions
[11:01:02.666]     ...future.result$finished <- base::Sys.time()
[11:01:02.666]     ...future.result
[11:01:02.666] }
[11:01:02.668] assign_globals() ...
[11:01:02.668] List of 4
[11:01:02.668]  $ ii   : int 1
[11:01:02.668]  $ n    : int 4
[11:01:02.668]  $ C    : cplx [1:25, 1:25] -2.25-1.5i -2.25-1.44i -2.25-1.38i ...
[11:01:02.668]   ..- attr(*, "region")=List of 2
[11:01:02.668]   .. ..$ xrange: num [1:2] -2.25 -0.781
[11:01:02.668]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[11:01:02.668]   ..- attr(*, "tile")= int [1:2] 1 1
[11:01:02.668]  $ delay:function (counts)  
[11:01:02.668]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[11:01:02.668]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x564914762e40> 
[11:01:02.668]  - attr(*, "where")=List of 4
[11:01:02.668]   ..$ ii   :<environment: R_EmptyEnv> 
[11:01:02.668]   ..$ n    :<environment: R_EmptyEnv> 
[11:01:02.668]   ..$ C    :<environment: R_EmptyEnv> 
[11:01:02.668]   ..$ delay:<environment: R_EmptyEnv> 
[11:01:02.668]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:02.668]  - attr(*, "resolved")= logi FALSE
[11:01:02.668]  - attr(*, "total_size")= num 58781
[11:01:02.668]  - attr(*, "already-done")= logi TRUE
[11:01:02.674] - copied ‘ii’ to environment
[11:01:02.674] - copied ‘n’ to environment
[11:01:02.674] - copied ‘C’ to environment
[11:01:02.674] - reassign environment for ‘delay’
[11:01:02.675] - copied ‘delay’ to environment
[11:01:02.675] assign_globals() ... done
[11:01:02.675] plan(): Setting new future strategy stack:
[11:01:02.675] List of future strategies:
[11:01:02.675] 1. sequential:
[11:01:02.675]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:02.675]    - tweaked: FALSE
[11:01:02.675]    - call: NULL
[11:01:02.676] plan(): nbrOfWorkers() = 1
[11:01:02.691] plan(): Setting new future strategy stack:
[11:01:02.691] List of future strategies:
[11:01:02.691] 1. sequential:
[11:01:02.691]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:02.691]    - tweaked: FALSE
[11:01:02.691]    - call: plan(strategy)
[11:01:02.692] plan(): nbrOfWorkers() = 1
[11:01:02.692] SequentialFuture started (and completed)
[11:01:02.692] signalConditions() ...
[11:01:02.692]  - include = ‘immediateCondition’
[11:01:02.692]  - exclude = 
[11:01:02.692]  - resignal = FALSE
[11:01:02.692]  - Number of conditions: 2
[11:01:02.693] signalConditions() ... done
[11:01:02.693] - Launch lazy future ... done
[11:01:02.693] run() for ‘SequentialFuture’ ... done
[11:01:02.693] - run() ... done
[11:01:02.693] - resolved() ...
[11:01:02.693] resolved() for ‘SequentialFuture’ ...
[11:01:02.693] - state: ‘finished’
[11:01:02.693] - run: TRUE
[11:01:02.693] - result: ‘FutureResult’
[11:01:02.693] resolved() for ‘SequentialFuture’ ... done
[11:01:02.693] - resolved: TRUE
[11:01:02.694] - resolved() ... done
[11:01:02.695] resolved() for ‘SequentialFuture’ ... done
Plotting tile #1 of 4 ...
[11:01:02.695] signalConditions() ...
[11:01:02.695]  - include = ‘immediateCondition’
[11:01:02.695]  - exclude = 
[11:01:02.695]  - resignal = FALSE
[11:01:02.696]  - Number of conditions: 2
[11:01:02.696] signalConditions() ... done
[11:01:02.696] Future state: ‘finished’
[11:01:02.696] signalConditions() ...
[11:01:02.696]  - include = ‘condition’
[11:01:02.696]  - exclude = ‘immediateCondition’
[11:01:02.696]  - resignal = TRUE
[11:01:02.696]  - Number of conditions: 2
[11:01:02.696]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[11:01:02.696]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[11:01:02.697] signalConditions() ... done
[11:01:02.698] resolved() for ‘Future’ ...
[11:01:02.698] - state: ‘created’
[11:01:02.698] - run: TRUE
[11:01:02.698] - run() ...
[11:01:02.698] run() for ‘Future’ ...
[11:01:02.698] - state: ‘created’
[11:01:02.699] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:02.699] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:02.699] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:02.699]   - Field: ‘label’
[11:01:02.699]   - Field: ‘local’
[11:01:02.699]   - Field: ‘owner’
[11:01:02.699]   - Field: ‘envir’
[11:01:02.700]   - Field: ‘packages’
[11:01:02.700]   - Field: ‘gc’
[11:01:02.700]   - Field: ‘conditions’
[11:01:02.700]   - Field: ‘expr’
[11:01:02.700]   - Field: ‘uuid’
[11:01:02.700]   - Field: ‘seed’
[11:01:02.700]   - Field: ‘version’
[11:01:02.700]   - Field: ‘result’
[11:01:02.700]   - Field: ‘asynchronous’
[11:01:02.700]   - Field: ‘calls’
[11:01:02.700]   - Field: ‘globals’
[11:01:02.701]   - Field: ‘stdout’
[11:01:02.701]   - Field: ‘earlySignal’
[11:01:02.701]   - Field: ‘lazy’
[11:01:02.701]   - Field: ‘state’
[11:01:02.701] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:02.701] - Launch lazy future ...
[11:01:02.701] Packages needed by the future expression (n = 1): ‘future’
[11:01:02.701] Packages needed by future strategies (n = 0): <none>
[11:01:02.702] {
[11:01:02.702]     {
[11:01:02.702]         {
[11:01:02.702]             ...future.startTime <- base::Sys.time()
[11:01:02.702]             {
[11:01:02.702]                 {
[11:01:02.702]                   {
[11:01:02.702]                     {
[11:01:02.702]                       base::local({
[11:01:02.702]                         has_future <- base::requireNamespace("future", 
[11:01:02.702]                           quietly = TRUE)
[11:01:02.702]                         if (has_future) {
[11:01:02.702]                           ns <- base::getNamespace("future")
[11:01:02.702]                           version <- ns[[".package"]][["version"]]
[11:01:02.702]                           if (is.null(version)) 
[11:01:02.702]                             version <- utils::packageVersion("future")
[11:01:02.702]                         }
[11:01:02.702]                         else {
[11:01:02.702]                           version <- NULL
[11:01:02.702]                         }
[11:01:02.702]                         if (!has_future || version < "1.8.0") {
[11:01:02.702]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:02.702]                             "", base::R.version$version.string), 
[11:01:02.702]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:02.702]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:02.702]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:02.702]                               "release", "version")], collapse = " "), 
[11:01:02.702]                             hostname = base::Sys.info()[["nodename"]])
[11:01:02.702]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:02.702]                             info)
[11:01:02.702]                           info <- base::paste(info, collapse = "; ")
[11:01:02.702]                           if (!has_future) {
[11:01:02.702]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:02.702]                               info)
[11:01:02.702]                           }
[11:01:02.702]                           else {
[11:01:02.702]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:02.702]                               info, version)
[11:01:02.702]                           }
[11:01:02.702]                           base::stop(msg)
[11:01:02.702]                         }
[11:01:02.702]                       })
[11:01:02.702]                     }
[11:01:02.702]                     base::local({
[11:01:02.702]                       for (pkg in "future") {
[11:01:02.702]                         base::loadNamespace(pkg)
[11:01:02.702]                         base::library(pkg, character.only = TRUE)
[11:01:02.702]                       }
[11:01:02.702]                     })
[11:01:02.702]                   }
[11:01:02.702]                   ...future.strategy.old <- future::plan("list")
[11:01:02.702]                   options(future.plan = NULL)
[11:01:02.702]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:02.702]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:02.702]                 }
[11:01:02.702]                 ...future.workdir <- getwd()
[11:01:02.702]             }
[11:01:02.702]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:02.702]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:02.702]         }
[11:01:02.702]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:02.702]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:02.702]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:02.702]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:02.702]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:02.702]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:02.702]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:02.702]             base::names(...future.oldOptions))
[11:01:02.702]     }
[11:01:02.702]     if (FALSE) {
[11:01:02.702]     }
[11:01:02.702]     else {
[11:01:02.702]         if (TRUE) {
[11:01:02.702]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:02.702]                 open = "w")
[11:01:02.702]         }
[11:01:02.702]         else {
[11:01:02.702]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:02.702]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:02.702]         }
[11:01:02.702]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:02.702]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:02.702]             base::sink(type = "output", split = FALSE)
[11:01:02.702]             base::close(...future.stdout)
[11:01:02.702]         }, add = TRUE)
[11:01:02.702]     }
[11:01:02.702]     ...future.frame <- base::sys.nframe()
[11:01:02.702]     ...future.conditions <- base::list()
[11:01:02.702]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:02.702]     if (FALSE) {
[11:01:02.702]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:02.702]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:02.702]     }
[11:01:02.702]     ...future.result <- base::tryCatch({
[11:01:02.702]         base::withCallingHandlers({
[11:01:02.702]             ...future.value <- base::withVisible(base::local({
[11:01:02.702]                 message(sprintf("Calculating tile #%d of %d ...", 
[11:01:02.702]                   ii, n), appendLF = FALSE)
[11:01:02.702]                 fit <- mandelbrot(C)
[11:01:02.702]                 delay(fit)
[11:01:02.702]                 message(" done")
[11:01:02.702]                 fit
[11:01:02.702]             }))
[11:01:02.702]             future::FutureResult(value = ...future.value$value, 
[11:01:02.702]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:02.702]                   ...future.rng), globalenv = if (FALSE) 
[11:01:02.702]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:02.702]                     ...future.globalenv.names))
[11:01:02.702]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:02.702]         }, condition = base::local({
[11:01:02.702]             c <- base::c
[11:01:02.702]             inherits <- base::inherits
[11:01:02.702]             invokeRestart <- base::invokeRestart
[11:01:02.702]             length <- base::length
[11:01:02.702]             list <- base::list
[11:01:02.702]             seq.int <- base::seq.int
[11:01:02.702]             signalCondition <- base::signalCondition
[11:01:02.702]             sys.calls <- base::sys.calls
[11:01:02.702]             `[[` <- base::`[[`
[11:01:02.702]             `+` <- base::`+`
[11:01:02.702]             `<<-` <- base::`<<-`
[11:01:02.702]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:02.702]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:02.702]                   3L)]
[11:01:02.702]             }
[11:01:02.702]             function(cond) {
[11:01:02.702]                 is_error <- inherits(cond, "error")
[11:01:02.702]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:02.702]                   NULL)
[11:01:02.702]                 if (is_error) {
[11:01:02.702]                   sessionInformation <- function() {
[11:01:02.702]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:02.702]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:02.702]                       search = base::search(), system = base::Sys.info())
[11:01:02.702]                   }
[11:01:02.702]                   ...future.conditions[[length(...future.conditions) + 
[11:01:02.702]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:02.702]                     cond$call), session = sessionInformation(), 
[11:01:02.702]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:02.702]                   signalCondition(cond)
[11:01:02.702]                 }
[11:01:02.702]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:02.702]                 "immediateCondition"))) {
[11:01:02.702]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:02.702]                   ...future.conditions[[length(...future.conditions) + 
[11:01:02.702]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:02.702]                   if (TRUE && !signal) {
[11:01:02.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:02.702]                     {
[11:01:02.702]                       inherits <- base::inherits
[11:01:02.702]                       invokeRestart <- base::invokeRestart
[11:01:02.702]                       is.null <- base::is.null
[11:01:02.702]                       muffled <- FALSE
[11:01:02.702]                       if (inherits(cond, "message")) {
[11:01:02.702]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:02.702]                         if (muffled) 
[11:01:02.702]                           invokeRestart("muffleMessage")
[11:01:02.702]                       }
[11:01:02.702]                       else if (inherits(cond, "warning")) {
[11:01:02.702]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:02.702]                         if (muffled) 
[11:01:02.702]                           invokeRestart("muffleWarning")
[11:01:02.702]                       }
[11:01:02.702]                       else if (inherits(cond, "condition")) {
[11:01:02.702]                         if (!is.null(pattern)) {
[11:01:02.702]                           computeRestarts <- base::computeRestarts
[11:01:02.702]                           grepl <- base::grepl
[11:01:02.702]                           restarts <- computeRestarts(cond)
[11:01:02.702]                           for (restart in restarts) {
[11:01:02.702]                             name <- restart$name
[11:01:02.702]                             if (is.null(name)) 
[11:01:02.702]                               next
[11:01:02.702]                             if (!grepl(pattern, name)) 
[11:01:02.702]                               next
[11:01:02.702]                             invokeRestart(restart)
[11:01:02.702]                             muffled <- TRUE
[11:01:02.702]                             break
[11:01:02.702]                           }
[11:01:02.702]                         }
[11:01:02.702]                       }
[11:01:02.702]                       invisible(muffled)
[11:01:02.702]                     }
[11:01:02.702]                     muffleCondition(cond, pattern = "^muffle")
[11:01:02.702]                   }
[11:01:02.702]                 }
[11:01:02.702]                 else {
[11:01:02.702]                   if (TRUE) {
[11:01:02.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:02.702]                     {
[11:01:02.702]                       inherits <- base::inherits
[11:01:02.702]                       invokeRestart <- base::invokeRestart
[11:01:02.702]                       is.null <- base::is.null
[11:01:02.702]                       muffled <- FALSE
[11:01:02.702]                       if (inherits(cond, "message")) {
[11:01:02.702]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:02.702]                         if (muffled) 
[11:01:02.702]                           invokeRestart("muffleMessage")
[11:01:02.702]                       }
[11:01:02.702]                       else if (inherits(cond, "warning")) {
[11:01:02.702]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:02.702]                         if (muffled) 
[11:01:02.702]                           invokeRestart("muffleWarning")
[11:01:02.702]                       }
[11:01:02.702]                       else if (inherits(cond, "condition")) {
[11:01:02.702]                         if (!is.null(pattern)) {
[11:01:02.702]                           computeRestarts <- base::computeRestarts
[11:01:02.702]                           grepl <- base::grepl
[11:01:02.702]                           restarts <- computeRestarts(cond)
[11:01:02.702]                           for (restart in restarts) {
[11:01:02.702]                             name <- restart$name
[11:01:02.702]                             if (is.null(name)) 
[11:01:02.702]                               next
[11:01:02.702]                             if (!grepl(pattern, name)) 
[11:01:02.702]                               next
[11:01:02.702]                             invokeRestart(restart)
[11:01:02.702]                             muffled <- TRUE
[11:01:02.702]                             break
[11:01:02.702]                           }
[11:01:02.702]                         }
[11:01:02.702]                       }
[11:01:02.702]                       invisible(muffled)
[11:01:02.702]                     }
[11:01:02.702]                     muffleCondition(cond, pattern = "^muffle")
[11:01:02.702]                   }
[11:01:02.702]                 }
[11:01:02.702]             }
[11:01:02.702]         }))
[11:01:02.702]     }, error = function(ex) {
[11:01:02.702]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:02.702]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:02.702]                 ...future.rng), started = ...future.startTime, 
[11:01:02.702]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:02.702]             version = "1.8"), class = "FutureResult")
[11:01:02.702]     }, finally = {
[11:01:02.702]         if (!identical(...future.workdir, getwd())) 
[11:01:02.702]             setwd(...future.workdir)
[11:01:02.702]         {
[11:01:02.702]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:02.702]                 ...future.oldOptions$nwarnings <- NULL
[11:01:02.702]             }
[11:01:02.702]             base::options(...future.oldOptions)
[11:01:02.702]             if (.Platform$OS.type == "windows") {
[11:01:02.702]                 old_names <- names(...future.oldEnvVars)
[11:01:02.702]                 envs <- base::Sys.getenv()
[11:01:02.702]                 names <- names(envs)
[11:01:02.702]                 common <- intersect(names, old_names)
[11:01:02.702]                 added <- setdiff(names, old_names)
[11:01:02.702]                 removed <- setdiff(old_names, names)
[11:01:02.702]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:02.702]                   envs[common]]
[11:01:02.702]                 NAMES <- toupper(changed)
[11:01:02.702]                 args <- list()
[11:01:02.702]                 for (kk in seq_along(NAMES)) {
[11:01:02.702]                   name <- changed[[kk]]
[11:01:02.702]                   NAME <- NAMES[[kk]]
[11:01:02.702]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.702]                     next
[11:01:02.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:02.702]                 }
[11:01:02.702]                 NAMES <- toupper(added)
[11:01:02.702]                 for (kk in seq_along(NAMES)) {
[11:01:02.702]                   name <- added[[kk]]
[11:01:02.702]                   NAME <- NAMES[[kk]]
[11:01:02.702]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.702]                     next
[11:01:02.702]                   args[[name]] <- ""
[11:01:02.702]                 }
[11:01:02.702]                 NAMES <- toupper(removed)
[11:01:02.702]                 for (kk in seq_along(NAMES)) {
[11:01:02.702]                   name <- removed[[kk]]
[11:01:02.702]                   NAME <- NAMES[[kk]]
[11:01:02.702]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.702]                     next
[11:01:02.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:02.702]                 }
[11:01:02.702]                 if (length(args) > 0) 
[11:01:02.702]                   base::do.call(base::Sys.setenv, args = args)
[11:01:02.702]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:02.702]             }
[11:01:02.702]             else {
[11:01:02.702]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:02.702]             }
[11:01:02.702]             {
[11:01:02.702]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:02.702]                   0L) {
[11:01:02.702]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:02.702]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:02.702]                   base::options(opts)
[11:01:02.702]                 }
[11:01:02.702]                 {
[11:01:02.702]                   {
[11:01:02.702]                     NULL
[11:01:02.702]                     RNGkind("Mersenne-Twister")
[11:01:02.702]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:02.702]                       inherits = FALSE)
[11:01:02.702]                   }
[11:01:02.702]                   options(future.plan = NULL)
[11:01:02.702]                   if (is.na(NA_character_)) 
[11:01:02.702]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:02.702]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:02.702]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:02.702]                     .init = FALSE)
[11:01:02.702]                 }
[11:01:02.702]             }
[11:01:02.702]         }
[11:01:02.702]     })
[11:01:02.702]     if (TRUE) {
[11:01:02.702]         base::sink(type = "output", split = FALSE)
[11:01:02.702]         if (TRUE) {
[11:01:02.702]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:02.702]         }
[11:01:02.702]         else {
[11:01:02.702]             ...future.result["stdout"] <- base::list(NULL)
[11:01:02.702]         }
[11:01:02.702]         base::close(...future.stdout)
[11:01:02.702]         ...future.stdout <- NULL
[11:01:02.702]     }
[11:01:02.702]     ...future.result$conditions <- ...future.conditions
[11:01:02.702]     ...future.result$finished <- base::Sys.time()
[11:01:02.702]     ...future.result
[11:01:02.702] }
[11:01:02.704] assign_globals() ...
[11:01:02.704] List of 4
[11:01:02.704]  $ ii   : int 2
[11:01:02.704]  $ n    : int 4
[11:01:02.704]  $ C    : cplx [1:25, 1:25] -0.719-1.5i -0.719-1.44i -0.719-1.38i ...
[11:01:02.704]   ..- attr(*, "region")=List of 2
[11:01:02.704]   .. ..$ xrange: num [1:2] -0.719 0.75
[11:01:02.704]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[11:01:02.704]   ..- attr(*, "tile")= int [1:2] 1 2
[11:01:02.704]  $ delay:function (counts)  
[11:01:02.704]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[11:01:02.704]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x564914762e40> 
[11:01:02.704]  - attr(*, "where")=List of 4
[11:01:02.704]   ..$ ii   :<environment: R_EmptyEnv> 
[11:01:02.704]   ..$ n    :<environment: R_EmptyEnv> 
[11:01:02.704]   ..$ C    :<environment: R_EmptyEnv> 
[11:01:02.704]   ..$ delay:<environment: R_EmptyEnv> 
[11:01:02.704]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:02.704]  - attr(*, "resolved")= logi FALSE
[11:01:02.704]  - attr(*, "total_size")= num 58781
[11:01:02.704]  - attr(*, "already-done")= logi TRUE
[11:01:02.710] - copied ‘ii’ to environment
[11:01:02.710] - copied ‘n’ to environment
[11:01:02.710] - copied ‘C’ to environment
[11:01:02.710] - reassign environment for ‘delay’
[11:01:02.710] - copied ‘delay’ to environment
[11:01:02.710] assign_globals() ... done
[11:01:02.710] plan(): Setting new future strategy stack:
[11:01:02.710] List of future strategies:
[11:01:02.710] 1. sequential:
[11:01:02.710]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:02.710]    - tweaked: FALSE
[11:01:02.710]    - call: NULL
[11:01:02.711] plan(): nbrOfWorkers() = 1
[11:01:02.758] plan(): Setting new future strategy stack:
[11:01:02.758] List of future strategies:
[11:01:02.758] 1. sequential:
[11:01:02.758]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:02.758]    - tweaked: FALSE
[11:01:02.758]    - call: plan(strategy)
[11:01:02.758] plan(): nbrOfWorkers() = 1
[11:01:02.759] SequentialFuture started (and completed)
[11:01:02.759] signalConditions() ...
[11:01:02.759]  - include = ‘immediateCondition’
[11:01:02.759]  - exclude = 
[11:01:02.759]  - resignal = FALSE
[11:01:02.759]  - Number of conditions: 2
[11:01:02.759] signalConditions() ... done
[11:01:02.759] - Launch lazy future ... done
[11:01:02.759] run() for ‘SequentialFuture’ ... done
[11:01:02.759] - run() ... done
[11:01:02.759] - resolved() ...
[11:01:02.759] resolved() for ‘SequentialFuture’ ...
[11:01:02.760] - state: ‘finished’
[11:01:02.760] - run: TRUE
[11:01:02.760] - result: ‘FutureResult’
[11:01:02.760] resolved() for ‘SequentialFuture’ ... done
[11:01:02.760] - resolved: TRUE
[11:01:02.760] - resolved() ... done
[11:01:02.760] resolved() for ‘SequentialFuture’ ... done
Plotting tile #2 of 4 ...
[11:01:02.760] signalConditions() ...
[11:01:02.760]  - include = ‘immediateCondition’
[11:01:02.760]  - exclude = 
[11:01:02.760]  - resignal = FALSE
[11:01:02.761]  - Number of conditions: 2
[11:01:02.761] signalConditions() ... done
[11:01:02.761] Future state: ‘finished’
[11:01:02.761] signalConditions() ...
[11:01:02.761]  - include = ‘condition’
[11:01:02.761]  - exclude = ‘immediateCondition’
[11:01:02.761]  - resignal = TRUE
[11:01:02.761]  - Number of conditions: 2
[11:01:02.761]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[11:01:02.761]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[11:01:02.761] signalConditions() ... done
[11:01:02.762] resolved() for ‘Future’ ...
[11:01:02.762] - state: ‘created’
[11:01:02.762] - run: TRUE
[11:01:02.762] - run() ...
[11:01:02.762] run() for ‘Future’ ...
[11:01:02.762] - state: ‘created’
[11:01:02.763] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:02.763] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:02.763] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:02.763]   - Field: ‘label’
[11:01:02.763]   - Field: ‘local’
[11:01:02.763]   - Field: ‘owner’
[11:01:02.763]   - Field: ‘envir’
[11:01:02.763]   - Field: ‘packages’
[11:01:02.763]   - Field: ‘gc’
[11:01:02.764]   - Field: ‘conditions’
[11:01:02.764]   - Field: ‘expr’
[11:01:02.764]   - Field: ‘uuid’
[11:01:02.764]   - Field: ‘seed’
[11:01:02.764]   - Field: ‘version’
[11:01:02.764]   - Field: ‘result’
[11:01:02.764]   - Field: ‘asynchronous’
[11:01:02.764]   - Field: ‘calls’
[11:01:02.764]   - Field: ‘globals’
[11:01:02.764]   - Field: ‘stdout’
[11:01:02.764]   - Field: ‘earlySignal’
[11:01:02.764]   - Field: ‘lazy’
[11:01:02.765]   - Field: ‘state’
[11:01:02.765] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:02.765] - Launch lazy future ...
[11:01:02.765] Packages needed by the future expression (n = 1): ‘future’
[11:01:02.765] Packages needed by future strategies (n = 0): <none>
[11:01:02.765] {
[11:01:02.765]     {
[11:01:02.765]         {
[11:01:02.765]             ...future.startTime <- base::Sys.time()
[11:01:02.765]             {
[11:01:02.765]                 {
[11:01:02.765]                   {
[11:01:02.765]                     {
[11:01:02.765]                       base::local({
[11:01:02.765]                         has_future <- base::requireNamespace("future", 
[11:01:02.765]                           quietly = TRUE)
[11:01:02.765]                         if (has_future) {
[11:01:02.765]                           ns <- base::getNamespace("future")
[11:01:02.765]                           version <- ns[[".package"]][["version"]]
[11:01:02.765]                           if (is.null(version)) 
[11:01:02.765]                             version <- utils::packageVersion("future")
[11:01:02.765]                         }
[11:01:02.765]                         else {
[11:01:02.765]                           version <- NULL
[11:01:02.765]                         }
[11:01:02.765]                         if (!has_future || version < "1.8.0") {
[11:01:02.765]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:02.765]                             "", base::R.version$version.string), 
[11:01:02.765]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:02.765]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:02.765]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:02.765]                               "release", "version")], collapse = " "), 
[11:01:02.765]                             hostname = base::Sys.info()[["nodename"]])
[11:01:02.765]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:02.765]                             info)
[11:01:02.765]                           info <- base::paste(info, collapse = "; ")
[11:01:02.765]                           if (!has_future) {
[11:01:02.765]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:02.765]                               info)
[11:01:02.765]                           }
[11:01:02.765]                           else {
[11:01:02.765]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:02.765]                               info, version)
[11:01:02.765]                           }
[11:01:02.765]                           base::stop(msg)
[11:01:02.765]                         }
[11:01:02.765]                       })
[11:01:02.765]                     }
[11:01:02.765]                     base::local({
[11:01:02.765]                       for (pkg in "future") {
[11:01:02.765]                         base::loadNamespace(pkg)
[11:01:02.765]                         base::library(pkg, character.only = TRUE)
[11:01:02.765]                       }
[11:01:02.765]                     })
[11:01:02.765]                   }
[11:01:02.765]                   ...future.strategy.old <- future::plan("list")
[11:01:02.765]                   options(future.plan = NULL)
[11:01:02.765]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:02.765]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:02.765]                 }
[11:01:02.765]                 ...future.workdir <- getwd()
[11:01:02.765]             }
[11:01:02.765]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:02.765]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:02.765]         }
[11:01:02.765]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:02.765]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:02.765]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:02.765]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:02.765]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:02.765]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:02.765]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:02.765]             base::names(...future.oldOptions))
[11:01:02.765]     }
[11:01:02.765]     if (FALSE) {
[11:01:02.765]     }
[11:01:02.765]     else {
[11:01:02.765]         if (TRUE) {
[11:01:02.765]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:02.765]                 open = "w")
[11:01:02.765]         }
[11:01:02.765]         else {
[11:01:02.765]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:02.765]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:02.765]         }
[11:01:02.765]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:02.765]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:02.765]             base::sink(type = "output", split = FALSE)
[11:01:02.765]             base::close(...future.stdout)
[11:01:02.765]         }, add = TRUE)
[11:01:02.765]     }
[11:01:02.765]     ...future.frame <- base::sys.nframe()
[11:01:02.765]     ...future.conditions <- base::list()
[11:01:02.765]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:02.765]     if (FALSE) {
[11:01:02.765]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:02.765]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:02.765]     }
[11:01:02.765]     ...future.result <- base::tryCatch({
[11:01:02.765]         base::withCallingHandlers({
[11:01:02.765]             ...future.value <- base::withVisible(base::local({
[11:01:02.765]                 message(sprintf("Calculating tile #%d of %d ...", 
[11:01:02.765]                   ii, n), appendLF = FALSE)
[11:01:02.765]                 fit <- mandelbrot(C)
[11:01:02.765]                 delay(fit)
[11:01:02.765]                 message(" done")
[11:01:02.765]                 fit
[11:01:02.765]             }))
[11:01:02.765]             future::FutureResult(value = ...future.value$value, 
[11:01:02.765]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:02.765]                   ...future.rng), globalenv = if (FALSE) 
[11:01:02.765]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:02.765]                     ...future.globalenv.names))
[11:01:02.765]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:02.765]         }, condition = base::local({
[11:01:02.765]             c <- base::c
[11:01:02.765]             inherits <- base::inherits
[11:01:02.765]             invokeRestart <- base::invokeRestart
[11:01:02.765]             length <- base::length
[11:01:02.765]             list <- base::list
[11:01:02.765]             seq.int <- base::seq.int
[11:01:02.765]             signalCondition <- base::signalCondition
[11:01:02.765]             sys.calls <- base::sys.calls
[11:01:02.765]             `[[` <- base::`[[`
[11:01:02.765]             `+` <- base::`+`
[11:01:02.765]             `<<-` <- base::`<<-`
[11:01:02.765]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:02.765]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:02.765]                   3L)]
[11:01:02.765]             }
[11:01:02.765]             function(cond) {
[11:01:02.765]                 is_error <- inherits(cond, "error")
[11:01:02.765]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:02.765]                   NULL)
[11:01:02.765]                 if (is_error) {
[11:01:02.765]                   sessionInformation <- function() {
[11:01:02.765]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:02.765]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:02.765]                       search = base::search(), system = base::Sys.info())
[11:01:02.765]                   }
[11:01:02.765]                   ...future.conditions[[length(...future.conditions) + 
[11:01:02.765]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:02.765]                     cond$call), session = sessionInformation(), 
[11:01:02.765]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:02.765]                   signalCondition(cond)
[11:01:02.765]                 }
[11:01:02.765]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:02.765]                 "immediateCondition"))) {
[11:01:02.765]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:02.765]                   ...future.conditions[[length(...future.conditions) + 
[11:01:02.765]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:02.765]                   if (TRUE && !signal) {
[11:01:02.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:02.765]                     {
[11:01:02.765]                       inherits <- base::inherits
[11:01:02.765]                       invokeRestart <- base::invokeRestart
[11:01:02.765]                       is.null <- base::is.null
[11:01:02.765]                       muffled <- FALSE
[11:01:02.765]                       if (inherits(cond, "message")) {
[11:01:02.765]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:02.765]                         if (muffled) 
[11:01:02.765]                           invokeRestart("muffleMessage")
[11:01:02.765]                       }
[11:01:02.765]                       else if (inherits(cond, "warning")) {
[11:01:02.765]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:02.765]                         if (muffled) 
[11:01:02.765]                           invokeRestart("muffleWarning")
[11:01:02.765]                       }
[11:01:02.765]                       else if (inherits(cond, "condition")) {
[11:01:02.765]                         if (!is.null(pattern)) {
[11:01:02.765]                           computeRestarts <- base::computeRestarts
[11:01:02.765]                           grepl <- base::grepl
[11:01:02.765]                           restarts <- computeRestarts(cond)
[11:01:02.765]                           for (restart in restarts) {
[11:01:02.765]                             name <- restart$name
[11:01:02.765]                             if (is.null(name)) 
[11:01:02.765]                               next
[11:01:02.765]                             if (!grepl(pattern, name)) 
[11:01:02.765]                               next
[11:01:02.765]                             invokeRestart(restart)
[11:01:02.765]                             muffled <- TRUE
[11:01:02.765]                             break
[11:01:02.765]                           }
[11:01:02.765]                         }
[11:01:02.765]                       }
[11:01:02.765]                       invisible(muffled)
[11:01:02.765]                     }
[11:01:02.765]                     muffleCondition(cond, pattern = "^muffle")
[11:01:02.765]                   }
[11:01:02.765]                 }
[11:01:02.765]                 else {
[11:01:02.765]                   if (TRUE) {
[11:01:02.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:02.765]                     {
[11:01:02.765]                       inherits <- base::inherits
[11:01:02.765]                       invokeRestart <- base::invokeRestart
[11:01:02.765]                       is.null <- base::is.null
[11:01:02.765]                       muffled <- FALSE
[11:01:02.765]                       if (inherits(cond, "message")) {
[11:01:02.765]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:02.765]                         if (muffled) 
[11:01:02.765]                           invokeRestart("muffleMessage")
[11:01:02.765]                       }
[11:01:02.765]                       else if (inherits(cond, "warning")) {
[11:01:02.765]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:02.765]                         if (muffled) 
[11:01:02.765]                           invokeRestart("muffleWarning")
[11:01:02.765]                       }
[11:01:02.765]                       else if (inherits(cond, "condition")) {
[11:01:02.765]                         if (!is.null(pattern)) {
[11:01:02.765]                           computeRestarts <- base::computeRestarts
[11:01:02.765]                           grepl <- base::grepl
[11:01:02.765]                           restarts <- computeRestarts(cond)
[11:01:02.765]                           for (restart in restarts) {
[11:01:02.765]                             name <- restart$name
[11:01:02.765]                             if (is.null(name)) 
[11:01:02.765]                               next
[11:01:02.765]                             if (!grepl(pattern, name)) 
[11:01:02.765]                               next
[11:01:02.765]                             invokeRestart(restart)
[11:01:02.765]                             muffled <- TRUE
[11:01:02.765]                             break
[11:01:02.765]                           }
[11:01:02.765]                         }
[11:01:02.765]                       }
[11:01:02.765]                       invisible(muffled)
[11:01:02.765]                     }
[11:01:02.765]                     muffleCondition(cond, pattern = "^muffle")
[11:01:02.765]                   }
[11:01:02.765]                 }
[11:01:02.765]             }
[11:01:02.765]         }))
[11:01:02.765]     }, error = function(ex) {
[11:01:02.765]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:02.765]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:02.765]                 ...future.rng), started = ...future.startTime, 
[11:01:02.765]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:02.765]             version = "1.8"), class = "FutureResult")
[11:01:02.765]     }, finally = {
[11:01:02.765]         if (!identical(...future.workdir, getwd())) 
[11:01:02.765]             setwd(...future.workdir)
[11:01:02.765]         {
[11:01:02.765]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:02.765]                 ...future.oldOptions$nwarnings <- NULL
[11:01:02.765]             }
[11:01:02.765]             base::options(...future.oldOptions)
[11:01:02.765]             if (.Platform$OS.type == "windows") {
[11:01:02.765]                 old_names <- names(...future.oldEnvVars)
[11:01:02.765]                 envs <- base::Sys.getenv()
[11:01:02.765]                 names <- names(envs)
[11:01:02.765]                 common <- intersect(names, old_names)
[11:01:02.765]                 added <- setdiff(names, old_names)
[11:01:02.765]                 removed <- setdiff(old_names, names)
[11:01:02.765]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:02.765]                   envs[common]]
[11:01:02.765]                 NAMES <- toupper(changed)
[11:01:02.765]                 args <- list()
[11:01:02.765]                 for (kk in seq_along(NAMES)) {
[11:01:02.765]                   name <- changed[[kk]]
[11:01:02.765]                   NAME <- NAMES[[kk]]
[11:01:02.765]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.765]                     next
[11:01:02.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:02.765]                 }
[11:01:02.765]                 NAMES <- toupper(added)
[11:01:02.765]                 for (kk in seq_along(NAMES)) {
[11:01:02.765]                   name <- added[[kk]]
[11:01:02.765]                   NAME <- NAMES[[kk]]
[11:01:02.765]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.765]                     next
[11:01:02.765]                   args[[name]] <- ""
[11:01:02.765]                 }
[11:01:02.765]                 NAMES <- toupper(removed)
[11:01:02.765]                 for (kk in seq_along(NAMES)) {
[11:01:02.765]                   name <- removed[[kk]]
[11:01:02.765]                   NAME <- NAMES[[kk]]
[11:01:02.765]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.765]                     next
[11:01:02.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:02.765]                 }
[11:01:02.765]                 if (length(args) > 0) 
[11:01:02.765]                   base::do.call(base::Sys.setenv, args = args)
[11:01:02.765]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:02.765]             }
[11:01:02.765]             else {
[11:01:02.765]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:02.765]             }
[11:01:02.765]             {
[11:01:02.765]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:02.765]                   0L) {
[11:01:02.765]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:02.765]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:02.765]                   base::options(opts)
[11:01:02.765]                 }
[11:01:02.765]                 {
[11:01:02.765]                   {
[11:01:02.765]                     NULL
[11:01:02.765]                     RNGkind("Mersenne-Twister")
[11:01:02.765]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:02.765]                       inherits = FALSE)
[11:01:02.765]                   }
[11:01:02.765]                   options(future.plan = NULL)
[11:01:02.765]                   if (is.na(NA_character_)) 
[11:01:02.765]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:02.765]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:02.765]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:02.765]                     .init = FALSE)
[11:01:02.765]                 }
[11:01:02.765]             }
[11:01:02.765]         }
[11:01:02.765]     })
[11:01:02.765]     if (TRUE) {
[11:01:02.765]         base::sink(type = "output", split = FALSE)
[11:01:02.765]         if (TRUE) {
[11:01:02.765]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:02.765]         }
[11:01:02.765]         else {
[11:01:02.765]             ...future.result["stdout"] <- base::list(NULL)
[11:01:02.765]         }
[11:01:02.765]         base::close(...future.stdout)
[11:01:02.765]         ...future.stdout <- NULL
[11:01:02.765]     }
[11:01:02.765]     ...future.result$conditions <- ...future.conditions
[11:01:02.765]     ...future.result$finished <- base::Sys.time()
[11:01:02.765]     ...future.result
[11:01:02.765] }
[11:01:02.767] assign_globals() ...
[11:01:02.767] List of 4
[11:01:02.767]  $ ii   : int 3
[11:01:02.767]  $ n    : int 4
[11:01:02.767]  $ C    : cplx [1:25, 1:25] -2.25+0.0306i -2.25+0.0918i -2.25+0.1531i ...
[11:01:02.767]   ..- attr(*, "region")=List of 2
[11:01:02.767]   .. ..$ xrange: num [1:2] -2.25 -0.781
[11:01:02.767]   .. ..$ yrange: num [1:2] 0.0306 1.5
[11:01:02.767]   ..- attr(*, "tile")= int [1:2] 2 1
[11:01:02.767]  $ delay:function (counts)  
[11:01:02.767]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[11:01:02.767]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x564914762e40> 
[11:01:02.767]  - attr(*, "where")=List of 4
[11:01:02.767]   ..$ ii   :<environment: R_EmptyEnv> 
[11:01:02.767]   ..$ n    :<environment: R_EmptyEnv> 
[11:01:02.767]   ..$ C    :<environment: R_EmptyEnv> 
[11:01:02.767]   ..$ delay:<environment: R_EmptyEnv> 
[11:01:02.767]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:02.767]  - attr(*, "resolved")= logi FALSE
[11:01:02.767]  - attr(*, "total_size")= num 58781
[11:01:02.767]  - attr(*, "already-done")= logi TRUE
[11:01:02.773] - copied ‘ii’ to environment
[11:01:02.773] - copied ‘n’ to environment
[11:01:02.773] - copied ‘C’ to environment
[11:01:02.773] - reassign environment for ‘delay’
[11:01:02.773] - copied ‘delay’ to environment
[11:01:02.774] assign_globals() ... done
[11:01:02.774] plan(): Setting new future strategy stack:
[11:01:02.774] List of future strategies:
[11:01:02.774] 1. sequential:
[11:01:02.774]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:02.774]    - tweaked: FALSE
[11:01:02.774]    - call: NULL
[11:01:02.774] plan(): nbrOfWorkers() = 1
[11:01:02.789] plan(): Setting new future strategy stack:
[11:01:02.789] List of future strategies:
[11:01:02.789] 1. sequential:
[11:01:02.789]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:02.789]    - tweaked: FALSE
[11:01:02.789]    - call: plan(strategy)
[11:01:02.789] plan(): nbrOfWorkers() = 1
[11:01:02.789] SequentialFuture started (and completed)
[11:01:02.789] signalConditions() ...
[11:01:02.790]  - include = ‘immediateCondition’
[11:01:02.790]  - exclude = 
[11:01:02.790]  - resignal = FALSE
[11:01:02.790]  - Number of conditions: 2
[11:01:02.790] signalConditions() ... done
[11:01:02.790] - Launch lazy future ... done
[11:01:02.790] run() for ‘SequentialFuture’ ... done
[11:01:02.790] - run() ... done
[11:01:02.790] - resolved() ...
[11:01:02.790] resolved() for ‘SequentialFuture’ ...
[11:01:02.790] - state: ‘finished’
[11:01:02.791] - run: TRUE
[11:01:02.791] - result: ‘FutureResult’
[11:01:02.791] resolved() for ‘SequentialFuture’ ... done
[11:01:02.791] - resolved: TRUE
[11:01:02.791] - resolved() ... done
[11:01:02.791] resolved() for ‘SequentialFuture’ ... done
Plotting tile #3 of 4 ...
[11:01:02.791] signalConditions() ...
[11:01:02.791]  - include = ‘immediateCondition’
[11:01:02.791]  - exclude = 
[11:01:02.791]  - resignal = FALSE
[11:01:02.791]  - Number of conditions: 2
[11:01:02.791] signalConditions() ... done
[11:01:02.792] Future state: ‘finished’
[11:01:02.792] signalConditions() ...
[11:01:02.792]  - include = ‘condition’
[11:01:02.792]  - exclude = ‘immediateCondition’
[11:01:02.792]  - resignal = TRUE
[11:01:02.792]  - Number of conditions: 2
[11:01:02.792]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[11:01:02.792]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[11:01:02.792] signalConditions() ... done
[11:01:02.793] resolved() for ‘Future’ ...
[11:01:02.793] - state: ‘created’
[11:01:02.793] - run: TRUE
[11:01:02.793] - run() ...
[11:01:02.793] run() for ‘Future’ ...
[11:01:02.793] - state: ‘created’
[11:01:02.793] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:02.794] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:02.794] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:02.794]   - Field: ‘label’
[11:01:02.794]   - Field: ‘local’
[11:01:02.794]   - Field: ‘owner’
[11:01:02.794]   - Field: ‘envir’
[11:01:02.794]   - Field: ‘packages’
[11:01:02.794]   - Field: ‘gc’
[11:01:02.794]   - Field: ‘conditions’
[11:01:02.795]   - Field: ‘expr’
[11:01:02.795]   - Field: ‘uuid’
[11:01:02.795]   - Field: ‘seed’
[11:01:02.795]   - Field: ‘version’
[11:01:02.795]   - Field: ‘result’
[11:01:02.795]   - Field: ‘asynchronous’
[11:01:02.795]   - Field: ‘calls’
[11:01:02.795]   - Field: ‘globals’
[11:01:02.795]   - Field: ‘stdout’
[11:01:02.795]   - Field: ‘earlySignal’
[11:01:02.795]   - Field: ‘lazy’
[11:01:02.795]   - Field: ‘state’
[11:01:02.796] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:02.796] - Launch lazy future ...
[11:01:02.796] Packages needed by the future expression (n = 1): ‘future’
[11:01:02.796] Packages needed by future strategies (n = 0): <none>
[11:01:02.796] {
[11:01:02.796]     {
[11:01:02.796]         {
[11:01:02.796]             ...future.startTime <- base::Sys.time()
[11:01:02.796]             {
[11:01:02.796]                 {
[11:01:02.796]                   {
[11:01:02.796]                     {
[11:01:02.796]                       base::local({
[11:01:02.796]                         has_future <- base::requireNamespace("future", 
[11:01:02.796]                           quietly = TRUE)
[11:01:02.796]                         if (has_future) {
[11:01:02.796]                           ns <- base::getNamespace("future")
[11:01:02.796]                           version <- ns[[".package"]][["version"]]
[11:01:02.796]                           if (is.null(version)) 
[11:01:02.796]                             version <- utils::packageVersion("future")
[11:01:02.796]                         }
[11:01:02.796]                         else {
[11:01:02.796]                           version <- NULL
[11:01:02.796]                         }
[11:01:02.796]                         if (!has_future || version < "1.8.0") {
[11:01:02.796]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:02.796]                             "", base::R.version$version.string), 
[11:01:02.796]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:02.796]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:02.796]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:02.796]                               "release", "version")], collapse = " "), 
[11:01:02.796]                             hostname = base::Sys.info()[["nodename"]])
[11:01:02.796]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:02.796]                             info)
[11:01:02.796]                           info <- base::paste(info, collapse = "; ")
[11:01:02.796]                           if (!has_future) {
[11:01:02.796]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:02.796]                               info)
[11:01:02.796]                           }
[11:01:02.796]                           else {
[11:01:02.796]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:02.796]                               info, version)
[11:01:02.796]                           }
[11:01:02.796]                           base::stop(msg)
[11:01:02.796]                         }
[11:01:02.796]                       })
[11:01:02.796]                     }
[11:01:02.796]                     base::local({
[11:01:02.796]                       for (pkg in "future") {
[11:01:02.796]                         base::loadNamespace(pkg)
[11:01:02.796]                         base::library(pkg, character.only = TRUE)
[11:01:02.796]                       }
[11:01:02.796]                     })
[11:01:02.796]                   }
[11:01:02.796]                   ...future.strategy.old <- future::plan("list")
[11:01:02.796]                   options(future.plan = NULL)
[11:01:02.796]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:02.796]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:02.796]                 }
[11:01:02.796]                 ...future.workdir <- getwd()
[11:01:02.796]             }
[11:01:02.796]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:02.796]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:02.796]         }
[11:01:02.796]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:02.796]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:02.796]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:02.796]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:02.796]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:02.796]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:02.796]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:02.796]             base::names(...future.oldOptions))
[11:01:02.796]     }
[11:01:02.796]     if (FALSE) {
[11:01:02.796]     }
[11:01:02.796]     else {
[11:01:02.796]         if (TRUE) {
[11:01:02.796]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:02.796]                 open = "w")
[11:01:02.796]         }
[11:01:02.796]         else {
[11:01:02.796]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:02.796]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:02.796]         }
[11:01:02.796]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:02.796]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:02.796]             base::sink(type = "output", split = FALSE)
[11:01:02.796]             base::close(...future.stdout)
[11:01:02.796]         }, add = TRUE)
[11:01:02.796]     }
[11:01:02.796]     ...future.frame <- base::sys.nframe()
[11:01:02.796]     ...future.conditions <- base::list()
[11:01:02.796]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:02.796]     if (FALSE) {
[11:01:02.796]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:02.796]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:02.796]     }
[11:01:02.796]     ...future.result <- base::tryCatch({
[11:01:02.796]         base::withCallingHandlers({
[11:01:02.796]             ...future.value <- base::withVisible(base::local({
[11:01:02.796]                 message(sprintf("Calculating tile #%d of %d ...", 
[11:01:02.796]                   ii, n), appendLF = FALSE)
[11:01:02.796]                 fit <- mandelbrot(C)
[11:01:02.796]                 delay(fit)
[11:01:02.796]                 message(" done")
[11:01:02.796]                 fit
[11:01:02.796]             }))
[11:01:02.796]             future::FutureResult(value = ...future.value$value, 
[11:01:02.796]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:02.796]                   ...future.rng), globalenv = if (FALSE) 
[11:01:02.796]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:02.796]                     ...future.globalenv.names))
[11:01:02.796]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:02.796]         }, condition = base::local({
[11:01:02.796]             c <- base::c
[11:01:02.796]             inherits <- base::inherits
[11:01:02.796]             invokeRestart <- base::invokeRestart
[11:01:02.796]             length <- base::length
[11:01:02.796]             list <- base::list
[11:01:02.796]             seq.int <- base::seq.int
[11:01:02.796]             signalCondition <- base::signalCondition
[11:01:02.796]             sys.calls <- base::sys.calls
[11:01:02.796]             `[[` <- base::`[[`
[11:01:02.796]             `+` <- base::`+`
[11:01:02.796]             `<<-` <- base::`<<-`
[11:01:02.796]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:02.796]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:02.796]                   3L)]
[11:01:02.796]             }
[11:01:02.796]             function(cond) {
[11:01:02.796]                 is_error <- inherits(cond, "error")
[11:01:02.796]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:02.796]                   NULL)
[11:01:02.796]                 if (is_error) {
[11:01:02.796]                   sessionInformation <- function() {
[11:01:02.796]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:02.796]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:02.796]                       search = base::search(), system = base::Sys.info())
[11:01:02.796]                   }
[11:01:02.796]                   ...future.conditions[[length(...future.conditions) + 
[11:01:02.796]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:02.796]                     cond$call), session = sessionInformation(), 
[11:01:02.796]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:02.796]                   signalCondition(cond)
[11:01:02.796]                 }
[11:01:02.796]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:02.796]                 "immediateCondition"))) {
[11:01:02.796]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:02.796]                   ...future.conditions[[length(...future.conditions) + 
[11:01:02.796]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:02.796]                   if (TRUE && !signal) {
[11:01:02.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:02.796]                     {
[11:01:02.796]                       inherits <- base::inherits
[11:01:02.796]                       invokeRestart <- base::invokeRestart
[11:01:02.796]                       is.null <- base::is.null
[11:01:02.796]                       muffled <- FALSE
[11:01:02.796]                       if (inherits(cond, "message")) {
[11:01:02.796]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:02.796]                         if (muffled) 
[11:01:02.796]                           invokeRestart("muffleMessage")
[11:01:02.796]                       }
[11:01:02.796]                       else if (inherits(cond, "warning")) {
[11:01:02.796]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:02.796]                         if (muffled) 
[11:01:02.796]                           invokeRestart("muffleWarning")
[11:01:02.796]                       }
[11:01:02.796]                       else if (inherits(cond, "condition")) {
[11:01:02.796]                         if (!is.null(pattern)) {
[11:01:02.796]                           computeRestarts <- base::computeRestarts
[11:01:02.796]                           grepl <- base::grepl
[11:01:02.796]                           restarts <- computeRestarts(cond)
[11:01:02.796]                           for (restart in restarts) {
[11:01:02.796]                             name <- restart$name
[11:01:02.796]                             if (is.null(name)) 
[11:01:02.796]                               next
[11:01:02.796]                             if (!grepl(pattern, name)) 
[11:01:02.796]                               next
[11:01:02.796]                             invokeRestart(restart)
[11:01:02.796]                             muffled <- TRUE
[11:01:02.796]                             break
[11:01:02.796]                           }
[11:01:02.796]                         }
[11:01:02.796]                       }
[11:01:02.796]                       invisible(muffled)
[11:01:02.796]                     }
[11:01:02.796]                     muffleCondition(cond, pattern = "^muffle")
[11:01:02.796]                   }
[11:01:02.796]                 }
[11:01:02.796]                 else {
[11:01:02.796]                   if (TRUE) {
[11:01:02.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:02.796]                     {
[11:01:02.796]                       inherits <- base::inherits
[11:01:02.796]                       invokeRestart <- base::invokeRestart
[11:01:02.796]                       is.null <- base::is.null
[11:01:02.796]                       muffled <- FALSE
[11:01:02.796]                       if (inherits(cond, "message")) {
[11:01:02.796]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:02.796]                         if (muffled) 
[11:01:02.796]                           invokeRestart("muffleMessage")
[11:01:02.796]                       }
[11:01:02.796]                       else if (inherits(cond, "warning")) {
[11:01:02.796]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:02.796]                         if (muffled) 
[11:01:02.796]                           invokeRestart("muffleWarning")
[11:01:02.796]                       }
[11:01:02.796]                       else if (inherits(cond, "condition")) {
[11:01:02.796]                         if (!is.null(pattern)) {
[11:01:02.796]                           computeRestarts <- base::computeRestarts
[11:01:02.796]                           grepl <- base::grepl
[11:01:02.796]                           restarts <- computeRestarts(cond)
[11:01:02.796]                           for (restart in restarts) {
[11:01:02.796]                             name <- restart$name
[11:01:02.796]                             if (is.null(name)) 
[11:01:02.796]                               next
[11:01:02.796]                             if (!grepl(pattern, name)) 
[11:01:02.796]                               next
[11:01:02.796]                             invokeRestart(restart)
[11:01:02.796]                             muffled <- TRUE
[11:01:02.796]                             break
[11:01:02.796]                           }
[11:01:02.796]                         }
[11:01:02.796]                       }
[11:01:02.796]                       invisible(muffled)
[11:01:02.796]                     }
[11:01:02.796]                     muffleCondition(cond, pattern = "^muffle")
[11:01:02.796]                   }
[11:01:02.796]                 }
[11:01:02.796]             }
[11:01:02.796]         }))
[11:01:02.796]     }, error = function(ex) {
[11:01:02.796]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:02.796]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:02.796]                 ...future.rng), started = ...future.startTime, 
[11:01:02.796]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:02.796]             version = "1.8"), class = "FutureResult")
[11:01:02.796]     }, finally = {
[11:01:02.796]         if (!identical(...future.workdir, getwd())) 
[11:01:02.796]             setwd(...future.workdir)
[11:01:02.796]         {
[11:01:02.796]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:02.796]                 ...future.oldOptions$nwarnings <- NULL
[11:01:02.796]             }
[11:01:02.796]             base::options(...future.oldOptions)
[11:01:02.796]             if (.Platform$OS.type == "windows") {
[11:01:02.796]                 old_names <- names(...future.oldEnvVars)
[11:01:02.796]                 envs <- base::Sys.getenv()
[11:01:02.796]                 names <- names(envs)
[11:01:02.796]                 common <- intersect(names, old_names)
[11:01:02.796]                 added <- setdiff(names, old_names)
[11:01:02.796]                 removed <- setdiff(old_names, names)
[11:01:02.796]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:02.796]                   envs[common]]
[11:01:02.796]                 NAMES <- toupper(changed)
[11:01:02.796]                 args <- list()
[11:01:02.796]                 for (kk in seq_along(NAMES)) {
[11:01:02.796]                   name <- changed[[kk]]
[11:01:02.796]                   NAME <- NAMES[[kk]]
[11:01:02.796]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.796]                     next
[11:01:02.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:02.796]                 }
[11:01:02.796]                 NAMES <- toupper(added)
[11:01:02.796]                 for (kk in seq_along(NAMES)) {
[11:01:02.796]                   name <- added[[kk]]
[11:01:02.796]                   NAME <- NAMES[[kk]]
[11:01:02.796]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.796]                     next
[11:01:02.796]                   args[[name]] <- ""
[11:01:02.796]                 }
[11:01:02.796]                 NAMES <- toupper(removed)
[11:01:02.796]                 for (kk in seq_along(NAMES)) {
[11:01:02.796]                   name <- removed[[kk]]
[11:01:02.796]                   NAME <- NAMES[[kk]]
[11:01:02.796]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.796]                     next
[11:01:02.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:02.796]                 }
[11:01:02.796]                 if (length(args) > 0) 
[11:01:02.796]                   base::do.call(base::Sys.setenv, args = args)
[11:01:02.796]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:02.796]             }
[11:01:02.796]             else {
[11:01:02.796]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:02.796]             }
[11:01:02.796]             {
[11:01:02.796]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:02.796]                   0L) {
[11:01:02.796]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:02.796]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:02.796]                   base::options(opts)
[11:01:02.796]                 }
[11:01:02.796]                 {
[11:01:02.796]                   {
[11:01:02.796]                     NULL
[11:01:02.796]                     RNGkind("Mersenne-Twister")
[11:01:02.796]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:02.796]                       inherits = FALSE)
[11:01:02.796]                   }
[11:01:02.796]                   options(future.plan = NULL)
[11:01:02.796]                   if (is.na(NA_character_)) 
[11:01:02.796]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:02.796]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:02.796]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:02.796]                     .init = FALSE)
[11:01:02.796]                 }
[11:01:02.796]             }
[11:01:02.796]         }
[11:01:02.796]     })
[11:01:02.796]     if (TRUE) {
[11:01:02.796]         base::sink(type = "output", split = FALSE)
[11:01:02.796]         if (TRUE) {
[11:01:02.796]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:02.796]         }
[11:01:02.796]         else {
[11:01:02.796]             ...future.result["stdout"] <- base::list(NULL)
[11:01:02.796]         }
[11:01:02.796]         base::close(...future.stdout)
[11:01:02.796]         ...future.stdout <- NULL
[11:01:02.796]     }
[11:01:02.796]     ...future.result$conditions <- ...future.conditions
[11:01:02.796]     ...future.result$finished <- base::Sys.time()
[11:01:02.796]     ...future.result
[11:01:02.796] }
[11:01:02.798] assign_globals() ...
[11:01:02.798] List of 4
[11:01:02.798]  $ ii   : int 4
[11:01:02.798]  $ n    : int 4
[11:01:02.798]  $ C    : cplx [1:25, 1:25] -0.719+0.0306i -0.719+0.0918i -0.719+0.1531i ...
[11:01:02.798]   ..- attr(*, "region")=List of 2
[11:01:02.798]   .. ..$ xrange: num [1:2] -0.719 0.75
[11:01:02.798]   .. ..$ yrange: num [1:2] 0.0306 1.5
[11:01:02.798]   ..- attr(*, "tile")= int [1:2] 2 2
[11:01:02.798]  $ delay:function (counts)  
[11:01:02.798]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[11:01:02.798]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x564914762e40> 
[11:01:02.798]  - attr(*, "where")=List of 4
[11:01:02.798]   ..$ ii   :<environment: R_EmptyEnv> 
[11:01:02.798]   ..$ n    :<environment: R_EmptyEnv> 
[11:01:02.798]   ..$ C    :<environment: R_EmptyEnv> 
[11:01:02.798]   ..$ delay:<environment: R_EmptyEnv> 
[11:01:02.798]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:02.798]  - attr(*, "resolved")= logi FALSE
[11:01:02.798]  - attr(*, "total_size")= num 58781
[11:01:02.798]  - attr(*, "already-done")= logi TRUE
[11:01:02.804] - copied ‘ii’ to environment
[11:01:02.804] - copied ‘n’ to environment
[11:01:02.804] - copied ‘C’ to environment
[11:01:02.804] - reassign environment for ‘delay’
[11:01:02.804] - copied ‘delay’ to environment
[11:01:02.804] assign_globals() ... done
[11:01:02.805] plan(): Setting new future strategy stack:
[11:01:02.805] List of future strategies:
[11:01:02.805] 1. sequential:
[11:01:02.805]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:02.805]    - tweaked: FALSE
[11:01:02.805]    - call: NULL
[11:01:02.805] plan(): nbrOfWorkers() = 1
[11:01:02.825] plan(): Setting new future strategy stack:
[11:01:02.825] List of future strategies:
[11:01:02.825] 1. sequential:
[11:01:02.825]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:02.825]    - tweaked: FALSE
[11:01:02.825]    - call: plan(strategy)
[11:01:02.826] plan(): nbrOfWorkers() = 1
[11:01:02.826] SequentialFuture started (and completed)
[11:01:02.826] signalConditions() ...
[11:01:02.826]  - include = ‘immediateCondition’
[11:01:02.826]  - exclude = 
[11:01:02.826]  - resignal = FALSE
[11:01:02.826]  - Number of conditions: 2
[11:01:02.826] signalConditions() ... done
[11:01:02.827] - Launch lazy future ... done
[11:01:02.827] run() for ‘SequentialFuture’ ... done
[11:01:02.827] - run() ... done
[11:01:02.827] - resolved() ...
[11:01:02.827] resolved() for ‘SequentialFuture’ ...
[11:01:02.827] - state: ‘finished’
[11:01:02.827] - run: TRUE
[11:01:02.827] - result: ‘FutureResult’
[11:01:02.827] resolved() for ‘SequentialFuture’ ... done
[11:01:02.828] - resolved: TRUE
[11:01:02.828] - resolved() ... done
[11:01:02.828] resolved() for ‘SequentialFuture’ ... done
Plotting tile #4 of 4 ...
[11:01:02.828] signalConditions() ...
[11:01:02.828]  - include = ‘immediateCondition’
[11:01:02.828]  - exclude = 
[11:01:02.828]  - resignal = FALSE
[11:01:02.828]  - Number of conditions: 2
[11:01:02.829] signalConditions() ... done
[11:01:02.829] Future state: ‘finished’
[11:01:02.829] signalConditions() ...
[11:01:02.829]  - include = ‘condition’
[11:01:02.829]  - exclude = ‘immediateCondition’
[11:01:02.829]  - resignal = TRUE
[11:01:02.829]  - Number of conditions: 2
[11:01:02.829]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[11:01:02.829]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[11:01:02.830] signalConditions() ... done

> close.screen()
[1] 1 2 3 4

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('sequential') ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('multicore') ...
[11:01:02.837] plan(): Setting new future strategy stack:
[11:01:02.837] List of future strategies:
[11:01:02.837] 1. multicore:
[11:01:02.837]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:02.837]    - tweaked: FALSE
[11:01:02.837]    - call: plan(strategy)
[11:01:02.839] plan(): nbrOfWorkers() = 2


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1] 5 6 7 8

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[11:01:02.842] getGlobalsAndPackages() ...
[11:01:02.843] Searching for globals...
[11:01:02.846] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[11:01:02.846] Searching for globals ... DONE
[11:01:02.846] Resolving globals: FALSE
[11:01:02.847] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[11:01:02.847] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:02.847] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[11:01:02.847] - packages: [1] ‘future’
[11:01:02.847] getGlobalsAndPackages() ... DONE
 2[11:01:02.851] getGlobalsAndPackages() ...
[11:01:02.851] Searching for globals...
[11:01:02.854] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[11:01:02.854] Searching for globals ... DONE
[11:01:02.854] Resolving globals: FALSE
[11:01:02.855] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[11:01:02.855] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:02.856] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[11:01:02.856] - packages: [1] ‘future’
[11:01:02.856] getGlobalsAndPackages() ... DONE
 3[11:01:02.856] getGlobalsAndPackages() ...
[11:01:02.856] Searching for globals...
[11:01:02.859] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[11:01:02.859] Searching for globals ... DONE
[11:01:02.859] Resolving globals: FALSE
[11:01:02.860] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[11:01:02.860] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:02.860] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[11:01:02.861] - packages: [1] ‘future’
[11:01:02.861] getGlobalsAndPackages() ... DONE
 4[11:01:02.861] getGlobalsAndPackages() ...
[11:01:02.861] Searching for globals...
[11:01:02.864] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[11:01:02.864] Searching for globals ... DONE
[11:01:02.864] Resolving globals: FALSE
[11:01:02.865] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[11:01:02.865] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:02.865] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[11:01:02.866] - packages: [1] ‘future’
[11:01:02.866] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[11:01:02.874] resolved() for ‘Future’ ...
[11:01:02.874] - state: ‘created’
[11:01:02.874] - run: TRUE
[11:01:02.874] - run() ...
[11:01:02.874] run() for ‘Future’ ...
[11:01:02.875] - state: ‘created’
[11:01:02.875] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:02.876] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:02.876] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:02.877]   - Field: ‘label’
[11:01:02.877]   - Field: ‘local’
[11:01:02.877]   - Field: ‘owner’
[11:01:02.877]   - Field: ‘envir’
[11:01:02.877]   - Field: ‘workers’
[11:01:02.877]   - Field: ‘packages’
[11:01:02.877]   - Field: ‘gc’
[11:01:02.877]   - Field: ‘job’
[11:01:02.877]   - Field: ‘conditions’
[11:01:02.877]   - Field: ‘expr’
[11:01:02.877]   - Field: ‘uuid’
[11:01:02.877]   - Field: ‘seed’
[11:01:02.878]   - Field: ‘version’
[11:01:02.878]   - Field: ‘result’
[11:01:02.878]   - Field: ‘asynchronous’
[11:01:02.878]   - Field: ‘calls’
[11:01:02.878]   - Field: ‘globals’
[11:01:02.878]   - Field: ‘stdout’
[11:01:02.878]   - Field: ‘earlySignal’
[11:01:02.878]   - Field: ‘lazy’
[11:01:02.878]   - Field: ‘state’
[11:01:02.878] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:02.878] - Launch lazy future ...
[11:01:02.879] Packages needed by the future expression (n = 1): ‘future’
[11:01:02.879] Packages needed by future strategies (n = 0): <none>
[11:01:02.880] {
[11:01:02.880]     {
[11:01:02.880]         {
[11:01:02.880]             ...future.startTime <- base::Sys.time()
[11:01:02.880]             {
[11:01:02.880]                 {
[11:01:02.880]                   {
[11:01:02.880]                     {
[11:01:02.880]                       {
[11:01:02.880]                         base::local({
[11:01:02.880]                           has_future <- base::requireNamespace("future", 
[11:01:02.880]                             quietly = TRUE)
[11:01:02.880]                           if (has_future) {
[11:01:02.880]                             ns <- base::getNamespace("future")
[11:01:02.880]                             version <- ns[[".package"]][["version"]]
[11:01:02.880]                             if (is.null(version)) 
[11:01:02.880]                               version <- utils::packageVersion("future")
[11:01:02.880]                           }
[11:01:02.880]                           else {
[11:01:02.880]                             version <- NULL
[11:01:02.880]                           }
[11:01:02.880]                           if (!has_future || version < "1.8.0") {
[11:01:02.880]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:02.880]                               "", base::R.version$version.string), 
[11:01:02.880]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:02.880]                                 base::R.version$platform, 8 * 
[11:01:02.880]                                   base::.Machine$sizeof.pointer), 
[11:01:02.880]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:02.880]                                 "release", "version")], collapse = " "), 
[11:01:02.880]                               hostname = base::Sys.info()[["nodename"]])
[11:01:02.880]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:02.880]                               info)
[11:01:02.880]                             info <- base::paste(info, collapse = "; ")
[11:01:02.880]                             if (!has_future) {
[11:01:02.880]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:02.880]                                 info)
[11:01:02.880]                             }
[11:01:02.880]                             else {
[11:01:02.880]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:02.880]                                 info, version)
[11:01:02.880]                             }
[11:01:02.880]                             base::stop(msg)
[11:01:02.880]                           }
[11:01:02.880]                         })
[11:01:02.880]                       }
[11:01:02.880]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:02.880]                       base::options(mc.cores = 1L)
[11:01:02.880]                     }
[11:01:02.880]                     base::local({
[11:01:02.880]                       for (pkg in "future") {
[11:01:02.880]                         base::loadNamespace(pkg)
[11:01:02.880]                         base::library(pkg, character.only = TRUE)
[11:01:02.880]                       }
[11:01:02.880]                     })
[11:01:02.880]                   }
[11:01:02.880]                   ...future.strategy.old <- future::plan("list")
[11:01:02.880]                   options(future.plan = NULL)
[11:01:02.880]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:02.880]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:02.880]                 }
[11:01:02.880]                 ...future.workdir <- getwd()
[11:01:02.880]             }
[11:01:02.880]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:02.880]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:02.880]         }
[11:01:02.880]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:02.880]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:02.880]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:02.880]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:02.880]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:02.880]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:02.880]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:02.880]             base::names(...future.oldOptions))
[11:01:02.880]     }
[11:01:02.880]     if (FALSE) {
[11:01:02.880]     }
[11:01:02.880]     else {
[11:01:02.880]         if (TRUE) {
[11:01:02.880]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:02.880]                 open = "w")
[11:01:02.880]         }
[11:01:02.880]         else {
[11:01:02.880]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:02.880]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:02.880]         }
[11:01:02.880]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:02.880]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:02.880]             base::sink(type = "output", split = FALSE)
[11:01:02.880]             base::close(...future.stdout)
[11:01:02.880]         }, add = TRUE)
[11:01:02.880]     }
[11:01:02.880]     ...future.frame <- base::sys.nframe()
[11:01:02.880]     ...future.conditions <- base::list()
[11:01:02.880]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:02.880]     if (FALSE) {
[11:01:02.880]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:02.880]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:02.880]     }
[11:01:02.880]     ...future.result <- base::tryCatch({
[11:01:02.880]         base::withCallingHandlers({
[11:01:02.880]             ...future.value <- base::withVisible(base::local({
[11:01:02.880]                 withCallingHandlers({
[11:01:02.880]                   {
[11:01:02.880]                     message(sprintf("Calculating tile #%d of %d ...", 
[11:01:02.880]                       ii, n), appendLF = FALSE)
[11:01:02.880]                     fit <- mandelbrot(C)
[11:01:02.880]                     delay(fit)
[11:01:02.880]                     message(" done")
[11:01:02.880]                     fit
[11:01:02.880]                   }
[11:01:02.880]                 }, immediateCondition = function(cond) {
[11:01:02.880]                   save_rds <- function (object, pathname, ...) 
[11:01:02.880]                   {
[11:01:02.880]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:02.880]                     if (file_test("-f", pathname_tmp)) {
[11:01:02.880]                       fi_tmp <- file.info(pathname_tmp)
[11:01:02.880]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:02.880]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:02.880]                         fi_tmp[["mtime"]])
[11:01:02.880]                     }
[11:01:02.880]                     tryCatch({
[11:01:02.880]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:02.880]                     }, error = function(ex) {
[11:01:02.880]                       msg <- conditionMessage(ex)
[11:01:02.880]                       fi_tmp <- file.info(pathname_tmp)
[11:01:02.880]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:02.880]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:02.880]                         fi_tmp[["mtime"]], msg)
[11:01:02.880]                       ex$message <- msg
[11:01:02.880]                       stop(ex)
[11:01:02.880]                     })
[11:01:02.880]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:02.880]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:02.880]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:02.880]                       fi_tmp <- file.info(pathname_tmp)
[11:01:02.880]                       fi <- file.info(pathname)
[11:01:02.880]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:02.880]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:02.880]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:02.880]                         fi[["size"]], fi[["mtime"]])
[11:01:02.880]                       stop(msg)
[11:01:02.880]                     }
[11:01:02.880]                     invisible(pathname)
[11:01:02.880]                   }
[11:01:02.880]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:02.880]                     rootPath = tempdir()) 
[11:01:02.880]                   {
[11:01:02.880]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:02.880]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:02.880]                       tmpdir = path, fileext = ".rds")
[11:01:02.880]                     save_rds(obj, file)
[11:01:02.880]                   }
[11:01:02.880]                   saveImmediateCondition(cond, path = "/tmp/Rtmpbx4bQL/.future/immediateConditions")
[11:01:02.880]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:02.880]                   {
[11:01:02.880]                     inherits <- base::inherits
[11:01:02.880]                     invokeRestart <- base::invokeRestart
[11:01:02.880]                     is.null <- base::is.null
[11:01:02.880]                     muffled <- FALSE
[11:01:02.880]                     if (inherits(cond, "message")) {
[11:01:02.880]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:02.880]                       if (muffled) 
[11:01:02.880]                         invokeRestart("muffleMessage")
[11:01:02.880]                     }
[11:01:02.880]                     else if (inherits(cond, "warning")) {
[11:01:02.880]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:02.880]                       if (muffled) 
[11:01:02.880]                         invokeRestart("muffleWarning")
[11:01:02.880]                     }
[11:01:02.880]                     else if (inherits(cond, "condition")) {
[11:01:02.880]                       if (!is.null(pattern)) {
[11:01:02.880]                         computeRestarts <- base::computeRestarts
[11:01:02.880]                         grepl <- base::grepl
[11:01:02.880]                         restarts <- computeRestarts(cond)
[11:01:02.880]                         for (restart in restarts) {
[11:01:02.880]                           name <- restart$name
[11:01:02.880]                           if (is.null(name)) 
[11:01:02.880]                             next
[11:01:02.880]                           if (!grepl(pattern, name)) 
[11:01:02.880]                             next
[11:01:02.880]                           invokeRestart(restart)
[11:01:02.880]                           muffled <- TRUE
[11:01:02.880]                           break
[11:01:02.880]                         }
[11:01:02.880]                       }
[11:01:02.880]                     }
[11:01:02.880]                     invisible(muffled)
[11:01:02.880]                   }
[11:01:02.880]                   muffleCondition(cond)
[11:01:02.880]                 })
[11:01:02.880]             }))
[11:01:02.880]             future::FutureResult(value = ...future.value$value, 
[11:01:02.880]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:02.880]                   ...future.rng), globalenv = if (FALSE) 
[11:01:02.880]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:02.880]                     ...future.globalenv.names))
[11:01:02.880]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:02.880]         }, condition = base::local({
[11:01:02.880]             c <- base::c
[11:01:02.880]             inherits <- base::inherits
[11:01:02.880]             invokeRestart <- base::invokeRestart
[11:01:02.880]             length <- base::length
[11:01:02.880]             list <- base::list
[11:01:02.880]             seq.int <- base::seq.int
[11:01:02.880]             signalCondition <- base::signalCondition
[11:01:02.880]             sys.calls <- base::sys.calls
[11:01:02.880]             `[[` <- base::`[[`
[11:01:02.880]             `+` <- base::`+`
[11:01:02.880]             `<<-` <- base::`<<-`
[11:01:02.880]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:02.880]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:02.880]                   3L)]
[11:01:02.880]             }
[11:01:02.880]             function(cond) {
[11:01:02.880]                 is_error <- inherits(cond, "error")
[11:01:02.880]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:02.880]                   NULL)
[11:01:02.880]                 if (is_error) {
[11:01:02.880]                   sessionInformation <- function() {
[11:01:02.880]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:02.880]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:02.880]                       search = base::search(), system = base::Sys.info())
[11:01:02.880]                   }
[11:01:02.880]                   ...future.conditions[[length(...future.conditions) + 
[11:01:02.880]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:02.880]                     cond$call), session = sessionInformation(), 
[11:01:02.880]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:02.880]                   signalCondition(cond)
[11:01:02.880]                 }
[11:01:02.880]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:02.880]                 "immediateCondition"))) {
[11:01:02.880]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:02.880]                   ...future.conditions[[length(...future.conditions) + 
[11:01:02.880]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:02.880]                   if (TRUE && !signal) {
[11:01:02.880]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:02.880]                     {
[11:01:02.880]                       inherits <- base::inherits
[11:01:02.880]                       invokeRestart <- base::invokeRestart
[11:01:02.880]                       is.null <- base::is.null
[11:01:02.880]                       muffled <- FALSE
[11:01:02.880]                       if (inherits(cond, "message")) {
[11:01:02.880]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:02.880]                         if (muffled) 
[11:01:02.880]                           invokeRestart("muffleMessage")
[11:01:02.880]                       }
[11:01:02.880]                       else if (inherits(cond, "warning")) {
[11:01:02.880]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:02.880]                         if (muffled) 
[11:01:02.880]                           invokeRestart("muffleWarning")
[11:01:02.880]                       }
[11:01:02.880]                       else if (inherits(cond, "condition")) {
[11:01:02.880]                         if (!is.null(pattern)) {
[11:01:02.880]                           computeRestarts <- base::computeRestarts
[11:01:02.880]                           grepl <- base::grepl
[11:01:02.880]                           restarts <- computeRestarts(cond)
[11:01:02.880]                           for (restart in restarts) {
[11:01:02.880]                             name <- restart$name
[11:01:02.880]                             if (is.null(name)) 
[11:01:02.880]                               next
[11:01:02.880]                             if (!grepl(pattern, name)) 
[11:01:02.880]                               next
[11:01:02.880]                             invokeRestart(restart)
[11:01:02.880]                             muffled <- TRUE
[11:01:02.880]                             break
[11:01:02.880]                           }
[11:01:02.880]                         }
[11:01:02.880]                       }
[11:01:02.880]                       invisible(muffled)
[11:01:02.880]                     }
[11:01:02.880]                     muffleCondition(cond, pattern = "^muffle")
[11:01:02.880]                   }
[11:01:02.880]                 }
[11:01:02.880]                 else {
[11:01:02.880]                   if (TRUE) {
[11:01:02.880]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:02.880]                     {
[11:01:02.880]                       inherits <- base::inherits
[11:01:02.880]                       invokeRestart <- base::invokeRestart
[11:01:02.880]                       is.null <- base::is.null
[11:01:02.880]                       muffled <- FALSE
[11:01:02.880]                       if (inherits(cond, "message")) {
[11:01:02.880]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:02.880]                         if (muffled) 
[11:01:02.880]                           invokeRestart("muffleMessage")
[11:01:02.880]                       }
[11:01:02.880]                       else if (inherits(cond, "warning")) {
[11:01:02.880]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:02.880]                         if (muffled) 
[11:01:02.880]                           invokeRestart("muffleWarning")
[11:01:02.880]                       }
[11:01:02.880]                       else if (inherits(cond, "condition")) {
[11:01:02.880]                         if (!is.null(pattern)) {
[11:01:02.880]                           computeRestarts <- base::computeRestarts
[11:01:02.880]                           grepl <- base::grepl
[11:01:02.880]                           restarts <- computeRestarts(cond)
[11:01:02.880]                           for (restart in restarts) {
[11:01:02.880]                             name <- restart$name
[11:01:02.880]                             if (is.null(name)) 
[11:01:02.880]                               next
[11:01:02.880]                             if (!grepl(pattern, name)) 
[11:01:02.880]                               next
[11:01:02.880]                             invokeRestart(restart)
[11:01:02.880]                             muffled <- TRUE
[11:01:02.880]                             break
[11:01:02.880]                           }
[11:01:02.880]                         }
[11:01:02.880]                       }
[11:01:02.880]                       invisible(muffled)
[11:01:02.880]                     }
[11:01:02.880]                     muffleCondition(cond, pattern = "^muffle")
[11:01:02.880]                   }
[11:01:02.880]                 }
[11:01:02.880]             }
[11:01:02.880]         }))
[11:01:02.880]     }, error = function(ex) {
[11:01:02.880]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:02.880]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:02.880]                 ...future.rng), started = ...future.startTime, 
[11:01:02.880]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:02.880]             version = "1.8"), class = "FutureResult")
[11:01:02.880]     }, finally = {
[11:01:02.880]         if (!identical(...future.workdir, getwd())) 
[11:01:02.880]             setwd(...future.workdir)
[11:01:02.880]         {
[11:01:02.880]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:02.880]                 ...future.oldOptions$nwarnings <- NULL
[11:01:02.880]             }
[11:01:02.880]             base::options(...future.oldOptions)
[11:01:02.880]             if (.Platform$OS.type == "windows") {
[11:01:02.880]                 old_names <- names(...future.oldEnvVars)
[11:01:02.880]                 envs <- base::Sys.getenv()
[11:01:02.880]                 names <- names(envs)
[11:01:02.880]                 common <- intersect(names, old_names)
[11:01:02.880]                 added <- setdiff(names, old_names)
[11:01:02.880]                 removed <- setdiff(old_names, names)
[11:01:02.880]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:02.880]                   envs[common]]
[11:01:02.880]                 NAMES <- toupper(changed)
[11:01:02.880]                 args <- list()
[11:01:02.880]                 for (kk in seq_along(NAMES)) {
[11:01:02.880]                   name <- changed[[kk]]
[11:01:02.880]                   NAME <- NAMES[[kk]]
[11:01:02.880]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.880]                     next
[11:01:02.880]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:02.880]                 }
[11:01:02.880]                 NAMES <- toupper(added)
[11:01:02.880]                 for (kk in seq_along(NAMES)) {
[11:01:02.880]                   name <- added[[kk]]
[11:01:02.880]                   NAME <- NAMES[[kk]]
[11:01:02.880]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.880]                     next
[11:01:02.880]                   args[[name]] <- ""
[11:01:02.880]                 }
[11:01:02.880]                 NAMES <- toupper(removed)
[11:01:02.880]                 for (kk in seq_along(NAMES)) {
[11:01:02.880]                   name <- removed[[kk]]
[11:01:02.880]                   NAME <- NAMES[[kk]]
[11:01:02.880]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.880]                     next
[11:01:02.880]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:02.880]                 }
[11:01:02.880]                 if (length(args) > 0) 
[11:01:02.880]                   base::do.call(base::Sys.setenv, args = args)
[11:01:02.880]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:02.880]             }
[11:01:02.880]             else {
[11:01:02.880]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:02.880]             }
[11:01:02.880]             {
[11:01:02.880]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:02.880]                   0L) {
[11:01:02.880]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:02.880]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:02.880]                   base::options(opts)
[11:01:02.880]                 }
[11:01:02.880]                 {
[11:01:02.880]                   {
[11:01:02.880]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:02.880]                     NULL
[11:01:02.880]                   }
[11:01:02.880]                   options(future.plan = NULL)
[11:01:02.880]                   if (is.na(NA_character_)) 
[11:01:02.880]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:02.880]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:02.880]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:02.880]                     .init = FALSE)
[11:01:02.880]                 }
[11:01:02.880]             }
[11:01:02.880]         }
[11:01:02.880]     })
[11:01:02.880]     if (TRUE) {
[11:01:02.880]         base::sink(type = "output", split = FALSE)
[11:01:02.880]         if (TRUE) {
[11:01:02.880]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:02.880]         }
[11:01:02.880]         else {
[11:01:02.880]             ...future.result["stdout"] <- base::list(NULL)
[11:01:02.880]         }
[11:01:02.880]         base::close(...future.stdout)
[11:01:02.880]         ...future.stdout <- NULL
[11:01:02.880]     }
[11:01:02.880]     ...future.result$conditions <- ...future.conditions
[11:01:02.880]     ...future.result$finished <- base::Sys.time()
[11:01:02.880]     ...future.result
[11:01:02.880] }
[11:01:02.882] assign_globals() ...
[11:01:02.882] List of 4
[11:01:02.882]  $ ii   : int 1
[11:01:02.882]  $ n    : int 4
[11:01:02.882]  $ C    : cplx [1:25, 1:25] -2.25-1.5i -2.25-1.44i -2.25-1.38i ...
[11:01:02.882]   ..- attr(*, "region")=List of 2
[11:01:02.882]   .. ..$ xrange: num [1:2] -2.25 -0.781
[11:01:02.882]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[11:01:02.882]   ..- attr(*, "tile")= int [1:2] 1 1
[11:01:02.882]  $ delay:function (counts)  
[11:01:02.882]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[11:01:02.882]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x56491639efc0> 
[11:01:02.882]  - attr(*, "where")=List of 4
[11:01:02.882]   ..$ ii   :<environment: R_EmptyEnv> 
[11:01:02.882]   ..$ n    :<environment: R_EmptyEnv> 
[11:01:02.882]   ..$ C    :<environment: R_EmptyEnv> 
[11:01:02.882]   ..$ delay:<environment: R_EmptyEnv> 
[11:01:02.882]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:02.882]  - attr(*, "resolved")= logi FALSE
[11:01:02.882]  - attr(*, "total_size")= num 58781
[11:01:02.882]  - attr(*, "already-done")= logi TRUE
[11:01:02.888] - copied ‘ii’ to environment
[11:01:02.888] - copied ‘n’ to environment
[11:01:02.888] - copied ‘C’ to environment
[11:01:02.888] - reassign environment for ‘delay’
[11:01:02.888] - copied ‘delay’ to environment
[11:01:02.888] assign_globals() ... done
[11:01:02.889] requestCore(): workers = 2
[11:01:02.892] MulticoreFuture started
[11:01:02.892] - Launch lazy future ... done
[11:01:02.892] run() for ‘MulticoreFuture’ ... done
[11:01:02.893] - run() ... done
[11:01:02.893] - resolved() ...
[11:01:02.893] plan(): Setting new future strategy stack:
[11:01:02.893] List of future strategies:
[11:01:02.893] 1. sequential:
[11:01:02.893]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:02.893]    - tweaked: FALSE
[11:01:02.893]    - call: NULL
[11:01:02.894] plan(): nbrOfWorkers() = 1
[11:01:02.897] plan(): Setting new future strategy stack:
[11:01:02.897] List of future strategies:
[11:01:02.897] 1. multicore:
[11:01:02.897]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:02.897]    - tweaked: FALSE
[11:01:02.897]    - call: plan(strategy)
[11:01:02.900] plan(): nbrOfWorkers() = 2
[11:01:02.901] - resolved: TRUE
[11:01:02.901] - resolved() ... done
[11:01:02.901] resolved() for ‘MulticoreFuture’ ... done
Plotting tile #1 of 4 ...
[11:01:02.902] result() for MulticoreFuture ...
[11:01:02.907] result() for MulticoreFuture ...
[11:01:02.907] result() for MulticoreFuture ... done
[11:01:02.908] signalConditions() ...
[11:01:02.908]  - include = ‘immediateCondition’
[11:01:02.908]  - exclude = 
[11:01:02.908]  - resignal = FALSE
[11:01:02.908]  - Number of conditions: 2
[11:01:02.908] signalConditions() ... done
[11:01:02.908] result() for MulticoreFuture ... done
[11:01:02.908] result() for MulticoreFuture ...
[11:01:02.908] result() for MulticoreFuture ... done
[11:01:02.909] signalConditions() ...
[11:01:02.909]  - include = ‘immediateCondition’
[11:01:02.909]  - exclude = 
[11:01:02.909]  - resignal = FALSE
[11:01:02.909]  - Number of conditions: 2
[11:01:02.909] signalConditions() ... done
[11:01:02.909] Future state: ‘finished’
[11:01:02.909] result() for MulticoreFuture ...
[11:01:02.909] result() for MulticoreFuture ... done
[11:01:02.910] signalConditions() ...
[11:01:02.910]  - include = ‘condition’
[11:01:02.910]  - exclude = ‘immediateCondition’
[11:01:02.910]  - resignal = TRUE
[11:01:02.910]  - Number of conditions: 2
[11:01:02.910]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[11:01:02.910]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[11:01:02.910] signalConditions() ... done
[11:01:02.911] resolved() for ‘Future’ ...
[11:01:02.911] - state: ‘created’
[11:01:02.911] - run: TRUE
[11:01:02.911] - run() ...
[11:01:02.912] run() for ‘Future’ ...
[11:01:02.912] - state: ‘created’
[11:01:02.912] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:02.914] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:02.914] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:02.914]   - Field: ‘label’
[11:01:02.914]   - Field: ‘local’
[11:01:02.915]   - Field: ‘owner’
[11:01:02.915]   - Field: ‘envir’
[11:01:02.915]   - Field: ‘workers’
[11:01:02.915]   - Field: ‘packages’
[11:01:02.915]   - Field: ‘gc’
[11:01:02.915]   - Field: ‘job’
[11:01:02.915]   - Field: ‘conditions’
[11:01:02.915]   - Field: ‘expr’
[11:01:02.915]   - Field: ‘uuid’
[11:01:02.915]   - Field: ‘seed’
[11:01:02.916]   - Field: ‘version’
[11:01:02.916]   - Field: ‘result’
[11:01:02.916]   - Field: ‘asynchronous’
[11:01:02.916]   - Field: ‘calls’
[11:01:02.916]   - Field: ‘globals’
[11:01:02.916]   - Field: ‘stdout’
[11:01:02.916]   - Field: ‘earlySignal’
[11:01:02.916]   - Field: ‘lazy’
[11:01:02.916]   - Field: ‘state’
[11:01:02.919] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:02.919] - Launch lazy future ...
[11:01:02.920] Packages needed by the future expression (n = 1): ‘future’
[11:01:02.920] Packages needed by future strategies (n = 0): <none>
[11:01:02.920] {
[11:01:02.920]     {
[11:01:02.920]         {
[11:01:02.920]             ...future.startTime <- base::Sys.time()
[11:01:02.920]             {
[11:01:02.920]                 {
[11:01:02.920]                   {
[11:01:02.920]                     {
[11:01:02.920]                       {
[11:01:02.920]                         base::local({
[11:01:02.920]                           has_future <- base::requireNamespace("future", 
[11:01:02.920]                             quietly = TRUE)
[11:01:02.920]                           if (has_future) {
[11:01:02.920]                             ns <- base::getNamespace("future")
[11:01:02.920]                             version <- ns[[".package"]][["version"]]
[11:01:02.920]                             if (is.null(version)) 
[11:01:02.920]                               version <- utils::packageVersion("future")
[11:01:02.920]                           }
[11:01:02.920]                           else {
[11:01:02.920]                             version <- NULL
[11:01:02.920]                           }
[11:01:02.920]                           if (!has_future || version < "1.8.0") {
[11:01:02.920]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:02.920]                               "", base::R.version$version.string), 
[11:01:02.920]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:02.920]                                 base::R.version$platform, 8 * 
[11:01:02.920]                                   base::.Machine$sizeof.pointer), 
[11:01:02.920]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:02.920]                                 "release", "version")], collapse = " "), 
[11:01:02.920]                               hostname = base::Sys.info()[["nodename"]])
[11:01:02.920]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:02.920]                               info)
[11:01:02.920]                             info <- base::paste(info, collapse = "; ")
[11:01:02.920]                             if (!has_future) {
[11:01:02.920]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:02.920]                                 info)
[11:01:02.920]                             }
[11:01:02.920]                             else {
[11:01:02.920]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:02.920]                                 info, version)
[11:01:02.920]                             }
[11:01:02.920]                             base::stop(msg)
[11:01:02.920]                           }
[11:01:02.920]                         })
[11:01:02.920]                       }
[11:01:02.920]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:02.920]                       base::options(mc.cores = 1L)
[11:01:02.920]                     }
[11:01:02.920]                     base::local({
[11:01:02.920]                       for (pkg in "future") {
[11:01:02.920]                         base::loadNamespace(pkg)
[11:01:02.920]                         base::library(pkg, character.only = TRUE)
[11:01:02.920]                       }
[11:01:02.920]                     })
[11:01:02.920]                   }
[11:01:02.920]                   ...future.strategy.old <- future::plan("list")
[11:01:02.920]                   options(future.plan = NULL)
[11:01:02.920]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:02.920]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:02.920]                 }
[11:01:02.920]                 ...future.workdir <- getwd()
[11:01:02.920]             }
[11:01:02.920]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:02.920]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:02.920]         }
[11:01:02.920]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:02.920]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:02.920]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:02.920]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:02.920]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:02.920]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:02.920]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:02.920]             base::names(...future.oldOptions))
[11:01:02.920]     }
[11:01:02.920]     if (FALSE) {
[11:01:02.920]     }
[11:01:02.920]     else {
[11:01:02.920]         if (TRUE) {
[11:01:02.920]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:02.920]                 open = "w")
[11:01:02.920]         }
[11:01:02.920]         else {
[11:01:02.920]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:02.920]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:02.920]         }
[11:01:02.920]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:02.920]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:02.920]             base::sink(type = "output", split = FALSE)
[11:01:02.920]             base::close(...future.stdout)
[11:01:02.920]         }, add = TRUE)
[11:01:02.920]     }
[11:01:02.920]     ...future.frame <- base::sys.nframe()
[11:01:02.920]     ...future.conditions <- base::list()
[11:01:02.920]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:02.920]     if (FALSE) {
[11:01:02.920]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:02.920]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:02.920]     }
[11:01:02.920]     ...future.result <- base::tryCatch({
[11:01:02.920]         base::withCallingHandlers({
[11:01:02.920]             ...future.value <- base::withVisible(base::local({
[11:01:02.920]                 withCallingHandlers({
[11:01:02.920]                   {
[11:01:02.920]                     message(sprintf("Calculating tile #%d of %d ...", 
[11:01:02.920]                       ii, n), appendLF = FALSE)
[11:01:02.920]                     fit <- mandelbrot(C)
[11:01:02.920]                     delay(fit)
[11:01:02.920]                     message(" done")
[11:01:02.920]                     fit
[11:01:02.920]                   }
[11:01:02.920]                 }, immediateCondition = function(cond) {
[11:01:02.920]                   save_rds <- function (object, pathname, ...) 
[11:01:02.920]                   {
[11:01:02.920]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:02.920]                     if (file_test("-f", pathname_tmp)) {
[11:01:02.920]                       fi_tmp <- file.info(pathname_tmp)
[11:01:02.920]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:02.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:02.920]                         fi_tmp[["mtime"]])
[11:01:02.920]                     }
[11:01:02.920]                     tryCatch({
[11:01:02.920]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:02.920]                     }, error = function(ex) {
[11:01:02.920]                       msg <- conditionMessage(ex)
[11:01:02.920]                       fi_tmp <- file.info(pathname_tmp)
[11:01:02.920]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:02.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:02.920]                         fi_tmp[["mtime"]], msg)
[11:01:02.920]                       ex$message <- msg
[11:01:02.920]                       stop(ex)
[11:01:02.920]                     })
[11:01:02.920]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:02.920]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:02.920]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:02.920]                       fi_tmp <- file.info(pathname_tmp)
[11:01:02.920]                       fi <- file.info(pathname)
[11:01:02.920]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:02.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:02.920]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:02.920]                         fi[["size"]], fi[["mtime"]])
[11:01:02.920]                       stop(msg)
[11:01:02.920]                     }
[11:01:02.920]                     invisible(pathname)
[11:01:02.920]                   }
[11:01:02.920]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:02.920]                     rootPath = tempdir()) 
[11:01:02.920]                   {
[11:01:02.920]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:02.920]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:02.920]                       tmpdir = path, fileext = ".rds")
[11:01:02.920]                     save_rds(obj, file)
[11:01:02.920]                   }
[11:01:02.920]                   saveImmediateCondition(cond, path = "/tmp/Rtmpbx4bQL/.future/immediateConditions")
[11:01:02.920]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:02.920]                   {
[11:01:02.920]                     inherits <- base::inherits
[11:01:02.920]                     invokeRestart <- base::invokeRestart
[11:01:02.920]                     is.null <- base::is.null
[11:01:02.920]                     muffled <- FALSE
[11:01:02.920]                     if (inherits(cond, "message")) {
[11:01:02.920]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:02.920]                       if (muffled) 
[11:01:02.920]                         invokeRestart("muffleMessage")
[11:01:02.920]                     }
[11:01:02.920]                     else if (inherits(cond, "warning")) {
[11:01:02.920]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:02.920]                       if (muffled) 
[11:01:02.920]                         invokeRestart("muffleWarning")
[11:01:02.920]                     }
[11:01:02.920]                     else if (inherits(cond, "condition")) {
[11:01:02.920]                       if (!is.null(pattern)) {
[11:01:02.920]                         computeRestarts <- base::computeRestarts
[11:01:02.920]                         grepl <- base::grepl
[11:01:02.920]                         restarts <- computeRestarts(cond)
[11:01:02.920]                         for (restart in restarts) {
[11:01:02.920]                           name <- restart$name
[11:01:02.920]                           if (is.null(name)) 
[11:01:02.920]                             next
[11:01:02.920]                           if (!grepl(pattern, name)) 
[11:01:02.920]                             next
[11:01:02.920]                           invokeRestart(restart)
[11:01:02.920]                           muffled <- TRUE
[11:01:02.920]                           break
[11:01:02.920]                         }
[11:01:02.920]                       }
[11:01:02.920]                     }
[11:01:02.920]                     invisible(muffled)
[11:01:02.920]                   }
[11:01:02.920]                   muffleCondition(cond)
[11:01:02.920]                 })
[11:01:02.920]             }))
[11:01:02.920]             future::FutureResult(value = ...future.value$value, 
[11:01:02.920]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:02.920]                   ...future.rng), globalenv = if (FALSE) 
[11:01:02.920]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:02.920]                     ...future.globalenv.names))
[11:01:02.920]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:02.920]         }, condition = base::local({
[11:01:02.920]             c <- base::c
[11:01:02.920]             inherits <- base::inherits
[11:01:02.920]             invokeRestart <- base::invokeRestart
[11:01:02.920]             length <- base::length
[11:01:02.920]             list <- base::list
[11:01:02.920]             seq.int <- base::seq.int
[11:01:02.920]             signalCondition <- base::signalCondition
[11:01:02.920]             sys.calls <- base::sys.calls
[11:01:02.920]             `[[` <- base::`[[`
[11:01:02.920]             `+` <- base::`+`
[11:01:02.920]             `<<-` <- base::`<<-`
[11:01:02.920]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:02.920]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:02.920]                   3L)]
[11:01:02.920]             }
[11:01:02.920]             function(cond) {
[11:01:02.920]                 is_error <- inherits(cond, "error")
[11:01:02.920]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:02.920]                   NULL)
[11:01:02.920]                 if (is_error) {
[11:01:02.920]                   sessionInformation <- function() {
[11:01:02.920]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:02.920]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:02.920]                       search = base::search(), system = base::Sys.info())
[11:01:02.920]                   }
[11:01:02.920]                   ...future.conditions[[length(...future.conditions) + 
[11:01:02.920]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:02.920]                     cond$call), session = sessionInformation(), 
[11:01:02.920]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:02.920]                   signalCondition(cond)
[11:01:02.920]                 }
[11:01:02.920]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:02.920]                 "immediateCondition"))) {
[11:01:02.920]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:02.920]                   ...future.conditions[[length(...future.conditions) + 
[11:01:02.920]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:02.920]                   if (TRUE && !signal) {
[11:01:02.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:02.920]                     {
[11:01:02.920]                       inherits <- base::inherits
[11:01:02.920]                       invokeRestart <- base::invokeRestart
[11:01:02.920]                       is.null <- base::is.null
[11:01:02.920]                       muffled <- FALSE
[11:01:02.920]                       if (inherits(cond, "message")) {
[11:01:02.920]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:02.920]                         if (muffled) 
[11:01:02.920]                           invokeRestart("muffleMessage")
[11:01:02.920]                       }
[11:01:02.920]                       else if (inherits(cond, "warning")) {
[11:01:02.920]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:02.920]                         if (muffled) 
[11:01:02.920]                           invokeRestart("muffleWarning")
[11:01:02.920]                       }
[11:01:02.920]                       else if (inherits(cond, "condition")) {
[11:01:02.920]                         if (!is.null(pattern)) {
[11:01:02.920]                           computeRestarts <- base::computeRestarts
[11:01:02.920]                           grepl <- base::grepl
[11:01:02.920]                           restarts <- computeRestarts(cond)
[11:01:02.920]                           for (restart in restarts) {
[11:01:02.920]                             name <- restart$name
[11:01:02.920]                             if (is.null(name)) 
[11:01:02.920]                               next
[11:01:02.920]                             if (!grepl(pattern, name)) 
[11:01:02.920]                               next
[11:01:02.920]                             invokeRestart(restart)
[11:01:02.920]                             muffled <- TRUE
[11:01:02.920]                             break
[11:01:02.920]                           }
[11:01:02.920]                         }
[11:01:02.920]                       }
[11:01:02.920]                       invisible(muffled)
[11:01:02.920]                     }
[11:01:02.920]                     muffleCondition(cond, pattern = "^muffle")
[11:01:02.920]                   }
[11:01:02.920]                 }
[11:01:02.920]                 else {
[11:01:02.920]                   if (TRUE) {
[11:01:02.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:02.920]                     {
[11:01:02.920]                       inherits <- base::inherits
[11:01:02.920]                       invokeRestart <- base::invokeRestart
[11:01:02.920]                       is.null <- base::is.null
[11:01:02.920]                       muffled <- FALSE
[11:01:02.920]                       if (inherits(cond, "message")) {
[11:01:02.920]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:02.920]                         if (muffled) 
[11:01:02.920]                           invokeRestart("muffleMessage")
[11:01:02.920]                       }
[11:01:02.920]                       else if (inherits(cond, "warning")) {
[11:01:02.920]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:02.920]                         if (muffled) 
[11:01:02.920]                           invokeRestart("muffleWarning")
[11:01:02.920]                       }
[11:01:02.920]                       else if (inherits(cond, "condition")) {
[11:01:02.920]                         if (!is.null(pattern)) {
[11:01:02.920]                           computeRestarts <- base::computeRestarts
[11:01:02.920]                           grepl <- base::grepl
[11:01:02.920]                           restarts <- computeRestarts(cond)
[11:01:02.920]                           for (restart in restarts) {
[11:01:02.920]                             name <- restart$name
[11:01:02.920]                             if (is.null(name)) 
[11:01:02.920]                               next
[11:01:02.920]                             if (!grepl(pattern, name)) 
[11:01:02.920]                               next
[11:01:02.920]                             invokeRestart(restart)
[11:01:02.920]                             muffled <- TRUE
[11:01:02.920]                             break
[11:01:02.920]                           }
[11:01:02.920]                         }
[11:01:02.920]                       }
[11:01:02.920]                       invisible(muffled)
[11:01:02.920]                     }
[11:01:02.920]                     muffleCondition(cond, pattern = "^muffle")
[11:01:02.920]                   }
[11:01:02.920]                 }
[11:01:02.920]             }
[11:01:02.920]         }))
[11:01:02.920]     }, error = function(ex) {
[11:01:02.920]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:02.920]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:02.920]                 ...future.rng), started = ...future.startTime, 
[11:01:02.920]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:02.920]             version = "1.8"), class = "FutureResult")
[11:01:02.920]     }, finally = {
[11:01:02.920]         if (!identical(...future.workdir, getwd())) 
[11:01:02.920]             setwd(...future.workdir)
[11:01:02.920]         {
[11:01:02.920]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:02.920]                 ...future.oldOptions$nwarnings <- NULL
[11:01:02.920]             }
[11:01:02.920]             base::options(...future.oldOptions)
[11:01:02.920]             if (.Platform$OS.type == "windows") {
[11:01:02.920]                 old_names <- names(...future.oldEnvVars)
[11:01:02.920]                 envs <- base::Sys.getenv()
[11:01:02.920]                 names <- names(envs)
[11:01:02.920]                 common <- intersect(names, old_names)
[11:01:02.920]                 added <- setdiff(names, old_names)
[11:01:02.920]                 removed <- setdiff(old_names, names)
[11:01:02.920]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:02.920]                   envs[common]]
[11:01:02.920]                 NAMES <- toupper(changed)
[11:01:02.920]                 args <- list()
[11:01:02.920]                 for (kk in seq_along(NAMES)) {
[11:01:02.920]                   name <- changed[[kk]]
[11:01:02.920]                   NAME <- NAMES[[kk]]
[11:01:02.920]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.920]                     next
[11:01:02.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:02.920]                 }
[11:01:02.920]                 NAMES <- toupper(added)
[11:01:02.920]                 for (kk in seq_along(NAMES)) {
[11:01:02.920]                   name <- added[[kk]]
[11:01:02.920]                   NAME <- NAMES[[kk]]
[11:01:02.920]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.920]                     next
[11:01:02.920]                   args[[name]] <- ""
[11:01:02.920]                 }
[11:01:02.920]                 NAMES <- toupper(removed)
[11:01:02.920]                 for (kk in seq_along(NAMES)) {
[11:01:02.920]                   name <- removed[[kk]]
[11:01:02.920]                   NAME <- NAMES[[kk]]
[11:01:02.920]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.920]                     next
[11:01:02.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:02.920]                 }
[11:01:02.920]                 if (length(args) > 0) 
[11:01:02.920]                   base::do.call(base::Sys.setenv, args = args)
[11:01:02.920]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:02.920]             }
[11:01:02.920]             else {
[11:01:02.920]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:02.920]             }
[11:01:02.920]             {
[11:01:02.920]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:02.920]                   0L) {
[11:01:02.920]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:02.920]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:02.920]                   base::options(opts)
[11:01:02.920]                 }
[11:01:02.920]                 {
[11:01:02.920]                   {
[11:01:02.920]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:02.920]                     NULL
[11:01:02.920]                   }
[11:01:02.920]                   options(future.plan = NULL)
[11:01:02.920]                   if (is.na(NA_character_)) 
[11:01:02.920]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:02.920]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:02.920]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:02.920]                     .init = FALSE)
[11:01:02.920]                 }
[11:01:02.920]             }
[11:01:02.920]         }
[11:01:02.920]     })
[11:01:02.920]     if (TRUE) {
[11:01:02.920]         base::sink(type = "output", split = FALSE)
[11:01:02.920]         if (TRUE) {
[11:01:02.920]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:02.920]         }
[11:01:02.920]         else {
[11:01:02.920]             ...future.result["stdout"] <- base::list(NULL)
[11:01:02.920]         }
[11:01:02.920]         base::close(...future.stdout)
[11:01:02.920]         ...future.stdout <- NULL
[11:01:02.920]     }
[11:01:02.920]     ...future.result$conditions <- ...future.conditions
[11:01:02.920]     ...future.result$finished <- base::Sys.time()
[11:01:02.920]     ...future.result
[11:01:02.920] }
[11:01:02.923] assign_globals() ...
[11:01:02.923] List of 4
[11:01:02.923]  $ ii   : int 2
[11:01:02.923]  $ n    : int 4
[11:01:02.923]  $ C    : cplx [1:25, 1:25] -0.719-1.5i -0.719-1.44i -0.719-1.38i ...
[11:01:02.923]   ..- attr(*, "region")=List of 2
[11:01:02.923]   .. ..$ xrange: num [1:2] -0.719 0.75
[11:01:02.923]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[11:01:02.923]   ..- attr(*, "tile")= int [1:2] 1 2
[11:01:02.923]  $ delay:function (counts)  
[11:01:02.923]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[11:01:02.923]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x56491639efc0> 
[11:01:02.923]  - attr(*, "where")=List of 4
[11:01:02.923]   ..$ ii   :<environment: R_EmptyEnv> 
[11:01:02.923]   ..$ n    :<environment: R_EmptyEnv> 
[11:01:02.923]   ..$ C    :<environment: R_EmptyEnv> 
[11:01:02.923]   ..$ delay:<environment: R_EmptyEnv> 
[11:01:02.923]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:02.923]  - attr(*, "resolved")= logi FALSE
[11:01:02.923]  - attr(*, "total_size")= num 58781
[11:01:02.923]  - attr(*, "already-done")= logi TRUE
[11:01:02.930] - copied ‘ii’ to environment
[11:01:02.930] - copied ‘n’ to environment
[11:01:02.930] - copied ‘C’ to environment
[11:01:02.930] - reassign environment for ‘delay’
[11:01:02.930] - copied ‘delay’ to environment
[11:01:02.930] assign_globals() ... done
[11:01:02.931] requestCore(): workers = 2
[11:01:02.933] MulticoreFuture started
[11:01:02.933] - Launch lazy future ... done
[11:01:02.933] run() for ‘MulticoreFuture’ ... done
[11:01:02.934] - run() ... done
[11:01:02.934] - resolved() ...
[11:01:02.934] plan(): Setting new future strategy stack:
[11:01:02.934] List of future strategies:
[11:01:02.934] 1. sequential:
[11:01:02.934]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:02.934]    - tweaked: FALSE
[11:01:02.934]    - call: NULL
[11:01:02.935] plan(): nbrOfWorkers() = 1
[11:01:02.940] plan(): Setting new future strategy stack:
[11:01:02.940] List of future strategies:
[11:01:02.940] 1. multicore:
[11:01:02.940]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:02.940]    - tweaked: FALSE
[11:01:02.940]    - call: plan(strategy)
[11:01:02.944] plan(): nbrOfWorkers() = 2
[11:01:02.945] - resolved: FALSE
[11:01:02.945] - resolved() ... done
[11:01:02.945] resolved() for ‘MulticoreFuture’ ... done
[11:01:02.945] resolved() for ‘Future’ ...
[11:01:02.945] - state: ‘created’
[11:01:02.945] - run: TRUE
[11:01:02.945] - run() ...
[11:01:02.946] run() for ‘Future’ ...
[11:01:02.946] - state: ‘created’
[11:01:02.946] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:02.949] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:02.949] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:02.949]   - Field: ‘label’
[11:01:02.949]   - Field: ‘local’
[11:01:02.949]   - Field: ‘owner’
[11:01:02.949]   - Field: ‘envir’
[11:01:02.949]   - Field: ‘workers’
[11:01:02.950]   - Field: ‘packages’
[11:01:02.950]   - Field: ‘gc’
[11:01:02.950]   - Field: ‘job’
[11:01:02.950]   - Field: ‘conditions’
[11:01:02.950]   - Field: ‘expr’
[11:01:02.950]   - Field: ‘uuid’
[11:01:02.951]   - Field: ‘seed’
[11:01:02.951]   - Field: ‘version’
[11:01:02.951]   - Field: ‘result’
[11:01:02.951]   - Field: ‘asynchronous’
[11:01:02.951]   - Field: ‘calls’
[11:01:02.951]   - Field: ‘globals’
[11:01:02.952]   - Field: ‘stdout’
[11:01:02.952]   - Field: ‘earlySignal’
[11:01:02.952]   - Field: ‘lazy’
[11:01:02.952]   - Field: ‘state’
[11:01:02.952] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:02.952] - Launch lazy future ...
[11:01:02.953] Packages needed by the future expression (n = 1): ‘future’
[11:01:02.953] Packages needed by future strategies (n = 0): <none>
[11:01:02.954] {
[11:01:02.954]     {
[11:01:02.954]         {
[11:01:02.954]             ...future.startTime <- base::Sys.time()
[11:01:02.954]             {
[11:01:02.954]                 {
[11:01:02.954]                   {
[11:01:02.954]                     {
[11:01:02.954]                       {
[11:01:02.954]                         base::local({
[11:01:02.954]                           has_future <- base::requireNamespace("future", 
[11:01:02.954]                             quietly = TRUE)
[11:01:02.954]                           if (has_future) {
[11:01:02.954]                             ns <- base::getNamespace("future")
[11:01:02.954]                             version <- ns[[".package"]][["version"]]
[11:01:02.954]                             if (is.null(version)) 
[11:01:02.954]                               version <- utils::packageVersion("future")
[11:01:02.954]                           }
[11:01:02.954]                           else {
[11:01:02.954]                             version <- NULL
[11:01:02.954]                           }
[11:01:02.954]                           if (!has_future || version < "1.8.0") {
[11:01:02.954]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:02.954]                               "", base::R.version$version.string), 
[11:01:02.954]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:02.954]                                 base::R.version$platform, 8 * 
[11:01:02.954]                                   base::.Machine$sizeof.pointer), 
[11:01:02.954]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:02.954]                                 "release", "version")], collapse = " "), 
[11:01:02.954]                               hostname = base::Sys.info()[["nodename"]])
[11:01:02.954]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:02.954]                               info)
[11:01:02.954]                             info <- base::paste(info, collapse = "; ")
[11:01:02.954]                             if (!has_future) {
[11:01:02.954]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:02.954]                                 info)
[11:01:02.954]                             }
[11:01:02.954]                             else {
[11:01:02.954]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:02.954]                                 info, version)
[11:01:02.954]                             }
[11:01:02.954]                             base::stop(msg)
[11:01:02.954]                           }
[11:01:02.954]                         })
[11:01:02.954]                       }
[11:01:02.954]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:02.954]                       base::options(mc.cores = 1L)
[11:01:02.954]                     }
[11:01:02.954]                     base::local({
[11:01:02.954]                       for (pkg in "future") {
[11:01:02.954]                         base::loadNamespace(pkg)
[11:01:02.954]                         base::library(pkg, character.only = TRUE)
[11:01:02.954]                       }
[11:01:02.954]                     })
[11:01:02.954]                   }
[11:01:02.954]                   ...future.strategy.old <- future::plan("list")
[11:01:02.954]                   options(future.plan = NULL)
[11:01:02.954]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:02.954]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:02.954]                 }
[11:01:02.954]                 ...future.workdir <- getwd()
[11:01:02.954]             }
[11:01:02.954]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:02.954]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:02.954]         }
[11:01:02.954]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:02.954]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:02.954]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:02.954]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:02.954]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:02.954]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:02.954]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:02.954]             base::names(...future.oldOptions))
[11:01:02.954]     }
[11:01:02.954]     if (FALSE) {
[11:01:02.954]     }
[11:01:02.954]     else {
[11:01:02.954]         if (TRUE) {
[11:01:02.954]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:02.954]                 open = "w")
[11:01:02.954]         }
[11:01:02.954]         else {
[11:01:02.954]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:02.954]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:02.954]         }
[11:01:02.954]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:02.954]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:02.954]             base::sink(type = "output", split = FALSE)
[11:01:02.954]             base::close(...future.stdout)
[11:01:02.954]         }, add = TRUE)
[11:01:02.954]     }
[11:01:02.954]     ...future.frame <- base::sys.nframe()
[11:01:02.954]     ...future.conditions <- base::list()
[11:01:02.954]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:02.954]     if (FALSE) {
[11:01:02.954]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:02.954]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:02.954]     }
[11:01:02.954]     ...future.result <- base::tryCatch({
[11:01:02.954]         base::withCallingHandlers({
[11:01:02.954]             ...future.value <- base::withVisible(base::local({
[11:01:02.954]                 withCallingHandlers({
[11:01:02.954]                   {
[11:01:02.954]                     message(sprintf("Calculating tile #%d of %d ...", 
[11:01:02.954]                       ii, n), appendLF = FALSE)
[11:01:02.954]                     fit <- mandelbrot(C)
[11:01:02.954]                     delay(fit)
[11:01:02.954]                     message(" done")
[11:01:02.954]                     fit
[11:01:02.954]                   }
[11:01:02.954]                 }, immediateCondition = function(cond) {
[11:01:02.954]                   save_rds <- function (object, pathname, ...) 
[11:01:02.954]                   {
[11:01:02.954]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:02.954]                     if (file_test("-f", pathname_tmp)) {
[11:01:02.954]                       fi_tmp <- file.info(pathname_tmp)
[11:01:02.954]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:02.954]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:02.954]                         fi_tmp[["mtime"]])
[11:01:02.954]                     }
[11:01:02.954]                     tryCatch({
[11:01:02.954]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:02.954]                     }, error = function(ex) {
[11:01:02.954]                       msg <- conditionMessage(ex)
[11:01:02.954]                       fi_tmp <- file.info(pathname_tmp)
[11:01:02.954]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:02.954]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:02.954]                         fi_tmp[["mtime"]], msg)
[11:01:02.954]                       ex$message <- msg
[11:01:02.954]                       stop(ex)
[11:01:02.954]                     })
[11:01:02.954]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:02.954]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:02.954]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:02.954]                       fi_tmp <- file.info(pathname_tmp)
[11:01:02.954]                       fi <- file.info(pathname)
[11:01:02.954]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:02.954]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:02.954]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:02.954]                         fi[["size"]], fi[["mtime"]])
[11:01:02.954]                       stop(msg)
[11:01:02.954]                     }
[11:01:02.954]                     invisible(pathname)
[11:01:02.954]                   }
[11:01:02.954]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:02.954]                     rootPath = tempdir()) 
[11:01:02.954]                   {
[11:01:02.954]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:02.954]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:02.954]                       tmpdir = path, fileext = ".rds")
[11:01:02.954]                     save_rds(obj, file)
[11:01:02.954]                   }
[11:01:02.954]                   saveImmediateCondition(cond, path = "/tmp/Rtmpbx4bQL/.future/immediateConditions")
[11:01:02.954]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:02.954]                   {
[11:01:02.954]                     inherits <- base::inherits
[11:01:02.954]                     invokeRestart <- base::invokeRestart
[11:01:02.954]                     is.null <- base::is.null
[11:01:02.954]                     muffled <- FALSE
[11:01:02.954]                     if (inherits(cond, "message")) {
[11:01:02.954]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:02.954]                       if (muffled) 
[11:01:02.954]                         invokeRestart("muffleMessage")
[11:01:02.954]                     }
[11:01:02.954]                     else if (inherits(cond, "warning")) {
[11:01:02.954]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:02.954]                       if (muffled) 
[11:01:02.954]                         invokeRestart("muffleWarning")
[11:01:02.954]                     }
[11:01:02.954]                     else if (inherits(cond, "condition")) {
[11:01:02.954]                       if (!is.null(pattern)) {
[11:01:02.954]                         computeRestarts <- base::computeRestarts
[11:01:02.954]                         grepl <- base::grepl
[11:01:02.954]                         restarts <- computeRestarts(cond)
[11:01:02.954]                         for (restart in restarts) {
[11:01:02.954]                           name <- restart$name
[11:01:02.954]                           if (is.null(name)) 
[11:01:02.954]                             next
[11:01:02.954]                           if (!grepl(pattern, name)) 
[11:01:02.954]                             next
[11:01:02.954]                           invokeRestart(restart)
[11:01:02.954]                           muffled <- TRUE
[11:01:02.954]                           break
[11:01:02.954]                         }
[11:01:02.954]                       }
[11:01:02.954]                     }
[11:01:02.954]                     invisible(muffled)
[11:01:02.954]                   }
[11:01:02.954]                   muffleCondition(cond)
[11:01:02.954]                 })
[11:01:02.954]             }))
[11:01:02.954]             future::FutureResult(value = ...future.value$value, 
[11:01:02.954]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:02.954]                   ...future.rng), globalenv = if (FALSE) 
[11:01:02.954]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:02.954]                     ...future.globalenv.names))
[11:01:02.954]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:02.954]         }, condition = base::local({
[11:01:02.954]             c <- base::c
[11:01:02.954]             inherits <- base::inherits
[11:01:02.954]             invokeRestart <- base::invokeRestart
[11:01:02.954]             length <- base::length
[11:01:02.954]             list <- base::list
[11:01:02.954]             seq.int <- base::seq.int
[11:01:02.954]             signalCondition <- base::signalCondition
[11:01:02.954]             sys.calls <- base::sys.calls
[11:01:02.954]             `[[` <- base::`[[`
[11:01:02.954]             `+` <- base::`+`
[11:01:02.954]             `<<-` <- base::`<<-`
[11:01:02.954]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:02.954]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:02.954]                   3L)]
[11:01:02.954]             }
[11:01:02.954]             function(cond) {
[11:01:02.954]                 is_error <- inherits(cond, "error")
[11:01:02.954]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:02.954]                   NULL)
[11:01:02.954]                 if (is_error) {
[11:01:02.954]                   sessionInformation <- function() {
[11:01:02.954]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:02.954]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:02.954]                       search = base::search(), system = base::Sys.info())
[11:01:02.954]                   }
[11:01:02.954]                   ...future.conditions[[length(...future.conditions) + 
[11:01:02.954]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:02.954]                     cond$call), session = sessionInformation(), 
[11:01:02.954]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:02.954]                   signalCondition(cond)
[11:01:02.954]                 }
[11:01:02.954]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:02.954]                 "immediateCondition"))) {
[11:01:02.954]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:02.954]                   ...future.conditions[[length(...future.conditions) + 
[11:01:02.954]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:02.954]                   if (TRUE && !signal) {
[11:01:02.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:02.954]                     {
[11:01:02.954]                       inherits <- base::inherits
[11:01:02.954]                       invokeRestart <- base::invokeRestart
[11:01:02.954]                       is.null <- base::is.null
[11:01:02.954]                       muffled <- FALSE
[11:01:02.954]                       if (inherits(cond, "message")) {
[11:01:02.954]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:02.954]                         if (muffled) 
[11:01:02.954]                           invokeRestart("muffleMessage")
[11:01:02.954]                       }
[11:01:02.954]                       else if (inherits(cond, "warning")) {
[11:01:02.954]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:02.954]                         if (muffled) 
[11:01:02.954]                           invokeRestart("muffleWarning")
[11:01:02.954]                       }
[11:01:02.954]                       else if (inherits(cond, "condition")) {
[11:01:02.954]                         if (!is.null(pattern)) {
[11:01:02.954]                           computeRestarts <- base::computeRestarts
[11:01:02.954]                           grepl <- base::grepl
[11:01:02.954]                           restarts <- computeRestarts(cond)
[11:01:02.954]                           for (restart in restarts) {
[11:01:02.954]                             name <- restart$name
[11:01:02.954]                             if (is.null(name)) 
[11:01:02.954]                               next
[11:01:02.954]                             if (!grepl(pattern, name)) 
[11:01:02.954]                               next
[11:01:02.954]                             invokeRestart(restart)
[11:01:02.954]                             muffled <- TRUE
[11:01:02.954]                             break
[11:01:02.954]                           }
[11:01:02.954]                         }
[11:01:02.954]                       }
[11:01:02.954]                       invisible(muffled)
[11:01:02.954]                     }
[11:01:02.954]                     muffleCondition(cond, pattern = "^muffle")
[11:01:02.954]                   }
[11:01:02.954]                 }
[11:01:02.954]                 else {
[11:01:02.954]                   if (TRUE) {
[11:01:02.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:02.954]                     {
[11:01:02.954]                       inherits <- base::inherits
[11:01:02.954]                       invokeRestart <- base::invokeRestart
[11:01:02.954]                       is.null <- base::is.null
[11:01:02.954]                       muffled <- FALSE
[11:01:02.954]                       if (inherits(cond, "message")) {
[11:01:02.954]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:02.954]                         if (muffled) 
[11:01:02.954]                           invokeRestart("muffleMessage")
[11:01:02.954]                       }
[11:01:02.954]                       else if (inherits(cond, "warning")) {
[11:01:02.954]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:02.954]                         if (muffled) 
[11:01:02.954]                           invokeRestart("muffleWarning")
[11:01:02.954]                       }
[11:01:02.954]                       else if (inherits(cond, "condition")) {
[11:01:02.954]                         if (!is.null(pattern)) {
[11:01:02.954]                           computeRestarts <- base::computeRestarts
[11:01:02.954]                           grepl <- base::grepl
[11:01:02.954]                           restarts <- computeRestarts(cond)
[11:01:02.954]                           for (restart in restarts) {
[11:01:02.954]                             name <- restart$name
[11:01:02.954]                             if (is.null(name)) 
[11:01:02.954]                               next
[11:01:02.954]                             if (!grepl(pattern, name)) 
[11:01:02.954]                               next
[11:01:02.954]                             invokeRestart(restart)
[11:01:02.954]                             muffled <- TRUE
[11:01:02.954]                             break
[11:01:02.954]                           }
[11:01:02.954]                         }
[11:01:02.954]                       }
[11:01:02.954]                       invisible(muffled)
[11:01:02.954]                     }
[11:01:02.954]                     muffleCondition(cond, pattern = "^muffle")
[11:01:02.954]                   }
[11:01:02.954]                 }
[11:01:02.954]             }
[11:01:02.954]         }))
[11:01:02.954]     }, error = function(ex) {
[11:01:02.954]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:02.954]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:02.954]                 ...future.rng), started = ...future.startTime, 
[11:01:02.954]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:02.954]             version = "1.8"), class = "FutureResult")
[11:01:02.954]     }, finally = {
[11:01:02.954]         if (!identical(...future.workdir, getwd())) 
[11:01:02.954]             setwd(...future.workdir)
[11:01:02.954]         {
[11:01:02.954]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:02.954]                 ...future.oldOptions$nwarnings <- NULL
[11:01:02.954]             }
[11:01:02.954]             base::options(...future.oldOptions)
[11:01:02.954]             if (.Platform$OS.type == "windows") {
[11:01:02.954]                 old_names <- names(...future.oldEnvVars)
[11:01:02.954]                 envs <- base::Sys.getenv()
[11:01:02.954]                 names <- names(envs)
[11:01:02.954]                 common <- intersect(names, old_names)
[11:01:02.954]                 added <- setdiff(names, old_names)
[11:01:02.954]                 removed <- setdiff(old_names, names)
[11:01:02.954]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:02.954]                   envs[common]]
[11:01:02.954]                 NAMES <- toupper(changed)
[11:01:02.954]                 args <- list()
[11:01:02.954]                 for (kk in seq_along(NAMES)) {
[11:01:02.954]                   name <- changed[[kk]]
[11:01:02.954]                   NAME <- NAMES[[kk]]
[11:01:02.954]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.954]                     next
[11:01:02.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:02.954]                 }
[11:01:02.954]                 NAMES <- toupper(added)
[11:01:02.954]                 for (kk in seq_along(NAMES)) {
[11:01:02.954]                   name <- added[[kk]]
[11:01:02.954]                   NAME <- NAMES[[kk]]
[11:01:02.954]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.954]                     next
[11:01:02.954]                   args[[name]] <- ""
[11:01:02.954]                 }
[11:01:02.954]                 NAMES <- toupper(removed)
[11:01:02.954]                 for (kk in seq_along(NAMES)) {
[11:01:02.954]                   name <- removed[[kk]]
[11:01:02.954]                   NAME <- NAMES[[kk]]
[11:01:02.954]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.954]                     next
[11:01:02.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:02.954]                 }
[11:01:02.954]                 if (length(args) > 0) 
[11:01:02.954]                   base::do.call(base::Sys.setenv, args = args)
[11:01:02.954]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:02.954]             }
[11:01:02.954]             else {
[11:01:02.954]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:02.954]             }
[11:01:02.954]             {
[11:01:02.954]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:02.954]                   0L) {
[11:01:02.954]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:02.954]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:02.954]                   base::options(opts)
[11:01:02.954]                 }
[11:01:02.954]                 {
[11:01:02.954]                   {
[11:01:02.954]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:02.954]                     NULL
[11:01:02.954]                   }
[11:01:02.954]                   options(future.plan = NULL)
[11:01:02.954]                   if (is.na(NA_character_)) 
[11:01:02.954]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:02.954]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:02.954]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:02.954]                     .init = FALSE)
[11:01:02.954]                 }
[11:01:02.954]             }
[11:01:02.954]         }
[11:01:02.954]     })
[11:01:02.954]     if (TRUE) {
[11:01:02.954]         base::sink(type = "output", split = FALSE)
[11:01:02.954]         if (TRUE) {
[11:01:02.954]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:02.954]         }
[11:01:02.954]         else {
[11:01:02.954]             ...future.result["stdout"] <- base::list(NULL)
[11:01:02.954]         }
[11:01:02.954]         base::close(...future.stdout)
[11:01:02.954]         ...future.stdout <- NULL
[11:01:02.954]     }
[11:01:02.954]     ...future.result$conditions <- ...future.conditions
[11:01:02.954]     ...future.result$finished <- base::Sys.time()
[11:01:02.954]     ...future.result
[11:01:02.954] }
[11:01:02.958] assign_globals() ...
[11:01:02.958] List of 4
[11:01:02.958]  $ ii   : int 3
[11:01:02.958]  $ n    : int 4
[11:01:02.958]  $ C    : cplx [1:25, 1:25] -2.25+0.0306i -2.25+0.0918i -2.25+0.1531i ...
[11:01:02.958]   ..- attr(*, "region")=List of 2
[11:01:02.958]   .. ..$ xrange: num [1:2] -2.25 -0.781
[11:01:02.958]   .. ..$ yrange: num [1:2] 0.0306 1.5
[11:01:02.958]   ..- attr(*, "tile")= int [1:2] 2 1
[11:01:02.958]  $ delay:function (counts)  
[11:01:02.958]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[11:01:02.958]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x56491639efc0> 
[11:01:02.958]  - attr(*, "where")=List of 4
[11:01:02.958]   ..$ ii   :<environment: R_EmptyEnv> 
[11:01:02.958]   ..$ n    :<environment: R_EmptyEnv> 
[11:01:02.958]   ..$ C    :<environment: R_EmptyEnv> 
[11:01:02.958]   ..$ delay:<environment: R_EmptyEnv> 
[11:01:02.958]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:02.958]  - attr(*, "resolved")= logi FALSE
[11:01:02.958]  - attr(*, "total_size")= num 58781
[11:01:02.958]  - attr(*, "already-done")= logi TRUE
[11:01:02.968] - copied ‘ii’ to environment
[11:01:02.968] - copied ‘n’ to environment
[11:01:02.968] - copied ‘C’ to environment
[11:01:02.968] - reassign environment for ‘delay’
[11:01:02.968] - copied ‘delay’ to environment
[11:01:02.969] assign_globals() ... done
[11:01:02.969] requestCore(): workers = 2
[11:01:02.971] MulticoreFuture started
[11:01:02.972] - Launch lazy future ... done
[11:01:02.972] run() for ‘MulticoreFuture’ ... done
[11:01:02.972] - run() ... done
[11:01:02.972] - resolved() ...
[11:01:02.973] plan(): Setting new future strategy stack:
[11:01:02.973] List of future strategies:
[11:01:02.973] 1. sequential:
[11:01:02.973]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:02.973]    - tweaked: FALSE
[11:01:02.973]    - call: NULL
[11:01:02.974] plan(): nbrOfWorkers() = 1
[11:01:02.979] plan(): Setting new future strategy stack:
[11:01:02.979] List of future strategies:
[11:01:02.979] 1. multicore:
[11:01:02.979]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:02.979]    - tweaked: FALSE
[11:01:02.979]    - call: plan(strategy)
[11:01:02.982] plan(): nbrOfWorkers() = 2
[11:01:02.983] - resolved: TRUE
[11:01:02.983] - resolved() ... done
[11:01:02.983] resolved() for ‘MulticoreFuture’ ... done
Plotting tile #3 of 4 ...
[11:01:02.984] result() for MulticoreFuture ...
[11:01:02.985] result() for MulticoreFuture ...
[11:01:02.985] result() for MulticoreFuture ... done
[11:01:02.985] signalConditions() ...
[11:01:02.986]  - include = ‘immediateCondition’
[11:01:02.986]  - exclude = 
[11:01:02.986]  - resignal = FALSE
[11:01:02.986]  - Number of conditions: 2
[11:01:02.986] signalConditions() ... done
[11:01:02.986] result() for MulticoreFuture ... done
[11:01:02.987] result() for MulticoreFuture ...
[11:01:02.987] result() for MulticoreFuture ... done
[11:01:02.987] signalConditions() ...
[11:01:02.987]  - include = ‘immediateCondition’
[11:01:02.987]  - exclude = 
[11:01:02.987]  - resignal = FALSE
[11:01:02.987]  - Number of conditions: 2
[11:01:02.988] signalConditions() ... done
[11:01:02.988] Future state: ‘finished’
[11:01:02.988] result() for MulticoreFuture ...
[11:01:02.988] result() for MulticoreFuture ... done
[11:01:02.988] signalConditions() ...
[11:01:02.988]  - include = ‘condition’
[11:01:02.989]  - exclude = ‘immediateCondition’
[11:01:02.989]  - resignal = TRUE
[11:01:02.989]  - Number of conditions: 2
[11:01:02.989]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[11:01:02.989]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[11:01:02.990] signalConditions() ... done
[11:01:02.991] resolved() for ‘Future’ ...
[11:01:02.991] - state: ‘created’
[11:01:02.991] - run: TRUE
[11:01:02.991] - run() ...
[11:01:02.992] run() for ‘Future’ ...
[11:01:02.992] - state: ‘created’
[11:01:02.992] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:02.995] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:02.995] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:02.995]   - Field: ‘label’
[11:01:02.995]   - Field: ‘local’
[11:01:02.995]   - Field: ‘owner’
[11:01:02.995]   - Field: ‘envir’
[11:01:02.995]   - Field: ‘workers’
[11:01:02.996]   - Field: ‘packages’
[11:01:02.996]   - Field: ‘gc’
[11:01:02.996]   - Field: ‘job’
[11:01:02.996]   - Field: ‘conditions’
[11:01:02.996]   - Field: ‘expr’
[11:01:02.996]   - Field: ‘uuid’
[11:01:02.996]   - Field: ‘seed’
[11:01:02.996]   - Field: ‘version’
[11:01:02.997]   - Field: ‘result’
[11:01:02.997]   - Field: ‘asynchronous’
[11:01:02.997]   - Field: ‘calls’
[11:01:02.997]   - Field: ‘globals’
[11:01:02.997]   - Field: ‘stdout’
[11:01:02.997]   - Field: ‘earlySignal’
[11:01:02.997]   - Field: ‘lazy’
[11:01:02.998]   - Field: ‘state’
[11:01:02.998] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:02.998] - Launch lazy future ...
[11:01:02.998] Packages needed by the future expression (n = 1): ‘future’
[11:01:02.998] Packages needed by future strategies (n = 0): <none>
[11:01:02.999] {
[11:01:02.999]     {
[11:01:02.999]         {
[11:01:02.999]             ...future.startTime <- base::Sys.time()
[11:01:02.999]             {
[11:01:02.999]                 {
[11:01:02.999]                   {
[11:01:02.999]                     {
[11:01:02.999]                       {
[11:01:02.999]                         base::local({
[11:01:02.999]                           has_future <- base::requireNamespace("future", 
[11:01:02.999]                             quietly = TRUE)
[11:01:02.999]                           if (has_future) {
[11:01:02.999]                             ns <- base::getNamespace("future")
[11:01:02.999]                             version <- ns[[".package"]][["version"]]
[11:01:02.999]                             if (is.null(version)) 
[11:01:02.999]                               version <- utils::packageVersion("future")
[11:01:02.999]                           }
[11:01:02.999]                           else {
[11:01:02.999]                             version <- NULL
[11:01:02.999]                           }
[11:01:02.999]                           if (!has_future || version < "1.8.0") {
[11:01:02.999]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:02.999]                               "", base::R.version$version.string), 
[11:01:02.999]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:02.999]                                 base::R.version$platform, 8 * 
[11:01:02.999]                                   base::.Machine$sizeof.pointer), 
[11:01:02.999]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:02.999]                                 "release", "version")], collapse = " "), 
[11:01:02.999]                               hostname = base::Sys.info()[["nodename"]])
[11:01:02.999]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:02.999]                               info)
[11:01:02.999]                             info <- base::paste(info, collapse = "; ")
[11:01:02.999]                             if (!has_future) {
[11:01:02.999]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:02.999]                                 info)
[11:01:02.999]                             }
[11:01:02.999]                             else {
[11:01:02.999]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:02.999]                                 info, version)
[11:01:02.999]                             }
[11:01:02.999]                             base::stop(msg)
[11:01:02.999]                           }
[11:01:02.999]                         })
[11:01:02.999]                       }
[11:01:02.999]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:02.999]                       base::options(mc.cores = 1L)
[11:01:02.999]                     }
[11:01:02.999]                     base::local({
[11:01:02.999]                       for (pkg in "future") {
[11:01:02.999]                         base::loadNamespace(pkg)
[11:01:02.999]                         base::library(pkg, character.only = TRUE)
[11:01:02.999]                       }
[11:01:02.999]                     })
[11:01:02.999]                   }
[11:01:02.999]                   ...future.strategy.old <- future::plan("list")
[11:01:02.999]                   options(future.plan = NULL)
[11:01:02.999]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:02.999]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:02.999]                 }
[11:01:02.999]                 ...future.workdir <- getwd()
[11:01:02.999]             }
[11:01:02.999]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:02.999]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:02.999]         }
[11:01:02.999]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:02.999]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:02.999]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:02.999]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:02.999]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:02.999]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:02.999]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:02.999]             base::names(...future.oldOptions))
[11:01:02.999]     }
[11:01:02.999]     if (FALSE) {
[11:01:02.999]     }
[11:01:02.999]     else {
[11:01:02.999]         if (TRUE) {
[11:01:02.999]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:02.999]                 open = "w")
[11:01:02.999]         }
[11:01:02.999]         else {
[11:01:02.999]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:02.999]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:02.999]         }
[11:01:02.999]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:02.999]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:02.999]             base::sink(type = "output", split = FALSE)
[11:01:02.999]             base::close(...future.stdout)
[11:01:02.999]         }, add = TRUE)
[11:01:02.999]     }
[11:01:02.999]     ...future.frame <- base::sys.nframe()
[11:01:02.999]     ...future.conditions <- base::list()
[11:01:02.999]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:02.999]     if (FALSE) {
[11:01:02.999]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:02.999]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:02.999]     }
[11:01:02.999]     ...future.result <- base::tryCatch({
[11:01:02.999]         base::withCallingHandlers({
[11:01:02.999]             ...future.value <- base::withVisible(base::local({
[11:01:02.999]                 withCallingHandlers({
[11:01:02.999]                   {
[11:01:02.999]                     message(sprintf("Calculating tile #%d of %d ...", 
[11:01:02.999]                       ii, n), appendLF = FALSE)
[11:01:02.999]                     fit <- mandelbrot(C)
[11:01:02.999]                     delay(fit)
[11:01:02.999]                     message(" done")
[11:01:02.999]                     fit
[11:01:02.999]                   }
[11:01:02.999]                 }, immediateCondition = function(cond) {
[11:01:02.999]                   save_rds <- function (object, pathname, ...) 
[11:01:02.999]                   {
[11:01:02.999]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:02.999]                     if (file_test("-f", pathname_tmp)) {
[11:01:02.999]                       fi_tmp <- file.info(pathname_tmp)
[11:01:02.999]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:02.999]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:02.999]                         fi_tmp[["mtime"]])
[11:01:02.999]                     }
[11:01:02.999]                     tryCatch({
[11:01:02.999]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:02.999]                     }, error = function(ex) {
[11:01:02.999]                       msg <- conditionMessage(ex)
[11:01:02.999]                       fi_tmp <- file.info(pathname_tmp)
[11:01:02.999]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:02.999]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:02.999]                         fi_tmp[["mtime"]], msg)
[11:01:02.999]                       ex$message <- msg
[11:01:02.999]                       stop(ex)
[11:01:02.999]                     })
[11:01:02.999]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:02.999]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:02.999]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:02.999]                       fi_tmp <- file.info(pathname_tmp)
[11:01:02.999]                       fi <- file.info(pathname)
[11:01:02.999]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:02.999]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:02.999]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:02.999]                         fi[["size"]], fi[["mtime"]])
[11:01:02.999]                       stop(msg)
[11:01:02.999]                     }
[11:01:02.999]                     invisible(pathname)
[11:01:02.999]                   }
[11:01:02.999]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:02.999]                     rootPath = tempdir()) 
[11:01:02.999]                   {
[11:01:02.999]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:02.999]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:02.999]                       tmpdir = path, fileext = ".rds")
[11:01:02.999]                     save_rds(obj, file)
[11:01:02.999]                   }
[11:01:02.999]                   saveImmediateCondition(cond, path = "/tmp/Rtmpbx4bQL/.future/immediateConditions")
[11:01:02.999]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:02.999]                   {
[11:01:02.999]                     inherits <- base::inherits
[11:01:02.999]                     invokeRestart <- base::invokeRestart
[11:01:02.999]                     is.null <- base::is.null
[11:01:02.999]                     muffled <- FALSE
[11:01:02.999]                     if (inherits(cond, "message")) {
[11:01:02.999]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:02.999]                       if (muffled) 
[11:01:02.999]                         invokeRestart("muffleMessage")
[11:01:02.999]                     }
[11:01:02.999]                     else if (inherits(cond, "warning")) {
[11:01:02.999]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:02.999]                       if (muffled) 
[11:01:02.999]                         invokeRestart("muffleWarning")
[11:01:02.999]                     }
[11:01:02.999]                     else if (inherits(cond, "condition")) {
[11:01:02.999]                       if (!is.null(pattern)) {
[11:01:02.999]                         computeRestarts <- base::computeRestarts
[11:01:02.999]                         grepl <- base::grepl
[11:01:02.999]                         restarts <- computeRestarts(cond)
[11:01:02.999]                         for (restart in restarts) {
[11:01:02.999]                           name <- restart$name
[11:01:02.999]                           if (is.null(name)) 
[11:01:02.999]                             next
[11:01:02.999]                           if (!grepl(pattern, name)) 
[11:01:02.999]                             next
[11:01:02.999]                           invokeRestart(restart)
[11:01:02.999]                           muffled <- TRUE
[11:01:02.999]                           break
[11:01:02.999]                         }
[11:01:02.999]                       }
[11:01:02.999]                     }
[11:01:02.999]                     invisible(muffled)
[11:01:02.999]                   }
[11:01:02.999]                   muffleCondition(cond)
[11:01:02.999]                 })
[11:01:02.999]             }))
[11:01:02.999]             future::FutureResult(value = ...future.value$value, 
[11:01:02.999]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:02.999]                   ...future.rng), globalenv = if (FALSE) 
[11:01:02.999]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:02.999]                     ...future.globalenv.names))
[11:01:02.999]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:02.999]         }, condition = base::local({
[11:01:02.999]             c <- base::c
[11:01:02.999]             inherits <- base::inherits
[11:01:02.999]             invokeRestart <- base::invokeRestart
[11:01:02.999]             length <- base::length
[11:01:02.999]             list <- base::list
[11:01:02.999]             seq.int <- base::seq.int
[11:01:02.999]             signalCondition <- base::signalCondition
[11:01:02.999]             sys.calls <- base::sys.calls
[11:01:02.999]             `[[` <- base::`[[`
[11:01:02.999]             `+` <- base::`+`
[11:01:02.999]             `<<-` <- base::`<<-`
[11:01:02.999]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:02.999]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:02.999]                   3L)]
[11:01:02.999]             }
[11:01:02.999]             function(cond) {
[11:01:02.999]                 is_error <- inherits(cond, "error")
[11:01:02.999]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:02.999]                   NULL)
[11:01:02.999]                 if (is_error) {
[11:01:02.999]                   sessionInformation <- function() {
[11:01:02.999]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:02.999]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:02.999]                       search = base::search(), system = base::Sys.info())
[11:01:02.999]                   }
[11:01:02.999]                   ...future.conditions[[length(...future.conditions) + 
[11:01:02.999]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:02.999]                     cond$call), session = sessionInformation(), 
[11:01:02.999]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:02.999]                   signalCondition(cond)
[11:01:02.999]                 }
[11:01:02.999]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:02.999]                 "immediateCondition"))) {
[11:01:02.999]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:02.999]                   ...future.conditions[[length(...future.conditions) + 
[11:01:02.999]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:02.999]                   if (TRUE && !signal) {
[11:01:02.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:02.999]                     {
[11:01:02.999]                       inherits <- base::inherits
[11:01:02.999]                       invokeRestart <- base::invokeRestart
[11:01:02.999]                       is.null <- base::is.null
[11:01:02.999]                       muffled <- FALSE
[11:01:02.999]                       if (inherits(cond, "message")) {
[11:01:02.999]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:02.999]                         if (muffled) 
[11:01:02.999]                           invokeRestart("muffleMessage")
[11:01:02.999]                       }
[11:01:02.999]                       else if (inherits(cond, "warning")) {
[11:01:02.999]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:02.999]                         if (muffled) 
[11:01:02.999]                           invokeRestart("muffleWarning")
[11:01:02.999]                       }
[11:01:02.999]                       else if (inherits(cond, "condition")) {
[11:01:02.999]                         if (!is.null(pattern)) {
[11:01:02.999]                           computeRestarts <- base::computeRestarts
[11:01:02.999]                           grepl <- base::grepl
[11:01:02.999]                           restarts <- computeRestarts(cond)
[11:01:02.999]                           for (restart in restarts) {
[11:01:02.999]                             name <- restart$name
[11:01:02.999]                             if (is.null(name)) 
[11:01:02.999]                               next
[11:01:02.999]                             if (!grepl(pattern, name)) 
[11:01:02.999]                               next
[11:01:02.999]                             invokeRestart(restart)
[11:01:02.999]                             muffled <- TRUE
[11:01:02.999]                             break
[11:01:02.999]                           }
[11:01:02.999]                         }
[11:01:02.999]                       }
[11:01:02.999]                       invisible(muffled)
[11:01:02.999]                     }
[11:01:02.999]                     muffleCondition(cond, pattern = "^muffle")
[11:01:02.999]                   }
[11:01:02.999]                 }
[11:01:02.999]                 else {
[11:01:02.999]                   if (TRUE) {
[11:01:02.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:02.999]                     {
[11:01:02.999]                       inherits <- base::inherits
[11:01:02.999]                       invokeRestart <- base::invokeRestart
[11:01:02.999]                       is.null <- base::is.null
[11:01:02.999]                       muffled <- FALSE
[11:01:02.999]                       if (inherits(cond, "message")) {
[11:01:02.999]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:02.999]                         if (muffled) 
[11:01:02.999]                           invokeRestart("muffleMessage")
[11:01:02.999]                       }
[11:01:02.999]                       else if (inherits(cond, "warning")) {
[11:01:02.999]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:02.999]                         if (muffled) 
[11:01:02.999]                           invokeRestart("muffleWarning")
[11:01:02.999]                       }
[11:01:02.999]                       else if (inherits(cond, "condition")) {
[11:01:02.999]                         if (!is.null(pattern)) {
[11:01:02.999]                           computeRestarts <- base::computeRestarts
[11:01:02.999]                           grepl <- base::grepl
[11:01:02.999]                           restarts <- computeRestarts(cond)
[11:01:02.999]                           for (restart in restarts) {
[11:01:02.999]                             name <- restart$name
[11:01:02.999]                             if (is.null(name)) 
[11:01:02.999]                               next
[11:01:02.999]                             if (!grepl(pattern, name)) 
[11:01:02.999]                               next
[11:01:02.999]                             invokeRestart(restart)
[11:01:02.999]                             muffled <- TRUE
[11:01:02.999]                             break
[11:01:02.999]                           }
[11:01:02.999]                         }
[11:01:02.999]                       }
[11:01:02.999]                       invisible(muffled)
[11:01:02.999]                     }
[11:01:02.999]                     muffleCondition(cond, pattern = "^muffle")
[11:01:02.999]                   }
[11:01:02.999]                 }
[11:01:02.999]             }
[11:01:02.999]         }))
[11:01:02.999]     }, error = function(ex) {
[11:01:02.999]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:02.999]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:02.999]                 ...future.rng), started = ...future.startTime, 
[11:01:02.999]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:02.999]             version = "1.8"), class = "FutureResult")
[11:01:02.999]     }, finally = {
[11:01:02.999]         if (!identical(...future.workdir, getwd())) 
[11:01:02.999]             setwd(...future.workdir)
[11:01:02.999]         {
[11:01:02.999]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:02.999]                 ...future.oldOptions$nwarnings <- NULL
[11:01:02.999]             }
[11:01:02.999]             base::options(...future.oldOptions)
[11:01:02.999]             if (.Platform$OS.type == "windows") {
[11:01:02.999]                 old_names <- names(...future.oldEnvVars)
[11:01:02.999]                 envs <- base::Sys.getenv()
[11:01:02.999]                 names <- names(envs)
[11:01:02.999]                 common <- intersect(names, old_names)
[11:01:02.999]                 added <- setdiff(names, old_names)
[11:01:02.999]                 removed <- setdiff(old_names, names)
[11:01:02.999]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:02.999]                   envs[common]]
[11:01:02.999]                 NAMES <- toupper(changed)
[11:01:02.999]                 args <- list()
[11:01:02.999]                 for (kk in seq_along(NAMES)) {
[11:01:02.999]                   name <- changed[[kk]]
[11:01:02.999]                   NAME <- NAMES[[kk]]
[11:01:02.999]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.999]                     next
[11:01:02.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:02.999]                 }
[11:01:02.999]                 NAMES <- toupper(added)
[11:01:02.999]                 for (kk in seq_along(NAMES)) {
[11:01:02.999]                   name <- added[[kk]]
[11:01:02.999]                   NAME <- NAMES[[kk]]
[11:01:02.999]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.999]                     next
[11:01:02.999]                   args[[name]] <- ""
[11:01:02.999]                 }
[11:01:02.999]                 NAMES <- toupper(removed)
[11:01:02.999]                 for (kk in seq_along(NAMES)) {
[11:01:02.999]                   name <- removed[[kk]]
[11:01:02.999]                   NAME <- NAMES[[kk]]
[11:01:02.999]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:02.999]                     next
[11:01:02.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:02.999]                 }
[11:01:02.999]                 if (length(args) > 0) 
[11:01:02.999]                   base::do.call(base::Sys.setenv, args = args)
[11:01:02.999]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:02.999]             }
[11:01:02.999]             else {
[11:01:02.999]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:02.999]             }
[11:01:02.999]             {
[11:01:02.999]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:02.999]                   0L) {
[11:01:02.999]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:02.999]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:02.999]                   base::options(opts)
[11:01:02.999]                 }
[11:01:02.999]                 {
[11:01:02.999]                   {
[11:01:02.999]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:02.999]                     NULL
[11:01:02.999]                   }
[11:01:02.999]                   options(future.plan = NULL)
[11:01:02.999]                   if (is.na(NA_character_)) 
[11:01:02.999]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:02.999]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:02.999]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:02.999]                     .init = FALSE)
[11:01:02.999]                 }
[11:01:02.999]             }
[11:01:02.999]         }
[11:01:02.999]     })
[11:01:02.999]     if (TRUE) {
[11:01:02.999]         base::sink(type = "output", split = FALSE)
[11:01:02.999]         if (TRUE) {
[11:01:02.999]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:02.999]         }
[11:01:02.999]         else {
[11:01:02.999]             ...future.result["stdout"] <- base::list(NULL)
[11:01:02.999]         }
[11:01:02.999]         base::close(...future.stdout)
[11:01:02.999]         ...future.stdout <- NULL
[11:01:02.999]     }
[11:01:02.999]     ...future.result$conditions <- ...future.conditions
[11:01:02.999]     ...future.result$finished <- base::Sys.time()
[11:01:02.999]     ...future.result
[11:01:02.999] }
[11:01:03.002] assign_globals() ...
[11:01:03.002] List of 4
[11:01:03.002]  $ ii   : int 4
[11:01:03.002]  $ n    : int 4
[11:01:03.002]  $ C    : cplx [1:25, 1:25] -0.719+0.0306i -0.719+0.0918i -0.719+0.1531i ...
[11:01:03.002]   ..- attr(*, "region")=List of 2
[11:01:03.002]   .. ..$ xrange: num [1:2] -0.719 0.75
[11:01:03.002]   .. ..$ yrange: num [1:2] 0.0306 1.5
[11:01:03.002]   ..- attr(*, "tile")= int [1:2] 2 2
[11:01:03.002]  $ delay:function (counts)  
[11:01:03.002]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[11:01:03.002]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x56491639efc0> 
[11:01:03.002]  - attr(*, "where")=List of 4
[11:01:03.002]   ..$ ii   :<environment: R_EmptyEnv> 
[11:01:03.002]   ..$ n    :<environment: R_EmptyEnv> 
[11:01:03.002]   ..$ C    :<environment: R_EmptyEnv> 
[11:01:03.002]   ..$ delay:<environment: R_EmptyEnv> 
[11:01:03.002]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:03.002]  - attr(*, "resolved")= logi FALSE
[11:01:03.002]  - attr(*, "total_size")= num 58781
[11:01:03.002]  - attr(*, "already-done")= logi TRUE
[11:01:03.010] - copied ‘ii’ to environment
[11:01:03.011] - copied ‘n’ to environment
[11:01:03.011] - copied ‘C’ to environment
[11:01:03.011] - reassign environment for ‘delay’
[11:01:03.011] - copied ‘delay’ to environment
[11:01:03.011] assign_globals() ... done
[11:01:03.011] requestCore(): workers = 2
[11:01:03.013] MulticoreFuture started
[11:01:03.014] - Launch lazy future ... done
[11:01:03.014] run() for ‘MulticoreFuture’ ... done
[11:01:03.014] - run() ... done
[11:01:03.014] - resolved() ...
[11:01:03.015] plan(): Setting new future strategy stack:
[11:01:03.015] List of future strategies:
[11:01:03.015] 1. sequential:
[11:01:03.015]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:03.015]    - tweaked: FALSE
[11:01:03.015]    - call: NULL
[11:01:03.016] plan(): nbrOfWorkers() = 1
[11:01:03.020] plan(): Setting new future strategy stack:
[11:01:03.020] List of future strategies:
[11:01:03.020] 1. multicore:
[11:01:03.020]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:03.020]    - tweaked: FALSE
[11:01:03.020]    - call: plan(strategy)
[11:01:03.023] plan(): nbrOfWorkers() = 2
[11:01:03.024] - resolved: TRUE
[11:01:03.024] - resolved() ... done
[11:01:03.024] resolved() for ‘MulticoreFuture’ ... done
Plotting tile #4 of 4 ...
[11:01:03.024] result() for MulticoreFuture ...
[11:01:03.026] result() for MulticoreFuture ...
[11:01:03.026] result() for MulticoreFuture ... done
[11:01:03.026] signalConditions() ...
[11:01:03.026]  - include = ‘immediateCondition’
[11:01:03.026]  - exclude = 
[11:01:03.026]  - resignal = FALSE
[11:01:03.026]  - Number of conditions: 2
[11:01:03.027] signalConditions() ... done
[11:01:03.027] result() for MulticoreFuture ... done
[11:01:03.027] result() for MulticoreFuture ...
[11:01:03.027] result() for MulticoreFuture ... done
[11:01:03.027] signalConditions() ...
[11:01:03.027]  - include = ‘immediateCondition’
[11:01:03.027]  - exclude = 
[11:01:03.027]  - resignal = FALSE
[11:01:03.027]  - Number of conditions: 2
[11:01:03.028] signalConditions() ... done
[11:01:03.028] Future state: ‘finished’
[11:01:03.028] result() for MulticoreFuture ...
[11:01:03.028] result() for MulticoreFuture ... done
[11:01:03.028] signalConditions() ...
[11:01:03.028]  - include = ‘condition’
[11:01:03.028]  - exclude = ‘immediateCondition’
[11:01:03.029]  - resignal = TRUE
[11:01:03.029]  - Number of conditions: 2
[11:01:03.029]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[11:01:03.029]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[11:01:03.029] signalConditions() ... done
Plotting tile #2 of 4 ...
[11:01:03.030] result() for MulticoreFuture ...
[11:01:03.031] result() for MulticoreFuture ...
[11:01:03.032] result() for MulticoreFuture ... done
[11:01:03.032] signalConditions() ...
[11:01:03.032]  - include = ‘immediateCondition’
[11:01:03.032]  - exclude = 
[11:01:03.032]  - resignal = FALSE
[11:01:03.032]  - Number of conditions: 2
[11:01:03.032] signalConditions() ... done
[11:01:03.032] result() for MulticoreFuture ... done
[11:01:03.033] result() for MulticoreFuture ...
[11:01:03.033] result() for MulticoreFuture ... done
[11:01:03.033] signalConditions() ...
[11:01:03.033]  - include = ‘immediateCondition’
[11:01:03.033]  - exclude = 
[11:01:03.033]  - resignal = FALSE
[11:01:03.033]  - Number of conditions: 2
[11:01:03.033] signalConditions() ... done
[11:01:03.033] Future state: ‘finished’
[11:01:03.034] result() for MulticoreFuture ...
[11:01:03.034] result() for MulticoreFuture ... done
[11:01:03.034] signalConditions() ...
[11:01:03.034]  - include = ‘condition’
[11:01:03.034]  - exclude = ‘immediateCondition’
[11:01:03.034]  - resignal = TRUE
[11:01:03.034]  - Number of conditions: 2
[11:01:03.034]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[11:01:03.035]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[11:01:03.035] signalConditions() ... done

> close.screen()
[1] 1 2 3 4 5 6 7 8

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('multicore') ... DONE
- plan('multisession') ...
[11:01:03.036] plan(): Setting new future strategy stack:
[11:01:03.037] List of future strategies:
[11:01:03.037] 1. multisession:
[11:01:03.037]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:03.037]    - tweaked: FALSE
[11:01:03.037]    - call: plan(strategy)
[11:01:03.037] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[11:01:03.037] multisession:
[11:01:03.037] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:03.037] - tweaked: FALSE
[11:01:03.037] - call: plan(strategy)
[11:01:03.042] getGlobalsAndPackages() ...
[11:01:03.042] Not searching for globals
[11:01:03.042] - globals: [0] <none>
[11:01:03.042] getGlobalsAndPackages() ... DONE
[11:01:03.529] Packages needed by the future expression (n = 0): <none>
[11:01:03.530] Packages needed by future strategies (n = 0): <none>
[11:01:03.530] {
[11:01:03.530]     {
[11:01:03.530]         {
[11:01:03.530]             ...future.startTime <- base::Sys.time()
[11:01:03.530]             {
[11:01:03.530]                 {
[11:01:03.530]                   {
[11:01:03.530]                     {
[11:01:03.530]                       base::local({
[11:01:03.530]                         has_future <- base::requireNamespace("future", 
[11:01:03.530]                           quietly = TRUE)
[11:01:03.530]                         if (has_future) {
[11:01:03.530]                           ns <- base::getNamespace("future")
[11:01:03.530]                           version <- ns[[".package"]][["version"]]
[11:01:03.530]                           if (is.null(version)) 
[11:01:03.530]                             version <- utils::packageVersion("future")
[11:01:03.530]                         }
[11:01:03.530]                         else {
[11:01:03.530]                           version <- NULL
[11:01:03.530]                         }
[11:01:03.530]                         if (!has_future || version < "1.8.0") {
[11:01:03.530]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:03.530]                             "", base::R.version$version.string), 
[11:01:03.530]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:03.530]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:03.530]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:03.530]                               "release", "version")], collapse = " "), 
[11:01:03.530]                             hostname = base::Sys.info()[["nodename"]])
[11:01:03.530]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:03.530]                             info)
[11:01:03.530]                           info <- base::paste(info, collapse = "; ")
[11:01:03.530]                           if (!has_future) {
[11:01:03.530]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:03.530]                               info)
[11:01:03.530]                           }
[11:01:03.530]                           else {
[11:01:03.530]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:03.530]                               info, version)
[11:01:03.530]                           }
[11:01:03.530]                           base::stop(msg)
[11:01:03.530]                         }
[11:01:03.530]                       })
[11:01:03.530]                     }
[11:01:03.530]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:03.530]                     base::options(mc.cores = 1L)
[11:01:03.530]                   }
[11:01:03.530]                   ...future.strategy.old <- future::plan("list")
[11:01:03.530]                   options(future.plan = NULL)
[11:01:03.530]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:03.530]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:03.530]                 }
[11:01:03.530]                 ...future.workdir <- getwd()
[11:01:03.530]             }
[11:01:03.530]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:03.530]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:03.530]         }
[11:01:03.530]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:03.530]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:03.530]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:03.530]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:03.530]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:03.530]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:03.530]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:03.530]             base::names(...future.oldOptions))
[11:01:03.530]     }
[11:01:03.530]     if (FALSE) {
[11:01:03.530]     }
[11:01:03.530]     else {
[11:01:03.530]         if (TRUE) {
[11:01:03.530]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:03.530]                 open = "w")
[11:01:03.530]         }
[11:01:03.530]         else {
[11:01:03.530]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:03.530]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:03.530]         }
[11:01:03.530]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:03.530]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:03.530]             base::sink(type = "output", split = FALSE)
[11:01:03.530]             base::close(...future.stdout)
[11:01:03.530]         }, add = TRUE)
[11:01:03.530]     }
[11:01:03.530]     ...future.frame <- base::sys.nframe()
[11:01:03.530]     ...future.conditions <- base::list()
[11:01:03.530]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:03.530]     if (FALSE) {
[11:01:03.530]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:03.530]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:03.530]     }
[11:01:03.530]     ...future.result <- base::tryCatch({
[11:01:03.530]         base::withCallingHandlers({
[11:01:03.530]             ...future.value <- base::withVisible(base::local({
[11:01:03.530]                 ...future.makeSendCondition <- base::local({
[11:01:03.530]                   sendCondition <- NULL
[11:01:03.530]                   function(frame = 1L) {
[11:01:03.530]                     if (is.function(sendCondition)) 
[11:01:03.530]                       return(sendCondition)
[11:01:03.530]                     ns <- getNamespace("parallel")
[11:01:03.530]                     if (exists("sendData", mode = "function", 
[11:01:03.530]                       envir = ns)) {
[11:01:03.530]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:03.530]                         envir = ns)
[11:01:03.530]                       envir <- sys.frame(frame)
[11:01:03.530]                       master <- NULL
[11:01:03.530]                       while (!identical(envir, .GlobalEnv) && 
[11:01:03.530]                         !identical(envir, emptyenv())) {
[11:01:03.530]                         if (exists("master", mode = "list", envir = envir, 
[11:01:03.530]                           inherits = FALSE)) {
[11:01:03.530]                           master <- get("master", mode = "list", 
[11:01:03.530]                             envir = envir, inherits = FALSE)
[11:01:03.530]                           if (inherits(master, c("SOCKnode", 
[11:01:03.530]                             "SOCK0node"))) {
[11:01:03.530]                             sendCondition <<- function(cond) {
[11:01:03.530]                               data <- list(type = "VALUE", value = cond, 
[11:01:03.530]                                 success = TRUE)
[11:01:03.530]                               parallel_sendData(master, data)
[11:01:03.530]                             }
[11:01:03.530]                             return(sendCondition)
[11:01:03.530]                           }
[11:01:03.530]                         }
[11:01:03.530]                         frame <- frame + 1L
[11:01:03.530]                         envir <- sys.frame(frame)
[11:01:03.530]                       }
[11:01:03.530]                     }
[11:01:03.530]                     sendCondition <<- function(cond) NULL
[11:01:03.530]                   }
[11:01:03.530]                 })
[11:01:03.530]                 withCallingHandlers({
[11:01:03.530]                   NA
[11:01:03.530]                 }, immediateCondition = function(cond) {
[11:01:03.530]                   sendCondition <- ...future.makeSendCondition()
[11:01:03.530]                   sendCondition(cond)
[11:01:03.530]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:03.530]                   {
[11:01:03.530]                     inherits <- base::inherits
[11:01:03.530]                     invokeRestart <- base::invokeRestart
[11:01:03.530]                     is.null <- base::is.null
[11:01:03.530]                     muffled <- FALSE
[11:01:03.530]                     if (inherits(cond, "message")) {
[11:01:03.530]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:03.530]                       if (muffled) 
[11:01:03.530]                         invokeRestart("muffleMessage")
[11:01:03.530]                     }
[11:01:03.530]                     else if (inherits(cond, "warning")) {
[11:01:03.530]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:03.530]                       if (muffled) 
[11:01:03.530]                         invokeRestart("muffleWarning")
[11:01:03.530]                     }
[11:01:03.530]                     else if (inherits(cond, "condition")) {
[11:01:03.530]                       if (!is.null(pattern)) {
[11:01:03.530]                         computeRestarts <- base::computeRestarts
[11:01:03.530]                         grepl <- base::grepl
[11:01:03.530]                         restarts <- computeRestarts(cond)
[11:01:03.530]                         for (restart in restarts) {
[11:01:03.530]                           name <- restart$name
[11:01:03.530]                           if (is.null(name)) 
[11:01:03.530]                             next
[11:01:03.530]                           if (!grepl(pattern, name)) 
[11:01:03.530]                             next
[11:01:03.530]                           invokeRestart(restart)
[11:01:03.530]                           muffled <- TRUE
[11:01:03.530]                           break
[11:01:03.530]                         }
[11:01:03.530]                       }
[11:01:03.530]                     }
[11:01:03.530]                     invisible(muffled)
[11:01:03.530]                   }
[11:01:03.530]                   muffleCondition(cond)
[11:01:03.530]                 })
[11:01:03.530]             }))
[11:01:03.530]             future::FutureResult(value = ...future.value$value, 
[11:01:03.530]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:03.530]                   ...future.rng), globalenv = if (FALSE) 
[11:01:03.530]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:03.530]                     ...future.globalenv.names))
[11:01:03.530]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:03.530]         }, condition = base::local({
[11:01:03.530]             c <- base::c
[11:01:03.530]             inherits <- base::inherits
[11:01:03.530]             invokeRestart <- base::invokeRestart
[11:01:03.530]             length <- base::length
[11:01:03.530]             list <- base::list
[11:01:03.530]             seq.int <- base::seq.int
[11:01:03.530]             signalCondition <- base::signalCondition
[11:01:03.530]             sys.calls <- base::sys.calls
[11:01:03.530]             `[[` <- base::`[[`
[11:01:03.530]             `+` <- base::`+`
[11:01:03.530]             `<<-` <- base::`<<-`
[11:01:03.530]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:03.530]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:03.530]                   3L)]
[11:01:03.530]             }
[11:01:03.530]             function(cond) {
[11:01:03.530]                 is_error <- inherits(cond, "error")
[11:01:03.530]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:03.530]                   NULL)
[11:01:03.530]                 if (is_error) {
[11:01:03.530]                   sessionInformation <- function() {
[11:01:03.530]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:03.530]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:03.530]                       search = base::search(), system = base::Sys.info())
[11:01:03.530]                   }
[11:01:03.530]                   ...future.conditions[[length(...future.conditions) + 
[11:01:03.530]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:03.530]                     cond$call), session = sessionInformation(), 
[11:01:03.530]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:03.530]                   signalCondition(cond)
[11:01:03.530]                 }
[11:01:03.530]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:03.530]                 "immediateCondition"))) {
[11:01:03.530]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:03.530]                   ...future.conditions[[length(...future.conditions) + 
[11:01:03.530]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:03.530]                   if (TRUE && !signal) {
[11:01:03.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:03.530]                     {
[11:01:03.530]                       inherits <- base::inherits
[11:01:03.530]                       invokeRestart <- base::invokeRestart
[11:01:03.530]                       is.null <- base::is.null
[11:01:03.530]                       muffled <- FALSE
[11:01:03.530]                       if (inherits(cond, "message")) {
[11:01:03.530]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:03.530]                         if (muffled) 
[11:01:03.530]                           invokeRestart("muffleMessage")
[11:01:03.530]                       }
[11:01:03.530]                       else if (inherits(cond, "warning")) {
[11:01:03.530]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:03.530]                         if (muffled) 
[11:01:03.530]                           invokeRestart("muffleWarning")
[11:01:03.530]                       }
[11:01:03.530]                       else if (inherits(cond, "condition")) {
[11:01:03.530]                         if (!is.null(pattern)) {
[11:01:03.530]                           computeRestarts <- base::computeRestarts
[11:01:03.530]                           grepl <- base::grepl
[11:01:03.530]                           restarts <- computeRestarts(cond)
[11:01:03.530]                           for (restart in restarts) {
[11:01:03.530]                             name <- restart$name
[11:01:03.530]                             if (is.null(name)) 
[11:01:03.530]                               next
[11:01:03.530]                             if (!grepl(pattern, name)) 
[11:01:03.530]                               next
[11:01:03.530]                             invokeRestart(restart)
[11:01:03.530]                             muffled <- TRUE
[11:01:03.530]                             break
[11:01:03.530]                           }
[11:01:03.530]                         }
[11:01:03.530]                       }
[11:01:03.530]                       invisible(muffled)
[11:01:03.530]                     }
[11:01:03.530]                     muffleCondition(cond, pattern = "^muffle")
[11:01:03.530]                   }
[11:01:03.530]                 }
[11:01:03.530]                 else {
[11:01:03.530]                   if (TRUE) {
[11:01:03.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:03.530]                     {
[11:01:03.530]                       inherits <- base::inherits
[11:01:03.530]                       invokeRestart <- base::invokeRestart
[11:01:03.530]                       is.null <- base::is.null
[11:01:03.530]                       muffled <- FALSE
[11:01:03.530]                       if (inherits(cond, "message")) {
[11:01:03.530]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:03.530]                         if (muffled) 
[11:01:03.530]                           invokeRestart("muffleMessage")
[11:01:03.530]                       }
[11:01:03.530]                       else if (inherits(cond, "warning")) {
[11:01:03.530]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:03.530]                         if (muffled) 
[11:01:03.530]                           invokeRestart("muffleWarning")
[11:01:03.530]                       }
[11:01:03.530]                       else if (inherits(cond, "condition")) {
[11:01:03.530]                         if (!is.null(pattern)) {
[11:01:03.530]                           computeRestarts <- base::computeRestarts
[11:01:03.530]                           grepl <- base::grepl
[11:01:03.530]                           restarts <- computeRestarts(cond)
[11:01:03.530]                           for (restart in restarts) {
[11:01:03.530]                             name <- restart$name
[11:01:03.530]                             if (is.null(name)) 
[11:01:03.530]                               next
[11:01:03.530]                             if (!grepl(pattern, name)) 
[11:01:03.530]                               next
[11:01:03.530]                             invokeRestart(restart)
[11:01:03.530]                             muffled <- TRUE
[11:01:03.530]                             break
[11:01:03.530]                           }
[11:01:03.530]                         }
[11:01:03.530]                       }
[11:01:03.530]                       invisible(muffled)
[11:01:03.530]                     }
[11:01:03.530]                     muffleCondition(cond, pattern = "^muffle")
[11:01:03.530]                   }
[11:01:03.530]                 }
[11:01:03.530]             }
[11:01:03.530]         }))
[11:01:03.530]     }, error = function(ex) {
[11:01:03.530]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:03.530]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:03.530]                 ...future.rng), started = ...future.startTime, 
[11:01:03.530]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:03.530]             version = "1.8"), class = "FutureResult")
[11:01:03.530]     }, finally = {
[11:01:03.530]         if (!identical(...future.workdir, getwd())) 
[11:01:03.530]             setwd(...future.workdir)
[11:01:03.530]         {
[11:01:03.530]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:03.530]                 ...future.oldOptions$nwarnings <- NULL
[11:01:03.530]             }
[11:01:03.530]             base::options(...future.oldOptions)
[11:01:03.530]             if (.Platform$OS.type == "windows") {
[11:01:03.530]                 old_names <- names(...future.oldEnvVars)
[11:01:03.530]                 envs <- base::Sys.getenv()
[11:01:03.530]                 names <- names(envs)
[11:01:03.530]                 common <- intersect(names, old_names)
[11:01:03.530]                 added <- setdiff(names, old_names)
[11:01:03.530]                 removed <- setdiff(old_names, names)
[11:01:03.530]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:03.530]                   envs[common]]
[11:01:03.530]                 NAMES <- toupper(changed)
[11:01:03.530]                 args <- list()
[11:01:03.530]                 for (kk in seq_along(NAMES)) {
[11:01:03.530]                   name <- changed[[kk]]
[11:01:03.530]                   NAME <- NAMES[[kk]]
[11:01:03.530]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:03.530]                     next
[11:01:03.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:03.530]                 }
[11:01:03.530]                 NAMES <- toupper(added)
[11:01:03.530]                 for (kk in seq_along(NAMES)) {
[11:01:03.530]                   name <- added[[kk]]
[11:01:03.530]                   NAME <- NAMES[[kk]]
[11:01:03.530]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:03.530]                     next
[11:01:03.530]                   args[[name]] <- ""
[11:01:03.530]                 }
[11:01:03.530]                 NAMES <- toupper(removed)
[11:01:03.530]                 for (kk in seq_along(NAMES)) {
[11:01:03.530]                   name <- removed[[kk]]
[11:01:03.530]                   NAME <- NAMES[[kk]]
[11:01:03.530]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:03.530]                     next
[11:01:03.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:03.530]                 }
[11:01:03.530]                 if (length(args) > 0) 
[11:01:03.530]                   base::do.call(base::Sys.setenv, args = args)
[11:01:03.530]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:03.530]             }
[11:01:03.530]             else {
[11:01:03.530]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:03.530]             }
[11:01:03.530]             {
[11:01:03.530]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:03.530]                   0L) {
[11:01:03.530]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:03.530]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:03.530]                   base::options(opts)
[11:01:03.530]                 }
[11:01:03.530]                 {
[11:01:03.530]                   {
[11:01:03.530]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:03.530]                     NULL
[11:01:03.530]                   }
[11:01:03.530]                   options(future.plan = NULL)
[11:01:03.530]                   if (is.na(NA_character_)) 
[11:01:03.530]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:03.530]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:03.530]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:03.530]                     .init = FALSE)
[11:01:03.530]                 }
[11:01:03.530]             }
[11:01:03.530]         }
[11:01:03.530]     })
[11:01:03.530]     if (TRUE) {
[11:01:03.530]         base::sink(type = "output", split = FALSE)
[11:01:03.530]         if (TRUE) {
[11:01:03.530]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:03.530]         }
[11:01:03.530]         else {
[11:01:03.530]             ...future.result["stdout"] <- base::list(NULL)
[11:01:03.530]         }
[11:01:03.530]         base::close(...future.stdout)
[11:01:03.530]         ...future.stdout <- NULL
[11:01:03.530]     }
[11:01:03.530]     ...future.result$conditions <- ...future.conditions
[11:01:03.530]     ...future.result$finished <- base::Sys.time()
[11:01:03.530]     ...future.result
[11:01:03.530] }
[11:01:03.582] MultisessionFuture started
[11:01:03.582] result() for ClusterFuture ...
[11:01:03.582] receiveMessageFromWorker() for ClusterFuture ...
[11:01:03.583] - Validating connection of MultisessionFuture
[11:01:03.613] - received message: FutureResult
[11:01:03.613] - Received FutureResult
[11:01:03.613] - Erased future from FutureRegistry
[11:01:03.613] result() for ClusterFuture ...
[11:01:03.613] - result already collected: FutureResult
[11:01:03.613] result() for ClusterFuture ... done
[11:01:03.614] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:03.614] result() for ClusterFuture ... done
[11:01:03.614] result() for ClusterFuture ...
[11:01:03.614] - result already collected: FutureResult
[11:01:03.614] result() for ClusterFuture ... done
[11:01:03.614] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[11:01:03.616] plan(): nbrOfWorkers() = 2


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1]  9 10 11 12

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[11:01:03.619] getGlobalsAndPackages() ...
[11:01:03.619] Searching for globals...
[11:01:03.622] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[11:01:03.623] Searching for globals ... DONE
[11:01:03.623] Resolving globals: FALSE
[11:01:03.623] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[11:01:03.624] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:03.624] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[11:01:03.624] - packages: [1] ‘future’
[11:01:03.624] getGlobalsAndPackages() ... DONE
 2[11:01:03.628] getGlobalsAndPackages() ...
[11:01:03.628] Searching for globals...
[11:01:03.631] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[11:01:03.631] Searching for globals ... DONE
[11:01:03.631] Resolving globals: FALSE
[11:01:03.632] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[11:01:03.632] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:03.632] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[11:01:03.632] - packages: [1] ‘future’
[11:01:03.633] getGlobalsAndPackages() ... DONE
 3[11:01:03.633] getGlobalsAndPackages() ...
[11:01:03.633] Searching for globals...
[11:01:03.636] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[11:01:03.636] Searching for globals ... DONE
[11:01:03.636] Resolving globals: FALSE
[11:01:03.637] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[11:01:03.637] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:03.637] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[11:01:03.637] - packages: [1] ‘future’
[11:01:03.637] getGlobalsAndPackages() ... DONE
 4[11:01:03.638] getGlobalsAndPackages() ...
[11:01:03.638] Searching for globals...
[11:01:03.641] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[11:01:03.641] Searching for globals ... DONE
[11:01:03.641] Resolving globals: FALSE
[11:01:03.642] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[11:01:03.642] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:03.642] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[11:01:03.642] - packages: [1] ‘future’
[11:01:03.642] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[11:01:03.651] resolved() for ‘Future’ ...
[11:01:03.651] - state: ‘created’
[11:01:03.651] - run: TRUE
[11:01:03.651] - run() ...
[11:01:03.651] run() for ‘Future’ ...
[11:01:03.651] - state: ‘created’
[11:01:03.651] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:03.666] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:03.666] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:03.666]   - Field: ‘node’
[11:01:03.666]   - Field: ‘label’
[11:01:03.667]   - Field: ‘local’
[11:01:03.667]   - Field: ‘owner’
[11:01:03.667]   - Field: ‘envir’
[11:01:03.667]   - Field: ‘workers’
[11:01:03.667]   - Field: ‘packages’
[11:01:03.667]   - Field: ‘gc’
[11:01:03.667]   - Field: ‘conditions’
[11:01:03.667]   - Field: ‘persistent’
[11:01:03.667]   - Field: ‘expr’
[11:01:03.667]   - Field: ‘uuid’
[11:01:03.667]   - Field: ‘seed’
[11:01:03.668]   - Field: ‘version’
[11:01:03.668]   - Field: ‘result’
[11:01:03.668]   - Field: ‘asynchronous’
[11:01:03.668]   - Field: ‘calls’
[11:01:03.668]   - Field: ‘globals’
[11:01:03.668]   - Field: ‘stdout’
[11:01:03.668]   - Field: ‘earlySignal’
[11:01:03.668]   - Field: ‘lazy’
[11:01:03.668]   - Field: ‘state’
[11:01:03.668] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:03.668] - Launch lazy future ...
[11:01:03.669] Packages needed by the future expression (n = 1): ‘future’
[11:01:03.669] Packages needed by future strategies (n = 0): <none>
[11:01:03.669] {
[11:01:03.669]     {
[11:01:03.669]         {
[11:01:03.669]             ...future.startTime <- base::Sys.time()
[11:01:03.669]             {
[11:01:03.669]                 {
[11:01:03.669]                   {
[11:01:03.669]                     {
[11:01:03.669]                       {
[11:01:03.669]                         base::local({
[11:01:03.669]                           has_future <- base::requireNamespace("future", 
[11:01:03.669]                             quietly = TRUE)
[11:01:03.669]                           if (has_future) {
[11:01:03.669]                             ns <- base::getNamespace("future")
[11:01:03.669]                             version <- ns[[".package"]][["version"]]
[11:01:03.669]                             if (is.null(version)) 
[11:01:03.669]                               version <- utils::packageVersion("future")
[11:01:03.669]                           }
[11:01:03.669]                           else {
[11:01:03.669]                             version <- NULL
[11:01:03.669]                           }
[11:01:03.669]                           if (!has_future || version < "1.8.0") {
[11:01:03.669]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:03.669]                               "", base::R.version$version.string), 
[11:01:03.669]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:03.669]                                 base::R.version$platform, 8 * 
[11:01:03.669]                                   base::.Machine$sizeof.pointer), 
[11:01:03.669]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:03.669]                                 "release", "version")], collapse = " "), 
[11:01:03.669]                               hostname = base::Sys.info()[["nodename"]])
[11:01:03.669]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:03.669]                               info)
[11:01:03.669]                             info <- base::paste(info, collapse = "; ")
[11:01:03.669]                             if (!has_future) {
[11:01:03.669]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:03.669]                                 info)
[11:01:03.669]                             }
[11:01:03.669]                             else {
[11:01:03.669]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:03.669]                                 info, version)
[11:01:03.669]                             }
[11:01:03.669]                             base::stop(msg)
[11:01:03.669]                           }
[11:01:03.669]                         })
[11:01:03.669]                       }
[11:01:03.669]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:03.669]                       base::options(mc.cores = 1L)
[11:01:03.669]                     }
[11:01:03.669]                     base::local({
[11:01:03.669]                       for (pkg in "future") {
[11:01:03.669]                         base::loadNamespace(pkg)
[11:01:03.669]                         base::library(pkg, character.only = TRUE)
[11:01:03.669]                       }
[11:01:03.669]                     })
[11:01:03.669]                   }
[11:01:03.669]                   ...future.strategy.old <- future::plan("list")
[11:01:03.669]                   options(future.plan = NULL)
[11:01:03.669]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:03.669]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:03.669]                 }
[11:01:03.669]                 ...future.workdir <- getwd()
[11:01:03.669]             }
[11:01:03.669]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:03.669]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:03.669]         }
[11:01:03.669]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:03.669]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:03.669]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:03.669]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:03.669]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:03.669]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:03.669]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:03.669]             base::names(...future.oldOptions))
[11:01:03.669]     }
[11:01:03.669]     if (FALSE) {
[11:01:03.669]     }
[11:01:03.669]     else {
[11:01:03.669]         if (TRUE) {
[11:01:03.669]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:03.669]                 open = "w")
[11:01:03.669]         }
[11:01:03.669]         else {
[11:01:03.669]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:03.669]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:03.669]         }
[11:01:03.669]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:03.669]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:03.669]             base::sink(type = "output", split = FALSE)
[11:01:03.669]             base::close(...future.stdout)
[11:01:03.669]         }, add = TRUE)
[11:01:03.669]     }
[11:01:03.669]     ...future.frame <- base::sys.nframe()
[11:01:03.669]     ...future.conditions <- base::list()
[11:01:03.669]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:03.669]     if (FALSE) {
[11:01:03.669]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:03.669]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:03.669]     }
[11:01:03.669]     ...future.result <- base::tryCatch({
[11:01:03.669]         base::withCallingHandlers({
[11:01:03.669]             ...future.value <- base::withVisible(base::local({
[11:01:03.669]                 ...future.makeSendCondition <- base::local({
[11:01:03.669]                   sendCondition <- NULL
[11:01:03.669]                   function(frame = 1L) {
[11:01:03.669]                     if (is.function(sendCondition)) 
[11:01:03.669]                       return(sendCondition)
[11:01:03.669]                     ns <- getNamespace("parallel")
[11:01:03.669]                     if (exists("sendData", mode = "function", 
[11:01:03.669]                       envir = ns)) {
[11:01:03.669]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:03.669]                         envir = ns)
[11:01:03.669]                       envir <- sys.frame(frame)
[11:01:03.669]                       master <- NULL
[11:01:03.669]                       while (!identical(envir, .GlobalEnv) && 
[11:01:03.669]                         !identical(envir, emptyenv())) {
[11:01:03.669]                         if (exists("master", mode = "list", envir = envir, 
[11:01:03.669]                           inherits = FALSE)) {
[11:01:03.669]                           master <- get("master", mode = "list", 
[11:01:03.669]                             envir = envir, inherits = FALSE)
[11:01:03.669]                           if (inherits(master, c("SOCKnode", 
[11:01:03.669]                             "SOCK0node"))) {
[11:01:03.669]                             sendCondition <<- function(cond) {
[11:01:03.669]                               data <- list(type = "VALUE", value = cond, 
[11:01:03.669]                                 success = TRUE)
[11:01:03.669]                               parallel_sendData(master, data)
[11:01:03.669]                             }
[11:01:03.669]                             return(sendCondition)
[11:01:03.669]                           }
[11:01:03.669]                         }
[11:01:03.669]                         frame <- frame + 1L
[11:01:03.669]                         envir <- sys.frame(frame)
[11:01:03.669]                       }
[11:01:03.669]                     }
[11:01:03.669]                     sendCondition <<- function(cond) NULL
[11:01:03.669]                   }
[11:01:03.669]                 })
[11:01:03.669]                 withCallingHandlers({
[11:01:03.669]                   {
[11:01:03.669]                     message(sprintf("Calculating tile #%d of %d ...", 
[11:01:03.669]                       ii, n), appendLF = FALSE)
[11:01:03.669]                     fit <- mandelbrot(C)
[11:01:03.669]                     delay(fit)
[11:01:03.669]                     message(" done")
[11:01:03.669]                     fit
[11:01:03.669]                   }
[11:01:03.669]                 }, immediateCondition = function(cond) {
[11:01:03.669]                   sendCondition <- ...future.makeSendCondition()
[11:01:03.669]                   sendCondition(cond)
[11:01:03.669]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:03.669]                   {
[11:01:03.669]                     inherits <- base::inherits
[11:01:03.669]                     invokeRestart <- base::invokeRestart
[11:01:03.669]                     is.null <- base::is.null
[11:01:03.669]                     muffled <- FALSE
[11:01:03.669]                     if (inherits(cond, "message")) {
[11:01:03.669]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:03.669]                       if (muffled) 
[11:01:03.669]                         invokeRestart("muffleMessage")
[11:01:03.669]                     }
[11:01:03.669]                     else if (inherits(cond, "warning")) {
[11:01:03.669]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:03.669]                       if (muffled) 
[11:01:03.669]                         invokeRestart("muffleWarning")
[11:01:03.669]                     }
[11:01:03.669]                     else if (inherits(cond, "condition")) {
[11:01:03.669]                       if (!is.null(pattern)) {
[11:01:03.669]                         computeRestarts <- base::computeRestarts
[11:01:03.669]                         grepl <- base::grepl
[11:01:03.669]                         restarts <- computeRestarts(cond)
[11:01:03.669]                         for (restart in restarts) {
[11:01:03.669]                           name <- restart$name
[11:01:03.669]                           if (is.null(name)) 
[11:01:03.669]                             next
[11:01:03.669]                           if (!grepl(pattern, name)) 
[11:01:03.669]                             next
[11:01:03.669]                           invokeRestart(restart)
[11:01:03.669]                           muffled <- TRUE
[11:01:03.669]                           break
[11:01:03.669]                         }
[11:01:03.669]                       }
[11:01:03.669]                     }
[11:01:03.669]                     invisible(muffled)
[11:01:03.669]                   }
[11:01:03.669]                   muffleCondition(cond)
[11:01:03.669]                 })
[11:01:03.669]             }))
[11:01:03.669]             future::FutureResult(value = ...future.value$value, 
[11:01:03.669]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:03.669]                   ...future.rng), globalenv = if (FALSE) 
[11:01:03.669]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:03.669]                     ...future.globalenv.names))
[11:01:03.669]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:03.669]         }, condition = base::local({
[11:01:03.669]             c <- base::c
[11:01:03.669]             inherits <- base::inherits
[11:01:03.669]             invokeRestart <- base::invokeRestart
[11:01:03.669]             length <- base::length
[11:01:03.669]             list <- base::list
[11:01:03.669]             seq.int <- base::seq.int
[11:01:03.669]             signalCondition <- base::signalCondition
[11:01:03.669]             sys.calls <- base::sys.calls
[11:01:03.669]             `[[` <- base::`[[`
[11:01:03.669]             `+` <- base::`+`
[11:01:03.669]             `<<-` <- base::`<<-`
[11:01:03.669]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:03.669]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:03.669]                   3L)]
[11:01:03.669]             }
[11:01:03.669]             function(cond) {
[11:01:03.669]                 is_error <- inherits(cond, "error")
[11:01:03.669]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:03.669]                   NULL)
[11:01:03.669]                 if (is_error) {
[11:01:03.669]                   sessionInformation <- function() {
[11:01:03.669]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:03.669]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:03.669]                       search = base::search(), system = base::Sys.info())
[11:01:03.669]                   }
[11:01:03.669]                   ...future.conditions[[length(...future.conditions) + 
[11:01:03.669]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:03.669]                     cond$call), session = sessionInformation(), 
[11:01:03.669]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:03.669]                   signalCondition(cond)
[11:01:03.669]                 }
[11:01:03.669]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:03.669]                 "immediateCondition"))) {
[11:01:03.669]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:03.669]                   ...future.conditions[[length(...future.conditions) + 
[11:01:03.669]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:03.669]                   if (TRUE && !signal) {
[11:01:03.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:03.669]                     {
[11:01:03.669]                       inherits <- base::inherits
[11:01:03.669]                       invokeRestart <- base::invokeRestart
[11:01:03.669]                       is.null <- base::is.null
[11:01:03.669]                       muffled <- FALSE
[11:01:03.669]                       if (inherits(cond, "message")) {
[11:01:03.669]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:03.669]                         if (muffled) 
[11:01:03.669]                           invokeRestart("muffleMessage")
[11:01:03.669]                       }
[11:01:03.669]                       else if (inherits(cond, "warning")) {
[11:01:03.669]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:03.669]                         if (muffled) 
[11:01:03.669]                           invokeRestart("muffleWarning")
[11:01:03.669]                       }
[11:01:03.669]                       else if (inherits(cond, "condition")) {
[11:01:03.669]                         if (!is.null(pattern)) {
[11:01:03.669]                           computeRestarts <- base::computeRestarts
[11:01:03.669]                           grepl <- base::grepl
[11:01:03.669]                           restarts <- computeRestarts(cond)
[11:01:03.669]                           for (restart in restarts) {
[11:01:03.669]                             name <- restart$name
[11:01:03.669]                             if (is.null(name)) 
[11:01:03.669]                               next
[11:01:03.669]                             if (!grepl(pattern, name)) 
[11:01:03.669]                               next
[11:01:03.669]                             invokeRestart(restart)
[11:01:03.669]                             muffled <- TRUE
[11:01:03.669]                             break
[11:01:03.669]                           }
[11:01:03.669]                         }
[11:01:03.669]                       }
[11:01:03.669]                       invisible(muffled)
[11:01:03.669]                     }
[11:01:03.669]                     muffleCondition(cond, pattern = "^muffle")
[11:01:03.669]                   }
[11:01:03.669]                 }
[11:01:03.669]                 else {
[11:01:03.669]                   if (TRUE) {
[11:01:03.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:03.669]                     {
[11:01:03.669]                       inherits <- base::inherits
[11:01:03.669]                       invokeRestart <- base::invokeRestart
[11:01:03.669]                       is.null <- base::is.null
[11:01:03.669]                       muffled <- FALSE
[11:01:03.669]                       if (inherits(cond, "message")) {
[11:01:03.669]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:03.669]                         if (muffled) 
[11:01:03.669]                           invokeRestart("muffleMessage")
[11:01:03.669]                       }
[11:01:03.669]                       else if (inherits(cond, "warning")) {
[11:01:03.669]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:03.669]                         if (muffled) 
[11:01:03.669]                           invokeRestart("muffleWarning")
[11:01:03.669]                       }
[11:01:03.669]                       else if (inherits(cond, "condition")) {
[11:01:03.669]                         if (!is.null(pattern)) {
[11:01:03.669]                           computeRestarts <- base::computeRestarts
[11:01:03.669]                           grepl <- base::grepl
[11:01:03.669]                           restarts <- computeRestarts(cond)
[11:01:03.669]                           for (restart in restarts) {
[11:01:03.669]                             name <- restart$name
[11:01:03.669]                             if (is.null(name)) 
[11:01:03.669]                               next
[11:01:03.669]                             if (!grepl(pattern, name)) 
[11:01:03.669]                               next
[11:01:03.669]                             invokeRestart(restart)
[11:01:03.669]                             muffled <- TRUE
[11:01:03.669]                             break
[11:01:03.669]                           }
[11:01:03.669]                         }
[11:01:03.669]                       }
[11:01:03.669]                       invisible(muffled)
[11:01:03.669]                     }
[11:01:03.669]                     muffleCondition(cond, pattern = "^muffle")
[11:01:03.669]                   }
[11:01:03.669]                 }
[11:01:03.669]             }
[11:01:03.669]         }))
[11:01:03.669]     }, error = function(ex) {
[11:01:03.669]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:03.669]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:03.669]                 ...future.rng), started = ...future.startTime, 
[11:01:03.669]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:03.669]             version = "1.8"), class = "FutureResult")
[11:01:03.669]     }, finally = {
[11:01:03.669]         if (!identical(...future.workdir, getwd())) 
[11:01:03.669]             setwd(...future.workdir)
[11:01:03.669]         {
[11:01:03.669]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:03.669]                 ...future.oldOptions$nwarnings <- NULL
[11:01:03.669]             }
[11:01:03.669]             base::options(...future.oldOptions)
[11:01:03.669]             if (.Platform$OS.type == "windows") {
[11:01:03.669]                 old_names <- names(...future.oldEnvVars)
[11:01:03.669]                 envs <- base::Sys.getenv()
[11:01:03.669]                 names <- names(envs)
[11:01:03.669]                 common <- intersect(names, old_names)
[11:01:03.669]                 added <- setdiff(names, old_names)
[11:01:03.669]                 removed <- setdiff(old_names, names)
[11:01:03.669]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:03.669]                   envs[common]]
[11:01:03.669]                 NAMES <- toupper(changed)
[11:01:03.669]                 args <- list()
[11:01:03.669]                 for (kk in seq_along(NAMES)) {
[11:01:03.669]                   name <- changed[[kk]]
[11:01:03.669]                   NAME <- NAMES[[kk]]
[11:01:03.669]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:03.669]                     next
[11:01:03.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:03.669]                 }
[11:01:03.669]                 NAMES <- toupper(added)
[11:01:03.669]                 for (kk in seq_along(NAMES)) {
[11:01:03.669]                   name <- added[[kk]]
[11:01:03.669]                   NAME <- NAMES[[kk]]
[11:01:03.669]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:03.669]                     next
[11:01:03.669]                   args[[name]] <- ""
[11:01:03.669]                 }
[11:01:03.669]                 NAMES <- toupper(removed)
[11:01:03.669]                 for (kk in seq_along(NAMES)) {
[11:01:03.669]                   name <- removed[[kk]]
[11:01:03.669]                   NAME <- NAMES[[kk]]
[11:01:03.669]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:03.669]                     next
[11:01:03.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:03.669]                 }
[11:01:03.669]                 if (length(args) > 0) 
[11:01:03.669]                   base::do.call(base::Sys.setenv, args = args)
[11:01:03.669]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:03.669]             }
[11:01:03.669]             else {
[11:01:03.669]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:03.669]             }
[11:01:03.669]             {
[11:01:03.669]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:03.669]                   0L) {
[11:01:03.669]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:03.669]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:03.669]                   base::options(opts)
[11:01:03.669]                 }
[11:01:03.669]                 {
[11:01:03.669]                   {
[11:01:03.669]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:03.669]                     NULL
[11:01:03.669]                   }
[11:01:03.669]                   options(future.plan = NULL)
[11:01:03.669]                   if (is.na(NA_character_)) 
[11:01:03.669]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:03.669]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:03.669]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:03.669]                     .init = FALSE)
[11:01:03.669]                 }
[11:01:03.669]             }
[11:01:03.669]         }
[11:01:03.669]     })
[11:01:03.669]     if (TRUE) {
[11:01:03.669]         base::sink(type = "output", split = FALSE)
[11:01:03.669]         if (TRUE) {
[11:01:03.669]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:03.669]         }
[11:01:03.669]         else {
[11:01:03.669]             ...future.result["stdout"] <- base::list(NULL)
[11:01:03.669]         }
[11:01:03.669]         base::close(...future.stdout)
[11:01:03.669]         ...future.stdout <- NULL
[11:01:03.669]     }
[11:01:03.669]     ...future.result$conditions <- ...future.conditions
[11:01:03.669]     ...future.result$finished <- base::Sys.time()
[11:01:03.669]     ...future.result
[11:01:03.669] }
[11:01:03.672] Exporting 4 global objects (57.67 KiB) to cluster node #1 ...
[11:01:03.672] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[11:01:03.672] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[11:01:03.673] Exporting ‘n’ (35 bytes) to cluster node #1 ...
[11:01:03.673] Exporting ‘n’ (35 bytes) to cluster node #1 ... DONE
[11:01:03.673] Exporting ‘C’ (10.00 KiB) to cluster node #1 ...
[11:01:03.714] Exporting ‘C’ (10.00 KiB) to cluster node #1 ... DONE
[11:01:03.714] Exporting ‘delay’ (47.33 KiB) to cluster node #1 ...
[11:01:03.755] Exporting ‘delay’ (47.33 KiB) to cluster node #1 ... DONE
[11:01:03.755] Exporting 4 global objects (57.67 KiB) to cluster node #1 ... DONE
[11:01:03.756] MultisessionFuture started
[11:01:03.756] - Launch lazy future ... done
[11:01:03.756] run() for ‘MultisessionFuture’ ... done
[11:01:03.756] - run() ... done
[11:01:03.756] - resolved() ...
[11:01:03.767] - resolved: FALSE
[11:01:03.767] - resolved() ... done
[11:01:03.767] resolved() for ‘MultisessionFuture’ ... done
[11:01:03.767] resolved() for ‘Future’ ...
[11:01:03.767] - state: ‘created’
[11:01:03.767] - run: TRUE
[11:01:03.767] - run() ...
[11:01:03.768] run() for ‘Future’ ...
[11:01:03.768] - state: ‘created’
[11:01:03.768] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:03.782] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:03.782] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:03.782]   - Field: ‘node’
[11:01:03.782]   - Field: ‘label’
[11:01:03.782]   - Field: ‘local’
[11:01:03.782]   - Field: ‘owner’
[11:01:03.782]   - Field: ‘envir’
[11:01:03.782]   - Field: ‘workers’
[11:01:03.782]   - Field: ‘packages’
[11:01:03.782]   - Field: ‘gc’
[11:01:03.782]   - Field: ‘conditions’
[11:01:03.783]   - Field: ‘persistent’
[11:01:03.783]   - Field: ‘expr’
[11:01:03.783]   - Field: ‘uuid’
[11:01:03.783]   - Field: ‘seed’
[11:01:03.783]   - Field: ‘version’
[11:01:03.783]   - Field: ‘result’
[11:01:03.783]   - Field: ‘asynchronous’
[11:01:03.783]   - Field: ‘calls’
[11:01:03.783]   - Field: ‘globals’
[11:01:03.783]   - Field: ‘stdout’
[11:01:03.783]   - Field: ‘earlySignal’
[11:01:03.783]   - Field: ‘lazy’
[11:01:03.784]   - Field: ‘state’
[11:01:03.784] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:03.784] - Launch lazy future ...
[11:01:03.784] Packages needed by the future expression (n = 1): ‘future’
[11:01:03.784] Packages needed by future strategies (n = 0): <none>
[11:01:03.785] {
[11:01:03.785]     {
[11:01:03.785]         {
[11:01:03.785]             ...future.startTime <- base::Sys.time()
[11:01:03.785]             {
[11:01:03.785]                 {
[11:01:03.785]                   {
[11:01:03.785]                     {
[11:01:03.785]                       {
[11:01:03.785]                         base::local({
[11:01:03.785]                           has_future <- base::requireNamespace("future", 
[11:01:03.785]                             quietly = TRUE)
[11:01:03.785]                           if (has_future) {
[11:01:03.785]                             ns <- base::getNamespace("future")
[11:01:03.785]                             version <- ns[[".package"]][["version"]]
[11:01:03.785]                             if (is.null(version)) 
[11:01:03.785]                               version <- utils::packageVersion("future")
[11:01:03.785]                           }
[11:01:03.785]                           else {
[11:01:03.785]                             version <- NULL
[11:01:03.785]                           }
[11:01:03.785]                           if (!has_future || version < "1.8.0") {
[11:01:03.785]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:03.785]                               "", base::R.version$version.string), 
[11:01:03.785]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:03.785]                                 base::R.version$platform, 8 * 
[11:01:03.785]                                   base::.Machine$sizeof.pointer), 
[11:01:03.785]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:03.785]                                 "release", "version")], collapse = " "), 
[11:01:03.785]                               hostname = base::Sys.info()[["nodename"]])
[11:01:03.785]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:03.785]                               info)
[11:01:03.785]                             info <- base::paste(info, collapse = "; ")
[11:01:03.785]                             if (!has_future) {
[11:01:03.785]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:03.785]                                 info)
[11:01:03.785]                             }
[11:01:03.785]                             else {
[11:01:03.785]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:03.785]                                 info, version)
[11:01:03.785]                             }
[11:01:03.785]                             base::stop(msg)
[11:01:03.785]                           }
[11:01:03.785]                         })
[11:01:03.785]                       }
[11:01:03.785]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:03.785]                       base::options(mc.cores = 1L)
[11:01:03.785]                     }
[11:01:03.785]                     base::local({
[11:01:03.785]                       for (pkg in "future") {
[11:01:03.785]                         base::loadNamespace(pkg)
[11:01:03.785]                         base::library(pkg, character.only = TRUE)
[11:01:03.785]                       }
[11:01:03.785]                     })
[11:01:03.785]                   }
[11:01:03.785]                   ...future.strategy.old <- future::plan("list")
[11:01:03.785]                   options(future.plan = NULL)
[11:01:03.785]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:03.785]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:03.785]                 }
[11:01:03.785]                 ...future.workdir <- getwd()
[11:01:03.785]             }
[11:01:03.785]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:03.785]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:03.785]         }
[11:01:03.785]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:03.785]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:03.785]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:03.785]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:03.785]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:03.785]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:03.785]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:03.785]             base::names(...future.oldOptions))
[11:01:03.785]     }
[11:01:03.785]     if (FALSE) {
[11:01:03.785]     }
[11:01:03.785]     else {
[11:01:03.785]         if (TRUE) {
[11:01:03.785]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:03.785]                 open = "w")
[11:01:03.785]         }
[11:01:03.785]         else {
[11:01:03.785]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:03.785]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:03.785]         }
[11:01:03.785]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:03.785]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:03.785]             base::sink(type = "output", split = FALSE)
[11:01:03.785]             base::close(...future.stdout)
[11:01:03.785]         }, add = TRUE)
[11:01:03.785]     }
[11:01:03.785]     ...future.frame <- base::sys.nframe()
[11:01:03.785]     ...future.conditions <- base::list()
[11:01:03.785]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:03.785]     if (FALSE) {
[11:01:03.785]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:03.785]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:03.785]     }
[11:01:03.785]     ...future.result <- base::tryCatch({
[11:01:03.785]         base::withCallingHandlers({
[11:01:03.785]             ...future.value <- base::withVisible(base::local({
[11:01:03.785]                 ...future.makeSendCondition <- base::local({
[11:01:03.785]                   sendCondition <- NULL
[11:01:03.785]                   function(frame = 1L) {
[11:01:03.785]                     if (is.function(sendCondition)) 
[11:01:03.785]                       return(sendCondition)
[11:01:03.785]                     ns <- getNamespace("parallel")
[11:01:03.785]                     if (exists("sendData", mode = "function", 
[11:01:03.785]                       envir = ns)) {
[11:01:03.785]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:03.785]                         envir = ns)
[11:01:03.785]                       envir <- sys.frame(frame)
[11:01:03.785]                       master <- NULL
[11:01:03.785]                       while (!identical(envir, .GlobalEnv) && 
[11:01:03.785]                         !identical(envir, emptyenv())) {
[11:01:03.785]                         if (exists("master", mode = "list", envir = envir, 
[11:01:03.785]                           inherits = FALSE)) {
[11:01:03.785]                           master <- get("master", mode = "list", 
[11:01:03.785]                             envir = envir, inherits = FALSE)
[11:01:03.785]                           if (inherits(master, c("SOCKnode", 
[11:01:03.785]                             "SOCK0node"))) {
[11:01:03.785]                             sendCondition <<- function(cond) {
[11:01:03.785]                               data <- list(type = "VALUE", value = cond, 
[11:01:03.785]                                 success = TRUE)
[11:01:03.785]                               parallel_sendData(master, data)
[11:01:03.785]                             }
[11:01:03.785]                             return(sendCondition)
[11:01:03.785]                           }
[11:01:03.785]                         }
[11:01:03.785]                         frame <- frame + 1L
[11:01:03.785]                         envir <- sys.frame(frame)
[11:01:03.785]                       }
[11:01:03.785]                     }
[11:01:03.785]                     sendCondition <<- function(cond) NULL
[11:01:03.785]                   }
[11:01:03.785]                 })
[11:01:03.785]                 withCallingHandlers({
[11:01:03.785]                   {
[11:01:03.785]                     message(sprintf("Calculating tile #%d of %d ...", 
[11:01:03.785]                       ii, n), appendLF = FALSE)
[11:01:03.785]                     fit <- mandelbrot(C)
[11:01:03.785]                     delay(fit)
[11:01:03.785]                     message(" done")
[11:01:03.785]                     fit
[11:01:03.785]                   }
[11:01:03.785]                 }, immediateCondition = function(cond) {
[11:01:03.785]                   sendCondition <- ...future.makeSendCondition()
[11:01:03.785]                   sendCondition(cond)
[11:01:03.785]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:03.785]                   {
[11:01:03.785]                     inherits <- base::inherits
[11:01:03.785]                     invokeRestart <- base::invokeRestart
[11:01:03.785]                     is.null <- base::is.null
[11:01:03.785]                     muffled <- FALSE
[11:01:03.785]                     if (inherits(cond, "message")) {
[11:01:03.785]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:03.785]                       if (muffled) 
[11:01:03.785]                         invokeRestart("muffleMessage")
[11:01:03.785]                     }
[11:01:03.785]                     else if (inherits(cond, "warning")) {
[11:01:03.785]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:03.785]                       if (muffled) 
[11:01:03.785]                         invokeRestart("muffleWarning")
[11:01:03.785]                     }
[11:01:03.785]                     else if (inherits(cond, "condition")) {
[11:01:03.785]                       if (!is.null(pattern)) {
[11:01:03.785]                         computeRestarts <- base::computeRestarts
[11:01:03.785]                         grepl <- base::grepl
[11:01:03.785]                         restarts <- computeRestarts(cond)
[11:01:03.785]                         for (restart in restarts) {
[11:01:03.785]                           name <- restart$name
[11:01:03.785]                           if (is.null(name)) 
[11:01:03.785]                             next
[11:01:03.785]                           if (!grepl(pattern, name)) 
[11:01:03.785]                             next
[11:01:03.785]                           invokeRestart(restart)
[11:01:03.785]                           muffled <- TRUE
[11:01:03.785]                           break
[11:01:03.785]                         }
[11:01:03.785]                       }
[11:01:03.785]                     }
[11:01:03.785]                     invisible(muffled)
[11:01:03.785]                   }
[11:01:03.785]                   muffleCondition(cond)
[11:01:03.785]                 })
[11:01:03.785]             }))
[11:01:03.785]             future::FutureResult(value = ...future.value$value, 
[11:01:03.785]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:03.785]                   ...future.rng), globalenv = if (FALSE) 
[11:01:03.785]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:03.785]                     ...future.globalenv.names))
[11:01:03.785]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:03.785]         }, condition = base::local({
[11:01:03.785]             c <- base::c
[11:01:03.785]             inherits <- base::inherits
[11:01:03.785]             invokeRestart <- base::invokeRestart
[11:01:03.785]             length <- base::length
[11:01:03.785]             list <- base::list
[11:01:03.785]             seq.int <- base::seq.int
[11:01:03.785]             signalCondition <- base::signalCondition
[11:01:03.785]             sys.calls <- base::sys.calls
[11:01:03.785]             `[[` <- base::`[[`
[11:01:03.785]             `+` <- base::`+`
[11:01:03.785]             `<<-` <- base::`<<-`
[11:01:03.785]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:03.785]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:03.785]                   3L)]
[11:01:03.785]             }
[11:01:03.785]             function(cond) {
[11:01:03.785]                 is_error <- inherits(cond, "error")
[11:01:03.785]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:03.785]                   NULL)
[11:01:03.785]                 if (is_error) {
[11:01:03.785]                   sessionInformation <- function() {
[11:01:03.785]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:03.785]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:03.785]                       search = base::search(), system = base::Sys.info())
[11:01:03.785]                   }
[11:01:03.785]                   ...future.conditions[[length(...future.conditions) + 
[11:01:03.785]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:03.785]                     cond$call), session = sessionInformation(), 
[11:01:03.785]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:03.785]                   signalCondition(cond)
[11:01:03.785]                 }
[11:01:03.785]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:03.785]                 "immediateCondition"))) {
[11:01:03.785]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:03.785]                   ...future.conditions[[length(...future.conditions) + 
[11:01:03.785]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:03.785]                   if (TRUE && !signal) {
[11:01:03.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:03.785]                     {
[11:01:03.785]                       inherits <- base::inherits
[11:01:03.785]                       invokeRestart <- base::invokeRestart
[11:01:03.785]                       is.null <- base::is.null
[11:01:03.785]                       muffled <- FALSE
[11:01:03.785]                       if (inherits(cond, "message")) {
[11:01:03.785]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:03.785]                         if (muffled) 
[11:01:03.785]                           invokeRestart("muffleMessage")
[11:01:03.785]                       }
[11:01:03.785]                       else if (inherits(cond, "warning")) {
[11:01:03.785]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:03.785]                         if (muffled) 
[11:01:03.785]                           invokeRestart("muffleWarning")
[11:01:03.785]                       }
[11:01:03.785]                       else if (inherits(cond, "condition")) {
[11:01:03.785]                         if (!is.null(pattern)) {
[11:01:03.785]                           computeRestarts <- base::computeRestarts
[11:01:03.785]                           grepl <- base::grepl
[11:01:03.785]                           restarts <- computeRestarts(cond)
[11:01:03.785]                           for (restart in restarts) {
[11:01:03.785]                             name <- restart$name
[11:01:03.785]                             if (is.null(name)) 
[11:01:03.785]                               next
[11:01:03.785]                             if (!grepl(pattern, name)) 
[11:01:03.785]                               next
[11:01:03.785]                             invokeRestart(restart)
[11:01:03.785]                             muffled <- TRUE
[11:01:03.785]                             break
[11:01:03.785]                           }
[11:01:03.785]                         }
[11:01:03.785]                       }
[11:01:03.785]                       invisible(muffled)
[11:01:03.785]                     }
[11:01:03.785]                     muffleCondition(cond, pattern = "^muffle")
[11:01:03.785]                   }
[11:01:03.785]                 }
[11:01:03.785]                 else {
[11:01:03.785]                   if (TRUE) {
[11:01:03.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:03.785]                     {
[11:01:03.785]                       inherits <- base::inherits
[11:01:03.785]                       invokeRestart <- base::invokeRestart
[11:01:03.785]                       is.null <- base::is.null
[11:01:03.785]                       muffled <- FALSE
[11:01:03.785]                       if (inherits(cond, "message")) {
[11:01:03.785]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:03.785]                         if (muffled) 
[11:01:03.785]                           invokeRestart("muffleMessage")
[11:01:03.785]                       }
[11:01:03.785]                       else if (inherits(cond, "warning")) {
[11:01:03.785]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:03.785]                         if (muffled) 
[11:01:03.785]                           invokeRestart("muffleWarning")
[11:01:03.785]                       }
[11:01:03.785]                       else if (inherits(cond, "condition")) {
[11:01:03.785]                         if (!is.null(pattern)) {
[11:01:03.785]                           computeRestarts <- base::computeRestarts
[11:01:03.785]                           grepl <- base::grepl
[11:01:03.785]                           restarts <- computeRestarts(cond)
[11:01:03.785]                           for (restart in restarts) {
[11:01:03.785]                             name <- restart$name
[11:01:03.785]                             if (is.null(name)) 
[11:01:03.785]                               next
[11:01:03.785]                             if (!grepl(pattern, name)) 
[11:01:03.785]                               next
[11:01:03.785]                             invokeRestart(restart)
[11:01:03.785]                             muffled <- TRUE
[11:01:03.785]                             break
[11:01:03.785]                           }
[11:01:03.785]                         }
[11:01:03.785]                       }
[11:01:03.785]                       invisible(muffled)
[11:01:03.785]                     }
[11:01:03.785]                     muffleCondition(cond, pattern = "^muffle")
[11:01:03.785]                   }
[11:01:03.785]                 }
[11:01:03.785]             }
[11:01:03.785]         }))
[11:01:03.785]     }, error = function(ex) {
[11:01:03.785]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:03.785]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:03.785]                 ...future.rng), started = ...future.startTime, 
[11:01:03.785]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:03.785]             version = "1.8"), class = "FutureResult")
[11:01:03.785]     }, finally = {
[11:01:03.785]         if (!identical(...future.workdir, getwd())) 
[11:01:03.785]             setwd(...future.workdir)
[11:01:03.785]         {
[11:01:03.785]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:03.785]                 ...future.oldOptions$nwarnings <- NULL
[11:01:03.785]             }
[11:01:03.785]             base::options(...future.oldOptions)
[11:01:03.785]             if (.Platform$OS.type == "windows") {
[11:01:03.785]                 old_names <- names(...future.oldEnvVars)
[11:01:03.785]                 envs <- base::Sys.getenv()
[11:01:03.785]                 names <- names(envs)
[11:01:03.785]                 common <- intersect(names, old_names)
[11:01:03.785]                 added <- setdiff(names, old_names)
[11:01:03.785]                 removed <- setdiff(old_names, names)
[11:01:03.785]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:03.785]                   envs[common]]
[11:01:03.785]                 NAMES <- toupper(changed)
[11:01:03.785]                 args <- list()
[11:01:03.785]                 for (kk in seq_along(NAMES)) {
[11:01:03.785]                   name <- changed[[kk]]
[11:01:03.785]                   NAME <- NAMES[[kk]]
[11:01:03.785]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:03.785]                     next
[11:01:03.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:03.785]                 }
[11:01:03.785]                 NAMES <- toupper(added)
[11:01:03.785]                 for (kk in seq_along(NAMES)) {
[11:01:03.785]                   name <- added[[kk]]
[11:01:03.785]                   NAME <- NAMES[[kk]]
[11:01:03.785]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:03.785]                     next
[11:01:03.785]                   args[[name]] <- ""
[11:01:03.785]                 }
[11:01:03.785]                 NAMES <- toupper(removed)
[11:01:03.785]                 for (kk in seq_along(NAMES)) {
[11:01:03.785]                   name <- removed[[kk]]
[11:01:03.785]                   NAME <- NAMES[[kk]]
[11:01:03.785]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:03.785]                     next
[11:01:03.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:03.785]                 }
[11:01:03.785]                 if (length(args) > 0) 
[11:01:03.785]                   base::do.call(base::Sys.setenv, args = args)
[11:01:03.785]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:03.785]             }
[11:01:03.785]             else {
[11:01:03.785]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:03.785]             }
[11:01:03.785]             {
[11:01:03.785]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:03.785]                   0L) {
[11:01:03.785]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:03.785]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:03.785]                   base::options(opts)
[11:01:03.785]                 }
[11:01:03.785]                 {
[11:01:03.785]                   {
[11:01:03.785]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:03.785]                     NULL
[11:01:03.785]                   }
[11:01:03.785]                   options(future.plan = NULL)
[11:01:03.785]                   if (is.na(NA_character_)) 
[11:01:03.785]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:03.785]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:03.785]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:03.785]                     .init = FALSE)
[11:01:03.785]                 }
[11:01:03.785]             }
[11:01:03.785]         }
[11:01:03.785]     })
[11:01:03.785]     if (TRUE) {
[11:01:03.785]         base::sink(type = "output", split = FALSE)
[11:01:03.785]         if (TRUE) {
[11:01:03.785]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:03.785]         }
[11:01:03.785]         else {
[11:01:03.785]             ...future.result["stdout"] <- base::list(NULL)
[11:01:03.785]         }
[11:01:03.785]         base::close(...future.stdout)
[11:01:03.785]         ...future.stdout <- NULL
[11:01:03.785]     }
[11:01:03.785]     ...future.result$conditions <- ...future.conditions
[11:01:03.785]     ...future.result$finished <- base::Sys.time()
[11:01:03.785]     ...future.result
[11:01:03.785] }
[11:01:03.836] Exporting 4 global objects (57.67 KiB) to cluster node #2 ...
[11:01:03.836] Exporting ‘ii’ (35 bytes) to cluster node #2 ...
[11:01:03.837] Exporting ‘ii’ (35 bytes) to cluster node #2 ... DONE
[11:01:03.837] Exporting ‘n’ (35 bytes) to cluster node #2 ...
[11:01:03.837] Exporting ‘n’ (35 bytes) to cluster node #2 ... DONE
[11:01:03.837] Exporting ‘C’ (10.00 KiB) to cluster node #2 ...
[11:01:03.879] Exporting ‘C’ (10.00 KiB) to cluster node #2 ... DONE
[11:01:03.879] Exporting ‘delay’ (47.33 KiB) to cluster node #2 ...
[11:01:03.920] Exporting ‘delay’ (47.33 KiB) to cluster node #2 ... DONE
[11:01:03.920] Exporting 4 global objects (57.67 KiB) to cluster node #2 ... DONE
[11:01:03.921] MultisessionFuture started
[11:01:03.921] - Launch lazy future ... done
[11:01:03.921] run() for ‘MultisessionFuture’ ... done
[11:01:03.921] - run() ... done
[11:01:03.921] - resolved() ...
[11:01:03.932] - resolved: FALSE
[11:01:03.932] - resolved() ... done
[11:01:03.932] resolved() for ‘MultisessionFuture’ ... done
[11:01:03.932] resolved() for ‘Future’ ...
[11:01:03.932] - state: ‘created’
[11:01:03.933] - run: TRUE
[11:01:03.933] - run() ...
[11:01:03.933] run() for ‘Future’ ...
[11:01:03.933] - state: ‘created’
[11:01:03.935] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:03.949] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:03.949] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:03.949]   - Field: ‘node’
[11:01:03.949]   - Field: ‘label’
[11:01:03.949]   - Field: ‘local’
[11:01:03.949]   - Field: ‘owner’
[11:01:03.950]   - Field: ‘envir’
[11:01:03.950]   - Field: ‘workers’
[11:01:03.950]   - Field: ‘packages’
[11:01:03.950]   - Field: ‘gc’
[11:01:03.950]   - Field: ‘conditions’
[11:01:03.950]   - Field: ‘persistent’
[11:01:03.950]   - Field: ‘expr’
[11:01:03.950]   - Field: ‘uuid’
[11:01:03.950]   - Field: ‘seed’
[11:01:03.950]   - Field: ‘version’
[11:01:03.950]   - Field: ‘result’
[11:01:03.950]   - Field: ‘asynchronous’
[11:01:03.951]   - Field: ‘calls’
[11:01:03.951]   - Field: ‘globals’
[11:01:03.951]   - Field: ‘stdout’
[11:01:03.951]   - Field: ‘earlySignal’
[11:01:03.951]   - Field: ‘lazy’
[11:01:03.951]   - Field: ‘state’
[11:01:03.951] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:03.951] - Launch lazy future ...
[11:01:03.951] Packages needed by the future expression (n = 1): ‘future’
[11:01:03.951] Packages needed by future strategies (n = 0): <none>
[11:01:03.952] {
[11:01:03.952]     {
[11:01:03.952]         {
[11:01:03.952]             ...future.startTime <- base::Sys.time()
[11:01:03.952]             {
[11:01:03.952]                 {
[11:01:03.952]                   {
[11:01:03.952]                     {
[11:01:03.952]                       {
[11:01:03.952]                         base::local({
[11:01:03.952]                           has_future <- base::requireNamespace("future", 
[11:01:03.952]                             quietly = TRUE)
[11:01:03.952]                           if (has_future) {
[11:01:03.952]                             ns <- base::getNamespace("future")
[11:01:03.952]                             version <- ns[[".package"]][["version"]]
[11:01:03.952]                             if (is.null(version)) 
[11:01:03.952]                               version <- utils::packageVersion("future")
[11:01:03.952]                           }
[11:01:03.952]                           else {
[11:01:03.952]                             version <- NULL
[11:01:03.952]                           }
[11:01:03.952]                           if (!has_future || version < "1.8.0") {
[11:01:03.952]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:03.952]                               "", base::R.version$version.string), 
[11:01:03.952]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:03.952]                                 base::R.version$platform, 8 * 
[11:01:03.952]                                   base::.Machine$sizeof.pointer), 
[11:01:03.952]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:03.952]                                 "release", "version")], collapse = " "), 
[11:01:03.952]                               hostname = base::Sys.info()[["nodename"]])
[11:01:03.952]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:03.952]                               info)
[11:01:03.952]                             info <- base::paste(info, collapse = "; ")
[11:01:03.952]                             if (!has_future) {
[11:01:03.952]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:03.952]                                 info)
[11:01:03.952]                             }
[11:01:03.952]                             else {
[11:01:03.952]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:03.952]                                 info, version)
[11:01:03.952]                             }
[11:01:03.952]                             base::stop(msg)
[11:01:03.952]                           }
[11:01:03.952]                         })
[11:01:03.952]                       }
[11:01:03.952]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:03.952]                       base::options(mc.cores = 1L)
[11:01:03.952]                     }
[11:01:03.952]                     base::local({
[11:01:03.952]                       for (pkg in "future") {
[11:01:03.952]                         base::loadNamespace(pkg)
[11:01:03.952]                         base::library(pkg, character.only = TRUE)
[11:01:03.952]                       }
[11:01:03.952]                     })
[11:01:03.952]                   }
[11:01:03.952]                   ...future.strategy.old <- future::plan("list")
[11:01:03.952]                   options(future.plan = NULL)
[11:01:03.952]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:03.952]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:03.952]                 }
[11:01:03.952]                 ...future.workdir <- getwd()
[11:01:03.952]             }
[11:01:03.952]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:03.952]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:03.952]         }
[11:01:03.952]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:03.952]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:03.952]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:03.952]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:03.952]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:03.952]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:03.952]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:03.952]             base::names(...future.oldOptions))
[11:01:03.952]     }
[11:01:03.952]     if (FALSE) {
[11:01:03.952]     }
[11:01:03.952]     else {
[11:01:03.952]         if (TRUE) {
[11:01:03.952]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:03.952]                 open = "w")
[11:01:03.952]         }
[11:01:03.952]         else {
[11:01:03.952]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:03.952]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:03.952]         }
[11:01:03.952]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:03.952]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:03.952]             base::sink(type = "output", split = FALSE)
[11:01:03.952]             base::close(...future.stdout)
[11:01:03.952]         }, add = TRUE)
[11:01:03.952]     }
[11:01:03.952]     ...future.frame <- base::sys.nframe()
[11:01:03.952]     ...future.conditions <- base::list()
[11:01:03.952]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:03.952]     if (FALSE) {
[11:01:03.952]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:03.952]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:03.952]     }
[11:01:03.952]     ...future.result <- base::tryCatch({
[11:01:03.952]         base::withCallingHandlers({
[11:01:03.952]             ...future.value <- base::withVisible(base::local({
[11:01:03.952]                 ...future.makeSendCondition <- base::local({
[11:01:03.952]                   sendCondition <- NULL
[11:01:03.952]                   function(frame = 1L) {
[11:01:03.952]                     if (is.function(sendCondition)) 
[11:01:03.952]                       return(sendCondition)
[11:01:03.952]                     ns <- getNamespace("parallel")
[11:01:03.952]                     if (exists("sendData", mode = "function", 
[11:01:03.952]                       envir = ns)) {
[11:01:03.952]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:03.952]                         envir = ns)
[11:01:03.952]                       envir <- sys.frame(frame)
[11:01:03.952]                       master <- NULL
[11:01:03.952]                       while (!identical(envir, .GlobalEnv) && 
[11:01:03.952]                         !identical(envir, emptyenv())) {
[11:01:03.952]                         if (exists("master", mode = "list", envir = envir, 
[11:01:03.952]                           inherits = FALSE)) {
[11:01:03.952]                           master <- get("master", mode = "list", 
[11:01:03.952]                             envir = envir, inherits = FALSE)
[11:01:03.952]                           if (inherits(master, c("SOCKnode", 
[11:01:03.952]                             "SOCK0node"))) {
[11:01:03.952]                             sendCondition <<- function(cond) {
[11:01:03.952]                               data <- list(type = "VALUE", value = cond, 
[11:01:03.952]                                 success = TRUE)
[11:01:03.952]                               parallel_sendData(master, data)
[11:01:03.952]                             }
[11:01:03.952]                             return(sendCondition)
[11:01:03.952]                           }
[11:01:03.952]                         }
[11:01:03.952]                         frame <- frame + 1L
[11:01:03.952]                         envir <- sys.frame(frame)
[11:01:03.952]                       }
[11:01:03.952]                     }
[11:01:03.952]                     sendCondition <<- function(cond) NULL
[11:01:03.952]                   }
[11:01:03.952]                 })
[11:01:03.952]                 withCallingHandlers({
[11:01:03.952]                   {
[11:01:03.952]                     message(sprintf("Calculating tile #%d of %d ...", 
[11:01:03.952]                       ii, n), appendLF = FALSE)
[11:01:03.952]                     fit <- mandelbrot(C)
[11:01:03.952]                     delay(fit)
[11:01:03.952]                     message(" done")
[11:01:03.952]                     fit
[11:01:03.952]                   }
[11:01:03.952]                 }, immediateCondition = function(cond) {
[11:01:03.952]                   sendCondition <- ...future.makeSendCondition()
[11:01:03.952]                   sendCondition(cond)
[11:01:03.952]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:03.952]                   {
[11:01:03.952]                     inherits <- base::inherits
[11:01:03.952]                     invokeRestart <- base::invokeRestart
[11:01:03.952]                     is.null <- base::is.null
[11:01:03.952]                     muffled <- FALSE
[11:01:03.952]                     if (inherits(cond, "message")) {
[11:01:03.952]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:03.952]                       if (muffled) 
[11:01:03.952]                         invokeRestart("muffleMessage")
[11:01:03.952]                     }
[11:01:03.952]                     else if (inherits(cond, "warning")) {
[11:01:03.952]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:03.952]                       if (muffled) 
[11:01:03.952]                         invokeRestart("muffleWarning")
[11:01:03.952]                     }
[11:01:03.952]                     else if (inherits(cond, "condition")) {
[11:01:03.952]                       if (!is.null(pattern)) {
[11:01:03.952]                         computeRestarts <- base::computeRestarts
[11:01:03.952]                         grepl <- base::grepl
[11:01:03.952]                         restarts <- computeRestarts(cond)
[11:01:03.952]                         for (restart in restarts) {
[11:01:03.952]                           name <- restart$name
[11:01:03.952]                           if (is.null(name)) 
[11:01:03.952]                             next
[11:01:03.952]                           if (!grepl(pattern, name)) 
[11:01:03.952]                             next
[11:01:03.952]                           invokeRestart(restart)
[11:01:03.952]                           muffled <- TRUE
[11:01:03.952]                           break
[11:01:03.952]                         }
[11:01:03.952]                       }
[11:01:03.952]                     }
[11:01:03.952]                     invisible(muffled)
[11:01:03.952]                   }
[11:01:03.952]                   muffleCondition(cond)
[11:01:03.952]                 })
[11:01:03.952]             }))
[11:01:03.952]             future::FutureResult(value = ...future.value$value, 
[11:01:03.952]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:03.952]                   ...future.rng), globalenv = if (FALSE) 
[11:01:03.952]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:03.952]                     ...future.globalenv.names))
[11:01:03.952]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:03.952]         }, condition = base::local({
[11:01:03.952]             c <- base::c
[11:01:03.952]             inherits <- base::inherits
[11:01:03.952]             invokeRestart <- base::invokeRestart
[11:01:03.952]             length <- base::length
[11:01:03.952]             list <- base::list
[11:01:03.952]             seq.int <- base::seq.int
[11:01:03.952]             signalCondition <- base::signalCondition
[11:01:03.952]             sys.calls <- base::sys.calls
[11:01:03.952]             `[[` <- base::`[[`
[11:01:03.952]             `+` <- base::`+`
[11:01:03.952]             `<<-` <- base::`<<-`
[11:01:03.952]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:03.952]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:03.952]                   3L)]
[11:01:03.952]             }
[11:01:03.952]             function(cond) {
[11:01:03.952]                 is_error <- inherits(cond, "error")
[11:01:03.952]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:03.952]                   NULL)
[11:01:03.952]                 if (is_error) {
[11:01:03.952]                   sessionInformation <- function() {
[11:01:03.952]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:03.952]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:03.952]                       search = base::search(), system = base::Sys.info())
[11:01:03.952]                   }
[11:01:03.952]                   ...future.conditions[[length(...future.conditions) + 
[11:01:03.952]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:03.952]                     cond$call), session = sessionInformation(), 
[11:01:03.952]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:03.952]                   signalCondition(cond)
[11:01:03.952]                 }
[11:01:03.952]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:03.952]                 "immediateCondition"))) {
[11:01:03.952]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:03.952]                   ...future.conditions[[length(...future.conditions) + 
[11:01:03.952]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:03.952]                   if (TRUE && !signal) {
[11:01:03.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:03.952]                     {
[11:01:03.952]                       inherits <- base::inherits
[11:01:03.952]                       invokeRestart <- base::invokeRestart
[11:01:03.952]                       is.null <- base::is.null
[11:01:03.952]                       muffled <- FALSE
[11:01:03.952]                       if (inherits(cond, "message")) {
[11:01:03.952]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:03.952]                         if (muffled) 
[11:01:03.952]                           invokeRestart("muffleMessage")
[11:01:03.952]                       }
[11:01:03.952]                       else if (inherits(cond, "warning")) {
[11:01:03.952]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:03.952]                         if (muffled) 
[11:01:03.952]                           invokeRestart("muffleWarning")
[11:01:03.952]                       }
[11:01:03.952]                       else if (inherits(cond, "condition")) {
[11:01:03.952]                         if (!is.null(pattern)) {
[11:01:03.952]                           computeRestarts <- base::computeRestarts
[11:01:03.952]                           grepl <- base::grepl
[11:01:03.952]                           restarts <- computeRestarts(cond)
[11:01:03.952]                           for (restart in restarts) {
[11:01:03.952]                             name <- restart$name
[11:01:03.952]                             if (is.null(name)) 
[11:01:03.952]                               next
[11:01:03.952]                             if (!grepl(pattern, name)) 
[11:01:03.952]                               next
[11:01:03.952]                             invokeRestart(restart)
[11:01:03.952]                             muffled <- TRUE
[11:01:03.952]                             break
[11:01:03.952]                           }
[11:01:03.952]                         }
[11:01:03.952]                       }
[11:01:03.952]                       invisible(muffled)
[11:01:03.952]                     }
[11:01:03.952]                     muffleCondition(cond, pattern = "^muffle")
[11:01:03.952]                   }
[11:01:03.952]                 }
[11:01:03.952]                 else {
[11:01:03.952]                   if (TRUE) {
[11:01:03.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:03.952]                     {
[11:01:03.952]                       inherits <- base::inherits
[11:01:03.952]                       invokeRestart <- base::invokeRestart
[11:01:03.952]                       is.null <- base::is.null
[11:01:03.952]                       muffled <- FALSE
[11:01:03.952]                       if (inherits(cond, "message")) {
[11:01:03.952]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:03.952]                         if (muffled) 
[11:01:03.952]                           invokeRestart("muffleMessage")
[11:01:03.952]                       }
[11:01:03.952]                       else if (inherits(cond, "warning")) {
[11:01:03.952]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:03.952]                         if (muffled) 
[11:01:03.952]                           invokeRestart("muffleWarning")
[11:01:03.952]                       }
[11:01:03.952]                       else if (inherits(cond, "condition")) {
[11:01:03.952]                         if (!is.null(pattern)) {
[11:01:03.952]                           computeRestarts <- base::computeRestarts
[11:01:03.952]                           grepl <- base::grepl
[11:01:03.952]                           restarts <- computeRestarts(cond)
[11:01:03.952]                           for (restart in restarts) {
[11:01:03.952]                             name <- restart$name
[11:01:03.952]                             if (is.null(name)) 
[11:01:03.952]                               next
[11:01:03.952]                             if (!grepl(pattern, name)) 
[11:01:03.952]                               next
[11:01:03.952]                             invokeRestart(restart)
[11:01:03.952]                             muffled <- TRUE
[11:01:03.952]                             break
[11:01:03.952]                           }
[11:01:03.952]                         }
[11:01:03.952]                       }
[11:01:03.952]                       invisible(muffled)
[11:01:03.952]                     }
[11:01:03.952]                     muffleCondition(cond, pattern = "^muffle")
[11:01:03.952]                   }
[11:01:03.952]                 }
[11:01:03.952]             }
[11:01:03.952]         }))
[11:01:03.952]     }, error = function(ex) {
[11:01:03.952]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:03.952]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:03.952]                 ...future.rng), started = ...future.startTime, 
[11:01:03.952]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:03.952]             version = "1.8"), class = "FutureResult")
[11:01:03.952]     }, finally = {
[11:01:03.952]         if (!identical(...future.workdir, getwd())) 
[11:01:03.952]             setwd(...future.workdir)
[11:01:03.952]         {
[11:01:03.952]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:03.952]                 ...future.oldOptions$nwarnings <- NULL
[11:01:03.952]             }
[11:01:03.952]             base::options(...future.oldOptions)
[11:01:03.952]             if (.Platform$OS.type == "windows") {
[11:01:03.952]                 old_names <- names(...future.oldEnvVars)
[11:01:03.952]                 envs <- base::Sys.getenv()
[11:01:03.952]                 names <- names(envs)
[11:01:03.952]                 common <- intersect(names, old_names)
[11:01:03.952]                 added <- setdiff(names, old_names)
[11:01:03.952]                 removed <- setdiff(old_names, names)
[11:01:03.952]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:03.952]                   envs[common]]
[11:01:03.952]                 NAMES <- toupper(changed)
[11:01:03.952]                 args <- list()
[11:01:03.952]                 for (kk in seq_along(NAMES)) {
[11:01:03.952]                   name <- changed[[kk]]
[11:01:03.952]                   NAME <- NAMES[[kk]]
[11:01:03.952]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:03.952]                     next
[11:01:03.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:03.952]                 }
[11:01:03.952]                 NAMES <- toupper(added)
[11:01:03.952]                 for (kk in seq_along(NAMES)) {
[11:01:03.952]                   name <- added[[kk]]
[11:01:03.952]                   NAME <- NAMES[[kk]]
[11:01:03.952]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:03.952]                     next
[11:01:03.952]                   args[[name]] <- ""
[11:01:03.952]                 }
[11:01:03.952]                 NAMES <- toupper(removed)
[11:01:03.952]                 for (kk in seq_along(NAMES)) {
[11:01:03.952]                   name <- removed[[kk]]
[11:01:03.952]                   NAME <- NAMES[[kk]]
[11:01:03.952]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:03.952]                     next
[11:01:03.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:03.952]                 }
[11:01:03.952]                 if (length(args) > 0) 
[11:01:03.952]                   base::do.call(base::Sys.setenv, args = args)
[11:01:03.952]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:03.952]             }
[11:01:03.952]             else {
[11:01:03.952]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:03.952]             }
[11:01:03.952]             {
[11:01:03.952]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:03.952]                   0L) {
[11:01:03.952]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:03.952]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:03.952]                   base::options(opts)
[11:01:03.952]                 }
[11:01:03.952]                 {
[11:01:03.952]                   {
[11:01:03.952]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:03.952]                     NULL
[11:01:03.952]                   }
[11:01:03.952]                   options(future.plan = NULL)
[11:01:03.952]                   if (is.na(NA_character_)) 
[11:01:03.952]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:03.952]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:03.952]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:03.952]                     .init = FALSE)
[11:01:03.952]                 }
[11:01:03.952]             }
[11:01:03.952]         }
[11:01:03.952]     })
[11:01:03.952]     if (TRUE) {
[11:01:03.952]         base::sink(type = "output", split = FALSE)
[11:01:03.952]         if (TRUE) {
[11:01:03.952]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:03.952]         }
[11:01:03.952]         else {
[11:01:03.952]             ...future.result["stdout"] <- base::list(NULL)
[11:01:03.952]         }
[11:01:03.952]         base::close(...future.stdout)
[11:01:03.952]         ...future.stdout <- NULL
[11:01:03.952]     }
[11:01:03.952]     ...future.result$conditions <- ...future.conditions
[11:01:03.952]     ...future.result$finished <- base::Sys.time()
[11:01:03.952]     ...future.result
[11:01:03.952] }
[11:01:03.954] Poll #1 (0): usedNodes() = 2, workers = 2
[11:01:03.965] receiveMessageFromWorker() for ClusterFuture ...
[11:01:03.965] - Validating connection of MultisessionFuture
[11:01:03.966] - received message: FutureResult
[11:01:03.966] - Received FutureResult
[11:01:03.966] - Erased future from FutureRegistry
[11:01:03.966] result() for ClusterFuture ...
[11:01:03.966] - result already collected: FutureResult
[11:01:03.966] result() for ClusterFuture ... done
[11:01:03.967] signalConditions() ...
[11:01:03.967]  - include = ‘immediateCondition’
[11:01:03.967]  - exclude = 
[11:01:03.967]  - resignal = FALSE
[11:01:03.967]  - Number of conditions: 2
[11:01:03.967] signalConditions() ... done
[11:01:03.967] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:03.968] result() for ClusterFuture ...
[11:01:03.968] - result already collected: FutureResult
[11:01:03.968] result() for ClusterFuture ... done
[11:01:03.968] result() for ClusterFuture ...
[11:01:03.968] - result already collected: FutureResult
[11:01:03.968] result() for ClusterFuture ... done
[11:01:03.968] signalConditions() ...
[11:01:03.969]  - include = ‘immediateCondition’
[11:01:03.969]  - exclude = 
[11:01:03.969]  - resignal = FALSE
[11:01:03.969]  - Number of conditions: 2
[11:01:03.969] signalConditions() ... done
[11:01:03.970] Exporting 4 global objects (57.67 KiB) to cluster node #1 ...
[11:01:03.970] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[11:01:03.971] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[11:01:03.971] Exporting ‘n’ (35 bytes) to cluster node #1 ...
[11:01:03.971] Exporting ‘n’ (35 bytes) to cluster node #1 ... DONE
[11:01:03.971] Exporting ‘C’ (10.00 KiB) to cluster node #1 ...
[11:01:04.013] Exporting ‘C’ (10.00 KiB) to cluster node #1 ... DONE
[11:01:04.013] Exporting ‘delay’ (47.33 KiB) to cluster node #1 ...
[11:01:04.055] Exporting ‘delay’ (47.33 KiB) to cluster node #1 ... DONE
[11:01:04.055] Exporting 4 global objects (57.67 KiB) to cluster node #1 ... DONE
[11:01:04.056] MultisessionFuture started
[11:01:04.056] - Launch lazy future ... done
[11:01:04.056] run() for ‘MultisessionFuture’ ... done
[11:01:04.056] - run() ... done
[11:01:04.056] - resolved() ...
[11:01:04.067] - resolved: FALSE
[11:01:04.067] - resolved() ... done
[11:01:04.067] resolved() for ‘MultisessionFuture’ ... done
[11:01:04.067] resolved() for ‘Future’ ...
[11:01:04.067] - state: ‘created’
[11:01:04.067] - run: TRUE
[11:01:04.067] - run() ...
[11:01:04.067] run() for ‘Future’ ...
[11:01:04.067] - state: ‘created’
[11:01:04.068] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:04.081] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:04.081] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:04.081]   - Field: ‘node’
[11:01:04.082]   - Field: ‘label’
[11:01:04.082]   - Field: ‘local’
[11:01:04.082]   - Field: ‘owner’
[11:01:04.082]   - Field: ‘envir’
[11:01:04.082]   - Field: ‘workers’
[11:01:04.082]   - Field: ‘packages’
[11:01:04.082]   - Field: ‘gc’
[11:01:04.082]   - Field: ‘conditions’
[11:01:04.082]   - Field: ‘persistent’
[11:01:04.082]   - Field: ‘expr’
[11:01:04.082]   - Field: ‘uuid’
[11:01:04.083]   - Field: ‘seed’
[11:01:04.083]   - Field: ‘version’
[11:01:04.083]   - Field: ‘result’
[11:01:04.083]   - Field: ‘asynchronous’
[11:01:04.083]   - Field: ‘calls’
[11:01:04.083]   - Field: ‘globals’
[11:01:04.083]   - Field: ‘stdout’
[11:01:04.083]   - Field: ‘earlySignal’
[11:01:04.083]   - Field: ‘lazy’
[11:01:04.083]   - Field: ‘state’
[11:01:04.083] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:04.083] - Launch lazy future ...
[11:01:04.084] Packages needed by the future expression (n = 1): ‘future’
[11:01:04.084] Packages needed by future strategies (n = 0): <none>
[11:01:04.084] {
[11:01:04.084]     {
[11:01:04.084]         {
[11:01:04.084]             ...future.startTime <- base::Sys.time()
[11:01:04.084]             {
[11:01:04.084]                 {
[11:01:04.084]                   {
[11:01:04.084]                     {
[11:01:04.084]                       {
[11:01:04.084]                         base::local({
[11:01:04.084]                           has_future <- base::requireNamespace("future", 
[11:01:04.084]                             quietly = TRUE)
[11:01:04.084]                           if (has_future) {
[11:01:04.084]                             ns <- base::getNamespace("future")
[11:01:04.084]                             version <- ns[[".package"]][["version"]]
[11:01:04.084]                             if (is.null(version)) 
[11:01:04.084]                               version <- utils::packageVersion("future")
[11:01:04.084]                           }
[11:01:04.084]                           else {
[11:01:04.084]                             version <- NULL
[11:01:04.084]                           }
[11:01:04.084]                           if (!has_future || version < "1.8.0") {
[11:01:04.084]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:04.084]                               "", base::R.version$version.string), 
[11:01:04.084]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:04.084]                                 base::R.version$platform, 8 * 
[11:01:04.084]                                   base::.Machine$sizeof.pointer), 
[11:01:04.084]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:04.084]                                 "release", "version")], collapse = " "), 
[11:01:04.084]                               hostname = base::Sys.info()[["nodename"]])
[11:01:04.084]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:04.084]                               info)
[11:01:04.084]                             info <- base::paste(info, collapse = "; ")
[11:01:04.084]                             if (!has_future) {
[11:01:04.084]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:04.084]                                 info)
[11:01:04.084]                             }
[11:01:04.084]                             else {
[11:01:04.084]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:04.084]                                 info, version)
[11:01:04.084]                             }
[11:01:04.084]                             base::stop(msg)
[11:01:04.084]                           }
[11:01:04.084]                         })
[11:01:04.084]                       }
[11:01:04.084]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:04.084]                       base::options(mc.cores = 1L)
[11:01:04.084]                     }
[11:01:04.084]                     base::local({
[11:01:04.084]                       for (pkg in "future") {
[11:01:04.084]                         base::loadNamespace(pkg)
[11:01:04.084]                         base::library(pkg, character.only = TRUE)
[11:01:04.084]                       }
[11:01:04.084]                     })
[11:01:04.084]                   }
[11:01:04.084]                   ...future.strategy.old <- future::plan("list")
[11:01:04.084]                   options(future.plan = NULL)
[11:01:04.084]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:04.084]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:04.084]                 }
[11:01:04.084]                 ...future.workdir <- getwd()
[11:01:04.084]             }
[11:01:04.084]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:04.084]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:04.084]         }
[11:01:04.084]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:04.084]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:04.084]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:04.084]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:04.084]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:04.084]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:04.084]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:04.084]             base::names(...future.oldOptions))
[11:01:04.084]     }
[11:01:04.084]     if (FALSE) {
[11:01:04.084]     }
[11:01:04.084]     else {
[11:01:04.084]         if (TRUE) {
[11:01:04.084]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:04.084]                 open = "w")
[11:01:04.084]         }
[11:01:04.084]         else {
[11:01:04.084]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:04.084]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:04.084]         }
[11:01:04.084]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:04.084]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:04.084]             base::sink(type = "output", split = FALSE)
[11:01:04.084]             base::close(...future.stdout)
[11:01:04.084]         }, add = TRUE)
[11:01:04.084]     }
[11:01:04.084]     ...future.frame <- base::sys.nframe()
[11:01:04.084]     ...future.conditions <- base::list()
[11:01:04.084]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:04.084]     if (FALSE) {
[11:01:04.084]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:04.084]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:04.084]     }
[11:01:04.084]     ...future.result <- base::tryCatch({
[11:01:04.084]         base::withCallingHandlers({
[11:01:04.084]             ...future.value <- base::withVisible(base::local({
[11:01:04.084]                 ...future.makeSendCondition <- base::local({
[11:01:04.084]                   sendCondition <- NULL
[11:01:04.084]                   function(frame = 1L) {
[11:01:04.084]                     if (is.function(sendCondition)) 
[11:01:04.084]                       return(sendCondition)
[11:01:04.084]                     ns <- getNamespace("parallel")
[11:01:04.084]                     if (exists("sendData", mode = "function", 
[11:01:04.084]                       envir = ns)) {
[11:01:04.084]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:04.084]                         envir = ns)
[11:01:04.084]                       envir <- sys.frame(frame)
[11:01:04.084]                       master <- NULL
[11:01:04.084]                       while (!identical(envir, .GlobalEnv) && 
[11:01:04.084]                         !identical(envir, emptyenv())) {
[11:01:04.084]                         if (exists("master", mode = "list", envir = envir, 
[11:01:04.084]                           inherits = FALSE)) {
[11:01:04.084]                           master <- get("master", mode = "list", 
[11:01:04.084]                             envir = envir, inherits = FALSE)
[11:01:04.084]                           if (inherits(master, c("SOCKnode", 
[11:01:04.084]                             "SOCK0node"))) {
[11:01:04.084]                             sendCondition <<- function(cond) {
[11:01:04.084]                               data <- list(type = "VALUE", value = cond, 
[11:01:04.084]                                 success = TRUE)
[11:01:04.084]                               parallel_sendData(master, data)
[11:01:04.084]                             }
[11:01:04.084]                             return(sendCondition)
[11:01:04.084]                           }
[11:01:04.084]                         }
[11:01:04.084]                         frame <- frame + 1L
[11:01:04.084]                         envir <- sys.frame(frame)
[11:01:04.084]                       }
[11:01:04.084]                     }
[11:01:04.084]                     sendCondition <<- function(cond) NULL
[11:01:04.084]                   }
[11:01:04.084]                 })
[11:01:04.084]                 withCallingHandlers({
[11:01:04.084]                   {
[11:01:04.084]                     message(sprintf("Calculating tile #%d of %d ...", 
[11:01:04.084]                       ii, n), appendLF = FALSE)
[11:01:04.084]                     fit <- mandelbrot(C)
[11:01:04.084]                     delay(fit)
[11:01:04.084]                     message(" done")
[11:01:04.084]                     fit
[11:01:04.084]                   }
[11:01:04.084]                 }, immediateCondition = function(cond) {
[11:01:04.084]                   sendCondition <- ...future.makeSendCondition()
[11:01:04.084]                   sendCondition(cond)
[11:01:04.084]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:04.084]                   {
[11:01:04.084]                     inherits <- base::inherits
[11:01:04.084]                     invokeRestart <- base::invokeRestart
[11:01:04.084]                     is.null <- base::is.null
[11:01:04.084]                     muffled <- FALSE
[11:01:04.084]                     if (inherits(cond, "message")) {
[11:01:04.084]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:04.084]                       if (muffled) 
[11:01:04.084]                         invokeRestart("muffleMessage")
[11:01:04.084]                     }
[11:01:04.084]                     else if (inherits(cond, "warning")) {
[11:01:04.084]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:04.084]                       if (muffled) 
[11:01:04.084]                         invokeRestart("muffleWarning")
[11:01:04.084]                     }
[11:01:04.084]                     else if (inherits(cond, "condition")) {
[11:01:04.084]                       if (!is.null(pattern)) {
[11:01:04.084]                         computeRestarts <- base::computeRestarts
[11:01:04.084]                         grepl <- base::grepl
[11:01:04.084]                         restarts <- computeRestarts(cond)
[11:01:04.084]                         for (restart in restarts) {
[11:01:04.084]                           name <- restart$name
[11:01:04.084]                           if (is.null(name)) 
[11:01:04.084]                             next
[11:01:04.084]                           if (!grepl(pattern, name)) 
[11:01:04.084]                             next
[11:01:04.084]                           invokeRestart(restart)
[11:01:04.084]                           muffled <- TRUE
[11:01:04.084]                           break
[11:01:04.084]                         }
[11:01:04.084]                       }
[11:01:04.084]                     }
[11:01:04.084]                     invisible(muffled)
[11:01:04.084]                   }
[11:01:04.084]                   muffleCondition(cond)
[11:01:04.084]                 })
[11:01:04.084]             }))
[11:01:04.084]             future::FutureResult(value = ...future.value$value, 
[11:01:04.084]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:04.084]                   ...future.rng), globalenv = if (FALSE) 
[11:01:04.084]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:04.084]                     ...future.globalenv.names))
[11:01:04.084]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:04.084]         }, condition = base::local({
[11:01:04.084]             c <- base::c
[11:01:04.084]             inherits <- base::inherits
[11:01:04.084]             invokeRestart <- base::invokeRestart
[11:01:04.084]             length <- base::length
[11:01:04.084]             list <- base::list
[11:01:04.084]             seq.int <- base::seq.int
[11:01:04.084]             signalCondition <- base::signalCondition
[11:01:04.084]             sys.calls <- base::sys.calls
[11:01:04.084]             `[[` <- base::`[[`
[11:01:04.084]             `+` <- base::`+`
[11:01:04.084]             `<<-` <- base::`<<-`
[11:01:04.084]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:04.084]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:04.084]                   3L)]
[11:01:04.084]             }
[11:01:04.084]             function(cond) {
[11:01:04.084]                 is_error <- inherits(cond, "error")
[11:01:04.084]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:04.084]                   NULL)
[11:01:04.084]                 if (is_error) {
[11:01:04.084]                   sessionInformation <- function() {
[11:01:04.084]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:04.084]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:04.084]                       search = base::search(), system = base::Sys.info())
[11:01:04.084]                   }
[11:01:04.084]                   ...future.conditions[[length(...future.conditions) + 
[11:01:04.084]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:04.084]                     cond$call), session = sessionInformation(), 
[11:01:04.084]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:04.084]                   signalCondition(cond)
[11:01:04.084]                 }
[11:01:04.084]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:04.084]                 "immediateCondition"))) {
[11:01:04.084]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:04.084]                   ...future.conditions[[length(...future.conditions) + 
[11:01:04.084]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:04.084]                   if (TRUE && !signal) {
[11:01:04.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:04.084]                     {
[11:01:04.084]                       inherits <- base::inherits
[11:01:04.084]                       invokeRestart <- base::invokeRestart
[11:01:04.084]                       is.null <- base::is.null
[11:01:04.084]                       muffled <- FALSE
[11:01:04.084]                       if (inherits(cond, "message")) {
[11:01:04.084]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:04.084]                         if (muffled) 
[11:01:04.084]                           invokeRestart("muffleMessage")
[11:01:04.084]                       }
[11:01:04.084]                       else if (inherits(cond, "warning")) {
[11:01:04.084]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:04.084]                         if (muffled) 
[11:01:04.084]                           invokeRestart("muffleWarning")
[11:01:04.084]                       }
[11:01:04.084]                       else if (inherits(cond, "condition")) {
[11:01:04.084]                         if (!is.null(pattern)) {
[11:01:04.084]                           computeRestarts <- base::computeRestarts
[11:01:04.084]                           grepl <- base::grepl
[11:01:04.084]                           restarts <- computeRestarts(cond)
[11:01:04.084]                           for (restart in restarts) {
[11:01:04.084]                             name <- restart$name
[11:01:04.084]                             if (is.null(name)) 
[11:01:04.084]                               next
[11:01:04.084]                             if (!grepl(pattern, name)) 
[11:01:04.084]                               next
[11:01:04.084]                             invokeRestart(restart)
[11:01:04.084]                             muffled <- TRUE
[11:01:04.084]                             break
[11:01:04.084]                           }
[11:01:04.084]                         }
[11:01:04.084]                       }
[11:01:04.084]                       invisible(muffled)
[11:01:04.084]                     }
[11:01:04.084]                     muffleCondition(cond, pattern = "^muffle")
[11:01:04.084]                   }
[11:01:04.084]                 }
[11:01:04.084]                 else {
[11:01:04.084]                   if (TRUE) {
[11:01:04.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:04.084]                     {
[11:01:04.084]                       inherits <- base::inherits
[11:01:04.084]                       invokeRestart <- base::invokeRestart
[11:01:04.084]                       is.null <- base::is.null
[11:01:04.084]                       muffled <- FALSE
[11:01:04.084]                       if (inherits(cond, "message")) {
[11:01:04.084]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:04.084]                         if (muffled) 
[11:01:04.084]                           invokeRestart("muffleMessage")
[11:01:04.084]                       }
[11:01:04.084]                       else if (inherits(cond, "warning")) {
[11:01:04.084]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:04.084]                         if (muffled) 
[11:01:04.084]                           invokeRestart("muffleWarning")
[11:01:04.084]                       }
[11:01:04.084]                       else if (inherits(cond, "condition")) {
[11:01:04.084]                         if (!is.null(pattern)) {
[11:01:04.084]                           computeRestarts <- base::computeRestarts
[11:01:04.084]                           grepl <- base::grepl
[11:01:04.084]                           restarts <- computeRestarts(cond)
[11:01:04.084]                           for (restart in restarts) {
[11:01:04.084]                             name <- restart$name
[11:01:04.084]                             if (is.null(name)) 
[11:01:04.084]                               next
[11:01:04.084]                             if (!grepl(pattern, name)) 
[11:01:04.084]                               next
[11:01:04.084]                             invokeRestart(restart)
[11:01:04.084]                             muffled <- TRUE
[11:01:04.084]                             break
[11:01:04.084]                           }
[11:01:04.084]                         }
[11:01:04.084]                       }
[11:01:04.084]                       invisible(muffled)
[11:01:04.084]                     }
[11:01:04.084]                     muffleCondition(cond, pattern = "^muffle")
[11:01:04.084]                   }
[11:01:04.084]                 }
[11:01:04.084]             }
[11:01:04.084]         }))
[11:01:04.084]     }, error = function(ex) {
[11:01:04.084]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:04.084]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:04.084]                 ...future.rng), started = ...future.startTime, 
[11:01:04.084]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:04.084]             version = "1.8"), class = "FutureResult")
[11:01:04.084]     }, finally = {
[11:01:04.084]         if (!identical(...future.workdir, getwd())) 
[11:01:04.084]             setwd(...future.workdir)
[11:01:04.084]         {
[11:01:04.084]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:04.084]                 ...future.oldOptions$nwarnings <- NULL
[11:01:04.084]             }
[11:01:04.084]             base::options(...future.oldOptions)
[11:01:04.084]             if (.Platform$OS.type == "windows") {
[11:01:04.084]                 old_names <- names(...future.oldEnvVars)
[11:01:04.084]                 envs <- base::Sys.getenv()
[11:01:04.084]                 names <- names(envs)
[11:01:04.084]                 common <- intersect(names, old_names)
[11:01:04.084]                 added <- setdiff(names, old_names)
[11:01:04.084]                 removed <- setdiff(old_names, names)
[11:01:04.084]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:04.084]                   envs[common]]
[11:01:04.084]                 NAMES <- toupper(changed)
[11:01:04.084]                 args <- list()
[11:01:04.084]                 for (kk in seq_along(NAMES)) {
[11:01:04.084]                   name <- changed[[kk]]
[11:01:04.084]                   NAME <- NAMES[[kk]]
[11:01:04.084]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:04.084]                     next
[11:01:04.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:04.084]                 }
[11:01:04.084]                 NAMES <- toupper(added)
[11:01:04.084]                 for (kk in seq_along(NAMES)) {
[11:01:04.084]                   name <- added[[kk]]
[11:01:04.084]                   NAME <- NAMES[[kk]]
[11:01:04.084]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:04.084]                     next
[11:01:04.084]                   args[[name]] <- ""
[11:01:04.084]                 }
[11:01:04.084]                 NAMES <- toupper(removed)
[11:01:04.084]                 for (kk in seq_along(NAMES)) {
[11:01:04.084]                   name <- removed[[kk]]
[11:01:04.084]                   NAME <- NAMES[[kk]]
[11:01:04.084]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:04.084]                     next
[11:01:04.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:04.084]                 }
[11:01:04.084]                 if (length(args) > 0) 
[11:01:04.084]                   base::do.call(base::Sys.setenv, args = args)
[11:01:04.084]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:04.084]             }
[11:01:04.084]             else {
[11:01:04.084]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:04.084]             }
[11:01:04.084]             {
[11:01:04.084]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:04.084]                   0L) {
[11:01:04.084]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:04.084]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:04.084]                   base::options(opts)
[11:01:04.084]                 }
[11:01:04.084]                 {
[11:01:04.084]                   {
[11:01:04.084]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:04.084]                     NULL
[11:01:04.084]                   }
[11:01:04.084]                   options(future.plan = NULL)
[11:01:04.084]                   if (is.na(NA_character_)) 
[11:01:04.084]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:04.084]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:04.084]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:04.084]                     .init = FALSE)
[11:01:04.084]                 }
[11:01:04.084]             }
[11:01:04.084]         }
[11:01:04.084]     })
[11:01:04.084]     if (TRUE) {
[11:01:04.084]         base::sink(type = "output", split = FALSE)
[11:01:04.084]         if (TRUE) {
[11:01:04.084]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:04.084]         }
[11:01:04.084]         else {
[11:01:04.084]             ...future.result["stdout"] <- base::list(NULL)
[11:01:04.084]         }
[11:01:04.084]         base::close(...future.stdout)
[11:01:04.084]         ...future.stdout <- NULL
[11:01:04.084]     }
[11:01:04.084]     ...future.result$conditions <- ...future.conditions
[11:01:04.084]     ...future.result$finished <- base::Sys.time()
[11:01:04.084]     ...future.result
[11:01:04.084] }
[11:01:04.087] Poll #1 (0): usedNodes() = 2, workers = 2
[11:01:04.105] receiveMessageFromWorker() for ClusterFuture ...
[11:01:04.105] - Validating connection of MultisessionFuture
[11:01:04.106] - received message: FutureResult
[11:01:04.106] - Received FutureResult
[11:01:04.106] - Erased future from FutureRegistry
[11:01:04.106] result() for ClusterFuture ...
[11:01:04.106] - result already collected: FutureResult
[11:01:04.106] result() for ClusterFuture ... done
[11:01:04.106] signalConditions() ...
[11:01:04.106]  - include = ‘immediateCondition’
[11:01:04.106]  - exclude = 
[11:01:04.106]  - resignal = FALSE
[11:01:04.107]  - Number of conditions: 2
[11:01:04.107] signalConditions() ... done
[11:01:04.107] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:04.107] result() for ClusterFuture ...
[11:01:04.107] - result already collected: FutureResult
[11:01:04.107] result() for ClusterFuture ... done
[11:01:04.107] result() for ClusterFuture ...
[11:01:04.107] - result already collected: FutureResult
[11:01:04.107] result() for ClusterFuture ... done
[11:01:04.107] signalConditions() ...
[11:01:04.107]  - include = ‘immediateCondition’
[11:01:04.107]  - exclude = 
[11:01:04.108]  - resignal = FALSE
[11:01:04.108]  - Number of conditions: 2
[11:01:04.108] signalConditions() ... done
[11:01:04.108] Exporting 4 global objects (57.67 KiB) to cluster node #2 ...
[11:01:04.109] Exporting ‘ii’ (35 bytes) to cluster node #2 ...
[11:01:04.109] Exporting ‘ii’ (35 bytes) to cluster node #2 ... DONE
[11:01:04.109] Exporting ‘n’ (35 bytes) to cluster node #2 ...
[11:01:04.109] Exporting ‘n’ (35 bytes) to cluster node #2 ... DONE
[11:01:04.110] Exporting ‘C’ (10.00 KiB) to cluster node #2 ...
[11:01:04.151] Exporting ‘C’ (10.00 KiB) to cluster node #2 ... DONE
[11:01:04.151] Exporting ‘delay’ (47.33 KiB) to cluster node #2 ...
[11:01:04.192] Exporting ‘delay’ (47.33 KiB) to cluster node #2 ... DONE
[11:01:04.192] Exporting 4 global objects (57.67 KiB) to cluster node #2 ... DONE
[11:01:04.193] MultisessionFuture started
[11:01:04.193] - Launch lazy future ... done
[11:01:04.193] run() for ‘MultisessionFuture’ ... done
[11:01:04.193] - run() ... done
[11:01:04.193] - resolved() ...
[11:01:04.204] - resolved: FALSE
[11:01:04.204] - resolved() ... done
[11:01:04.204] resolved() for ‘MultisessionFuture’ ... done
Plotting tile #1 of 4 ...
[11:01:04.204] result() for ClusterFuture ...
[11:01:04.204] - result already collected: FutureResult
[11:01:04.204] result() for ClusterFuture ... done
[11:01:04.204] result() for ClusterFuture ...
[11:01:04.205] - result already collected: FutureResult
[11:01:04.205] result() for ClusterFuture ... done
[11:01:04.205] signalConditions() ...
[11:01:04.205]  - include = ‘immediateCondition’
[11:01:04.205]  - exclude = 
[11:01:04.205]  - resignal = FALSE
[11:01:04.205]  - Number of conditions: 2
[11:01:04.205] signalConditions() ... done
[11:01:04.205] Future state: ‘finished’
[11:01:04.205] result() for ClusterFuture ...
[11:01:04.205] - result already collected: FutureResult
[11:01:04.205] result() for ClusterFuture ... done
[11:01:04.206] signalConditions() ...
[11:01:04.206]  - include = ‘condition’
[11:01:04.206]  - exclude = ‘immediateCondition’
[11:01:04.206]  - resignal = TRUE
[11:01:04.206]  - Number of conditions: 2
[11:01:04.206]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[11:01:04.206]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[11:01:04.206] signalConditions() ... done
Plotting tile #2 of 4 ...
[11:01:04.207] result() for ClusterFuture ...
[11:01:04.207] - result already collected: FutureResult
[11:01:04.207] result() for ClusterFuture ... done
[11:01:04.207] result() for ClusterFuture ...
[11:01:04.207] - result already collected: FutureResult
[11:01:04.207] result() for ClusterFuture ... done
[11:01:04.207] signalConditions() ...
[11:01:04.207]  - include = ‘immediateCondition’
[11:01:04.207]  - exclude = 
[11:01:04.208]  - resignal = FALSE
[11:01:04.208]  - Number of conditions: 2
[11:01:04.208] signalConditions() ... done
[11:01:04.208] Future state: ‘finished’
[11:01:04.208] result() for ClusterFuture ...
[11:01:04.208] - result already collected: FutureResult
[11:01:04.208] result() for ClusterFuture ... done
[11:01:04.208] signalConditions() ...
[11:01:04.208]  - include = ‘condition’
[11:01:04.208]  - exclude = ‘immediateCondition’
[11:01:04.208]  - resignal = TRUE
[11:01:04.208]  - Number of conditions: 2
[11:01:04.209]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[11:01:04.209]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[11:01:04.209] signalConditions() ... done
[11:01:04.210] receiveMessageFromWorker() for ClusterFuture ...
[11:01:04.210] - Validating connection of MultisessionFuture
[11:01:04.210] - received message: FutureResult
[11:01:04.210] - Received FutureResult
[11:01:04.210] - Erased future from FutureRegistry
[11:01:04.210] result() for ClusterFuture ...
[11:01:04.210] - result already collected: FutureResult
[11:01:04.211] result() for ClusterFuture ... done
[11:01:04.211] signalConditions() ...
[11:01:04.211]  - include = ‘immediateCondition’
[11:01:04.211]  - exclude = 
[11:01:04.211]  - resignal = FALSE
[11:01:04.211]  - Number of conditions: 2
[11:01:04.211] signalConditions() ... done
[11:01:04.211] receiveMessageFromWorker() for ClusterFuture ... done
Plotting tile #3 of 4 ...
[11:01:04.211] result() for ClusterFuture ...
[11:01:04.211] - result already collected: FutureResult
[11:01:04.211] result() for ClusterFuture ... done
[11:01:04.211] result() for ClusterFuture ...
[11:01:04.212] - result already collected: FutureResult
[11:01:04.212] result() for ClusterFuture ... done
[11:01:04.212] signalConditions() ...
[11:01:04.212]  - include = ‘immediateCondition’
[11:01:04.212]  - exclude = 
[11:01:04.212]  - resignal = FALSE
[11:01:04.212]  - Number of conditions: 2
[11:01:04.212] signalConditions() ... done
[11:01:04.212] Future state: ‘finished’
[11:01:04.212] result() for ClusterFuture ...
[11:01:04.212] - result already collected: FutureResult
[11:01:04.212] result() for ClusterFuture ... done
[11:01:04.212] signalConditions() ...
[11:01:04.213]  - include = ‘condition’
[11:01:04.213]  - exclude = ‘immediateCondition’
[11:01:04.213]  - resignal = TRUE
[11:01:04.213]  - Number of conditions: 2
[11:01:04.213]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[11:01:04.213]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[11:01:04.213] signalConditions() ... done
[11:01:04.251] receiveMessageFromWorker() for ClusterFuture ...
[11:01:04.251] - Validating connection of MultisessionFuture
[11:01:04.251] - received message: FutureResult
[11:01:04.251] - Received FutureResult
[11:01:04.251] - Erased future from FutureRegistry
[11:01:04.252] result() for ClusterFuture ...
[11:01:04.252] - result already collected: FutureResult
[11:01:04.252] result() for ClusterFuture ... done
[11:01:04.252] signalConditions() ...
[11:01:04.252]  - include = ‘immediateCondition’
[11:01:04.252]  - exclude = 
[11:01:04.252]  - resignal = FALSE
[11:01:04.252]  - Number of conditions: 2
[11:01:04.252] signalConditions() ... done
[11:01:04.252] receiveMessageFromWorker() for ClusterFuture ... done
Plotting tile #4 of 4 ...
[11:01:04.252] result() for ClusterFuture ...
[11:01:04.252] - result already collected: FutureResult
[11:01:04.253] result() for ClusterFuture ... done
[11:01:04.253] result() for ClusterFuture ...
[11:01:04.253] - result already collected: FutureResult
[11:01:04.253] result() for ClusterFuture ... done
[11:01:04.253] signalConditions() ...
[11:01:04.253]  - include = ‘immediateCondition’
[11:01:04.253]  - exclude = 
[11:01:04.253]  - resignal = FALSE
[11:01:04.253]  - Number of conditions: 2
[11:01:04.253] signalConditions() ... done
[11:01:04.253] Future state: ‘finished’
[11:01:04.253] result() for ClusterFuture ...
[11:01:04.254] - result already collected: FutureResult
[11:01:04.254] result() for ClusterFuture ... done
[11:01:04.254] signalConditions() ...
[11:01:04.254]  - include = ‘condition’
[11:01:04.254]  - exclude = ‘immediateCondition’
[11:01:04.254]  - resignal = TRUE
[11:01:04.254]  - Number of conditions: 2
[11:01:04.254]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[11:01:04.254]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[11:01:04.254] signalConditions() ... done

> close.screen()
 [1]  1  2  3  4  5  6  7  8  9 10 11 12

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('multisession') ... DONE
Testing with 2 cores ... DONE
> message("*** Mandelbrot demo of the 'future' package ... DONE")
*** Mandelbrot demo of the 'future' package ... DONE
> 
> message("*** Demos ... DONE")
*** Demos ... DONE
> 
> source("incl/end.R")
[11:01:04.256] plan(): Setting new future strategy stack:
[11:01:04.256] List of future strategies:
[11:01:04.256] 1. sequential:
[11:01:04.256]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:04.256]    - tweaked: FALSE
[11:01:04.256]    - call: future::plan("sequential")
[11:01:04.257] plan(): nbrOfWorkers() = 1
> 
