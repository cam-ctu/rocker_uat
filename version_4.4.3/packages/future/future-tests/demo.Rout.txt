
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[08:27:21.306] plan(): Setting new future strategy stack:
[08:27:21.306] List of future strategies:
[08:27:21.306] 1. sequential:
[08:27:21.306]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:21.306]    - tweaked: FALSE
[08:27:21.306]    - call: future::plan("sequential")
[08:27:21.321] plan(): nbrOfWorkers() = 1
> 
> message("*** Demos ...")
*** Demos ...
> 
> message("*** Fibonacci demo of the 'future' package ...")
*** Fibonacci demo of the 'future' package ...
> demo("fibonacci", package = "future", ask = FALSE)


	demo(fibonacci)
	---- ~~~~~~~~~

> library("future")

> library("listenv")

> ## IMPORTANT:
> ## 1. The below usage of lazy futures will only work when they are
> ##    all evaluated in the same process.
> ## 2. We disable the capturing of standard output (stdout=NA) to avoid
> ##    'sink stack is full' errors
> ## 3. We disable the capturing of most conditions (condition="error") to
> ##    avoid stacking up too many conditions
> oplan <- plan(sequential)
[08:27:21.343] plan(): Setting new future strategy stack:
[08:27:21.343] List of future strategies:
[08:27:21.343] 1. sequential:
[08:27:21.343]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:21.343]    - tweaked: FALSE
[08:27:21.343]    - call: plan(sequential)
[08:27:21.355] plan(): nbrOfWorkers() = 1

> ## Defines the first 100 Fibonacci numbers
> ## (0, 1, 1, 2, 3, 5, 8, ...)
> ## but calculate only the ones need when
> ## a number is actually requested.
> 
> x <- listenv()

> x[[1]] <- 0

> x[[2]] <- 1

> for (i in 3:100) {
+   x[[i]] %<-% { x[[i - 2]] + x[[i - 1]] } %lazy% TRUE %stdout% NA %conditions% "error"
+ }
[08:27:21.361] getGlobalsAndPackages() ...
[08:27:21.362] Searching for globals...
[08:27:21.371] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.371] Searching for globals ... DONE
[08:27:21.371] Resolving globals: FALSE
[08:27:21.372] The total size of the 2 globals is 721 bytes (721 bytes)
[08:27:21.373] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 721 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (686 bytes of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.373] - globals: [2] ‘x’, ‘i’
[08:27:21.373] 
[08:27:21.373] getGlobalsAndPackages() ... DONE
[08:27:21.374] getGlobalsAndPackages() ...
[08:27:21.374] Searching for globals...
[08:27:21.375] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.376] Searching for globals ... DONE
[08:27:21.376] Resolving globals: FALSE
[08:27:21.376] The total size of the 2 globals is 33.37 KiB (34170 bytes)
[08:27:21.377] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 33.37 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (33.33 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.377] - globals: [2] ‘x’, ‘i’
[08:27:21.377] 
[08:27:21.377] getGlobalsAndPackages() ... DONE
[08:27:21.377] getGlobalsAndPackages() ...
[08:27:21.377] Searching for globals...
[08:27:21.379] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.379] Searching for globals ... DONE
[08:27:21.379] Resolving globals: FALSE
[08:27:21.380] The total size of the 2 globals is 52.40 KiB (53658 bytes)
[08:27:21.380] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 52.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (52.37 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.380] - globals: [2] ‘x’, ‘i’
[08:27:21.380] 
[08:27:21.380] getGlobalsAndPackages() ... DONE
[08:27:21.381] getGlobalsAndPackages() ...
[08:27:21.381] Searching for globals...
[08:27:21.383] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.383] Searching for globals ... DONE
[08:27:21.383] Resolving globals: FALSE
[08:27:21.383] The total size of the 2 globals is 71.43 KiB (73146 bytes)
[08:27:21.384] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 71.43 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (71.40 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.384] - globals: [2] ‘x’, ‘i’
[08:27:21.384] 
[08:27:21.384] getGlobalsAndPackages() ... DONE
[08:27:21.385] getGlobalsAndPackages() ...
[08:27:21.385] Searching for globals...
[08:27:21.386] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.386] Searching for globals ... DONE
[08:27:21.386] Resolving globals: FALSE
[08:27:21.387] The total size of the 2 globals is 90.46 KiB (92634 bytes)
[08:27:21.387] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 90.46 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (90.43 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.388] - globals: [2] ‘x’, ‘i’
[08:27:21.388] 
[08:27:21.388] getGlobalsAndPackages() ... DONE
[08:27:21.388] getGlobalsAndPackages() ...
[08:27:21.388] Searching for globals...
[08:27:21.390] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.390] Searching for globals ... DONE
[08:27:21.390] Resolving globals: FALSE
[08:27:21.391] The total size of the 2 globals is 109.49 KiB (112122 bytes)
[08:27:21.391] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 109.49 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (109.46 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.391] - globals: [2] ‘x’, ‘i’
[08:27:21.391] 
[08:27:21.391] getGlobalsAndPackages() ... DONE
[08:27:21.392] getGlobalsAndPackages() ...
[08:27:21.392] Searching for globals...
[08:27:21.393] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.394] Searching for globals ... DONE
[08:27:21.394] Resolving globals: FALSE
[08:27:21.396] The total size of the 2 globals is 128.53 KiB (131610 bytes)
[08:27:21.397] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 128.53 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (128.49 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.397] - globals: [2] ‘x’, ‘i’
[08:27:21.397] 
[08:27:21.397] getGlobalsAndPackages() ... DONE
[08:27:21.398] getGlobalsAndPackages() ...
[08:27:21.398] Searching for globals...
[08:27:21.399] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.399] Searching for globals ... DONE
[08:27:21.399] Resolving globals: FALSE
[08:27:21.400] The total size of the 2 globals is 147.56 KiB (151100 bytes)
[08:27:21.401] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 147.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (147.52 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.401] - globals: [2] ‘x’, ‘i’
[08:27:21.401] 
[08:27:21.401] getGlobalsAndPackages() ... DONE
[08:27:21.402] getGlobalsAndPackages() ...
[08:27:21.402] Searching for globals...
[08:27:21.403] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.403] Searching for globals ... DONE
[08:27:21.403] Resolving globals: FALSE
[08:27:21.404] The total size of the 2 globals is 166.59 KiB (170593 bytes)
[08:27:21.405] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 166.59 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (166.56 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.405] - globals: [2] ‘x’, ‘i’
[08:27:21.405] 
[08:27:21.405] getGlobalsAndPackages() ... DONE
[08:27:21.405] getGlobalsAndPackages() ...
[08:27:21.406] Searching for globals...
[08:27:21.407] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.407] Searching for globals ... DONE
[08:27:21.407] Resolving globals: FALSE
[08:27:21.408] The total size of the 2 globals is 185.63 KiB (190086 bytes)
[08:27:21.409] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 185.63 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (185.60 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.409] - globals: [2] ‘x’, ‘i’
[08:27:21.409] 
[08:27:21.409] getGlobalsAndPackages() ... DONE
[08:27:21.409] getGlobalsAndPackages() ...
[08:27:21.410] Searching for globals...
[08:27:21.411] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.411] Searching for globals ... DONE
[08:27:21.411] Resolving globals: FALSE
[08:27:21.412] The total size of the 2 globals is 204.67 KiB (209579 bytes)
[08:27:21.413] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 204.67 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (204.63 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.413] - globals: [2] ‘x’, ‘i’
[08:27:21.413] 
[08:27:21.413] getGlobalsAndPackages() ... DONE
[08:27:21.414] getGlobalsAndPackages() ...
[08:27:21.414] Searching for globals...
[08:27:21.415] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.415] Searching for globals ... DONE
[08:27:21.415] Resolving globals: FALSE
[08:27:21.417] The total size of the 2 globals is 223.73 KiB (229096 bytes)
[08:27:21.417] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 223.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (223.69 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.417] - globals: [2] ‘x’, ‘i’
[08:27:21.417] 
[08:27:21.417] getGlobalsAndPackages() ... DONE
[08:27:21.418] getGlobalsAndPackages() ...
[08:27:21.418] Searching for globals...
[08:27:21.419] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.420] Searching for globals ... DONE
[08:27:21.420] Resolving globals: FALSE
[08:27:21.421] The total size of the 2 globals is 242.76 KiB (248589 bytes)
[08:27:21.422] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 242.76 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (242.73 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.422] - globals: [2] ‘x’, ‘i’
[08:27:21.422] 
[08:27:21.422] getGlobalsAndPackages() ... DONE
[08:27:21.424] getGlobalsAndPackages() ...
[08:27:21.424] Searching for globals...
[08:27:21.426] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.426] Searching for globals ... DONE
[08:27:21.426] Resolving globals: FALSE
[08:27:21.427] The total size of the 2 globals is 261.80 KiB (268082 bytes)
[08:27:21.428] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 261.80 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (261.76 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.428] - globals: [2] ‘x’, ‘i’
[08:27:21.428] 
[08:27:21.428] getGlobalsAndPackages() ... DONE
[08:27:21.428] getGlobalsAndPackages() ...
[08:27:21.429] Searching for globals...
[08:27:21.430] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.430] Searching for globals ... DONE
[08:27:21.430] Resolving globals: FALSE
[08:27:21.432] The total size of the 2 globals is 280.83 KiB (287575 bytes)
[08:27:21.432] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 280.83 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (280.80 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.432] - globals: [2] ‘x’, ‘i’
[08:27:21.432] 
[08:27:21.432] getGlobalsAndPackages() ... DONE
[08:27:21.433] getGlobalsAndPackages() ...
[08:27:21.433] Searching for globals...
[08:27:21.434] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.435] Searching for globals ... DONE
[08:27:21.435] Resolving globals: FALSE
[08:27:21.436] The total size of the 2 globals is 299.87 KiB (307068 bytes)
[08:27:21.437] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 299.87 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (299.84 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.437] - globals: [2] ‘x’, ‘i’
[08:27:21.437] 
[08:27:21.437] getGlobalsAndPackages() ... DONE
[08:27:21.437] getGlobalsAndPackages() ...
[08:27:21.437] Searching for globals...
[08:27:21.439] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.439] Searching for globals ... DONE
[08:27:21.439] Resolving globals: FALSE
[08:27:21.441] The total size of the 2 globals is 318.91 KiB (326561 bytes)
[08:27:21.441] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 318.91 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (318.87 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.441] - globals: [2] ‘x’, ‘i’
[08:27:21.441] 
[08:27:21.441] getGlobalsAndPackages() ... DONE
[08:27:21.442] getGlobalsAndPackages() ...
[08:27:21.442] Searching for globals...
[08:27:21.443] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.443] Searching for globals ... DONE
[08:27:21.444] Resolving globals: FALSE
[08:27:21.445] The total size of the 2 globals is 337.97 KiB (346086 bytes)
[08:27:21.446] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 337.97 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (337.94 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.446] - globals: [2] ‘x’, ‘i’
[08:27:21.446] 
[08:27:21.446] getGlobalsAndPackages() ... DONE
[08:27:21.447] getGlobalsAndPackages() ...
[08:27:21.447] Searching for globals...
[08:27:21.448] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.448] Searching for globals ... DONE
[08:27:21.448] Resolving globals: FALSE
[08:27:21.450] The total size of the 2 globals is 357.01 KiB (365579 bytes)
[08:27:21.452] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 357.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (356.98 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.452] - globals: [2] ‘x’, ‘i’
[08:27:21.453] 
[08:27:21.453] getGlobalsAndPackages() ... DONE
[08:27:21.453] getGlobalsAndPackages() ...
[08:27:21.453] Searching for globals...
[08:27:21.455] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.455] Searching for globals ... DONE
[08:27:21.455] Resolving globals: FALSE
[08:27:21.457] The total size of the 2 globals is 376.05 KiB (385072 bytes)
[08:27:21.457] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 376.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (376.01 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.457] - globals: [2] ‘x’, ‘i’
[08:27:21.457] 
[08:27:21.458] getGlobalsAndPackages() ... DONE
[08:27:21.458] getGlobalsAndPackages() ...
[08:27:21.458] Searching for globals...
[08:27:21.460] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.460] Searching for globals ... DONE
[08:27:21.460] Resolving globals: FALSE
[08:27:21.462] The total size of the 2 globals is 395.08 KiB (404565 bytes)
[08:27:21.462] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 395.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (395.05 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.462] - globals: [2] ‘x’, ‘i’
[08:27:21.462] 
[08:27:21.462] getGlobalsAndPackages() ... DONE
[08:27:21.463] getGlobalsAndPackages() ...
[08:27:21.463] Searching for globals...
[08:27:21.464] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.465] Searching for globals ... DONE
[08:27:21.465] Resolving globals: FALSE
[08:27:21.466] The total size of the 2 globals is 414.12 KiB (424058 bytes)
[08:27:21.467] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 414.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (414.08 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.467] - globals: [2] ‘x’, ‘i’
[08:27:21.467] 
[08:27:21.468] getGlobalsAndPackages() ... DONE
[08:27:21.468] getGlobalsAndPackages() ...
[08:27:21.468] Searching for globals...
[08:27:21.470] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.470] Searching for globals ... DONE
[08:27:21.470] Resolving globals: FALSE
[08:27:21.472] The total size of the 2 globals is 433.19 KiB (443587 bytes)
[08:27:21.472] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 433.19 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (433.16 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.473] - globals: [2] ‘x’, ‘i’
[08:27:21.473] 
[08:27:21.473] getGlobalsAndPackages() ... DONE
[08:27:21.473] getGlobalsAndPackages() ...
[08:27:21.473] Searching for globals...
[08:27:21.475] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.475] Searching for globals ... DONE
[08:27:21.475] Resolving globals: FALSE
[08:27:21.477] The total size of the 2 globals is 452.23 KiB (463080 bytes)
[08:27:21.478] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 452.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (452.19 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.478] - globals: [2] ‘x’, ‘i’
[08:27:21.478] 
[08:27:21.478] getGlobalsAndPackages() ... DONE
[08:27:21.478] getGlobalsAndPackages() ...
[08:27:21.479] Searching for globals...
[08:27:21.482] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.482] Searching for globals ... DONE
[08:27:21.482] Resolving globals: FALSE
[08:27:21.484] The total size of the 2 globals is 471.26 KiB (482573 bytes)
[08:27:21.484] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 471.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (471.23 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.485] - globals: [2] ‘x’, ‘i’
[08:27:21.485] 
[08:27:21.485] getGlobalsAndPackages() ... DONE
[08:27:21.485] getGlobalsAndPackages() ...
[08:27:21.485] Searching for globals...
[08:27:21.487] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.487] Searching for globals ... DONE
[08:27:21.487] Resolving globals: FALSE
[08:27:21.489] The total size of the 2 globals is 490.30 KiB (502066 bytes)
[08:27:21.490] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 490.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (490.26 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.490] - globals: [2] ‘x’, ‘i’
[08:27:21.490] 
[08:27:21.490] getGlobalsAndPackages() ... DONE
[08:27:21.490] getGlobalsAndPackages() ...
[08:27:21.490] Searching for globals...
[08:27:21.492] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.492] Searching for globals ... DONE
[08:27:21.492] Resolving globals: FALSE
[08:27:21.494] The total size of the 2 globals is 509.33 KiB (521559 bytes)
[08:27:21.495] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 509.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (509.30 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.495] - globals: [2] ‘x’, ‘i’
[08:27:21.495] 
[08:27:21.495] getGlobalsAndPackages() ... DONE
[08:27:21.495] getGlobalsAndPackages() ...
[08:27:21.496] Searching for globals...
[08:27:21.497] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.497] Searching for globals ... DONE
[08:27:21.497] Resolving globals: FALSE
[08:27:21.500] The total size of the 2 globals is 528.37 KiB (541052 bytes)
[08:27:21.500] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 528.37 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (528.34 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.500] - globals: [2] ‘x’, ‘i’
[08:27:21.500] 
[08:27:21.500] getGlobalsAndPackages() ... DONE
[08:27:21.501] getGlobalsAndPackages() ...
[08:27:21.501] Searching for globals...
[08:27:21.502] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.502] Searching for globals ... DONE
[08:27:21.503] Resolving globals: FALSE
[08:27:21.505] The total size of the 2 globals is 547.41 KiB (560545 bytes)
[08:27:21.506] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 547.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (547.37 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.506] - globals: [2] ‘x’, ‘i’
[08:27:21.506] 
[08:27:21.506] getGlobalsAndPackages() ... DONE
[08:27:21.507] getGlobalsAndPackages() ...
[08:27:21.507] Searching for globals...
[08:27:21.508] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.508] Searching for globals ... DONE
[08:27:21.508] Resolving globals: FALSE
[08:27:21.513] The total size of the 2 globals is 566.44 KiB (580038 bytes)
[08:27:21.513] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 566.44 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (566.41 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.513] - globals: [2] ‘x’, ‘i’
[08:27:21.513] 
[08:27:21.513] getGlobalsAndPackages() ... DONE
[08:27:21.514] getGlobalsAndPackages() ...
[08:27:21.514] Searching for globals...
[08:27:21.516] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.516] Searching for globals ... DONE
[08:27:21.516] Resolving globals: FALSE
[08:27:21.518] The total size of the 2 globals is 585.48 KiB (599531 bytes)
[08:27:21.519] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 585.48 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (585.45 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.519] - globals: [2] ‘x’, ‘i’
[08:27:21.519] 
[08:27:21.519] getGlobalsAndPackages() ... DONE
[08:27:21.520] getGlobalsAndPackages() ...
[08:27:21.520] Searching for globals...
[08:27:21.521] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.521] Searching for globals ... DONE
[08:27:21.521] Resolving globals: FALSE
[08:27:21.524] The total size of the 2 globals is 604.52 KiB (619024 bytes)
[08:27:21.524] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 604.52 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (604.48 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.524] - globals: [2] ‘x’, ‘i’
[08:27:21.525] 
[08:27:21.525] getGlobalsAndPackages() ... DONE
[08:27:21.525] getGlobalsAndPackages() ...
[08:27:21.525] Searching for globals...
[08:27:21.527] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.527] Searching for globals ... DONE
[08:27:21.527] Resolving globals: FALSE
[08:27:21.530] The total size of the 2 globals is 623.55 KiB (638517 bytes)
[08:27:21.530] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 623.55 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (623.52 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.530] - globals: [2] ‘x’, ‘i’
[08:27:21.530] 
[08:27:21.530] getGlobalsAndPackages() ... DONE
[08:27:21.531] getGlobalsAndPackages() ...
[08:27:21.531] Searching for globals...
[08:27:21.532] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.532] Searching for globals ... DONE
[08:27:21.532] Resolving globals: FALSE
[08:27:21.535] The total size of the 2 globals is 642.59 KiB (658010 bytes)
[08:27:21.536] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 642.59 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (642.55 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.536] - globals: [2] ‘x’, ‘i’
[08:27:21.536] 
[08:27:21.536] getGlobalsAndPackages() ... DONE
[08:27:21.537] getGlobalsAndPackages() ...
[08:27:21.537] Searching for globals...
[08:27:21.538] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.538] Searching for globals ... DONE
[08:27:21.538] Resolving globals: FALSE
[08:27:21.543] The total size of the 2 globals is 661.62 KiB (677503 bytes)
[08:27:21.543] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 661.62 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (661.59 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.544] - globals: [2] ‘x’, ‘i’
[08:27:21.544] 
[08:27:21.544] getGlobalsAndPackages() ... DONE
[08:27:21.544] getGlobalsAndPackages() ...
[08:27:21.544] Searching for globals...
[08:27:21.546] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.546] Searching for globals ... DONE
[08:27:21.546] Resolving globals: FALSE
[08:27:21.549] The total size of the 2 globals is 680.66 KiB (696996 bytes)
[08:27:21.549] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 680.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (680.63 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.549] - globals: [2] ‘x’, ‘i’
[08:27:21.550] 
[08:27:21.550] getGlobalsAndPackages() ... DONE
[08:27:21.550] getGlobalsAndPackages() ...
[08:27:21.550] Searching for globals...
[08:27:21.552] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.552] Searching for globals ... DONE
[08:27:21.552] Resolving globals: FALSE
[08:27:21.555] The total size of the 2 globals is 699.70 KiB (716489 bytes)
[08:27:21.555] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 699.70 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (699.66 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.555] - globals: [2] ‘x’, ‘i’
[08:27:21.555] 
[08:27:21.555] getGlobalsAndPackages() ... DONE
[08:27:21.556] getGlobalsAndPackages() ...
[08:27:21.556] Searching for globals...
[08:27:21.558] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.558] Searching for globals ... DONE
[08:27:21.558] Resolving globals: FALSE
[08:27:21.561] The total size of the 2 globals is 718.73 KiB (735982 bytes)
[08:27:21.561] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 718.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (718.70 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.561] - globals: [2] ‘x’, ‘i’
[08:27:21.561] 
[08:27:21.562] getGlobalsAndPackages() ... DONE
[08:27:21.562] getGlobalsAndPackages() ...
[08:27:21.562] Searching for globals...
[08:27:21.564] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.564] Searching for globals ... DONE
[08:27:21.564] Resolving globals: FALSE
[08:27:21.567] The total size of the 2 globals is 737.81 KiB (755519 bytes)
[08:27:21.568] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 737.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (737.78 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.568] - globals: [2] ‘x’, ‘i’
[08:27:21.568] 
[08:27:21.568] getGlobalsAndPackages() ... DONE
[08:27:21.568] getGlobalsAndPackages() ...
[08:27:21.568] Searching for globals...
[08:27:21.572] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.572] Searching for globals ... DONE
[08:27:21.572] Resolving globals: FALSE
[08:27:21.575] The total size of the 2 globals is 756.85 KiB (775012 bytes)
[08:27:21.575] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 756.85 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (756.81 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.576] - globals: [2] ‘x’, ‘i’
[08:27:21.576] 
[08:27:21.576] getGlobalsAndPackages() ... DONE
[08:27:21.576] getGlobalsAndPackages() ...
[08:27:21.576] Searching for globals...
[08:27:21.578] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.578] Searching for globals ... DONE
[08:27:21.578] Resolving globals: FALSE
[08:27:21.581] The total size of the 2 globals is 775.88 KiB (794505 bytes)
[08:27:21.582] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 775.88 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (775.85 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.582] - globals: [2] ‘x’, ‘i’
[08:27:21.582] 
[08:27:21.582] getGlobalsAndPackages() ... DONE
[08:27:21.582] getGlobalsAndPackages() ...
[08:27:21.583] Searching for globals...
[08:27:21.584] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.584] Searching for globals ... DONE
[08:27:21.584] Resolving globals: FALSE
[08:27:21.588] The total size of the 2 globals is 794.97 KiB (814050 bytes)
[08:27:21.588] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 794.97 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (794.94 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.588] - globals: [2] ‘x’, ‘i’
[08:27:21.588] 
[08:27:21.588] getGlobalsAndPackages() ... DONE
[08:27:21.589] getGlobalsAndPackages() ...
[08:27:21.589] Searching for globals...
[08:27:21.590] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.590] Searching for globals ... DONE
[08:27:21.591] Resolving globals: FALSE
[08:27:21.594] The total size of the 2 globals is 814.01 KiB (833543 bytes)
[08:27:21.594] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 814.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (813.97 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.594] - globals: [2] ‘x’, ‘i’
[08:27:21.594] 
[08:27:21.594] getGlobalsAndPackages() ... DONE
[08:27:21.595] getGlobalsAndPackages() ...
[08:27:21.595] Searching for globals...
[08:27:21.597] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.597] Searching for globals ... DONE
[08:27:21.597] Resolving globals: FALSE
[08:27:21.601] The total size of the 2 globals is 833.04 KiB (853036 bytes)
[08:27:21.603] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 833.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (833.01 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.603] - globals: [2] ‘x’, ‘i’
[08:27:21.603] 
[08:27:21.603] getGlobalsAndPackages() ... DONE
[08:27:21.604] getGlobalsAndPackages() ...
[08:27:21.604] Searching for globals...
[08:27:21.605] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.605] Searching for globals ... DONE
[08:27:21.606] Resolving globals: FALSE
[08:27:21.609] The total size of the 2 globals is 852.08 KiB (872529 bytes)
[08:27:21.609] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 852.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (852.04 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.610] - globals: [2] ‘x’, ‘i’
[08:27:21.610] 
[08:27:21.610] getGlobalsAndPackages() ... DONE
[08:27:21.610] getGlobalsAndPackages() ...
[08:27:21.610] Searching for globals...
[08:27:21.612] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.612] Searching for globals ... DONE
[08:27:21.612] Resolving globals: FALSE
[08:27:21.616] The total size of the 2 globals is 871.12 KiB (892022 bytes)
[08:27:21.616] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 871.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (871.08 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.616] - globals: [2] ‘x’, ‘i’
[08:27:21.616] 
[08:27:21.616] getGlobalsAndPackages() ... DONE
[08:27:21.617] getGlobalsAndPackages() ...
[08:27:21.617] Searching for globals...
[08:27:21.618] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.619] Searching for globals ... DONE
[08:27:21.619] Resolving globals: FALSE
[08:27:21.622] The total size of the 2 globals is 890.15 KiB (911515 bytes)
[08:27:21.623] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 890.15 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (890.12 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.623] - globals: [2] ‘x’, ‘i’
[08:27:21.623] 
[08:27:21.623] getGlobalsAndPackages() ... DONE
[08:27:21.623] getGlobalsAndPackages() ...
[08:27:21.624] Searching for globals...
[08:27:21.625] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.625] Searching for globals ... DONE
[08:27:21.625] Resolving globals: FALSE
[08:27:21.629] The total size of the 2 globals is 909.19 KiB (931008 bytes)
[08:27:21.629] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 909.19 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (909.15 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.629] - globals: [2] ‘x’, ‘i’
[08:27:21.630] 
[08:27:21.630] getGlobalsAndPackages() ... DONE
[08:27:21.630] getGlobalsAndPackages() ...
[08:27:21.630] Searching for globals...
[08:27:21.634] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.634] Searching for globals ... DONE
[08:27:21.634] Resolving globals: FALSE
[08:27:21.638] The total size of the 2 globals is 928.22 KiB (950501 bytes)
[08:27:21.638] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 928.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (928.19 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.638] - globals: [2] ‘x’, ‘i’
[08:27:21.638] 
[08:27:21.639] getGlobalsAndPackages() ... DONE
[08:27:21.639] getGlobalsAndPackages() ...
[08:27:21.639] Searching for globals...
[08:27:21.641] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.641] Searching for globals ... DONE
[08:27:21.641] Resolving globals: FALSE
[08:27:21.645] The total size of the 2 globals is 947.26 KiB (969994 bytes)
[08:27:21.645] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 947.26 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (947.23 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.645] - globals: [2] ‘x’, ‘i’
[08:27:21.645] 
[08:27:21.645] getGlobalsAndPackages() ... DONE
[08:27:21.646] getGlobalsAndPackages() ...
[08:27:21.646] Searching for globals...
[08:27:21.648] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.648] Searching for globals ... DONE
[08:27:21.648] Resolving globals: FALSE
[08:27:21.652] The total size of the 2 globals is 966.30 KiB (989487 bytes)
[08:27:21.652] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 966.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (966.26 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.652] - globals: [2] ‘x’, ‘i’
[08:27:21.652] 
[08:27:21.652] getGlobalsAndPackages() ... DONE
[08:27:21.653] getGlobalsAndPackages() ...
[08:27:21.653] Searching for globals...
[08:27:21.654] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.655] Searching for globals ... DONE
[08:27:21.655] Resolving globals: FALSE
[08:27:21.658] The total size of the 2 globals is 985.33 KiB (1008980 bytes)
[08:27:21.659] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 985.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (985.30 KiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.659] - globals: [2] ‘x’, ‘i’
[08:27:21.659] 
[08:27:21.659] getGlobalsAndPackages() ... DONE
[08:27:21.660] getGlobalsAndPackages() ...
[08:27:21.660] Searching for globals...
[08:27:21.663] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.663] Searching for globals ... DONE
[08:27:21.663] Resolving globals: FALSE
[08:27:21.667] The total size of the 2 globals is 0.98 MiB (1028473 bytes)
[08:27:21.668] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 0.98 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (0.98 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.668] - globals: [2] ‘x’, ‘i’
[08:27:21.668] 
[08:27:21.668] getGlobalsAndPackages() ... DONE
[08:27:21.669] getGlobalsAndPackages() ...
[08:27:21.669] Searching for globals...
[08:27:21.670] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.670] Searching for globals ... DONE
[08:27:21.670] Resolving globals: FALSE
[08:27:21.675] The total size of the 2 globals is 1.00 MiB (1047966 bytes)
[08:27:21.675] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.00 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.00 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.675] - globals: [2] ‘x’, ‘i’
[08:27:21.675] 
[08:27:21.675] getGlobalsAndPackages() ... DONE
[08:27:21.676] getGlobalsAndPackages() ...
[08:27:21.676] Searching for globals...
[08:27:21.677] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.678] Searching for globals ... DONE
[08:27:21.678] Resolving globals: FALSE
[08:27:21.682] The total size of the 2 globals is 1.02 MiB (1067459 bytes)
[08:27:21.682] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.02 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.02 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.682] - globals: [2] ‘x’, ‘i’
[08:27:21.682] 
[08:27:21.682] getGlobalsAndPackages() ... DONE
[08:27:21.683] getGlobalsAndPackages() ...
[08:27:21.683] Searching for globals...
[08:27:21.685] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.685] Searching for globals ... DONE
[08:27:21.685] Resolving globals: FALSE
[08:27:21.689] The total size of the 2 globals is 1.04 MiB (1086952 bytes)
[08:27:21.690] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.04 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.04 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.690] - globals: [2] ‘x’, ‘i’
[08:27:21.690] 
[08:27:21.690] getGlobalsAndPackages() ... DONE
[08:27:21.690] getGlobalsAndPackages() ...
[08:27:21.691] Searching for globals...
[08:27:21.692] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.694] Searching for globals ... DONE
[08:27:21.694] Resolving globals: FALSE
[08:27:21.699] The total size of the 2 globals is 1.06 MiB (1106445 bytes)
[08:27:21.699] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.06 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.06 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.699] - globals: [2] ‘x’, ‘i’
[08:27:21.699] 
[08:27:21.699] getGlobalsAndPackages() ... DONE
[08:27:21.700] getGlobalsAndPackages() ...
[08:27:21.700] Searching for globals...
[08:27:21.701] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.702] Searching for globals ... DONE
[08:27:21.702] Resolving globals: FALSE
[08:27:21.706] The total size of the 2 globals is 1.07 MiB (1125938 bytes)
[08:27:21.706] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.07 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.07 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.707] - globals: [2] ‘x’, ‘i’
[08:27:21.707] 
[08:27:21.707] getGlobalsAndPackages() ... DONE
[08:27:21.707] getGlobalsAndPackages() ...
[08:27:21.707] Searching for globals...
[08:27:21.709] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.709] Searching for globals ... DONE
[08:27:21.709] Resolving globals: FALSE
[08:27:21.714] The total size of the 2 globals is 1.09 MiB (1145431 bytes)
[08:27:21.714] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.09 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.09 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.714] - globals: [2] ‘x’, ‘i’
[08:27:21.714] 
[08:27:21.714] getGlobalsAndPackages() ... DONE
[08:27:21.715] getGlobalsAndPackages() ...
[08:27:21.715] Searching for globals...
[08:27:21.716] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.716] Searching for globals ... DONE
[08:27:21.717] Resolving globals: FALSE
[08:27:21.721] The total size of the 2 globals is 1.11 MiB (1164924 bytes)
[08:27:21.722] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.11 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.11 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.722] - globals: [2] ‘x’, ‘i’
[08:27:21.722] 
[08:27:21.722] getGlobalsAndPackages() ... DONE
[08:27:21.722] getGlobalsAndPackages() ...
[08:27:21.723] Searching for globals...
[08:27:21.726] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.726] Searching for globals ... DONE
[08:27:21.726] Resolving globals: FALSE
[08:27:21.731] The total size of the 2 globals is 1.13 MiB (1184417 bytes)
[08:27:21.731] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.13 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.13 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.731] - globals: [2] ‘x’, ‘i’
[08:27:21.731] 
[08:27:21.731] getGlobalsAndPackages() ... DONE
[08:27:21.732] getGlobalsAndPackages() ...
[08:27:21.732] Searching for globals...
[08:27:21.734] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.734] Searching for globals ... DONE
[08:27:21.734] Resolving globals: FALSE
[08:27:21.738] The total size of the 2 globals is 1.15 MiB (1203910 bytes)
[08:27:21.739] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.15 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.15 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.739] - globals: [2] ‘x’, ‘i’
[08:27:21.739] 
[08:27:21.739] getGlobalsAndPackages() ... DONE
[08:27:21.740] getGlobalsAndPackages() ...
[08:27:21.740] Searching for globals...
[08:27:21.741] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.741] Searching for globals ... DONE
[08:27:21.741] Resolving globals: FALSE
[08:27:21.746] The total size of the 2 globals is 1.17 MiB (1223403 bytes)
[08:27:21.747] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.17 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.17 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.747] - globals: [2] ‘x’, ‘i’
[08:27:21.747] 
[08:27:21.747] getGlobalsAndPackages() ... DONE
[08:27:21.747] getGlobalsAndPackages() ...
[08:27:21.748] Searching for globals...
[08:27:21.749] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.749] Searching for globals ... DONE
[08:27:21.749] Resolving globals: FALSE
[08:27:21.754] The total size of the 2 globals is 1.19 MiB (1242896 bytes)
[08:27:21.755] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.19 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.19 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.755] - globals: [2] ‘x’, ‘i’
[08:27:21.755] 
[08:27:21.755] getGlobalsAndPackages() ... DONE
[08:27:21.757] getGlobalsAndPackages() ...
[08:27:21.757] Searching for globals...
[08:27:21.759] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.759] Searching for globals ... DONE
[08:27:21.759] Resolving globals: FALSE
[08:27:21.764] The total size of the 2 globals is 1.20 MiB (1262453 bytes)
[08:27:21.765] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.20 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.20 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.765] - globals: [2] ‘x’, ‘i’
[08:27:21.765] 
[08:27:21.765] getGlobalsAndPackages() ... DONE
[08:27:21.766] getGlobalsAndPackages() ...
[08:27:21.766] Searching for globals...
[08:27:21.767] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.767] Searching for globals ... DONE
[08:27:21.767] Resolving globals: FALSE
[08:27:21.772] The total size of the 2 globals is 1.22 MiB (1281946 bytes)
[08:27:21.773] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.22 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.22 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.773] - globals: [2] ‘x’, ‘i’
[08:27:21.773] 
[08:27:21.773] getGlobalsAndPackages() ... DONE
[08:27:21.774] getGlobalsAndPackages() ...
[08:27:21.774] Searching for globals...
[08:27:21.775] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.775] Searching for globals ... DONE
[08:27:21.775] Resolving globals: FALSE
[08:27:21.780] The total size of the 2 globals is 1.24 MiB (1301439 bytes)
[08:27:21.781] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.24 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.24 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.781] - globals: [2] ‘x’, ‘i’
[08:27:21.781] 
[08:27:21.781] getGlobalsAndPackages() ... DONE
[08:27:21.782] getGlobalsAndPackages() ...
[08:27:21.782] Searching for globals...
[08:27:21.783] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.783] Searching for globals ... DONE
[08:27:21.783] Resolving globals: FALSE
[08:27:21.790] The total size of the 2 globals is 1.26 MiB (1320932 bytes)
[08:27:21.791] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.26 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.26 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.791] - globals: [2] ‘x’, ‘i’
[08:27:21.791] 
[08:27:21.791] getGlobalsAndPackages() ... DONE
[08:27:21.792] getGlobalsAndPackages() ...
[08:27:21.792] Searching for globals...
[08:27:21.793] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.793] Searching for globals ... DONE
[08:27:21.793] Resolving globals: FALSE
[08:27:21.799] The total size of the 2 globals is 1.28 MiB (1340425 bytes)
[08:27:21.799] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.28 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.28 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.799] - globals: [2] ‘x’, ‘i’
[08:27:21.799] 
[08:27:21.799] getGlobalsAndPackages() ... DONE
[08:27:21.800] getGlobalsAndPackages() ...
[08:27:21.800] Searching for globals...
[08:27:21.802] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.802] Searching for globals ... DONE
[08:27:21.802] Resolving globals: FALSE
[08:27:21.807] The total size of the 2 globals is 1.30 MiB (1359918 bytes)
[08:27:21.807] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.30 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.30 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.808] - globals: [2] ‘x’, ‘i’
[08:27:21.808] 
[08:27:21.808] getGlobalsAndPackages() ... DONE
[08:27:21.808] getGlobalsAndPackages() ...
[08:27:21.808] Searching for globals...
[08:27:21.810] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.810] Searching for globals ... DONE
[08:27:21.810] Resolving globals: FALSE
[08:27:21.815] The total size of the 2 globals is 1.32 MiB (1379411 bytes)
[08:27:21.816] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.32 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.32 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.816] - globals: [2] ‘x’, ‘i’
[08:27:21.816] 
[08:27:21.816] getGlobalsAndPackages() ... DONE
[08:27:21.817] getGlobalsAndPackages() ...
[08:27:21.817] Searching for globals...
[08:27:21.820] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.820] Searching for globals ... DONE
[08:27:21.820] Resolving globals: FALSE
[08:27:21.826] The total size of the 2 globals is 1.33 MiB (1398904 bytes)
[08:27:21.826] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.33 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.33 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.826] - globals: [2] ‘x’, ‘i’
[08:27:21.826] 
[08:27:21.826] getGlobalsAndPackages() ... DONE
[08:27:21.827] getGlobalsAndPackages() ...
[08:27:21.827] Searching for globals...
[08:27:21.829] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.829] Searching for globals ... DONE
[08:27:21.829] Resolving globals: FALSE
[08:27:21.834] The total size of the 2 globals is 1.35 MiB (1418397 bytes)
[08:27:21.834] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.35 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.35 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.835] - globals: [2] ‘x’, ‘i’
[08:27:21.835] 
[08:27:21.835] getGlobalsAndPackages() ... DONE
[08:27:21.835] getGlobalsAndPackages() ...
[08:27:21.835] Searching for globals...
[08:27:21.837] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.837] Searching for globals ... DONE
[08:27:21.837] Resolving globals: FALSE
[08:27:21.843] The total size of the 2 globals is 1.37 MiB (1437890 bytes)
[08:27:21.843] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.37 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.37 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.843] - globals: [2] ‘x’, ‘i’
[08:27:21.843] 
[08:27:21.843] getGlobalsAndPackages() ... DONE
[08:27:21.844] getGlobalsAndPackages() ...
[08:27:21.844] Searching for globals...
[08:27:21.845] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.846] Searching for globals ... DONE
[08:27:21.846] Resolving globals: FALSE
[08:27:21.853] The total size of the 2 globals is 1.39 MiB (1457383 bytes)
[08:27:21.854] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.39 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.39 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.854] - globals: [2] ‘x’, ‘i’
[08:27:21.854] 
[08:27:21.854] getGlobalsAndPackages() ... DONE
[08:27:21.854] getGlobalsAndPackages() ...
[08:27:21.855] Searching for globals...
[08:27:21.856] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.856] Searching for globals ... DONE
[08:27:21.856] Resolving globals: FALSE
[08:27:21.862] The total size of the 2 globals is 1.41 MiB (1476876 bytes)
[08:27:21.863] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.41 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.41 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.863] - globals: [2] ‘x’, ‘i’
[08:27:21.863] 
[08:27:21.863] getGlobalsAndPackages() ... DONE
[08:27:21.863] getGlobalsAndPackages() ...
[08:27:21.864] Searching for globals...
[08:27:21.865] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.865] Searching for globals ... DONE
[08:27:21.865] Resolving globals: FALSE
[08:27:21.871] The total size of the 2 globals is 1.43 MiB (1496369 bytes)
[08:27:21.872] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.43 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.43 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.872] - globals: [2] ‘x’, ‘i’
[08:27:21.872] 
[08:27:21.872] getGlobalsAndPackages() ... DONE
[08:27:21.872] getGlobalsAndPackages() ...
[08:27:21.872] Searching for globals...
[08:27:21.874] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.874] Searching for globals ... DONE
[08:27:21.874] Resolving globals: FALSE
[08:27:21.881] The total size of the 2 globals is 1.45 MiB (1515862 bytes)
[08:27:21.881] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.45 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.45 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.882] - globals: [2] ‘x’, ‘i’
[08:27:21.884] 
[08:27:21.884] getGlobalsAndPackages() ... DONE
[08:27:21.884] getGlobalsAndPackages() ...
[08:27:21.885] Searching for globals...
[08:27:21.886] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.886] Searching for globals ... DONE
[08:27:21.886] Resolving globals: FALSE
[08:27:21.893] The total size of the 2 globals is 1.46 MiB (1535355 bytes)
[08:27:21.893] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.46 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.46 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.894] - globals: [2] ‘x’, ‘i’
[08:27:21.894] 
[08:27:21.894] getGlobalsAndPackages() ... DONE
[08:27:21.894] getGlobalsAndPackages() ...
[08:27:21.894] Searching for globals...
[08:27:21.896] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.896] Searching for globals ... DONE
[08:27:21.896] Resolving globals: FALSE
[08:27:21.903] The total size of the 2 globals is 1.48 MiB (1554848 bytes)
[08:27:21.903] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.48 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.48 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.903] - globals: [2] ‘x’, ‘i’
[08:27:21.903] 
[08:27:21.904] getGlobalsAndPackages() ... DONE
[08:27:21.904] getGlobalsAndPackages() ...
[08:27:21.904] Searching for globals...
[08:27:21.906] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.906] Searching for globals ... DONE
[08:27:21.906] Resolving globals: FALSE
[08:27:21.913] The total size of the 2 globals is 1.50 MiB (1574341 bytes)
[08:27:21.913] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.50 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.50 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.913] - globals: [2] ‘x’, ‘i’
[08:27:21.913] 
[08:27:21.913] getGlobalsAndPackages() ... DONE
[08:27:21.914] getGlobalsAndPackages() ...
[08:27:21.914] Searching for globals...
[08:27:21.946] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.947] Searching for globals ... DONE
[08:27:21.947] Resolving globals: FALSE
[08:27:21.953] The total size of the 2 globals is 1.52 MiB (1593834 bytes)
[08:27:21.954] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.52 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.52 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.954] - globals: [2] ‘x’, ‘i’
[08:27:21.954] 
[08:27:21.954] getGlobalsAndPackages() ... DONE
[08:27:21.955] getGlobalsAndPackages() ...
[08:27:21.955] Searching for globals...
[08:27:21.957] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.957] Searching for globals ... DONE
[08:27:21.957] Resolving globals: FALSE
[08:27:21.963] The total size of the 2 globals is 1.54 MiB (1613327 bytes)
[08:27:21.964] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.54 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.54 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.964] - globals: [2] ‘x’, ‘i’
[08:27:21.964] 
[08:27:21.964] getGlobalsAndPackages() ... DONE
[08:27:21.964] getGlobalsAndPackages() ...
[08:27:21.965] Searching for globals...
[08:27:21.966] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.966] Searching for globals ... DONE
[08:27:21.966] Resolving globals: FALSE
[08:27:21.973] The total size of the 2 globals is 1.56 MiB (1632820 bytes)
[08:27:21.973] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.56 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.56 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.973] - globals: [2] ‘x’, ‘i’
[08:27:21.973] 
[08:27:21.973] getGlobalsAndPackages() ... DONE
[08:27:21.974] getGlobalsAndPackages() ...
[08:27:21.974] Searching for globals...
[08:27:21.976] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.976] Searching for globals ... DONE
[08:27:21.976] Resolving globals: FALSE
[08:27:21.984] The total size of the 2 globals is 1.58 MiB (1652313 bytes)
[08:27:21.985] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.58 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.58 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.985] - globals: [2] ‘x’, ‘i’
[08:27:21.985] 
[08:27:21.985] getGlobalsAndPackages() ... DONE
[08:27:21.986] getGlobalsAndPackages() ...
[08:27:21.986] Searching for globals...
[08:27:21.987] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.988] Searching for globals ... DONE
[08:27:21.988] Resolving globals: FALSE
[08:27:21.994] The total size of the 2 globals is 1.59 MiB (1671806 bytes)
[08:27:21.995] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.59 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.59 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:21.995] - globals: [2] ‘x’, ‘i’
[08:27:21.995] 
[08:27:21.995] getGlobalsAndPackages() ... DONE
[08:27:21.996] getGlobalsAndPackages() ...
[08:27:21.996] Searching for globals...
[08:27:21.997] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:21.997] Searching for globals ... DONE
[08:27:21.997] Resolving globals: FALSE
[08:27:22.004] The total size of the 2 globals is 1.61 MiB (1691299 bytes)
[08:27:22.005] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.61 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.61 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:22.005] - globals: [2] ‘x’, ‘i’
[08:27:22.005] 
[08:27:22.005] getGlobalsAndPackages() ... DONE
[08:27:22.005] getGlobalsAndPackages() ...
[08:27:22.006] Searching for globals...
[08:27:22.007] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:22.007] Searching for globals ... DONE
[08:27:22.007] Resolving globals: FALSE
[08:27:22.015] The total size of the 2 globals is 1.63 MiB (1710792 bytes)
[08:27:22.017] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.63 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.63 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:22.017] - globals: [2] ‘x’, ‘i’
[08:27:22.017] 
[08:27:22.017] getGlobalsAndPackages() ... DONE
[08:27:22.018] getGlobalsAndPackages() ...
[08:27:22.018] Searching for globals...
[08:27:22.020] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:22.020] Searching for globals ... DONE
[08:27:22.020] Resolving globals: FALSE
[08:27:22.027] The total size of the 2 globals is 1.65 MiB (1730285 bytes)
[08:27:22.028] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.65 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.65 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:22.028] - globals: [2] ‘x’, ‘i’
[08:27:22.028] 
[08:27:22.028] getGlobalsAndPackages() ... DONE
[08:27:22.029] getGlobalsAndPackages() ...
[08:27:22.029] Searching for globals...
[08:27:22.030] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:22.030] Searching for globals ... DONE
[08:27:22.031] Resolving globals: FALSE
[08:27:22.037] The total size of the 2 globals is 1.67 MiB (1749778 bytes)
[08:27:22.038] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.67 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.67 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:22.038] - globals: [2] ‘x’, ‘i’
[08:27:22.038] 
[08:27:22.038] getGlobalsAndPackages() ... DONE
[08:27:22.039] getGlobalsAndPackages() ...
[08:27:22.039] Searching for globals...
[08:27:22.040] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:22.041] Searching for globals ... DONE
[08:27:22.041] Resolving globals: FALSE
[08:27:22.048] The total size of the 2 globals is 1.69 MiB (1769271 bytes)
[08:27:22.048] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.69 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.69 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:22.048] - globals: [2] ‘x’, ‘i’
[08:27:22.048] 
[08:27:22.049] getGlobalsAndPackages() ... DONE
[08:27:22.049] getGlobalsAndPackages() ...
[08:27:22.049] Searching for globals...
[08:27:22.053] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:22.053] Searching for globals ... DONE
[08:27:22.053] Resolving globals: FALSE
[08:27:22.060] The total size of the 2 globals is 1.71 MiB (1788764 bytes)
[08:27:22.061] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.71 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.71 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:22.061] - globals: [2] ‘x’, ‘i’
[08:27:22.061] 
[08:27:22.061] getGlobalsAndPackages() ... DONE
[08:27:22.062] getGlobalsAndPackages() ...
[08:27:22.062] Searching for globals...
[08:27:22.063] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:22.064] Searching for globals ... DONE
[08:27:22.064] Resolving globals: FALSE
[08:27:22.071] The total size of the 2 globals is 1.72 MiB (1808425 bytes)
[08:27:22.071] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.72 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.72 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:22.072] - globals: [2] ‘x’, ‘i’
[08:27:22.072] 
[08:27:22.072] getGlobalsAndPackages() ... DONE
[08:27:22.072] getGlobalsAndPackages() ...
[08:27:22.072] Searching for globals...
[08:27:22.074] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:22.074] Searching for globals ... DONE
[08:27:22.074] Resolving globals: FALSE
[08:27:22.081] The total size of the 2 globals is 1.74 MiB (1827918 bytes)
[08:27:22.082] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.74 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.74 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:22.082] - globals: [2] ‘x’, ‘i’
[08:27:22.082] 
[08:27:22.082] getGlobalsAndPackages() ... DONE
[08:27:22.083] getGlobalsAndPackages() ...
[08:27:22.083] Searching for globals...
[08:27:22.085] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:22.086] Searching for globals ... DONE
[08:27:22.086] Resolving globals: FALSE
[08:27:22.095] The total size of the 2 globals is 1.76 MiB (1847411 bytes)
[08:27:22.095] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.76 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.76 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:22.095] - globals: [2] ‘x’, ‘i’
[08:27:22.095] 
[08:27:22.095] getGlobalsAndPackages() ... DONE
[08:27:22.096] getGlobalsAndPackages() ...
[08:27:22.096] Searching for globals...
[08:27:22.098] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:22.098] Searching for globals ... DONE
[08:27:22.098] Resolving globals: FALSE
[08:27:22.105] The total size of the 2 globals is 1.78 MiB (1866904 bytes)
[08:27:22.106] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.78 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.78 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:22.106] - globals: [2] ‘x’, ‘i’
[08:27:22.106] 
[08:27:22.106] getGlobalsAndPackages() ... DONE
[08:27:22.107] getGlobalsAndPackages() ...
[08:27:22.107] Searching for globals...
[08:27:22.109] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:22.109] Searching for globals ... DONE
[08:27:22.109] Resolving globals: FALSE
[08:27:22.117] The total size of the 2 globals is 1.80 MiB (1886397 bytes)
[08:27:22.117] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.80 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.80 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:22.117] - globals: [2] ‘x’, ‘i’
[08:27:22.118] 
[08:27:22.118] getGlobalsAndPackages() ... DONE
[08:27:22.118] getGlobalsAndPackages() ...
[08:27:22.118] Searching for globals...
[08:27:22.120] - globals found: [6] ‘{’, ‘+’, ‘[[’, ‘x’, ‘-’, ‘i’
[08:27:22.120] Searching for globals ... DONE
[08:27:22.120] Resolving globals: FALSE
[08:27:22.131] The total size of the 2 globals is 1.82 MiB (1905892 bytes)
[08:27:22.131] The total size of the 2 globals exported for future expression (‘{; x[[i - 2]] + x[[i - 1]]; }’) is 1.82 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘x’ (1.82 MiB of class ‘environment’) and ‘i’ (35 bytes of class ‘numeric’)
[08:27:22.131] - globals: [2] ‘x’, ‘i’
[08:27:22.131] 
[08:27:22.132] getGlobalsAndPackages() ... DONE

> ## At this point nothing has been calculated,
> ## because lazy evaluation is in place.
> 
> ## Get the 7:th Fibonnaci numbers (should be 8)
> print(x[[7]])
[08:27:22.133] run() for ‘Future’ ...
[08:27:22.133] - state: ‘created’
[08:27:22.133] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:22.133] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:22.133] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:22.134]   - Field: ‘label’
[08:27:22.134]   - Field: ‘local’
[08:27:22.134]   - Field: ‘owner’
[08:27:22.134]   - Field: ‘envir’
[08:27:22.134]   - Field: ‘packages’
[08:27:22.134]   - Field: ‘gc’
[08:27:22.134]   - Field: ‘conditions’
[08:27:22.134]   - Field: ‘expr’
[08:27:22.134]   - Field: ‘uuid’
[08:27:22.134]   - Field: ‘seed’
[08:27:22.134]   - Field: ‘version’
[08:27:22.135]   - Field: ‘result’
[08:27:22.135]   - Field: ‘asynchronous’
[08:27:22.135]   - Field: ‘calls’
[08:27:22.135]   - Field: ‘globals’
[08:27:22.135]   - Field: ‘stdout’
[08:27:22.135]   - Field: ‘earlySignal’
[08:27:22.135]   - Field: ‘lazy’
[08:27:22.135]   - Field: ‘state’
[08:27:22.135] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:22.135] - Launch lazy future ...
[08:27:22.136] Packages needed by the future expression (n = 0): <none>
[08:27:22.136] Packages needed by future strategies (n = 0): <none>
[08:27:22.137] {
[08:27:22.137]     {
[08:27:22.137]         {
[08:27:22.137]             ...future.startTime <- base::Sys.time()
[08:27:22.137]             {
[08:27:22.137]                 {
[08:27:22.137]                   {
[08:27:22.137]                     base::local({
[08:27:22.137]                       has_future <- base::requireNamespace("future", 
[08:27:22.137]                         quietly = TRUE)
[08:27:22.137]                       if (has_future) {
[08:27:22.137]                         ns <- base::getNamespace("future")
[08:27:22.137]                         version <- ns[[".package"]][["version"]]
[08:27:22.137]                         if (is.null(version)) 
[08:27:22.137]                           version <- utils::packageVersion("future")
[08:27:22.137]                       }
[08:27:22.137]                       else {
[08:27:22.137]                         version <- NULL
[08:27:22.137]                       }
[08:27:22.137]                       if (!has_future || version < "1.8.0") {
[08:27:22.137]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:22.137]                           "", base::R.version$version.string), 
[08:27:22.137]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:22.137]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:22.137]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:22.137]                             "release", "version")], collapse = " "), 
[08:27:22.137]                           hostname = base::Sys.info()[["nodename"]])
[08:27:22.137]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:22.137]                           info)
[08:27:22.137]                         info <- base::paste(info, collapse = "; ")
[08:27:22.137]                         if (!has_future) {
[08:27:22.137]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:22.137]                             info)
[08:27:22.137]                         }
[08:27:22.137]                         else {
[08:27:22.137]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:22.137]                             info, version)
[08:27:22.137]                         }
[08:27:22.137]                         base::stop(msg)
[08:27:22.137]                       }
[08:27:22.137]                     })
[08:27:22.137]                   }
[08:27:22.137]                   ...future.strategy.old <- future::plan("list")
[08:27:22.137]                   options(future.plan = NULL)
[08:27:22.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:22.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:22.137]                 }
[08:27:22.137]                 ...future.workdir <- getwd()
[08:27:22.137]             }
[08:27:22.137]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:22.137]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:22.137]         }
[08:27:22.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:22.137]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:22.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:22.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:22.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:22.137]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:22.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:22.137]             base::names(...future.oldOptions))
[08:27:22.137]     }
[08:27:22.137]     if (TRUE) {
[08:27:22.137]     }
[08:27:22.137]     else {
[08:27:22.137]         if (NA) {
[08:27:22.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:22.137]                 open = "w")
[08:27:22.137]         }
[08:27:22.137]         else {
[08:27:22.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:22.137]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:22.137]         }
[08:27:22.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:22.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:22.137]             base::sink(type = "output", split = FALSE)
[08:27:22.137]             base::close(...future.stdout)
[08:27:22.137]         }, add = TRUE)
[08:27:22.137]     }
[08:27:22.137]     ...future.frame <- base::sys.nframe()
[08:27:22.137]     ...future.conditions <- base::list()
[08:27:22.137]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:22.137]     if (FALSE) {
[08:27:22.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:22.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:22.137]     }
[08:27:22.137]     ...future.result <- base::tryCatch({
[08:27:22.137]         base::withCallingHandlers({
[08:27:22.137]             ...future.value <- base::withVisible(base::local({
[08:27:22.137]                 x[[i - 2]] + x[[i - 1]]
[08:27:22.137]             }))
[08:27:22.137]             future::FutureResult(value = ...future.value$value, 
[08:27:22.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:22.137]                   ...future.rng), globalenv = if (FALSE) 
[08:27:22.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:22.137]                     ...future.globalenv.names))
[08:27:22.137]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:22.137]         }, condition = base::local({
[08:27:22.137]             c <- base::c
[08:27:22.137]             inherits <- base::inherits
[08:27:22.137]             invokeRestart <- base::invokeRestart
[08:27:22.137]             length <- base::length
[08:27:22.137]             list <- base::list
[08:27:22.137]             seq.int <- base::seq.int
[08:27:22.137]             signalCondition <- base::signalCondition
[08:27:22.137]             sys.calls <- base::sys.calls
[08:27:22.137]             `[[` <- base::`[[`
[08:27:22.137]             `+` <- base::`+`
[08:27:22.137]             `<<-` <- base::`<<-`
[08:27:22.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:22.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:22.137]                   3L)]
[08:27:22.137]             }
[08:27:22.137]             function(cond) {
[08:27:22.137]                 is_error <- inherits(cond, "error")
[08:27:22.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:22.137]                   NULL)
[08:27:22.137]                 if (is_error) {
[08:27:22.137]                   sessionInformation <- function() {
[08:27:22.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:22.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:22.137]                       search = base::search(), system = base::Sys.info())
[08:27:22.137]                   }
[08:27:22.137]                   ...future.conditions[[length(...future.conditions) + 
[08:27:22.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:22.137]                     cond$call), session = sessionInformation(), 
[08:27:22.137]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:22.137]                   signalCondition(cond)
[08:27:22.137]                 }
[08:27:22.137]                 else if (!ignore && TRUE && inherits(cond, c("error", 
[08:27:22.137]                 "immediateCondition"))) {
[08:27:22.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:22.137]                   ...future.conditions[[length(...future.conditions) + 
[08:27:22.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:22.137]                   if (TRUE && !signal) {
[08:27:22.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:22.137]                     {
[08:27:22.137]                       inherits <- base::inherits
[08:27:22.137]                       invokeRestart <- base::invokeRestart
[08:27:22.137]                       is.null <- base::is.null
[08:27:22.137]                       muffled <- FALSE
[08:27:22.137]                       if (inherits(cond, "message")) {
[08:27:22.137]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:22.137]                         if (muffled) 
[08:27:22.137]                           invokeRestart("muffleMessage")
[08:27:22.137]                       }
[08:27:22.137]                       else if (inherits(cond, "warning")) {
[08:27:22.137]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:22.137]                         if (muffled) 
[08:27:22.137]                           invokeRestart("muffleWarning")
[08:27:22.137]                       }
[08:27:22.137]                       else if (inherits(cond, "condition")) {
[08:27:22.137]                         if (!is.null(pattern)) {
[08:27:22.137]                           computeRestarts <- base::computeRestarts
[08:27:22.137]                           grepl <- base::grepl
[08:27:22.137]                           restarts <- computeRestarts(cond)
[08:27:22.137]                           for (restart in restarts) {
[08:27:22.137]                             name <- restart$name
[08:27:22.137]                             if (is.null(name)) 
[08:27:22.137]                               next
[08:27:22.137]                             if (!grepl(pattern, name)) 
[08:27:22.137]                               next
[08:27:22.137]                             invokeRestart(restart)
[08:27:22.137]                             muffled <- TRUE
[08:27:22.137]                             break
[08:27:22.137]                           }
[08:27:22.137]                         }
[08:27:22.137]                       }
[08:27:22.137]                       invisible(muffled)
[08:27:22.137]                     }
[08:27:22.137]                     muffleCondition(cond, pattern = "^muffle")
[08:27:22.137]                   }
[08:27:22.137]                 }
[08:27:22.137]                 else {
[08:27:22.137]                   if (TRUE) {
[08:27:22.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:22.137]                     {
[08:27:22.137]                       inherits <- base::inherits
[08:27:22.137]                       invokeRestart <- base::invokeRestart
[08:27:22.137]                       is.null <- base::is.null
[08:27:22.137]                       muffled <- FALSE
[08:27:22.137]                       if (inherits(cond, "message")) {
[08:27:22.137]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:22.137]                         if (muffled) 
[08:27:22.137]                           invokeRestart("muffleMessage")
[08:27:22.137]                       }
[08:27:22.137]                       else if (inherits(cond, "warning")) {
[08:27:22.137]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:22.137]                         if (muffled) 
[08:27:22.137]                           invokeRestart("muffleWarning")
[08:27:22.137]                       }
[08:27:22.137]                       else if (inherits(cond, "condition")) {
[08:27:22.137]                         if (!is.null(pattern)) {
[08:27:22.137]                           computeRestarts <- base::computeRestarts
[08:27:22.137]                           grepl <- base::grepl
[08:27:22.137]                           restarts <- computeRestarts(cond)
[08:27:22.137]                           for (restart in restarts) {
[08:27:22.137]                             name <- restart$name
[08:27:22.137]                             if (is.null(name)) 
[08:27:22.137]                               next
[08:27:22.137]                             if (!grepl(pattern, name)) 
[08:27:22.137]                               next
[08:27:22.137]                             invokeRestart(restart)
[08:27:22.137]                             muffled <- TRUE
[08:27:22.137]                             break
[08:27:22.137]                           }
[08:27:22.137]                         }
[08:27:22.137]                       }
[08:27:22.137]                       invisible(muffled)
[08:27:22.137]                     }
[08:27:22.137]                     muffleCondition(cond, pattern = "^muffle")
[08:27:22.137]                   }
[08:27:22.137]                 }
[08:27:22.137]             }
[08:27:22.137]         }))
[08:27:22.137]     }, error = function(ex) {
[08:27:22.137]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:22.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:22.137]                 ...future.rng), started = ...future.startTime, 
[08:27:22.137]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:22.137]             version = "1.8"), class = "FutureResult")
[08:27:22.137]     }, finally = {
[08:27:22.137]         if (!identical(...future.workdir, getwd())) 
[08:27:22.137]             setwd(...future.workdir)
[08:27:22.137]         {
[08:27:22.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:22.137]                 ...future.oldOptions$nwarnings <- NULL
[08:27:22.137]             }
[08:27:22.137]             base::options(...future.oldOptions)
[08:27:22.137]             if (.Platform$OS.type == "windows") {
[08:27:22.137]                 old_names <- names(...future.oldEnvVars)
[08:27:22.137]                 envs <- base::Sys.getenv()
[08:27:22.137]                 names <- names(envs)
[08:27:22.137]                 common <- intersect(names, old_names)
[08:27:22.137]                 added <- setdiff(names, old_names)
[08:27:22.137]                 removed <- setdiff(old_names, names)
[08:27:22.137]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:22.137]                   envs[common]]
[08:27:22.137]                 NAMES <- toupper(changed)
[08:27:22.137]                 args <- list()
[08:27:22.137]                 for (kk in seq_along(NAMES)) {
[08:27:22.137]                   name <- changed[[kk]]
[08:27:22.137]                   NAME <- NAMES[[kk]]
[08:27:22.137]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:22.137]                     next
[08:27:22.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:22.137]                 }
[08:27:22.137]                 NAMES <- toupper(added)
[08:27:22.137]                 for (kk in seq_along(NAMES)) {
[08:27:22.137]                   name <- added[[kk]]
[08:27:22.137]                   NAME <- NAMES[[kk]]
[08:27:22.137]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:22.137]                     next
[08:27:22.137]                   args[[name]] <- ""
[08:27:22.137]                 }
[08:27:22.137]                 NAMES <- toupper(removed)
[08:27:22.137]                 for (kk in seq_along(NAMES)) {
[08:27:22.137]                   name <- removed[[kk]]
[08:27:22.137]                   NAME <- NAMES[[kk]]
[08:27:22.137]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:22.137]                     next
[08:27:22.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:22.137]                 }
[08:27:22.137]                 if (length(args) > 0) 
[08:27:22.137]                   base::do.call(base::Sys.setenv, args = args)
[08:27:22.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:22.137]             }
[08:27:22.137]             else {
[08:27:22.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:22.137]             }
[08:27:22.137]             {
[08:27:22.137]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:22.137]                   0L) {
[08:27:22.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:22.137]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:22.137]                   base::options(opts)
[08:27:22.137]                 }
[08:27:22.137]                 {
[08:27:22.137]                   {
[08:27:22.137]                     NULL
[08:27:22.137]                     RNGkind("Mersenne-Twister")
[08:27:22.137]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:22.137]                       inherits = FALSE)
[08:27:22.137]                   }
[08:27:22.137]                   options(future.plan = NULL)
[08:27:22.137]                   if (is.na(NA_character_)) 
[08:27:22.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:22.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:22.137]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:22.137]                     .init = FALSE)
[08:27:22.137]                 }
[08:27:22.137]             }
[08:27:22.137]         }
[08:27:22.137]     })
[08:27:22.137]     if (FALSE) {
[08:27:22.137]         base::sink(type = "output", split = FALSE)
[08:27:22.137]         if (NA) {
[08:27:22.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:22.137]         }
[08:27:22.137]         else {
[08:27:22.137]             ...future.result["stdout"] <- base::list(NULL)
[08:27:22.137]         }
[08:27:22.137]         base::close(...future.stdout)
[08:27:22.137]         ...future.stdout <- NULL
[08:27:22.137]     }
[08:27:22.137]     ...future.result$conditions <- ...future.conditions
[08:27:22.137]     ...future.result$finished <- base::Sys.time()
[08:27:22.137]     ...future.result
[08:27:22.137] }
[08:27:22.139] assign_globals() ...
[08:27:22.139] List of 2
[08:27:22.139]  $ x:Classes 'listenv', 'environment' <environment: 0x561dea0f90f8> 
[08:27:22.139]  $ i: int 7
[08:27:22.139]  - attr(*, "where")=List of 2
[08:27:22.139]   ..$ x:<environment: R_EmptyEnv> 
[08:27:22.139]   ..$ i:<environment: R_EmptyEnv> 
[08:27:22.139]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:22.139]  - attr(*, "resolved")= logi FALSE
[08:27:22.139]  - attr(*, "total_size")= num 92634
[08:27:22.139]  - attr(*, "already-done")= logi TRUE
[08:27:22.144] - copied ‘x’ to environment
[08:27:22.144] - copied ‘i’ to environment
[08:27:22.144] assign_globals() ... done
[08:27:22.145] plan(): Setting new future strategy stack:
[08:27:22.145] List of future strategies:
[08:27:22.145] 1. sequential:
[08:27:22.145]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:22.145]    - tweaked: FALSE
[08:27:22.145]    - call: NULL
[08:27:22.145] plan(): nbrOfWorkers() = 1
[08:27:22.230] plan(): Setting new future strategy stack:
[08:27:22.230] List of future strategies:
[08:27:22.230] 1. sequential:
[08:27:22.230]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:22.230]    - tweaked: FALSE
[08:27:22.230]    - call: plan(sequential)
[08:27:22.230] plan(): nbrOfWorkers() = 1
[08:27:22.230] SequentialFuture started (and completed)
[08:27:22.231] - Launch lazy future ... done
[08:27:22.231] run() for ‘SequentialFuture’ ... done
[1] 8

> ## At this point x[1:7] have been calculated,
> ## but nothing beyond.
> 
> ## Let's get the 50:th number.
> print(x[[50]])
[08:27:22.231] run() for ‘Future’ ...
[08:27:22.231] - state: ‘created’
[08:27:22.231] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:22.232] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:22.232] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:22.232]   - Field: ‘label’
[08:27:22.232]   - Field: ‘local’
[08:27:22.232]   - Field: ‘owner’
[08:27:22.232]   - Field: ‘envir’
[08:27:22.232]   - Field: ‘packages’
[08:27:22.232]   - Field: ‘gc’
[08:27:22.232]   - Field: ‘conditions’
[08:27:22.233]   - Field: ‘expr’
[08:27:22.233]   - Field: ‘uuid’
[08:27:22.233]   - Field: ‘seed’
[08:27:22.233]   - Field: ‘version’
[08:27:22.233]   - Field: ‘result’
[08:27:22.233]   - Field: ‘asynchronous’
[08:27:22.233]   - Field: ‘calls’
[08:27:22.233]   - Field: ‘globals’
[08:27:22.233]   - Field: ‘stdout’
[08:27:22.233]   - Field: ‘earlySignal’
[08:27:22.233]   - Field: ‘lazy’
[08:27:22.234]   - Field: ‘state’
[08:27:22.234] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:22.234] - Launch lazy future ...
[08:27:22.234] Packages needed by the future expression (n = 0): <none>
[08:27:22.234] Packages needed by future strategies (n = 0): <none>
[08:27:22.234] {
[08:27:22.234]     {
[08:27:22.234]         {
[08:27:22.234]             ...future.startTime <- base::Sys.time()
[08:27:22.234]             {
[08:27:22.234]                 {
[08:27:22.234]                   {
[08:27:22.234]                     base::local({
[08:27:22.234]                       has_future <- base::requireNamespace("future", 
[08:27:22.234]                         quietly = TRUE)
[08:27:22.234]                       if (has_future) {
[08:27:22.234]                         ns <- base::getNamespace("future")
[08:27:22.234]                         version <- ns[[".package"]][["version"]]
[08:27:22.234]                         if (is.null(version)) 
[08:27:22.234]                           version <- utils::packageVersion("future")
[08:27:22.234]                       }
[08:27:22.234]                       else {
[08:27:22.234]                         version <- NULL
[08:27:22.234]                       }
[08:27:22.234]                       if (!has_future || version < "1.8.0") {
[08:27:22.234]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:22.234]                           "", base::R.version$version.string), 
[08:27:22.234]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:22.234]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:22.234]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:22.234]                             "release", "version")], collapse = " "), 
[08:27:22.234]                           hostname = base::Sys.info()[["nodename"]])
[08:27:22.234]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:22.234]                           info)
[08:27:22.234]                         info <- base::paste(info, collapse = "; ")
[08:27:22.234]                         if (!has_future) {
[08:27:22.234]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:22.234]                             info)
[08:27:22.234]                         }
[08:27:22.234]                         else {
[08:27:22.234]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:22.234]                             info, version)
[08:27:22.234]                         }
[08:27:22.234]                         base::stop(msg)
[08:27:22.234]                       }
[08:27:22.234]                     })
[08:27:22.234]                   }
[08:27:22.234]                   ...future.strategy.old <- future::plan("list")
[08:27:22.234]                   options(future.plan = NULL)
[08:27:22.234]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:22.234]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:22.234]                 }
[08:27:22.234]                 ...future.workdir <- getwd()
[08:27:22.234]             }
[08:27:22.234]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:22.234]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:22.234]         }
[08:27:22.234]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:22.234]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:22.234]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:22.234]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:22.234]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:22.234]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:22.234]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:22.234]             base::names(...future.oldOptions))
[08:27:22.234]     }
[08:27:22.234]     if (TRUE) {
[08:27:22.234]     }
[08:27:22.234]     else {
[08:27:22.234]         if (NA) {
[08:27:22.234]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:22.234]                 open = "w")
[08:27:22.234]         }
[08:27:22.234]         else {
[08:27:22.234]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:22.234]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:22.234]         }
[08:27:22.234]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:22.234]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:22.234]             base::sink(type = "output", split = FALSE)
[08:27:22.234]             base::close(...future.stdout)
[08:27:22.234]         }, add = TRUE)
[08:27:22.234]     }
[08:27:22.234]     ...future.frame <- base::sys.nframe()
[08:27:22.234]     ...future.conditions <- base::list()
[08:27:22.234]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:22.234]     if (FALSE) {
[08:27:22.234]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:22.234]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:22.234]     }
[08:27:22.234]     ...future.result <- base::tryCatch({
[08:27:22.234]         base::withCallingHandlers({
[08:27:22.234]             ...future.value <- base::withVisible(base::local({
[08:27:22.234]                 x[[i - 2]] + x[[i - 1]]
[08:27:22.234]             }))
[08:27:22.234]             future::FutureResult(value = ...future.value$value, 
[08:27:22.234]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:22.234]                   ...future.rng), globalenv = if (FALSE) 
[08:27:22.234]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:22.234]                     ...future.globalenv.names))
[08:27:22.234]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:22.234]         }, condition = base::local({
[08:27:22.234]             c <- base::c
[08:27:22.234]             inherits <- base::inherits
[08:27:22.234]             invokeRestart <- base::invokeRestart
[08:27:22.234]             length <- base::length
[08:27:22.234]             list <- base::list
[08:27:22.234]             seq.int <- base::seq.int
[08:27:22.234]             signalCondition <- base::signalCondition
[08:27:22.234]             sys.calls <- base::sys.calls
[08:27:22.234]             `[[` <- base::`[[`
[08:27:22.234]             `+` <- base::`+`
[08:27:22.234]             `<<-` <- base::`<<-`
[08:27:22.234]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:22.234]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:22.234]                   3L)]
[08:27:22.234]             }
[08:27:22.234]             function(cond) {
[08:27:22.234]                 is_error <- inherits(cond, "error")
[08:27:22.234]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:22.234]                   NULL)
[08:27:22.234]                 if (is_error) {
[08:27:22.234]                   sessionInformation <- function() {
[08:27:22.234]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:22.234]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:22.234]                       search = base::search(), system = base::Sys.info())
[08:27:22.234]                   }
[08:27:22.234]                   ...future.conditions[[length(...future.conditions) + 
[08:27:22.234]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:22.234]                     cond$call), session = sessionInformation(), 
[08:27:22.234]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:22.234]                   signalCondition(cond)
[08:27:22.234]                 }
[08:27:22.234]                 else if (!ignore && TRUE && inherits(cond, c("error", 
[08:27:22.234]                 "immediateCondition"))) {
[08:27:22.234]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:22.234]                   ...future.conditions[[length(...future.conditions) + 
[08:27:22.234]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:22.234]                   if (TRUE && !signal) {
[08:27:22.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:22.234]                     {
[08:27:22.234]                       inherits <- base::inherits
[08:27:22.234]                       invokeRestart <- base::invokeRestart
[08:27:22.234]                       is.null <- base::is.null
[08:27:22.234]                       muffled <- FALSE
[08:27:22.234]                       if (inherits(cond, "message")) {
[08:27:22.234]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:22.234]                         if (muffled) 
[08:27:22.234]                           invokeRestart("muffleMessage")
[08:27:22.234]                       }
[08:27:22.234]                       else if (inherits(cond, "warning")) {
[08:27:22.234]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:22.234]                         if (muffled) 
[08:27:22.234]                           invokeRestart("muffleWarning")
[08:27:22.234]                       }
[08:27:22.234]                       else if (inherits(cond, "condition")) {
[08:27:22.234]                         if (!is.null(pattern)) {
[08:27:22.234]                           computeRestarts <- base::computeRestarts
[08:27:22.234]                           grepl <- base::grepl
[08:27:22.234]                           restarts <- computeRestarts(cond)
[08:27:22.234]                           for (restart in restarts) {
[08:27:22.234]                             name <- restart$name
[08:27:22.234]                             if (is.null(name)) 
[08:27:22.234]                               next
[08:27:22.234]                             if (!grepl(pattern, name)) 
[08:27:22.234]                               next
[08:27:22.234]                             invokeRestart(restart)
[08:27:22.234]                             muffled <- TRUE
[08:27:22.234]                             break
[08:27:22.234]                           }
[08:27:22.234]                         }
[08:27:22.234]                       }
[08:27:22.234]                       invisible(muffled)
[08:27:22.234]                     }
[08:27:22.234]                     muffleCondition(cond, pattern = "^muffle")
[08:27:22.234]                   }
[08:27:22.234]                 }
[08:27:22.234]                 else {
[08:27:22.234]                   if (TRUE) {
[08:27:22.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:22.234]                     {
[08:27:22.234]                       inherits <- base::inherits
[08:27:22.234]                       invokeRestart <- base::invokeRestart
[08:27:22.234]                       is.null <- base::is.null
[08:27:22.234]                       muffled <- FALSE
[08:27:22.234]                       if (inherits(cond, "message")) {
[08:27:22.234]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:22.234]                         if (muffled) 
[08:27:22.234]                           invokeRestart("muffleMessage")
[08:27:22.234]                       }
[08:27:22.234]                       else if (inherits(cond, "warning")) {
[08:27:22.234]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:22.234]                         if (muffled) 
[08:27:22.234]                           invokeRestart("muffleWarning")
[08:27:22.234]                       }
[08:27:22.234]                       else if (inherits(cond, "condition")) {
[08:27:22.234]                         if (!is.null(pattern)) {
[08:27:22.234]                           computeRestarts <- base::computeRestarts
[08:27:22.234]                           grepl <- base::grepl
[08:27:22.234]                           restarts <- computeRestarts(cond)
[08:27:22.234]                           for (restart in restarts) {
[08:27:22.234]                             name <- restart$name
[08:27:22.234]                             if (is.null(name)) 
[08:27:22.234]                               next
[08:27:22.234]                             if (!grepl(pattern, name)) 
[08:27:22.234]                               next
[08:27:22.234]                             invokeRestart(restart)
[08:27:22.234]                             muffled <- TRUE
[08:27:22.234]                             break
[08:27:22.234]                           }
[08:27:22.234]                         }
[08:27:22.234]                       }
[08:27:22.234]                       invisible(muffled)
[08:27:22.234]                     }
[08:27:22.234]                     muffleCondition(cond, pattern = "^muffle")
[08:27:22.234]                   }
[08:27:22.234]                 }
[08:27:22.234]             }
[08:27:22.234]         }))
[08:27:22.234]     }, error = function(ex) {
[08:27:22.234]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:22.234]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:22.234]                 ...future.rng), started = ...future.startTime, 
[08:27:22.234]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:22.234]             version = "1.8"), class = "FutureResult")
[08:27:22.234]     }, finally = {
[08:27:22.234]         if (!identical(...future.workdir, getwd())) 
[08:27:22.234]             setwd(...future.workdir)
[08:27:22.234]         {
[08:27:22.234]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:22.234]                 ...future.oldOptions$nwarnings <- NULL
[08:27:22.234]             }
[08:27:22.234]             base::options(...future.oldOptions)
[08:27:22.234]             if (.Platform$OS.type == "windows") {
[08:27:22.234]                 old_names <- names(...future.oldEnvVars)
[08:27:22.234]                 envs <- base::Sys.getenv()
[08:27:22.234]                 names <- names(envs)
[08:27:22.234]                 common <- intersect(names, old_names)
[08:27:22.234]                 added <- setdiff(names, old_names)
[08:27:22.234]                 removed <- setdiff(old_names, names)
[08:27:22.234]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:22.234]                   envs[common]]
[08:27:22.234]                 NAMES <- toupper(changed)
[08:27:22.234]                 args <- list()
[08:27:22.234]                 for (kk in seq_along(NAMES)) {
[08:27:22.234]                   name <- changed[[kk]]
[08:27:22.234]                   NAME <- NAMES[[kk]]
[08:27:22.234]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:22.234]                     next
[08:27:22.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:22.234]                 }
[08:27:22.234]                 NAMES <- toupper(added)
[08:27:22.234]                 for (kk in seq_along(NAMES)) {
[08:27:22.234]                   name <- added[[kk]]
[08:27:22.234]                   NAME <- NAMES[[kk]]
[08:27:22.234]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:22.234]                     next
[08:27:22.234]                   args[[name]] <- ""
[08:27:22.234]                 }
[08:27:22.234]                 NAMES <- toupper(removed)
[08:27:22.234]                 for (kk in seq_along(NAMES)) {
[08:27:22.234]                   name <- removed[[kk]]
[08:27:22.234]                   NAME <- NAMES[[kk]]
[08:27:22.234]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:22.234]                     next
[08:27:22.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:22.234]                 }
[08:27:22.234]                 if (length(args) > 0) 
[08:27:22.234]                   base::do.call(base::Sys.setenv, args = args)
[08:27:22.234]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:22.234]             }
[08:27:22.234]             else {
[08:27:22.234]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:22.234]             }
[08:27:22.234]             {
[08:27:22.234]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:22.234]                   0L) {
[08:27:22.234]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:22.234]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:22.234]                   base::options(opts)
[08:27:22.234]                 }
[08:27:22.234]                 {
[08:27:22.234]                   {
[08:27:22.234]                     NULL
[08:27:22.234]                     RNGkind("Mersenne-Twister")
[08:27:22.234]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:22.234]                       inherits = FALSE)
[08:27:22.234]                   }
[08:27:22.234]                   options(future.plan = NULL)
[08:27:22.234]                   if (is.na(NA_character_)) 
[08:27:22.234]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:22.234]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:22.234]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:22.234]                     .init = FALSE)
[08:27:22.234]                 }
[08:27:22.234]             }
[08:27:22.234]         }
[08:27:22.234]     })
[08:27:22.234]     if (FALSE) {
[08:27:22.234]         base::sink(type = "output", split = FALSE)
[08:27:22.234]         if (NA) {
[08:27:22.234]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:22.234]         }
[08:27:22.234]         else {
[08:27:22.234]             ...future.result["stdout"] <- base::list(NULL)
[08:27:22.234]         }
[08:27:22.234]         base::close(...future.stdout)
[08:27:22.234]         ...future.stdout <- NULL
[08:27:22.234]     }
[08:27:22.234]     ...future.result$conditions <- ...future.conditions
[08:27:22.234]     ...future.result$finished <- base::Sys.time()
[08:27:22.234]     ...future.result
[08:27:22.234] }
[08:27:22.236] assign_globals() ...
[08:27:22.236] List of 2
[08:27:22.236]  $ x:Classes 'listenv', 'environment' <environment: 0x561dea0f90f8> 
[08:27:22.236]  $ i: int 50
[08:27:22.236]  - attr(*, "where")=List of 2
[08:27:22.236]   ..$ x:<environment: R_EmptyEnv> 
[08:27:22.236]   ..$ i:<environment: R_EmptyEnv> 
[08:27:22.236]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:22.236]  - attr(*, "resolved")= logi FALSE
[08:27:22.236]  - attr(*, "total_size")= num 931008
[08:27:22.236]  - attr(*, "already-done")= logi TRUE
[08:27:22.239] - copied ‘x’ to environment
[08:27:22.239] - copied ‘i’ to environment
[08:27:22.240] assign_globals() ... done
[08:27:22.240] plan(): Setting new future strategy stack:
[08:27:22.240] List of future strategies:
[08:27:22.240] 1. sequential:
[08:27:22.240]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:22.240]    - tweaked: FALSE
[08:27:22.240]    - call: NULL
[08:27:22.240] plan(): nbrOfWorkers() = 1
[08:27:23.228] plan(): Setting new future strategy stack:
[08:27:23.228] List of future strategies:
[08:27:23.228] 1. sequential:
[08:27:23.228]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:23.228]    - tweaked: FALSE
[08:27:23.228]    - call: plan(sequential)
[08:27:23.229] plan(): nbrOfWorkers() = 1
[08:27:23.229] SequentialFuture started (and completed)
[08:27:23.229] - Launch lazy future ... done
[08:27:23.229] run() for ‘SequentialFuture’ ... done
[1] 7778742049

> ## Reset plan
> plan(oplan)
[08:27:23.229] plan(): Setting new future strategy stack:
[08:27:23.230] List of future strategies:
[08:27:23.230] 1. sequential:
[08:27:23.230]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:23.230]    - tweaked: FALSE
[08:27:23.230]    - call: future::plan("sequential")
[08:27:23.230] plan(): nbrOfWorkers() = 1
> message("*** Fibonacci demo of the 'future' package ... DONE")
*** Fibonacci demo of the 'future' package ... DONE
> 
> 
> message("*** Mandelbrot demo of the 'future' package ...")
*** Mandelbrot demo of the 'future' package ...
> if (getRversion() >= "3.2.0" && !isWin32) {
+   options(future.demo.mandelbrot.nrow = 2L)
+   options(future.demo.mandelbrot.resolution = 50L)
+   options(future.demo.mandelbrot.delay = FALSE)
+   
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+   
+     for (strategy in supportedStrategies(cores)) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+       demo("mandelbrot", package = "future", ask = FALSE)
+       message(sprintf("- plan('%s') ... DONE", strategy))
+     }
+   
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } else {
+   message(" - This demo requires R (>= 3.2.0). Skipping test. (Skipping also on Win32 i386 for speed)")
+ }
Testing with 1 cores ...
- plan('sequential') ...
[08:27:23.240] plan(): Setting new future strategy stack:
[08:27:23.240] List of future strategies:
[08:27:23.240] 1. sequential:
[08:27:23.240]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:23.240]    - tweaked: FALSE
[08:27:23.240]    - call: plan(strategy)
[08:27:23.241] plan(): nbrOfWorkers() = 1


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1] 1 2 3 4

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[08:27:23.272] getGlobalsAndPackages() ...
[08:27:23.272] Searching for globals...
[08:27:23.277] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[08:27:23.277] Searching for globals ... DONE
[08:27:23.277] Resolving globals: FALSE
[08:27:23.277] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[08:27:23.278] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:27:23.278] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[08:27:23.278] - packages: [1] ‘future’
[08:27:23.281] getGlobalsAndPackages() ... DONE
 2[08:27:23.286] getGlobalsAndPackages() ...
[08:27:23.287] Searching for globals...
[08:27:23.290] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[08:27:23.290] Searching for globals ... DONE
[08:27:23.290] Resolving globals: FALSE
[08:27:23.291] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[08:27:23.291] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:27:23.292] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[08:27:23.292] - packages: [1] ‘future’
[08:27:23.292] getGlobalsAndPackages() ... DONE
 3[08:27:23.292] getGlobalsAndPackages() ...
[08:27:23.292] Searching for globals...
[08:27:23.296] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[08:27:23.296] Searching for globals ... DONE
[08:27:23.296] Resolving globals: FALSE
[08:27:23.296] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[08:27:23.301] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:27:23.301] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[08:27:23.301] - packages: [1] ‘future’
[08:27:23.301] getGlobalsAndPackages() ... DONE
 4[08:27:23.302] getGlobalsAndPackages() ...
[08:27:23.302] Searching for globals...
[08:27:23.306] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[08:27:23.307] Searching for globals ... DONE
[08:27:23.307] Resolving globals: FALSE
[08:27:23.307] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[08:27:23.308] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:27:23.308] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[08:27:23.308] - packages: [1] ‘future’
[08:27:23.308] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[08:27:23.320] resolved() for ‘Future’ ...
[08:27:23.321] - state: ‘created’
[08:27:23.321] - run: TRUE
[08:27:23.321] - run() ...
[08:27:23.321] run() for ‘Future’ ...
[08:27:23.321] - state: ‘created’
[08:27:23.321] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:23.322] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:23.322] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:23.322]   - Field: ‘label’
[08:27:23.322]   - Field: ‘local’
[08:27:23.322]   - Field: ‘owner’
[08:27:23.322]   - Field: ‘envir’
[08:27:23.322]   - Field: ‘packages’
[08:27:23.323]   - Field: ‘gc’
[08:27:23.323]   - Field: ‘conditions’
[08:27:23.323]   - Field: ‘expr’
[08:27:23.323]   - Field: ‘uuid’
[08:27:23.323]   - Field: ‘seed’
[08:27:23.323]   - Field: ‘version’
[08:27:23.323]   - Field: ‘result’
[08:27:23.323]   - Field: ‘asynchronous’
[08:27:23.324]   - Field: ‘calls’
[08:27:23.324]   - Field: ‘globals’
[08:27:23.324]   - Field: ‘stdout’
[08:27:23.324]   - Field: ‘earlySignal’
[08:27:23.324]   - Field: ‘lazy’
[08:27:23.324]   - Field: ‘state’
[08:27:23.324] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:23.324] - Launch lazy future ...
[08:27:23.325] Packages needed by the future expression (n = 1): ‘future’
[08:27:23.325] Packages needed by future strategies (n = 0): <none>
[08:27:23.326] {
[08:27:23.326]     {
[08:27:23.326]         {
[08:27:23.326]             ...future.startTime <- base::Sys.time()
[08:27:23.326]             {
[08:27:23.326]                 {
[08:27:23.326]                   {
[08:27:23.326]                     {
[08:27:23.326]                       base::local({
[08:27:23.326]                         has_future <- base::requireNamespace("future", 
[08:27:23.326]                           quietly = TRUE)
[08:27:23.326]                         if (has_future) {
[08:27:23.326]                           ns <- base::getNamespace("future")
[08:27:23.326]                           version <- ns[[".package"]][["version"]]
[08:27:23.326]                           if (is.null(version)) 
[08:27:23.326]                             version <- utils::packageVersion("future")
[08:27:23.326]                         }
[08:27:23.326]                         else {
[08:27:23.326]                           version <- NULL
[08:27:23.326]                         }
[08:27:23.326]                         if (!has_future || version < "1.8.0") {
[08:27:23.326]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:23.326]                             "", base::R.version$version.string), 
[08:27:23.326]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:23.326]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:23.326]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:23.326]                               "release", "version")], collapse = " "), 
[08:27:23.326]                             hostname = base::Sys.info()[["nodename"]])
[08:27:23.326]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:23.326]                             info)
[08:27:23.326]                           info <- base::paste(info, collapse = "; ")
[08:27:23.326]                           if (!has_future) {
[08:27:23.326]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:23.326]                               info)
[08:27:23.326]                           }
[08:27:23.326]                           else {
[08:27:23.326]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:23.326]                               info, version)
[08:27:23.326]                           }
[08:27:23.326]                           base::stop(msg)
[08:27:23.326]                         }
[08:27:23.326]                       })
[08:27:23.326]                     }
[08:27:23.326]                     base::local({
[08:27:23.326]                       for (pkg in "future") {
[08:27:23.326]                         base::loadNamespace(pkg)
[08:27:23.326]                         base::library(pkg, character.only = TRUE)
[08:27:23.326]                       }
[08:27:23.326]                     })
[08:27:23.326]                   }
[08:27:23.326]                   ...future.strategy.old <- future::plan("list")
[08:27:23.326]                   options(future.plan = NULL)
[08:27:23.326]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:23.326]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:23.326]                 }
[08:27:23.326]                 ...future.workdir <- getwd()
[08:27:23.326]             }
[08:27:23.326]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:23.326]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:23.326]         }
[08:27:23.326]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:23.326]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:23.326]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:23.326]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:23.326]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:23.326]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:23.326]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:23.326]             base::names(...future.oldOptions))
[08:27:23.326]     }
[08:27:23.326]     if (FALSE) {
[08:27:23.326]     }
[08:27:23.326]     else {
[08:27:23.326]         if (TRUE) {
[08:27:23.326]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:23.326]                 open = "w")
[08:27:23.326]         }
[08:27:23.326]         else {
[08:27:23.326]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:23.326]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:23.326]         }
[08:27:23.326]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:23.326]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:23.326]             base::sink(type = "output", split = FALSE)
[08:27:23.326]             base::close(...future.stdout)
[08:27:23.326]         }, add = TRUE)
[08:27:23.326]     }
[08:27:23.326]     ...future.frame <- base::sys.nframe()
[08:27:23.326]     ...future.conditions <- base::list()
[08:27:23.326]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:23.326]     if (FALSE) {
[08:27:23.326]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:23.326]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:23.326]     }
[08:27:23.326]     ...future.result <- base::tryCatch({
[08:27:23.326]         base::withCallingHandlers({
[08:27:23.326]             ...future.value <- base::withVisible(base::local({
[08:27:23.326]                 message(sprintf("Calculating tile #%d of %d ...", 
[08:27:23.326]                   ii, n), appendLF = FALSE)
[08:27:23.326]                 fit <- mandelbrot(C)
[08:27:23.326]                 delay(fit)
[08:27:23.326]                 message(" done")
[08:27:23.326]                 fit
[08:27:23.326]             }))
[08:27:23.326]             future::FutureResult(value = ...future.value$value, 
[08:27:23.326]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:23.326]                   ...future.rng), globalenv = if (FALSE) 
[08:27:23.326]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:23.326]                     ...future.globalenv.names))
[08:27:23.326]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:23.326]         }, condition = base::local({
[08:27:23.326]             c <- base::c
[08:27:23.326]             inherits <- base::inherits
[08:27:23.326]             invokeRestart <- base::invokeRestart
[08:27:23.326]             length <- base::length
[08:27:23.326]             list <- base::list
[08:27:23.326]             seq.int <- base::seq.int
[08:27:23.326]             signalCondition <- base::signalCondition
[08:27:23.326]             sys.calls <- base::sys.calls
[08:27:23.326]             `[[` <- base::`[[`
[08:27:23.326]             `+` <- base::`+`
[08:27:23.326]             `<<-` <- base::`<<-`
[08:27:23.326]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:23.326]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:23.326]                   3L)]
[08:27:23.326]             }
[08:27:23.326]             function(cond) {
[08:27:23.326]                 is_error <- inherits(cond, "error")
[08:27:23.326]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:23.326]                   NULL)
[08:27:23.326]                 if (is_error) {
[08:27:23.326]                   sessionInformation <- function() {
[08:27:23.326]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:23.326]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:23.326]                       search = base::search(), system = base::Sys.info())
[08:27:23.326]                   }
[08:27:23.326]                   ...future.conditions[[length(...future.conditions) + 
[08:27:23.326]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:23.326]                     cond$call), session = sessionInformation(), 
[08:27:23.326]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:23.326]                   signalCondition(cond)
[08:27:23.326]                 }
[08:27:23.326]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:23.326]                 "immediateCondition"))) {
[08:27:23.326]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:23.326]                   ...future.conditions[[length(...future.conditions) + 
[08:27:23.326]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:23.326]                   if (TRUE && !signal) {
[08:27:23.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:23.326]                     {
[08:27:23.326]                       inherits <- base::inherits
[08:27:23.326]                       invokeRestart <- base::invokeRestart
[08:27:23.326]                       is.null <- base::is.null
[08:27:23.326]                       muffled <- FALSE
[08:27:23.326]                       if (inherits(cond, "message")) {
[08:27:23.326]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:23.326]                         if (muffled) 
[08:27:23.326]                           invokeRestart("muffleMessage")
[08:27:23.326]                       }
[08:27:23.326]                       else if (inherits(cond, "warning")) {
[08:27:23.326]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:23.326]                         if (muffled) 
[08:27:23.326]                           invokeRestart("muffleWarning")
[08:27:23.326]                       }
[08:27:23.326]                       else if (inherits(cond, "condition")) {
[08:27:23.326]                         if (!is.null(pattern)) {
[08:27:23.326]                           computeRestarts <- base::computeRestarts
[08:27:23.326]                           grepl <- base::grepl
[08:27:23.326]                           restarts <- computeRestarts(cond)
[08:27:23.326]                           for (restart in restarts) {
[08:27:23.326]                             name <- restart$name
[08:27:23.326]                             if (is.null(name)) 
[08:27:23.326]                               next
[08:27:23.326]                             if (!grepl(pattern, name)) 
[08:27:23.326]                               next
[08:27:23.326]                             invokeRestart(restart)
[08:27:23.326]                             muffled <- TRUE
[08:27:23.326]                             break
[08:27:23.326]                           }
[08:27:23.326]                         }
[08:27:23.326]                       }
[08:27:23.326]                       invisible(muffled)
[08:27:23.326]                     }
[08:27:23.326]                     muffleCondition(cond, pattern = "^muffle")
[08:27:23.326]                   }
[08:27:23.326]                 }
[08:27:23.326]                 else {
[08:27:23.326]                   if (TRUE) {
[08:27:23.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:23.326]                     {
[08:27:23.326]                       inherits <- base::inherits
[08:27:23.326]                       invokeRestart <- base::invokeRestart
[08:27:23.326]                       is.null <- base::is.null
[08:27:23.326]                       muffled <- FALSE
[08:27:23.326]                       if (inherits(cond, "message")) {
[08:27:23.326]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:23.326]                         if (muffled) 
[08:27:23.326]                           invokeRestart("muffleMessage")
[08:27:23.326]                       }
[08:27:23.326]                       else if (inherits(cond, "warning")) {
[08:27:23.326]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:23.326]                         if (muffled) 
[08:27:23.326]                           invokeRestart("muffleWarning")
[08:27:23.326]                       }
[08:27:23.326]                       else if (inherits(cond, "condition")) {
[08:27:23.326]                         if (!is.null(pattern)) {
[08:27:23.326]                           computeRestarts <- base::computeRestarts
[08:27:23.326]                           grepl <- base::grepl
[08:27:23.326]                           restarts <- computeRestarts(cond)
[08:27:23.326]                           for (restart in restarts) {
[08:27:23.326]                             name <- restart$name
[08:27:23.326]                             if (is.null(name)) 
[08:27:23.326]                               next
[08:27:23.326]                             if (!grepl(pattern, name)) 
[08:27:23.326]                               next
[08:27:23.326]                             invokeRestart(restart)
[08:27:23.326]                             muffled <- TRUE
[08:27:23.326]                             break
[08:27:23.326]                           }
[08:27:23.326]                         }
[08:27:23.326]                       }
[08:27:23.326]                       invisible(muffled)
[08:27:23.326]                     }
[08:27:23.326]                     muffleCondition(cond, pattern = "^muffle")
[08:27:23.326]                   }
[08:27:23.326]                 }
[08:27:23.326]             }
[08:27:23.326]         }))
[08:27:23.326]     }, error = function(ex) {
[08:27:23.326]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:23.326]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:23.326]                 ...future.rng), started = ...future.startTime, 
[08:27:23.326]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:23.326]             version = "1.8"), class = "FutureResult")
[08:27:23.326]     }, finally = {
[08:27:23.326]         if (!identical(...future.workdir, getwd())) 
[08:27:23.326]             setwd(...future.workdir)
[08:27:23.326]         {
[08:27:23.326]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:23.326]                 ...future.oldOptions$nwarnings <- NULL
[08:27:23.326]             }
[08:27:23.326]             base::options(...future.oldOptions)
[08:27:23.326]             if (.Platform$OS.type == "windows") {
[08:27:23.326]                 old_names <- names(...future.oldEnvVars)
[08:27:23.326]                 envs <- base::Sys.getenv()
[08:27:23.326]                 names <- names(envs)
[08:27:23.326]                 common <- intersect(names, old_names)
[08:27:23.326]                 added <- setdiff(names, old_names)
[08:27:23.326]                 removed <- setdiff(old_names, names)
[08:27:23.326]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:23.326]                   envs[common]]
[08:27:23.326]                 NAMES <- toupper(changed)
[08:27:23.326]                 args <- list()
[08:27:23.326]                 for (kk in seq_along(NAMES)) {
[08:27:23.326]                   name <- changed[[kk]]
[08:27:23.326]                   NAME <- NAMES[[kk]]
[08:27:23.326]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.326]                     next
[08:27:23.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:23.326]                 }
[08:27:23.326]                 NAMES <- toupper(added)
[08:27:23.326]                 for (kk in seq_along(NAMES)) {
[08:27:23.326]                   name <- added[[kk]]
[08:27:23.326]                   NAME <- NAMES[[kk]]
[08:27:23.326]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.326]                     next
[08:27:23.326]                   args[[name]] <- ""
[08:27:23.326]                 }
[08:27:23.326]                 NAMES <- toupper(removed)
[08:27:23.326]                 for (kk in seq_along(NAMES)) {
[08:27:23.326]                   name <- removed[[kk]]
[08:27:23.326]                   NAME <- NAMES[[kk]]
[08:27:23.326]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.326]                     next
[08:27:23.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:23.326]                 }
[08:27:23.326]                 if (length(args) > 0) 
[08:27:23.326]                   base::do.call(base::Sys.setenv, args = args)
[08:27:23.326]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:23.326]             }
[08:27:23.326]             else {
[08:27:23.326]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:23.326]             }
[08:27:23.326]             {
[08:27:23.326]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:23.326]                   0L) {
[08:27:23.326]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:23.326]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:23.326]                   base::options(opts)
[08:27:23.326]                 }
[08:27:23.326]                 {
[08:27:23.326]                   {
[08:27:23.326]                     NULL
[08:27:23.326]                     RNGkind("Mersenne-Twister")
[08:27:23.326]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:23.326]                       inherits = FALSE)
[08:27:23.326]                   }
[08:27:23.326]                   options(future.plan = NULL)
[08:27:23.326]                   if (is.na(NA_character_)) 
[08:27:23.326]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:23.326]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:23.326]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:23.326]                     .init = FALSE)
[08:27:23.326]                 }
[08:27:23.326]             }
[08:27:23.326]         }
[08:27:23.326]     })
[08:27:23.326]     if (TRUE) {
[08:27:23.326]         base::sink(type = "output", split = FALSE)
[08:27:23.326]         if (TRUE) {
[08:27:23.326]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:23.326]         }
[08:27:23.326]         else {
[08:27:23.326]             ...future.result["stdout"] <- base::list(NULL)
[08:27:23.326]         }
[08:27:23.326]         base::close(...future.stdout)
[08:27:23.326]         ...future.stdout <- NULL
[08:27:23.326]     }
[08:27:23.326]     ...future.result$conditions <- ...future.conditions
[08:27:23.326]     ...future.result$finished <- base::Sys.time()
[08:27:23.326]     ...future.result
[08:27:23.326] }
[08:27:23.327] assign_globals() ...
[08:27:23.328] List of 4
[08:27:23.328]  $ ii   : int 1
[08:27:23.328]  $ n    : int 4
[08:27:23.328]  $ C    : cplx [1:25, 1:25] -2.25-1.5i -2.25-1.44i -2.25-1.38i ...
[08:27:23.328]   ..- attr(*, "region")=List of 2
[08:27:23.328]   .. ..$ xrange: num [1:2] -2.25 -0.781
[08:27:23.328]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[08:27:23.328]   ..- attr(*, "tile")= int [1:2] 1 1
[08:27:23.328]  $ delay:function (counts)  
[08:27:23.328]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[08:27:23.328]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x561de858f950> 
[08:27:23.328]  - attr(*, "where")=List of 4
[08:27:23.328]   ..$ ii   :<environment: R_EmptyEnv> 
[08:27:23.328]   ..$ n    :<environment: R_EmptyEnv> 
[08:27:23.328]   ..$ C    :<environment: R_EmptyEnv> 
[08:27:23.328]   ..$ delay:<environment: R_EmptyEnv> 
[08:27:23.328]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:23.328]  - attr(*, "resolved")= logi FALSE
[08:27:23.328]  - attr(*, "total_size")= num 58781
[08:27:23.328]  - attr(*, "already-done")= logi TRUE
[08:27:23.334] - copied ‘ii’ to environment
[08:27:23.334] - copied ‘n’ to environment
[08:27:23.334] - copied ‘C’ to environment
[08:27:23.335] - reassign environment for ‘delay’
[08:27:23.335] - copied ‘delay’ to environment
[08:27:23.335] assign_globals() ... done
[08:27:23.335] plan(): Setting new future strategy stack:
[08:27:23.335] List of future strategies:
[08:27:23.335] 1. sequential:
[08:27:23.335]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:23.335]    - tweaked: FALSE
[08:27:23.335]    - call: NULL
[08:27:23.336] plan(): nbrOfWorkers() = 1
[08:27:23.355] plan(): Setting new future strategy stack:
[08:27:23.356] List of future strategies:
[08:27:23.356] 1. sequential:
[08:27:23.356]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:23.356]    - tweaked: FALSE
[08:27:23.356]    - call: plan(strategy)
[08:27:23.356] plan(): nbrOfWorkers() = 1
[08:27:23.356] SequentialFuture started (and completed)
[08:27:23.357] signalConditions() ...
[08:27:23.357]  - include = ‘immediateCondition’
[08:27:23.357]  - exclude = 
[08:27:23.357]  - resignal = FALSE
[08:27:23.357]  - Number of conditions: 2
[08:27:23.357] signalConditions() ... done
[08:27:23.357] - Launch lazy future ... done
[08:27:23.357] run() for ‘SequentialFuture’ ... done
[08:27:23.357] - run() ... done
[08:27:23.357] - resolved() ...
[08:27:23.358] resolved() for ‘SequentialFuture’ ...
[08:27:23.358] - state: ‘finished’
[08:27:23.358] - run: TRUE
[08:27:23.358] - result: ‘FutureResult’
[08:27:23.358] resolved() for ‘SequentialFuture’ ... done
[08:27:23.360] - resolved: TRUE
[08:27:23.360] - resolved() ... done
[08:27:23.360] resolved() for ‘SequentialFuture’ ... done
Plotting tile #1 of 4 ...
[08:27:23.361] signalConditions() ...
[08:27:23.361]  - include = ‘immediateCondition’
[08:27:23.361]  - exclude = 
[08:27:23.361]  - resignal = FALSE
[08:27:23.361]  - Number of conditions: 2
[08:27:23.361] signalConditions() ... done
[08:27:23.361] Future state: ‘finished’
[08:27:23.362] signalConditions() ...
[08:27:23.362]  - include = ‘condition’
[08:27:23.362]  - exclude = ‘immediateCondition’
[08:27:23.362]  - resignal = TRUE
[08:27:23.362]  - Number of conditions: 2
[08:27:23.362]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[08:27:23.362]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[08:27:23.362] signalConditions() ... done
[08:27:23.364] resolved() for ‘Future’ ...
[08:27:23.364] - state: ‘created’
[08:27:23.364] - run: TRUE
[08:27:23.364] - run() ...
[08:27:23.365] run() for ‘Future’ ...
[08:27:23.365] - state: ‘created’
[08:27:23.365] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:23.365] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:23.365] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:23.366]   - Field: ‘label’
[08:27:23.366]   - Field: ‘local’
[08:27:23.366]   - Field: ‘owner’
[08:27:23.366]   - Field: ‘envir’
[08:27:23.366]   - Field: ‘packages’
[08:27:23.366]   - Field: ‘gc’
[08:27:23.366]   - Field: ‘conditions’
[08:27:23.366]   - Field: ‘expr’
[08:27:23.366]   - Field: ‘uuid’
[08:27:23.367]   - Field: ‘seed’
[08:27:23.367]   - Field: ‘version’
[08:27:23.367]   - Field: ‘result’
[08:27:23.367]   - Field: ‘asynchronous’
[08:27:23.367]   - Field: ‘calls’
[08:27:23.367]   - Field: ‘globals’
[08:27:23.367]   - Field: ‘stdout’
[08:27:23.367]   - Field: ‘earlySignal’
[08:27:23.368]   - Field: ‘lazy’
[08:27:23.368]   - Field: ‘state’
[08:27:23.368] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:23.368] - Launch lazy future ...
[08:27:23.368] Packages needed by the future expression (n = 1): ‘future’
[08:27:23.368] Packages needed by future strategies (n = 0): <none>
[08:27:23.369] {
[08:27:23.369]     {
[08:27:23.369]         {
[08:27:23.369]             ...future.startTime <- base::Sys.time()
[08:27:23.369]             {
[08:27:23.369]                 {
[08:27:23.369]                   {
[08:27:23.369]                     {
[08:27:23.369]                       base::local({
[08:27:23.369]                         has_future <- base::requireNamespace("future", 
[08:27:23.369]                           quietly = TRUE)
[08:27:23.369]                         if (has_future) {
[08:27:23.369]                           ns <- base::getNamespace("future")
[08:27:23.369]                           version <- ns[[".package"]][["version"]]
[08:27:23.369]                           if (is.null(version)) 
[08:27:23.369]                             version <- utils::packageVersion("future")
[08:27:23.369]                         }
[08:27:23.369]                         else {
[08:27:23.369]                           version <- NULL
[08:27:23.369]                         }
[08:27:23.369]                         if (!has_future || version < "1.8.0") {
[08:27:23.369]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:23.369]                             "", base::R.version$version.string), 
[08:27:23.369]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:23.369]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:23.369]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:23.369]                               "release", "version")], collapse = " "), 
[08:27:23.369]                             hostname = base::Sys.info()[["nodename"]])
[08:27:23.369]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:23.369]                             info)
[08:27:23.369]                           info <- base::paste(info, collapse = "; ")
[08:27:23.369]                           if (!has_future) {
[08:27:23.369]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:23.369]                               info)
[08:27:23.369]                           }
[08:27:23.369]                           else {
[08:27:23.369]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:23.369]                               info, version)
[08:27:23.369]                           }
[08:27:23.369]                           base::stop(msg)
[08:27:23.369]                         }
[08:27:23.369]                       })
[08:27:23.369]                     }
[08:27:23.369]                     base::local({
[08:27:23.369]                       for (pkg in "future") {
[08:27:23.369]                         base::loadNamespace(pkg)
[08:27:23.369]                         base::library(pkg, character.only = TRUE)
[08:27:23.369]                       }
[08:27:23.369]                     })
[08:27:23.369]                   }
[08:27:23.369]                   ...future.strategy.old <- future::plan("list")
[08:27:23.369]                   options(future.plan = NULL)
[08:27:23.369]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:23.369]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:23.369]                 }
[08:27:23.369]                 ...future.workdir <- getwd()
[08:27:23.369]             }
[08:27:23.369]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:23.369]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:23.369]         }
[08:27:23.369]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:23.369]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:23.369]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:23.369]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:23.369]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:23.369]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:23.369]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:23.369]             base::names(...future.oldOptions))
[08:27:23.369]     }
[08:27:23.369]     if (FALSE) {
[08:27:23.369]     }
[08:27:23.369]     else {
[08:27:23.369]         if (TRUE) {
[08:27:23.369]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:23.369]                 open = "w")
[08:27:23.369]         }
[08:27:23.369]         else {
[08:27:23.369]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:23.369]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:23.369]         }
[08:27:23.369]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:23.369]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:23.369]             base::sink(type = "output", split = FALSE)
[08:27:23.369]             base::close(...future.stdout)
[08:27:23.369]         }, add = TRUE)
[08:27:23.369]     }
[08:27:23.369]     ...future.frame <- base::sys.nframe()
[08:27:23.369]     ...future.conditions <- base::list()
[08:27:23.369]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:23.369]     if (FALSE) {
[08:27:23.369]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:23.369]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:23.369]     }
[08:27:23.369]     ...future.result <- base::tryCatch({
[08:27:23.369]         base::withCallingHandlers({
[08:27:23.369]             ...future.value <- base::withVisible(base::local({
[08:27:23.369]                 message(sprintf("Calculating tile #%d of %d ...", 
[08:27:23.369]                   ii, n), appendLF = FALSE)
[08:27:23.369]                 fit <- mandelbrot(C)
[08:27:23.369]                 delay(fit)
[08:27:23.369]                 message(" done")
[08:27:23.369]                 fit
[08:27:23.369]             }))
[08:27:23.369]             future::FutureResult(value = ...future.value$value, 
[08:27:23.369]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:23.369]                   ...future.rng), globalenv = if (FALSE) 
[08:27:23.369]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:23.369]                     ...future.globalenv.names))
[08:27:23.369]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:23.369]         }, condition = base::local({
[08:27:23.369]             c <- base::c
[08:27:23.369]             inherits <- base::inherits
[08:27:23.369]             invokeRestart <- base::invokeRestart
[08:27:23.369]             length <- base::length
[08:27:23.369]             list <- base::list
[08:27:23.369]             seq.int <- base::seq.int
[08:27:23.369]             signalCondition <- base::signalCondition
[08:27:23.369]             sys.calls <- base::sys.calls
[08:27:23.369]             `[[` <- base::`[[`
[08:27:23.369]             `+` <- base::`+`
[08:27:23.369]             `<<-` <- base::`<<-`
[08:27:23.369]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:23.369]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:23.369]                   3L)]
[08:27:23.369]             }
[08:27:23.369]             function(cond) {
[08:27:23.369]                 is_error <- inherits(cond, "error")
[08:27:23.369]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:23.369]                   NULL)
[08:27:23.369]                 if (is_error) {
[08:27:23.369]                   sessionInformation <- function() {
[08:27:23.369]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:23.369]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:23.369]                       search = base::search(), system = base::Sys.info())
[08:27:23.369]                   }
[08:27:23.369]                   ...future.conditions[[length(...future.conditions) + 
[08:27:23.369]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:23.369]                     cond$call), session = sessionInformation(), 
[08:27:23.369]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:23.369]                   signalCondition(cond)
[08:27:23.369]                 }
[08:27:23.369]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:23.369]                 "immediateCondition"))) {
[08:27:23.369]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:23.369]                   ...future.conditions[[length(...future.conditions) + 
[08:27:23.369]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:23.369]                   if (TRUE && !signal) {
[08:27:23.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:23.369]                     {
[08:27:23.369]                       inherits <- base::inherits
[08:27:23.369]                       invokeRestart <- base::invokeRestart
[08:27:23.369]                       is.null <- base::is.null
[08:27:23.369]                       muffled <- FALSE
[08:27:23.369]                       if (inherits(cond, "message")) {
[08:27:23.369]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:23.369]                         if (muffled) 
[08:27:23.369]                           invokeRestart("muffleMessage")
[08:27:23.369]                       }
[08:27:23.369]                       else if (inherits(cond, "warning")) {
[08:27:23.369]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:23.369]                         if (muffled) 
[08:27:23.369]                           invokeRestart("muffleWarning")
[08:27:23.369]                       }
[08:27:23.369]                       else if (inherits(cond, "condition")) {
[08:27:23.369]                         if (!is.null(pattern)) {
[08:27:23.369]                           computeRestarts <- base::computeRestarts
[08:27:23.369]                           grepl <- base::grepl
[08:27:23.369]                           restarts <- computeRestarts(cond)
[08:27:23.369]                           for (restart in restarts) {
[08:27:23.369]                             name <- restart$name
[08:27:23.369]                             if (is.null(name)) 
[08:27:23.369]                               next
[08:27:23.369]                             if (!grepl(pattern, name)) 
[08:27:23.369]                               next
[08:27:23.369]                             invokeRestart(restart)
[08:27:23.369]                             muffled <- TRUE
[08:27:23.369]                             break
[08:27:23.369]                           }
[08:27:23.369]                         }
[08:27:23.369]                       }
[08:27:23.369]                       invisible(muffled)
[08:27:23.369]                     }
[08:27:23.369]                     muffleCondition(cond, pattern = "^muffle")
[08:27:23.369]                   }
[08:27:23.369]                 }
[08:27:23.369]                 else {
[08:27:23.369]                   if (TRUE) {
[08:27:23.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:23.369]                     {
[08:27:23.369]                       inherits <- base::inherits
[08:27:23.369]                       invokeRestart <- base::invokeRestart
[08:27:23.369]                       is.null <- base::is.null
[08:27:23.369]                       muffled <- FALSE
[08:27:23.369]                       if (inherits(cond, "message")) {
[08:27:23.369]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:23.369]                         if (muffled) 
[08:27:23.369]                           invokeRestart("muffleMessage")
[08:27:23.369]                       }
[08:27:23.369]                       else if (inherits(cond, "warning")) {
[08:27:23.369]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:23.369]                         if (muffled) 
[08:27:23.369]                           invokeRestart("muffleWarning")
[08:27:23.369]                       }
[08:27:23.369]                       else if (inherits(cond, "condition")) {
[08:27:23.369]                         if (!is.null(pattern)) {
[08:27:23.369]                           computeRestarts <- base::computeRestarts
[08:27:23.369]                           grepl <- base::grepl
[08:27:23.369]                           restarts <- computeRestarts(cond)
[08:27:23.369]                           for (restart in restarts) {
[08:27:23.369]                             name <- restart$name
[08:27:23.369]                             if (is.null(name)) 
[08:27:23.369]                               next
[08:27:23.369]                             if (!grepl(pattern, name)) 
[08:27:23.369]                               next
[08:27:23.369]                             invokeRestart(restart)
[08:27:23.369]                             muffled <- TRUE
[08:27:23.369]                             break
[08:27:23.369]                           }
[08:27:23.369]                         }
[08:27:23.369]                       }
[08:27:23.369]                       invisible(muffled)
[08:27:23.369]                     }
[08:27:23.369]                     muffleCondition(cond, pattern = "^muffle")
[08:27:23.369]                   }
[08:27:23.369]                 }
[08:27:23.369]             }
[08:27:23.369]         }))
[08:27:23.369]     }, error = function(ex) {
[08:27:23.369]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:23.369]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:23.369]                 ...future.rng), started = ...future.startTime, 
[08:27:23.369]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:23.369]             version = "1.8"), class = "FutureResult")
[08:27:23.369]     }, finally = {
[08:27:23.369]         if (!identical(...future.workdir, getwd())) 
[08:27:23.369]             setwd(...future.workdir)
[08:27:23.369]         {
[08:27:23.369]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:23.369]                 ...future.oldOptions$nwarnings <- NULL
[08:27:23.369]             }
[08:27:23.369]             base::options(...future.oldOptions)
[08:27:23.369]             if (.Platform$OS.type == "windows") {
[08:27:23.369]                 old_names <- names(...future.oldEnvVars)
[08:27:23.369]                 envs <- base::Sys.getenv()
[08:27:23.369]                 names <- names(envs)
[08:27:23.369]                 common <- intersect(names, old_names)
[08:27:23.369]                 added <- setdiff(names, old_names)
[08:27:23.369]                 removed <- setdiff(old_names, names)
[08:27:23.369]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:23.369]                   envs[common]]
[08:27:23.369]                 NAMES <- toupper(changed)
[08:27:23.369]                 args <- list()
[08:27:23.369]                 for (kk in seq_along(NAMES)) {
[08:27:23.369]                   name <- changed[[kk]]
[08:27:23.369]                   NAME <- NAMES[[kk]]
[08:27:23.369]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.369]                     next
[08:27:23.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:23.369]                 }
[08:27:23.369]                 NAMES <- toupper(added)
[08:27:23.369]                 for (kk in seq_along(NAMES)) {
[08:27:23.369]                   name <- added[[kk]]
[08:27:23.369]                   NAME <- NAMES[[kk]]
[08:27:23.369]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.369]                     next
[08:27:23.369]                   args[[name]] <- ""
[08:27:23.369]                 }
[08:27:23.369]                 NAMES <- toupper(removed)
[08:27:23.369]                 for (kk in seq_along(NAMES)) {
[08:27:23.369]                   name <- removed[[kk]]
[08:27:23.369]                   NAME <- NAMES[[kk]]
[08:27:23.369]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.369]                     next
[08:27:23.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:23.369]                 }
[08:27:23.369]                 if (length(args) > 0) 
[08:27:23.369]                   base::do.call(base::Sys.setenv, args = args)
[08:27:23.369]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:23.369]             }
[08:27:23.369]             else {
[08:27:23.369]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:23.369]             }
[08:27:23.369]             {
[08:27:23.369]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:23.369]                   0L) {
[08:27:23.369]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:23.369]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:23.369]                   base::options(opts)
[08:27:23.369]                 }
[08:27:23.369]                 {
[08:27:23.369]                   {
[08:27:23.369]                     NULL
[08:27:23.369]                     RNGkind("Mersenne-Twister")
[08:27:23.369]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:23.369]                       inherits = FALSE)
[08:27:23.369]                   }
[08:27:23.369]                   options(future.plan = NULL)
[08:27:23.369]                   if (is.na(NA_character_)) 
[08:27:23.369]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:23.369]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:23.369]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:23.369]                     .init = FALSE)
[08:27:23.369]                 }
[08:27:23.369]             }
[08:27:23.369]         }
[08:27:23.369]     })
[08:27:23.369]     if (TRUE) {
[08:27:23.369]         base::sink(type = "output", split = FALSE)
[08:27:23.369]         if (TRUE) {
[08:27:23.369]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:23.369]         }
[08:27:23.369]         else {
[08:27:23.369]             ...future.result["stdout"] <- base::list(NULL)
[08:27:23.369]         }
[08:27:23.369]         base::close(...future.stdout)
[08:27:23.369]         ...future.stdout <- NULL
[08:27:23.369]     }
[08:27:23.369]     ...future.result$conditions <- ...future.conditions
[08:27:23.369]     ...future.result$finished <- base::Sys.time()
[08:27:23.369]     ...future.result
[08:27:23.369] }
[08:27:23.371] assign_globals() ...
[08:27:23.371] List of 4
[08:27:23.371]  $ ii   : int 2
[08:27:23.371]  $ n    : int 4
[08:27:23.371]  $ C    : cplx [1:25, 1:25] -0.719-1.5i -0.719-1.44i -0.719-1.38i ...
[08:27:23.371]   ..- attr(*, "region")=List of 2
[08:27:23.371]   .. ..$ xrange: num [1:2] -0.719 0.75
[08:27:23.371]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[08:27:23.371]   ..- attr(*, "tile")= int [1:2] 1 2
[08:27:23.371]  $ delay:function (counts)  
[08:27:23.371]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[08:27:23.371]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x561de858f950> 
[08:27:23.371]  - attr(*, "where")=List of 4
[08:27:23.371]   ..$ ii   :<environment: R_EmptyEnv> 
[08:27:23.371]   ..$ n    :<environment: R_EmptyEnv> 
[08:27:23.371]   ..$ C    :<environment: R_EmptyEnv> 
[08:27:23.371]   ..$ delay:<environment: R_EmptyEnv> 
[08:27:23.371]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:23.371]  - attr(*, "resolved")= logi FALSE
[08:27:23.371]  - attr(*, "total_size")= num 58781
[08:27:23.371]  - attr(*, "already-done")= logi TRUE
[08:27:23.377] - copied ‘ii’ to environment
[08:27:23.377] - copied ‘n’ to environment
[08:27:23.377] - copied ‘C’ to environment
[08:27:23.377] - reassign environment for ‘delay’
[08:27:23.377] - copied ‘delay’ to environment
[08:27:23.378] assign_globals() ... done
[08:27:23.378] plan(): Setting new future strategy stack:
[08:27:23.378] List of future strategies:
[08:27:23.378] 1. sequential:
[08:27:23.378]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:23.378]    - tweaked: FALSE
[08:27:23.378]    - call: NULL
[08:27:23.379] plan(): nbrOfWorkers() = 1
[08:27:23.439] plan(): Setting new future strategy stack:
[08:27:23.439] List of future strategies:
[08:27:23.439] 1. sequential:
[08:27:23.439]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:23.439]    - tweaked: FALSE
[08:27:23.439]    - call: plan(strategy)
[08:27:23.440] plan(): nbrOfWorkers() = 1
[08:27:23.440] SequentialFuture started (and completed)
[08:27:23.440] signalConditions() ...
[08:27:23.440]  - include = ‘immediateCondition’
[08:27:23.440]  - exclude = 
[08:27:23.440]  - resignal = FALSE
[08:27:23.440]  - Number of conditions: 2
[08:27:23.440] signalConditions() ... done
[08:27:23.441] - Launch lazy future ... done
[08:27:23.441] run() for ‘SequentialFuture’ ... done
[08:27:23.441] - run() ... done
[08:27:23.441] - resolved() ...
[08:27:23.441] resolved() for ‘SequentialFuture’ ...
[08:27:23.441] - state: ‘finished’
[08:27:23.441] - run: TRUE
[08:27:23.441] - result: ‘FutureResult’
[08:27:23.441] resolved() for ‘SequentialFuture’ ... done
[08:27:23.441] - resolved: TRUE
[08:27:23.441] - resolved() ... done
[08:27:23.441] resolved() for ‘SequentialFuture’ ... done
Plotting tile #2 of 4 ...
[08:27:23.442] signalConditions() ...
[08:27:23.442]  - include = ‘immediateCondition’
[08:27:23.442]  - exclude = 
[08:27:23.442]  - resignal = FALSE
[08:27:23.442]  - Number of conditions: 2
[08:27:23.442] signalConditions() ... done
[08:27:23.442] Future state: ‘finished’
[08:27:23.442] signalConditions() ...
[08:27:23.442]  - include = ‘condition’
[08:27:23.442]  - exclude = ‘immediateCondition’
[08:27:23.442]  - resignal = TRUE
[08:27:23.443]  - Number of conditions: 2
[08:27:23.443]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[08:27:23.443]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[08:27:23.443] signalConditions() ... done
[08:27:23.443] resolved() for ‘Future’ ...
[08:27:23.444] - state: ‘created’
[08:27:23.444] - run: TRUE
[08:27:23.444] - run() ...
[08:27:23.444] run() for ‘Future’ ...
[08:27:23.444] - state: ‘created’
[08:27:23.444] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:23.444] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:23.444] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:23.445]   - Field: ‘label’
[08:27:23.445]   - Field: ‘local’
[08:27:23.445]   - Field: ‘owner’
[08:27:23.445]   - Field: ‘envir’
[08:27:23.445]   - Field: ‘packages’
[08:27:23.445]   - Field: ‘gc’
[08:27:23.445]   - Field: ‘conditions’
[08:27:23.445]   - Field: ‘expr’
[08:27:23.445]   - Field: ‘uuid’
[08:27:23.445]   - Field: ‘seed’
[08:27:23.445]   - Field: ‘version’
[08:27:23.445]   - Field: ‘result’
[08:27:23.446]   - Field: ‘asynchronous’
[08:27:23.446]   - Field: ‘calls’
[08:27:23.446]   - Field: ‘globals’
[08:27:23.446]   - Field: ‘stdout’
[08:27:23.446]   - Field: ‘earlySignal’
[08:27:23.446]   - Field: ‘lazy’
[08:27:23.446]   - Field: ‘state’
[08:27:23.446] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:23.446] - Launch lazy future ...
[08:27:23.446] Packages needed by the future expression (n = 1): ‘future’
[08:27:23.447] Packages needed by future strategies (n = 0): <none>
[08:27:23.447] {
[08:27:23.447]     {
[08:27:23.447]         {
[08:27:23.447]             ...future.startTime <- base::Sys.time()
[08:27:23.447]             {
[08:27:23.447]                 {
[08:27:23.447]                   {
[08:27:23.447]                     {
[08:27:23.447]                       base::local({
[08:27:23.447]                         has_future <- base::requireNamespace("future", 
[08:27:23.447]                           quietly = TRUE)
[08:27:23.447]                         if (has_future) {
[08:27:23.447]                           ns <- base::getNamespace("future")
[08:27:23.447]                           version <- ns[[".package"]][["version"]]
[08:27:23.447]                           if (is.null(version)) 
[08:27:23.447]                             version <- utils::packageVersion("future")
[08:27:23.447]                         }
[08:27:23.447]                         else {
[08:27:23.447]                           version <- NULL
[08:27:23.447]                         }
[08:27:23.447]                         if (!has_future || version < "1.8.0") {
[08:27:23.447]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:23.447]                             "", base::R.version$version.string), 
[08:27:23.447]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:23.447]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:23.447]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:23.447]                               "release", "version")], collapse = " "), 
[08:27:23.447]                             hostname = base::Sys.info()[["nodename"]])
[08:27:23.447]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:23.447]                             info)
[08:27:23.447]                           info <- base::paste(info, collapse = "; ")
[08:27:23.447]                           if (!has_future) {
[08:27:23.447]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:23.447]                               info)
[08:27:23.447]                           }
[08:27:23.447]                           else {
[08:27:23.447]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:23.447]                               info, version)
[08:27:23.447]                           }
[08:27:23.447]                           base::stop(msg)
[08:27:23.447]                         }
[08:27:23.447]                       })
[08:27:23.447]                     }
[08:27:23.447]                     base::local({
[08:27:23.447]                       for (pkg in "future") {
[08:27:23.447]                         base::loadNamespace(pkg)
[08:27:23.447]                         base::library(pkg, character.only = TRUE)
[08:27:23.447]                       }
[08:27:23.447]                     })
[08:27:23.447]                   }
[08:27:23.447]                   ...future.strategy.old <- future::plan("list")
[08:27:23.447]                   options(future.plan = NULL)
[08:27:23.447]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:23.447]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:23.447]                 }
[08:27:23.447]                 ...future.workdir <- getwd()
[08:27:23.447]             }
[08:27:23.447]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:23.447]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:23.447]         }
[08:27:23.447]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:23.447]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:23.447]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:23.447]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:23.447]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:23.447]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:23.447]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:23.447]             base::names(...future.oldOptions))
[08:27:23.447]     }
[08:27:23.447]     if (FALSE) {
[08:27:23.447]     }
[08:27:23.447]     else {
[08:27:23.447]         if (TRUE) {
[08:27:23.447]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:23.447]                 open = "w")
[08:27:23.447]         }
[08:27:23.447]         else {
[08:27:23.447]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:23.447]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:23.447]         }
[08:27:23.447]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:23.447]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:23.447]             base::sink(type = "output", split = FALSE)
[08:27:23.447]             base::close(...future.stdout)
[08:27:23.447]         }, add = TRUE)
[08:27:23.447]     }
[08:27:23.447]     ...future.frame <- base::sys.nframe()
[08:27:23.447]     ...future.conditions <- base::list()
[08:27:23.447]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:23.447]     if (FALSE) {
[08:27:23.447]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:23.447]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:23.447]     }
[08:27:23.447]     ...future.result <- base::tryCatch({
[08:27:23.447]         base::withCallingHandlers({
[08:27:23.447]             ...future.value <- base::withVisible(base::local({
[08:27:23.447]                 message(sprintf("Calculating tile #%d of %d ...", 
[08:27:23.447]                   ii, n), appendLF = FALSE)
[08:27:23.447]                 fit <- mandelbrot(C)
[08:27:23.447]                 delay(fit)
[08:27:23.447]                 message(" done")
[08:27:23.447]                 fit
[08:27:23.447]             }))
[08:27:23.447]             future::FutureResult(value = ...future.value$value, 
[08:27:23.447]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:23.447]                   ...future.rng), globalenv = if (FALSE) 
[08:27:23.447]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:23.447]                     ...future.globalenv.names))
[08:27:23.447]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:23.447]         }, condition = base::local({
[08:27:23.447]             c <- base::c
[08:27:23.447]             inherits <- base::inherits
[08:27:23.447]             invokeRestart <- base::invokeRestart
[08:27:23.447]             length <- base::length
[08:27:23.447]             list <- base::list
[08:27:23.447]             seq.int <- base::seq.int
[08:27:23.447]             signalCondition <- base::signalCondition
[08:27:23.447]             sys.calls <- base::sys.calls
[08:27:23.447]             `[[` <- base::`[[`
[08:27:23.447]             `+` <- base::`+`
[08:27:23.447]             `<<-` <- base::`<<-`
[08:27:23.447]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:23.447]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:23.447]                   3L)]
[08:27:23.447]             }
[08:27:23.447]             function(cond) {
[08:27:23.447]                 is_error <- inherits(cond, "error")
[08:27:23.447]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:23.447]                   NULL)
[08:27:23.447]                 if (is_error) {
[08:27:23.447]                   sessionInformation <- function() {
[08:27:23.447]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:23.447]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:23.447]                       search = base::search(), system = base::Sys.info())
[08:27:23.447]                   }
[08:27:23.447]                   ...future.conditions[[length(...future.conditions) + 
[08:27:23.447]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:23.447]                     cond$call), session = sessionInformation(), 
[08:27:23.447]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:23.447]                   signalCondition(cond)
[08:27:23.447]                 }
[08:27:23.447]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:23.447]                 "immediateCondition"))) {
[08:27:23.447]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:23.447]                   ...future.conditions[[length(...future.conditions) + 
[08:27:23.447]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:23.447]                   if (TRUE && !signal) {
[08:27:23.447]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:23.447]                     {
[08:27:23.447]                       inherits <- base::inherits
[08:27:23.447]                       invokeRestart <- base::invokeRestart
[08:27:23.447]                       is.null <- base::is.null
[08:27:23.447]                       muffled <- FALSE
[08:27:23.447]                       if (inherits(cond, "message")) {
[08:27:23.447]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:23.447]                         if (muffled) 
[08:27:23.447]                           invokeRestart("muffleMessage")
[08:27:23.447]                       }
[08:27:23.447]                       else if (inherits(cond, "warning")) {
[08:27:23.447]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:23.447]                         if (muffled) 
[08:27:23.447]                           invokeRestart("muffleWarning")
[08:27:23.447]                       }
[08:27:23.447]                       else if (inherits(cond, "condition")) {
[08:27:23.447]                         if (!is.null(pattern)) {
[08:27:23.447]                           computeRestarts <- base::computeRestarts
[08:27:23.447]                           grepl <- base::grepl
[08:27:23.447]                           restarts <- computeRestarts(cond)
[08:27:23.447]                           for (restart in restarts) {
[08:27:23.447]                             name <- restart$name
[08:27:23.447]                             if (is.null(name)) 
[08:27:23.447]                               next
[08:27:23.447]                             if (!grepl(pattern, name)) 
[08:27:23.447]                               next
[08:27:23.447]                             invokeRestart(restart)
[08:27:23.447]                             muffled <- TRUE
[08:27:23.447]                             break
[08:27:23.447]                           }
[08:27:23.447]                         }
[08:27:23.447]                       }
[08:27:23.447]                       invisible(muffled)
[08:27:23.447]                     }
[08:27:23.447]                     muffleCondition(cond, pattern = "^muffle")
[08:27:23.447]                   }
[08:27:23.447]                 }
[08:27:23.447]                 else {
[08:27:23.447]                   if (TRUE) {
[08:27:23.447]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:23.447]                     {
[08:27:23.447]                       inherits <- base::inherits
[08:27:23.447]                       invokeRestart <- base::invokeRestart
[08:27:23.447]                       is.null <- base::is.null
[08:27:23.447]                       muffled <- FALSE
[08:27:23.447]                       if (inherits(cond, "message")) {
[08:27:23.447]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:23.447]                         if (muffled) 
[08:27:23.447]                           invokeRestart("muffleMessage")
[08:27:23.447]                       }
[08:27:23.447]                       else if (inherits(cond, "warning")) {
[08:27:23.447]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:23.447]                         if (muffled) 
[08:27:23.447]                           invokeRestart("muffleWarning")
[08:27:23.447]                       }
[08:27:23.447]                       else if (inherits(cond, "condition")) {
[08:27:23.447]                         if (!is.null(pattern)) {
[08:27:23.447]                           computeRestarts <- base::computeRestarts
[08:27:23.447]                           grepl <- base::grepl
[08:27:23.447]                           restarts <- computeRestarts(cond)
[08:27:23.447]                           for (restart in restarts) {
[08:27:23.447]                             name <- restart$name
[08:27:23.447]                             if (is.null(name)) 
[08:27:23.447]                               next
[08:27:23.447]                             if (!grepl(pattern, name)) 
[08:27:23.447]                               next
[08:27:23.447]                             invokeRestart(restart)
[08:27:23.447]                             muffled <- TRUE
[08:27:23.447]                             break
[08:27:23.447]                           }
[08:27:23.447]                         }
[08:27:23.447]                       }
[08:27:23.447]                       invisible(muffled)
[08:27:23.447]                     }
[08:27:23.447]                     muffleCondition(cond, pattern = "^muffle")
[08:27:23.447]                   }
[08:27:23.447]                 }
[08:27:23.447]             }
[08:27:23.447]         }))
[08:27:23.447]     }, error = function(ex) {
[08:27:23.447]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:23.447]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:23.447]                 ...future.rng), started = ...future.startTime, 
[08:27:23.447]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:23.447]             version = "1.8"), class = "FutureResult")
[08:27:23.447]     }, finally = {
[08:27:23.447]         if (!identical(...future.workdir, getwd())) 
[08:27:23.447]             setwd(...future.workdir)
[08:27:23.447]         {
[08:27:23.447]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:23.447]                 ...future.oldOptions$nwarnings <- NULL
[08:27:23.447]             }
[08:27:23.447]             base::options(...future.oldOptions)
[08:27:23.447]             if (.Platform$OS.type == "windows") {
[08:27:23.447]                 old_names <- names(...future.oldEnvVars)
[08:27:23.447]                 envs <- base::Sys.getenv()
[08:27:23.447]                 names <- names(envs)
[08:27:23.447]                 common <- intersect(names, old_names)
[08:27:23.447]                 added <- setdiff(names, old_names)
[08:27:23.447]                 removed <- setdiff(old_names, names)
[08:27:23.447]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:23.447]                   envs[common]]
[08:27:23.447]                 NAMES <- toupper(changed)
[08:27:23.447]                 args <- list()
[08:27:23.447]                 for (kk in seq_along(NAMES)) {
[08:27:23.447]                   name <- changed[[kk]]
[08:27:23.447]                   NAME <- NAMES[[kk]]
[08:27:23.447]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.447]                     next
[08:27:23.447]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:23.447]                 }
[08:27:23.447]                 NAMES <- toupper(added)
[08:27:23.447]                 for (kk in seq_along(NAMES)) {
[08:27:23.447]                   name <- added[[kk]]
[08:27:23.447]                   NAME <- NAMES[[kk]]
[08:27:23.447]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.447]                     next
[08:27:23.447]                   args[[name]] <- ""
[08:27:23.447]                 }
[08:27:23.447]                 NAMES <- toupper(removed)
[08:27:23.447]                 for (kk in seq_along(NAMES)) {
[08:27:23.447]                   name <- removed[[kk]]
[08:27:23.447]                   NAME <- NAMES[[kk]]
[08:27:23.447]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.447]                     next
[08:27:23.447]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:23.447]                 }
[08:27:23.447]                 if (length(args) > 0) 
[08:27:23.447]                   base::do.call(base::Sys.setenv, args = args)
[08:27:23.447]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:23.447]             }
[08:27:23.447]             else {
[08:27:23.447]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:23.447]             }
[08:27:23.447]             {
[08:27:23.447]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:23.447]                   0L) {
[08:27:23.447]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:23.447]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:23.447]                   base::options(opts)
[08:27:23.447]                 }
[08:27:23.447]                 {
[08:27:23.447]                   {
[08:27:23.447]                     NULL
[08:27:23.447]                     RNGkind("Mersenne-Twister")
[08:27:23.447]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:23.447]                       inherits = FALSE)
[08:27:23.447]                   }
[08:27:23.447]                   options(future.plan = NULL)
[08:27:23.447]                   if (is.na(NA_character_)) 
[08:27:23.447]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:23.447]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:23.447]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:23.447]                     .init = FALSE)
[08:27:23.447]                 }
[08:27:23.447]             }
[08:27:23.447]         }
[08:27:23.447]     })
[08:27:23.447]     if (TRUE) {
[08:27:23.447]         base::sink(type = "output", split = FALSE)
[08:27:23.447]         if (TRUE) {
[08:27:23.447]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:23.447]         }
[08:27:23.447]         else {
[08:27:23.447]             ...future.result["stdout"] <- base::list(NULL)
[08:27:23.447]         }
[08:27:23.447]         base::close(...future.stdout)
[08:27:23.447]         ...future.stdout <- NULL
[08:27:23.447]     }
[08:27:23.447]     ...future.result$conditions <- ...future.conditions
[08:27:23.447]     ...future.result$finished <- base::Sys.time()
[08:27:23.447]     ...future.result
[08:27:23.447] }
[08:27:23.449] assign_globals() ...
[08:27:23.449] List of 4
[08:27:23.449]  $ ii   : int 3
[08:27:23.449]  $ n    : int 4
[08:27:23.449]  $ C    : cplx [1:25, 1:25] -2.25+0.0306i -2.25+0.0918i -2.25+0.1531i ...
[08:27:23.449]   ..- attr(*, "region")=List of 2
[08:27:23.449]   .. ..$ xrange: num [1:2] -2.25 -0.781
[08:27:23.449]   .. ..$ yrange: num [1:2] 0.0306 1.5
[08:27:23.449]   ..- attr(*, "tile")= int [1:2] 2 1
[08:27:23.449]  $ delay:function (counts)  
[08:27:23.449]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[08:27:23.449]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x561de858f950> 
[08:27:23.449]  - attr(*, "where")=List of 4
[08:27:23.449]   ..$ ii   :<environment: R_EmptyEnv> 
[08:27:23.449]   ..$ n    :<environment: R_EmptyEnv> 
[08:27:23.449]   ..$ C    :<environment: R_EmptyEnv> 
[08:27:23.449]   ..$ delay:<environment: R_EmptyEnv> 
[08:27:23.449]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:23.449]  - attr(*, "resolved")= logi FALSE
[08:27:23.449]  - attr(*, "total_size")= num 58781
[08:27:23.449]  - attr(*, "already-done")= logi TRUE
[08:27:23.455] - copied ‘ii’ to environment
[08:27:23.455] - copied ‘n’ to environment
[08:27:23.455] - copied ‘C’ to environment
[08:27:23.455] - reassign environment for ‘delay’
[08:27:23.455] - copied ‘delay’ to environment
[08:27:23.455] assign_globals() ... done
[08:27:23.456] plan(): Setting new future strategy stack:
[08:27:23.456] List of future strategies:
[08:27:23.456] 1. sequential:
[08:27:23.456]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:23.456]    - tweaked: FALSE
[08:27:23.456]    - call: NULL
[08:27:23.456] plan(): nbrOfWorkers() = 1
[08:27:23.472] plan(): Setting new future strategy stack:
[08:27:23.472] List of future strategies:
[08:27:23.472] 1. sequential:
[08:27:23.472]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:23.472]    - tweaked: FALSE
[08:27:23.472]    - call: plan(strategy)
[08:27:23.473] plan(): nbrOfWorkers() = 1
[08:27:23.473] SequentialFuture started (and completed)
[08:27:23.473] signalConditions() ...
[08:27:23.473]  - include = ‘immediateCondition’
[08:27:23.473]  - exclude = 
[08:27:23.473]  - resignal = FALSE
[08:27:23.474]  - Number of conditions: 2
[08:27:23.474] signalConditions() ... done
[08:27:23.474] - Launch lazy future ... done
[08:27:23.474] run() for ‘SequentialFuture’ ... done
[08:27:23.474] - run() ... done
[08:27:23.474] - resolved() ...
[08:27:23.474] resolved() for ‘SequentialFuture’ ...
[08:27:23.474] - state: ‘finished’
[08:27:23.474] - run: TRUE
[08:27:23.474] - result: ‘FutureResult’
[08:27:23.474] resolved() for ‘SequentialFuture’ ... done
[08:27:23.475] - resolved: TRUE
[08:27:23.475] - resolved() ... done
[08:27:23.475] resolved() for ‘SequentialFuture’ ... done
Plotting tile #3 of 4 ...
[08:27:23.475] signalConditions() ...
[08:27:23.475]  - include = ‘immediateCondition’
[08:27:23.475]  - exclude = 
[08:27:23.475]  - resignal = FALSE
[08:27:23.475]  - Number of conditions: 2
[08:27:23.475] signalConditions() ... done
[08:27:23.475] Future state: ‘finished’
[08:27:23.476] signalConditions() ...
[08:27:23.476]  - include = ‘condition’
[08:27:23.476]  - exclude = ‘immediateCondition’
[08:27:23.476]  - resignal = TRUE
[08:27:23.476]  - Number of conditions: 2
[08:27:23.476]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[08:27:23.476]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[08:27:23.476] signalConditions() ... done
[08:27:23.477] resolved() for ‘Future’ ...
[08:27:23.477] - state: ‘created’
[08:27:23.477] - run: TRUE
[08:27:23.477] - run() ...
[08:27:23.477] run() for ‘Future’ ...
[08:27:23.477] - state: ‘created’
[08:27:23.477] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:23.478] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:23.478] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:23.478]   - Field: ‘label’
[08:27:23.478]   - Field: ‘local’
[08:27:23.478]   - Field: ‘owner’
[08:27:23.478]   - Field: ‘envir’
[08:27:23.478]   - Field: ‘packages’
[08:27:23.478]   - Field: ‘gc’
[08:27:23.479]   - Field: ‘conditions’
[08:27:23.479]   - Field: ‘expr’
[08:27:23.479]   - Field: ‘uuid’
[08:27:23.479]   - Field: ‘seed’
[08:27:23.479]   - Field: ‘version’
[08:27:23.479]   - Field: ‘result’
[08:27:23.479]   - Field: ‘asynchronous’
[08:27:23.479]   - Field: ‘calls’
[08:27:23.479]   - Field: ‘globals’
[08:27:23.479]   - Field: ‘stdout’
[08:27:23.479]   - Field: ‘earlySignal’
[08:27:23.479]   - Field: ‘lazy’
[08:27:23.480]   - Field: ‘state’
[08:27:23.480] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:23.480] - Launch lazy future ...
[08:27:23.480] Packages needed by the future expression (n = 1): ‘future’
[08:27:23.480] Packages needed by future strategies (n = 0): <none>
[08:27:23.481] {
[08:27:23.481]     {
[08:27:23.481]         {
[08:27:23.481]             ...future.startTime <- base::Sys.time()
[08:27:23.481]             {
[08:27:23.481]                 {
[08:27:23.481]                   {
[08:27:23.481]                     {
[08:27:23.481]                       base::local({
[08:27:23.481]                         has_future <- base::requireNamespace("future", 
[08:27:23.481]                           quietly = TRUE)
[08:27:23.481]                         if (has_future) {
[08:27:23.481]                           ns <- base::getNamespace("future")
[08:27:23.481]                           version <- ns[[".package"]][["version"]]
[08:27:23.481]                           if (is.null(version)) 
[08:27:23.481]                             version <- utils::packageVersion("future")
[08:27:23.481]                         }
[08:27:23.481]                         else {
[08:27:23.481]                           version <- NULL
[08:27:23.481]                         }
[08:27:23.481]                         if (!has_future || version < "1.8.0") {
[08:27:23.481]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:23.481]                             "", base::R.version$version.string), 
[08:27:23.481]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:23.481]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:23.481]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:23.481]                               "release", "version")], collapse = " "), 
[08:27:23.481]                             hostname = base::Sys.info()[["nodename"]])
[08:27:23.481]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:23.481]                             info)
[08:27:23.481]                           info <- base::paste(info, collapse = "; ")
[08:27:23.481]                           if (!has_future) {
[08:27:23.481]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:23.481]                               info)
[08:27:23.481]                           }
[08:27:23.481]                           else {
[08:27:23.481]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:23.481]                               info, version)
[08:27:23.481]                           }
[08:27:23.481]                           base::stop(msg)
[08:27:23.481]                         }
[08:27:23.481]                       })
[08:27:23.481]                     }
[08:27:23.481]                     base::local({
[08:27:23.481]                       for (pkg in "future") {
[08:27:23.481]                         base::loadNamespace(pkg)
[08:27:23.481]                         base::library(pkg, character.only = TRUE)
[08:27:23.481]                       }
[08:27:23.481]                     })
[08:27:23.481]                   }
[08:27:23.481]                   ...future.strategy.old <- future::plan("list")
[08:27:23.481]                   options(future.plan = NULL)
[08:27:23.481]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:23.481]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:23.481]                 }
[08:27:23.481]                 ...future.workdir <- getwd()
[08:27:23.481]             }
[08:27:23.481]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:23.481]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:23.481]         }
[08:27:23.481]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:23.481]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:23.481]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:23.481]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:23.481]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:23.481]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:23.481]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:23.481]             base::names(...future.oldOptions))
[08:27:23.481]     }
[08:27:23.481]     if (FALSE) {
[08:27:23.481]     }
[08:27:23.481]     else {
[08:27:23.481]         if (TRUE) {
[08:27:23.481]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:23.481]                 open = "w")
[08:27:23.481]         }
[08:27:23.481]         else {
[08:27:23.481]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:23.481]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:23.481]         }
[08:27:23.481]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:23.481]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:23.481]             base::sink(type = "output", split = FALSE)
[08:27:23.481]             base::close(...future.stdout)
[08:27:23.481]         }, add = TRUE)
[08:27:23.481]     }
[08:27:23.481]     ...future.frame <- base::sys.nframe()
[08:27:23.481]     ...future.conditions <- base::list()
[08:27:23.481]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:23.481]     if (FALSE) {
[08:27:23.481]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:23.481]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:23.481]     }
[08:27:23.481]     ...future.result <- base::tryCatch({
[08:27:23.481]         base::withCallingHandlers({
[08:27:23.481]             ...future.value <- base::withVisible(base::local({
[08:27:23.481]                 message(sprintf("Calculating tile #%d of %d ...", 
[08:27:23.481]                   ii, n), appendLF = FALSE)
[08:27:23.481]                 fit <- mandelbrot(C)
[08:27:23.481]                 delay(fit)
[08:27:23.481]                 message(" done")
[08:27:23.481]                 fit
[08:27:23.481]             }))
[08:27:23.481]             future::FutureResult(value = ...future.value$value, 
[08:27:23.481]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:23.481]                   ...future.rng), globalenv = if (FALSE) 
[08:27:23.481]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:23.481]                     ...future.globalenv.names))
[08:27:23.481]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:23.481]         }, condition = base::local({
[08:27:23.481]             c <- base::c
[08:27:23.481]             inherits <- base::inherits
[08:27:23.481]             invokeRestart <- base::invokeRestart
[08:27:23.481]             length <- base::length
[08:27:23.481]             list <- base::list
[08:27:23.481]             seq.int <- base::seq.int
[08:27:23.481]             signalCondition <- base::signalCondition
[08:27:23.481]             sys.calls <- base::sys.calls
[08:27:23.481]             `[[` <- base::`[[`
[08:27:23.481]             `+` <- base::`+`
[08:27:23.481]             `<<-` <- base::`<<-`
[08:27:23.481]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:23.481]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:23.481]                   3L)]
[08:27:23.481]             }
[08:27:23.481]             function(cond) {
[08:27:23.481]                 is_error <- inherits(cond, "error")
[08:27:23.481]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:23.481]                   NULL)
[08:27:23.481]                 if (is_error) {
[08:27:23.481]                   sessionInformation <- function() {
[08:27:23.481]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:23.481]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:23.481]                       search = base::search(), system = base::Sys.info())
[08:27:23.481]                   }
[08:27:23.481]                   ...future.conditions[[length(...future.conditions) + 
[08:27:23.481]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:23.481]                     cond$call), session = sessionInformation(), 
[08:27:23.481]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:23.481]                   signalCondition(cond)
[08:27:23.481]                 }
[08:27:23.481]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:23.481]                 "immediateCondition"))) {
[08:27:23.481]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:23.481]                   ...future.conditions[[length(...future.conditions) + 
[08:27:23.481]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:23.481]                   if (TRUE && !signal) {
[08:27:23.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:23.481]                     {
[08:27:23.481]                       inherits <- base::inherits
[08:27:23.481]                       invokeRestart <- base::invokeRestart
[08:27:23.481]                       is.null <- base::is.null
[08:27:23.481]                       muffled <- FALSE
[08:27:23.481]                       if (inherits(cond, "message")) {
[08:27:23.481]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:23.481]                         if (muffled) 
[08:27:23.481]                           invokeRestart("muffleMessage")
[08:27:23.481]                       }
[08:27:23.481]                       else if (inherits(cond, "warning")) {
[08:27:23.481]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:23.481]                         if (muffled) 
[08:27:23.481]                           invokeRestart("muffleWarning")
[08:27:23.481]                       }
[08:27:23.481]                       else if (inherits(cond, "condition")) {
[08:27:23.481]                         if (!is.null(pattern)) {
[08:27:23.481]                           computeRestarts <- base::computeRestarts
[08:27:23.481]                           grepl <- base::grepl
[08:27:23.481]                           restarts <- computeRestarts(cond)
[08:27:23.481]                           for (restart in restarts) {
[08:27:23.481]                             name <- restart$name
[08:27:23.481]                             if (is.null(name)) 
[08:27:23.481]                               next
[08:27:23.481]                             if (!grepl(pattern, name)) 
[08:27:23.481]                               next
[08:27:23.481]                             invokeRestart(restart)
[08:27:23.481]                             muffled <- TRUE
[08:27:23.481]                             break
[08:27:23.481]                           }
[08:27:23.481]                         }
[08:27:23.481]                       }
[08:27:23.481]                       invisible(muffled)
[08:27:23.481]                     }
[08:27:23.481]                     muffleCondition(cond, pattern = "^muffle")
[08:27:23.481]                   }
[08:27:23.481]                 }
[08:27:23.481]                 else {
[08:27:23.481]                   if (TRUE) {
[08:27:23.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:23.481]                     {
[08:27:23.481]                       inherits <- base::inherits
[08:27:23.481]                       invokeRestart <- base::invokeRestart
[08:27:23.481]                       is.null <- base::is.null
[08:27:23.481]                       muffled <- FALSE
[08:27:23.481]                       if (inherits(cond, "message")) {
[08:27:23.481]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:23.481]                         if (muffled) 
[08:27:23.481]                           invokeRestart("muffleMessage")
[08:27:23.481]                       }
[08:27:23.481]                       else if (inherits(cond, "warning")) {
[08:27:23.481]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:23.481]                         if (muffled) 
[08:27:23.481]                           invokeRestart("muffleWarning")
[08:27:23.481]                       }
[08:27:23.481]                       else if (inherits(cond, "condition")) {
[08:27:23.481]                         if (!is.null(pattern)) {
[08:27:23.481]                           computeRestarts <- base::computeRestarts
[08:27:23.481]                           grepl <- base::grepl
[08:27:23.481]                           restarts <- computeRestarts(cond)
[08:27:23.481]                           for (restart in restarts) {
[08:27:23.481]                             name <- restart$name
[08:27:23.481]                             if (is.null(name)) 
[08:27:23.481]                               next
[08:27:23.481]                             if (!grepl(pattern, name)) 
[08:27:23.481]                               next
[08:27:23.481]                             invokeRestart(restart)
[08:27:23.481]                             muffled <- TRUE
[08:27:23.481]                             break
[08:27:23.481]                           }
[08:27:23.481]                         }
[08:27:23.481]                       }
[08:27:23.481]                       invisible(muffled)
[08:27:23.481]                     }
[08:27:23.481]                     muffleCondition(cond, pattern = "^muffle")
[08:27:23.481]                   }
[08:27:23.481]                 }
[08:27:23.481]             }
[08:27:23.481]         }))
[08:27:23.481]     }, error = function(ex) {
[08:27:23.481]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:23.481]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:23.481]                 ...future.rng), started = ...future.startTime, 
[08:27:23.481]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:23.481]             version = "1.8"), class = "FutureResult")
[08:27:23.481]     }, finally = {
[08:27:23.481]         if (!identical(...future.workdir, getwd())) 
[08:27:23.481]             setwd(...future.workdir)
[08:27:23.481]         {
[08:27:23.481]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:23.481]                 ...future.oldOptions$nwarnings <- NULL
[08:27:23.481]             }
[08:27:23.481]             base::options(...future.oldOptions)
[08:27:23.481]             if (.Platform$OS.type == "windows") {
[08:27:23.481]                 old_names <- names(...future.oldEnvVars)
[08:27:23.481]                 envs <- base::Sys.getenv()
[08:27:23.481]                 names <- names(envs)
[08:27:23.481]                 common <- intersect(names, old_names)
[08:27:23.481]                 added <- setdiff(names, old_names)
[08:27:23.481]                 removed <- setdiff(old_names, names)
[08:27:23.481]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:23.481]                   envs[common]]
[08:27:23.481]                 NAMES <- toupper(changed)
[08:27:23.481]                 args <- list()
[08:27:23.481]                 for (kk in seq_along(NAMES)) {
[08:27:23.481]                   name <- changed[[kk]]
[08:27:23.481]                   NAME <- NAMES[[kk]]
[08:27:23.481]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.481]                     next
[08:27:23.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:23.481]                 }
[08:27:23.481]                 NAMES <- toupper(added)
[08:27:23.481]                 for (kk in seq_along(NAMES)) {
[08:27:23.481]                   name <- added[[kk]]
[08:27:23.481]                   NAME <- NAMES[[kk]]
[08:27:23.481]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.481]                     next
[08:27:23.481]                   args[[name]] <- ""
[08:27:23.481]                 }
[08:27:23.481]                 NAMES <- toupper(removed)
[08:27:23.481]                 for (kk in seq_along(NAMES)) {
[08:27:23.481]                   name <- removed[[kk]]
[08:27:23.481]                   NAME <- NAMES[[kk]]
[08:27:23.481]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.481]                     next
[08:27:23.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:23.481]                 }
[08:27:23.481]                 if (length(args) > 0) 
[08:27:23.481]                   base::do.call(base::Sys.setenv, args = args)
[08:27:23.481]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:23.481]             }
[08:27:23.481]             else {
[08:27:23.481]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:23.481]             }
[08:27:23.481]             {
[08:27:23.481]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:23.481]                   0L) {
[08:27:23.481]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:23.481]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:23.481]                   base::options(opts)
[08:27:23.481]                 }
[08:27:23.481]                 {
[08:27:23.481]                   {
[08:27:23.481]                     NULL
[08:27:23.481]                     RNGkind("Mersenne-Twister")
[08:27:23.481]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:23.481]                       inherits = FALSE)
[08:27:23.481]                   }
[08:27:23.481]                   options(future.plan = NULL)
[08:27:23.481]                   if (is.na(NA_character_)) 
[08:27:23.481]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:23.481]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:23.481]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:23.481]                     .init = FALSE)
[08:27:23.481]                 }
[08:27:23.481]             }
[08:27:23.481]         }
[08:27:23.481]     })
[08:27:23.481]     if (TRUE) {
[08:27:23.481]         base::sink(type = "output", split = FALSE)
[08:27:23.481]         if (TRUE) {
[08:27:23.481]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:23.481]         }
[08:27:23.481]         else {
[08:27:23.481]             ...future.result["stdout"] <- base::list(NULL)
[08:27:23.481]         }
[08:27:23.481]         base::close(...future.stdout)
[08:27:23.481]         ...future.stdout <- NULL
[08:27:23.481]     }
[08:27:23.481]     ...future.result$conditions <- ...future.conditions
[08:27:23.481]     ...future.result$finished <- base::Sys.time()
[08:27:23.481]     ...future.result
[08:27:23.481] }
[08:27:23.482] assign_globals() ...
[08:27:23.482] List of 4
[08:27:23.482]  $ ii   : int 4
[08:27:23.482]  $ n    : int 4
[08:27:23.482]  $ C    : cplx [1:25, 1:25] -0.719+0.0306i -0.719+0.0918i -0.719+0.1531i ...
[08:27:23.482]   ..- attr(*, "region")=List of 2
[08:27:23.482]   .. ..$ xrange: num [1:2] -0.719 0.75
[08:27:23.482]   .. ..$ yrange: num [1:2] 0.0306 1.5
[08:27:23.482]   ..- attr(*, "tile")= int [1:2] 2 2
[08:27:23.482]  $ delay:function (counts)  
[08:27:23.482]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[08:27:23.482]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x561de858f950> 
[08:27:23.482]  - attr(*, "where")=List of 4
[08:27:23.482]   ..$ ii   :<environment: R_EmptyEnv> 
[08:27:23.482]   ..$ n    :<environment: R_EmptyEnv> 
[08:27:23.482]   ..$ C    :<environment: R_EmptyEnv> 
[08:27:23.482]   ..$ delay:<environment: R_EmptyEnv> 
[08:27:23.482]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:23.482]  - attr(*, "resolved")= logi FALSE
[08:27:23.482]  - attr(*, "total_size")= num 58781
[08:27:23.482]  - attr(*, "already-done")= logi TRUE
[08:27:23.489] - copied ‘ii’ to environment
[08:27:23.489] - copied ‘n’ to environment
[08:27:23.489] - copied ‘C’ to environment
[08:27:23.489] - reassign environment for ‘delay’
[08:27:23.489] - copied ‘delay’ to environment
[08:27:23.489] assign_globals() ... done
[08:27:23.490] plan(): Setting new future strategy stack:
[08:27:23.490] List of future strategies:
[08:27:23.490] 1. sequential:
[08:27:23.490]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:23.490]    - tweaked: FALSE
[08:27:23.490]    - call: NULL
[08:27:23.490] plan(): nbrOfWorkers() = 1
[08:27:23.510] plan(): Setting new future strategy stack:
[08:27:23.511] List of future strategies:
[08:27:23.511] 1. sequential:
[08:27:23.511]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:23.511]    - tweaked: FALSE
[08:27:23.511]    - call: plan(strategy)
[08:27:23.511] plan(): nbrOfWorkers() = 1
[08:27:23.512] SequentialFuture started (and completed)
[08:27:23.512] signalConditions() ...
[08:27:23.512]  - include = ‘immediateCondition’
[08:27:23.512]  - exclude = 
[08:27:23.512]  - resignal = FALSE
[08:27:23.512]  - Number of conditions: 2
[08:27:23.512] signalConditions() ... done
[08:27:23.512] - Launch lazy future ... done
[08:27:23.513] run() for ‘SequentialFuture’ ... done
[08:27:23.513] - run() ... done
[08:27:23.513] - resolved() ...
[08:27:23.513] resolved() for ‘SequentialFuture’ ...
[08:27:23.513] - state: ‘finished’
[08:27:23.513] - run: TRUE
[08:27:23.513] - result: ‘FutureResult’
[08:27:23.513] resolved() for ‘SequentialFuture’ ... done
[08:27:23.513] - resolved: TRUE
[08:27:23.514] - resolved() ... done
[08:27:23.514] resolved() for ‘SequentialFuture’ ... done
Plotting tile #4 of 4 ...
[08:27:23.514] signalConditions() ...
[08:27:23.514]  - include = ‘immediateCondition’
[08:27:23.514]  - exclude = 
[08:27:23.514]  - resignal = FALSE
[08:27:23.514]  - Number of conditions: 2
[08:27:23.514] signalConditions() ... done
[08:27:23.515] Future state: ‘finished’
[08:27:23.515] signalConditions() ...
[08:27:23.515]  - include = ‘condition’
[08:27:23.515]  - exclude = ‘immediateCondition’
[08:27:23.515]  - resignal = TRUE
[08:27:23.515]  - Number of conditions: 2
[08:27:23.515]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[08:27:23.515]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[08:27:23.516] signalConditions() ... done

> close.screen()
[1] 1 2 3 4

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('sequential') ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('multicore') ...
[08:27:23.525] plan(): Setting new future strategy stack:
[08:27:23.525] List of future strategies:
[08:27:23.525] 1. multicore:
[08:27:23.525]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:23.525]    - tweaked: FALSE
[08:27:23.525]    - call: plan(strategy)
[08:27:23.527] plan(): nbrOfWorkers() = 2


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1] 5 6 7 8

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[08:27:23.530] getGlobalsAndPackages() ...
[08:27:23.531] Searching for globals...
[08:27:23.534] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[08:27:23.534] Searching for globals ... DONE
[08:27:23.534] Resolving globals: FALSE
[08:27:23.535] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[08:27:23.535] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:27:23.535] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[08:27:23.536] - packages: [1] ‘future’
[08:27:23.536] getGlobalsAndPackages() ... DONE
 2[08:27:23.540] getGlobalsAndPackages() ...
[08:27:23.540] Searching for globals...
[08:27:23.543] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[08:27:23.544] Searching for globals ... DONE
[08:27:23.544] Resolving globals: FALSE
[08:27:23.544] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[08:27:23.545] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:27:23.545] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[08:27:23.545] - packages: [1] ‘future’
[08:27:23.545] getGlobalsAndPackages() ... DONE
 3[08:27:23.545] getGlobalsAndPackages() ...
[08:27:23.545] Searching for globals...
[08:27:23.549] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[08:27:23.549] Searching for globals ... DONE
[08:27:23.549] Resolving globals: FALSE
[08:27:23.550] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[08:27:23.550] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:27:23.550] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[08:27:23.550] - packages: [1] ‘future’
[08:27:23.550] getGlobalsAndPackages() ... DONE
 4[08:27:23.551] getGlobalsAndPackages() ...
[08:27:23.551] Searching for globals...
[08:27:23.554] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[08:27:23.554] Searching for globals ... DONE
[08:27:23.554] Resolving globals: FALSE
[08:27:23.555] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[08:27:23.555] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:27:23.556] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[08:27:23.556] - packages: [1] ‘future’
[08:27:23.556] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[08:27:23.565] resolved() for ‘Future’ ...
[08:27:23.565] - state: ‘created’
[08:27:23.566] - run: TRUE
[08:27:23.566] - run() ...
[08:27:23.566] run() for ‘Future’ ...
[08:27:23.566] - state: ‘created’
[08:27:23.566] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:23.568] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:23.568] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:23.568]   - Field: ‘label’
[08:27:23.568]   - Field: ‘local’
[08:27:23.568]   - Field: ‘owner’
[08:27:23.568]   - Field: ‘envir’
[08:27:23.569]   - Field: ‘workers’
[08:27:23.569]   - Field: ‘packages’
[08:27:23.569]   - Field: ‘gc’
[08:27:23.569]   - Field: ‘job’
[08:27:23.569]   - Field: ‘conditions’
[08:27:23.569]   - Field: ‘expr’
[08:27:23.569]   - Field: ‘uuid’
[08:27:23.569]   - Field: ‘seed’
[08:27:23.569]   - Field: ‘version’
[08:27:23.569]   - Field: ‘result’
[08:27:23.569]   - Field: ‘asynchronous’
[08:27:23.570]   - Field: ‘calls’
[08:27:23.570]   - Field: ‘globals’
[08:27:23.570]   - Field: ‘stdout’
[08:27:23.570]   - Field: ‘earlySignal’
[08:27:23.570]   - Field: ‘lazy’
[08:27:23.570]   - Field: ‘state’
[08:27:23.570] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:23.570] - Launch lazy future ...
[08:27:23.571] Packages needed by the future expression (n = 1): ‘future’
[08:27:23.571] Packages needed by future strategies (n = 0): <none>
[08:27:23.572] {
[08:27:23.572]     {
[08:27:23.572]         {
[08:27:23.572]             ...future.startTime <- base::Sys.time()
[08:27:23.572]             {
[08:27:23.572]                 {
[08:27:23.572]                   {
[08:27:23.572]                     {
[08:27:23.572]                       {
[08:27:23.572]                         base::local({
[08:27:23.572]                           has_future <- base::requireNamespace("future", 
[08:27:23.572]                             quietly = TRUE)
[08:27:23.572]                           if (has_future) {
[08:27:23.572]                             ns <- base::getNamespace("future")
[08:27:23.572]                             version <- ns[[".package"]][["version"]]
[08:27:23.572]                             if (is.null(version)) 
[08:27:23.572]                               version <- utils::packageVersion("future")
[08:27:23.572]                           }
[08:27:23.572]                           else {
[08:27:23.572]                             version <- NULL
[08:27:23.572]                           }
[08:27:23.572]                           if (!has_future || version < "1.8.0") {
[08:27:23.572]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:23.572]                               "", base::R.version$version.string), 
[08:27:23.572]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:23.572]                                 base::R.version$platform, 8 * 
[08:27:23.572]                                   base::.Machine$sizeof.pointer), 
[08:27:23.572]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:23.572]                                 "release", "version")], collapse = " "), 
[08:27:23.572]                               hostname = base::Sys.info()[["nodename"]])
[08:27:23.572]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:23.572]                               info)
[08:27:23.572]                             info <- base::paste(info, collapse = "; ")
[08:27:23.572]                             if (!has_future) {
[08:27:23.572]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:23.572]                                 info)
[08:27:23.572]                             }
[08:27:23.572]                             else {
[08:27:23.572]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:23.572]                                 info, version)
[08:27:23.572]                             }
[08:27:23.572]                             base::stop(msg)
[08:27:23.572]                           }
[08:27:23.572]                         })
[08:27:23.572]                       }
[08:27:23.572]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:23.572]                       base::options(mc.cores = 1L)
[08:27:23.572]                     }
[08:27:23.572]                     base::local({
[08:27:23.572]                       for (pkg in "future") {
[08:27:23.572]                         base::loadNamespace(pkg)
[08:27:23.572]                         base::library(pkg, character.only = TRUE)
[08:27:23.572]                       }
[08:27:23.572]                     })
[08:27:23.572]                   }
[08:27:23.572]                   ...future.strategy.old <- future::plan("list")
[08:27:23.572]                   options(future.plan = NULL)
[08:27:23.572]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:23.572]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:23.572]                 }
[08:27:23.572]                 ...future.workdir <- getwd()
[08:27:23.572]             }
[08:27:23.572]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:23.572]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:23.572]         }
[08:27:23.572]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:23.572]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:23.572]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:23.572]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:23.572]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:23.572]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:23.572]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:23.572]             base::names(...future.oldOptions))
[08:27:23.572]     }
[08:27:23.572]     if (FALSE) {
[08:27:23.572]     }
[08:27:23.572]     else {
[08:27:23.572]         if (TRUE) {
[08:27:23.572]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:23.572]                 open = "w")
[08:27:23.572]         }
[08:27:23.572]         else {
[08:27:23.572]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:23.572]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:23.572]         }
[08:27:23.572]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:23.572]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:23.572]             base::sink(type = "output", split = FALSE)
[08:27:23.572]             base::close(...future.stdout)
[08:27:23.572]         }, add = TRUE)
[08:27:23.572]     }
[08:27:23.572]     ...future.frame <- base::sys.nframe()
[08:27:23.572]     ...future.conditions <- base::list()
[08:27:23.572]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:23.572]     if (FALSE) {
[08:27:23.572]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:23.572]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:23.572]     }
[08:27:23.572]     ...future.result <- base::tryCatch({
[08:27:23.572]         base::withCallingHandlers({
[08:27:23.572]             ...future.value <- base::withVisible(base::local({
[08:27:23.572]                 withCallingHandlers({
[08:27:23.572]                   {
[08:27:23.572]                     message(sprintf("Calculating tile #%d of %d ...", 
[08:27:23.572]                       ii, n), appendLF = FALSE)
[08:27:23.572]                     fit <- mandelbrot(C)
[08:27:23.572]                     delay(fit)
[08:27:23.572]                     message(" done")
[08:27:23.572]                     fit
[08:27:23.572]                   }
[08:27:23.572]                 }, immediateCondition = function(cond) {
[08:27:23.572]                   save_rds <- function (object, pathname, ...) 
[08:27:23.572]                   {
[08:27:23.572]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:23.572]                     if (file_test("-f", pathname_tmp)) {
[08:27:23.572]                       fi_tmp <- file.info(pathname_tmp)
[08:27:23.572]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:23.572]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:23.572]                         fi_tmp[["mtime"]])
[08:27:23.572]                     }
[08:27:23.572]                     tryCatch({
[08:27:23.572]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:23.572]                     }, error = function(ex) {
[08:27:23.572]                       msg <- conditionMessage(ex)
[08:27:23.572]                       fi_tmp <- file.info(pathname_tmp)
[08:27:23.572]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:23.572]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:23.572]                         fi_tmp[["mtime"]], msg)
[08:27:23.572]                       ex$message <- msg
[08:27:23.572]                       stop(ex)
[08:27:23.572]                     })
[08:27:23.572]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:23.572]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:23.572]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:23.572]                       fi_tmp <- file.info(pathname_tmp)
[08:27:23.572]                       fi <- file.info(pathname)
[08:27:23.572]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:23.572]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:23.572]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:23.572]                         fi[["size"]], fi[["mtime"]])
[08:27:23.572]                       stop(msg)
[08:27:23.572]                     }
[08:27:23.572]                     invisible(pathname)
[08:27:23.572]                   }
[08:27:23.572]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:23.572]                     rootPath = tempdir()) 
[08:27:23.572]                   {
[08:27:23.572]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:23.572]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:23.572]                       tmpdir = path, fileext = ".rds")
[08:27:23.572]                     save_rds(obj, file)
[08:27:23.572]                   }
[08:27:23.572]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0QGEgG/.future/immediateConditions")
[08:27:23.572]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:23.572]                   {
[08:27:23.572]                     inherits <- base::inherits
[08:27:23.572]                     invokeRestart <- base::invokeRestart
[08:27:23.572]                     is.null <- base::is.null
[08:27:23.572]                     muffled <- FALSE
[08:27:23.572]                     if (inherits(cond, "message")) {
[08:27:23.572]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:23.572]                       if (muffled) 
[08:27:23.572]                         invokeRestart("muffleMessage")
[08:27:23.572]                     }
[08:27:23.572]                     else if (inherits(cond, "warning")) {
[08:27:23.572]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:23.572]                       if (muffled) 
[08:27:23.572]                         invokeRestart("muffleWarning")
[08:27:23.572]                     }
[08:27:23.572]                     else if (inherits(cond, "condition")) {
[08:27:23.572]                       if (!is.null(pattern)) {
[08:27:23.572]                         computeRestarts <- base::computeRestarts
[08:27:23.572]                         grepl <- base::grepl
[08:27:23.572]                         restarts <- computeRestarts(cond)
[08:27:23.572]                         for (restart in restarts) {
[08:27:23.572]                           name <- restart$name
[08:27:23.572]                           if (is.null(name)) 
[08:27:23.572]                             next
[08:27:23.572]                           if (!grepl(pattern, name)) 
[08:27:23.572]                             next
[08:27:23.572]                           invokeRestart(restart)
[08:27:23.572]                           muffled <- TRUE
[08:27:23.572]                           break
[08:27:23.572]                         }
[08:27:23.572]                       }
[08:27:23.572]                     }
[08:27:23.572]                     invisible(muffled)
[08:27:23.572]                   }
[08:27:23.572]                   muffleCondition(cond)
[08:27:23.572]                 })
[08:27:23.572]             }))
[08:27:23.572]             future::FutureResult(value = ...future.value$value, 
[08:27:23.572]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:23.572]                   ...future.rng), globalenv = if (FALSE) 
[08:27:23.572]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:23.572]                     ...future.globalenv.names))
[08:27:23.572]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:23.572]         }, condition = base::local({
[08:27:23.572]             c <- base::c
[08:27:23.572]             inherits <- base::inherits
[08:27:23.572]             invokeRestart <- base::invokeRestart
[08:27:23.572]             length <- base::length
[08:27:23.572]             list <- base::list
[08:27:23.572]             seq.int <- base::seq.int
[08:27:23.572]             signalCondition <- base::signalCondition
[08:27:23.572]             sys.calls <- base::sys.calls
[08:27:23.572]             `[[` <- base::`[[`
[08:27:23.572]             `+` <- base::`+`
[08:27:23.572]             `<<-` <- base::`<<-`
[08:27:23.572]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:23.572]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:23.572]                   3L)]
[08:27:23.572]             }
[08:27:23.572]             function(cond) {
[08:27:23.572]                 is_error <- inherits(cond, "error")
[08:27:23.572]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:23.572]                   NULL)
[08:27:23.572]                 if (is_error) {
[08:27:23.572]                   sessionInformation <- function() {
[08:27:23.572]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:23.572]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:23.572]                       search = base::search(), system = base::Sys.info())
[08:27:23.572]                   }
[08:27:23.572]                   ...future.conditions[[length(...future.conditions) + 
[08:27:23.572]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:23.572]                     cond$call), session = sessionInformation(), 
[08:27:23.572]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:23.572]                   signalCondition(cond)
[08:27:23.572]                 }
[08:27:23.572]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:23.572]                 "immediateCondition"))) {
[08:27:23.572]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:23.572]                   ...future.conditions[[length(...future.conditions) + 
[08:27:23.572]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:23.572]                   if (TRUE && !signal) {
[08:27:23.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:23.572]                     {
[08:27:23.572]                       inherits <- base::inherits
[08:27:23.572]                       invokeRestart <- base::invokeRestart
[08:27:23.572]                       is.null <- base::is.null
[08:27:23.572]                       muffled <- FALSE
[08:27:23.572]                       if (inherits(cond, "message")) {
[08:27:23.572]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:23.572]                         if (muffled) 
[08:27:23.572]                           invokeRestart("muffleMessage")
[08:27:23.572]                       }
[08:27:23.572]                       else if (inherits(cond, "warning")) {
[08:27:23.572]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:23.572]                         if (muffled) 
[08:27:23.572]                           invokeRestart("muffleWarning")
[08:27:23.572]                       }
[08:27:23.572]                       else if (inherits(cond, "condition")) {
[08:27:23.572]                         if (!is.null(pattern)) {
[08:27:23.572]                           computeRestarts <- base::computeRestarts
[08:27:23.572]                           grepl <- base::grepl
[08:27:23.572]                           restarts <- computeRestarts(cond)
[08:27:23.572]                           for (restart in restarts) {
[08:27:23.572]                             name <- restart$name
[08:27:23.572]                             if (is.null(name)) 
[08:27:23.572]                               next
[08:27:23.572]                             if (!grepl(pattern, name)) 
[08:27:23.572]                               next
[08:27:23.572]                             invokeRestart(restart)
[08:27:23.572]                             muffled <- TRUE
[08:27:23.572]                             break
[08:27:23.572]                           }
[08:27:23.572]                         }
[08:27:23.572]                       }
[08:27:23.572]                       invisible(muffled)
[08:27:23.572]                     }
[08:27:23.572]                     muffleCondition(cond, pattern = "^muffle")
[08:27:23.572]                   }
[08:27:23.572]                 }
[08:27:23.572]                 else {
[08:27:23.572]                   if (TRUE) {
[08:27:23.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:23.572]                     {
[08:27:23.572]                       inherits <- base::inherits
[08:27:23.572]                       invokeRestart <- base::invokeRestart
[08:27:23.572]                       is.null <- base::is.null
[08:27:23.572]                       muffled <- FALSE
[08:27:23.572]                       if (inherits(cond, "message")) {
[08:27:23.572]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:23.572]                         if (muffled) 
[08:27:23.572]                           invokeRestart("muffleMessage")
[08:27:23.572]                       }
[08:27:23.572]                       else if (inherits(cond, "warning")) {
[08:27:23.572]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:23.572]                         if (muffled) 
[08:27:23.572]                           invokeRestart("muffleWarning")
[08:27:23.572]                       }
[08:27:23.572]                       else if (inherits(cond, "condition")) {
[08:27:23.572]                         if (!is.null(pattern)) {
[08:27:23.572]                           computeRestarts <- base::computeRestarts
[08:27:23.572]                           grepl <- base::grepl
[08:27:23.572]                           restarts <- computeRestarts(cond)
[08:27:23.572]                           for (restart in restarts) {
[08:27:23.572]                             name <- restart$name
[08:27:23.572]                             if (is.null(name)) 
[08:27:23.572]                               next
[08:27:23.572]                             if (!grepl(pattern, name)) 
[08:27:23.572]                               next
[08:27:23.572]                             invokeRestart(restart)
[08:27:23.572]                             muffled <- TRUE
[08:27:23.572]                             break
[08:27:23.572]                           }
[08:27:23.572]                         }
[08:27:23.572]                       }
[08:27:23.572]                       invisible(muffled)
[08:27:23.572]                     }
[08:27:23.572]                     muffleCondition(cond, pattern = "^muffle")
[08:27:23.572]                   }
[08:27:23.572]                 }
[08:27:23.572]             }
[08:27:23.572]         }))
[08:27:23.572]     }, error = function(ex) {
[08:27:23.572]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:23.572]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:23.572]                 ...future.rng), started = ...future.startTime, 
[08:27:23.572]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:23.572]             version = "1.8"), class = "FutureResult")
[08:27:23.572]     }, finally = {
[08:27:23.572]         if (!identical(...future.workdir, getwd())) 
[08:27:23.572]             setwd(...future.workdir)
[08:27:23.572]         {
[08:27:23.572]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:23.572]                 ...future.oldOptions$nwarnings <- NULL
[08:27:23.572]             }
[08:27:23.572]             base::options(...future.oldOptions)
[08:27:23.572]             if (.Platform$OS.type == "windows") {
[08:27:23.572]                 old_names <- names(...future.oldEnvVars)
[08:27:23.572]                 envs <- base::Sys.getenv()
[08:27:23.572]                 names <- names(envs)
[08:27:23.572]                 common <- intersect(names, old_names)
[08:27:23.572]                 added <- setdiff(names, old_names)
[08:27:23.572]                 removed <- setdiff(old_names, names)
[08:27:23.572]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:23.572]                   envs[common]]
[08:27:23.572]                 NAMES <- toupper(changed)
[08:27:23.572]                 args <- list()
[08:27:23.572]                 for (kk in seq_along(NAMES)) {
[08:27:23.572]                   name <- changed[[kk]]
[08:27:23.572]                   NAME <- NAMES[[kk]]
[08:27:23.572]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.572]                     next
[08:27:23.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:23.572]                 }
[08:27:23.572]                 NAMES <- toupper(added)
[08:27:23.572]                 for (kk in seq_along(NAMES)) {
[08:27:23.572]                   name <- added[[kk]]
[08:27:23.572]                   NAME <- NAMES[[kk]]
[08:27:23.572]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.572]                     next
[08:27:23.572]                   args[[name]] <- ""
[08:27:23.572]                 }
[08:27:23.572]                 NAMES <- toupper(removed)
[08:27:23.572]                 for (kk in seq_along(NAMES)) {
[08:27:23.572]                   name <- removed[[kk]]
[08:27:23.572]                   NAME <- NAMES[[kk]]
[08:27:23.572]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.572]                     next
[08:27:23.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:23.572]                 }
[08:27:23.572]                 if (length(args) > 0) 
[08:27:23.572]                   base::do.call(base::Sys.setenv, args = args)
[08:27:23.572]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:23.572]             }
[08:27:23.572]             else {
[08:27:23.572]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:23.572]             }
[08:27:23.572]             {
[08:27:23.572]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:23.572]                   0L) {
[08:27:23.572]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:23.572]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:23.572]                   base::options(opts)
[08:27:23.572]                 }
[08:27:23.572]                 {
[08:27:23.572]                   {
[08:27:23.572]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:23.572]                     NULL
[08:27:23.572]                   }
[08:27:23.572]                   options(future.plan = NULL)
[08:27:23.572]                   if (is.na(NA_character_)) 
[08:27:23.572]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:23.572]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:23.572]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:23.572]                     .init = FALSE)
[08:27:23.572]                 }
[08:27:23.572]             }
[08:27:23.572]         }
[08:27:23.572]     })
[08:27:23.572]     if (TRUE) {
[08:27:23.572]         base::sink(type = "output", split = FALSE)
[08:27:23.572]         if (TRUE) {
[08:27:23.572]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:23.572]         }
[08:27:23.572]         else {
[08:27:23.572]             ...future.result["stdout"] <- base::list(NULL)
[08:27:23.572]         }
[08:27:23.572]         base::close(...future.stdout)
[08:27:23.572]         ...future.stdout <- NULL
[08:27:23.572]     }
[08:27:23.572]     ...future.result$conditions <- ...future.conditions
[08:27:23.572]     ...future.result$finished <- base::Sys.time()
[08:27:23.572]     ...future.result
[08:27:23.572] }
[08:27:23.575] assign_globals() ...
[08:27:23.575] List of 4
[08:27:23.575]  $ ii   : int 1
[08:27:23.575]  $ n    : int 4
[08:27:23.575]  $ C    : cplx [1:25, 1:25] -2.25-1.5i -2.25-1.44i -2.25-1.38i ...
[08:27:23.575]   ..- attr(*, "region")=List of 2
[08:27:23.575]   .. ..$ xrange: num [1:2] -2.25 -0.781
[08:27:23.575]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[08:27:23.575]   ..- attr(*, "tile")= int [1:2] 1 1
[08:27:23.575]  $ delay:function (counts)  
[08:27:23.575]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[08:27:23.575]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x561dea221c10> 
[08:27:23.575]  - attr(*, "where")=List of 4
[08:27:23.575]   ..$ ii   :<environment: R_EmptyEnv> 
[08:27:23.575]   ..$ n    :<environment: R_EmptyEnv> 
[08:27:23.575]   ..$ C    :<environment: R_EmptyEnv> 
[08:27:23.575]   ..$ delay:<environment: R_EmptyEnv> 
[08:27:23.575]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:23.575]  - attr(*, "resolved")= logi FALSE
[08:27:23.575]  - attr(*, "total_size")= num 58781
[08:27:23.575]  - attr(*, "already-done")= logi TRUE
[08:27:23.581] - copied ‘ii’ to environment
[08:27:23.581] - copied ‘n’ to environment
[08:27:23.581] - copied ‘C’ to environment
[08:27:23.581] - reassign environment for ‘delay’
[08:27:23.581] - copied ‘delay’ to environment
[08:27:23.582] assign_globals() ... done
[08:27:23.582] requestCore(): workers = 2
[08:27:23.585] MulticoreFuture started
[08:27:23.586] - Launch lazy future ... done
[08:27:23.586] run() for ‘MulticoreFuture’ ... done
[08:27:23.586] - run() ... done
[08:27:23.586] - resolved() ...
[08:27:23.586] plan(): Setting new future strategy stack:
[08:27:23.587] List of future strategies:
[08:27:23.587] 1. sequential:
[08:27:23.587]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:23.587]    - tweaked: FALSE
[08:27:23.587]    - call: NULL
[08:27:23.588] plan(): nbrOfWorkers() = 1
[08:27:23.591] plan(): Setting new future strategy stack:
[08:27:23.591] List of future strategies:
[08:27:23.591] 1. multicore:
[08:27:23.591]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:23.591]    - tweaked: FALSE
[08:27:23.591]    - call: plan(strategy)
[08:27:23.594] plan(): nbrOfWorkers() = 2
[08:27:23.595] - resolved: TRUE
[08:27:23.596] - resolved() ... done
[08:27:23.596] resolved() for ‘MulticoreFuture’ ... done
Plotting tile #1 of 4 ...
[08:27:23.597] result() for MulticoreFuture ...
[08:27:23.602] result() for MulticoreFuture ...
[08:27:23.603] result() for MulticoreFuture ... done
[08:27:23.603] signalConditions() ...
[08:27:23.603]  - include = ‘immediateCondition’
[08:27:23.603]  - exclude = 
[08:27:23.603]  - resignal = FALSE
[08:27:23.603]  - Number of conditions: 2
[08:27:23.603] signalConditions() ... done
[08:27:23.603] result() for MulticoreFuture ... done
[08:27:23.603] result() for MulticoreFuture ...
[08:27:23.604] result() for MulticoreFuture ... done
[08:27:23.604] signalConditions() ...
[08:27:23.604]  - include = ‘immediateCondition’
[08:27:23.604]  - exclude = 
[08:27:23.604]  - resignal = FALSE
[08:27:23.604]  - Number of conditions: 2
[08:27:23.604] signalConditions() ... done
[08:27:23.604] Future state: ‘finished’
[08:27:23.604] result() for MulticoreFuture ...
[08:27:23.605] result() for MulticoreFuture ... done
[08:27:23.605] signalConditions() ...
[08:27:23.605]  - include = ‘condition’
[08:27:23.605]  - exclude = ‘immediateCondition’
[08:27:23.605]  - resignal = TRUE
[08:27:23.605]  - Number of conditions: 2
[08:27:23.605]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[08:27:23.605]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[08:27:23.606] signalConditions() ... done
[08:27:23.606] resolved() for ‘Future’ ...
[08:27:23.607] - state: ‘created’
[08:27:23.607] - run: TRUE
[08:27:23.607] - run() ...
[08:27:23.607] run() for ‘Future’ ...
[08:27:23.607] - state: ‘created’
[08:27:23.607] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:23.610] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:23.610] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:23.610]   - Field: ‘label’
[08:27:23.610]   - Field: ‘local’
[08:27:23.610]   - Field: ‘owner’
[08:27:23.610]   - Field: ‘envir’
[08:27:23.610]   - Field: ‘workers’
[08:27:23.610]   - Field: ‘packages’
[08:27:23.610]   - Field: ‘gc’
[08:27:23.611]   - Field: ‘job’
[08:27:23.611]   - Field: ‘conditions’
[08:27:23.611]   - Field: ‘expr’
[08:27:23.611]   - Field: ‘uuid’
[08:27:23.611]   - Field: ‘seed’
[08:27:23.611]   - Field: ‘version’
[08:27:23.611]   - Field: ‘result’
[08:27:23.611]   - Field: ‘asynchronous’
[08:27:23.611]   - Field: ‘calls’
[08:27:23.612]   - Field: ‘globals’
[08:27:23.612]   - Field: ‘stdout’
[08:27:23.612]   - Field: ‘earlySignal’
[08:27:23.615]   - Field: ‘lazy’
[08:27:23.615]   - Field: ‘state’
[08:27:23.616] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:23.616] - Launch lazy future ...
[08:27:23.616] Packages needed by the future expression (n = 1): ‘future’
[08:27:23.616] Packages needed by future strategies (n = 0): <none>
[08:27:23.617] {
[08:27:23.617]     {
[08:27:23.617]         {
[08:27:23.617]             ...future.startTime <- base::Sys.time()
[08:27:23.617]             {
[08:27:23.617]                 {
[08:27:23.617]                   {
[08:27:23.617]                     {
[08:27:23.617]                       {
[08:27:23.617]                         base::local({
[08:27:23.617]                           has_future <- base::requireNamespace("future", 
[08:27:23.617]                             quietly = TRUE)
[08:27:23.617]                           if (has_future) {
[08:27:23.617]                             ns <- base::getNamespace("future")
[08:27:23.617]                             version <- ns[[".package"]][["version"]]
[08:27:23.617]                             if (is.null(version)) 
[08:27:23.617]                               version <- utils::packageVersion("future")
[08:27:23.617]                           }
[08:27:23.617]                           else {
[08:27:23.617]                             version <- NULL
[08:27:23.617]                           }
[08:27:23.617]                           if (!has_future || version < "1.8.0") {
[08:27:23.617]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:23.617]                               "", base::R.version$version.string), 
[08:27:23.617]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:23.617]                                 base::R.version$platform, 8 * 
[08:27:23.617]                                   base::.Machine$sizeof.pointer), 
[08:27:23.617]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:23.617]                                 "release", "version")], collapse = " "), 
[08:27:23.617]                               hostname = base::Sys.info()[["nodename"]])
[08:27:23.617]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:23.617]                               info)
[08:27:23.617]                             info <- base::paste(info, collapse = "; ")
[08:27:23.617]                             if (!has_future) {
[08:27:23.617]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:23.617]                                 info)
[08:27:23.617]                             }
[08:27:23.617]                             else {
[08:27:23.617]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:23.617]                                 info, version)
[08:27:23.617]                             }
[08:27:23.617]                             base::stop(msg)
[08:27:23.617]                           }
[08:27:23.617]                         })
[08:27:23.617]                       }
[08:27:23.617]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:23.617]                       base::options(mc.cores = 1L)
[08:27:23.617]                     }
[08:27:23.617]                     base::local({
[08:27:23.617]                       for (pkg in "future") {
[08:27:23.617]                         base::loadNamespace(pkg)
[08:27:23.617]                         base::library(pkg, character.only = TRUE)
[08:27:23.617]                       }
[08:27:23.617]                     })
[08:27:23.617]                   }
[08:27:23.617]                   ...future.strategy.old <- future::plan("list")
[08:27:23.617]                   options(future.plan = NULL)
[08:27:23.617]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:23.617]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:23.617]                 }
[08:27:23.617]                 ...future.workdir <- getwd()
[08:27:23.617]             }
[08:27:23.617]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:23.617]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:23.617]         }
[08:27:23.617]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:23.617]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:23.617]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:23.617]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:23.617]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:23.617]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:23.617]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:23.617]             base::names(...future.oldOptions))
[08:27:23.617]     }
[08:27:23.617]     if (FALSE) {
[08:27:23.617]     }
[08:27:23.617]     else {
[08:27:23.617]         if (TRUE) {
[08:27:23.617]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:23.617]                 open = "w")
[08:27:23.617]         }
[08:27:23.617]         else {
[08:27:23.617]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:23.617]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:23.617]         }
[08:27:23.617]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:23.617]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:23.617]             base::sink(type = "output", split = FALSE)
[08:27:23.617]             base::close(...future.stdout)
[08:27:23.617]         }, add = TRUE)
[08:27:23.617]     }
[08:27:23.617]     ...future.frame <- base::sys.nframe()
[08:27:23.617]     ...future.conditions <- base::list()
[08:27:23.617]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:23.617]     if (FALSE) {
[08:27:23.617]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:23.617]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:23.617]     }
[08:27:23.617]     ...future.result <- base::tryCatch({
[08:27:23.617]         base::withCallingHandlers({
[08:27:23.617]             ...future.value <- base::withVisible(base::local({
[08:27:23.617]                 withCallingHandlers({
[08:27:23.617]                   {
[08:27:23.617]                     message(sprintf("Calculating tile #%d of %d ...", 
[08:27:23.617]                       ii, n), appendLF = FALSE)
[08:27:23.617]                     fit <- mandelbrot(C)
[08:27:23.617]                     delay(fit)
[08:27:23.617]                     message(" done")
[08:27:23.617]                     fit
[08:27:23.617]                   }
[08:27:23.617]                 }, immediateCondition = function(cond) {
[08:27:23.617]                   save_rds <- function (object, pathname, ...) 
[08:27:23.617]                   {
[08:27:23.617]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:23.617]                     if (file_test("-f", pathname_tmp)) {
[08:27:23.617]                       fi_tmp <- file.info(pathname_tmp)
[08:27:23.617]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:23.617]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:23.617]                         fi_tmp[["mtime"]])
[08:27:23.617]                     }
[08:27:23.617]                     tryCatch({
[08:27:23.617]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:23.617]                     }, error = function(ex) {
[08:27:23.617]                       msg <- conditionMessage(ex)
[08:27:23.617]                       fi_tmp <- file.info(pathname_tmp)
[08:27:23.617]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:23.617]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:23.617]                         fi_tmp[["mtime"]], msg)
[08:27:23.617]                       ex$message <- msg
[08:27:23.617]                       stop(ex)
[08:27:23.617]                     })
[08:27:23.617]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:23.617]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:23.617]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:23.617]                       fi_tmp <- file.info(pathname_tmp)
[08:27:23.617]                       fi <- file.info(pathname)
[08:27:23.617]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:23.617]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:23.617]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:23.617]                         fi[["size"]], fi[["mtime"]])
[08:27:23.617]                       stop(msg)
[08:27:23.617]                     }
[08:27:23.617]                     invisible(pathname)
[08:27:23.617]                   }
[08:27:23.617]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:23.617]                     rootPath = tempdir()) 
[08:27:23.617]                   {
[08:27:23.617]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:23.617]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:23.617]                       tmpdir = path, fileext = ".rds")
[08:27:23.617]                     save_rds(obj, file)
[08:27:23.617]                   }
[08:27:23.617]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0QGEgG/.future/immediateConditions")
[08:27:23.617]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:23.617]                   {
[08:27:23.617]                     inherits <- base::inherits
[08:27:23.617]                     invokeRestart <- base::invokeRestart
[08:27:23.617]                     is.null <- base::is.null
[08:27:23.617]                     muffled <- FALSE
[08:27:23.617]                     if (inherits(cond, "message")) {
[08:27:23.617]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:23.617]                       if (muffled) 
[08:27:23.617]                         invokeRestart("muffleMessage")
[08:27:23.617]                     }
[08:27:23.617]                     else if (inherits(cond, "warning")) {
[08:27:23.617]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:23.617]                       if (muffled) 
[08:27:23.617]                         invokeRestart("muffleWarning")
[08:27:23.617]                     }
[08:27:23.617]                     else if (inherits(cond, "condition")) {
[08:27:23.617]                       if (!is.null(pattern)) {
[08:27:23.617]                         computeRestarts <- base::computeRestarts
[08:27:23.617]                         grepl <- base::grepl
[08:27:23.617]                         restarts <- computeRestarts(cond)
[08:27:23.617]                         for (restart in restarts) {
[08:27:23.617]                           name <- restart$name
[08:27:23.617]                           if (is.null(name)) 
[08:27:23.617]                             next
[08:27:23.617]                           if (!grepl(pattern, name)) 
[08:27:23.617]                             next
[08:27:23.617]                           invokeRestart(restart)
[08:27:23.617]                           muffled <- TRUE
[08:27:23.617]                           break
[08:27:23.617]                         }
[08:27:23.617]                       }
[08:27:23.617]                     }
[08:27:23.617]                     invisible(muffled)
[08:27:23.617]                   }
[08:27:23.617]                   muffleCondition(cond)
[08:27:23.617]                 })
[08:27:23.617]             }))
[08:27:23.617]             future::FutureResult(value = ...future.value$value, 
[08:27:23.617]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:23.617]                   ...future.rng), globalenv = if (FALSE) 
[08:27:23.617]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:23.617]                     ...future.globalenv.names))
[08:27:23.617]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:23.617]         }, condition = base::local({
[08:27:23.617]             c <- base::c
[08:27:23.617]             inherits <- base::inherits
[08:27:23.617]             invokeRestart <- base::invokeRestart
[08:27:23.617]             length <- base::length
[08:27:23.617]             list <- base::list
[08:27:23.617]             seq.int <- base::seq.int
[08:27:23.617]             signalCondition <- base::signalCondition
[08:27:23.617]             sys.calls <- base::sys.calls
[08:27:23.617]             `[[` <- base::`[[`
[08:27:23.617]             `+` <- base::`+`
[08:27:23.617]             `<<-` <- base::`<<-`
[08:27:23.617]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:23.617]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:23.617]                   3L)]
[08:27:23.617]             }
[08:27:23.617]             function(cond) {
[08:27:23.617]                 is_error <- inherits(cond, "error")
[08:27:23.617]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:23.617]                   NULL)
[08:27:23.617]                 if (is_error) {
[08:27:23.617]                   sessionInformation <- function() {
[08:27:23.617]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:23.617]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:23.617]                       search = base::search(), system = base::Sys.info())
[08:27:23.617]                   }
[08:27:23.617]                   ...future.conditions[[length(...future.conditions) + 
[08:27:23.617]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:23.617]                     cond$call), session = sessionInformation(), 
[08:27:23.617]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:23.617]                   signalCondition(cond)
[08:27:23.617]                 }
[08:27:23.617]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:23.617]                 "immediateCondition"))) {
[08:27:23.617]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:23.617]                   ...future.conditions[[length(...future.conditions) + 
[08:27:23.617]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:23.617]                   if (TRUE && !signal) {
[08:27:23.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:23.617]                     {
[08:27:23.617]                       inherits <- base::inherits
[08:27:23.617]                       invokeRestart <- base::invokeRestart
[08:27:23.617]                       is.null <- base::is.null
[08:27:23.617]                       muffled <- FALSE
[08:27:23.617]                       if (inherits(cond, "message")) {
[08:27:23.617]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:23.617]                         if (muffled) 
[08:27:23.617]                           invokeRestart("muffleMessage")
[08:27:23.617]                       }
[08:27:23.617]                       else if (inherits(cond, "warning")) {
[08:27:23.617]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:23.617]                         if (muffled) 
[08:27:23.617]                           invokeRestart("muffleWarning")
[08:27:23.617]                       }
[08:27:23.617]                       else if (inherits(cond, "condition")) {
[08:27:23.617]                         if (!is.null(pattern)) {
[08:27:23.617]                           computeRestarts <- base::computeRestarts
[08:27:23.617]                           grepl <- base::grepl
[08:27:23.617]                           restarts <- computeRestarts(cond)
[08:27:23.617]                           for (restart in restarts) {
[08:27:23.617]                             name <- restart$name
[08:27:23.617]                             if (is.null(name)) 
[08:27:23.617]                               next
[08:27:23.617]                             if (!grepl(pattern, name)) 
[08:27:23.617]                               next
[08:27:23.617]                             invokeRestart(restart)
[08:27:23.617]                             muffled <- TRUE
[08:27:23.617]                             break
[08:27:23.617]                           }
[08:27:23.617]                         }
[08:27:23.617]                       }
[08:27:23.617]                       invisible(muffled)
[08:27:23.617]                     }
[08:27:23.617]                     muffleCondition(cond, pattern = "^muffle")
[08:27:23.617]                   }
[08:27:23.617]                 }
[08:27:23.617]                 else {
[08:27:23.617]                   if (TRUE) {
[08:27:23.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:23.617]                     {
[08:27:23.617]                       inherits <- base::inherits
[08:27:23.617]                       invokeRestart <- base::invokeRestart
[08:27:23.617]                       is.null <- base::is.null
[08:27:23.617]                       muffled <- FALSE
[08:27:23.617]                       if (inherits(cond, "message")) {
[08:27:23.617]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:23.617]                         if (muffled) 
[08:27:23.617]                           invokeRestart("muffleMessage")
[08:27:23.617]                       }
[08:27:23.617]                       else if (inherits(cond, "warning")) {
[08:27:23.617]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:23.617]                         if (muffled) 
[08:27:23.617]                           invokeRestart("muffleWarning")
[08:27:23.617]                       }
[08:27:23.617]                       else if (inherits(cond, "condition")) {
[08:27:23.617]                         if (!is.null(pattern)) {
[08:27:23.617]                           computeRestarts <- base::computeRestarts
[08:27:23.617]                           grepl <- base::grepl
[08:27:23.617]                           restarts <- computeRestarts(cond)
[08:27:23.617]                           for (restart in restarts) {
[08:27:23.617]                             name <- restart$name
[08:27:23.617]                             if (is.null(name)) 
[08:27:23.617]                               next
[08:27:23.617]                             if (!grepl(pattern, name)) 
[08:27:23.617]                               next
[08:27:23.617]                             invokeRestart(restart)
[08:27:23.617]                             muffled <- TRUE
[08:27:23.617]                             break
[08:27:23.617]                           }
[08:27:23.617]                         }
[08:27:23.617]                       }
[08:27:23.617]                       invisible(muffled)
[08:27:23.617]                     }
[08:27:23.617]                     muffleCondition(cond, pattern = "^muffle")
[08:27:23.617]                   }
[08:27:23.617]                 }
[08:27:23.617]             }
[08:27:23.617]         }))
[08:27:23.617]     }, error = function(ex) {
[08:27:23.617]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:23.617]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:23.617]                 ...future.rng), started = ...future.startTime, 
[08:27:23.617]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:23.617]             version = "1.8"), class = "FutureResult")
[08:27:23.617]     }, finally = {
[08:27:23.617]         if (!identical(...future.workdir, getwd())) 
[08:27:23.617]             setwd(...future.workdir)
[08:27:23.617]         {
[08:27:23.617]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:23.617]                 ...future.oldOptions$nwarnings <- NULL
[08:27:23.617]             }
[08:27:23.617]             base::options(...future.oldOptions)
[08:27:23.617]             if (.Platform$OS.type == "windows") {
[08:27:23.617]                 old_names <- names(...future.oldEnvVars)
[08:27:23.617]                 envs <- base::Sys.getenv()
[08:27:23.617]                 names <- names(envs)
[08:27:23.617]                 common <- intersect(names, old_names)
[08:27:23.617]                 added <- setdiff(names, old_names)
[08:27:23.617]                 removed <- setdiff(old_names, names)
[08:27:23.617]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:23.617]                   envs[common]]
[08:27:23.617]                 NAMES <- toupper(changed)
[08:27:23.617]                 args <- list()
[08:27:23.617]                 for (kk in seq_along(NAMES)) {
[08:27:23.617]                   name <- changed[[kk]]
[08:27:23.617]                   NAME <- NAMES[[kk]]
[08:27:23.617]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.617]                     next
[08:27:23.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:23.617]                 }
[08:27:23.617]                 NAMES <- toupper(added)
[08:27:23.617]                 for (kk in seq_along(NAMES)) {
[08:27:23.617]                   name <- added[[kk]]
[08:27:23.617]                   NAME <- NAMES[[kk]]
[08:27:23.617]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.617]                     next
[08:27:23.617]                   args[[name]] <- ""
[08:27:23.617]                 }
[08:27:23.617]                 NAMES <- toupper(removed)
[08:27:23.617]                 for (kk in seq_along(NAMES)) {
[08:27:23.617]                   name <- removed[[kk]]
[08:27:23.617]                   NAME <- NAMES[[kk]]
[08:27:23.617]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.617]                     next
[08:27:23.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:23.617]                 }
[08:27:23.617]                 if (length(args) > 0) 
[08:27:23.617]                   base::do.call(base::Sys.setenv, args = args)
[08:27:23.617]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:23.617]             }
[08:27:23.617]             else {
[08:27:23.617]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:23.617]             }
[08:27:23.617]             {
[08:27:23.617]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:23.617]                   0L) {
[08:27:23.617]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:23.617]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:23.617]                   base::options(opts)
[08:27:23.617]                 }
[08:27:23.617]                 {
[08:27:23.617]                   {
[08:27:23.617]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:23.617]                     NULL
[08:27:23.617]                   }
[08:27:23.617]                   options(future.plan = NULL)
[08:27:23.617]                   if (is.na(NA_character_)) 
[08:27:23.617]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:23.617]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:23.617]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:23.617]                     .init = FALSE)
[08:27:23.617]                 }
[08:27:23.617]             }
[08:27:23.617]         }
[08:27:23.617]     })
[08:27:23.617]     if (TRUE) {
[08:27:23.617]         base::sink(type = "output", split = FALSE)
[08:27:23.617]         if (TRUE) {
[08:27:23.617]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:23.617]         }
[08:27:23.617]         else {
[08:27:23.617]             ...future.result["stdout"] <- base::list(NULL)
[08:27:23.617]         }
[08:27:23.617]         base::close(...future.stdout)
[08:27:23.617]         ...future.stdout <- NULL
[08:27:23.617]     }
[08:27:23.617]     ...future.result$conditions <- ...future.conditions
[08:27:23.617]     ...future.result$finished <- base::Sys.time()
[08:27:23.617]     ...future.result
[08:27:23.617] }
[08:27:23.620] assign_globals() ...
[08:27:23.620] List of 4
[08:27:23.620]  $ ii   : int 2
[08:27:23.620]  $ n    : int 4
[08:27:23.620]  $ C    : cplx [1:25, 1:25] -0.719-1.5i -0.719-1.44i -0.719-1.38i ...
[08:27:23.620]   ..- attr(*, "region")=List of 2
[08:27:23.620]   .. ..$ xrange: num [1:2] -0.719 0.75
[08:27:23.620]   .. ..$ yrange: num [1:2] -1.5 -0.0306
[08:27:23.620]   ..- attr(*, "tile")= int [1:2] 1 2
[08:27:23.620]  $ delay:function (counts)  
[08:27:23.620]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[08:27:23.620]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x561dea221c10> 
[08:27:23.620]  - attr(*, "where")=List of 4
[08:27:23.620]   ..$ ii   :<environment: R_EmptyEnv> 
[08:27:23.620]   ..$ n    :<environment: R_EmptyEnv> 
[08:27:23.620]   ..$ C    :<environment: R_EmptyEnv> 
[08:27:23.620]   ..$ delay:<environment: R_EmptyEnv> 
[08:27:23.620]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:23.620]  - attr(*, "resolved")= logi FALSE
[08:27:23.620]  - attr(*, "total_size")= num 58781
[08:27:23.620]  - attr(*, "already-done")= logi TRUE
[08:27:23.627] - copied ‘ii’ to environment
[08:27:23.627] - copied ‘n’ to environment
[08:27:23.627] - copied ‘C’ to environment
[08:27:23.627] - reassign environment for ‘delay’
[08:27:23.628] - copied ‘delay’ to environment
[08:27:23.628] assign_globals() ... done
[08:27:23.628] requestCore(): workers = 2
[08:27:23.631] MulticoreFuture started
[08:27:23.631] - Launch lazy future ... done
[08:27:23.632] run() for ‘MulticoreFuture’ ... done
[08:27:23.632] - run() ... done
[08:27:23.632] - resolved() ...
[08:27:23.632] plan(): Setting new future strategy stack:
[08:27:23.632] List of future strategies:
[08:27:23.632] 1. sequential:
[08:27:23.632]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:23.632]    - tweaked: FALSE
[08:27:23.632]    - call: NULL
[08:27:23.634] plan(): nbrOfWorkers() = 1
[08:27:23.639] plan(): Setting new future strategy stack:
[08:27:23.639] List of future strategies:
[08:27:23.639] 1. multicore:
[08:27:23.639]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:23.639]    - tweaked: FALSE
[08:27:23.639]    - call: plan(strategy)
[08:27:23.642] plan(): nbrOfWorkers() = 2
[08:27:23.643] - resolved: TRUE
[08:27:23.643] - resolved() ... done
[08:27:23.643] resolved() for ‘MulticoreFuture’ ... done
Plotting tile #2 of 4 ...
[08:27:23.643] result() for MulticoreFuture ...
[08:27:23.645] result() for MulticoreFuture ...
[08:27:23.645] result() for MulticoreFuture ... done
[08:27:23.645] signalConditions() ...
[08:27:23.645]  - include = ‘immediateCondition’
[08:27:23.645]  - exclude = 
[08:27:23.646]  - resignal = FALSE
[08:27:23.646]  - Number of conditions: 2
[08:27:23.646] signalConditions() ... done
[08:27:23.646] result() for MulticoreFuture ... done
[08:27:23.646] result() for MulticoreFuture ...
[08:27:23.646] result() for MulticoreFuture ... done
[08:27:23.646] signalConditions() ...
[08:27:23.646]  - include = ‘immediateCondition’
[08:27:23.646]  - exclude = 
[08:27:23.647]  - resignal = FALSE
[08:27:23.647]  - Number of conditions: 2
[08:27:23.647] signalConditions() ... done
[08:27:23.647] Future state: ‘finished’
[08:27:23.647] result() for MulticoreFuture ...
[08:27:23.647] result() for MulticoreFuture ... done
[08:27:23.647] signalConditions() ...
[08:27:23.647]  - include = ‘condition’
[08:27:23.648]  - exclude = ‘immediateCondition’
[08:27:23.648]  - resignal = TRUE
[08:27:23.648]  - Number of conditions: 2
[08:27:23.648]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[08:27:23.648]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[08:27:23.648] signalConditions() ... done
[08:27:23.649] resolved() for ‘Future’ ...
[08:27:23.649] - state: ‘created’
[08:27:23.650] - run: TRUE
[08:27:23.650] - run() ...
[08:27:23.650] run() for ‘Future’ ...
[08:27:23.650] - state: ‘created’
[08:27:23.650] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:23.653] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:23.653] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:23.653]   - Field: ‘label’
[08:27:23.653]   - Field: ‘local’
[08:27:23.653]   - Field: ‘owner’
[08:27:23.653]   - Field: ‘envir’
[08:27:23.653]   - Field: ‘workers’
[08:27:23.653]   - Field: ‘packages’
[08:27:23.654]   - Field: ‘gc’
[08:27:23.654]   - Field: ‘job’
[08:27:23.654]   - Field: ‘conditions’
[08:27:23.654]   - Field: ‘expr’
[08:27:23.654]   - Field: ‘uuid’
[08:27:23.654]   - Field: ‘seed’
[08:27:23.654]   - Field: ‘version’
[08:27:23.654]   - Field: ‘result’
[08:27:23.654]   - Field: ‘asynchronous’
[08:27:23.654]   - Field: ‘calls’
[08:27:23.655]   - Field: ‘globals’
[08:27:23.655]   - Field: ‘stdout’
[08:27:23.655]   - Field: ‘earlySignal’
[08:27:23.655]   - Field: ‘lazy’
[08:27:23.655]   - Field: ‘state’
[08:27:23.655] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:23.655] - Launch lazy future ...
[08:27:23.656] Packages needed by the future expression (n = 1): ‘future’
[08:27:23.656] Packages needed by future strategies (n = 0): <none>
[08:27:23.656] {
[08:27:23.656]     {
[08:27:23.656]         {
[08:27:23.656]             ...future.startTime <- base::Sys.time()
[08:27:23.656]             {
[08:27:23.656]                 {
[08:27:23.656]                   {
[08:27:23.656]                     {
[08:27:23.656]                       {
[08:27:23.656]                         base::local({
[08:27:23.656]                           has_future <- base::requireNamespace("future", 
[08:27:23.656]                             quietly = TRUE)
[08:27:23.656]                           if (has_future) {
[08:27:23.656]                             ns <- base::getNamespace("future")
[08:27:23.656]                             version <- ns[[".package"]][["version"]]
[08:27:23.656]                             if (is.null(version)) 
[08:27:23.656]                               version <- utils::packageVersion("future")
[08:27:23.656]                           }
[08:27:23.656]                           else {
[08:27:23.656]                             version <- NULL
[08:27:23.656]                           }
[08:27:23.656]                           if (!has_future || version < "1.8.0") {
[08:27:23.656]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:23.656]                               "", base::R.version$version.string), 
[08:27:23.656]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:23.656]                                 base::R.version$platform, 8 * 
[08:27:23.656]                                   base::.Machine$sizeof.pointer), 
[08:27:23.656]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:23.656]                                 "release", "version")], collapse = " "), 
[08:27:23.656]                               hostname = base::Sys.info()[["nodename"]])
[08:27:23.656]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:23.656]                               info)
[08:27:23.656]                             info <- base::paste(info, collapse = "; ")
[08:27:23.656]                             if (!has_future) {
[08:27:23.656]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:23.656]                                 info)
[08:27:23.656]                             }
[08:27:23.656]                             else {
[08:27:23.656]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:23.656]                                 info, version)
[08:27:23.656]                             }
[08:27:23.656]                             base::stop(msg)
[08:27:23.656]                           }
[08:27:23.656]                         })
[08:27:23.656]                       }
[08:27:23.656]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:23.656]                       base::options(mc.cores = 1L)
[08:27:23.656]                     }
[08:27:23.656]                     base::local({
[08:27:23.656]                       for (pkg in "future") {
[08:27:23.656]                         base::loadNamespace(pkg)
[08:27:23.656]                         base::library(pkg, character.only = TRUE)
[08:27:23.656]                       }
[08:27:23.656]                     })
[08:27:23.656]                   }
[08:27:23.656]                   ...future.strategy.old <- future::plan("list")
[08:27:23.656]                   options(future.plan = NULL)
[08:27:23.656]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:23.656]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:23.656]                 }
[08:27:23.656]                 ...future.workdir <- getwd()
[08:27:23.656]             }
[08:27:23.656]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:23.656]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:23.656]         }
[08:27:23.656]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:23.656]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:23.656]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:23.656]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:23.656]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:23.656]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:23.656]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:23.656]             base::names(...future.oldOptions))
[08:27:23.656]     }
[08:27:23.656]     if (FALSE) {
[08:27:23.656]     }
[08:27:23.656]     else {
[08:27:23.656]         if (TRUE) {
[08:27:23.656]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:23.656]                 open = "w")
[08:27:23.656]         }
[08:27:23.656]         else {
[08:27:23.656]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:23.656]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:23.656]         }
[08:27:23.656]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:23.656]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:23.656]             base::sink(type = "output", split = FALSE)
[08:27:23.656]             base::close(...future.stdout)
[08:27:23.656]         }, add = TRUE)
[08:27:23.656]     }
[08:27:23.656]     ...future.frame <- base::sys.nframe()
[08:27:23.656]     ...future.conditions <- base::list()
[08:27:23.656]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:23.656]     if (FALSE) {
[08:27:23.656]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:23.656]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:23.656]     }
[08:27:23.656]     ...future.result <- base::tryCatch({
[08:27:23.656]         base::withCallingHandlers({
[08:27:23.656]             ...future.value <- base::withVisible(base::local({
[08:27:23.656]                 withCallingHandlers({
[08:27:23.656]                   {
[08:27:23.656]                     message(sprintf("Calculating tile #%d of %d ...", 
[08:27:23.656]                       ii, n), appendLF = FALSE)
[08:27:23.656]                     fit <- mandelbrot(C)
[08:27:23.656]                     delay(fit)
[08:27:23.656]                     message(" done")
[08:27:23.656]                     fit
[08:27:23.656]                   }
[08:27:23.656]                 }, immediateCondition = function(cond) {
[08:27:23.656]                   save_rds <- function (object, pathname, ...) 
[08:27:23.656]                   {
[08:27:23.656]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:23.656]                     if (file_test("-f", pathname_tmp)) {
[08:27:23.656]                       fi_tmp <- file.info(pathname_tmp)
[08:27:23.656]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:23.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:23.656]                         fi_tmp[["mtime"]])
[08:27:23.656]                     }
[08:27:23.656]                     tryCatch({
[08:27:23.656]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:23.656]                     }, error = function(ex) {
[08:27:23.656]                       msg <- conditionMessage(ex)
[08:27:23.656]                       fi_tmp <- file.info(pathname_tmp)
[08:27:23.656]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:23.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:23.656]                         fi_tmp[["mtime"]], msg)
[08:27:23.656]                       ex$message <- msg
[08:27:23.656]                       stop(ex)
[08:27:23.656]                     })
[08:27:23.656]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:23.656]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:23.656]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:23.656]                       fi_tmp <- file.info(pathname_tmp)
[08:27:23.656]                       fi <- file.info(pathname)
[08:27:23.656]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:23.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:23.656]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:23.656]                         fi[["size"]], fi[["mtime"]])
[08:27:23.656]                       stop(msg)
[08:27:23.656]                     }
[08:27:23.656]                     invisible(pathname)
[08:27:23.656]                   }
[08:27:23.656]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:23.656]                     rootPath = tempdir()) 
[08:27:23.656]                   {
[08:27:23.656]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:23.656]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:23.656]                       tmpdir = path, fileext = ".rds")
[08:27:23.656]                     save_rds(obj, file)
[08:27:23.656]                   }
[08:27:23.656]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0QGEgG/.future/immediateConditions")
[08:27:23.656]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:23.656]                   {
[08:27:23.656]                     inherits <- base::inherits
[08:27:23.656]                     invokeRestart <- base::invokeRestart
[08:27:23.656]                     is.null <- base::is.null
[08:27:23.656]                     muffled <- FALSE
[08:27:23.656]                     if (inherits(cond, "message")) {
[08:27:23.656]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:23.656]                       if (muffled) 
[08:27:23.656]                         invokeRestart("muffleMessage")
[08:27:23.656]                     }
[08:27:23.656]                     else if (inherits(cond, "warning")) {
[08:27:23.656]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:23.656]                       if (muffled) 
[08:27:23.656]                         invokeRestart("muffleWarning")
[08:27:23.656]                     }
[08:27:23.656]                     else if (inherits(cond, "condition")) {
[08:27:23.656]                       if (!is.null(pattern)) {
[08:27:23.656]                         computeRestarts <- base::computeRestarts
[08:27:23.656]                         grepl <- base::grepl
[08:27:23.656]                         restarts <- computeRestarts(cond)
[08:27:23.656]                         for (restart in restarts) {
[08:27:23.656]                           name <- restart$name
[08:27:23.656]                           if (is.null(name)) 
[08:27:23.656]                             next
[08:27:23.656]                           if (!grepl(pattern, name)) 
[08:27:23.656]                             next
[08:27:23.656]                           invokeRestart(restart)
[08:27:23.656]                           muffled <- TRUE
[08:27:23.656]                           break
[08:27:23.656]                         }
[08:27:23.656]                       }
[08:27:23.656]                     }
[08:27:23.656]                     invisible(muffled)
[08:27:23.656]                   }
[08:27:23.656]                   muffleCondition(cond)
[08:27:23.656]                 })
[08:27:23.656]             }))
[08:27:23.656]             future::FutureResult(value = ...future.value$value, 
[08:27:23.656]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:23.656]                   ...future.rng), globalenv = if (FALSE) 
[08:27:23.656]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:23.656]                     ...future.globalenv.names))
[08:27:23.656]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:23.656]         }, condition = base::local({
[08:27:23.656]             c <- base::c
[08:27:23.656]             inherits <- base::inherits
[08:27:23.656]             invokeRestart <- base::invokeRestart
[08:27:23.656]             length <- base::length
[08:27:23.656]             list <- base::list
[08:27:23.656]             seq.int <- base::seq.int
[08:27:23.656]             signalCondition <- base::signalCondition
[08:27:23.656]             sys.calls <- base::sys.calls
[08:27:23.656]             `[[` <- base::`[[`
[08:27:23.656]             `+` <- base::`+`
[08:27:23.656]             `<<-` <- base::`<<-`
[08:27:23.656]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:23.656]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:23.656]                   3L)]
[08:27:23.656]             }
[08:27:23.656]             function(cond) {
[08:27:23.656]                 is_error <- inherits(cond, "error")
[08:27:23.656]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:23.656]                   NULL)
[08:27:23.656]                 if (is_error) {
[08:27:23.656]                   sessionInformation <- function() {
[08:27:23.656]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:23.656]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:23.656]                       search = base::search(), system = base::Sys.info())
[08:27:23.656]                   }
[08:27:23.656]                   ...future.conditions[[length(...future.conditions) + 
[08:27:23.656]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:23.656]                     cond$call), session = sessionInformation(), 
[08:27:23.656]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:23.656]                   signalCondition(cond)
[08:27:23.656]                 }
[08:27:23.656]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:23.656]                 "immediateCondition"))) {
[08:27:23.656]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:23.656]                   ...future.conditions[[length(...future.conditions) + 
[08:27:23.656]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:23.656]                   if (TRUE && !signal) {
[08:27:23.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:23.656]                     {
[08:27:23.656]                       inherits <- base::inherits
[08:27:23.656]                       invokeRestart <- base::invokeRestart
[08:27:23.656]                       is.null <- base::is.null
[08:27:23.656]                       muffled <- FALSE
[08:27:23.656]                       if (inherits(cond, "message")) {
[08:27:23.656]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:23.656]                         if (muffled) 
[08:27:23.656]                           invokeRestart("muffleMessage")
[08:27:23.656]                       }
[08:27:23.656]                       else if (inherits(cond, "warning")) {
[08:27:23.656]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:23.656]                         if (muffled) 
[08:27:23.656]                           invokeRestart("muffleWarning")
[08:27:23.656]                       }
[08:27:23.656]                       else if (inherits(cond, "condition")) {
[08:27:23.656]                         if (!is.null(pattern)) {
[08:27:23.656]                           computeRestarts <- base::computeRestarts
[08:27:23.656]                           grepl <- base::grepl
[08:27:23.656]                           restarts <- computeRestarts(cond)
[08:27:23.656]                           for (restart in restarts) {
[08:27:23.656]                             name <- restart$name
[08:27:23.656]                             if (is.null(name)) 
[08:27:23.656]                               next
[08:27:23.656]                             if (!grepl(pattern, name)) 
[08:27:23.656]                               next
[08:27:23.656]                             invokeRestart(restart)
[08:27:23.656]                             muffled <- TRUE
[08:27:23.656]                             break
[08:27:23.656]                           }
[08:27:23.656]                         }
[08:27:23.656]                       }
[08:27:23.656]                       invisible(muffled)
[08:27:23.656]                     }
[08:27:23.656]                     muffleCondition(cond, pattern = "^muffle")
[08:27:23.656]                   }
[08:27:23.656]                 }
[08:27:23.656]                 else {
[08:27:23.656]                   if (TRUE) {
[08:27:23.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:23.656]                     {
[08:27:23.656]                       inherits <- base::inherits
[08:27:23.656]                       invokeRestart <- base::invokeRestart
[08:27:23.656]                       is.null <- base::is.null
[08:27:23.656]                       muffled <- FALSE
[08:27:23.656]                       if (inherits(cond, "message")) {
[08:27:23.656]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:23.656]                         if (muffled) 
[08:27:23.656]                           invokeRestart("muffleMessage")
[08:27:23.656]                       }
[08:27:23.656]                       else if (inherits(cond, "warning")) {
[08:27:23.656]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:23.656]                         if (muffled) 
[08:27:23.656]                           invokeRestart("muffleWarning")
[08:27:23.656]                       }
[08:27:23.656]                       else if (inherits(cond, "condition")) {
[08:27:23.656]                         if (!is.null(pattern)) {
[08:27:23.656]                           computeRestarts <- base::computeRestarts
[08:27:23.656]                           grepl <- base::grepl
[08:27:23.656]                           restarts <- computeRestarts(cond)
[08:27:23.656]                           for (restart in restarts) {
[08:27:23.656]                             name <- restart$name
[08:27:23.656]                             if (is.null(name)) 
[08:27:23.656]                               next
[08:27:23.656]                             if (!grepl(pattern, name)) 
[08:27:23.656]                               next
[08:27:23.656]                             invokeRestart(restart)
[08:27:23.656]                             muffled <- TRUE
[08:27:23.656]                             break
[08:27:23.656]                           }
[08:27:23.656]                         }
[08:27:23.656]                       }
[08:27:23.656]                       invisible(muffled)
[08:27:23.656]                     }
[08:27:23.656]                     muffleCondition(cond, pattern = "^muffle")
[08:27:23.656]                   }
[08:27:23.656]                 }
[08:27:23.656]             }
[08:27:23.656]         }))
[08:27:23.656]     }, error = function(ex) {
[08:27:23.656]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:23.656]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:23.656]                 ...future.rng), started = ...future.startTime, 
[08:27:23.656]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:23.656]             version = "1.8"), class = "FutureResult")
[08:27:23.656]     }, finally = {
[08:27:23.656]         if (!identical(...future.workdir, getwd())) 
[08:27:23.656]             setwd(...future.workdir)
[08:27:23.656]         {
[08:27:23.656]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:23.656]                 ...future.oldOptions$nwarnings <- NULL
[08:27:23.656]             }
[08:27:23.656]             base::options(...future.oldOptions)
[08:27:23.656]             if (.Platform$OS.type == "windows") {
[08:27:23.656]                 old_names <- names(...future.oldEnvVars)
[08:27:23.656]                 envs <- base::Sys.getenv()
[08:27:23.656]                 names <- names(envs)
[08:27:23.656]                 common <- intersect(names, old_names)
[08:27:23.656]                 added <- setdiff(names, old_names)
[08:27:23.656]                 removed <- setdiff(old_names, names)
[08:27:23.656]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:23.656]                   envs[common]]
[08:27:23.656]                 NAMES <- toupper(changed)
[08:27:23.656]                 args <- list()
[08:27:23.656]                 for (kk in seq_along(NAMES)) {
[08:27:23.656]                   name <- changed[[kk]]
[08:27:23.656]                   NAME <- NAMES[[kk]]
[08:27:23.656]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.656]                     next
[08:27:23.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:23.656]                 }
[08:27:23.656]                 NAMES <- toupper(added)
[08:27:23.656]                 for (kk in seq_along(NAMES)) {
[08:27:23.656]                   name <- added[[kk]]
[08:27:23.656]                   NAME <- NAMES[[kk]]
[08:27:23.656]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.656]                     next
[08:27:23.656]                   args[[name]] <- ""
[08:27:23.656]                 }
[08:27:23.656]                 NAMES <- toupper(removed)
[08:27:23.656]                 for (kk in seq_along(NAMES)) {
[08:27:23.656]                   name <- removed[[kk]]
[08:27:23.656]                   NAME <- NAMES[[kk]]
[08:27:23.656]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.656]                     next
[08:27:23.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:23.656]                 }
[08:27:23.656]                 if (length(args) > 0) 
[08:27:23.656]                   base::do.call(base::Sys.setenv, args = args)
[08:27:23.656]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:23.656]             }
[08:27:23.656]             else {
[08:27:23.656]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:23.656]             }
[08:27:23.656]             {
[08:27:23.656]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:23.656]                   0L) {
[08:27:23.656]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:23.656]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:23.656]                   base::options(opts)
[08:27:23.656]                 }
[08:27:23.656]                 {
[08:27:23.656]                   {
[08:27:23.656]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:23.656]                     NULL
[08:27:23.656]                   }
[08:27:23.656]                   options(future.plan = NULL)
[08:27:23.656]                   if (is.na(NA_character_)) 
[08:27:23.656]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:23.656]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:23.656]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:23.656]                     .init = FALSE)
[08:27:23.656]                 }
[08:27:23.656]             }
[08:27:23.656]         }
[08:27:23.656]     })
[08:27:23.656]     if (TRUE) {
[08:27:23.656]         base::sink(type = "output", split = FALSE)
[08:27:23.656]         if (TRUE) {
[08:27:23.656]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:23.656]         }
[08:27:23.656]         else {
[08:27:23.656]             ...future.result["stdout"] <- base::list(NULL)
[08:27:23.656]         }
[08:27:23.656]         base::close(...future.stdout)
[08:27:23.656]         ...future.stdout <- NULL
[08:27:23.656]     }
[08:27:23.656]     ...future.result$conditions <- ...future.conditions
[08:27:23.656]     ...future.result$finished <- base::Sys.time()
[08:27:23.656]     ...future.result
[08:27:23.656] }
[08:27:23.659] assign_globals() ...
[08:27:23.660] List of 4
[08:27:23.660]  $ ii   : int 3
[08:27:23.660]  $ n    : int 4
[08:27:23.660]  $ C    : cplx [1:25, 1:25] -2.25+0.0306i -2.25+0.0918i -2.25+0.1531i ...
[08:27:23.660]   ..- attr(*, "region")=List of 2
[08:27:23.660]   .. ..$ xrange: num [1:2] -2.25 -0.781
[08:27:23.660]   .. ..$ yrange: num [1:2] 0.0306 1.5
[08:27:23.660]   ..- attr(*, "tile")= int [1:2] 2 1
[08:27:23.660]  $ delay:function (counts)  
[08:27:23.660]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[08:27:23.660]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x561dea221c10> 
[08:27:23.660]  - attr(*, "where")=List of 4
[08:27:23.660]   ..$ ii   :<environment: R_EmptyEnv> 
[08:27:23.660]   ..$ n    :<environment: R_EmptyEnv> 
[08:27:23.660]   ..$ C    :<environment: R_EmptyEnv> 
[08:27:23.660]   ..$ delay:<environment: R_EmptyEnv> 
[08:27:23.660]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:23.660]  - attr(*, "resolved")= logi FALSE
[08:27:23.660]  - attr(*, "total_size")= num 58781
[08:27:23.660]  - attr(*, "already-done")= logi TRUE
[08:27:23.668] - copied ‘ii’ to environment
[08:27:23.668] - copied ‘n’ to environment
[08:27:23.668] - copied ‘C’ to environment
[08:27:23.668] - reassign environment for ‘delay’
[08:27:23.668] - copied ‘delay’ to environment
[08:27:23.668] assign_globals() ... done
[08:27:23.669] requestCore(): workers = 2
[08:27:23.671] MulticoreFuture started
[08:27:23.672] - Launch lazy future ... done
[08:27:23.672] run() for ‘MulticoreFuture’ ... done
[08:27:23.672] - run() ... done
[08:27:23.672] - resolved() ...
[08:27:23.673] plan(): Setting new future strategy stack:
[08:27:23.673] List of future strategies:
[08:27:23.673] 1. sequential:
[08:27:23.673]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:23.673]    - tweaked: FALSE
[08:27:23.673]    - call: NULL
[08:27:23.674] plan(): nbrOfWorkers() = 1
[08:27:23.679] plan(): Setting new future strategy stack:
[08:27:23.679] List of future strategies:
[08:27:23.679] 1. multicore:
[08:27:23.679]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:23.679]    - tweaked: FALSE
[08:27:23.679]    - call: plan(strategy)
[08:27:23.682] plan(): nbrOfWorkers() = 2
[08:27:23.683] - resolved: TRUE
[08:27:23.683] - resolved() ... done
[08:27:23.683] resolved() for ‘MulticoreFuture’ ... done
Plotting tile #3 of 4 ...
[08:27:23.684] result() for MulticoreFuture ...
[08:27:23.685] result() for MulticoreFuture ...
[08:27:23.685] result() for MulticoreFuture ... done
[08:27:23.685] signalConditions() ...
[08:27:23.686]  - include = ‘immediateCondition’
[08:27:23.686]  - exclude = 
[08:27:23.686]  - resignal = FALSE
[08:27:23.686]  - Number of conditions: 2
[08:27:23.686] signalConditions() ... done
[08:27:23.686] result() for MulticoreFuture ... done
[08:27:23.686] result() for MulticoreFuture ...
[08:27:23.686] result() for MulticoreFuture ... done
[08:27:23.686] signalConditions() ...
[08:27:23.687]  - include = ‘immediateCondition’
[08:27:23.687]  - exclude = 
[08:27:23.687]  - resignal = FALSE
[08:27:23.687]  - Number of conditions: 2
[08:27:23.687] signalConditions() ... done
[08:27:23.687] Future state: ‘finished’
[08:27:23.687] result() for MulticoreFuture ...
[08:27:23.687] result() for MulticoreFuture ... done
[08:27:23.687] signalConditions() ...
[08:27:23.688]  - include = ‘condition’
[08:27:23.688]  - exclude = ‘immediateCondition’
[08:27:23.688]  - resignal = TRUE
[08:27:23.688]  - Number of conditions: 2
[08:27:23.688]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[08:27:23.688]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[08:27:23.688] signalConditions() ... done
[08:27:23.689] resolved() for ‘Future’ ...
[08:27:23.690] - state: ‘created’
[08:27:23.690] - run: TRUE
[08:27:23.690] - run() ...
[08:27:23.690] run() for ‘Future’ ...
[08:27:23.690] - state: ‘created’
[08:27:23.690] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:23.693] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:23.693] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:23.693]   - Field: ‘label’
[08:27:23.693]   - Field: ‘local’
[08:27:23.693]   - Field: ‘owner’
[08:27:23.693]   - Field: ‘envir’
[08:27:23.693]   - Field: ‘workers’
[08:27:23.694]   - Field: ‘packages’
[08:27:23.694]   - Field: ‘gc’
[08:27:23.694]   - Field: ‘job’
[08:27:23.694]   - Field: ‘conditions’
[08:27:23.694]   - Field: ‘expr’
[08:27:23.694]   - Field: ‘uuid’
[08:27:23.694]   - Field: ‘seed’
[08:27:23.694]   - Field: ‘version’
[08:27:23.694]   - Field: ‘result’
[08:27:23.694]   - Field: ‘asynchronous’
[08:27:23.695]   - Field: ‘calls’
[08:27:23.695]   - Field: ‘globals’
[08:27:23.695]   - Field: ‘stdout’
[08:27:23.695]   - Field: ‘earlySignal’
[08:27:23.695]   - Field: ‘lazy’
[08:27:23.695]   - Field: ‘state’
[08:27:23.695] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:23.695] - Launch lazy future ...
[08:27:23.696] Packages needed by the future expression (n = 1): ‘future’
[08:27:23.696] Packages needed by future strategies (n = 0): <none>
[08:27:23.697] {
[08:27:23.697]     {
[08:27:23.697]         {
[08:27:23.697]             ...future.startTime <- base::Sys.time()
[08:27:23.697]             {
[08:27:23.697]                 {
[08:27:23.697]                   {
[08:27:23.697]                     {
[08:27:23.697]                       {
[08:27:23.697]                         base::local({
[08:27:23.697]                           has_future <- base::requireNamespace("future", 
[08:27:23.697]                             quietly = TRUE)
[08:27:23.697]                           if (has_future) {
[08:27:23.697]                             ns <- base::getNamespace("future")
[08:27:23.697]                             version <- ns[[".package"]][["version"]]
[08:27:23.697]                             if (is.null(version)) 
[08:27:23.697]                               version <- utils::packageVersion("future")
[08:27:23.697]                           }
[08:27:23.697]                           else {
[08:27:23.697]                             version <- NULL
[08:27:23.697]                           }
[08:27:23.697]                           if (!has_future || version < "1.8.0") {
[08:27:23.697]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:23.697]                               "", base::R.version$version.string), 
[08:27:23.697]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:23.697]                                 base::R.version$platform, 8 * 
[08:27:23.697]                                   base::.Machine$sizeof.pointer), 
[08:27:23.697]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:23.697]                                 "release", "version")], collapse = " "), 
[08:27:23.697]                               hostname = base::Sys.info()[["nodename"]])
[08:27:23.697]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:23.697]                               info)
[08:27:23.697]                             info <- base::paste(info, collapse = "; ")
[08:27:23.697]                             if (!has_future) {
[08:27:23.697]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:23.697]                                 info)
[08:27:23.697]                             }
[08:27:23.697]                             else {
[08:27:23.697]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:23.697]                                 info, version)
[08:27:23.697]                             }
[08:27:23.697]                             base::stop(msg)
[08:27:23.697]                           }
[08:27:23.697]                         })
[08:27:23.697]                       }
[08:27:23.697]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:23.697]                       base::options(mc.cores = 1L)
[08:27:23.697]                     }
[08:27:23.697]                     base::local({
[08:27:23.697]                       for (pkg in "future") {
[08:27:23.697]                         base::loadNamespace(pkg)
[08:27:23.697]                         base::library(pkg, character.only = TRUE)
[08:27:23.697]                       }
[08:27:23.697]                     })
[08:27:23.697]                   }
[08:27:23.697]                   ...future.strategy.old <- future::plan("list")
[08:27:23.697]                   options(future.plan = NULL)
[08:27:23.697]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:23.697]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:23.697]                 }
[08:27:23.697]                 ...future.workdir <- getwd()
[08:27:23.697]             }
[08:27:23.697]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:23.697]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:23.697]         }
[08:27:23.697]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:23.697]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:23.697]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:23.697]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:23.697]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:23.697]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:23.697]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:23.697]             base::names(...future.oldOptions))
[08:27:23.697]     }
[08:27:23.697]     if (FALSE) {
[08:27:23.697]     }
[08:27:23.697]     else {
[08:27:23.697]         if (TRUE) {
[08:27:23.697]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:23.697]                 open = "w")
[08:27:23.697]         }
[08:27:23.697]         else {
[08:27:23.697]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:23.697]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:23.697]         }
[08:27:23.697]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:23.697]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:23.697]             base::sink(type = "output", split = FALSE)
[08:27:23.697]             base::close(...future.stdout)
[08:27:23.697]         }, add = TRUE)
[08:27:23.697]     }
[08:27:23.697]     ...future.frame <- base::sys.nframe()
[08:27:23.697]     ...future.conditions <- base::list()
[08:27:23.697]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:23.697]     if (FALSE) {
[08:27:23.697]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:23.697]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:23.697]     }
[08:27:23.697]     ...future.result <- base::tryCatch({
[08:27:23.697]         base::withCallingHandlers({
[08:27:23.697]             ...future.value <- base::withVisible(base::local({
[08:27:23.697]                 withCallingHandlers({
[08:27:23.697]                   {
[08:27:23.697]                     message(sprintf("Calculating tile #%d of %d ...", 
[08:27:23.697]                       ii, n), appendLF = FALSE)
[08:27:23.697]                     fit <- mandelbrot(C)
[08:27:23.697]                     delay(fit)
[08:27:23.697]                     message(" done")
[08:27:23.697]                     fit
[08:27:23.697]                   }
[08:27:23.697]                 }, immediateCondition = function(cond) {
[08:27:23.697]                   save_rds <- function (object, pathname, ...) 
[08:27:23.697]                   {
[08:27:23.697]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:23.697]                     if (file_test("-f", pathname_tmp)) {
[08:27:23.697]                       fi_tmp <- file.info(pathname_tmp)
[08:27:23.697]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:23.697]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:23.697]                         fi_tmp[["mtime"]])
[08:27:23.697]                     }
[08:27:23.697]                     tryCatch({
[08:27:23.697]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:23.697]                     }, error = function(ex) {
[08:27:23.697]                       msg <- conditionMessage(ex)
[08:27:23.697]                       fi_tmp <- file.info(pathname_tmp)
[08:27:23.697]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:23.697]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:23.697]                         fi_tmp[["mtime"]], msg)
[08:27:23.697]                       ex$message <- msg
[08:27:23.697]                       stop(ex)
[08:27:23.697]                     })
[08:27:23.697]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:23.697]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:23.697]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:23.697]                       fi_tmp <- file.info(pathname_tmp)
[08:27:23.697]                       fi <- file.info(pathname)
[08:27:23.697]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:23.697]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:23.697]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:23.697]                         fi[["size"]], fi[["mtime"]])
[08:27:23.697]                       stop(msg)
[08:27:23.697]                     }
[08:27:23.697]                     invisible(pathname)
[08:27:23.697]                   }
[08:27:23.697]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:23.697]                     rootPath = tempdir()) 
[08:27:23.697]                   {
[08:27:23.697]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:23.697]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:23.697]                       tmpdir = path, fileext = ".rds")
[08:27:23.697]                     save_rds(obj, file)
[08:27:23.697]                   }
[08:27:23.697]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0QGEgG/.future/immediateConditions")
[08:27:23.697]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:23.697]                   {
[08:27:23.697]                     inherits <- base::inherits
[08:27:23.697]                     invokeRestart <- base::invokeRestart
[08:27:23.697]                     is.null <- base::is.null
[08:27:23.697]                     muffled <- FALSE
[08:27:23.697]                     if (inherits(cond, "message")) {
[08:27:23.697]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:23.697]                       if (muffled) 
[08:27:23.697]                         invokeRestart("muffleMessage")
[08:27:23.697]                     }
[08:27:23.697]                     else if (inherits(cond, "warning")) {
[08:27:23.697]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:23.697]                       if (muffled) 
[08:27:23.697]                         invokeRestart("muffleWarning")
[08:27:23.697]                     }
[08:27:23.697]                     else if (inherits(cond, "condition")) {
[08:27:23.697]                       if (!is.null(pattern)) {
[08:27:23.697]                         computeRestarts <- base::computeRestarts
[08:27:23.697]                         grepl <- base::grepl
[08:27:23.697]                         restarts <- computeRestarts(cond)
[08:27:23.697]                         for (restart in restarts) {
[08:27:23.697]                           name <- restart$name
[08:27:23.697]                           if (is.null(name)) 
[08:27:23.697]                             next
[08:27:23.697]                           if (!grepl(pattern, name)) 
[08:27:23.697]                             next
[08:27:23.697]                           invokeRestart(restart)
[08:27:23.697]                           muffled <- TRUE
[08:27:23.697]                           break
[08:27:23.697]                         }
[08:27:23.697]                       }
[08:27:23.697]                     }
[08:27:23.697]                     invisible(muffled)
[08:27:23.697]                   }
[08:27:23.697]                   muffleCondition(cond)
[08:27:23.697]                 })
[08:27:23.697]             }))
[08:27:23.697]             future::FutureResult(value = ...future.value$value, 
[08:27:23.697]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:23.697]                   ...future.rng), globalenv = if (FALSE) 
[08:27:23.697]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:23.697]                     ...future.globalenv.names))
[08:27:23.697]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:23.697]         }, condition = base::local({
[08:27:23.697]             c <- base::c
[08:27:23.697]             inherits <- base::inherits
[08:27:23.697]             invokeRestart <- base::invokeRestart
[08:27:23.697]             length <- base::length
[08:27:23.697]             list <- base::list
[08:27:23.697]             seq.int <- base::seq.int
[08:27:23.697]             signalCondition <- base::signalCondition
[08:27:23.697]             sys.calls <- base::sys.calls
[08:27:23.697]             `[[` <- base::`[[`
[08:27:23.697]             `+` <- base::`+`
[08:27:23.697]             `<<-` <- base::`<<-`
[08:27:23.697]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:23.697]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:23.697]                   3L)]
[08:27:23.697]             }
[08:27:23.697]             function(cond) {
[08:27:23.697]                 is_error <- inherits(cond, "error")
[08:27:23.697]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:23.697]                   NULL)
[08:27:23.697]                 if (is_error) {
[08:27:23.697]                   sessionInformation <- function() {
[08:27:23.697]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:23.697]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:23.697]                       search = base::search(), system = base::Sys.info())
[08:27:23.697]                   }
[08:27:23.697]                   ...future.conditions[[length(...future.conditions) + 
[08:27:23.697]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:23.697]                     cond$call), session = sessionInformation(), 
[08:27:23.697]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:23.697]                   signalCondition(cond)
[08:27:23.697]                 }
[08:27:23.697]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:23.697]                 "immediateCondition"))) {
[08:27:23.697]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:23.697]                   ...future.conditions[[length(...future.conditions) + 
[08:27:23.697]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:23.697]                   if (TRUE && !signal) {
[08:27:23.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:23.697]                     {
[08:27:23.697]                       inherits <- base::inherits
[08:27:23.697]                       invokeRestart <- base::invokeRestart
[08:27:23.697]                       is.null <- base::is.null
[08:27:23.697]                       muffled <- FALSE
[08:27:23.697]                       if (inherits(cond, "message")) {
[08:27:23.697]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:23.697]                         if (muffled) 
[08:27:23.697]                           invokeRestart("muffleMessage")
[08:27:23.697]                       }
[08:27:23.697]                       else if (inherits(cond, "warning")) {
[08:27:23.697]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:23.697]                         if (muffled) 
[08:27:23.697]                           invokeRestart("muffleWarning")
[08:27:23.697]                       }
[08:27:23.697]                       else if (inherits(cond, "condition")) {
[08:27:23.697]                         if (!is.null(pattern)) {
[08:27:23.697]                           computeRestarts <- base::computeRestarts
[08:27:23.697]                           grepl <- base::grepl
[08:27:23.697]                           restarts <- computeRestarts(cond)
[08:27:23.697]                           for (restart in restarts) {
[08:27:23.697]                             name <- restart$name
[08:27:23.697]                             if (is.null(name)) 
[08:27:23.697]                               next
[08:27:23.697]                             if (!grepl(pattern, name)) 
[08:27:23.697]                               next
[08:27:23.697]                             invokeRestart(restart)
[08:27:23.697]                             muffled <- TRUE
[08:27:23.697]                             break
[08:27:23.697]                           }
[08:27:23.697]                         }
[08:27:23.697]                       }
[08:27:23.697]                       invisible(muffled)
[08:27:23.697]                     }
[08:27:23.697]                     muffleCondition(cond, pattern = "^muffle")
[08:27:23.697]                   }
[08:27:23.697]                 }
[08:27:23.697]                 else {
[08:27:23.697]                   if (TRUE) {
[08:27:23.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:23.697]                     {
[08:27:23.697]                       inherits <- base::inherits
[08:27:23.697]                       invokeRestart <- base::invokeRestart
[08:27:23.697]                       is.null <- base::is.null
[08:27:23.697]                       muffled <- FALSE
[08:27:23.697]                       if (inherits(cond, "message")) {
[08:27:23.697]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:23.697]                         if (muffled) 
[08:27:23.697]                           invokeRestart("muffleMessage")
[08:27:23.697]                       }
[08:27:23.697]                       else if (inherits(cond, "warning")) {
[08:27:23.697]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:23.697]                         if (muffled) 
[08:27:23.697]                           invokeRestart("muffleWarning")
[08:27:23.697]                       }
[08:27:23.697]                       else if (inherits(cond, "condition")) {
[08:27:23.697]                         if (!is.null(pattern)) {
[08:27:23.697]                           computeRestarts <- base::computeRestarts
[08:27:23.697]                           grepl <- base::grepl
[08:27:23.697]                           restarts <- computeRestarts(cond)
[08:27:23.697]                           for (restart in restarts) {
[08:27:23.697]                             name <- restart$name
[08:27:23.697]                             if (is.null(name)) 
[08:27:23.697]                               next
[08:27:23.697]                             if (!grepl(pattern, name)) 
[08:27:23.697]                               next
[08:27:23.697]                             invokeRestart(restart)
[08:27:23.697]                             muffled <- TRUE
[08:27:23.697]                             break
[08:27:23.697]                           }
[08:27:23.697]                         }
[08:27:23.697]                       }
[08:27:23.697]                       invisible(muffled)
[08:27:23.697]                     }
[08:27:23.697]                     muffleCondition(cond, pattern = "^muffle")
[08:27:23.697]                   }
[08:27:23.697]                 }
[08:27:23.697]             }
[08:27:23.697]         }))
[08:27:23.697]     }, error = function(ex) {
[08:27:23.697]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:23.697]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:23.697]                 ...future.rng), started = ...future.startTime, 
[08:27:23.697]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:23.697]             version = "1.8"), class = "FutureResult")
[08:27:23.697]     }, finally = {
[08:27:23.697]         if (!identical(...future.workdir, getwd())) 
[08:27:23.697]             setwd(...future.workdir)
[08:27:23.697]         {
[08:27:23.697]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:23.697]                 ...future.oldOptions$nwarnings <- NULL
[08:27:23.697]             }
[08:27:23.697]             base::options(...future.oldOptions)
[08:27:23.697]             if (.Platform$OS.type == "windows") {
[08:27:23.697]                 old_names <- names(...future.oldEnvVars)
[08:27:23.697]                 envs <- base::Sys.getenv()
[08:27:23.697]                 names <- names(envs)
[08:27:23.697]                 common <- intersect(names, old_names)
[08:27:23.697]                 added <- setdiff(names, old_names)
[08:27:23.697]                 removed <- setdiff(old_names, names)
[08:27:23.697]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:23.697]                   envs[common]]
[08:27:23.697]                 NAMES <- toupper(changed)
[08:27:23.697]                 args <- list()
[08:27:23.697]                 for (kk in seq_along(NAMES)) {
[08:27:23.697]                   name <- changed[[kk]]
[08:27:23.697]                   NAME <- NAMES[[kk]]
[08:27:23.697]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.697]                     next
[08:27:23.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:23.697]                 }
[08:27:23.697]                 NAMES <- toupper(added)
[08:27:23.697]                 for (kk in seq_along(NAMES)) {
[08:27:23.697]                   name <- added[[kk]]
[08:27:23.697]                   NAME <- NAMES[[kk]]
[08:27:23.697]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.697]                     next
[08:27:23.697]                   args[[name]] <- ""
[08:27:23.697]                 }
[08:27:23.697]                 NAMES <- toupper(removed)
[08:27:23.697]                 for (kk in seq_along(NAMES)) {
[08:27:23.697]                   name <- removed[[kk]]
[08:27:23.697]                   NAME <- NAMES[[kk]]
[08:27:23.697]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:23.697]                     next
[08:27:23.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:23.697]                 }
[08:27:23.697]                 if (length(args) > 0) 
[08:27:23.697]                   base::do.call(base::Sys.setenv, args = args)
[08:27:23.697]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:23.697]             }
[08:27:23.697]             else {
[08:27:23.697]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:23.697]             }
[08:27:23.697]             {
[08:27:23.697]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:23.697]                   0L) {
[08:27:23.697]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:23.697]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:23.697]                   base::options(opts)
[08:27:23.697]                 }
[08:27:23.697]                 {
[08:27:23.697]                   {
[08:27:23.697]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:23.697]                     NULL
[08:27:23.697]                   }
[08:27:23.697]                   options(future.plan = NULL)
[08:27:23.697]                   if (is.na(NA_character_)) 
[08:27:23.697]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:23.697]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:23.697]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:23.697]                     .init = FALSE)
[08:27:23.697]                 }
[08:27:23.697]             }
[08:27:23.697]         }
[08:27:23.697]     })
[08:27:23.697]     if (TRUE) {
[08:27:23.697]         base::sink(type = "output", split = FALSE)
[08:27:23.697]         if (TRUE) {
[08:27:23.697]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:23.697]         }
[08:27:23.697]         else {
[08:27:23.697]             ...future.result["stdout"] <- base::list(NULL)
[08:27:23.697]         }
[08:27:23.697]         base::close(...future.stdout)
[08:27:23.697]         ...future.stdout <- NULL
[08:27:23.697]     }
[08:27:23.697]     ...future.result$conditions <- ...future.conditions
[08:27:23.697]     ...future.result$finished <- base::Sys.time()
[08:27:23.697]     ...future.result
[08:27:23.697] }
[08:27:23.699] assign_globals() ...
[08:27:23.700] List of 4
[08:27:23.700]  $ ii   : int 4
[08:27:23.700]  $ n    : int 4
[08:27:23.700]  $ C    : cplx [1:25, 1:25] -0.719+0.0306i -0.719+0.0918i -0.719+0.1531i ...
[08:27:23.700]   ..- attr(*, "region")=List of 2
[08:27:23.700]   .. ..$ xrange: num [1:2] -0.719 0.75
[08:27:23.700]   .. ..$ yrange: num [1:2] 0.0306 1.5
[08:27:23.700]   ..- attr(*, "tile")= int [1:2] 2 2
[08:27:23.700]  $ delay:function (counts)  
[08:27:23.700]   ..- attr(*, "srcref")= 'srcref' int [1:8] 41 12 41 30 12 30 41 41
[08:27:23.700]   .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x561dea221c10> 
[08:27:23.700]  - attr(*, "where")=List of 4
[08:27:23.700]   ..$ ii   :<environment: R_EmptyEnv> 
[08:27:23.700]   ..$ n    :<environment: R_EmptyEnv> 
[08:27:23.700]   ..$ C    :<environment: R_EmptyEnv> 
[08:27:23.700]   ..$ delay:<environment: R_EmptyEnv> 
[08:27:23.700]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:23.700]  - attr(*, "resolved")= logi FALSE
[08:27:23.700]  - attr(*, "total_size")= num 58781
[08:27:23.700]  - attr(*, "already-done")= logi TRUE
[08:27:23.707] - copied ‘ii’ to environment
[08:27:23.707] - copied ‘n’ to environment
[08:27:23.707] - copied ‘C’ to environment
[08:27:23.708] - reassign environment for ‘delay’
[08:27:23.708] - copied ‘delay’ to environment
[08:27:23.708] assign_globals() ... done
[08:27:23.708] requestCore(): workers = 2
[08:27:23.711] MulticoreFuture started
[08:27:23.711] - Launch lazy future ... done
[08:27:23.711] run() for ‘MulticoreFuture’ ... done
[08:27:23.711] - run() ... done
[08:27:23.712] - resolved() ...
[08:27:23.712] plan(): Setting new future strategy stack:
[08:27:23.712] List of future strategies:
[08:27:23.712] 1. sequential:
[08:27:23.712]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:23.712]    - tweaked: FALSE
[08:27:23.712]    - call: NULL
[08:27:23.714] plan(): nbrOfWorkers() = 1
[08:27:23.718] plan(): Setting new future strategy stack:
[08:27:23.718] List of future strategies:
[08:27:23.718] 1. multicore:
[08:27:23.718]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:23.718]    - tweaked: FALSE
[08:27:23.718]    - call: plan(strategy)
[08:27:23.721] plan(): nbrOfWorkers() = 2
[08:27:23.722] - resolved: TRUE
[08:27:23.722] - resolved() ... done
[08:27:23.722] resolved() for ‘MulticoreFuture’ ... done
Plotting tile #4 of 4 ...
[08:27:23.723] result() for MulticoreFuture ...
[08:27:23.724] result() for MulticoreFuture ...
[08:27:23.724] result() for MulticoreFuture ... done
[08:27:23.724] signalConditions() ...
[08:27:23.725]  - include = ‘immediateCondition’
[08:27:23.725]  - exclude = 
[08:27:23.725]  - resignal = FALSE
[08:27:23.725]  - Number of conditions: 2
[08:27:23.725] signalConditions() ... done
[08:27:23.725] result() for MulticoreFuture ... done
[08:27:23.725] result() for MulticoreFuture ...
[08:27:23.725] result() for MulticoreFuture ... done
[08:27:23.726] signalConditions() ...
[08:27:23.726]  - include = ‘immediateCondition’
[08:27:23.726]  - exclude = 
[08:27:23.726]  - resignal = FALSE
[08:27:23.726]  - Number of conditions: 2
[08:27:23.726] signalConditions() ... done
[08:27:23.726] Future state: ‘finished’
[08:27:23.726] result() for MulticoreFuture ...
[08:27:23.726] result() for MulticoreFuture ... done
[08:27:23.727] signalConditions() ...
[08:27:23.727]  - include = ‘condition’
[08:27:23.727]  - exclude = ‘immediateCondition’
[08:27:23.727]  - resignal = TRUE
[08:27:23.727]  - Number of conditions: 2
[08:27:23.727]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[08:27:23.727]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[08:27:23.727] signalConditions() ... done

> close.screen()
[1] 1 2 3 4 5 6 7 8

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('multicore') ... DONE
- plan('multisession') ...
[08:27:23.730] plan(): Setting new future strategy stack:
[08:27:23.730] List of future strategies:
[08:27:23.730] 1. multisession:
[08:27:23.730]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:27:23.730]    - tweaked: FALSE
[08:27:23.730]    - call: plan(strategy)
[08:27:23.730] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:27:23.730] multisession:
[08:27:23.730] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:27:23.730] - tweaked: FALSE
[08:27:23.730] - call: plan(strategy)
[08:27:23.735] getGlobalsAndPackages() ...
[08:27:23.735] Not searching for globals
[08:27:23.736] - globals: [0] <none>
[08:27:23.736] getGlobalsAndPackages() ... DONE
[08:27:24.261] Packages needed by the future expression (n = 0): <none>
[08:27:24.261] Packages needed by future strategies (n = 0): <none>
[08:27:24.262] {
[08:27:24.262]     {
[08:27:24.262]         {
[08:27:24.262]             ...future.startTime <- base::Sys.time()
[08:27:24.262]             {
[08:27:24.262]                 {
[08:27:24.262]                   {
[08:27:24.262]                     {
[08:27:24.262]                       base::local({
[08:27:24.262]                         has_future <- base::requireNamespace("future", 
[08:27:24.262]                           quietly = TRUE)
[08:27:24.262]                         if (has_future) {
[08:27:24.262]                           ns <- base::getNamespace("future")
[08:27:24.262]                           version <- ns[[".package"]][["version"]]
[08:27:24.262]                           if (is.null(version)) 
[08:27:24.262]                             version <- utils::packageVersion("future")
[08:27:24.262]                         }
[08:27:24.262]                         else {
[08:27:24.262]                           version <- NULL
[08:27:24.262]                         }
[08:27:24.262]                         if (!has_future || version < "1.8.0") {
[08:27:24.262]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:24.262]                             "", base::R.version$version.string), 
[08:27:24.262]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:24.262]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:24.262]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:24.262]                               "release", "version")], collapse = " "), 
[08:27:24.262]                             hostname = base::Sys.info()[["nodename"]])
[08:27:24.262]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:24.262]                             info)
[08:27:24.262]                           info <- base::paste(info, collapse = "; ")
[08:27:24.262]                           if (!has_future) {
[08:27:24.262]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:24.262]                               info)
[08:27:24.262]                           }
[08:27:24.262]                           else {
[08:27:24.262]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:24.262]                               info, version)
[08:27:24.262]                           }
[08:27:24.262]                           base::stop(msg)
[08:27:24.262]                         }
[08:27:24.262]                       })
[08:27:24.262]                     }
[08:27:24.262]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:24.262]                     base::options(mc.cores = 1L)
[08:27:24.262]                   }
[08:27:24.262]                   ...future.strategy.old <- future::plan("list")
[08:27:24.262]                   options(future.plan = NULL)
[08:27:24.262]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:24.262]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:24.262]                 }
[08:27:24.262]                 ...future.workdir <- getwd()
[08:27:24.262]             }
[08:27:24.262]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:24.262]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:24.262]         }
[08:27:24.262]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:24.262]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:24.262]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:24.262]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:24.262]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:24.262]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:24.262]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:24.262]             base::names(...future.oldOptions))
[08:27:24.262]     }
[08:27:24.262]     if (FALSE) {
[08:27:24.262]     }
[08:27:24.262]     else {
[08:27:24.262]         if (TRUE) {
[08:27:24.262]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:24.262]                 open = "w")
[08:27:24.262]         }
[08:27:24.262]         else {
[08:27:24.262]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:24.262]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:24.262]         }
[08:27:24.262]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:24.262]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:24.262]             base::sink(type = "output", split = FALSE)
[08:27:24.262]             base::close(...future.stdout)
[08:27:24.262]         }, add = TRUE)
[08:27:24.262]     }
[08:27:24.262]     ...future.frame <- base::sys.nframe()
[08:27:24.262]     ...future.conditions <- base::list()
[08:27:24.262]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:24.262]     if (FALSE) {
[08:27:24.262]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:24.262]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:24.262]     }
[08:27:24.262]     ...future.result <- base::tryCatch({
[08:27:24.262]         base::withCallingHandlers({
[08:27:24.262]             ...future.value <- base::withVisible(base::local({
[08:27:24.262]                 ...future.makeSendCondition <- base::local({
[08:27:24.262]                   sendCondition <- NULL
[08:27:24.262]                   function(frame = 1L) {
[08:27:24.262]                     if (is.function(sendCondition)) 
[08:27:24.262]                       return(sendCondition)
[08:27:24.262]                     ns <- getNamespace("parallel")
[08:27:24.262]                     if (exists("sendData", mode = "function", 
[08:27:24.262]                       envir = ns)) {
[08:27:24.262]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:24.262]                         envir = ns)
[08:27:24.262]                       envir <- sys.frame(frame)
[08:27:24.262]                       master <- NULL
[08:27:24.262]                       while (!identical(envir, .GlobalEnv) && 
[08:27:24.262]                         !identical(envir, emptyenv())) {
[08:27:24.262]                         if (exists("master", mode = "list", envir = envir, 
[08:27:24.262]                           inherits = FALSE)) {
[08:27:24.262]                           master <- get("master", mode = "list", 
[08:27:24.262]                             envir = envir, inherits = FALSE)
[08:27:24.262]                           if (inherits(master, c("SOCKnode", 
[08:27:24.262]                             "SOCK0node"))) {
[08:27:24.262]                             sendCondition <<- function(cond) {
[08:27:24.262]                               data <- list(type = "VALUE", value = cond, 
[08:27:24.262]                                 success = TRUE)
[08:27:24.262]                               parallel_sendData(master, data)
[08:27:24.262]                             }
[08:27:24.262]                             return(sendCondition)
[08:27:24.262]                           }
[08:27:24.262]                         }
[08:27:24.262]                         frame <- frame + 1L
[08:27:24.262]                         envir <- sys.frame(frame)
[08:27:24.262]                       }
[08:27:24.262]                     }
[08:27:24.262]                     sendCondition <<- function(cond) NULL
[08:27:24.262]                   }
[08:27:24.262]                 })
[08:27:24.262]                 withCallingHandlers({
[08:27:24.262]                   NA
[08:27:24.262]                 }, immediateCondition = function(cond) {
[08:27:24.262]                   sendCondition <- ...future.makeSendCondition()
[08:27:24.262]                   sendCondition(cond)
[08:27:24.262]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:24.262]                   {
[08:27:24.262]                     inherits <- base::inherits
[08:27:24.262]                     invokeRestart <- base::invokeRestart
[08:27:24.262]                     is.null <- base::is.null
[08:27:24.262]                     muffled <- FALSE
[08:27:24.262]                     if (inherits(cond, "message")) {
[08:27:24.262]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:24.262]                       if (muffled) 
[08:27:24.262]                         invokeRestart("muffleMessage")
[08:27:24.262]                     }
[08:27:24.262]                     else if (inherits(cond, "warning")) {
[08:27:24.262]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:24.262]                       if (muffled) 
[08:27:24.262]                         invokeRestart("muffleWarning")
[08:27:24.262]                     }
[08:27:24.262]                     else if (inherits(cond, "condition")) {
[08:27:24.262]                       if (!is.null(pattern)) {
[08:27:24.262]                         computeRestarts <- base::computeRestarts
[08:27:24.262]                         grepl <- base::grepl
[08:27:24.262]                         restarts <- computeRestarts(cond)
[08:27:24.262]                         for (restart in restarts) {
[08:27:24.262]                           name <- restart$name
[08:27:24.262]                           if (is.null(name)) 
[08:27:24.262]                             next
[08:27:24.262]                           if (!grepl(pattern, name)) 
[08:27:24.262]                             next
[08:27:24.262]                           invokeRestart(restart)
[08:27:24.262]                           muffled <- TRUE
[08:27:24.262]                           break
[08:27:24.262]                         }
[08:27:24.262]                       }
[08:27:24.262]                     }
[08:27:24.262]                     invisible(muffled)
[08:27:24.262]                   }
[08:27:24.262]                   muffleCondition(cond)
[08:27:24.262]                 })
[08:27:24.262]             }))
[08:27:24.262]             future::FutureResult(value = ...future.value$value, 
[08:27:24.262]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:24.262]                   ...future.rng), globalenv = if (FALSE) 
[08:27:24.262]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:24.262]                     ...future.globalenv.names))
[08:27:24.262]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:24.262]         }, condition = base::local({
[08:27:24.262]             c <- base::c
[08:27:24.262]             inherits <- base::inherits
[08:27:24.262]             invokeRestart <- base::invokeRestart
[08:27:24.262]             length <- base::length
[08:27:24.262]             list <- base::list
[08:27:24.262]             seq.int <- base::seq.int
[08:27:24.262]             signalCondition <- base::signalCondition
[08:27:24.262]             sys.calls <- base::sys.calls
[08:27:24.262]             `[[` <- base::`[[`
[08:27:24.262]             `+` <- base::`+`
[08:27:24.262]             `<<-` <- base::`<<-`
[08:27:24.262]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:24.262]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:24.262]                   3L)]
[08:27:24.262]             }
[08:27:24.262]             function(cond) {
[08:27:24.262]                 is_error <- inherits(cond, "error")
[08:27:24.262]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:24.262]                   NULL)
[08:27:24.262]                 if (is_error) {
[08:27:24.262]                   sessionInformation <- function() {
[08:27:24.262]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:24.262]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:24.262]                       search = base::search(), system = base::Sys.info())
[08:27:24.262]                   }
[08:27:24.262]                   ...future.conditions[[length(...future.conditions) + 
[08:27:24.262]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:24.262]                     cond$call), session = sessionInformation(), 
[08:27:24.262]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:24.262]                   signalCondition(cond)
[08:27:24.262]                 }
[08:27:24.262]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:24.262]                 "immediateCondition"))) {
[08:27:24.262]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:24.262]                   ...future.conditions[[length(...future.conditions) + 
[08:27:24.262]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:24.262]                   if (TRUE && !signal) {
[08:27:24.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:24.262]                     {
[08:27:24.262]                       inherits <- base::inherits
[08:27:24.262]                       invokeRestart <- base::invokeRestart
[08:27:24.262]                       is.null <- base::is.null
[08:27:24.262]                       muffled <- FALSE
[08:27:24.262]                       if (inherits(cond, "message")) {
[08:27:24.262]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:24.262]                         if (muffled) 
[08:27:24.262]                           invokeRestart("muffleMessage")
[08:27:24.262]                       }
[08:27:24.262]                       else if (inherits(cond, "warning")) {
[08:27:24.262]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:24.262]                         if (muffled) 
[08:27:24.262]                           invokeRestart("muffleWarning")
[08:27:24.262]                       }
[08:27:24.262]                       else if (inherits(cond, "condition")) {
[08:27:24.262]                         if (!is.null(pattern)) {
[08:27:24.262]                           computeRestarts <- base::computeRestarts
[08:27:24.262]                           grepl <- base::grepl
[08:27:24.262]                           restarts <- computeRestarts(cond)
[08:27:24.262]                           for (restart in restarts) {
[08:27:24.262]                             name <- restart$name
[08:27:24.262]                             if (is.null(name)) 
[08:27:24.262]                               next
[08:27:24.262]                             if (!grepl(pattern, name)) 
[08:27:24.262]                               next
[08:27:24.262]                             invokeRestart(restart)
[08:27:24.262]                             muffled <- TRUE
[08:27:24.262]                             break
[08:27:24.262]                           }
[08:27:24.262]                         }
[08:27:24.262]                       }
[08:27:24.262]                       invisible(muffled)
[08:27:24.262]                     }
[08:27:24.262]                     muffleCondition(cond, pattern = "^muffle")
[08:27:24.262]                   }
[08:27:24.262]                 }
[08:27:24.262]                 else {
[08:27:24.262]                   if (TRUE) {
[08:27:24.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:24.262]                     {
[08:27:24.262]                       inherits <- base::inherits
[08:27:24.262]                       invokeRestart <- base::invokeRestart
[08:27:24.262]                       is.null <- base::is.null
[08:27:24.262]                       muffled <- FALSE
[08:27:24.262]                       if (inherits(cond, "message")) {
[08:27:24.262]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:24.262]                         if (muffled) 
[08:27:24.262]                           invokeRestart("muffleMessage")
[08:27:24.262]                       }
[08:27:24.262]                       else if (inherits(cond, "warning")) {
[08:27:24.262]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:24.262]                         if (muffled) 
[08:27:24.262]                           invokeRestart("muffleWarning")
[08:27:24.262]                       }
[08:27:24.262]                       else if (inherits(cond, "condition")) {
[08:27:24.262]                         if (!is.null(pattern)) {
[08:27:24.262]                           computeRestarts <- base::computeRestarts
[08:27:24.262]                           grepl <- base::grepl
[08:27:24.262]                           restarts <- computeRestarts(cond)
[08:27:24.262]                           for (restart in restarts) {
[08:27:24.262]                             name <- restart$name
[08:27:24.262]                             if (is.null(name)) 
[08:27:24.262]                               next
[08:27:24.262]                             if (!grepl(pattern, name)) 
[08:27:24.262]                               next
[08:27:24.262]                             invokeRestart(restart)
[08:27:24.262]                             muffled <- TRUE
[08:27:24.262]                             break
[08:27:24.262]                           }
[08:27:24.262]                         }
[08:27:24.262]                       }
[08:27:24.262]                       invisible(muffled)
[08:27:24.262]                     }
[08:27:24.262]                     muffleCondition(cond, pattern = "^muffle")
[08:27:24.262]                   }
[08:27:24.262]                 }
[08:27:24.262]             }
[08:27:24.262]         }))
[08:27:24.262]     }, error = function(ex) {
[08:27:24.262]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:24.262]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:24.262]                 ...future.rng), started = ...future.startTime, 
[08:27:24.262]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:24.262]             version = "1.8"), class = "FutureResult")
[08:27:24.262]     }, finally = {
[08:27:24.262]         if (!identical(...future.workdir, getwd())) 
[08:27:24.262]             setwd(...future.workdir)
[08:27:24.262]         {
[08:27:24.262]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:24.262]                 ...future.oldOptions$nwarnings <- NULL
[08:27:24.262]             }
[08:27:24.262]             base::options(...future.oldOptions)
[08:27:24.262]             if (.Platform$OS.type == "windows") {
[08:27:24.262]                 old_names <- names(...future.oldEnvVars)
[08:27:24.262]                 envs <- base::Sys.getenv()
[08:27:24.262]                 names <- names(envs)
[08:27:24.262]                 common <- intersect(names, old_names)
[08:27:24.262]                 added <- setdiff(names, old_names)
[08:27:24.262]                 removed <- setdiff(old_names, names)
[08:27:24.262]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:24.262]                   envs[common]]
[08:27:24.262]                 NAMES <- toupper(changed)
[08:27:24.262]                 args <- list()
[08:27:24.262]                 for (kk in seq_along(NAMES)) {
[08:27:24.262]                   name <- changed[[kk]]
[08:27:24.262]                   NAME <- NAMES[[kk]]
[08:27:24.262]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:24.262]                     next
[08:27:24.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:24.262]                 }
[08:27:24.262]                 NAMES <- toupper(added)
[08:27:24.262]                 for (kk in seq_along(NAMES)) {
[08:27:24.262]                   name <- added[[kk]]
[08:27:24.262]                   NAME <- NAMES[[kk]]
[08:27:24.262]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:24.262]                     next
[08:27:24.262]                   args[[name]] <- ""
[08:27:24.262]                 }
[08:27:24.262]                 NAMES <- toupper(removed)
[08:27:24.262]                 for (kk in seq_along(NAMES)) {
[08:27:24.262]                   name <- removed[[kk]]
[08:27:24.262]                   NAME <- NAMES[[kk]]
[08:27:24.262]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:24.262]                     next
[08:27:24.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:24.262]                 }
[08:27:24.262]                 if (length(args) > 0) 
[08:27:24.262]                   base::do.call(base::Sys.setenv, args = args)
[08:27:24.262]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:24.262]             }
[08:27:24.262]             else {
[08:27:24.262]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:24.262]             }
[08:27:24.262]             {
[08:27:24.262]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:24.262]                   0L) {
[08:27:24.262]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:24.262]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:24.262]                   base::options(opts)
[08:27:24.262]                 }
[08:27:24.262]                 {
[08:27:24.262]                   {
[08:27:24.262]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:24.262]                     NULL
[08:27:24.262]                   }
[08:27:24.262]                   options(future.plan = NULL)
[08:27:24.262]                   if (is.na(NA_character_)) 
[08:27:24.262]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:24.262]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:24.262]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:24.262]                     .init = FALSE)
[08:27:24.262]                 }
[08:27:24.262]             }
[08:27:24.262]         }
[08:27:24.262]     })
[08:27:24.262]     if (TRUE) {
[08:27:24.262]         base::sink(type = "output", split = FALSE)
[08:27:24.262]         if (TRUE) {
[08:27:24.262]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:24.262]         }
[08:27:24.262]         else {
[08:27:24.262]             ...future.result["stdout"] <- base::list(NULL)
[08:27:24.262]         }
[08:27:24.262]         base::close(...future.stdout)
[08:27:24.262]         ...future.stdout <- NULL
[08:27:24.262]     }
[08:27:24.262]     ...future.result$conditions <- ...future.conditions
[08:27:24.262]     ...future.result$finished <- base::Sys.time()
[08:27:24.262]     ...future.result
[08:27:24.262] }
[08:27:24.317] MultisessionFuture started
[08:27:24.317] result() for ClusterFuture ...
[08:27:24.318] receiveMessageFromWorker() for ClusterFuture ...
[08:27:24.318] - Validating connection of MultisessionFuture
[08:27:24.350] - received message: FutureResult
[08:27:24.351] - Received FutureResult
[08:27:24.351] - Erased future from FutureRegistry
[08:27:24.351] result() for ClusterFuture ...
[08:27:24.351] - result already collected: FutureResult
[08:27:24.351] result() for ClusterFuture ... done
[08:27:24.351] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:24.351] result() for ClusterFuture ... done
[08:27:24.351] result() for ClusterFuture ...
[08:27:24.351] - result already collected: FutureResult
[08:27:24.351] result() for ClusterFuture ... done
[08:27:24.351] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:27:24.353] plan(): nbrOfWorkers() = 2


	demo(mandelbrot)
	---- ~~~~~~~~~~

> library("future")

> library("graphics")

> plot_what_is_done <- function(counts) {
+   for (kk in seq_along(counts)) {
+     f <- counts[[kk]]
+ 
+     ## Already plotted?
+     if (!inherits(f, "Future")) next
+ 
+     ## Not resolved?
+     if (!resolved(f)) next
+ 
+     message(sprintf("Plotting tile #%d of %d ...", kk, n))
+     counts[[kk]] <- value(f)
+     screen(kk)
+     plot(counts[[kk]])
+   }
+ 
+   counts
+ }

> ## Options
> region <- getOption("future.demo.mandelbrot.region", 1L)

> if (!is.list(region)) {
+   if (region == 1L) {
+     region <- list(xmid = -0.75, ymid = 0.0, side = 3.0)
+   } else if (region == 2L) {
+     region <- list(xmid = 0.283, ymid = -0.0095, side = 0.00026)
+   } else if (region == 3L) {
+     region <- list(xmid = 0.282989, ymid = -0.01, side = 3e-8)
+   }
+ }

> nrow <- getOption("future.demo.mandelbrot.nrow", 3L)

> resolution <- getOption("future.demo.mandelbrot.resolution", 400L)

> delay <- getOption("future.demo.mandelbrot.delay", interactive())

> if (isTRUE(delay)) {
+   delay <- function(counts) Sys.sleep(1.0)
+ } else if (!is.function(delay)) {
+   delay <- function(counts) {}
+ }

> ## Generate Mandelbrot tiles to be computed
> Cs <- mandelbrot_tiles(xmid = region$xmid, ymid = region$ymid,
+                        side = region$side, nrow = nrow,
+                        resolution = resolution)

> if (interactive()) {
+   dev.new()
+   plot.new()
+   split.screen(dim(Cs))
+   for (ii in seq_along(Cs)) {
+     screen(ii)
+     par(mar = c(0, 0, 0, 0))
+     text(x = 1 / 2, y = 1 / 2, sprintf("Future #%d\nunresolved", ii), cex = 2)
+   }
+ } else {
+   split.screen(dim(Cs))
+ }
[1]  9 10 11 12

> ## Create all Mandelbrot tiles via lazy futures
> n <- length(Cs)

> message(sprintf("Creating %d Mandelbrot tiles:", n), appendLF = FALSE)
Creating 4 Mandelbrot tiles:
> counts <- lapply(seq_along(Cs), FUN=function(ii) {
+   message(" ", ii, appendLF = FALSE)
+   C <- Cs[[ii]]
+   future({
+     message(sprintf("Calculating tile #%d of %d ...", ii, n), appendLF = FALSE)
+     fit <- mandelbrot(C)
+ 
+     ## Emulate slowness
+     delay(fit)
+ 
+     message(" done")
+     fit
+   }, lazy = TRUE)
+ })
 1[08:27:24.357] getGlobalsAndPackages() ...
[08:27:24.357] Searching for globals...
[08:27:24.360] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[08:27:24.360] Searching for globals ... DONE
[08:27:24.360] Resolving globals: FALSE
[08:27:24.361] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[08:27:24.361] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:27:24.362] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[08:27:24.362] - packages: [1] ‘future’
[08:27:24.362] getGlobalsAndPackages() ... DONE
 2[08:27:24.366] getGlobalsAndPackages() ...
[08:27:24.366] Searching for globals...
[08:27:24.369] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[08:27:24.369] Searching for globals ... DONE
[08:27:24.369] Resolving globals: FALSE
[08:27:24.370] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[08:27:24.370] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:27:24.370] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[08:27:24.370] - packages: [1] ‘future’
[08:27:24.371] getGlobalsAndPackages() ... DONE
 3[08:27:24.371] getGlobalsAndPackages() ...
[08:27:24.371] Searching for globals...
[08:27:24.374] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[08:27:24.374] Searching for globals ... DONE
[08:27:24.374] Resolving globals: FALSE
[08:27:24.375] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[08:27:24.375] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:27:24.375] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[08:27:24.376] - packages: [1] ‘future’
[08:27:24.376] getGlobalsAndPackages() ... DONE
 4[08:27:24.376] getGlobalsAndPackages() ...
[08:27:24.376] Searching for globals...
[08:27:24.379] - globals found: [9] ‘{’, ‘message’, ‘sprintf’, ‘ii’, ‘n’, ‘<-’, ‘mandelbrot’, ‘C’, ‘delay’
[08:27:24.379] Searching for globals ... DONE
[08:27:24.379] Resolving globals: FALSE
[08:27:24.380] The total size of the 4 globals is 57.40 KiB (58781 bytes)
[08:27:24.380] The total size of the 4 globals exported for future expression (‘{; message(sprintf("Calculating tile #%d of %d ...", ii, n),; appendLF = FALSE); fit <- mandelbrot(C); delay(fit); message(" done"); fit; }’) is 57.40 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘delay’ (47.33 KiB of class ‘function’), ‘C’ (10.00 KiB of class ‘complex’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:27:24.380] - globals: [4] ‘ii’, ‘n’, ‘C’, ‘delay’
[08:27:24.381] - packages: [1] ‘future’
[08:27:24.381] getGlobalsAndPackages() ... DONE

> message(".")
.

> ## Calculate and plot tiles
> repeat {
+   counts <- plot_what_is_done(counts)
+   if (!any(sapply(counts, FUN = inherits, "Future"))) break
+ }
[08:27:24.389] resolved() for ‘Future’ ...
[08:27:24.390] - state: ‘created’
[08:27:24.390] - run: TRUE
[08:27:24.390] - run() ...
[08:27:24.390] run() for ‘Future’ ...
[08:27:24.390] - state: ‘created’
[08:27:24.390] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:24.405] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:24.405] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:24.405]   - Field: ‘node’
[08:27:24.405]   - Field: ‘label’
[08:27:24.405]   - Field: ‘local’
[08:27:24.405]   - Field: ‘owner’
[08:27:24.405]   - Field: ‘envir’
[08:27:24.405]   - Field: ‘workers’
[08:27:24.405]   - Field: ‘packages’
[08:27:24.405]   - Field: ‘gc’
[08:27:24.406]   - Field: ‘conditions’
[08:27:24.406]   - Field: ‘persistent’
[08:27:24.406]   - Field: ‘expr’
[08:27:24.406]   - Field: ‘uuid’
[08:27:24.406]   - Field: ‘seed’
[08:27:24.406]   - Field: ‘version’
[08:27:24.406]   - Field: ‘result’
[08:27:24.406]   - Field: ‘asynchronous’
[08:27:24.406]   - Field: ‘calls’
[08:27:24.406]   - Field: ‘globals’
[08:27:24.406]   - Field: ‘stdout’
[08:27:24.406]   - Field: ‘earlySignal’
[08:27:24.407]   - Field: ‘lazy’
[08:27:24.407]   - Field: ‘state’
[08:27:24.407] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:24.407] - Launch lazy future ...
[08:27:24.407] Packages needed by the future expression (n = 1): ‘future’
[08:27:24.407] Packages needed by future strategies (n = 0): <none>
[08:27:24.408] {
[08:27:24.408]     {
[08:27:24.408]         {
[08:27:24.408]             ...future.startTime <- base::Sys.time()
[08:27:24.408]             {
[08:27:24.408]                 {
[08:27:24.408]                   {
[08:27:24.408]                     {
[08:27:24.408]                       {
[08:27:24.408]                         base::local({
[08:27:24.408]                           has_future <- base::requireNamespace("future", 
[08:27:24.408]                             quietly = TRUE)
[08:27:24.408]                           if (has_future) {
[08:27:24.408]                             ns <- base::getNamespace("future")
[08:27:24.408]                             version <- ns[[".package"]][["version"]]
[08:27:24.408]                             if (is.null(version)) 
[08:27:24.408]                               version <- utils::packageVersion("future")
[08:27:24.408]                           }
[08:27:24.408]                           else {
[08:27:24.408]                             version <- NULL
[08:27:24.408]                           }
[08:27:24.408]                           if (!has_future || version < "1.8.0") {
[08:27:24.408]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:24.408]                               "", base::R.version$version.string), 
[08:27:24.408]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:24.408]                                 base::R.version$platform, 8 * 
[08:27:24.408]                                   base::.Machine$sizeof.pointer), 
[08:27:24.408]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:24.408]                                 "release", "version")], collapse = " "), 
[08:27:24.408]                               hostname = base::Sys.info()[["nodename"]])
[08:27:24.408]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:24.408]                               info)
[08:27:24.408]                             info <- base::paste(info, collapse = "; ")
[08:27:24.408]                             if (!has_future) {
[08:27:24.408]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:24.408]                                 info)
[08:27:24.408]                             }
[08:27:24.408]                             else {
[08:27:24.408]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:24.408]                                 info, version)
[08:27:24.408]                             }
[08:27:24.408]                             base::stop(msg)
[08:27:24.408]                           }
[08:27:24.408]                         })
[08:27:24.408]                       }
[08:27:24.408]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:24.408]                       base::options(mc.cores = 1L)
[08:27:24.408]                     }
[08:27:24.408]                     base::local({
[08:27:24.408]                       for (pkg in "future") {
[08:27:24.408]                         base::loadNamespace(pkg)
[08:27:24.408]                         base::library(pkg, character.only = TRUE)
[08:27:24.408]                       }
[08:27:24.408]                     })
[08:27:24.408]                   }
[08:27:24.408]                   ...future.strategy.old <- future::plan("list")
[08:27:24.408]                   options(future.plan = NULL)
[08:27:24.408]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:24.408]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:24.408]                 }
[08:27:24.408]                 ...future.workdir <- getwd()
[08:27:24.408]             }
[08:27:24.408]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:24.408]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:24.408]         }
[08:27:24.408]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:24.408]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:24.408]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:24.408]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:24.408]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:24.408]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:24.408]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:24.408]             base::names(...future.oldOptions))
[08:27:24.408]     }
[08:27:24.408]     if (FALSE) {
[08:27:24.408]     }
[08:27:24.408]     else {
[08:27:24.408]         if (TRUE) {
[08:27:24.408]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:24.408]                 open = "w")
[08:27:24.408]         }
[08:27:24.408]         else {
[08:27:24.408]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:24.408]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:24.408]         }
[08:27:24.408]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:24.408]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:24.408]             base::sink(type = "output", split = FALSE)
[08:27:24.408]             base::close(...future.stdout)
[08:27:24.408]         }, add = TRUE)
[08:27:24.408]     }
[08:27:24.408]     ...future.frame <- base::sys.nframe()
[08:27:24.408]     ...future.conditions <- base::list()
[08:27:24.408]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:24.408]     if (FALSE) {
[08:27:24.408]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:24.408]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:24.408]     }
[08:27:24.408]     ...future.result <- base::tryCatch({
[08:27:24.408]         base::withCallingHandlers({
[08:27:24.408]             ...future.value <- base::withVisible(base::local({
[08:27:24.408]                 ...future.makeSendCondition <- base::local({
[08:27:24.408]                   sendCondition <- NULL
[08:27:24.408]                   function(frame = 1L) {
[08:27:24.408]                     if (is.function(sendCondition)) 
[08:27:24.408]                       return(sendCondition)
[08:27:24.408]                     ns <- getNamespace("parallel")
[08:27:24.408]                     if (exists("sendData", mode = "function", 
[08:27:24.408]                       envir = ns)) {
[08:27:24.408]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:24.408]                         envir = ns)
[08:27:24.408]                       envir <- sys.frame(frame)
[08:27:24.408]                       master <- NULL
[08:27:24.408]                       while (!identical(envir, .GlobalEnv) && 
[08:27:24.408]                         !identical(envir, emptyenv())) {
[08:27:24.408]                         if (exists("master", mode = "list", envir = envir, 
[08:27:24.408]                           inherits = FALSE)) {
[08:27:24.408]                           master <- get("master", mode = "list", 
[08:27:24.408]                             envir = envir, inherits = FALSE)
[08:27:24.408]                           if (inherits(master, c("SOCKnode", 
[08:27:24.408]                             "SOCK0node"))) {
[08:27:24.408]                             sendCondition <<- function(cond) {
[08:27:24.408]                               data <- list(type = "VALUE", value = cond, 
[08:27:24.408]                                 success = TRUE)
[08:27:24.408]                               parallel_sendData(master, data)
[08:27:24.408]                             }
[08:27:24.408]                             return(sendCondition)
[08:27:24.408]                           }
[08:27:24.408]                         }
[08:27:24.408]                         frame <- frame + 1L
[08:27:24.408]                         envir <- sys.frame(frame)
[08:27:24.408]                       }
[08:27:24.408]                     }
[08:27:24.408]                     sendCondition <<- function(cond) NULL
[08:27:24.408]                   }
[08:27:24.408]                 })
[08:27:24.408]                 withCallingHandlers({
[08:27:24.408]                   {
[08:27:24.408]                     message(sprintf("Calculating tile #%d of %d ...", 
[08:27:24.408]                       ii, n), appendLF = FALSE)
[08:27:24.408]                     fit <- mandelbrot(C)
[08:27:24.408]                     delay(fit)
[08:27:24.408]                     message(" done")
[08:27:24.408]                     fit
[08:27:24.408]                   }
[08:27:24.408]                 }, immediateCondition = function(cond) {
[08:27:24.408]                   sendCondition <- ...future.makeSendCondition()
[08:27:24.408]                   sendCondition(cond)
[08:27:24.408]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:24.408]                   {
[08:27:24.408]                     inherits <- base::inherits
[08:27:24.408]                     invokeRestart <- base::invokeRestart
[08:27:24.408]                     is.null <- base::is.null
[08:27:24.408]                     muffled <- FALSE
[08:27:24.408]                     if (inherits(cond, "message")) {
[08:27:24.408]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:24.408]                       if (muffled) 
[08:27:24.408]                         invokeRestart("muffleMessage")
[08:27:24.408]                     }
[08:27:24.408]                     else if (inherits(cond, "warning")) {
[08:27:24.408]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:24.408]                       if (muffled) 
[08:27:24.408]                         invokeRestart("muffleWarning")
[08:27:24.408]                     }
[08:27:24.408]                     else if (inherits(cond, "condition")) {
[08:27:24.408]                       if (!is.null(pattern)) {
[08:27:24.408]                         computeRestarts <- base::computeRestarts
[08:27:24.408]                         grepl <- base::grepl
[08:27:24.408]                         restarts <- computeRestarts(cond)
[08:27:24.408]                         for (restart in restarts) {
[08:27:24.408]                           name <- restart$name
[08:27:24.408]                           if (is.null(name)) 
[08:27:24.408]                             next
[08:27:24.408]                           if (!grepl(pattern, name)) 
[08:27:24.408]                             next
[08:27:24.408]                           invokeRestart(restart)
[08:27:24.408]                           muffled <- TRUE
[08:27:24.408]                           break
[08:27:24.408]                         }
[08:27:24.408]                       }
[08:27:24.408]                     }
[08:27:24.408]                     invisible(muffled)
[08:27:24.408]                   }
[08:27:24.408]                   muffleCondition(cond)
[08:27:24.408]                 })
[08:27:24.408]             }))
[08:27:24.408]             future::FutureResult(value = ...future.value$value, 
[08:27:24.408]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:24.408]                   ...future.rng), globalenv = if (FALSE) 
[08:27:24.408]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:24.408]                     ...future.globalenv.names))
[08:27:24.408]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:24.408]         }, condition = base::local({
[08:27:24.408]             c <- base::c
[08:27:24.408]             inherits <- base::inherits
[08:27:24.408]             invokeRestart <- base::invokeRestart
[08:27:24.408]             length <- base::length
[08:27:24.408]             list <- base::list
[08:27:24.408]             seq.int <- base::seq.int
[08:27:24.408]             signalCondition <- base::signalCondition
[08:27:24.408]             sys.calls <- base::sys.calls
[08:27:24.408]             `[[` <- base::`[[`
[08:27:24.408]             `+` <- base::`+`
[08:27:24.408]             `<<-` <- base::`<<-`
[08:27:24.408]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:24.408]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:24.408]                   3L)]
[08:27:24.408]             }
[08:27:24.408]             function(cond) {
[08:27:24.408]                 is_error <- inherits(cond, "error")
[08:27:24.408]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:24.408]                   NULL)
[08:27:24.408]                 if (is_error) {
[08:27:24.408]                   sessionInformation <- function() {
[08:27:24.408]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:24.408]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:24.408]                       search = base::search(), system = base::Sys.info())
[08:27:24.408]                   }
[08:27:24.408]                   ...future.conditions[[length(...future.conditions) + 
[08:27:24.408]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:24.408]                     cond$call), session = sessionInformation(), 
[08:27:24.408]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:24.408]                   signalCondition(cond)
[08:27:24.408]                 }
[08:27:24.408]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:24.408]                 "immediateCondition"))) {
[08:27:24.408]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:24.408]                   ...future.conditions[[length(...future.conditions) + 
[08:27:24.408]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:24.408]                   if (TRUE && !signal) {
[08:27:24.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:24.408]                     {
[08:27:24.408]                       inherits <- base::inherits
[08:27:24.408]                       invokeRestart <- base::invokeRestart
[08:27:24.408]                       is.null <- base::is.null
[08:27:24.408]                       muffled <- FALSE
[08:27:24.408]                       if (inherits(cond, "message")) {
[08:27:24.408]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:24.408]                         if (muffled) 
[08:27:24.408]                           invokeRestart("muffleMessage")
[08:27:24.408]                       }
[08:27:24.408]                       else if (inherits(cond, "warning")) {
[08:27:24.408]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:24.408]                         if (muffled) 
[08:27:24.408]                           invokeRestart("muffleWarning")
[08:27:24.408]                       }
[08:27:24.408]                       else if (inherits(cond, "condition")) {
[08:27:24.408]                         if (!is.null(pattern)) {
[08:27:24.408]                           computeRestarts <- base::computeRestarts
[08:27:24.408]                           grepl <- base::grepl
[08:27:24.408]                           restarts <- computeRestarts(cond)
[08:27:24.408]                           for (restart in restarts) {
[08:27:24.408]                             name <- restart$name
[08:27:24.408]                             if (is.null(name)) 
[08:27:24.408]                               next
[08:27:24.408]                             if (!grepl(pattern, name)) 
[08:27:24.408]                               next
[08:27:24.408]                             invokeRestart(restart)
[08:27:24.408]                             muffled <- TRUE
[08:27:24.408]                             break
[08:27:24.408]                           }
[08:27:24.408]                         }
[08:27:24.408]                       }
[08:27:24.408]                       invisible(muffled)
[08:27:24.408]                     }
[08:27:24.408]                     muffleCondition(cond, pattern = "^muffle")
[08:27:24.408]                   }
[08:27:24.408]                 }
[08:27:24.408]                 else {
[08:27:24.408]                   if (TRUE) {
[08:27:24.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:24.408]                     {
[08:27:24.408]                       inherits <- base::inherits
[08:27:24.408]                       invokeRestart <- base::invokeRestart
[08:27:24.408]                       is.null <- base::is.null
[08:27:24.408]                       muffled <- FALSE
[08:27:24.408]                       if (inherits(cond, "message")) {
[08:27:24.408]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:24.408]                         if (muffled) 
[08:27:24.408]                           invokeRestart("muffleMessage")
[08:27:24.408]                       }
[08:27:24.408]                       else if (inherits(cond, "warning")) {
[08:27:24.408]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:24.408]                         if (muffled) 
[08:27:24.408]                           invokeRestart("muffleWarning")
[08:27:24.408]                       }
[08:27:24.408]                       else if (inherits(cond, "condition")) {
[08:27:24.408]                         if (!is.null(pattern)) {
[08:27:24.408]                           computeRestarts <- base::computeRestarts
[08:27:24.408]                           grepl <- base::grepl
[08:27:24.408]                           restarts <- computeRestarts(cond)
[08:27:24.408]                           for (restart in restarts) {
[08:27:24.408]                             name <- restart$name
[08:27:24.408]                             if (is.null(name)) 
[08:27:24.408]                               next
[08:27:24.408]                             if (!grepl(pattern, name)) 
[08:27:24.408]                               next
[08:27:24.408]                             invokeRestart(restart)
[08:27:24.408]                             muffled <- TRUE
[08:27:24.408]                             break
[08:27:24.408]                           }
[08:27:24.408]                         }
[08:27:24.408]                       }
[08:27:24.408]                       invisible(muffled)
[08:27:24.408]                     }
[08:27:24.408]                     muffleCondition(cond, pattern = "^muffle")
[08:27:24.408]                   }
[08:27:24.408]                 }
[08:27:24.408]             }
[08:27:24.408]         }))
[08:27:24.408]     }, error = function(ex) {
[08:27:24.408]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:24.408]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:24.408]                 ...future.rng), started = ...future.startTime, 
[08:27:24.408]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:24.408]             version = "1.8"), class = "FutureResult")
[08:27:24.408]     }, finally = {
[08:27:24.408]         if (!identical(...future.workdir, getwd())) 
[08:27:24.408]             setwd(...future.workdir)
[08:27:24.408]         {
[08:27:24.408]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:24.408]                 ...future.oldOptions$nwarnings <- NULL
[08:27:24.408]             }
[08:27:24.408]             base::options(...future.oldOptions)
[08:27:24.408]             if (.Platform$OS.type == "windows") {
[08:27:24.408]                 old_names <- names(...future.oldEnvVars)
[08:27:24.408]                 envs <- base::Sys.getenv()
[08:27:24.408]                 names <- names(envs)
[08:27:24.408]                 common <- intersect(names, old_names)
[08:27:24.408]                 added <- setdiff(names, old_names)
[08:27:24.408]                 removed <- setdiff(old_names, names)
[08:27:24.408]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:24.408]                   envs[common]]
[08:27:24.408]                 NAMES <- toupper(changed)
[08:27:24.408]                 args <- list()
[08:27:24.408]                 for (kk in seq_along(NAMES)) {
[08:27:24.408]                   name <- changed[[kk]]
[08:27:24.408]                   NAME <- NAMES[[kk]]
[08:27:24.408]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:24.408]                     next
[08:27:24.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:24.408]                 }
[08:27:24.408]                 NAMES <- toupper(added)
[08:27:24.408]                 for (kk in seq_along(NAMES)) {
[08:27:24.408]                   name <- added[[kk]]
[08:27:24.408]                   NAME <- NAMES[[kk]]
[08:27:24.408]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:24.408]                     next
[08:27:24.408]                   args[[name]] <- ""
[08:27:24.408]                 }
[08:27:24.408]                 NAMES <- toupper(removed)
[08:27:24.408]                 for (kk in seq_along(NAMES)) {
[08:27:24.408]                   name <- removed[[kk]]
[08:27:24.408]                   NAME <- NAMES[[kk]]
[08:27:24.408]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:24.408]                     next
[08:27:24.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:24.408]                 }
[08:27:24.408]                 if (length(args) > 0) 
[08:27:24.408]                   base::do.call(base::Sys.setenv, args = args)
[08:27:24.408]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:24.408]             }
[08:27:24.408]             else {
[08:27:24.408]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:24.408]             }
[08:27:24.408]             {
[08:27:24.408]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:24.408]                   0L) {
[08:27:24.408]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:24.408]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:24.408]                   base::options(opts)
[08:27:24.408]                 }
[08:27:24.408]                 {
[08:27:24.408]                   {
[08:27:24.408]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:24.408]                     NULL
[08:27:24.408]                   }
[08:27:24.408]                   options(future.plan = NULL)
[08:27:24.408]                   if (is.na(NA_character_)) 
[08:27:24.408]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:24.408]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:24.408]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:24.408]                     .init = FALSE)
[08:27:24.408]                 }
[08:27:24.408]             }
[08:27:24.408]         }
[08:27:24.408]     })
[08:27:24.408]     if (TRUE) {
[08:27:24.408]         base::sink(type = "output", split = FALSE)
[08:27:24.408]         if (TRUE) {
[08:27:24.408]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:24.408]         }
[08:27:24.408]         else {
[08:27:24.408]             ...future.result["stdout"] <- base::list(NULL)
[08:27:24.408]         }
[08:27:24.408]         base::close(...future.stdout)
[08:27:24.408]         ...future.stdout <- NULL
[08:27:24.408]     }
[08:27:24.408]     ...future.result$conditions <- ...future.conditions
[08:27:24.408]     ...future.result$finished <- base::Sys.time()
[08:27:24.408]     ...future.result
[08:27:24.408] }
[08:27:24.411] Exporting 4 global objects (57.67 KiB) to cluster node #1 ...
[08:27:24.411] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[08:27:24.411] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[08:27:24.411] Exporting ‘n’ (35 bytes) to cluster node #1 ...
[08:27:24.412] Exporting ‘n’ (35 bytes) to cluster node #1 ... DONE
[08:27:24.412] Exporting ‘C’ (10.00 KiB) to cluster node #1 ...
[08:27:24.454] Exporting ‘C’ (10.00 KiB) to cluster node #1 ... DONE
[08:27:24.454] Exporting ‘delay’ (47.33 KiB) to cluster node #1 ...
[08:27:24.495] Exporting ‘delay’ (47.33 KiB) to cluster node #1 ... DONE
[08:27:24.495] Exporting 4 global objects (57.67 KiB) to cluster node #1 ... DONE
[08:27:24.496] MultisessionFuture started
[08:27:24.496] - Launch lazy future ... done
[08:27:24.496] run() for ‘MultisessionFuture’ ... done
[08:27:24.497] - run() ... done
[08:27:24.497] - resolved() ...
[08:27:24.508] - resolved: FALSE
[08:27:24.508] - resolved() ... done
[08:27:24.508] resolved() for ‘MultisessionFuture’ ... done
[08:27:24.508] resolved() for ‘Future’ ...
[08:27:24.508] - state: ‘created’
[08:27:24.508] - run: TRUE
[08:27:24.508] - run() ...
[08:27:24.508] run() for ‘Future’ ...
[08:27:24.509] - state: ‘created’
[08:27:24.509] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:24.523] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:24.523] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:24.524]   - Field: ‘node’
[08:27:24.524]   - Field: ‘label’
[08:27:24.524]   - Field: ‘local’
[08:27:24.524]   - Field: ‘owner’
[08:27:24.524]   - Field: ‘envir’
[08:27:24.524]   - Field: ‘workers’
[08:27:24.524]   - Field: ‘packages’
[08:27:24.524]   - Field: ‘gc’
[08:27:24.524]   - Field: ‘conditions’
[08:27:24.524]   - Field: ‘persistent’
[08:27:24.524]   - Field: ‘expr’
[08:27:24.525]   - Field: ‘uuid’
[08:27:24.525]   - Field: ‘seed’
[08:27:24.525]   - Field: ‘version’
[08:27:24.525]   - Field: ‘result’
[08:27:24.525]   - Field: ‘asynchronous’
[08:27:24.525]   - Field: ‘calls’
[08:27:24.525]   - Field: ‘globals’
[08:27:24.525]   - Field: ‘stdout’
[08:27:24.525]   - Field: ‘earlySignal’
[08:27:24.525]   - Field: ‘lazy’
[08:27:24.525]   - Field: ‘state’
[08:27:24.525] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:24.526] - Launch lazy future ...
[08:27:24.526] Packages needed by the future expression (n = 1): ‘future’
[08:27:24.526] Packages needed by future strategies (n = 0): <none>
[08:27:24.527] {
[08:27:24.527]     {
[08:27:24.527]         {
[08:27:24.527]             ...future.startTime <- base::Sys.time()
[08:27:24.527]             {
[08:27:24.527]                 {
[08:27:24.527]                   {
[08:27:24.527]                     {
[08:27:24.527]                       {
[08:27:24.527]                         base::local({
[08:27:24.527]                           has_future <- base::requireNamespace("future", 
[08:27:24.527]                             quietly = TRUE)
[08:27:24.527]                           if (has_future) {
[08:27:24.527]                             ns <- base::getNamespace("future")
[08:27:24.527]                             version <- ns[[".package"]][["version"]]
[08:27:24.527]                             if (is.null(version)) 
[08:27:24.527]                               version <- utils::packageVersion("future")
[08:27:24.527]                           }
[08:27:24.527]                           else {
[08:27:24.527]                             version <- NULL
[08:27:24.527]                           }
[08:27:24.527]                           if (!has_future || version < "1.8.0") {
[08:27:24.527]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:24.527]                               "", base::R.version$version.string), 
[08:27:24.527]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:24.527]                                 base::R.version$platform, 8 * 
[08:27:24.527]                                   base::.Machine$sizeof.pointer), 
[08:27:24.527]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:24.527]                                 "release", "version")], collapse = " "), 
[08:27:24.527]                               hostname = base::Sys.info()[["nodename"]])
[08:27:24.527]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:24.527]                               info)
[08:27:24.527]                             info <- base::paste(info, collapse = "; ")
[08:27:24.527]                             if (!has_future) {
[08:27:24.527]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:24.527]                                 info)
[08:27:24.527]                             }
[08:27:24.527]                             else {
[08:27:24.527]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:24.527]                                 info, version)
[08:27:24.527]                             }
[08:27:24.527]                             base::stop(msg)
[08:27:24.527]                           }
[08:27:24.527]                         })
[08:27:24.527]                       }
[08:27:24.527]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:24.527]                       base::options(mc.cores = 1L)
[08:27:24.527]                     }
[08:27:24.527]                     base::local({
[08:27:24.527]                       for (pkg in "future") {
[08:27:24.527]                         base::loadNamespace(pkg)
[08:27:24.527]                         base::library(pkg, character.only = TRUE)
[08:27:24.527]                       }
[08:27:24.527]                     })
[08:27:24.527]                   }
[08:27:24.527]                   ...future.strategy.old <- future::plan("list")
[08:27:24.527]                   options(future.plan = NULL)
[08:27:24.527]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:24.527]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:24.527]                 }
[08:27:24.527]                 ...future.workdir <- getwd()
[08:27:24.527]             }
[08:27:24.527]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:24.527]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:24.527]         }
[08:27:24.527]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:24.527]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:24.527]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:24.527]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:24.527]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:24.527]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:24.527]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:24.527]             base::names(...future.oldOptions))
[08:27:24.527]     }
[08:27:24.527]     if (FALSE) {
[08:27:24.527]     }
[08:27:24.527]     else {
[08:27:24.527]         if (TRUE) {
[08:27:24.527]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:24.527]                 open = "w")
[08:27:24.527]         }
[08:27:24.527]         else {
[08:27:24.527]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:24.527]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:24.527]         }
[08:27:24.527]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:24.527]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:24.527]             base::sink(type = "output", split = FALSE)
[08:27:24.527]             base::close(...future.stdout)
[08:27:24.527]         }, add = TRUE)
[08:27:24.527]     }
[08:27:24.527]     ...future.frame <- base::sys.nframe()
[08:27:24.527]     ...future.conditions <- base::list()
[08:27:24.527]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:24.527]     if (FALSE) {
[08:27:24.527]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:24.527]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:24.527]     }
[08:27:24.527]     ...future.result <- base::tryCatch({
[08:27:24.527]         base::withCallingHandlers({
[08:27:24.527]             ...future.value <- base::withVisible(base::local({
[08:27:24.527]                 ...future.makeSendCondition <- base::local({
[08:27:24.527]                   sendCondition <- NULL
[08:27:24.527]                   function(frame = 1L) {
[08:27:24.527]                     if (is.function(sendCondition)) 
[08:27:24.527]                       return(sendCondition)
[08:27:24.527]                     ns <- getNamespace("parallel")
[08:27:24.527]                     if (exists("sendData", mode = "function", 
[08:27:24.527]                       envir = ns)) {
[08:27:24.527]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:24.527]                         envir = ns)
[08:27:24.527]                       envir <- sys.frame(frame)
[08:27:24.527]                       master <- NULL
[08:27:24.527]                       while (!identical(envir, .GlobalEnv) && 
[08:27:24.527]                         !identical(envir, emptyenv())) {
[08:27:24.527]                         if (exists("master", mode = "list", envir = envir, 
[08:27:24.527]                           inherits = FALSE)) {
[08:27:24.527]                           master <- get("master", mode = "list", 
[08:27:24.527]                             envir = envir, inherits = FALSE)
[08:27:24.527]                           if (inherits(master, c("SOCKnode", 
[08:27:24.527]                             "SOCK0node"))) {
[08:27:24.527]                             sendCondition <<- function(cond) {
[08:27:24.527]                               data <- list(type = "VALUE", value = cond, 
[08:27:24.527]                                 success = TRUE)
[08:27:24.527]                               parallel_sendData(master, data)
[08:27:24.527]                             }
[08:27:24.527]                             return(sendCondition)
[08:27:24.527]                           }
[08:27:24.527]                         }
[08:27:24.527]                         frame <- frame + 1L
[08:27:24.527]                         envir <- sys.frame(frame)
[08:27:24.527]                       }
[08:27:24.527]                     }
[08:27:24.527]                     sendCondition <<- function(cond) NULL
[08:27:24.527]                   }
[08:27:24.527]                 })
[08:27:24.527]                 withCallingHandlers({
[08:27:24.527]                   {
[08:27:24.527]                     message(sprintf("Calculating tile #%d of %d ...", 
[08:27:24.527]                       ii, n), appendLF = FALSE)
[08:27:24.527]                     fit <- mandelbrot(C)
[08:27:24.527]                     delay(fit)
[08:27:24.527]                     message(" done")
[08:27:24.527]                     fit
[08:27:24.527]                   }
[08:27:24.527]                 }, immediateCondition = function(cond) {
[08:27:24.527]                   sendCondition <- ...future.makeSendCondition()
[08:27:24.527]                   sendCondition(cond)
[08:27:24.527]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:24.527]                   {
[08:27:24.527]                     inherits <- base::inherits
[08:27:24.527]                     invokeRestart <- base::invokeRestart
[08:27:24.527]                     is.null <- base::is.null
[08:27:24.527]                     muffled <- FALSE
[08:27:24.527]                     if (inherits(cond, "message")) {
[08:27:24.527]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:24.527]                       if (muffled) 
[08:27:24.527]                         invokeRestart("muffleMessage")
[08:27:24.527]                     }
[08:27:24.527]                     else if (inherits(cond, "warning")) {
[08:27:24.527]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:24.527]                       if (muffled) 
[08:27:24.527]                         invokeRestart("muffleWarning")
[08:27:24.527]                     }
[08:27:24.527]                     else if (inherits(cond, "condition")) {
[08:27:24.527]                       if (!is.null(pattern)) {
[08:27:24.527]                         computeRestarts <- base::computeRestarts
[08:27:24.527]                         grepl <- base::grepl
[08:27:24.527]                         restarts <- computeRestarts(cond)
[08:27:24.527]                         for (restart in restarts) {
[08:27:24.527]                           name <- restart$name
[08:27:24.527]                           if (is.null(name)) 
[08:27:24.527]                             next
[08:27:24.527]                           if (!grepl(pattern, name)) 
[08:27:24.527]                             next
[08:27:24.527]                           invokeRestart(restart)
[08:27:24.527]                           muffled <- TRUE
[08:27:24.527]                           break
[08:27:24.527]                         }
[08:27:24.527]                       }
[08:27:24.527]                     }
[08:27:24.527]                     invisible(muffled)
[08:27:24.527]                   }
[08:27:24.527]                   muffleCondition(cond)
[08:27:24.527]                 })
[08:27:24.527]             }))
[08:27:24.527]             future::FutureResult(value = ...future.value$value, 
[08:27:24.527]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:24.527]                   ...future.rng), globalenv = if (FALSE) 
[08:27:24.527]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:24.527]                     ...future.globalenv.names))
[08:27:24.527]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:24.527]         }, condition = base::local({
[08:27:24.527]             c <- base::c
[08:27:24.527]             inherits <- base::inherits
[08:27:24.527]             invokeRestart <- base::invokeRestart
[08:27:24.527]             length <- base::length
[08:27:24.527]             list <- base::list
[08:27:24.527]             seq.int <- base::seq.int
[08:27:24.527]             signalCondition <- base::signalCondition
[08:27:24.527]             sys.calls <- base::sys.calls
[08:27:24.527]             `[[` <- base::`[[`
[08:27:24.527]             `+` <- base::`+`
[08:27:24.527]             `<<-` <- base::`<<-`
[08:27:24.527]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:24.527]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:24.527]                   3L)]
[08:27:24.527]             }
[08:27:24.527]             function(cond) {
[08:27:24.527]                 is_error <- inherits(cond, "error")
[08:27:24.527]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:24.527]                   NULL)
[08:27:24.527]                 if (is_error) {
[08:27:24.527]                   sessionInformation <- function() {
[08:27:24.527]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:24.527]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:24.527]                       search = base::search(), system = base::Sys.info())
[08:27:24.527]                   }
[08:27:24.527]                   ...future.conditions[[length(...future.conditions) + 
[08:27:24.527]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:24.527]                     cond$call), session = sessionInformation(), 
[08:27:24.527]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:24.527]                   signalCondition(cond)
[08:27:24.527]                 }
[08:27:24.527]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:24.527]                 "immediateCondition"))) {
[08:27:24.527]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:24.527]                   ...future.conditions[[length(...future.conditions) + 
[08:27:24.527]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:24.527]                   if (TRUE && !signal) {
[08:27:24.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:24.527]                     {
[08:27:24.527]                       inherits <- base::inherits
[08:27:24.527]                       invokeRestart <- base::invokeRestart
[08:27:24.527]                       is.null <- base::is.null
[08:27:24.527]                       muffled <- FALSE
[08:27:24.527]                       if (inherits(cond, "message")) {
[08:27:24.527]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:24.527]                         if (muffled) 
[08:27:24.527]                           invokeRestart("muffleMessage")
[08:27:24.527]                       }
[08:27:24.527]                       else if (inherits(cond, "warning")) {
[08:27:24.527]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:24.527]                         if (muffled) 
[08:27:24.527]                           invokeRestart("muffleWarning")
[08:27:24.527]                       }
[08:27:24.527]                       else if (inherits(cond, "condition")) {
[08:27:24.527]                         if (!is.null(pattern)) {
[08:27:24.527]                           computeRestarts <- base::computeRestarts
[08:27:24.527]                           grepl <- base::grepl
[08:27:24.527]                           restarts <- computeRestarts(cond)
[08:27:24.527]                           for (restart in restarts) {
[08:27:24.527]                             name <- restart$name
[08:27:24.527]                             if (is.null(name)) 
[08:27:24.527]                               next
[08:27:24.527]                             if (!grepl(pattern, name)) 
[08:27:24.527]                               next
[08:27:24.527]                             invokeRestart(restart)
[08:27:24.527]                             muffled <- TRUE
[08:27:24.527]                             break
[08:27:24.527]                           }
[08:27:24.527]                         }
[08:27:24.527]                       }
[08:27:24.527]                       invisible(muffled)
[08:27:24.527]                     }
[08:27:24.527]                     muffleCondition(cond, pattern = "^muffle")
[08:27:24.527]                   }
[08:27:24.527]                 }
[08:27:24.527]                 else {
[08:27:24.527]                   if (TRUE) {
[08:27:24.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:24.527]                     {
[08:27:24.527]                       inherits <- base::inherits
[08:27:24.527]                       invokeRestart <- base::invokeRestart
[08:27:24.527]                       is.null <- base::is.null
[08:27:24.527]                       muffled <- FALSE
[08:27:24.527]                       if (inherits(cond, "message")) {
[08:27:24.527]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:24.527]                         if (muffled) 
[08:27:24.527]                           invokeRestart("muffleMessage")
[08:27:24.527]                       }
[08:27:24.527]                       else if (inherits(cond, "warning")) {
[08:27:24.527]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:24.527]                         if (muffled) 
[08:27:24.527]                           invokeRestart("muffleWarning")
[08:27:24.527]                       }
[08:27:24.527]                       else if (inherits(cond, "condition")) {
[08:27:24.527]                         if (!is.null(pattern)) {
[08:27:24.527]                           computeRestarts <- base::computeRestarts
[08:27:24.527]                           grepl <- base::grepl
[08:27:24.527]                           restarts <- computeRestarts(cond)
[08:27:24.527]                           for (restart in restarts) {
[08:27:24.527]                             name <- restart$name
[08:27:24.527]                             if (is.null(name)) 
[08:27:24.527]                               next
[08:27:24.527]                             if (!grepl(pattern, name)) 
[08:27:24.527]                               next
[08:27:24.527]                             invokeRestart(restart)
[08:27:24.527]                             muffled <- TRUE
[08:27:24.527]                             break
[08:27:24.527]                           }
[08:27:24.527]                         }
[08:27:24.527]                       }
[08:27:24.527]                       invisible(muffled)
[08:27:24.527]                     }
[08:27:24.527]                     muffleCondition(cond, pattern = "^muffle")
[08:27:24.527]                   }
[08:27:24.527]                 }
[08:27:24.527]             }
[08:27:24.527]         }))
[08:27:24.527]     }, error = function(ex) {
[08:27:24.527]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:24.527]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:24.527]                 ...future.rng), started = ...future.startTime, 
[08:27:24.527]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:24.527]             version = "1.8"), class = "FutureResult")
[08:27:24.527]     }, finally = {
[08:27:24.527]         if (!identical(...future.workdir, getwd())) 
[08:27:24.527]             setwd(...future.workdir)
[08:27:24.527]         {
[08:27:24.527]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:24.527]                 ...future.oldOptions$nwarnings <- NULL
[08:27:24.527]             }
[08:27:24.527]             base::options(...future.oldOptions)
[08:27:24.527]             if (.Platform$OS.type == "windows") {
[08:27:24.527]                 old_names <- names(...future.oldEnvVars)
[08:27:24.527]                 envs <- base::Sys.getenv()
[08:27:24.527]                 names <- names(envs)
[08:27:24.527]                 common <- intersect(names, old_names)
[08:27:24.527]                 added <- setdiff(names, old_names)
[08:27:24.527]                 removed <- setdiff(old_names, names)
[08:27:24.527]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:24.527]                   envs[common]]
[08:27:24.527]                 NAMES <- toupper(changed)
[08:27:24.527]                 args <- list()
[08:27:24.527]                 for (kk in seq_along(NAMES)) {
[08:27:24.527]                   name <- changed[[kk]]
[08:27:24.527]                   NAME <- NAMES[[kk]]
[08:27:24.527]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:24.527]                     next
[08:27:24.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:24.527]                 }
[08:27:24.527]                 NAMES <- toupper(added)
[08:27:24.527]                 for (kk in seq_along(NAMES)) {
[08:27:24.527]                   name <- added[[kk]]
[08:27:24.527]                   NAME <- NAMES[[kk]]
[08:27:24.527]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:24.527]                     next
[08:27:24.527]                   args[[name]] <- ""
[08:27:24.527]                 }
[08:27:24.527]                 NAMES <- toupper(removed)
[08:27:24.527]                 for (kk in seq_along(NAMES)) {
[08:27:24.527]                   name <- removed[[kk]]
[08:27:24.527]                   NAME <- NAMES[[kk]]
[08:27:24.527]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:24.527]                     next
[08:27:24.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:24.527]                 }
[08:27:24.527]                 if (length(args) > 0) 
[08:27:24.527]                   base::do.call(base::Sys.setenv, args = args)
[08:27:24.527]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:24.527]             }
[08:27:24.527]             else {
[08:27:24.527]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:24.527]             }
[08:27:24.527]             {
[08:27:24.527]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:24.527]                   0L) {
[08:27:24.527]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:24.527]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:24.527]                   base::options(opts)
[08:27:24.527]                 }
[08:27:24.527]                 {
[08:27:24.527]                   {
[08:27:24.527]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:24.527]                     NULL
[08:27:24.527]                   }
[08:27:24.527]                   options(future.plan = NULL)
[08:27:24.527]                   if (is.na(NA_character_)) 
[08:27:24.527]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:24.527]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:24.527]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:24.527]                     .init = FALSE)
[08:27:24.527]                 }
[08:27:24.527]             }
[08:27:24.527]         }
[08:27:24.527]     })
[08:27:24.527]     if (TRUE) {
[08:27:24.527]         base::sink(type = "output", split = FALSE)
[08:27:24.527]         if (TRUE) {
[08:27:24.527]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:24.527]         }
[08:27:24.527]         else {
[08:27:24.527]             ...future.result["stdout"] <- base::list(NULL)
[08:27:24.527]         }
[08:27:24.527]         base::close(...future.stdout)
[08:27:24.527]         ...future.stdout <- NULL
[08:27:24.527]     }
[08:27:24.527]     ...future.result$conditions <- ...future.conditions
[08:27:24.527]     ...future.result$finished <- base::Sys.time()
[08:27:24.527]     ...future.result
[08:27:24.527] }
[08:27:24.582] Exporting 4 global objects (57.67 KiB) to cluster node #2 ...
[08:27:24.582] Exporting ‘ii’ (35 bytes) to cluster node #2 ...
[08:27:24.583] Exporting ‘ii’ (35 bytes) to cluster node #2 ... DONE
[08:27:24.583] Exporting ‘n’ (35 bytes) to cluster node #2 ...
[08:27:24.583] Exporting ‘n’ (35 bytes) to cluster node #2 ... DONE
[08:27:24.583] Exporting ‘C’ (10.00 KiB) to cluster node #2 ...
[08:27:24.624] Exporting ‘C’ (10.00 KiB) to cluster node #2 ... DONE
[08:27:24.625] Exporting ‘delay’ (47.33 KiB) to cluster node #2 ...
[08:27:24.666] Exporting ‘delay’ (47.33 KiB) to cluster node #2 ... DONE
[08:27:24.666] Exporting 4 global objects (57.67 KiB) to cluster node #2 ... DONE
[08:27:24.667] MultisessionFuture started
[08:27:24.667] - Launch lazy future ... done
[08:27:24.667] run() for ‘MultisessionFuture’ ... done
[08:27:24.667] - run() ... done
[08:27:24.667] - resolved() ...
[08:27:24.678] - resolved: FALSE
[08:27:24.678] - resolved() ... done
[08:27:24.678] resolved() for ‘MultisessionFuture’ ... done
[08:27:24.678] resolved() for ‘Future’ ...
[08:27:24.679] - state: ‘created’
[08:27:24.679] - run: TRUE
[08:27:24.679] - run() ...
[08:27:24.679] run() for ‘Future’ ...
[08:27:24.679] - state: ‘created’
[08:27:24.681] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:24.695] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:24.695] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:24.695]   - Field: ‘node’
[08:27:24.695]   - Field: ‘label’
[08:27:24.695]   - Field: ‘local’
[08:27:24.696]   - Field: ‘owner’
[08:27:24.696]   - Field: ‘envir’
[08:27:24.696]   - Field: ‘workers’
[08:27:24.696]   - Field: ‘packages’
[08:27:24.696]   - Field: ‘gc’
[08:27:24.696]   - Field: ‘conditions’
[08:27:24.696]   - Field: ‘persistent’
[08:27:24.696]   - Field: ‘expr’
[08:27:24.696]   - Field: ‘uuid’
[08:27:24.696]   - Field: ‘seed’
[08:27:24.696]   - Field: ‘version’
[08:27:24.696]   - Field: ‘result’
[08:27:24.697]   - Field: ‘asynchronous’
[08:27:24.697]   - Field: ‘calls’
[08:27:24.697]   - Field: ‘globals’
[08:27:24.697]   - Field: ‘stdout’
[08:27:24.697]   - Field: ‘earlySignal’
[08:27:24.697]   - Field: ‘lazy’
[08:27:24.697]   - Field: ‘state’
[08:27:24.697] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:24.697] - Launch lazy future ...
[08:27:24.698] Packages needed by the future expression (n = 1): ‘future’
[08:27:24.698] Packages needed by future strategies (n = 0): <none>
[08:27:24.698] {
[08:27:24.698]     {
[08:27:24.698]         {
[08:27:24.698]             ...future.startTime <- base::Sys.time()
[08:27:24.698]             {
[08:27:24.698]                 {
[08:27:24.698]                   {
[08:27:24.698]                     {
[08:27:24.698]                       {
[08:27:24.698]                         base::local({
[08:27:24.698]                           has_future <- base::requireNamespace("future", 
[08:27:24.698]                             quietly = TRUE)
[08:27:24.698]                           if (has_future) {
[08:27:24.698]                             ns <- base::getNamespace("future")
[08:27:24.698]                             version <- ns[[".package"]][["version"]]
[08:27:24.698]                             if (is.null(version)) 
[08:27:24.698]                               version <- utils::packageVersion("future")
[08:27:24.698]                           }
[08:27:24.698]                           else {
[08:27:24.698]                             version <- NULL
[08:27:24.698]                           }
[08:27:24.698]                           if (!has_future || version < "1.8.0") {
[08:27:24.698]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:24.698]                               "", base::R.version$version.string), 
[08:27:24.698]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:24.698]                                 base::R.version$platform, 8 * 
[08:27:24.698]                                   base::.Machine$sizeof.pointer), 
[08:27:24.698]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:24.698]                                 "release", "version")], collapse = " "), 
[08:27:24.698]                               hostname = base::Sys.info()[["nodename"]])
[08:27:24.698]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:24.698]                               info)
[08:27:24.698]                             info <- base::paste(info, collapse = "; ")
[08:27:24.698]                             if (!has_future) {
[08:27:24.698]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:24.698]                                 info)
[08:27:24.698]                             }
[08:27:24.698]                             else {
[08:27:24.698]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:24.698]                                 info, version)
[08:27:24.698]                             }
[08:27:24.698]                             base::stop(msg)
[08:27:24.698]                           }
[08:27:24.698]                         })
[08:27:24.698]                       }
[08:27:24.698]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:24.698]                       base::options(mc.cores = 1L)
[08:27:24.698]                     }
[08:27:24.698]                     base::local({
[08:27:24.698]                       for (pkg in "future") {
[08:27:24.698]                         base::loadNamespace(pkg)
[08:27:24.698]                         base::library(pkg, character.only = TRUE)
[08:27:24.698]                       }
[08:27:24.698]                     })
[08:27:24.698]                   }
[08:27:24.698]                   ...future.strategy.old <- future::plan("list")
[08:27:24.698]                   options(future.plan = NULL)
[08:27:24.698]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:24.698]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:24.698]                 }
[08:27:24.698]                 ...future.workdir <- getwd()
[08:27:24.698]             }
[08:27:24.698]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:24.698]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:24.698]         }
[08:27:24.698]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:24.698]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:24.698]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:24.698]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:24.698]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:24.698]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:24.698]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:24.698]             base::names(...future.oldOptions))
[08:27:24.698]     }
[08:27:24.698]     if (FALSE) {
[08:27:24.698]     }
[08:27:24.698]     else {
[08:27:24.698]         if (TRUE) {
[08:27:24.698]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:24.698]                 open = "w")
[08:27:24.698]         }
[08:27:24.698]         else {
[08:27:24.698]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:24.698]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:24.698]         }
[08:27:24.698]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:24.698]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:24.698]             base::sink(type = "output", split = FALSE)
[08:27:24.698]             base::close(...future.stdout)
[08:27:24.698]         }, add = TRUE)
[08:27:24.698]     }
[08:27:24.698]     ...future.frame <- base::sys.nframe()
[08:27:24.698]     ...future.conditions <- base::list()
[08:27:24.698]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:24.698]     if (FALSE) {
[08:27:24.698]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:24.698]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:24.698]     }
[08:27:24.698]     ...future.result <- base::tryCatch({
[08:27:24.698]         base::withCallingHandlers({
[08:27:24.698]             ...future.value <- base::withVisible(base::local({
[08:27:24.698]                 ...future.makeSendCondition <- base::local({
[08:27:24.698]                   sendCondition <- NULL
[08:27:24.698]                   function(frame = 1L) {
[08:27:24.698]                     if (is.function(sendCondition)) 
[08:27:24.698]                       return(sendCondition)
[08:27:24.698]                     ns <- getNamespace("parallel")
[08:27:24.698]                     if (exists("sendData", mode = "function", 
[08:27:24.698]                       envir = ns)) {
[08:27:24.698]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:24.698]                         envir = ns)
[08:27:24.698]                       envir <- sys.frame(frame)
[08:27:24.698]                       master <- NULL
[08:27:24.698]                       while (!identical(envir, .GlobalEnv) && 
[08:27:24.698]                         !identical(envir, emptyenv())) {
[08:27:24.698]                         if (exists("master", mode = "list", envir = envir, 
[08:27:24.698]                           inherits = FALSE)) {
[08:27:24.698]                           master <- get("master", mode = "list", 
[08:27:24.698]                             envir = envir, inherits = FALSE)
[08:27:24.698]                           if (inherits(master, c("SOCKnode", 
[08:27:24.698]                             "SOCK0node"))) {
[08:27:24.698]                             sendCondition <<- function(cond) {
[08:27:24.698]                               data <- list(type = "VALUE", value = cond, 
[08:27:24.698]                                 success = TRUE)
[08:27:24.698]                               parallel_sendData(master, data)
[08:27:24.698]                             }
[08:27:24.698]                             return(sendCondition)
[08:27:24.698]                           }
[08:27:24.698]                         }
[08:27:24.698]                         frame <- frame + 1L
[08:27:24.698]                         envir <- sys.frame(frame)
[08:27:24.698]                       }
[08:27:24.698]                     }
[08:27:24.698]                     sendCondition <<- function(cond) NULL
[08:27:24.698]                   }
[08:27:24.698]                 })
[08:27:24.698]                 withCallingHandlers({
[08:27:24.698]                   {
[08:27:24.698]                     message(sprintf("Calculating tile #%d of %d ...", 
[08:27:24.698]                       ii, n), appendLF = FALSE)
[08:27:24.698]                     fit <- mandelbrot(C)
[08:27:24.698]                     delay(fit)
[08:27:24.698]                     message(" done")
[08:27:24.698]                     fit
[08:27:24.698]                   }
[08:27:24.698]                 }, immediateCondition = function(cond) {
[08:27:24.698]                   sendCondition <- ...future.makeSendCondition()
[08:27:24.698]                   sendCondition(cond)
[08:27:24.698]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:24.698]                   {
[08:27:24.698]                     inherits <- base::inherits
[08:27:24.698]                     invokeRestart <- base::invokeRestart
[08:27:24.698]                     is.null <- base::is.null
[08:27:24.698]                     muffled <- FALSE
[08:27:24.698]                     if (inherits(cond, "message")) {
[08:27:24.698]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:24.698]                       if (muffled) 
[08:27:24.698]                         invokeRestart("muffleMessage")
[08:27:24.698]                     }
[08:27:24.698]                     else if (inherits(cond, "warning")) {
[08:27:24.698]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:24.698]                       if (muffled) 
[08:27:24.698]                         invokeRestart("muffleWarning")
[08:27:24.698]                     }
[08:27:24.698]                     else if (inherits(cond, "condition")) {
[08:27:24.698]                       if (!is.null(pattern)) {
[08:27:24.698]                         computeRestarts <- base::computeRestarts
[08:27:24.698]                         grepl <- base::grepl
[08:27:24.698]                         restarts <- computeRestarts(cond)
[08:27:24.698]                         for (restart in restarts) {
[08:27:24.698]                           name <- restart$name
[08:27:24.698]                           if (is.null(name)) 
[08:27:24.698]                             next
[08:27:24.698]                           if (!grepl(pattern, name)) 
[08:27:24.698]                             next
[08:27:24.698]                           invokeRestart(restart)
[08:27:24.698]                           muffled <- TRUE
[08:27:24.698]                           break
[08:27:24.698]                         }
[08:27:24.698]                       }
[08:27:24.698]                     }
[08:27:24.698]                     invisible(muffled)
[08:27:24.698]                   }
[08:27:24.698]                   muffleCondition(cond)
[08:27:24.698]                 })
[08:27:24.698]             }))
[08:27:24.698]             future::FutureResult(value = ...future.value$value, 
[08:27:24.698]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:24.698]                   ...future.rng), globalenv = if (FALSE) 
[08:27:24.698]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:24.698]                     ...future.globalenv.names))
[08:27:24.698]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:24.698]         }, condition = base::local({
[08:27:24.698]             c <- base::c
[08:27:24.698]             inherits <- base::inherits
[08:27:24.698]             invokeRestart <- base::invokeRestart
[08:27:24.698]             length <- base::length
[08:27:24.698]             list <- base::list
[08:27:24.698]             seq.int <- base::seq.int
[08:27:24.698]             signalCondition <- base::signalCondition
[08:27:24.698]             sys.calls <- base::sys.calls
[08:27:24.698]             `[[` <- base::`[[`
[08:27:24.698]             `+` <- base::`+`
[08:27:24.698]             `<<-` <- base::`<<-`
[08:27:24.698]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:24.698]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:24.698]                   3L)]
[08:27:24.698]             }
[08:27:24.698]             function(cond) {
[08:27:24.698]                 is_error <- inherits(cond, "error")
[08:27:24.698]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:24.698]                   NULL)
[08:27:24.698]                 if (is_error) {
[08:27:24.698]                   sessionInformation <- function() {
[08:27:24.698]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:24.698]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:24.698]                       search = base::search(), system = base::Sys.info())
[08:27:24.698]                   }
[08:27:24.698]                   ...future.conditions[[length(...future.conditions) + 
[08:27:24.698]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:24.698]                     cond$call), session = sessionInformation(), 
[08:27:24.698]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:24.698]                   signalCondition(cond)
[08:27:24.698]                 }
[08:27:24.698]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:24.698]                 "immediateCondition"))) {
[08:27:24.698]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:24.698]                   ...future.conditions[[length(...future.conditions) + 
[08:27:24.698]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:24.698]                   if (TRUE && !signal) {
[08:27:24.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:24.698]                     {
[08:27:24.698]                       inherits <- base::inherits
[08:27:24.698]                       invokeRestart <- base::invokeRestart
[08:27:24.698]                       is.null <- base::is.null
[08:27:24.698]                       muffled <- FALSE
[08:27:24.698]                       if (inherits(cond, "message")) {
[08:27:24.698]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:24.698]                         if (muffled) 
[08:27:24.698]                           invokeRestart("muffleMessage")
[08:27:24.698]                       }
[08:27:24.698]                       else if (inherits(cond, "warning")) {
[08:27:24.698]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:24.698]                         if (muffled) 
[08:27:24.698]                           invokeRestart("muffleWarning")
[08:27:24.698]                       }
[08:27:24.698]                       else if (inherits(cond, "condition")) {
[08:27:24.698]                         if (!is.null(pattern)) {
[08:27:24.698]                           computeRestarts <- base::computeRestarts
[08:27:24.698]                           grepl <- base::grepl
[08:27:24.698]                           restarts <- computeRestarts(cond)
[08:27:24.698]                           for (restart in restarts) {
[08:27:24.698]                             name <- restart$name
[08:27:24.698]                             if (is.null(name)) 
[08:27:24.698]                               next
[08:27:24.698]                             if (!grepl(pattern, name)) 
[08:27:24.698]                               next
[08:27:24.698]                             invokeRestart(restart)
[08:27:24.698]                             muffled <- TRUE
[08:27:24.698]                             break
[08:27:24.698]                           }
[08:27:24.698]                         }
[08:27:24.698]                       }
[08:27:24.698]                       invisible(muffled)
[08:27:24.698]                     }
[08:27:24.698]                     muffleCondition(cond, pattern = "^muffle")
[08:27:24.698]                   }
[08:27:24.698]                 }
[08:27:24.698]                 else {
[08:27:24.698]                   if (TRUE) {
[08:27:24.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:24.698]                     {
[08:27:24.698]                       inherits <- base::inherits
[08:27:24.698]                       invokeRestart <- base::invokeRestart
[08:27:24.698]                       is.null <- base::is.null
[08:27:24.698]                       muffled <- FALSE
[08:27:24.698]                       if (inherits(cond, "message")) {
[08:27:24.698]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:24.698]                         if (muffled) 
[08:27:24.698]                           invokeRestart("muffleMessage")
[08:27:24.698]                       }
[08:27:24.698]                       else if (inherits(cond, "warning")) {
[08:27:24.698]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:24.698]                         if (muffled) 
[08:27:24.698]                           invokeRestart("muffleWarning")
[08:27:24.698]                       }
[08:27:24.698]                       else if (inherits(cond, "condition")) {
[08:27:24.698]                         if (!is.null(pattern)) {
[08:27:24.698]                           computeRestarts <- base::computeRestarts
[08:27:24.698]                           grepl <- base::grepl
[08:27:24.698]                           restarts <- computeRestarts(cond)
[08:27:24.698]                           for (restart in restarts) {
[08:27:24.698]                             name <- restart$name
[08:27:24.698]                             if (is.null(name)) 
[08:27:24.698]                               next
[08:27:24.698]                             if (!grepl(pattern, name)) 
[08:27:24.698]                               next
[08:27:24.698]                             invokeRestart(restart)
[08:27:24.698]                             muffled <- TRUE
[08:27:24.698]                             break
[08:27:24.698]                           }
[08:27:24.698]                         }
[08:27:24.698]                       }
[08:27:24.698]                       invisible(muffled)
[08:27:24.698]                     }
[08:27:24.698]                     muffleCondition(cond, pattern = "^muffle")
[08:27:24.698]                   }
[08:27:24.698]                 }
[08:27:24.698]             }
[08:27:24.698]         }))
[08:27:24.698]     }, error = function(ex) {
[08:27:24.698]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:24.698]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:24.698]                 ...future.rng), started = ...future.startTime, 
[08:27:24.698]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:24.698]             version = "1.8"), class = "FutureResult")
[08:27:24.698]     }, finally = {
[08:27:24.698]         if (!identical(...future.workdir, getwd())) 
[08:27:24.698]             setwd(...future.workdir)
[08:27:24.698]         {
[08:27:24.698]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:24.698]                 ...future.oldOptions$nwarnings <- NULL
[08:27:24.698]             }
[08:27:24.698]             base::options(...future.oldOptions)
[08:27:24.698]             if (.Platform$OS.type == "windows") {
[08:27:24.698]                 old_names <- names(...future.oldEnvVars)
[08:27:24.698]                 envs <- base::Sys.getenv()
[08:27:24.698]                 names <- names(envs)
[08:27:24.698]                 common <- intersect(names, old_names)
[08:27:24.698]                 added <- setdiff(names, old_names)
[08:27:24.698]                 removed <- setdiff(old_names, names)
[08:27:24.698]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:24.698]                   envs[common]]
[08:27:24.698]                 NAMES <- toupper(changed)
[08:27:24.698]                 args <- list()
[08:27:24.698]                 for (kk in seq_along(NAMES)) {
[08:27:24.698]                   name <- changed[[kk]]
[08:27:24.698]                   NAME <- NAMES[[kk]]
[08:27:24.698]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:24.698]                     next
[08:27:24.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:24.698]                 }
[08:27:24.698]                 NAMES <- toupper(added)
[08:27:24.698]                 for (kk in seq_along(NAMES)) {
[08:27:24.698]                   name <- added[[kk]]
[08:27:24.698]                   NAME <- NAMES[[kk]]
[08:27:24.698]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:24.698]                     next
[08:27:24.698]                   args[[name]] <- ""
[08:27:24.698]                 }
[08:27:24.698]                 NAMES <- toupper(removed)
[08:27:24.698]                 for (kk in seq_along(NAMES)) {
[08:27:24.698]                   name <- removed[[kk]]
[08:27:24.698]                   NAME <- NAMES[[kk]]
[08:27:24.698]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:24.698]                     next
[08:27:24.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:24.698]                 }
[08:27:24.698]                 if (length(args) > 0) 
[08:27:24.698]                   base::do.call(base::Sys.setenv, args = args)
[08:27:24.698]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:24.698]             }
[08:27:24.698]             else {
[08:27:24.698]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:24.698]             }
[08:27:24.698]             {
[08:27:24.698]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:24.698]                   0L) {
[08:27:24.698]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:24.698]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:24.698]                   base::options(opts)
[08:27:24.698]                 }
[08:27:24.698]                 {
[08:27:24.698]                   {
[08:27:24.698]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:24.698]                     NULL
[08:27:24.698]                   }
[08:27:24.698]                   options(future.plan = NULL)
[08:27:24.698]                   if (is.na(NA_character_)) 
[08:27:24.698]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:24.698]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:24.698]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:24.698]                     .init = FALSE)
[08:27:24.698]                 }
[08:27:24.698]             }
[08:27:24.698]         }
[08:27:24.698]     })
[08:27:24.698]     if (TRUE) {
[08:27:24.698]         base::sink(type = "output", split = FALSE)
[08:27:24.698]         if (TRUE) {
[08:27:24.698]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:24.698]         }
[08:27:24.698]         else {
[08:27:24.698]             ...future.result["stdout"] <- base::list(NULL)
[08:27:24.698]         }
[08:27:24.698]         base::close(...future.stdout)
[08:27:24.698]         ...future.stdout <- NULL
[08:27:24.698]     }
[08:27:24.698]     ...future.result$conditions <- ...future.conditions
[08:27:24.698]     ...future.result$finished <- base::Sys.time()
[08:27:24.698]     ...future.result
[08:27:24.698] }
[08:27:24.700] Poll #1 (0): usedNodes() = 2, workers = 2
[08:27:24.711] receiveMessageFromWorker() for ClusterFuture ...
[08:27:24.712] - Validating connection of MultisessionFuture
[08:27:24.712] - received message: FutureResult
[08:27:24.712] - Received FutureResult
[08:27:24.712] - Erased future from FutureRegistry
[08:27:24.712] result() for ClusterFuture ...
[08:27:24.712] - result already collected: FutureResult
[08:27:24.712] result() for ClusterFuture ... done
[08:27:24.713] signalConditions() ...
[08:27:24.713]  - include = ‘immediateCondition’
[08:27:24.713]  - exclude = 
[08:27:24.713]  - resignal = FALSE
[08:27:24.713]  - Number of conditions: 2
[08:27:24.713] signalConditions() ... done
[08:27:24.713] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:24.713] result() for ClusterFuture ...
[08:27:24.713] - result already collected: FutureResult
[08:27:24.713] result() for ClusterFuture ... done
[08:27:24.713] result() for ClusterFuture ...
[08:27:24.713] - result already collected: FutureResult
[08:27:24.714] result() for ClusterFuture ... done
[08:27:24.714] signalConditions() ...
[08:27:24.714]  - include = ‘immediateCondition’
[08:27:24.714]  - exclude = 
[08:27:24.714]  - resignal = FALSE
[08:27:24.714]  - Number of conditions: 2
[08:27:24.714] signalConditions() ... done
[08:27:24.715] Exporting 4 global objects (57.67 KiB) to cluster node #1 ...
[08:27:24.715] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[08:27:24.715] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[08:27:24.716] Exporting ‘n’ (35 bytes) to cluster node #1 ...
[08:27:24.716] Exporting ‘n’ (35 bytes) to cluster node #1 ... DONE
[08:27:24.716] Exporting ‘C’ (10.00 KiB) to cluster node #1 ...
[08:27:24.758] Exporting ‘C’ (10.00 KiB) to cluster node #1 ... DONE
[08:27:24.758] Exporting ‘delay’ (47.33 KiB) to cluster node #1 ...
[08:27:24.800] Exporting ‘delay’ (47.33 KiB) to cluster node #1 ... DONE
[08:27:24.800] Exporting 4 global objects (57.67 KiB) to cluster node #1 ... DONE
[08:27:24.801] MultisessionFuture started
[08:27:24.801] - Launch lazy future ... done
[08:27:24.801] run() for ‘MultisessionFuture’ ... done
[08:27:24.801] - run() ... done
[08:27:24.801] - resolved() ...
[08:27:24.812] - resolved: FALSE
[08:27:24.812] - resolved() ... done
[08:27:24.812] resolved() for ‘MultisessionFuture’ ... done
[08:27:24.812] resolved() for ‘Future’ ...
[08:27:24.813] - state: ‘created’
[08:27:24.813] - run: TRUE
[08:27:24.813] - run() ...
[08:27:24.813] run() for ‘Future’ ...
[08:27:24.813] - state: ‘created’
[08:27:24.813] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:24.827] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:24.827] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:24.827]   - Field: ‘node’
[08:27:24.827]   - Field: ‘label’
[08:27:24.827]   - Field: ‘local’
[08:27:24.827]   - Field: ‘owner’
[08:27:24.827]   - Field: ‘envir’
[08:27:24.828]   - Field: ‘workers’
[08:27:24.828]   - Field: ‘packages’
[08:27:24.828]   - Field: ‘gc’
[08:27:24.828]   - Field: ‘conditions’
[08:27:24.828]   - Field: ‘persistent’
[08:27:24.828]   - Field: ‘expr’
[08:27:24.828]   - Field: ‘uuid’
[08:27:24.828]   - Field: ‘seed’
[08:27:24.828]   - Field: ‘version’
[08:27:24.828]   - Field: ‘result’
[08:27:24.828]   - Field: ‘asynchronous’
[08:27:24.828]   - Field: ‘calls’
[08:27:24.828]   - Field: ‘globals’
[08:27:24.829]   - Field: ‘stdout’
[08:27:24.829]   - Field: ‘earlySignal’
[08:27:24.829]   - Field: ‘lazy’
[08:27:24.829]   - Field: ‘state’
[08:27:24.829] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:24.829] - Launch lazy future ...
[08:27:24.829] Packages needed by the future expression (n = 1): ‘future’
[08:27:24.829] Packages needed by future strategies (n = 0): <none>
[08:27:24.830] {
[08:27:24.830]     {
[08:27:24.830]         {
[08:27:24.830]             ...future.startTime <- base::Sys.time()
[08:27:24.830]             {
[08:27:24.830]                 {
[08:27:24.830]                   {
[08:27:24.830]                     {
[08:27:24.830]                       {
[08:27:24.830]                         base::local({
[08:27:24.830]                           has_future <- base::requireNamespace("future", 
[08:27:24.830]                             quietly = TRUE)
[08:27:24.830]                           if (has_future) {
[08:27:24.830]                             ns <- base::getNamespace("future")
[08:27:24.830]                             version <- ns[[".package"]][["version"]]
[08:27:24.830]                             if (is.null(version)) 
[08:27:24.830]                               version <- utils::packageVersion("future")
[08:27:24.830]                           }
[08:27:24.830]                           else {
[08:27:24.830]                             version <- NULL
[08:27:24.830]                           }
[08:27:24.830]                           if (!has_future || version < "1.8.0") {
[08:27:24.830]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:24.830]                               "", base::R.version$version.string), 
[08:27:24.830]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:24.830]                                 base::R.version$platform, 8 * 
[08:27:24.830]                                   base::.Machine$sizeof.pointer), 
[08:27:24.830]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:24.830]                                 "release", "version")], collapse = " "), 
[08:27:24.830]                               hostname = base::Sys.info()[["nodename"]])
[08:27:24.830]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:24.830]                               info)
[08:27:24.830]                             info <- base::paste(info, collapse = "; ")
[08:27:24.830]                             if (!has_future) {
[08:27:24.830]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:24.830]                                 info)
[08:27:24.830]                             }
[08:27:24.830]                             else {
[08:27:24.830]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:24.830]                                 info, version)
[08:27:24.830]                             }
[08:27:24.830]                             base::stop(msg)
[08:27:24.830]                           }
[08:27:24.830]                         })
[08:27:24.830]                       }
[08:27:24.830]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:24.830]                       base::options(mc.cores = 1L)
[08:27:24.830]                     }
[08:27:24.830]                     base::local({
[08:27:24.830]                       for (pkg in "future") {
[08:27:24.830]                         base::loadNamespace(pkg)
[08:27:24.830]                         base::library(pkg, character.only = TRUE)
[08:27:24.830]                       }
[08:27:24.830]                     })
[08:27:24.830]                   }
[08:27:24.830]                   ...future.strategy.old <- future::plan("list")
[08:27:24.830]                   options(future.plan = NULL)
[08:27:24.830]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:24.830]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:24.830]                 }
[08:27:24.830]                 ...future.workdir <- getwd()
[08:27:24.830]             }
[08:27:24.830]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:24.830]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:24.830]         }
[08:27:24.830]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:24.830]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:24.830]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:24.830]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:24.830]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:24.830]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:24.830]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:24.830]             base::names(...future.oldOptions))
[08:27:24.830]     }
[08:27:24.830]     if (FALSE) {
[08:27:24.830]     }
[08:27:24.830]     else {
[08:27:24.830]         if (TRUE) {
[08:27:24.830]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:24.830]                 open = "w")
[08:27:24.830]         }
[08:27:24.830]         else {
[08:27:24.830]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:24.830]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:24.830]         }
[08:27:24.830]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:24.830]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:24.830]             base::sink(type = "output", split = FALSE)
[08:27:24.830]             base::close(...future.stdout)
[08:27:24.830]         }, add = TRUE)
[08:27:24.830]     }
[08:27:24.830]     ...future.frame <- base::sys.nframe()
[08:27:24.830]     ...future.conditions <- base::list()
[08:27:24.830]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:24.830]     if (FALSE) {
[08:27:24.830]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:24.830]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:24.830]     }
[08:27:24.830]     ...future.result <- base::tryCatch({
[08:27:24.830]         base::withCallingHandlers({
[08:27:24.830]             ...future.value <- base::withVisible(base::local({
[08:27:24.830]                 ...future.makeSendCondition <- base::local({
[08:27:24.830]                   sendCondition <- NULL
[08:27:24.830]                   function(frame = 1L) {
[08:27:24.830]                     if (is.function(sendCondition)) 
[08:27:24.830]                       return(sendCondition)
[08:27:24.830]                     ns <- getNamespace("parallel")
[08:27:24.830]                     if (exists("sendData", mode = "function", 
[08:27:24.830]                       envir = ns)) {
[08:27:24.830]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:24.830]                         envir = ns)
[08:27:24.830]                       envir <- sys.frame(frame)
[08:27:24.830]                       master <- NULL
[08:27:24.830]                       while (!identical(envir, .GlobalEnv) && 
[08:27:24.830]                         !identical(envir, emptyenv())) {
[08:27:24.830]                         if (exists("master", mode = "list", envir = envir, 
[08:27:24.830]                           inherits = FALSE)) {
[08:27:24.830]                           master <- get("master", mode = "list", 
[08:27:24.830]                             envir = envir, inherits = FALSE)
[08:27:24.830]                           if (inherits(master, c("SOCKnode", 
[08:27:24.830]                             "SOCK0node"))) {
[08:27:24.830]                             sendCondition <<- function(cond) {
[08:27:24.830]                               data <- list(type = "VALUE", value = cond, 
[08:27:24.830]                                 success = TRUE)
[08:27:24.830]                               parallel_sendData(master, data)
[08:27:24.830]                             }
[08:27:24.830]                             return(sendCondition)
[08:27:24.830]                           }
[08:27:24.830]                         }
[08:27:24.830]                         frame <- frame + 1L
[08:27:24.830]                         envir <- sys.frame(frame)
[08:27:24.830]                       }
[08:27:24.830]                     }
[08:27:24.830]                     sendCondition <<- function(cond) NULL
[08:27:24.830]                   }
[08:27:24.830]                 })
[08:27:24.830]                 withCallingHandlers({
[08:27:24.830]                   {
[08:27:24.830]                     message(sprintf("Calculating tile #%d of %d ...", 
[08:27:24.830]                       ii, n), appendLF = FALSE)
[08:27:24.830]                     fit <- mandelbrot(C)
[08:27:24.830]                     delay(fit)
[08:27:24.830]                     message(" done")
[08:27:24.830]                     fit
[08:27:24.830]                   }
[08:27:24.830]                 }, immediateCondition = function(cond) {
[08:27:24.830]                   sendCondition <- ...future.makeSendCondition()
[08:27:24.830]                   sendCondition(cond)
[08:27:24.830]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:24.830]                   {
[08:27:24.830]                     inherits <- base::inherits
[08:27:24.830]                     invokeRestart <- base::invokeRestart
[08:27:24.830]                     is.null <- base::is.null
[08:27:24.830]                     muffled <- FALSE
[08:27:24.830]                     if (inherits(cond, "message")) {
[08:27:24.830]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:24.830]                       if (muffled) 
[08:27:24.830]                         invokeRestart("muffleMessage")
[08:27:24.830]                     }
[08:27:24.830]                     else if (inherits(cond, "warning")) {
[08:27:24.830]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:24.830]                       if (muffled) 
[08:27:24.830]                         invokeRestart("muffleWarning")
[08:27:24.830]                     }
[08:27:24.830]                     else if (inherits(cond, "condition")) {
[08:27:24.830]                       if (!is.null(pattern)) {
[08:27:24.830]                         computeRestarts <- base::computeRestarts
[08:27:24.830]                         grepl <- base::grepl
[08:27:24.830]                         restarts <- computeRestarts(cond)
[08:27:24.830]                         for (restart in restarts) {
[08:27:24.830]                           name <- restart$name
[08:27:24.830]                           if (is.null(name)) 
[08:27:24.830]                             next
[08:27:24.830]                           if (!grepl(pattern, name)) 
[08:27:24.830]                             next
[08:27:24.830]                           invokeRestart(restart)
[08:27:24.830]                           muffled <- TRUE
[08:27:24.830]                           break
[08:27:24.830]                         }
[08:27:24.830]                       }
[08:27:24.830]                     }
[08:27:24.830]                     invisible(muffled)
[08:27:24.830]                   }
[08:27:24.830]                   muffleCondition(cond)
[08:27:24.830]                 })
[08:27:24.830]             }))
[08:27:24.830]             future::FutureResult(value = ...future.value$value, 
[08:27:24.830]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:24.830]                   ...future.rng), globalenv = if (FALSE) 
[08:27:24.830]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:24.830]                     ...future.globalenv.names))
[08:27:24.830]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:24.830]         }, condition = base::local({
[08:27:24.830]             c <- base::c
[08:27:24.830]             inherits <- base::inherits
[08:27:24.830]             invokeRestart <- base::invokeRestart
[08:27:24.830]             length <- base::length
[08:27:24.830]             list <- base::list
[08:27:24.830]             seq.int <- base::seq.int
[08:27:24.830]             signalCondition <- base::signalCondition
[08:27:24.830]             sys.calls <- base::sys.calls
[08:27:24.830]             `[[` <- base::`[[`
[08:27:24.830]             `+` <- base::`+`
[08:27:24.830]             `<<-` <- base::`<<-`
[08:27:24.830]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:24.830]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:24.830]                   3L)]
[08:27:24.830]             }
[08:27:24.830]             function(cond) {
[08:27:24.830]                 is_error <- inherits(cond, "error")
[08:27:24.830]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:24.830]                   NULL)
[08:27:24.830]                 if (is_error) {
[08:27:24.830]                   sessionInformation <- function() {
[08:27:24.830]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:24.830]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:24.830]                       search = base::search(), system = base::Sys.info())
[08:27:24.830]                   }
[08:27:24.830]                   ...future.conditions[[length(...future.conditions) + 
[08:27:24.830]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:24.830]                     cond$call), session = sessionInformation(), 
[08:27:24.830]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:24.830]                   signalCondition(cond)
[08:27:24.830]                 }
[08:27:24.830]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:24.830]                 "immediateCondition"))) {
[08:27:24.830]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:24.830]                   ...future.conditions[[length(...future.conditions) + 
[08:27:24.830]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:24.830]                   if (TRUE && !signal) {
[08:27:24.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:24.830]                     {
[08:27:24.830]                       inherits <- base::inherits
[08:27:24.830]                       invokeRestart <- base::invokeRestart
[08:27:24.830]                       is.null <- base::is.null
[08:27:24.830]                       muffled <- FALSE
[08:27:24.830]                       if (inherits(cond, "message")) {
[08:27:24.830]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:24.830]                         if (muffled) 
[08:27:24.830]                           invokeRestart("muffleMessage")
[08:27:24.830]                       }
[08:27:24.830]                       else if (inherits(cond, "warning")) {
[08:27:24.830]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:24.830]                         if (muffled) 
[08:27:24.830]                           invokeRestart("muffleWarning")
[08:27:24.830]                       }
[08:27:24.830]                       else if (inherits(cond, "condition")) {
[08:27:24.830]                         if (!is.null(pattern)) {
[08:27:24.830]                           computeRestarts <- base::computeRestarts
[08:27:24.830]                           grepl <- base::grepl
[08:27:24.830]                           restarts <- computeRestarts(cond)
[08:27:24.830]                           for (restart in restarts) {
[08:27:24.830]                             name <- restart$name
[08:27:24.830]                             if (is.null(name)) 
[08:27:24.830]                               next
[08:27:24.830]                             if (!grepl(pattern, name)) 
[08:27:24.830]                               next
[08:27:24.830]                             invokeRestart(restart)
[08:27:24.830]                             muffled <- TRUE
[08:27:24.830]                             break
[08:27:24.830]                           }
[08:27:24.830]                         }
[08:27:24.830]                       }
[08:27:24.830]                       invisible(muffled)
[08:27:24.830]                     }
[08:27:24.830]                     muffleCondition(cond, pattern = "^muffle")
[08:27:24.830]                   }
[08:27:24.830]                 }
[08:27:24.830]                 else {
[08:27:24.830]                   if (TRUE) {
[08:27:24.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:24.830]                     {
[08:27:24.830]                       inherits <- base::inherits
[08:27:24.830]                       invokeRestart <- base::invokeRestart
[08:27:24.830]                       is.null <- base::is.null
[08:27:24.830]                       muffled <- FALSE
[08:27:24.830]                       if (inherits(cond, "message")) {
[08:27:24.830]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:24.830]                         if (muffled) 
[08:27:24.830]                           invokeRestart("muffleMessage")
[08:27:24.830]                       }
[08:27:24.830]                       else if (inherits(cond, "warning")) {
[08:27:24.830]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:24.830]                         if (muffled) 
[08:27:24.830]                           invokeRestart("muffleWarning")
[08:27:24.830]                       }
[08:27:24.830]                       else if (inherits(cond, "condition")) {
[08:27:24.830]                         if (!is.null(pattern)) {
[08:27:24.830]                           computeRestarts <- base::computeRestarts
[08:27:24.830]                           grepl <- base::grepl
[08:27:24.830]                           restarts <- computeRestarts(cond)
[08:27:24.830]                           for (restart in restarts) {
[08:27:24.830]                             name <- restart$name
[08:27:24.830]                             if (is.null(name)) 
[08:27:24.830]                               next
[08:27:24.830]                             if (!grepl(pattern, name)) 
[08:27:24.830]                               next
[08:27:24.830]                             invokeRestart(restart)
[08:27:24.830]                             muffled <- TRUE
[08:27:24.830]                             break
[08:27:24.830]                           }
[08:27:24.830]                         }
[08:27:24.830]                       }
[08:27:24.830]                       invisible(muffled)
[08:27:24.830]                     }
[08:27:24.830]                     muffleCondition(cond, pattern = "^muffle")
[08:27:24.830]                   }
[08:27:24.830]                 }
[08:27:24.830]             }
[08:27:24.830]         }))
[08:27:24.830]     }, error = function(ex) {
[08:27:24.830]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:24.830]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:24.830]                 ...future.rng), started = ...future.startTime, 
[08:27:24.830]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:24.830]             version = "1.8"), class = "FutureResult")
[08:27:24.830]     }, finally = {
[08:27:24.830]         if (!identical(...future.workdir, getwd())) 
[08:27:24.830]             setwd(...future.workdir)
[08:27:24.830]         {
[08:27:24.830]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:24.830]                 ...future.oldOptions$nwarnings <- NULL
[08:27:24.830]             }
[08:27:24.830]             base::options(...future.oldOptions)
[08:27:24.830]             if (.Platform$OS.type == "windows") {
[08:27:24.830]                 old_names <- names(...future.oldEnvVars)
[08:27:24.830]                 envs <- base::Sys.getenv()
[08:27:24.830]                 names <- names(envs)
[08:27:24.830]                 common <- intersect(names, old_names)
[08:27:24.830]                 added <- setdiff(names, old_names)
[08:27:24.830]                 removed <- setdiff(old_names, names)
[08:27:24.830]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:24.830]                   envs[common]]
[08:27:24.830]                 NAMES <- toupper(changed)
[08:27:24.830]                 args <- list()
[08:27:24.830]                 for (kk in seq_along(NAMES)) {
[08:27:24.830]                   name <- changed[[kk]]
[08:27:24.830]                   NAME <- NAMES[[kk]]
[08:27:24.830]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:24.830]                     next
[08:27:24.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:24.830]                 }
[08:27:24.830]                 NAMES <- toupper(added)
[08:27:24.830]                 for (kk in seq_along(NAMES)) {
[08:27:24.830]                   name <- added[[kk]]
[08:27:24.830]                   NAME <- NAMES[[kk]]
[08:27:24.830]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:24.830]                     next
[08:27:24.830]                   args[[name]] <- ""
[08:27:24.830]                 }
[08:27:24.830]                 NAMES <- toupper(removed)
[08:27:24.830]                 for (kk in seq_along(NAMES)) {
[08:27:24.830]                   name <- removed[[kk]]
[08:27:24.830]                   NAME <- NAMES[[kk]]
[08:27:24.830]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:24.830]                     next
[08:27:24.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:24.830]                 }
[08:27:24.830]                 if (length(args) > 0) 
[08:27:24.830]                   base::do.call(base::Sys.setenv, args = args)
[08:27:24.830]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:24.830]             }
[08:27:24.830]             else {
[08:27:24.830]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:24.830]             }
[08:27:24.830]             {
[08:27:24.830]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:24.830]                   0L) {
[08:27:24.830]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:24.830]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:24.830]                   base::options(opts)
[08:27:24.830]                 }
[08:27:24.830]                 {
[08:27:24.830]                   {
[08:27:24.830]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:24.830]                     NULL
[08:27:24.830]                   }
[08:27:24.830]                   options(future.plan = NULL)
[08:27:24.830]                   if (is.na(NA_character_)) 
[08:27:24.830]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:24.830]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:24.830]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:24.830]                     .init = FALSE)
[08:27:24.830]                 }
[08:27:24.830]             }
[08:27:24.830]         }
[08:27:24.830]     })
[08:27:24.830]     if (TRUE) {
[08:27:24.830]         base::sink(type = "output", split = FALSE)
[08:27:24.830]         if (TRUE) {
[08:27:24.830]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:24.830]         }
[08:27:24.830]         else {
[08:27:24.830]             ...future.result["stdout"] <- base::list(NULL)
[08:27:24.830]         }
[08:27:24.830]         base::close(...future.stdout)
[08:27:24.830]         ...future.stdout <- NULL
[08:27:24.830]     }
[08:27:24.830]     ...future.result$conditions <- ...future.conditions
[08:27:24.830]     ...future.result$finished <- base::Sys.time()
[08:27:24.830]     ...future.result
[08:27:24.830] }
[08:27:24.832] Poll #1 (0): usedNodes() = 2, workers = 2
[08:27:24.857] receiveMessageFromWorker() for ClusterFuture ...
[08:27:24.857] - Validating connection of MultisessionFuture
[08:27:24.858] - received message: FutureResult
[08:27:24.858] - Received FutureResult
[08:27:24.858] - Erased future from FutureRegistry
[08:27:24.858] result() for ClusterFuture ...
[08:27:24.858] - result already collected: FutureResult
[08:27:24.858] result() for ClusterFuture ... done
[08:27:24.858] signalConditions() ...
[08:27:24.858]  - include = ‘immediateCondition’
[08:27:24.858]  - exclude = 
[08:27:24.858]  - resignal = FALSE
[08:27:24.858]  - Number of conditions: 2
[08:27:24.859] signalConditions() ... done
[08:27:24.859] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:24.859] result() for ClusterFuture ...
[08:27:24.859] - result already collected: FutureResult
[08:27:24.859] result() for ClusterFuture ... done
[08:27:24.859] result() for ClusterFuture ...
[08:27:24.859] - result already collected: FutureResult
[08:27:24.859] result() for ClusterFuture ... done
[08:27:24.859] signalConditions() ...
[08:27:24.859]  - include = ‘immediateCondition’
[08:27:24.859]  - exclude = 
[08:27:24.859]  - resignal = FALSE
[08:27:24.860]  - Number of conditions: 2
[08:27:24.860] signalConditions() ... done
[08:27:24.860] Exporting 4 global objects (57.67 KiB) to cluster node #2 ...
[08:27:24.861] Exporting ‘ii’ (35 bytes) to cluster node #2 ...
[08:27:24.861] Exporting ‘ii’ (35 bytes) to cluster node #2 ... DONE
[08:27:24.861] Exporting ‘n’ (35 bytes) to cluster node #2 ...
[08:27:24.862] Exporting ‘n’ (35 bytes) to cluster node #2 ... DONE
[08:27:24.862] Exporting ‘C’ (10.00 KiB) to cluster node #2 ...
[08:27:24.903] Exporting ‘C’ (10.00 KiB) to cluster node #2 ... DONE
[08:27:24.903] Exporting ‘delay’ (47.33 KiB) to cluster node #2 ...
[08:27:24.945] Exporting ‘delay’ (47.33 KiB) to cluster node #2 ... DONE
[08:27:24.945] Exporting 4 global objects (57.67 KiB) to cluster node #2 ... DONE
[08:27:24.946] MultisessionFuture started
[08:27:24.946] - Launch lazy future ... done
[08:27:24.946] run() for ‘MultisessionFuture’ ... done
[08:27:24.946] - run() ... done
[08:27:24.946] - resolved() ...
[08:27:24.957] - resolved: FALSE
[08:27:24.957] - resolved() ... done
[08:27:24.957] resolved() for ‘MultisessionFuture’ ... done
Plotting tile #1 of 4 ...
[08:27:24.958] result() for ClusterFuture ...
[08:27:24.958] - result already collected: FutureResult
[08:27:24.958] result() for ClusterFuture ... done
[08:27:24.958] result() for ClusterFuture ...
[08:27:24.958] - result already collected: FutureResult
[08:27:24.958] result() for ClusterFuture ... done
[08:27:24.958] signalConditions() ...
[08:27:24.958]  - include = ‘immediateCondition’
[08:27:24.958]  - exclude = 
[08:27:24.958]  - resignal = FALSE
[08:27:24.959]  - Number of conditions: 2
[08:27:24.959] signalConditions() ... done
[08:27:24.959] Future state: ‘finished’
[08:27:24.959] result() for ClusterFuture ...
[08:27:24.959] - result already collected: FutureResult
[08:27:24.959] result() for ClusterFuture ... done
[08:27:24.959] signalConditions() ...
[08:27:24.959]  - include = ‘condition’
[08:27:24.959]  - exclude = ‘immediateCondition’
[08:27:24.959]  - resignal = TRUE
[08:27:24.959]  - Number of conditions: 2
[08:27:24.959]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #1 of 4 ...[08:27:24.960]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[08:27:24.960] signalConditions() ... done
Plotting tile #2 of 4 ...
[08:27:24.961] result() for ClusterFuture ...
[08:27:24.961] - result already collected: FutureResult
[08:27:24.961] result() for ClusterFuture ... done
[08:27:24.961] result() for ClusterFuture ...
[08:27:24.961] - result already collected: FutureResult
[08:27:24.961] result() for ClusterFuture ... done
[08:27:24.961] signalConditions() ...
[08:27:24.961]  - include = ‘immediateCondition’
[08:27:24.961]  - exclude = 
[08:27:24.961]  - resignal = FALSE
[08:27:24.961]  - Number of conditions: 2
[08:27:24.961] signalConditions() ... done
[08:27:24.962] Future state: ‘finished’
[08:27:24.962] result() for ClusterFuture ...
[08:27:24.962] - result already collected: FutureResult
[08:27:24.962] result() for ClusterFuture ... done
[08:27:24.962] signalConditions() ...
[08:27:24.962]  - include = ‘condition’
[08:27:24.962]  - exclude = ‘immediateCondition’
[08:27:24.962]  - resignal = TRUE
[08:27:24.962]  - Number of conditions: 2
[08:27:24.962]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #2 of 4 ...[08:27:24.962]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[08:27:24.963] signalConditions() ... done
[08:27:24.964] receiveMessageFromWorker() for ClusterFuture ...
[08:27:24.964] - Validating connection of MultisessionFuture
[08:27:24.964] - received message: FutureResult
[08:27:24.964] - Received FutureResult
[08:27:24.964] - Erased future from FutureRegistry
[08:27:24.964] result() for ClusterFuture ...
[08:27:24.965] - result already collected: FutureResult
[08:27:24.965] result() for ClusterFuture ... done
[08:27:24.965] signalConditions() ...
[08:27:24.965]  - include = ‘immediateCondition’
[08:27:24.965]  - exclude = 
[08:27:24.965]  - resignal = FALSE
[08:27:24.965]  - Number of conditions: 2
[08:27:24.965] signalConditions() ... done
[08:27:24.965] receiveMessageFromWorker() for ClusterFuture ... done
Plotting tile #3 of 4 ...
[08:27:24.965] result() for ClusterFuture ...
[08:27:24.965] - result already collected: FutureResult
[08:27:24.966] result() for ClusterFuture ... done
[08:27:24.966] result() for ClusterFuture ...
[08:27:24.966] - result already collected: FutureResult
[08:27:24.966] result() for ClusterFuture ... done
[08:27:24.966] signalConditions() ...
[08:27:24.966]  - include = ‘immediateCondition’
[08:27:24.966]  - exclude = 
[08:27:24.966]  - resignal = FALSE
[08:27:24.966]  - Number of conditions: 2
[08:27:24.966] signalConditions() ... done
[08:27:24.966] Future state: ‘finished’
[08:27:24.966] result() for ClusterFuture ...
[08:27:24.966] - result already collected: FutureResult
[08:27:24.967] result() for ClusterFuture ... done
[08:27:24.967] signalConditions() ...
[08:27:24.967]  - include = ‘condition’
[08:27:24.967]  - exclude = ‘immediateCondition’
[08:27:24.967]  - resignal = TRUE
[08:27:24.967]  - Number of conditions: 2
[08:27:24.967]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #3 of 4 ...[08:27:24.967]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[08:27:24.967] signalConditions() ... done
[08:27:25.006] receiveMessageFromWorker() for ClusterFuture ...
[08:27:25.006] - Validating connection of MultisessionFuture
[08:27:25.007] - received message: FutureResult
[08:27:25.007] - Received FutureResult
[08:27:25.007] - Erased future from FutureRegistry
[08:27:25.007] result() for ClusterFuture ...
[08:27:25.007] - result already collected: FutureResult
[08:27:25.007] result() for ClusterFuture ... done
[08:27:25.007] signalConditions() ...
[08:27:25.007]  - include = ‘immediateCondition’
[08:27:25.007]  - exclude = 
[08:27:25.007]  - resignal = FALSE
[08:27:25.008]  - Number of conditions: 2
[08:27:25.008] signalConditions() ... done
[08:27:25.008] receiveMessageFromWorker() for ClusterFuture ... done
Plotting tile #4 of 4 ...
[08:27:25.008] result() for ClusterFuture ...
[08:27:25.008] - result already collected: FutureResult
[08:27:25.008] result() for ClusterFuture ... done
[08:27:25.008] result() for ClusterFuture ...
[08:27:25.008] - result already collected: FutureResult
[08:27:25.008] result() for ClusterFuture ... done
[08:27:25.008] signalConditions() ...
[08:27:25.008]  - include = ‘immediateCondition’
[08:27:25.009]  - exclude = 
[08:27:25.009]  - resignal = FALSE
[08:27:25.009]  - Number of conditions: 2
[08:27:25.009] signalConditions() ... done
[08:27:25.009] Future state: ‘finished’
[08:27:25.009] result() for ClusterFuture ...
[08:27:25.009] - result already collected: FutureResult
[08:27:25.009] result() for ClusterFuture ... done
[08:27:25.009] signalConditions() ...
[08:27:25.009]  - include = ‘condition’
[08:27:25.009]  - exclude = ‘immediateCondition’
[08:27:25.010]  - resignal = TRUE
[08:27:25.010]  - Number of conditions: 2
[08:27:25.010]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
Calculating tile #4 of 4 ...[08:27:25.010]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
 done
[08:27:25.010] signalConditions() ... done

> close.screen()
 [1]  1  2  3  4  5  6  7  8  9 10 11 12

> message("SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).\n")
SUGGESTION: Try to rerun this demo after changing strategy for how futures are resolved, e.g. plan(multisession).

- plan('multisession') ... DONE
Testing with 2 cores ... DONE
> message("*** Mandelbrot demo of the 'future' package ... DONE")
*** Mandelbrot demo of the 'future' package ... DONE
> 
> message("*** Demos ... DONE")
*** Demos ... DONE
> 
> source("incl/end.R")
[08:27:25.012] plan(): Setting new future strategy stack:
[08:27:25.012] List of future strategies:
[08:27:25.012] 1. sequential:
[08:27:25.012]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:25.012]    - tweaked: FALSE
[08:27:25.012]    - call: future::plan("sequential")
[08:27:25.013] plan(): nbrOfWorkers() = 1
> 
