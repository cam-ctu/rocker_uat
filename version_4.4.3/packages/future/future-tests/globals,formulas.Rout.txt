
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[08:27:57.300] plan(): Setting new future strategy stack:
[08:27:57.301] List of future strategies:
[08:27:57.301] 1. sequential:
[08:27:57.301]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.301]    - tweaked: FALSE
[08:27:57.301]    - call: future::plan("sequential")
[08:27:57.314] plan(): nbrOfWorkers() = 1
> 
> library("datasets") ## cars data set
> library("stats")    ## lm(), poly(), xtabs()
> 
> message("*** Globals - formulas ...")
*** Globals - formulas ...
> 
> ## (i) lm(<formula>):
> ## From example("lm", package = "stats")
> ctl <- c(4.17, 5.58, 5.18, 6.11, 4.50, 4.61, 5.17, 4.53, 5.33, 5.14)
> trt <- c(4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 4.89, 4.32, 4.69)
> group <- gl(2, 10, 20, labels = c("Ctl", "Trt"))
> weight <- c(ctl, trt)
> ctl <- trt <- NULL
> ## Truth:
> fit_i <- lm(weight ~ group - 1)
> print(fit_i)

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

> 
> ## (ii) xtabs(~ x):
> x <- c(1, 1, 2, 2, 2)
> ## Truth:
> tbl_ii <- xtabs(~ x)
> print(tbl_ii)
x
1 2 
2 3 
> 
> ## (iii) lm(<formula>, data = cars):
> exprs <- list(
+   # "remove-intercept-term" form of no-intercept
+   a = substitute({ lm(dist ~ . -1, data = cars) }),
+   # "make-intercept-zero" form of no-intercept
+   b = substitute({ lm(dist ~ . +0, data = cars) }),
+   # doesn't do what we want here
+   c = substitute({ lm(dist ~ speed + speed ^ 2, data = cars) }),
+   # gets us a quadratic term
+   d = substitute({ lm(dist ~ speed + I(speed ^ 2), data = cars) }),
+   # avoid potential multicollinearity
+   e = substitute({ lm(dist ~ poly(speed, 2), data = cars) })
+ )
> 
> ## (iv) Globals - map(x, ~ expr):
> ## A fake purrr::map() function with limited functionality
> map <- function(.x, .f, ...) {
+   if (inherits(.f, "formula")) {
+     expr <- .f[[-1]]
+     .f <- eval(bquote(function(...) {
+       .(expr)
+     }))
+   }
+   eval(lapply(.x, FUN = .f, ...))
+ }
> 
> inner_function <- function(x) { x + 1 }
> 
> outer_function <- function(x) {
+   map(1:2, ~ inner_function(.x))
+ }
> 
> y_iv <- outer_function(1L)
> str(y_iv)
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
> 
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     message("- lm(<formula>) ...")
+     
+     ## Explicit future
+     f <- future({ lm(weight ~ group - 1) })
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Explicit future (lazy)
+     f <- future({ lm(weight ~ group - 1) }, lazy = TRUE)
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment
+     fit %<-% { lm(weight ~ group - 1) }
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (non-lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% FALSE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% TRUE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     message("- Globals - one-side formulas, e.g. xtabs(~ x) ...")
+     ## Explicit future
+     f <- future({ xtabs(~ x) })
+     tbl <- value(f)
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     ## Future assignment
+     tbl %<-% { xtabs(~ x) }
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     message("- Globals - lm(<formula>, data = cars) ...")
+     for (kk in seq_along(exprs)) {
+       expr <- exprs[[kk]]
+       name <- names(exprs)[kk]
+       message(sprintf("- Globals - lm(<formula #%d (%s)>, data = cars) ...",
+                       kk, sQuote(name)))
+     
+       fit_iii <- eval(expr)
+       print(fit_iii)
+     
+       f <- future(expr, substitute = FALSE)
+       fit <- value(f)
+       print(fit)
+     
+       stopifnot(all.equal(fit, fit_iii))
+     } ## for (kk ...)
+ 
+     message("- Globals - map(x, ~ expr) ...")
+     f <- future({ outer_function(1L) })
+     y <- value(f)
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+ 
+     y %<-% { outer_function(1L) }
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+   } ## for (strategy ...)
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[08:27:57.372] plan(): Setting new future strategy stack:
[08:27:57.373] List of future strategies:
[08:27:57.373] 1. sequential:
[08:27:57.373]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.373]    - tweaked: FALSE
[08:27:57.373]    - call: plan(strategy)
[08:27:57.385] plan(): nbrOfWorkers() = 1
- lm(<formula>) ...
[08:27:57.386] getGlobalsAndPackages() ...
[08:27:57.386] Searching for globals...
[08:27:57.392] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[08:27:57.392] Searching for globals ... DONE
[08:27:57.392] Resolving globals: FALSE
[08:27:57.393] The total size of the 2 globals is 401 bytes (401 bytes)
[08:27:57.393] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[08:27:57.394] - globals: [2] ‘weight’, ‘group’
[08:27:57.394] - packages: [1] ‘stats’
[08:27:57.394] getGlobalsAndPackages() ... DONE
[08:27:57.394] run() for ‘Future’ ...
[08:27:57.394] - state: ‘created’
[08:27:57.395] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:57.395] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:57.395] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:57.395]   - Field: ‘label’
[08:27:57.395]   - Field: ‘local’
[08:27:57.395]   - Field: ‘owner’
[08:27:57.395]   - Field: ‘envir’
[08:27:57.396]   - Field: ‘packages’
[08:27:57.396]   - Field: ‘gc’
[08:27:57.396]   - Field: ‘conditions’
[08:27:57.396]   - Field: ‘expr’
[08:27:57.396]   - Field: ‘uuid’
[08:27:57.396]   - Field: ‘seed’
[08:27:57.396]   - Field: ‘version’
[08:27:57.396]   - Field: ‘result’
[08:27:57.396]   - Field: ‘asynchronous’
[08:27:57.396]   - Field: ‘calls’
[08:27:57.396]   - Field: ‘globals’
[08:27:57.396]   - Field: ‘stdout’
[08:27:57.396]   - Field: ‘earlySignal’
[08:27:57.397]   - Field: ‘lazy’
[08:27:57.397]   - Field: ‘state’
[08:27:57.397] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:57.397] - Launch lazy future ...
[08:27:57.397] Packages needed by the future expression (n = 1): ‘stats’
[08:27:57.398] Packages needed by future strategies (n = 0): <none>
[08:27:57.398] {
[08:27:57.398]     {
[08:27:57.398]         {
[08:27:57.398]             ...future.startTime <- base::Sys.time()
[08:27:57.398]             {
[08:27:57.398]                 {
[08:27:57.398]                   {
[08:27:57.398]                     {
[08:27:57.398]                       base::local({
[08:27:57.398]                         has_future <- base::requireNamespace("future", 
[08:27:57.398]                           quietly = TRUE)
[08:27:57.398]                         if (has_future) {
[08:27:57.398]                           ns <- base::getNamespace("future")
[08:27:57.398]                           version <- ns[[".package"]][["version"]]
[08:27:57.398]                           if (is.null(version)) 
[08:27:57.398]                             version <- utils::packageVersion("future")
[08:27:57.398]                         }
[08:27:57.398]                         else {
[08:27:57.398]                           version <- NULL
[08:27:57.398]                         }
[08:27:57.398]                         if (!has_future || version < "1.8.0") {
[08:27:57.398]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.398]                             "", base::R.version$version.string), 
[08:27:57.398]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:57.398]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:57.398]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.398]                               "release", "version")], collapse = " "), 
[08:27:57.398]                             hostname = base::Sys.info()[["nodename"]])
[08:27:57.398]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.398]                             info)
[08:27:57.398]                           info <- base::paste(info, collapse = "; ")
[08:27:57.398]                           if (!has_future) {
[08:27:57.398]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.398]                               info)
[08:27:57.398]                           }
[08:27:57.398]                           else {
[08:27:57.398]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.398]                               info, version)
[08:27:57.398]                           }
[08:27:57.398]                           base::stop(msg)
[08:27:57.398]                         }
[08:27:57.398]                       })
[08:27:57.398]                     }
[08:27:57.398]                     base::local({
[08:27:57.398]                       for (pkg in "stats") {
[08:27:57.398]                         base::loadNamespace(pkg)
[08:27:57.398]                         base::library(pkg, character.only = TRUE)
[08:27:57.398]                       }
[08:27:57.398]                     })
[08:27:57.398]                   }
[08:27:57.398]                   ...future.strategy.old <- future::plan("list")
[08:27:57.398]                   options(future.plan = NULL)
[08:27:57.398]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.398]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.398]                 }
[08:27:57.398]                 ...future.workdir <- getwd()
[08:27:57.398]             }
[08:27:57.398]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.398]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.398]         }
[08:27:57.398]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.398]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.398]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.398]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.398]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.398]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.398]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.398]             base::names(...future.oldOptions))
[08:27:57.398]     }
[08:27:57.398]     if (FALSE) {
[08:27:57.398]     }
[08:27:57.398]     else {
[08:27:57.398]         if (TRUE) {
[08:27:57.398]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.398]                 open = "w")
[08:27:57.398]         }
[08:27:57.398]         else {
[08:27:57.398]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.398]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.398]         }
[08:27:57.398]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.398]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.398]             base::sink(type = "output", split = FALSE)
[08:27:57.398]             base::close(...future.stdout)
[08:27:57.398]         }, add = TRUE)
[08:27:57.398]     }
[08:27:57.398]     ...future.frame <- base::sys.nframe()
[08:27:57.398]     ...future.conditions <- base::list()
[08:27:57.398]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.398]     if (FALSE) {
[08:27:57.398]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.398]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.398]     }
[08:27:57.398]     ...future.result <- base::tryCatch({
[08:27:57.398]         base::withCallingHandlers({
[08:27:57.398]             ...future.value <- base::withVisible(base::local({
[08:27:57.398]                 lm(weight ~ group - 1)
[08:27:57.398]             }))
[08:27:57.398]             future::FutureResult(value = ...future.value$value, 
[08:27:57.398]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.398]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.398]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.398]                     ...future.globalenv.names))
[08:27:57.398]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.398]         }, condition = base::local({
[08:27:57.398]             c <- base::c
[08:27:57.398]             inherits <- base::inherits
[08:27:57.398]             invokeRestart <- base::invokeRestart
[08:27:57.398]             length <- base::length
[08:27:57.398]             list <- base::list
[08:27:57.398]             seq.int <- base::seq.int
[08:27:57.398]             signalCondition <- base::signalCondition
[08:27:57.398]             sys.calls <- base::sys.calls
[08:27:57.398]             `[[` <- base::`[[`
[08:27:57.398]             `+` <- base::`+`
[08:27:57.398]             `<<-` <- base::`<<-`
[08:27:57.398]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.398]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.398]                   3L)]
[08:27:57.398]             }
[08:27:57.398]             function(cond) {
[08:27:57.398]                 is_error <- inherits(cond, "error")
[08:27:57.398]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.398]                   NULL)
[08:27:57.398]                 if (is_error) {
[08:27:57.398]                   sessionInformation <- function() {
[08:27:57.398]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.398]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.398]                       search = base::search(), system = base::Sys.info())
[08:27:57.398]                   }
[08:27:57.398]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.398]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.398]                     cond$call), session = sessionInformation(), 
[08:27:57.398]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.398]                   signalCondition(cond)
[08:27:57.398]                 }
[08:27:57.398]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.398]                 "immediateCondition"))) {
[08:27:57.398]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.398]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.398]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.398]                   if (TRUE && !signal) {
[08:27:57.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.398]                     {
[08:27:57.398]                       inherits <- base::inherits
[08:27:57.398]                       invokeRestart <- base::invokeRestart
[08:27:57.398]                       is.null <- base::is.null
[08:27:57.398]                       muffled <- FALSE
[08:27:57.398]                       if (inherits(cond, "message")) {
[08:27:57.398]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.398]                         if (muffled) 
[08:27:57.398]                           invokeRestart("muffleMessage")
[08:27:57.398]                       }
[08:27:57.398]                       else if (inherits(cond, "warning")) {
[08:27:57.398]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.398]                         if (muffled) 
[08:27:57.398]                           invokeRestart("muffleWarning")
[08:27:57.398]                       }
[08:27:57.398]                       else if (inherits(cond, "condition")) {
[08:27:57.398]                         if (!is.null(pattern)) {
[08:27:57.398]                           computeRestarts <- base::computeRestarts
[08:27:57.398]                           grepl <- base::grepl
[08:27:57.398]                           restarts <- computeRestarts(cond)
[08:27:57.398]                           for (restart in restarts) {
[08:27:57.398]                             name <- restart$name
[08:27:57.398]                             if (is.null(name)) 
[08:27:57.398]                               next
[08:27:57.398]                             if (!grepl(pattern, name)) 
[08:27:57.398]                               next
[08:27:57.398]                             invokeRestart(restart)
[08:27:57.398]                             muffled <- TRUE
[08:27:57.398]                             break
[08:27:57.398]                           }
[08:27:57.398]                         }
[08:27:57.398]                       }
[08:27:57.398]                       invisible(muffled)
[08:27:57.398]                     }
[08:27:57.398]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.398]                   }
[08:27:57.398]                 }
[08:27:57.398]                 else {
[08:27:57.398]                   if (TRUE) {
[08:27:57.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.398]                     {
[08:27:57.398]                       inherits <- base::inherits
[08:27:57.398]                       invokeRestart <- base::invokeRestart
[08:27:57.398]                       is.null <- base::is.null
[08:27:57.398]                       muffled <- FALSE
[08:27:57.398]                       if (inherits(cond, "message")) {
[08:27:57.398]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.398]                         if (muffled) 
[08:27:57.398]                           invokeRestart("muffleMessage")
[08:27:57.398]                       }
[08:27:57.398]                       else if (inherits(cond, "warning")) {
[08:27:57.398]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.398]                         if (muffled) 
[08:27:57.398]                           invokeRestart("muffleWarning")
[08:27:57.398]                       }
[08:27:57.398]                       else if (inherits(cond, "condition")) {
[08:27:57.398]                         if (!is.null(pattern)) {
[08:27:57.398]                           computeRestarts <- base::computeRestarts
[08:27:57.398]                           grepl <- base::grepl
[08:27:57.398]                           restarts <- computeRestarts(cond)
[08:27:57.398]                           for (restart in restarts) {
[08:27:57.398]                             name <- restart$name
[08:27:57.398]                             if (is.null(name)) 
[08:27:57.398]                               next
[08:27:57.398]                             if (!grepl(pattern, name)) 
[08:27:57.398]                               next
[08:27:57.398]                             invokeRestart(restart)
[08:27:57.398]                             muffled <- TRUE
[08:27:57.398]                             break
[08:27:57.398]                           }
[08:27:57.398]                         }
[08:27:57.398]                       }
[08:27:57.398]                       invisible(muffled)
[08:27:57.398]                     }
[08:27:57.398]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.398]                   }
[08:27:57.398]                 }
[08:27:57.398]             }
[08:27:57.398]         }))
[08:27:57.398]     }, error = function(ex) {
[08:27:57.398]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.398]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.398]                 ...future.rng), started = ...future.startTime, 
[08:27:57.398]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.398]             version = "1.8"), class = "FutureResult")
[08:27:57.398]     }, finally = {
[08:27:57.398]         if (!identical(...future.workdir, getwd())) 
[08:27:57.398]             setwd(...future.workdir)
[08:27:57.398]         {
[08:27:57.398]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.398]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.398]             }
[08:27:57.398]             base::options(...future.oldOptions)
[08:27:57.398]             if (.Platform$OS.type == "windows") {
[08:27:57.398]                 old_names <- names(...future.oldEnvVars)
[08:27:57.398]                 envs <- base::Sys.getenv()
[08:27:57.398]                 names <- names(envs)
[08:27:57.398]                 common <- intersect(names, old_names)
[08:27:57.398]                 added <- setdiff(names, old_names)
[08:27:57.398]                 removed <- setdiff(old_names, names)
[08:27:57.398]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.398]                   envs[common]]
[08:27:57.398]                 NAMES <- toupper(changed)
[08:27:57.398]                 args <- list()
[08:27:57.398]                 for (kk in seq_along(NAMES)) {
[08:27:57.398]                   name <- changed[[kk]]
[08:27:57.398]                   NAME <- NAMES[[kk]]
[08:27:57.398]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.398]                     next
[08:27:57.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.398]                 }
[08:27:57.398]                 NAMES <- toupper(added)
[08:27:57.398]                 for (kk in seq_along(NAMES)) {
[08:27:57.398]                   name <- added[[kk]]
[08:27:57.398]                   NAME <- NAMES[[kk]]
[08:27:57.398]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.398]                     next
[08:27:57.398]                   args[[name]] <- ""
[08:27:57.398]                 }
[08:27:57.398]                 NAMES <- toupper(removed)
[08:27:57.398]                 for (kk in seq_along(NAMES)) {
[08:27:57.398]                   name <- removed[[kk]]
[08:27:57.398]                   NAME <- NAMES[[kk]]
[08:27:57.398]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.398]                     next
[08:27:57.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.398]                 }
[08:27:57.398]                 if (length(args) > 0) 
[08:27:57.398]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.398]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.398]             }
[08:27:57.398]             else {
[08:27:57.398]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.398]             }
[08:27:57.398]             {
[08:27:57.398]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.398]                   0L) {
[08:27:57.398]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.398]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.398]                   base::options(opts)
[08:27:57.398]                 }
[08:27:57.398]                 {
[08:27:57.398]                   {
[08:27:57.398]                     NULL
[08:27:57.398]                     RNGkind("Mersenne-Twister")
[08:27:57.398]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:57.398]                       inherits = FALSE)
[08:27:57.398]                   }
[08:27:57.398]                   options(future.plan = NULL)
[08:27:57.398]                   if (is.na(NA_character_)) 
[08:27:57.398]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.398]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.398]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.398]                     .init = FALSE)
[08:27:57.398]                 }
[08:27:57.398]             }
[08:27:57.398]         }
[08:27:57.398]     })
[08:27:57.398]     if (TRUE) {
[08:27:57.398]         base::sink(type = "output", split = FALSE)
[08:27:57.398]         if (TRUE) {
[08:27:57.398]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.398]         }
[08:27:57.398]         else {
[08:27:57.398]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.398]         }
[08:27:57.398]         base::close(...future.stdout)
[08:27:57.398]         ...future.stdout <- NULL
[08:27:57.398]     }
[08:27:57.398]     ...future.result$conditions <- ...future.conditions
[08:27:57.398]     ...future.result$finished <- base::Sys.time()
[08:27:57.398]     ...future.result
[08:27:57.398] }
[08:27:57.400] assign_globals() ...
[08:27:57.400] List of 2
[08:27:57.400]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[08:27:57.400]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[08:27:57.400]  - attr(*, "where")=List of 2
[08:27:57.400]   ..$ weight:<environment: R_EmptyEnv> 
[08:27:57.400]   ..$ group :<environment: R_EmptyEnv> 
[08:27:57.400]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:57.400]  - attr(*, "resolved")= logi FALSE
[08:27:57.400]  - attr(*, "total_size")= num 401
[08:27:57.400]  - attr(*, "already-done")= logi TRUE
[08:27:57.403] - copied ‘weight’ to environment
[08:27:57.404] - copied ‘group’ to environment
[08:27:57.404] assign_globals() ... done
[08:27:57.404] plan(): Setting new future strategy stack:
[08:27:57.404] List of future strategies:
[08:27:57.404] 1. sequential:
[08:27:57.404]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.404]    - tweaked: FALSE
[08:27:57.404]    - call: NULL
[08:27:57.405] plan(): nbrOfWorkers() = 1
[08:27:57.406] plan(): Setting new future strategy stack:
[08:27:57.406] List of future strategies:
[08:27:57.406] 1. sequential:
[08:27:57.406]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.406]    - tweaked: FALSE
[08:27:57.406]    - call: plan(strategy)
[08:27:57.407] plan(): nbrOfWorkers() = 1
[08:27:57.407] SequentialFuture started (and completed)
[08:27:57.407] - Launch lazy future ... done
[08:27:57.408] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[08:27:57.412] getGlobalsAndPackages() ...
[08:27:57.412] Searching for globals...
[08:27:57.413] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[08:27:57.414] Searching for globals ... DONE
[08:27:57.414] Resolving globals: FALSE
[08:27:57.414] The total size of the 2 globals is 401 bytes (401 bytes)
[08:27:57.414] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[08:27:57.415] - globals: [2] ‘weight’, ‘group’
[08:27:57.415] - packages: [1] ‘stats’
[08:27:57.415] getGlobalsAndPackages() ... DONE
[08:27:57.415] run() for ‘Future’ ...
[08:27:57.415] - state: ‘created’
[08:27:57.415] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:57.415] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:57.416] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:57.416]   - Field: ‘label’
[08:27:57.416]   - Field: ‘local’
[08:27:57.416]   - Field: ‘owner’
[08:27:57.416]   - Field: ‘envir’
[08:27:57.416]   - Field: ‘packages’
[08:27:57.416]   - Field: ‘gc’
[08:27:57.416]   - Field: ‘conditions’
[08:27:57.416]   - Field: ‘expr’
[08:27:57.416]   - Field: ‘uuid’
[08:27:57.416]   - Field: ‘seed’
[08:27:57.417]   - Field: ‘version’
[08:27:57.417]   - Field: ‘result’
[08:27:57.417]   - Field: ‘asynchronous’
[08:27:57.417]   - Field: ‘calls’
[08:27:57.417]   - Field: ‘globals’
[08:27:57.417]   - Field: ‘stdout’
[08:27:57.417]   - Field: ‘earlySignal’
[08:27:57.417]   - Field: ‘lazy’
[08:27:57.417]   - Field: ‘state’
[08:27:57.417] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:57.417] - Launch lazy future ...
[08:27:57.418] Packages needed by the future expression (n = 1): ‘stats’
[08:27:57.418] Packages needed by future strategies (n = 0): <none>
[08:27:57.418] {
[08:27:57.418]     {
[08:27:57.418]         {
[08:27:57.418]             ...future.startTime <- base::Sys.time()
[08:27:57.418]             {
[08:27:57.418]                 {
[08:27:57.418]                   {
[08:27:57.418]                     {
[08:27:57.418]                       base::local({
[08:27:57.418]                         has_future <- base::requireNamespace("future", 
[08:27:57.418]                           quietly = TRUE)
[08:27:57.418]                         if (has_future) {
[08:27:57.418]                           ns <- base::getNamespace("future")
[08:27:57.418]                           version <- ns[[".package"]][["version"]]
[08:27:57.418]                           if (is.null(version)) 
[08:27:57.418]                             version <- utils::packageVersion("future")
[08:27:57.418]                         }
[08:27:57.418]                         else {
[08:27:57.418]                           version <- NULL
[08:27:57.418]                         }
[08:27:57.418]                         if (!has_future || version < "1.8.0") {
[08:27:57.418]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.418]                             "", base::R.version$version.string), 
[08:27:57.418]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:57.418]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:57.418]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.418]                               "release", "version")], collapse = " "), 
[08:27:57.418]                             hostname = base::Sys.info()[["nodename"]])
[08:27:57.418]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.418]                             info)
[08:27:57.418]                           info <- base::paste(info, collapse = "; ")
[08:27:57.418]                           if (!has_future) {
[08:27:57.418]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.418]                               info)
[08:27:57.418]                           }
[08:27:57.418]                           else {
[08:27:57.418]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.418]                               info, version)
[08:27:57.418]                           }
[08:27:57.418]                           base::stop(msg)
[08:27:57.418]                         }
[08:27:57.418]                       })
[08:27:57.418]                     }
[08:27:57.418]                     base::local({
[08:27:57.418]                       for (pkg in "stats") {
[08:27:57.418]                         base::loadNamespace(pkg)
[08:27:57.418]                         base::library(pkg, character.only = TRUE)
[08:27:57.418]                       }
[08:27:57.418]                     })
[08:27:57.418]                   }
[08:27:57.418]                   ...future.strategy.old <- future::plan("list")
[08:27:57.418]                   options(future.plan = NULL)
[08:27:57.418]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.418]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.418]                 }
[08:27:57.418]                 ...future.workdir <- getwd()
[08:27:57.418]             }
[08:27:57.418]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.418]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.418]         }
[08:27:57.418]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.418]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.418]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.418]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.418]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.418]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.418]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.418]             base::names(...future.oldOptions))
[08:27:57.418]     }
[08:27:57.418]     if (FALSE) {
[08:27:57.418]     }
[08:27:57.418]     else {
[08:27:57.418]         if (TRUE) {
[08:27:57.418]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.418]                 open = "w")
[08:27:57.418]         }
[08:27:57.418]         else {
[08:27:57.418]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.418]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.418]         }
[08:27:57.418]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.418]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.418]             base::sink(type = "output", split = FALSE)
[08:27:57.418]             base::close(...future.stdout)
[08:27:57.418]         }, add = TRUE)
[08:27:57.418]     }
[08:27:57.418]     ...future.frame <- base::sys.nframe()
[08:27:57.418]     ...future.conditions <- base::list()
[08:27:57.418]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.418]     if (FALSE) {
[08:27:57.418]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.418]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.418]     }
[08:27:57.418]     ...future.result <- base::tryCatch({
[08:27:57.418]         base::withCallingHandlers({
[08:27:57.418]             ...future.value <- base::withVisible(base::local({
[08:27:57.418]                 lm(weight ~ group - 1)
[08:27:57.418]             }))
[08:27:57.418]             future::FutureResult(value = ...future.value$value, 
[08:27:57.418]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.418]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.418]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.418]                     ...future.globalenv.names))
[08:27:57.418]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.418]         }, condition = base::local({
[08:27:57.418]             c <- base::c
[08:27:57.418]             inherits <- base::inherits
[08:27:57.418]             invokeRestart <- base::invokeRestart
[08:27:57.418]             length <- base::length
[08:27:57.418]             list <- base::list
[08:27:57.418]             seq.int <- base::seq.int
[08:27:57.418]             signalCondition <- base::signalCondition
[08:27:57.418]             sys.calls <- base::sys.calls
[08:27:57.418]             `[[` <- base::`[[`
[08:27:57.418]             `+` <- base::`+`
[08:27:57.418]             `<<-` <- base::`<<-`
[08:27:57.418]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.418]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.418]                   3L)]
[08:27:57.418]             }
[08:27:57.418]             function(cond) {
[08:27:57.418]                 is_error <- inherits(cond, "error")
[08:27:57.418]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.418]                   NULL)
[08:27:57.418]                 if (is_error) {
[08:27:57.418]                   sessionInformation <- function() {
[08:27:57.418]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.418]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.418]                       search = base::search(), system = base::Sys.info())
[08:27:57.418]                   }
[08:27:57.418]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.418]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.418]                     cond$call), session = sessionInformation(), 
[08:27:57.418]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.418]                   signalCondition(cond)
[08:27:57.418]                 }
[08:27:57.418]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.418]                 "immediateCondition"))) {
[08:27:57.418]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.418]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.418]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.418]                   if (TRUE && !signal) {
[08:27:57.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.418]                     {
[08:27:57.418]                       inherits <- base::inherits
[08:27:57.418]                       invokeRestart <- base::invokeRestart
[08:27:57.418]                       is.null <- base::is.null
[08:27:57.418]                       muffled <- FALSE
[08:27:57.418]                       if (inherits(cond, "message")) {
[08:27:57.418]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.418]                         if (muffled) 
[08:27:57.418]                           invokeRestart("muffleMessage")
[08:27:57.418]                       }
[08:27:57.418]                       else if (inherits(cond, "warning")) {
[08:27:57.418]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.418]                         if (muffled) 
[08:27:57.418]                           invokeRestart("muffleWarning")
[08:27:57.418]                       }
[08:27:57.418]                       else if (inherits(cond, "condition")) {
[08:27:57.418]                         if (!is.null(pattern)) {
[08:27:57.418]                           computeRestarts <- base::computeRestarts
[08:27:57.418]                           grepl <- base::grepl
[08:27:57.418]                           restarts <- computeRestarts(cond)
[08:27:57.418]                           for (restart in restarts) {
[08:27:57.418]                             name <- restart$name
[08:27:57.418]                             if (is.null(name)) 
[08:27:57.418]                               next
[08:27:57.418]                             if (!grepl(pattern, name)) 
[08:27:57.418]                               next
[08:27:57.418]                             invokeRestart(restart)
[08:27:57.418]                             muffled <- TRUE
[08:27:57.418]                             break
[08:27:57.418]                           }
[08:27:57.418]                         }
[08:27:57.418]                       }
[08:27:57.418]                       invisible(muffled)
[08:27:57.418]                     }
[08:27:57.418]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.418]                   }
[08:27:57.418]                 }
[08:27:57.418]                 else {
[08:27:57.418]                   if (TRUE) {
[08:27:57.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.418]                     {
[08:27:57.418]                       inherits <- base::inherits
[08:27:57.418]                       invokeRestart <- base::invokeRestart
[08:27:57.418]                       is.null <- base::is.null
[08:27:57.418]                       muffled <- FALSE
[08:27:57.418]                       if (inherits(cond, "message")) {
[08:27:57.418]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.418]                         if (muffled) 
[08:27:57.418]                           invokeRestart("muffleMessage")
[08:27:57.418]                       }
[08:27:57.418]                       else if (inherits(cond, "warning")) {
[08:27:57.418]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.418]                         if (muffled) 
[08:27:57.418]                           invokeRestart("muffleWarning")
[08:27:57.418]                       }
[08:27:57.418]                       else if (inherits(cond, "condition")) {
[08:27:57.418]                         if (!is.null(pattern)) {
[08:27:57.418]                           computeRestarts <- base::computeRestarts
[08:27:57.418]                           grepl <- base::grepl
[08:27:57.418]                           restarts <- computeRestarts(cond)
[08:27:57.418]                           for (restart in restarts) {
[08:27:57.418]                             name <- restart$name
[08:27:57.418]                             if (is.null(name)) 
[08:27:57.418]                               next
[08:27:57.418]                             if (!grepl(pattern, name)) 
[08:27:57.418]                               next
[08:27:57.418]                             invokeRestart(restart)
[08:27:57.418]                             muffled <- TRUE
[08:27:57.418]                             break
[08:27:57.418]                           }
[08:27:57.418]                         }
[08:27:57.418]                       }
[08:27:57.418]                       invisible(muffled)
[08:27:57.418]                     }
[08:27:57.418]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.418]                   }
[08:27:57.418]                 }
[08:27:57.418]             }
[08:27:57.418]         }))
[08:27:57.418]     }, error = function(ex) {
[08:27:57.418]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.418]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.418]                 ...future.rng), started = ...future.startTime, 
[08:27:57.418]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.418]             version = "1.8"), class = "FutureResult")
[08:27:57.418]     }, finally = {
[08:27:57.418]         if (!identical(...future.workdir, getwd())) 
[08:27:57.418]             setwd(...future.workdir)
[08:27:57.418]         {
[08:27:57.418]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.418]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.418]             }
[08:27:57.418]             base::options(...future.oldOptions)
[08:27:57.418]             if (.Platform$OS.type == "windows") {
[08:27:57.418]                 old_names <- names(...future.oldEnvVars)
[08:27:57.418]                 envs <- base::Sys.getenv()
[08:27:57.418]                 names <- names(envs)
[08:27:57.418]                 common <- intersect(names, old_names)
[08:27:57.418]                 added <- setdiff(names, old_names)
[08:27:57.418]                 removed <- setdiff(old_names, names)
[08:27:57.418]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.418]                   envs[common]]
[08:27:57.418]                 NAMES <- toupper(changed)
[08:27:57.418]                 args <- list()
[08:27:57.418]                 for (kk in seq_along(NAMES)) {
[08:27:57.418]                   name <- changed[[kk]]
[08:27:57.418]                   NAME <- NAMES[[kk]]
[08:27:57.418]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.418]                     next
[08:27:57.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.418]                 }
[08:27:57.418]                 NAMES <- toupper(added)
[08:27:57.418]                 for (kk in seq_along(NAMES)) {
[08:27:57.418]                   name <- added[[kk]]
[08:27:57.418]                   NAME <- NAMES[[kk]]
[08:27:57.418]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.418]                     next
[08:27:57.418]                   args[[name]] <- ""
[08:27:57.418]                 }
[08:27:57.418]                 NAMES <- toupper(removed)
[08:27:57.418]                 for (kk in seq_along(NAMES)) {
[08:27:57.418]                   name <- removed[[kk]]
[08:27:57.418]                   NAME <- NAMES[[kk]]
[08:27:57.418]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.418]                     next
[08:27:57.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.418]                 }
[08:27:57.418]                 if (length(args) > 0) 
[08:27:57.418]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.418]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.418]             }
[08:27:57.418]             else {
[08:27:57.418]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.418]             }
[08:27:57.418]             {
[08:27:57.418]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.418]                   0L) {
[08:27:57.418]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.418]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.418]                   base::options(opts)
[08:27:57.418]                 }
[08:27:57.418]                 {
[08:27:57.418]                   {
[08:27:57.418]                     NULL
[08:27:57.418]                     RNGkind("Mersenne-Twister")
[08:27:57.418]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:57.418]                       inherits = FALSE)
[08:27:57.418]                   }
[08:27:57.418]                   options(future.plan = NULL)
[08:27:57.418]                   if (is.na(NA_character_)) 
[08:27:57.418]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.418]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.418]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.418]                     .init = FALSE)
[08:27:57.418]                 }
[08:27:57.418]             }
[08:27:57.418]         }
[08:27:57.418]     })
[08:27:57.418]     if (TRUE) {
[08:27:57.418]         base::sink(type = "output", split = FALSE)
[08:27:57.418]         if (TRUE) {
[08:27:57.418]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.418]         }
[08:27:57.418]         else {
[08:27:57.418]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.418]         }
[08:27:57.418]         base::close(...future.stdout)
[08:27:57.418]         ...future.stdout <- NULL
[08:27:57.418]     }
[08:27:57.418]     ...future.result$conditions <- ...future.conditions
[08:27:57.418]     ...future.result$finished <- base::Sys.time()
[08:27:57.418]     ...future.result
[08:27:57.418] }
[08:27:57.420] assign_globals() ...
[08:27:57.420] List of 2
[08:27:57.420]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[08:27:57.420]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[08:27:57.420]  - attr(*, "where")=List of 2
[08:27:57.420]   ..$ weight:<environment: R_EmptyEnv> 
[08:27:57.420]   ..$ group :<environment: R_EmptyEnv> 
[08:27:57.420]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:57.420]  - attr(*, "resolved")= logi FALSE
[08:27:57.420]  - attr(*, "total_size")= num 401
[08:27:57.420]  - attr(*, "already-done")= logi TRUE
[08:27:57.423] - copied ‘weight’ to environment
[08:27:57.423] - copied ‘group’ to environment
[08:27:57.423] assign_globals() ... done
[08:27:57.423] plan(): Setting new future strategy stack:
[08:27:57.423] List of future strategies:
[08:27:57.423] 1. sequential:
[08:27:57.423]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.423]    - tweaked: FALSE
[08:27:57.423]    - call: NULL
[08:27:57.424] plan(): nbrOfWorkers() = 1
[08:27:57.425] plan(): Setting new future strategy stack:
[08:27:57.425] List of future strategies:
[08:27:57.425] 1. sequential:
[08:27:57.425]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.425]    - tweaked: FALSE
[08:27:57.425]    - call: plan(strategy)
[08:27:57.426] plan(): nbrOfWorkers() = 1
[08:27:57.426] SequentialFuture started (and completed)
[08:27:57.426] - Launch lazy future ... done
[08:27:57.426] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[08:27:57.428] getGlobalsAndPackages() ...
[08:27:57.428] Searching for globals...
[08:27:57.430] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[08:27:57.430] Searching for globals ... DONE
[08:27:57.430] Resolving globals: FALSE
[08:27:57.430] The total size of the 2 globals is 401 bytes (401 bytes)
[08:27:57.431] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[08:27:57.431] - globals: [2] ‘weight’, ‘group’
[08:27:57.431] - packages: [1] ‘stats’
[08:27:57.431] getGlobalsAndPackages() ... DONE
[08:27:57.431] run() for ‘Future’ ...
[08:27:57.431] - state: ‘created’
[08:27:57.431] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:57.432] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:57.432] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:57.432]   - Field: ‘label’
[08:27:57.432]   - Field: ‘local’
[08:27:57.432]   - Field: ‘owner’
[08:27:57.432]   - Field: ‘envir’
[08:27:57.432]   - Field: ‘packages’
[08:27:57.432]   - Field: ‘gc’
[08:27:57.432]   - Field: ‘conditions’
[08:27:57.432]   - Field: ‘expr’
[08:27:57.433]   - Field: ‘uuid’
[08:27:57.433]   - Field: ‘seed’
[08:27:57.433]   - Field: ‘version’
[08:27:57.433]   - Field: ‘result’
[08:27:57.433]   - Field: ‘asynchronous’
[08:27:57.433]   - Field: ‘calls’
[08:27:57.433]   - Field: ‘globals’
[08:27:57.433]   - Field: ‘stdout’
[08:27:57.433]   - Field: ‘earlySignal’
[08:27:57.433]   - Field: ‘lazy’
[08:27:57.433]   - Field: ‘state’
[08:27:57.433] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:57.434] - Launch lazy future ...
[08:27:57.434] Packages needed by the future expression (n = 1): ‘stats’
[08:27:57.434] Packages needed by future strategies (n = 0): <none>
[08:27:57.435] {
[08:27:57.435]     {
[08:27:57.435]         {
[08:27:57.435]             ...future.startTime <- base::Sys.time()
[08:27:57.435]             {
[08:27:57.435]                 {
[08:27:57.435]                   {
[08:27:57.435]                     {
[08:27:57.435]                       base::local({
[08:27:57.435]                         has_future <- base::requireNamespace("future", 
[08:27:57.435]                           quietly = TRUE)
[08:27:57.435]                         if (has_future) {
[08:27:57.435]                           ns <- base::getNamespace("future")
[08:27:57.435]                           version <- ns[[".package"]][["version"]]
[08:27:57.435]                           if (is.null(version)) 
[08:27:57.435]                             version <- utils::packageVersion("future")
[08:27:57.435]                         }
[08:27:57.435]                         else {
[08:27:57.435]                           version <- NULL
[08:27:57.435]                         }
[08:27:57.435]                         if (!has_future || version < "1.8.0") {
[08:27:57.435]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.435]                             "", base::R.version$version.string), 
[08:27:57.435]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:57.435]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:57.435]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.435]                               "release", "version")], collapse = " "), 
[08:27:57.435]                             hostname = base::Sys.info()[["nodename"]])
[08:27:57.435]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.435]                             info)
[08:27:57.435]                           info <- base::paste(info, collapse = "; ")
[08:27:57.435]                           if (!has_future) {
[08:27:57.435]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.435]                               info)
[08:27:57.435]                           }
[08:27:57.435]                           else {
[08:27:57.435]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.435]                               info, version)
[08:27:57.435]                           }
[08:27:57.435]                           base::stop(msg)
[08:27:57.435]                         }
[08:27:57.435]                       })
[08:27:57.435]                     }
[08:27:57.435]                     base::local({
[08:27:57.435]                       for (pkg in "stats") {
[08:27:57.435]                         base::loadNamespace(pkg)
[08:27:57.435]                         base::library(pkg, character.only = TRUE)
[08:27:57.435]                       }
[08:27:57.435]                     })
[08:27:57.435]                   }
[08:27:57.435]                   ...future.strategy.old <- future::plan("list")
[08:27:57.435]                   options(future.plan = NULL)
[08:27:57.435]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.435]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.435]                 }
[08:27:57.435]                 ...future.workdir <- getwd()
[08:27:57.435]             }
[08:27:57.435]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.435]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.435]         }
[08:27:57.435]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.435]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.435]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.435]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.435]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.435]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.435]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.435]             base::names(...future.oldOptions))
[08:27:57.435]     }
[08:27:57.435]     if (FALSE) {
[08:27:57.435]     }
[08:27:57.435]     else {
[08:27:57.435]         if (TRUE) {
[08:27:57.435]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.435]                 open = "w")
[08:27:57.435]         }
[08:27:57.435]         else {
[08:27:57.435]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.435]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.435]         }
[08:27:57.435]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.435]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.435]             base::sink(type = "output", split = FALSE)
[08:27:57.435]             base::close(...future.stdout)
[08:27:57.435]         }, add = TRUE)
[08:27:57.435]     }
[08:27:57.435]     ...future.frame <- base::sys.nframe()
[08:27:57.435]     ...future.conditions <- base::list()
[08:27:57.435]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.435]     if (FALSE) {
[08:27:57.435]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.435]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.435]     }
[08:27:57.435]     ...future.result <- base::tryCatch({
[08:27:57.435]         base::withCallingHandlers({
[08:27:57.435]             ...future.value <- base::withVisible(base::local({
[08:27:57.435]                 lm(weight ~ group - 1)
[08:27:57.435]             }))
[08:27:57.435]             future::FutureResult(value = ...future.value$value, 
[08:27:57.435]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.435]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.435]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.435]                     ...future.globalenv.names))
[08:27:57.435]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.435]         }, condition = base::local({
[08:27:57.435]             c <- base::c
[08:27:57.435]             inherits <- base::inherits
[08:27:57.435]             invokeRestart <- base::invokeRestart
[08:27:57.435]             length <- base::length
[08:27:57.435]             list <- base::list
[08:27:57.435]             seq.int <- base::seq.int
[08:27:57.435]             signalCondition <- base::signalCondition
[08:27:57.435]             sys.calls <- base::sys.calls
[08:27:57.435]             `[[` <- base::`[[`
[08:27:57.435]             `+` <- base::`+`
[08:27:57.435]             `<<-` <- base::`<<-`
[08:27:57.435]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.435]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.435]                   3L)]
[08:27:57.435]             }
[08:27:57.435]             function(cond) {
[08:27:57.435]                 is_error <- inherits(cond, "error")
[08:27:57.435]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.435]                   NULL)
[08:27:57.435]                 if (is_error) {
[08:27:57.435]                   sessionInformation <- function() {
[08:27:57.435]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.435]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.435]                       search = base::search(), system = base::Sys.info())
[08:27:57.435]                   }
[08:27:57.435]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.435]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.435]                     cond$call), session = sessionInformation(), 
[08:27:57.435]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.435]                   signalCondition(cond)
[08:27:57.435]                 }
[08:27:57.435]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.435]                 "immediateCondition"))) {
[08:27:57.435]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.435]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.435]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.435]                   if (TRUE && !signal) {
[08:27:57.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.435]                     {
[08:27:57.435]                       inherits <- base::inherits
[08:27:57.435]                       invokeRestart <- base::invokeRestart
[08:27:57.435]                       is.null <- base::is.null
[08:27:57.435]                       muffled <- FALSE
[08:27:57.435]                       if (inherits(cond, "message")) {
[08:27:57.435]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.435]                         if (muffled) 
[08:27:57.435]                           invokeRestart("muffleMessage")
[08:27:57.435]                       }
[08:27:57.435]                       else if (inherits(cond, "warning")) {
[08:27:57.435]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.435]                         if (muffled) 
[08:27:57.435]                           invokeRestart("muffleWarning")
[08:27:57.435]                       }
[08:27:57.435]                       else if (inherits(cond, "condition")) {
[08:27:57.435]                         if (!is.null(pattern)) {
[08:27:57.435]                           computeRestarts <- base::computeRestarts
[08:27:57.435]                           grepl <- base::grepl
[08:27:57.435]                           restarts <- computeRestarts(cond)
[08:27:57.435]                           for (restart in restarts) {
[08:27:57.435]                             name <- restart$name
[08:27:57.435]                             if (is.null(name)) 
[08:27:57.435]                               next
[08:27:57.435]                             if (!grepl(pattern, name)) 
[08:27:57.435]                               next
[08:27:57.435]                             invokeRestart(restart)
[08:27:57.435]                             muffled <- TRUE
[08:27:57.435]                             break
[08:27:57.435]                           }
[08:27:57.435]                         }
[08:27:57.435]                       }
[08:27:57.435]                       invisible(muffled)
[08:27:57.435]                     }
[08:27:57.435]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.435]                   }
[08:27:57.435]                 }
[08:27:57.435]                 else {
[08:27:57.435]                   if (TRUE) {
[08:27:57.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.435]                     {
[08:27:57.435]                       inherits <- base::inherits
[08:27:57.435]                       invokeRestart <- base::invokeRestart
[08:27:57.435]                       is.null <- base::is.null
[08:27:57.435]                       muffled <- FALSE
[08:27:57.435]                       if (inherits(cond, "message")) {
[08:27:57.435]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.435]                         if (muffled) 
[08:27:57.435]                           invokeRestart("muffleMessage")
[08:27:57.435]                       }
[08:27:57.435]                       else if (inherits(cond, "warning")) {
[08:27:57.435]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.435]                         if (muffled) 
[08:27:57.435]                           invokeRestart("muffleWarning")
[08:27:57.435]                       }
[08:27:57.435]                       else if (inherits(cond, "condition")) {
[08:27:57.435]                         if (!is.null(pattern)) {
[08:27:57.435]                           computeRestarts <- base::computeRestarts
[08:27:57.435]                           grepl <- base::grepl
[08:27:57.435]                           restarts <- computeRestarts(cond)
[08:27:57.435]                           for (restart in restarts) {
[08:27:57.435]                             name <- restart$name
[08:27:57.435]                             if (is.null(name)) 
[08:27:57.435]                               next
[08:27:57.435]                             if (!grepl(pattern, name)) 
[08:27:57.435]                               next
[08:27:57.435]                             invokeRestart(restart)
[08:27:57.435]                             muffled <- TRUE
[08:27:57.435]                             break
[08:27:57.435]                           }
[08:27:57.435]                         }
[08:27:57.435]                       }
[08:27:57.435]                       invisible(muffled)
[08:27:57.435]                     }
[08:27:57.435]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.435]                   }
[08:27:57.435]                 }
[08:27:57.435]             }
[08:27:57.435]         }))
[08:27:57.435]     }, error = function(ex) {
[08:27:57.435]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.435]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.435]                 ...future.rng), started = ...future.startTime, 
[08:27:57.435]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.435]             version = "1.8"), class = "FutureResult")
[08:27:57.435]     }, finally = {
[08:27:57.435]         if (!identical(...future.workdir, getwd())) 
[08:27:57.435]             setwd(...future.workdir)
[08:27:57.435]         {
[08:27:57.435]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.435]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.435]             }
[08:27:57.435]             base::options(...future.oldOptions)
[08:27:57.435]             if (.Platform$OS.type == "windows") {
[08:27:57.435]                 old_names <- names(...future.oldEnvVars)
[08:27:57.435]                 envs <- base::Sys.getenv()
[08:27:57.435]                 names <- names(envs)
[08:27:57.435]                 common <- intersect(names, old_names)
[08:27:57.435]                 added <- setdiff(names, old_names)
[08:27:57.435]                 removed <- setdiff(old_names, names)
[08:27:57.435]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.435]                   envs[common]]
[08:27:57.435]                 NAMES <- toupper(changed)
[08:27:57.435]                 args <- list()
[08:27:57.435]                 for (kk in seq_along(NAMES)) {
[08:27:57.435]                   name <- changed[[kk]]
[08:27:57.435]                   NAME <- NAMES[[kk]]
[08:27:57.435]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.435]                     next
[08:27:57.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.435]                 }
[08:27:57.435]                 NAMES <- toupper(added)
[08:27:57.435]                 for (kk in seq_along(NAMES)) {
[08:27:57.435]                   name <- added[[kk]]
[08:27:57.435]                   NAME <- NAMES[[kk]]
[08:27:57.435]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.435]                     next
[08:27:57.435]                   args[[name]] <- ""
[08:27:57.435]                 }
[08:27:57.435]                 NAMES <- toupper(removed)
[08:27:57.435]                 for (kk in seq_along(NAMES)) {
[08:27:57.435]                   name <- removed[[kk]]
[08:27:57.435]                   NAME <- NAMES[[kk]]
[08:27:57.435]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.435]                     next
[08:27:57.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.435]                 }
[08:27:57.435]                 if (length(args) > 0) 
[08:27:57.435]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.435]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.435]             }
[08:27:57.435]             else {
[08:27:57.435]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.435]             }
[08:27:57.435]             {
[08:27:57.435]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.435]                   0L) {
[08:27:57.435]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.435]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.435]                   base::options(opts)
[08:27:57.435]                 }
[08:27:57.435]                 {
[08:27:57.435]                   {
[08:27:57.435]                     NULL
[08:27:57.435]                     RNGkind("Mersenne-Twister")
[08:27:57.435]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:57.435]                       inherits = FALSE)
[08:27:57.435]                   }
[08:27:57.435]                   options(future.plan = NULL)
[08:27:57.435]                   if (is.na(NA_character_)) 
[08:27:57.435]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.435]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.435]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.435]                     .init = FALSE)
[08:27:57.435]                 }
[08:27:57.435]             }
[08:27:57.435]         }
[08:27:57.435]     })
[08:27:57.435]     if (TRUE) {
[08:27:57.435]         base::sink(type = "output", split = FALSE)
[08:27:57.435]         if (TRUE) {
[08:27:57.435]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.435]         }
[08:27:57.435]         else {
[08:27:57.435]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.435]         }
[08:27:57.435]         base::close(...future.stdout)
[08:27:57.435]         ...future.stdout <- NULL
[08:27:57.435]     }
[08:27:57.435]     ...future.result$conditions <- ...future.conditions
[08:27:57.435]     ...future.result$finished <- base::Sys.time()
[08:27:57.435]     ...future.result
[08:27:57.435] }
[08:27:57.437] assign_globals() ...
[08:27:57.437] List of 2
[08:27:57.437]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[08:27:57.437]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[08:27:57.437]  - attr(*, "where")=List of 2
[08:27:57.437]   ..$ weight:<environment: R_EmptyEnv> 
[08:27:57.437]   ..$ group :<environment: R_EmptyEnv> 
[08:27:57.437]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:57.437]  - attr(*, "resolved")= logi FALSE
[08:27:57.437]  - attr(*, "total_size")= num 401
[08:27:57.437]  - attr(*, "already-done")= logi TRUE
[08:27:57.440] - copied ‘weight’ to environment
[08:27:57.440] - copied ‘group’ to environment
[08:27:57.440] assign_globals() ... done
[08:27:57.441] plan(): Setting new future strategy stack:
[08:27:57.441] List of future strategies:
[08:27:57.441] 1. sequential:
[08:27:57.441]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.441]    - tweaked: FALSE
[08:27:57.441]    - call: NULL
[08:27:57.441] plan(): nbrOfWorkers() = 1
[08:27:57.443] plan(): Setting new future strategy stack:
[08:27:57.443] List of future strategies:
[08:27:57.443] 1. sequential:
[08:27:57.443]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.443]    - tweaked: FALSE
[08:27:57.443]    - call: plan(strategy)
[08:27:57.443] plan(): nbrOfWorkers() = 1
[08:27:57.443] SequentialFuture started (and completed)
[08:27:57.443] - Launch lazy future ... done
[08:27:57.443] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[08:27:57.445] getGlobalsAndPackages() ...
[08:27:57.445] Searching for globals...
[08:27:57.447] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[08:27:57.447] Searching for globals ... DONE
[08:27:57.447] Resolving globals: FALSE
[08:27:57.447] The total size of the 2 globals is 401 bytes (401 bytes)
[08:27:57.448] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[08:27:57.448] - globals: [2] ‘weight’, ‘group’
[08:27:57.448] - packages: [1] ‘stats’
[08:27:57.448] getGlobalsAndPackages() ... DONE
[08:27:57.448] run() for ‘Future’ ...
[08:27:57.448] - state: ‘created’
[08:27:57.448] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:57.449] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:57.449] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:57.449]   - Field: ‘label’
[08:27:57.449]   - Field: ‘local’
[08:27:57.449]   - Field: ‘owner’
[08:27:57.449]   - Field: ‘envir’
[08:27:57.449]   - Field: ‘packages’
[08:27:57.449]   - Field: ‘gc’
[08:27:57.449]   - Field: ‘conditions’
[08:27:57.449]   - Field: ‘expr’
[08:27:57.449]   - Field: ‘uuid’
[08:27:57.449]   - Field: ‘seed’
[08:27:57.450]   - Field: ‘version’
[08:27:57.450]   - Field: ‘result’
[08:27:57.450]   - Field: ‘asynchronous’
[08:27:57.450]   - Field: ‘calls’
[08:27:57.450]   - Field: ‘globals’
[08:27:57.450]   - Field: ‘stdout’
[08:27:57.450]   - Field: ‘earlySignal’
[08:27:57.450]   - Field: ‘lazy’
[08:27:57.450]   - Field: ‘state’
[08:27:57.450] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:57.450] - Launch lazy future ...
[08:27:57.451] Packages needed by the future expression (n = 1): ‘stats’
[08:27:57.451] Packages needed by future strategies (n = 0): <none>
[08:27:57.451] {
[08:27:57.451]     {
[08:27:57.451]         {
[08:27:57.451]             ...future.startTime <- base::Sys.time()
[08:27:57.451]             {
[08:27:57.451]                 {
[08:27:57.451]                   {
[08:27:57.451]                     {
[08:27:57.451]                       base::local({
[08:27:57.451]                         has_future <- base::requireNamespace("future", 
[08:27:57.451]                           quietly = TRUE)
[08:27:57.451]                         if (has_future) {
[08:27:57.451]                           ns <- base::getNamespace("future")
[08:27:57.451]                           version <- ns[[".package"]][["version"]]
[08:27:57.451]                           if (is.null(version)) 
[08:27:57.451]                             version <- utils::packageVersion("future")
[08:27:57.451]                         }
[08:27:57.451]                         else {
[08:27:57.451]                           version <- NULL
[08:27:57.451]                         }
[08:27:57.451]                         if (!has_future || version < "1.8.0") {
[08:27:57.451]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.451]                             "", base::R.version$version.string), 
[08:27:57.451]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:57.451]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:57.451]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.451]                               "release", "version")], collapse = " "), 
[08:27:57.451]                             hostname = base::Sys.info()[["nodename"]])
[08:27:57.451]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.451]                             info)
[08:27:57.451]                           info <- base::paste(info, collapse = "; ")
[08:27:57.451]                           if (!has_future) {
[08:27:57.451]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.451]                               info)
[08:27:57.451]                           }
[08:27:57.451]                           else {
[08:27:57.451]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.451]                               info, version)
[08:27:57.451]                           }
[08:27:57.451]                           base::stop(msg)
[08:27:57.451]                         }
[08:27:57.451]                       })
[08:27:57.451]                     }
[08:27:57.451]                     base::local({
[08:27:57.451]                       for (pkg in "stats") {
[08:27:57.451]                         base::loadNamespace(pkg)
[08:27:57.451]                         base::library(pkg, character.only = TRUE)
[08:27:57.451]                       }
[08:27:57.451]                     })
[08:27:57.451]                   }
[08:27:57.451]                   ...future.strategy.old <- future::plan("list")
[08:27:57.451]                   options(future.plan = NULL)
[08:27:57.451]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.451]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.451]                 }
[08:27:57.451]                 ...future.workdir <- getwd()
[08:27:57.451]             }
[08:27:57.451]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.451]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.451]         }
[08:27:57.451]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.451]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.451]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.451]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.451]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.451]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.451]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.451]             base::names(...future.oldOptions))
[08:27:57.451]     }
[08:27:57.451]     if (FALSE) {
[08:27:57.451]     }
[08:27:57.451]     else {
[08:27:57.451]         if (TRUE) {
[08:27:57.451]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.451]                 open = "w")
[08:27:57.451]         }
[08:27:57.451]         else {
[08:27:57.451]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.451]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.451]         }
[08:27:57.451]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.451]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.451]             base::sink(type = "output", split = FALSE)
[08:27:57.451]             base::close(...future.stdout)
[08:27:57.451]         }, add = TRUE)
[08:27:57.451]     }
[08:27:57.451]     ...future.frame <- base::sys.nframe()
[08:27:57.451]     ...future.conditions <- base::list()
[08:27:57.451]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.451]     if (FALSE) {
[08:27:57.451]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.451]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.451]     }
[08:27:57.451]     ...future.result <- base::tryCatch({
[08:27:57.451]         base::withCallingHandlers({
[08:27:57.451]             ...future.value <- base::withVisible(base::local({
[08:27:57.451]                 lm(weight ~ group - 1)
[08:27:57.451]             }))
[08:27:57.451]             future::FutureResult(value = ...future.value$value, 
[08:27:57.451]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.451]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.451]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.451]                     ...future.globalenv.names))
[08:27:57.451]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.451]         }, condition = base::local({
[08:27:57.451]             c <- base::c
[08:27:57.451]             inherits <- base::inherits
[08:27:57.451]             invokeRestart <- base::invokeRestart
[08:27:57.451]             length <- base::length
[08:27:57.451]             list <- base::list
[08:27:57.451]             seq.int <- base::seq.int
[08:27:57.451]             signalCondition <- base::signalCondition
[08:27:57.451]             sys.calls <- base::sys.calls
[08:27:57.451]             `[[` <- base::`[[`
[08:27:57.451]             `+` <- base::`+`
[08:27:57.451]             `<<-` <- base::`<<-`
[08:27:57.451]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.451]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.451]                   3L)]
[08:27:57.451]             }
[08:27:57.451]             function(cond) {
[08:27:57.451]                 is_error <- inherits(cond, "error")
[08:27:57.451]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.451]                   NULL)
[08:27:57.451]                 if (is_error) {
[08:27:57.451]                   sessionInformation <- function() {
[08:27:57.451]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.451]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.451]                       search = base::search(), system = base::Sys.info())
[08:27:57.451]                   }
[08:27:57.451]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.451]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.451]                     cond$call), session = sessionInformation(), 
[08:27:57.451]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.451]                   signalCondition(cond)
[08:27:57.451]                 }
[08:27:57.451]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.451]                 "immediateCondition"))) {
[08:27:57.451]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.451]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.451]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.451]                   if (TRUE && !signal) {
[08:27:57.451]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.451]                     {
[08:27:57.451]                       inherits <- base::inherits
[08:27:57.451]                       invokeRestart <- base::invokeRestart
[08:27:57.451]                       is.null <- base::is.null
[08:27:57.451]                       muffled <- FALSE
[08:27:57.451]                       if (inherits(cond, "message")) {
[08:27:57.451]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.451]                         if (muffled) 
[08:27:57.451]                           invokeRestart("muffleMessage")
[08:27:57.451]                       }
[08:27:57.451]                       else if (inherits(cond, "warning")) {
[08:27:57.451]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.451]                         if (muffled) 
[08:27:57.451]                           invokeRestart("muffleWarning")
[08:27:57.451]                       }
[08:27:57.451]                       else if (inherits(cond, "condition")) {
[08:27:57.451]                         if (!is.null(pattern)) {
[08:27:57.451]                           computeRestarts <- base::computeRestarts
[08:27:57.451]                           grepl <- base::grepl
[08:27:57.451]                           restarts <- computeRestarts(cond)
[08:27:57.451]                           for (restart in restarts) {
[08:27:57.451]                             name <- restart$name
[08:27:57.451]                             if (is.null(name)) 
[08:27:57.451]                               next
[08:27:57.451]                             if (!grepl(pattern, name)) 
[08:27:57.451]                               next
[08:27:57.451]                             invokeRestart(restart)
[08:27:57.451]                             muffled <- TRUE
[08:27:57.451]                             break
[08:27:57.451]                           }
[08:27:57.451]                         }
[08:27:57.451]                       }
[08:27:57.451]                       invisible(muffled)
[08:27:57.451]                     }
[08:27:57.451]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.451]                   }
[08:27:57.451]                 }
[08:27:57.451]                 else {
[08:27:57.451]                   if (TRUE) {
[08:27:57.451]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.451]                     {
[08:27:57.451]                       inherits <- base::inherits
[08:27:57.451]                       invokeRestart <- base::invokeRestart
[08:27:57.451]                       is.null <- base::is.null
[08:27:57.451]                       muffled <- FALSE
[08:27:57.451]                       if (inherits(cond, "message")) {
[08:27:57.451]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.451]                         if (muffled) 
[08:27:57.451]                           invokeRestart("muffleMessage")
[08:27:57.451]                       }
[08:27:57.451]                       else if (inherits(cond, "warning")) {
[08:27:57.451]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.451]                         if (muffled) 
[08:27:57.451]                           invokeRestart("muffleWarning")
[08:27:57.451]                       }
[08:27:57.451]                       else if (inherits(cond, "condition")) {
[08:27:57.451]                         if (!is.null(pattern)) {
[08:27:57.451]                           computeRestarts <- base::computeRestarts
[08:27:57.451]                           grepl <- base::grepl
[08:27:57.451]                           restarts <- computeRestarts(cond)
[08:27:57.451]                           for (restart in restarts) {
[08:27:57.451]                             name <- restart$name
[08:27:57.451]                             if (is.null(name)) 
[08:27:57.451]                               next
[08:27:57.451]                             if (!grepl(pattern, name)) 
[08:27:57.451]                               next
[08:27:57.451]                             invokeRestart(restart)
[08:27:57.451]                             muffled <- TRUE
[08:27:57.451]                             break
[08:27:57.451]                           }
[08:27:57.451]                         }
[08:27:57.451]                       }
[08:27:57.451]                       invisible(muffled)
[08:27:57.451]                     }
[08:27:57.451]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.451]                   }
[08:27:57.451]                 }
[08:27:57.451]             }
[08:27:57.451]         }))
[08:27:57.451]     }, error = function(ex) {
[08:27:57.451]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.451]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.451]                 ...future.rng), started = ...future.startTime, 
[08:27:57.451]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.451]             version = "1.8"), class = "FutureResult")
[08:27:57.451]     }, finally = {
[08:27:57.451]         if (!identical(...future.workdir, getwd())) 
[08:27:57.451]             setwd(...future.workdir)
[08:27:57.451]         {
[08:27:57.451]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.451]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.451]             }
[08:27:57.451]             base::options(...future.oldOptions)
[08:27:57.451]             if (.Platform$OS.type == "windows") {
[08:27:57.451]                 old_names <- names(...future.oldEnvVars)
[08:27:57.451]                 envs <- base::Sys.getenv()
[08:27:57.451]                 names <- names(envs)
[08:27:57.451]                 common <- intersect(names, old_names)
[08:27:57.451]                 added <- setdiff(names, old_names)
[08:27:57.451]                 removed <- setdiff(old_names, names)
[08:27:57.451]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.451]                   envs[common]]
[08:27:57.451]                 NAMES <- toupper(changed)
[08:27:57.451]                 args <- list()
[08:27:57.451]                 for (kk in seq_along(NAMES)) {
[08:27:57.451]                   name <- changed[[kk]]
[08:27:57.451]                   NAME <- NAMES[[kk]]
[08:27:57.451]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.451]                     next
[08:27:57.451]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.451]                 }
[08:27:57.451]                 NAMES <- toupper(added)
[08:27:57.451]                 for (kk in seq_along(NAMES)) {
[08:27:57.451]                   name <- added[[kk]]
[08:27:57.451]                   NAME <- NAMES[[kk]]
[08:27:57.451]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.451]                     next
[08:27:57.451]                   args[[name]] <- ""
[08:27:57.451]                 }
[08:27:57.451]                 NAMES <- toupper(removed)
[08:27:57.451]                 for (kk in seq_along(NAMES)) {
[08:27:57.451]                   name <- removed[[kk]]
[08:27:57.451]                   NAME <- NAMES[[kk]]
[08:27:57.451]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.451]                     next
[08:27:57.451]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.451]                 }
[08:27:57.451]                 if (length(args) > 0) 
[08:27:57.451]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.451]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.451]             }
[08:27:57.451]             else {
[08:27:57.451]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.451]             }
[08:27:57.451]             {
[08:27:57.451]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.451]                   0L) {
[08:27:57.451]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.451]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.451]                   base::options(opts)
[08:27:57.451]                 }
[08:27:57.451]                 {
[08:27:57.451]                   {
[08:27:57.451]                     NULL
[08:27:57.451]                     RNGkind("Mersenne-Twister")
[08:27:57.451]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:57.451]                       inherits = FALSE)
[08:27:57.451]                   }
[08:27:57.451]                   options(future.plan = NULL)
[08:27:57.451]                   if (is.na(NA_character_)) 
[08:27:57.451]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.451]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.451]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.451]                     .init = FALSE)
[08:27:57.451]                 }
[08:27:57.451]             }
[08:27:57.451]         }
[08:27:57.451]     })
[08:27:57.451]     if (TRUE) {
[08:27:57.451]         base::sink(type = "output", split = FALSE)
[08:27:57.451]         if (TRUE) {
[08:27:57.451]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.451]         }
[08:27:57.451]         else {
[08:27:57.451]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.451]         }
[08:27:57.451]         base::close(...future.stdout)
[08:27:57.451]         ...future.stdout <- NULL
[08:27:57.451]     }
[08:27:57.451]     ...future.result$conditions <- ...future.conditions
[08:27:57.451]     ...future.result$finished <- base::Sys.time()
[08:27:57.451]     ...future.result
[08:27:57.451] }
[08:27:57.453] assign_globals() ...
[08:27:57.453] List of 2
[08:27:57.453]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[08:27:57.453]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[08:27:57.453]  - attr(*, "where")=List of 2
[08:27:57.453]   ..$ weight:<environment: R_EmptyEnv> 
[08:27:57.453]   ..$ group :<environment: R_EmptyEnv> 
[08:27:57.453]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:57.453]  - attr(*, "resolved")= logi FALSE
[08:27:57.453]  - attr(*, "total_size")= num 401
[08:27:57.453]  - attr(*, "already-done")= logi TRUE
[08:27:57.456] - copied ‘weight’ to environment
[08:27:57.456] - copied ‘group’ to environment
[08:27:57.456] assign_globals() ... done
[08:27:57.456] plan(): Setting new future strategy stack:
[08:27:57.456] List of future strategies:
[08:27:57.456] 1. sequential:
[08:27:57.456]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.456]    - tweaked: FALSE
[08:27:57.456]    - call: NULL
[08:27:57.457] plan(): nbrOfWorkers() = 1
[08:27:57.458] plan(): Setting new future strategy stack:
[08:27:57.458] List of future strategies:
[08:27:57.458] 1. sequential:
[08:27:57.458]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.458]    - tweaked: FALSE
[08:27:57.458]    - call: plan(strategy)
[08:27:57.459] plan(): nbrOfWorkers() = 1
[08:27:57.459] SequentialFuture started (and completed)
[08:27:57.459] - Launch lazy future ... done
[08:27:57.459] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[08:27:57.462] getGlobalsAndPackages() ...
[08:27:57.462] Searching for globals...
[08:27:57.463] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[08:27:57.463] Searching for globals ... DONE
[08:27:57.464] Resolving globals: FALSE
[08:27:57.464] The total size of the 2 globals is 401 bytes (401 bytes)
[08:27:57.464] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[08:27:57.464] - globals: [2] ‘weight’, ‘group’
[08:27:57.465] - packages: [1] ‘stats’
[08:27:57.465] getGlobalsAndPackages() ... DONE
[08:27:57.465] run() for ‘Future’ ...
[08:27:57.465] - state: ‘created’
[08:27:57.465] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:57.465] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:57.465] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:57.466]   - Field: ‘label’
[08:27:57.466]   - Field: ‘local’
[08:27:57.466]   - Field: ‘owner’
[08:27:57.466]   - Field: ‘envir’
[08:27:57.466]   - Field: ‘packages’
[08:27:57.466]   - Field: ‘gc’
[08:27:57.466]   - Field: ‘conditions’
[08:27:57.466]   - Field: ‘expr’
[08:27:57.466]   - Field: ‘uuid’
[08:27:57.466]   - Field: ‘seed’
[08:27:57.466]   - Field: ‘version’
[08:27:57.466]   - Field: ‘result’
[08:27:57.467]   - Field: ‘asynchronous’
[08:27:57.467]   - Field: ‘calls’
[08:27:57.467]   - Field: ‘globals’
[08:27:57.467]   - Field: ‘stdout’
[08:27:57.467]   - Field: ‘earlySignal’
[08:27:57.467]   - Field: ‘lazy’
[08:27:57.467]   - Field: ‘state’
[08:27:57.467] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:57.467] - Launch lazy future ...
[08:27:57.467] Packages needed by the future expression (n = 1): ‘stats’
[08:27:57.467] Packages needed by future strategies (n = 0): <none>
[08:27:57.468] {
[08:27:57.468]     {
[08:27:57.468]         {
[08:27:57.468]             ...future.startTime <- base::Sys.time()
[08:27:57.468]             {
[08:27:57.468]                 {
[08:27:57.468]                   {
[08:27:57.468]                     {
[08:27:57.468]                       base::local({
[08:27:57.468]                         has_future <- base::requireNamespace("future", 
[08:27:57.468]                           quietly = TRUE)
[08:27:57.468]                         if (has_future) {
[08:27:57.468]                           ns <- base::getNamespace("future")
[08:27:57.468]                           version <- ns[[".package"]][["version"]]
[08:27:57.468]                           if (is.null(version)) 
[08:27:57.468]                             version <- utils::packageVersion("future")
[08:27:57.468]                         }
[08:27:57.468]                         else {
[08:27:57.468]                           version <- NULL
[08:27:57.468]                         }
[08:27:57.468]                         if (!has_future || version < "1.8.0") {
[08:27:57.468]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.468]                             "", base::R.version$version.string), 
[08:27:57.468]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:57.468]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:57.468]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.468]                               "release", "version")], collapse = " "), 
[08:27:57.468]                             hostname = base::Sys.info()[["nodename"]])
[08:27:57.468]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.468]                             info)
[08:27:57.468]                           info <- base::paste(info, collapse = "; ")
[08:27:57.468]                           if (!has_future) {
[08:27:57.468]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.468]                               info)
[08:27:57.468]                           }
[08:27:57.468]                           else {
[08:27:57.468]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.468]                               info, version)
[08:27:57.468]                           }
[08:27:57.468]                           base::stop(msg)
[08:27:57.468]                         }
[08:27:57.468]                       })
[08:27:57.468]                     }
[08:27:57.468]                     base::local({
[08:27:57.468]                       for (pkg in "stats") {
[08:27:57.468]                         base::loadNamespace(pkg)
[08:27:57.468]                         base::library(pkg, character.only = TRUE)
[08:27:57.468]                       }
[08:27:57.468]                     })
[08:27:57.468]                   }
[08:27:57.468]                   ...future.strategy.old <- future::plan("list")
[08:27:57.468]                   options(future.plan = NULL)
[08:27:57.468]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.468]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.468]                 }
[08:27:57.468]                 ...future.workdir <- getwd()
[08:27:57.468]             }
[08:27:57.468]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.468]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.468]         }
[08:27:57.468]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.468]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.468]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.468]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.468]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.468]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.468]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.468]             base::names(...future.oldOptions))
[08:27:57.468]     }
[08:27:57.468]     if (FALSE) {
[08:27:57.468]     }
[08:27:57.468]     else {
[08:27:57.468]         if (TRUE) {
[08:27:57.468]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.468]                 open = "w")
[08:27:57.468]         }
[08:27:57.468]         else {
[08:27:57.468]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.468]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.468]         }
[08:27:57.468]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.468]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.468]             base::sink(type = "output", split = FALSE)
[08:27:57.468]             base::close(...future.stdout)
[08:27:57.468]         }, add = TRUE)
[08:27:57.468]     }
[08:27:57.468]     ...future.frame <- base::sys.nframe()
[08:27:57.468]     ...future.conditions <- base::list()
[08:27:57.468]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.468]     if (FALSE) {
[08:27:57.468]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.468]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.468]     }
[08:27:57.468]     ...future.result <- base::tryCatch({
[08:27:57.468]         base::withCallingHandlers({
[08:27:57.468]             ...future.value <- base::withVisible(base::local({
[08:27:57.468]                 lm(weight ~ group - 1)
[08:27:57.468]             }))
[08:27:57.468]             future::FutureResult(value = ...future.value$value, 
[08:27:57.468]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.468]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.468]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.468]                     ...future.globalenv.names))
[08:27:57.468]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.468]         }, condition = base::local({
[08:27:57.468]             c <- base::c
[08:27:57.468]             inherits <- base::inherits
[08:27:57.468]             invokeRestart <- base::invokeRestart
[08:27:57.468]             length <- base::length
[08:27:57.468]             list <- base::list
[08:27:57.468]             seq.int <- base::seq.int
[08:27:57.468]             signalCondition <- base::signalCondition
[08:27:57.468]             sys.calls <- base::sys.calls
[08:27:57.468]             `[[` <- base::`[[`
[08:27:57.468]             `+` <- base::`+`
[08:27:57.468]             `<<-` <- base::`<<-`
[08:27:57.468]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.468]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.468]                   3L)]
[08:27:57.468]             }
[08:27:57.468]             function(cond) {
[08:27:57.468]                 is_error <- inherits(cond, "error")
[08:27:57.468]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.468]                   NULL)
[08:27:57.468]                 if (is_error) {
[08:27:57.468]                   sessionInformation <- function() {
[08:27:57.468]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.468]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.468]                       search = base::search(), system = base::Sys.info())
[08:27:57.468]                   }
[08:27:57.468]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.468]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.468]                     cond$call), session = sessionInformation(), 
[08:27:57.468]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.468]                   signalCondition(cond)
[08:27:57.468]                 }
[08:27:57.468]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.468]                 "immediateCondition"))) {
[08:27:57.468]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.468]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.468]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.468]                   if (TRUE && !signal) {
[08:27:57.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.468]                     {
[08:27:57.468]                       inherits <- base::inherits
[08:27:57.468]                       invokeRestart <- base::invokeRestart
[08:27:57.468]                       is.null <- base::is.null
[08:27:57.468]                       muffled <- FALSE
[08:27:57.468]                       if (inherits(cond, "message")) {
[08:27:57.468]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.468]                         if (muffled) 
[08:27:57.468]                           invokeRestart("muffleMessage")
[08:27:57.468]                       }
[08:27:57.468]                       else if (inherits(cond, "warning")) {
[08:27:57.468]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.468]                         if (muffled) 
[08:27:57.468]                           invokeRestart("muffleWarning")
[08:27:57.468]                       }
[08:27:57.468]                       else if (inherits(cond, "condition")) {
[08:27:57.468]                         if (!is.null(pattern)) {
[08:27:57.468]                           computeRestarts <- base::computeRestarts
[08:27:57.468]                           grepl <- base::grepl
[08:27:57.468]                           restarts <- computeRestarts(cond)
[08:27:57.468]                           for (restart in restarts) {
[08:27:57.468]                             name <- restart$name
[08:27:57.468]                             if (is.null(name)) 
[08:27:57.468]                               next
[08:27:57.468]                             if (!grepl(pattern, name)) 
[08:27:57.468]                               next
[08:27:57.468]                             invokeRestart(restart)
[08:27:57.468]                             muffled <- TRUE
[08:27:57.468]                             break
[08:27:57.468]                           }
[08:27:57.468]                         }
[08:27:57.468]                       }
[08:27:57.468]                       invisible(muffled)
[08:27:57.468]                     }
[08:27:57.468]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.468]                   }
[08:27:57.468]                 }
[08:27:57.468]                 else {
[08:27:57.468]                   if (TRUE) {
[08:27:57.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.468]                     {
[08:27:57.468]                       inherits <- base::inherits
[08:27:57.468]                       invokeRestart <- base::invokeRestart
[08:27:57.468]                       is.null <- base::is.null
[08:27:57.468]                       muffled <- FALSE
[08:27:57.468]                       if (inherits(cond, "message")) {
[08:27:57.468]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.468]                         if (muffled) 
[08:27:57.468]                           invokeRestart("muffleMessage")
[08:27:57.468]                       }
[08:27:57.468]                       else if (inherits(cond, "warning")) {
[08:27:57.468]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.468]                         if (muffled) 
[08:27:57.468]                           invokeRestart("muffleWarning")
[08:27:57.468]                       }
[08:27:57.468]                       else if (inherits(cond, "condition")) {
[08:27:57.468]                         if (!is.null(pattern)) {
[08:27:57.468]                           computeRestarts <- base::computeRestarts
[08:27:57.468]                           grepl <- base::grepl
[08:27:57.468]                           restarts <- computeRestarts(cond)
[08:27:57.468]                           for (restart in restarts) {
[08:27:57.468]                             name <- restart$name
[08:27:57.468]                             if (is.null(name)) 
[08:27:57.468]                               next
[08:27:57.468]                             if (!grepl(pattern, name)) 
[08:27:57.468]                               next
[08:27:57.468]                             invokeRestart(restart)
[08:27:57.468]                             muffled <- TRUE
[08:27:57.468]                             break
[08:27:57.468]                           }
[08:27:57.468]                         }
[08:27:57.468]                       }
[08:27:57.468]                       invisible(muffled)
[08:27:57.468]                     }
[08:27:57.468]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.468]                   }
[08:27:57.468]                 }
[08:27:57.468]             }
[08:27:57.468]         }))
[08:27:57.468]     }, error = function(ex) {
[08:27:57.468]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.468]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.468]                 ...future.rng), started = ...future.startTime, 
[08:27:57.468]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.468]             version = "1.8"), class = "FutureResult")
[08:27:57.468]     }, finally = {
[08:27:57.468]         if (!identical(...future.workdir, getwd())) 
[08:27:57.468]             setwd(...future.workdir)
[08:27:57.468]         {
[08:27:57.468]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.468]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.468]             }
[08:27:57.468]             base::options(...future.oldOptions)
[08:27:57.468]             if (.Platform$OS.type == "windows") {
[08:27:57.468]                 old_names <- names(...future.oldEnvVars)
[08:27:57.468]                 envs <- base::Sys.getenv()
[08:27:57.468]                 names <- names(envs)
[08:27:57.468]                 common <- intersect(names, old_names)
[08:27:57.468]                 added <- setdiff(names, old_names)
[08:27:57.468]                 removed <- setdiff(old_names, names)
[08:27:57.468]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.468]                   envs[common]]
[08:27:57.468]                 NAMES <- toupper(changed)
[08:27:57.468]                 args <- list()
[08:27:57.468]                 for (kk in seq_along(NAMES)) {
[08:27:57.468]                   name <- changed[[kk]]
[08:27:57.468]                   NAME <- NAMES[[kk]]
[08:27:57.468]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.468]                     next
[08:27:57.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.468]                 }
[08:27:57.468]                 NAMES <- toupper(added)
[08:27:57.468]                 for (kk in seq_along(NAMES)) {
[08:27:57.468]                   name <- added[[kk]]
[08:27:57.468]                   NAME <- NAMES[[kk]]
[08:27:57.468]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.468]                     next
[08:27:57.468]                   args[[name]] <- ""
[08:27:57.468]                 }
[08:27:57.468]                 NAMES <- toupper(removed)
[08:27:57.468]                 for (kk in seq_along(NAMES)) {
[08:27:57.468]                   name <- removed[[kk]]
[08:27:57.468]                   NAME <- NAMES[[kk]]
[08:27:57.468]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.468]                     next
[08:27:57.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.468]                 }
[08:27:57.468]                 if (length(args) > 0) 
[08:27:57.468]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.468]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.468]             }
[08:27:57.468]             else {
[08:27:57.468]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.468]             }
[08:27:57.468]             {
[08:27:57.468]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.468]                   0L) {
[08:27:57.468]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.468]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.468]                   base::options(opts)
[08:27:57.468]                 }
[08:27:57.468]                 {
[08:27:57.468]                   {
[08:27:57.468]                     NULL
[08:27:57.468]                     RNGkind("Mersenne-Twister")
[08:27:57.468]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:57.468]                       inherits = FALSE)
[08:27:57.468]                   }
[08:27:57.468]                   options(future.plan = NULL)
[08:27:57.468]                   if (is.na(NA_character_)) 
[08:27:57.468]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.468]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.468]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.468]                     .init = FALSE)
[08:27:57.468]                 }
[08:27:57.468]             }
[08:27:57.468]         }
[08:27:57.468]     })
[08:27:57.468]     if (TRUE) {
[08:27:57.468]         base::sink(type = "output", split = FALSE)
[08:27:57.468]         if (TRUE) {
[08:27:57.468]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.468]         }
[08:27:57.468]         else {
[08:27:57.468]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.468]         }
[08:27:57.468]         base::close(...future.stdout)
[08:27:57.468]         ...future.stdout <- NULL
[08:27:57.468]     }
[08:27:57.468]     ...future.result$conditions <- ...future.conditions
[08:27:57.468]     ...future.result$finished <- base::Sys.time()
[08:27:57.468]     ...future.result
[08:27:57.468] }
[08:27:57.470] assign_globals() ...
[08:27:57.470] List of 2
[08:27:57.470]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[08:27:57.470]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[08:27:57.470]  - attr(*, "where")=List of 2
[08:27:57.470]   ..$ weight:<environment: R_EmptyEnv> 
[08:27:57.470]   ..$ group :<environment: R_EmptyEnv> 
[08:27:57.470]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:57.470]  - attr(*, "resolved")= logi FALSE
[08:27:57.470]  - attr(*, "total_size")= num 401
[08:27:57.470]  - attr(*, "already-done")= logi TRUE
[08:27:57.473] - copied ‘weight’ to environment
[08:27:57.473] - copied ‘group’ to environment
[08:27:57.473] assign_globals() ... done
[08:27:57.473] plan(): Setting new future strategy stack:
[08:27:57.473] List of future strategies:
[08:27:57.473] 1. sequential:
[08:27:57.473]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.473]    - tweaked: FALSE
[08:27:57.473]    - call: NULL
[08:27:57.474] plan(): nbrOfWorkers() = 1
[08:27:57.475] plan(): Setting new future strategy stack:
[08:27:57.475] List of future strategies:
[08:27:57.475] 1. sequential:
[08:27:57.475]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.475]    - tweaked: FALSE
[08:27:57.475]    - call: plan(strategy)
[08:27:57.476] plan(): nbrOfWorkers() = 1
[08:27:57.476] SequentialFuture started (and completed)
[08:27:57.476] - Launch lazy future ... done
[08:27:57.476] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[08:27:57.477] getGlobalsAndPackages() ...
[08:27:57.478] Searching for globals...
[08:27:57.479] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[08:27:57.479] Searching for globals ... DONE
[08:27:57.479] Resolving globals: FALSE
[08:27:57.479] The total size of the 1 globals is 71 bytes (71 bytes)
[08:27:57.479] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 71 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (71 bytes of class ‘numeric’)
[08:27:57.480] - globals: [1] ‘x’
[08:27:57.480] - packages: [1] ‘stats’
[08:27:57.480] getGlobalsAndPackages() ... DONE
[08:27:57.480] run() for ‘Future’ ...
[08:27:57.480] - state: ‘created’
[08:27:57.480] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:57.480] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:57.481] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:57.481]   - Field: ‘label’
[08:27:57.481]   - Field: ‘local’
[08:27:57.481]   - Field: ‘owner’
[08:27:57.481]   - Field: ‘envir’
[08:27:57.481]   - Field: ‘packages’
[08:27:57.481]   - Field: ‘gc’
[08:27:57.481]   - Field: ‘conditions’
[08:27:57.481]   - Field: ‘expr’
[08:27:57.481]   - Field: ‘uuid’
[08:27:57.481]   - Field: ‘seed’
[08:27:57.481]   - Field: ‘version’
[08:27:57.482]   - Field: ‘result’
[08:27:57.482]   - Field: ‘asynchronous’
[08:27:57.482]   - Field: ‘calls’
[08:27:57.482]   - Field: ‘globals’
[08:27:57.482]   - Field: ‘stdout’
[08:27:57.482]   - Field: ‘earlySignal’
[08:27:57.482]   - Field: ‘lazy’
[08:27:57.482]   - Field: ‘state’
[08:27:57.482] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:57.482] - Launch lazy future ...
[08:27:57.482] Packages needed by the future expression (n = 1): ‘stats’
[08:27:57.484] Packages needed by future strategies (n = 0): <none>
[08:27:57.484] {
[08:27:57.484]     {
[08:27:57.484]         {
[08:27:57.484]             ...future.startTime <- base::Sys.time()
[08:27:57.484]             {
[08:27:57.484]                 {
[08:27:57.484]                   {
[08:27:57.484]                     {
[08:27:57.484]                       base::local({
[08:27:57.484]                         has_future <- base::requireNamespace("future", 
[08:27:57.484]                           quietly = TRUE)
[08:27:57.484]                         if (has_future) {
[08:27:57.484]                           ns <- base::getNamespace("future")
[08:27:57.484]                           version <- ns[[".package"]][["version"]]
[08:27:57.484]                           if (is.null(version)) 
[08:27:57.484]                             version <- utils::packageVersion("future")
[08:27:57.484]                         }
[08:27:57.484]                         else {
[08:27:57.484]                           version <- NULL
[08:27:57.484]                         }
[08:27:57.484]                         if (!has_future || version < "1.8.0") {
[08:27:57.484]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.484]                             "", base::R.version$version.string), 
[08:27:57.484]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:57.484]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:57.484]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.484]                               "release", "version")], collapse = " "), 
[08:27:57.484]                             hostname = base::Sys.info()[["nodename"]])
[08:27:57.484]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.484]                             info)
[08:27:57.484]                           info <- base::paste(info, collapse = "; ")
[08:27:57.484]                           if (!has_future) {
[08:27:57.484]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.484]                               info)
[08:27:57.484]                           }
[08:27:57.484]                           else {
[08:27:57.484]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.484]                               info, version)
[08:27:57.484]                           }
[08:27:57.484]                           base::stop(msg)
[08:27:57.484]                         }
[08:27:57.484]                       })
[08:27:57.484]                     }
[08:27:57.484]                     base::local({
[08:27:57.484]                       for (pkg in "stats") {
[08:27:57.484]                         base::loadNamespace(pkg)
[08:27:57.484]                         base::library(pkg, character.only = TRUE)
[08:27:57.484]                       }
[08:27:57.484]                     })
[08:27:57.484]                   }
[08:27:57.484]                   ...future.strategy.old <- future::plan("list")
[08:27:57.484]                   options(future.plan = NULL)
[08:27:57.484]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.484]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.484]                 }
[08:27:57.484]                 ...future.workdir <- getwd()
[08:27:57.484]             }
[08:27:57.484]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.484]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.484]         }
[08:27:57.484]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.484]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.484]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.484]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.484]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.484]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.484]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.484]             base::names(...future.oldOptions))
[08:27:57.484]     }
[08:27:57.484]     if (FALSE) {
[08:27:57.484]     }
[08:27:57.484]     else {
[08:27:57.484]         if (TRUE) {
[08:27:57.484]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.484]                 open = "w")
[08:27:57.484]         }
[08:27:57.484]         else {
[08:27:57.484]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.484]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.484]         }
[08:27:57.484]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.484]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.484]             base::sink(type = "output", split = FALSE)
[08:27:57.484]             base::close(...future.stdout)
[08:27:57.484]         }, add = TRUE)
[08:27:57.484]     }
[08:27:57.484]     ...future.frame <- base::sys.nframe()
[08:27:57.484]     ...future.conditions <- base::list()
[08:27:57.484]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.484]     if (FALSE) {
[08:27:57.484]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.484]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.484]     }
[08:27:57.484]     ...future.result <- base::tryCatch({
[08:27:57.484]         base::withCallingHandlers({
[08:27:57.484]             ...future.value <- base::withVisible(base::local({
[08:27:57.484]                 xtabs(~x)
[08:27:57.484]             }))
[08:27:57.484]             future::FutureResult(value = ...future.value$value, 
[08:27:57.484]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.484]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.484]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.484]                     ...future.globalenv.names))
[08:27:57.484]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.484]         }, condition = base::local({
[08:27:57.484]             c <- base::c
[08:27:57.484]             inherits <- base::inherits
[08:27:57.484]             invokeRestart <- base::invokeRestart
[08:27:57.484]             length <- base::length
[08:27:57.484]             list <- base::list
[08:27:57.484]             seq.int <- base::seq.int
[08:27:57.484]             signalCondition <- base::signalCondition
[08:27:57.484]             sys.calls <- base::sys.calls
[08:27:57.484]             `[[` <- base::`[[`
[08:27:57.484]             `+` <- base::`+`
[08:27:57.484]             `<<-` <- base::`<<-`
[08:27:57.484]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.484]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.484]                   3L)]
[08:27:57.484]             }
[08:27:57.484]             function(cond) {
[08:27:57.484]                 is_error <- inherits(cond, "error")
[08:27:57.484]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.484]                   NULL)
[08:27:57.484]                 if (is_error) {
[08:27:57.484]                   sessionInformation <- function() {
[08:27:57.484]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.484]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.484]                       search = base::search(), system = base::Sys.info())
[08:27:57.484]                   }
[08:27:57.484]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.484]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.484]                     cond$call), session = sessionInformation(), 
[08:27:57.484]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.484]                   signalCondition(cond)
[08:27:57.484]                 }
[08:27:57.484]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.484]                 "immediateCondition"))) {
[08:27:57.484]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.484]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.484]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.484]                   if (TRUE && !signal) {
[08:27:57.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.484]                     {
[08:27:57.484]                       inherits <- base::inherits
[08:27:57.484]                       invokeRestart <- base::invokeRestart
[08:27:57.484]                       is.null <- base::is.null
[08:27:57.484]                       muffled <- FALSE
[08:27:57.484]                       if (inherits(cond, "message")) {
[08:27:57.484]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.484]                         if (muffled) 
[08:27:57.484]                           invokeRestart("muffleMessage")
[08:27:57.484]                       }
[08:27:57.484]                       else if (inherits(cond, "warning")) {
[08:27:57.484]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.484]                         if (muffled) 
[08:27:57.484]                           invokeRestart("muffleWarning")
[08:27:57.484]                       }
[08:27:57.484]                       else if (inherits(cond, "condition")) {
[08:27:57.484]                         if (!is.null(pattern)) {
[08:27:57.484]                           computeRestarts <- base::computeRestarts
[08:27:57.484]                           grepl <- base::grepl
[08:27:57.484]                           restarts <- computeRestarts(cond)
[08:27:57.484]                           for (restart in restarts) {
[08:27:57.484]                             name <- restart$name
[08:27:57.484]                             if (is.null(name)) 
[08:27:57.484]                               next
[08:27:57.484]                             if (!grepl(pattern, name)) 
[08:27:57.484]                               next
[08:27:57.484]                             invokeRestart(restart)
[08:27:57.484]                             muffled <- TRUE
[08:27:57.484]                             break
[08:27:57.484]                           }
[08:27:57.484]                         }
[08:27:57.484]                       }
[08:27:57.484]                       invisible(muffled)
[08:27:57.484]                     }
[08:27:57.484]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.484]                   }
[08:27:57.484]                 }
[08:27:57.484]                 else {
[08:27:57.484]                   if (TRUE) {
[08:27:57.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.484]                     {
[08:27:57.484]                       inherits <- base::inherits
[08:27:57.484]                       invokeRestart <- base::invokeRestart
[08:27:57.484]                       is.null <- base::is.null
[08:27:57.484]                       muffled <- FALSE
[08:27:57.484]                       if (inherits(cond, "message")) {
[08:27:57.484]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.484]                         if (muffled) 
[08:27:57.484]                           invokeRestart("muffleMessage")
[08:27:57.484]                       }
[08:27:57.484]                       else if (inherits(cond, "warning")) {
[08:27:57.484]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.484]                         if (muffled) 
[08:27:57.484]                           invokeRestart("muffleWarning")
[08:27:57.484]                       }
[08:27:57.484]                       else if (inherits(cond, "condition")) {
[08:27:57.484]                         if (!is.null(pattern)) {
[08:27:57.484]                           computeRestarts <- base::computeRestarts
[08:27:57.484]                           grepl <- base::grepl
[08:27:57.484]                           restarts <- computeRestarts(cond)
[08:27:57.484]                           for (restart in restarts) {
[08:27:57.484]                             name <- restart$name
[08:27:57.484]                             if (is.null(name)) 
[08:27:57.484]                               next
[08:27:57.484]                             if (!grepl(pattern, name)) 
[08:27:57.484]                               next
[08:27:57.484]                             invokeRestart(restart)
[08:27:57.484]                             muffled <- TRUE
[08:27:57.484]                             break
[08:27:57.484]                           }
[08:27:57.484]                         }
[08:27:57.484]                       }
[08:27:57.484]                       invisible(muffled)
[08:27:57.484]                     }
[08:27:57.484]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.484]                   }
[08:27:57.484]                 }
[08:27:57.484]             }
[08:27:57.484]         }))
[08:27:57.484]     }, error = function(ex) {
[08:27:57.484]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.484]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.484]                 ...future.rng), started = ...future.startTime, 
[08:27:57.484]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.484]             version = "1.8"), class = "FutureResult")
[08:27:57.484]     }, finally = {
[08:27:57.484]         if (!identical(...future.workdir, getwd())) 
[08:27:57.484]             setwd(...future.workdir)
[08:27:57.484]         {
[08:27:57.484]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.484]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.484]             }
[08:27:57.484]             base::options(...future.oldOptions)
[08:27:57.484]             if (.Platform$OS.type == "windows") {
[08:27:57.484]                 old_names <- names(...future.oldEnvVars)
[08:27:57.484]                 envs <- base::Sys.getenv()
[08:27:57.484]                 names <- names(envs)
[08:27:57.484]                 common <- intersect(names, old_names)
[08:27:57.484]                 added <- setdiff(names, old_names)
[08:27:57.484]                 removed <- setdiff(old_names, names)
[08:27:57.484]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.484]                   envs[common]]
[08:27:57.484]                 NAMES <- toupper(changed)
[08:27:57.484]                 args <- list()
[08:27:57.484]                 for (kk in seq_along(NAMES)) {
[08:27:57.484]                   name <- changed[[kk]]
[08:27:57.484]                   NAME <- NAMES[[kk]]
[08:27:57.484]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.484]                     next
[08:27:57.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.484]                 }
[08:27:57.484]                 NAMES <- toupper(added)
[08:27:57.484]                 for (kk in seq_along(NAMES)) {
[08:27:57.484]                   name <- added[[kk]]
[08:27:57.484]                   NAME <- NAMES[[kk]]
[08:27:57.484]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.484]                     next
[08:27:57.484]                   args[[name]] <- ""
[08:27:57.484]                 }
[08:27:57.484]                 NAMES <- toupper(removed)
[08:27:57.484]                 for (kk in seq_along(NAMES)) {
[08:27:57.484]                   name <- removed[[kk]]
[08:27:57.484]                   NAME <- NAMES[[kk]]
[08:27:57.484]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.484]                     next
[08:27:57.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.484]                 }
[08:27:57.484]                 if (length(args) > 0) 
[08:27:57.484]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.484]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.484]             }
[08:27:57.484]             else {
[08:27:57.484]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.484]             }
[08:27:57.484]             {
[08:27:57.484]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.484]                   0L) {
[08:27:57.484]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.484]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.484]                   base::options(opts)
[08:27:57.484]                 }
[08:27:57.484]                 {
[08:27:57.484]                   {
[08:27:57.484]                     NULL
[08:27:57.484]                     RNGkind("Mersenne-Twister")
[08:27:57.484]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:57.484]                       inherits = FALSE)
[08:27:57.484]                   }
[08:27:57.484]                   options(future.plan = NULL)
[08:27:57.484]                   if (is.na(NA_character_)) 
[08:27:57.484]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.484]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.484]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.484]                     .init = FALSE)
[08:27:57.484]                 }
[08:27:57.484]             }
[08:27:57.484]         }
[08:27:57.484]     })
[08:27:57.484]     if (TRUE) {
[08:27:57.484]         base::sink(type = "output", split = FALSE)
[08:27:57.484]         if (TRUE) {
[08:27:57.484]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.484]         }
[08:27:57.484]         else {
[08:27:57.484]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.484]         }
[08:27:57.484]         base::close(...future.stdout)
[08:27:57.484]         ...future.stdout <- NULL
[08:27:57.484]     }
[08:27:57.484]     ...future.result$conditions <- ...future.conditions
[08:27:57.484]     ...future.result$finished <- base::Sys.time()
[08:27:57.484]     ...future.result
[08:27:57.484] }
[08:27:57.486] assign_globals() ...
[08:27:57.486] List of 1
[08:27:57.486]  $ x: num [1:5] 1 1 2 2 2
[08:27:57.486]  - attr(*, "where")=List of 1
[08:27:57.486]   ..$ x:<environment: R_EmptyEnv> 
[08:27:57.486]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:57.486]  - attr(*, "resolved")= logi FALSE
[08:27:57.486]  - attr(*, "total_size")= num 71
[08:27:57.486]  - attr(*, "already-done")= logi TRUE
[08:27:57.488] - copied ‘x’ to environment
[08:27:57.488] assign_globals() ... done
[08:27:57.489] plan(): Setting new future strategy stack:
[08:27:57.489] List of future strategies:
[08:27:57.489] 1. sequential:
[08:27:57.489]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.489]    - tweaked: FALSE
[08:27:57.489]    - call: NULL
[08:27:57.489] plan(): nbrOfWorkers() = 1
[08:27:57.490] plan(): Setting new future strategy stack:
[08:27:57.490] List of future strategies:
[08:27:57.490] 1. sequential:
[08:27:57.490]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.490]    - tweaked: FALSE
[08:27:57.490]    - call: plan(strategy)
[08:27:57.491] plan(): nbrOfWorkers() = 1
[08:27:57.491] SequentialFuture started (and completed)
[08:27:57.491] - Launch lazy future ... done
[08:27:57.491] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
[08:27:57.492] getGlobalsAndPackages() ...
[08:27:57.492] Searching for globals...
[08:27:57.493] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[08:27:57.493] Searching for globals ... DONE
[08:27:57.493] Resolving globals: FALSE
[08:27:57.493] The total size of the 1 globals is 71 bytes (71 bytes)
[08:27:57.494] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 71 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (71 bytes of class ‘numeric’)
[08:27:57.494] - globals: [1] ‘x’
[08:27:57.494] - packages: [1] ‘stats’
[08:27:57.494] getGlobalsAndPackages() ... DONE
[08:27:57.494] run() for ‘Future’ ...
[08:27:57.494] - state: ‘created’
[08:27:57.495] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:57.495] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:57.495] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:57.495]   - Field: ‘label’
[08:27:57.495]   - Field: ‘local’
[08:27:57.495]   - Field: ‘owner’
[08:27:57.495]   - Field: ‘envir’
[08:27:57.495]   - Field: ‘packages’
[08:27:57.495]   - Field: ‘gc’
[08:27:57.496]   - Field: ‘conditions’
[08:27:57.496]   - Field: ‘expr’
[08:27:57.496]   - Field: ‘uuid’
[08:27:57.496]   - Field: ‘seed’
[08:27:57.496]   - Field: ‘version’
[08:27:57.496]   - Field: ‘result’
[08:27:57.496]   - Field: ‘asynchronous’
[08:27:57.496]   - Field: ‘calls’
[08:27:57.496]   - Field: ‘globals’
[08:27:57.496]   - Field: ‘stdout’
[08:27:57.496]   - Field: ‘earlySignal’
[08:27:57.496]   - Field: ‘lazy’
[08:27:57.496]   - Field: ‘state’
[08:27:57.497] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:57.497] - Launch lazy future ...
[08:27:57.497] Packages needed by the future expression (n = 1): ‘stats’
[08:27:57.497] Packages needed by future strategies (n = 0): <none>
[08:27:57.497] {
[08:27:57.497]     {
[08:27:57.497]         {
[08:27:57.497]             ...future.startTime <- base::Sys.time()
[08:27:57.497]             {
[08:27:57.497]                 {
[08:27:57.497]                   {
[08:27:57.497]                     {
[08:27:57.497]                       base::local({
[08:27:57.497]                         has_future <- base::requireNamespace("future", 
[08:27:57.497]                           quietly = TRUE)
[08:27:57.497]                         if (has_future) {
[08:27:57.497]                           ns <- base::getNamespace("future")
[08:27:57.497]                           version <- ns[[".package"]][["version"]]
[08:27:57.497]                           if (is.null(version)) 
[08:27:57.497]                             version <- utils::packageVersion("future")
[08:27:57.497]                         }
[08:27:57.497]                         else {
[08:27:57.497]                           version <- NULL
[08:27:57.497]                         }
[08:27:57.497]                         if (!has_future || version < "1.8.0") {
[08:27:57.497]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.497]                             "", base::R.version$version.string), 
[08:27:57.497]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:57.497]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:57.497]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.497]                               "release", "version")], collapse = " "), 
[08:27:57.497]                             hostname = base::Sys.info()[["nodename"]])
[08:27:57.497]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.497]                             info)
[08:27:57.497]                           info <- base::paste(info, collapse = "; ")
[08:27:57.497]                           if (!has_future) {
[08:27:57.497]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.497]                               info)
[08:27:57.497]                           }
[08:27:57.497]                           else {
[08:27:57.497]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.497]                               info, version)
[08:27:57.497]                           }
[08:27:57.497]                           base::stop(msg)
[08:27:57.497]                         }
[08:27:57.497]                       })
[08:27:57.497]                     }
[08:27:57.497]                     base::local({
[08:27:57.497]                       for (pkg in "stats") {
[08:27:57.497]                         base::loadNamespace(pkg)
[08:27:57.497]                         base::library(pkg, character.only = TRUE)
[08:27:57.497]                       }
[08:27:57.497]                     })
[08:27:57.497]                   }
[08:27:57.497]                   ...future.strategy.old <- future::plan("list")
[08:27:57.497]                   options(future.plan = NULL)
[08:27:57.497]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.497]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.497]                 }
[08:27:57.497]                 ...future.workdir <- getwd()
[08:27:57.497]             }
[08:27:57.497]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.497]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.497]         }
[08:27:57.497]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.497]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.497]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.497]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.497]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.497]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.497]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.497]             base::names(...future.oldOptions))
[08:27:57.497]     }
[08:27:57.497]     if (FALSE) {
[08:27:57.497]     }
[08:27:57.497]     else {
[08:27:57.497]         if (TRUE) {
[08:27:57.497]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.497]                 open = "w")
[08:27:57.497]         }
[08:27:57.497]         else {
[08:27:57.497]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.497]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.497]         }
[08:27:57.497]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.497]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.497]             base::sink(type = "output", split = FALSE)
[08:27:57.497]             base::close(...future.stdout)
[08:27:57.497]         }, add = TRUE)
[08:27:57.497]     }
[08:27:57.497]     ...future.frame <- base::sys.nframe()
[08:27:57.497]     ...future.conditions <- base::list()
[08:27:57.497]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.497]     if (FALSE) {
[08:27:57.497]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.497]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.497]     }
[08:27:57.497]     ...future.result <- base::tryCatch({
[08:27:57.497]         base::withCallingHandlers({
[08:27:57.497]             ...future.value <- base::withVisible(base::local({
[08:27:57.497]                 xtabs(~x)
[08:27:57.497]             }))
[08:27:57.497]             future::FutureResult(value = ...future.value$value, 
[08:27:57.497]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.497]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.497]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.497]                     ...future.globalenv.names))
[08:27:57.497]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.497]         }, condition = base::local({
[08:27:57.497]             c <- base::c
[08:27:57.497]             inherits <- base::inherits
[08:27:57.497]             invokeRestart <- base::invokeRestart
[08:27:57.497]             length <- base::length
[08:27:57.497]             list <- base::list
[08:27:57.497]             seq.int <- base::seq.int
[08:27:57.497]             signalCondition <- base::signalCondition
[08:27:57.497]             sys.calls <- base::sys.calls
[08:27:57.497]             `[[` <- base::`[[`
[08:27:57.497]             `+` <- base::`+`
[08:27:57.497]             `<<-` <- base::`<<-`
[08:27:57.497]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.497]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.497]                   3L)]
[08:27:57.497]             }
[08:27:57.497]             function(cond) {
[08:27:57.497]                 is_error <- inherits(cond, "error")
[08:27:57.497]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.497]                   NULL)
[08:27:57.497]                 if (is_error) {
[08:27:57.497]                   sessionInformation <- function() {
[08:27:57.497]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.497]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.497]                       search = base::search(), system = base::Sys.info())
[08:27:57.497]                   }
[08:27:57.497]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.497]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.497]                     cond$call), session = sessionInformation(), 
[08:27:57.497]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.497]                   signalCondition(cond)
[08:27:57.497]                 }
[08:27:57.497]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.497]                 "immediateCondition"))) {
[08:27:57.497]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.497]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.497]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.497]                   if (TRUE && !signal) {
[08:27:57.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.497]                     {
[08:27:57.497]                       inherits <- base::inherits
[08:27:57.497]                       invokeRestart <- base::invokeRestart
[08:27:57.497]                       is.null <- base::is.null
[08:27:57.497]                       muffled <- FALSE
[08:27:57.497]                       if (inherits(cond, "message")) {
[08:27:57.497]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.497]                         if (muffled) 
[08:27:57.497]                           invokeRestart("muffleMessage")
[08:27:57.497]                       }
[08:27:57.497]                       else if (inherits(cond, "warning")) {
[08:27:57.497]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.497]                         if (muffled) 
[08:27:57.497]                           invokeRestart("muffleWarning")
[08:27:57.497]                       }
[08:27:57.497]                       else if (inherits(cond, "condition")) {
[08:27:57.497]                         if (!is.null(pattern)) {
[08:27:57.497]                           computeRestarts <- base::computeRestarts
[08:27:57.497]                           grepl <- base::grepl
[08:27:57.497]                           restarts <- computeRestarts(cond)
[08:27:57.497]                           for (restart in restarts) {
[08:27:57.497]                             name <- restart$name
[08:27:57.497]                             if (is.null(name)) 
[08:27:57.497]                               next
[08:27:57.497]                             if (!grepl(pattern, name)) 
[08:27:57.497]                               next
[08:27:57.497]                             invokeRestart(restart)
[08:27:57.497]                             muffled <- TRUE
[08:27:57.497]                             break
[08:27:57.497]                           }
[08:27:57.497]                         }
[08:27:57.497]                       }
[08:27:57.497]                       invisible(muffled)
[08:27:57.497]                     }
[08:27:57.497]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.497]                   }
[08:27:57.497]                 }
[08:27:57.497]                 else {
[08:27:57.497]                   if (TRUE) {
[08:27:57.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.497]                     {
[08:27:57.497]                       inherits <- base::inherits
[08:27:57.497]                       invokeRestart <- base::invokeRestart
[08:27:57.497]                       is.null <- base::is.null
[08:27:57.497]                       muffled <- FALSE
[08:27:57.497]                       if (inherits(cond, "message")) {
[08:27:57.497]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.497]                         if (muffled) 
[08:27:57.497]                           invokeRestart("muffleMessage")
[08:27:57.497]                       }
[08:27:57.497]                       else if (inherits(cond, "warning")) {
[08:27:57.497]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.497]                         if (muffled) 
[08:27:57.497]                           invokeRestart("muffleWarning")
[08:27:57.497]                       }
[08:27:57.497]                       else if (inherits(cond, "condition")) {
[08:27:57.497]                         if (!is.null(pattern)) {
[08:27:57.497]                           computeRestarts <- base::computeRestarts
[08:27:57.497]                           grepl <- base::grepl
[08:27:57.497]                           restarts <- computeRestarts(cond)
[08:27:57.497]                           for (restart in restarts) {
[08:27:57.497]                             name <- restart$name
[08:27:57.497]                             if (is.null(name)) 
[08:27:57.497]                               next
[08:27:57.497]                             if (!grepl(pattern, name)) 
[08:27:57.497]                               next
[08:27:57.497]                             invokeRestart(restart)
[08:27:57.497]                             muffled <- TRUE
[08:27:57.497]                             break
[08:27:57.497]                           }
[08:27:57.497]                         }
[08:27:57.497]                       }
[08:27:57.497]                       invisible(muffled)
[08:27:57.497]                     }
[08:27:57.497]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.497]                   }
[08:27:57.497]                 }
[08:27:57.497]             }
[08:27:57.497]         }))
[08:27:57.497]     }, error = function(ex) {
[08:27:57.497]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.497]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.497]                 ...future.rng), started = ...future.startTime, 
[08:27:57.497]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.497]             version = "1.8"), class = "FutureResult")
[08:27:57.497]     }, finally = {
[08:27:57.497]         if (!identical(...future.workdir, getwd())) 
[08:27:57.497]             setwd(...future.workdir)
[08:27:57.497]         {
[08:27:57.497]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.497]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.497]             }
[08:27:57.497]             base::options(...future.oldOptions)
[08:27:57.497]             if (.Platform$OS.type == "windows") {
[08:27:57.497]                 old_names <- names(...future.oldEnvVars)
[08:27:57.497]                 envs <- base::Sys.getenv()
[08:27:57.497]                 names <- names(envs)
[08:27:57.497]                 common <- intersect(names, old_names)
[08:27:57.497]                 added <- setdiff(names, old_names)
[08:27:57.497]                 removed <- setdiff(old_names, names)
[08:27:57.497]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.497]                   envs[common]]
[08:27:57.497]                 NAMES <- toupper(changed)
[08:27:57.497]                 args <- list()
[08:27:57.497]                 for (kk in seq_along(NAMES)) {
[08:27:57.497]                   name <- changed[[kk]]
[08:27:57.497]                   NAME <- NAMES[[kk]]
[08:27:57.497]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.497]                     next
[08:27:57.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.497]                 }
[08:27:57.497]                 NAMES <- toupper(added)
[08:27:57.497]                 for (kk in seq_along(NAMES)) {
[08:27:57.497]                   name <- added[[kk]]
[08:27:57.497]                   NAME <- NAMES[[kk]]
[08:27:57.497]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.497]                     next
[08:27:57.497]                   args[[name]] <- ""
[08:27:57.497]                 }
[08:27:57.497]                 NAMES <- toupper(removed)
[08:27:57.497]                 for (kk in seq_along(NAMES)) {
[08:27:57.497]                   name <- removed[[kk]]
[08:27:57.497]                   NAME <- NAMES[[kk]]
[08:27:57.497]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.497]                     next
[08:27:57.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.497]                 }
[08:27:57.497]                 if (length(args) > 0) 
[08:27:57.497]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.497]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.497]             }
[08:27:57.497]             else {
[08:27:57.497]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.497]             }
[08:27:57.497]             {
[08:27:57.497]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.497]                   0L) {
[08:27:57.497]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.497]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.497]                   base::options(opts)
[08:27:57.497]                 }
[08:27:57.497]                 {
[08:27:57.497]                   {
[08:27:57.497]                     NULL
[08:27:57.497]                     RNGkind("Mersenne-Twister")
[08:27:57.497]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:57.497]                       inherits = FALSE)
[08:27:57.497]                   }
[08:27:57.497]                   options(future.plan = NULL)
[08:27:57.497]                   if (is.na(NA_character_)) 
[08:27:57.497]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.497]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.497]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.497]                     .init = FALSE)
[08:27:57.497]                 }
[08:27:57.497]             }
[08:27:57.497]         }
[08:27:57.497]     })
[08:27:57.497]     if (TRUE) {
[08:27:57.497]         base::sink(type = "output", split = FALSE)
[08:27:57.497]         if (TRUE) {
[08:27:57.497]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.497]         }
[08:27:57.497]         else {
[08:27:57.497]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.497]         }
[08:27:57.497]         base::close(...future.stdout)
[08:27:57.497]         ...future.stdout <- NULL
[08:27:57.497]     }
[08:27:57.497]     ...future.result$conditions <- ...future.conditions
[08:27:57.497]     ...future.result$finished <- base::Sys.time()
[08:27:57.497]     ...future.result
[08:27:57.497] }
[08:27:57.499] assign_globals() ...
[08:27:57.499] List of 1
[08:27:57.499]  $ x: num [1:5] 1 1 2 2 2
[08:27:57.499]  - attr(*, "where")=List of 1
[08:27:57.499]   ..$ x:<environment: R_EmptyEnv> 
[08:27:57.499]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:57.499]  - attr(*, "resolved")= logi FALSE
[08:27:57.499]  - attr(*, "total_size")= num 71
[08:27:57.499]  - attr(*, "already-done")= logi TRUE
[08:27:57.501] - copied ‘x’ to environment
[08:27:57.502] assign_globals() ... done
[08:27:57.502] plan(): Setting new future strategy stack:
[08:27:57.502] List of future strategies:
[08:27:57.502] 1. sequential:
[08:27:57.502]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.502]    - tweaked: FALSE
[08:27:57.502]    - call: NULL
[08:27:57.502] plan(): nbrOfWorkers() = 1
[08:27:57.503] plan(): Setting new future strategy stack:
[08:27:57.503] List of future strategies:
[08:27:57.503] 1. sequential:
[08:27:57.503]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.503]    - tweaked: FALSE
[08:27:57.503]    - call: plan(strategy)
[08:27:57.504] plan(): nbrOfWorkers() = 1
[08:27:57.504] SequentialFuture started (and completed)
[08:27:57.504] - Launch lazy future ... done
[08:27:57.504] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[08:27:57.506] getGlobalsAndPackages() ...
[08:27:57.506] Searching for globals...
[08:27:57.507] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[08:27:57.508] Searching for globals ... DONE
[08:27:57.508] Resolving globals: FALSE
[08:27:57.508] 
[08:27:57.508] - packages: [2] ‘stats’, ‘datasets’
[08:27:57.510] getGlobalsAndPackages() ... DONE
[08:27:57.510] run() for ‘Future’ ...
[08:27:57.510] - state: ‘created’
[08:27:57.510] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:57.510] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:57.510] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:57.511]   - Field: ‘label’
[08:27:57.511]   - Field: ‘local’
[08:27:57.511]   - Field: ‘owner’
[08:27:57.511]   - Field: ‘envir’
[08:27:57.511]   - Field: ‘packages’
[08:27:57.511]   - Field: ‘gc’
[08:27:57.511]   - Field: ‘conditions’
[08:27:57.511]   - Field: ‘expr’
[08:27:57.511]   - Field: ‘uuid’
[08:27:57.511]   - Field: ‘seed’
[08:27:57.511]   - Field: ‘version’
[08:27:57.512]   - Field: ‘result’
[08:27:57.512]   - Field: ‘asynchronous’
[08:27:57.512]   - Field: ‘calls’
[08:27:57.512]   - Field: ‘globals’
[08:27:57.512]   - Field: ‘stdout’
[08:27:57.512]   - Field: ‘earlySignal’
[08:27:57.512]   - Field: ‘lazy’
[08:27:57.512]   - Field: ‘state’
[08:27:57.512] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:57.512] - Launch lazy future ...
[08:27:57.512] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[08:27:57.513] Packages needed by future strategies (n = 0): <none>
[08:27:57.513] {
[08:27:57.513]     {
[08:27:57.513]         {
[08:27:57.513]             ...future.startTime <- base::Sys.time()
[08:27:57.513]             {
[08:27:57.513]                 {
[08:27:57.513]                   {
[08:27:57.513]                     {
[08:27:57.513]                       base::local({
[08:27:57.513]                         has_future <- base::requireNamespace("future", 
[08:27:57.513]                           quietly = TRUE)
[08:27:57.513]                         if (has_future) {
[08:27:57.513]                           ns <- base::getNamespace("future")
[08:27:57.513]                           version <- ns[[".package"]][["version"]]
[08:27:57.513]                           if (is.null(version)) 
[08:27:57.513]                             version <- utils::packageVersion("future")
[08:27:57.513]                         }
[08:27:57.513]                         else {
[08:27:57.513]                           version <- NULL
[08:27:57.513]                         }
[08:27:57.513]                         if (!has_future || version < "1.8.0") {
[08:27:57.513]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.513]                             "", base::R.version$version.string), 
[08:27:57.513]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:57.513]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:57.513]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.513]                               "release", "version")], collapse = " "), 
[08:27:57.513]                             hostname = base::Sys.info()[["nodename"]])
[08:27:57.513]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.513]                             info)
[08:27:57.513]                           info <- base::paste(info, collapse = "; ")
[08:27:57.513]                           if (!has_future) {
[08:27:57.513]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.513]                               info)
[08:27:57.513]                           }
[08:27:57.513]                           else {
[08:27:57.513]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.513]                               info, version)
[08:27:57.513]                           }
[08:27:57.513]                           base::stop(msg)
[08:27:57.513]                         }
[08:27:57.513]                       })
[08:27:57.513]                     }
[08:27:57.513]                     base::local({
[08:27:57.513]                       for (pkg in c("stats", "datasets")) {
[08:27:57.513]                         base::loadNamespace(pkg)
[08:27:57.513]                         base::library(pkg, character.only = TRUE)
[08:27:57.513]                       }
[08:27:57.513]                     })
[08:27:57.513]                   }
[08:27:57.513]                   ...future.strategy.old <- future::plan("list")
[08:27:57.513]                   options(future.plan = NULL)
[08:27:57.513]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.513]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.513]                 }
[08:27:57.513]                 ...future.workdir <- getwd()
[08:27:57.513]             }
[08:27:57.513]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.513]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.513]         }
[08:27:57.513]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.513]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.513]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.513]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.513]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.513]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.513]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.513]             base::names(...future.oldOptions))
[08:27:57.513]     }
[08:27:57.513]     if (FALSE) {
[08:27:57.513]     }
[08:27:57.513]     else {
[08:27:57.513]         if (TRUE) {
[08:27:57.513]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.513]                 open = "w")
[08:27:57.513]         }
[08:27:57.513]         else {
[08:27:57.513]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.513]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.513]         }
[08:27:57.513]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.513]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.513]             base::sink(type = "output", split = FALSE)
[08:27:57.513]             base::close(...future.stdout)
[08:27:57.513]         }, add = TRUE)
[08:27:57.513]     }
[08:27:57.513]     ...future.frame <- base::sys.nframe()
[08:27:57.513]     ...future.conditions <- base::list()
[08:27:57.513]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.513]     if (FALSE) {
[08:27:57.513]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.513]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.513]     }
[08:27:57.513]     ...future.result <- base::tryCatch({
[08:27:57.513]         base::withCallingHandlers({
[08:27:57.513]             ...future.value <- base::withVisible(base::local({
[08:27:57.513]                 lm(dist ~ . - 1, data = cars)
[08:27:57.513]             }))
[08:27:57.513]             future::FutureResult(value = ...future.value$value, 
[08:27:57.513]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.513]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.513]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.513]                     ...future.globalenv.names))
[08:27:57.513]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.513]         }, condition = base::local({
[08:27:57.513]             c <- base::c
[08:27:57.513]             inherits <- base::inherits
[08:27:57.513]             invokeRestart <- base::invokeRestart
[08:27:57.513]             length <- base::length
[08:27:57.513]             list <- base::list
[08:27:57.513]             seq.int <- base::seq.int
[08:27:57.513]             signalCondition <- base::signalCondition
[08:27:57.513]             sys.calls <- base::sys.calls
[08:27:57.513]             `[[` <- base::`[[`
[08:27:57.513]             `+` <- base::`+`
[08:27:57.513]             `<<-` <- base::`<<-`
[08:27:57.513]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.513]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.513]                   3L)]
[08:27:57.513]             }
[08:27:57.513]             function(cond) {
[08:27:57.513]                 is_error <- inherits(cond, "error")
[08:27:57.513]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.513]                   NULL)
[08:27:57.513]                 if (is_error) {
[08:27:57.513]                   sessionInformation <- function() {
[08:27:57.513]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.513]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.513]                       search = base::search(), system = base::Sys.info())
[08:27:57.513]                   }
[08:27:57.513]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.513]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.513]                     cond$call), session = sessionInformation(), 
[08:27:57.513]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.513]                   signalCondition(cond)
[08:27:57.513]                 }
[08:27:57.513]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.513]                 "immediateCondition"))) {
[08:27:57.513]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.513]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.513]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.513]                   if (TRUE && !signal) {
[08:27:57.513]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.513]                     {
[08:27:57.513]                       inherits <- base::inherits
[08:27:57.513]                       invokeRestart <- base::invokeRestart
[08:27:57.513]                       is.null <- base::is.null
[08:27:57.513]                       muffled <- FALSE
[08:27:57.513]                       if (inherits(cond, "message")) {
[08:27:57.513]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.513]                         if (muffled) 
[08:27:57.513]                           invokeRestart("muffleMessage")
[08:27:57.513]                       }
[08:27:57.513]                       else if (inherits(cond, "warning")) {
[08:27:57.513]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.513]                         if (muffled) 
[08:27:57.513]                           invokeRestart("muffleWarning")
[08:27:57.513]                       }
[08:27:57.513]                       else if (inherits(cond, "condition")) {
[08:27:57.513]                         if (!is.null(pattern)) {
[08:27:57.513]                           computeRestarts <- base::computeRestarts
[08:27:57.513]                           grepl <- base::grepl
[08:27:57.513]                           restarts <- computeRestarts(cond)
[08:27:57.513]                           for (restart in restarts) {
[08:27:57.513]                             name <- restart$name
[08:27:57.513]                             if (is.null(name)) 
[08:27:57.513]                               next
[08:27:57.513]                             if (!grepl(pattern, name)) 
[08:27:57.513]                               next
[08:27:57.513]                             invokeRestart(restart)
[08:27:57.513]                             muffled <- TRUE
[08:27:57.513]                             break
[08:27:57.513]                           }
[08:27:57.513]                         }
[08:27:57.513]                       }
[08:27:57.513]                       invisible(muffled)
[08:27:57.513]                     }
[08:27:57.513]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.513]                   }
[08:27:57.513]                 }
[08:27:57.513]                 else {
[08:27:57.513]                   if (TRUE) {
[08:27:57.513]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.513]                     {
[08:27:57.513]                       inherits <- base::inherits
[08:27:57.513]                       invokeRestart <- base::invokeRestart
[08:27:57.513]                       is.null <- base::is.null
[08:27:57.513]                       muffled <- FALSE
[08:27:57.513]                       if (inherits(cond, "message")) {
[08:27:57.513]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.513]                         if (muffled) 
[08:27:57.513]                           invokeRestart("muffleMessage")
[08:27:57.513]                       }
[08:27:57.513]                       else if (inherits(cond, "warning")) {
[08:27:57.513]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.513]                         if (muffled) 
[08:27:57.513]                           invokeRestart("muffleWarning")
[08:27:57.513]                       }
[08:27:57.513]                       else if (inherits(cond, "condition")) {
[08:27:57.513]                         if (!is.null(pattern)) {
[08:27:57.513]                           computeRestarts <- base::computeRestarts
[08:27:57.513]                           grepl <- base::grepl
[08:27:57.513]                           restarts <- computeRestarts(cond)
[08:27:57.513]                           for (restart in restarts) {
[08:27:57.513]                             name <- restart$name
[08:27:57.513]                             if (is.null(name)) 
[08:27:57.513]                               next
[08:27:57.513]                             if (!grepl(pattern, name)) 
[08:27:57.513]                               next
[08:27:57.513]                             invokeRestart(restart)
[08:27:57.513]                             muffled <- TRUE
[08:27:57.513]                             break
[08:27:57.513]                           }
[08:27:57.513]                         }
[08:27:57.513]                       }
[08:27:57.513]                       invisible(muffled)
[08:27:57.513]                     }
[08:27:57.513]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.513]                   }
[08:27:57.513]                 }
[08:27:57.513]             }
[08:27:57.513]         }))
[08:27:57.513]     }, error = function(ex) {
[08:27:57.513]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.513]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.513]                 ...future.rng), started = ...future.startTime, 
[08:27:57.513]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.513]             version = "1.8"), class = "FutureResult")
[08:27:57.513]     }, finally = {
[08:27:57.513]         if (!identical(...future.workdir, getwd())) 
[08:27:57.513]             setwd(...future.workdir)
[08:27:57.513]         {
[08:27:57.513]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.513]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.513]             }
[08:27:57.513]             base::options(...future.oldOptions)
[08:27:57.513]             if (.Platform$OS.type == "windows") {
[08:27:57.513]                 old_names <- names(...future.oldEnvVars)
[08:27:57.513]                 envs <- base::Sys.getenv()
[08:27:57.513]                 names <- names(envs)
[08:27:57.513]                 common <- intersect(names, old_names)
[08:27:57.513]                 added <- setdiff(names, old_names)
[08:27:57.513]                 removed <- setdiff(old_names, names)
[08:27:57.513]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.513]                   envs[common]]
[08:27:57.513]                 NAMES <- toupper(changed)
[08:27:57.513]                 args <- list()
[08:27:57.513]                 for (kk in seq_along(NAMES)) {
[08:27:57.513]                   name <- changed[[kk]]
[08:27:57.513]                   NAME <- NAMES[[kk]]
[08:27:57.513]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.513]                     next
[08:27:57.513]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.513]                 }
[08:27:57.513]                 NAMES <- toupper(added)
[08:27:57.513]                 for (kk in seq_along(NAMES)) {
[08:27:57.513]                   name <- added[[kk]]
[08:27:57.513]                   NAME <- NAMES[[kk]]
[08:27:57.513]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.513]                     next
[08:27:57.513]                   args[[name]] <- ""
[08:27:57.513]                 }
[08:27:57.513]                 NAMES <- toupper(removed)
[08:27:57.513]                 for (kk in seq_along(NAMES)) {
[08:27:57.513]                   name <- removed[[kk]]
[08:27:57.513]                   NAME <- NAMES[[kk]]
[08:27:57.513]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.513]                     next
[08:27:57.513]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.513]                 }
[08:27:57.513]                 if (length(args) > 0) 
[08:27:57.513]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.513]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.513]             }
[08:27:57.513]             else {
[08:27:57.513]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.513]             }
[08:27:57.513]             {
[08:27:57.513]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.513]                   0L) {
[08:27:57.513]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.513]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.513]                   base::options(opts)
[08:27:57.513]                 }
[08:27:57.513]                 {
[08:27:57.513]                   {
[08:27:57.513]                     NULL
[08:27:57.513]                     RNGkind("Mersenne-Twister")
[08:27:57.513]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:57.513]                       inherits = FALSE)
[08:27:57.513]                   }
[08:27:57.513]                   options(future.plan = NULL)
[08:27:57.513]                   if (is.na(NA_character_)) 
[08:27:57.513]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.513]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.513]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.513]                     .init = FALSE)
[08:27:57.513]                 }
[08:27:57.513]             }
[08:27:57.513]         }
[08:27:57.513]     })
[08:27:57.513]     if (TRUE) {
[08:27:57.513]         base::sink(type = "output", split = FALSE)
[08:27:57.513]         if (TRUE) {
[08:27:57.513]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.513]         }
[08:27:57.513]         else {
[08:27:57.513]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.513]         }
[08:27:57.513]         base::close(...future.stdout)
[08:27:57.513]         ...future.stdout <- NULL
[08:27:57.513]     }
[08:27:57.513]     ...future.result$conditions <- ...future.conditions
[08:27:57.513]     ...future.result$finished <- base::Sys.time()
[08:27:57.513]     ...future.result
[08:27:57.513] }
[08:27:57.515] plan(): Setting new future strategy stack:
[08:27:57.515] List of future strategies:
[08:27:57.515] 1. sequential:
[08:27:57.515]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.515]    - tweaked: FALSE
[08:27:57.515]    - call: NULL
[08:27:57.516] plan(): nbrOfWorkers() = 1
[08:27:57.517] plan(): Setting new future strategy stack:
[08:27:57.517] List of future strategies:
[08:27:57.517] 1. sequential:
[08:27:57.517]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.517]    - tweaked: FALSE
[08:27:57.517]    - call: plan(strategy)
[08:27:57.517] plan(): nbrOfWorkers() = 1
[08:27:57.517] SequentialFuture started (and completed)
[08:27:57.518] - Launch lazy future ... done
[08:27:57.518] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[08:27:57.520] getGlobalsAndPackages() ...
[08:27:57.520] Searching for globals...
[08:27:57.521] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[08:27:57.522] Searching for globals ... DONE
[08:27:57.522] Resolving globals: FALSE
[08:27:57.522] 
[08:27:57.522] - packages: [2] ‘stats’, ‘datasets’
[08:27:57.522] getGlobalsAndPackages() ... DONE
[08:27:57.522] run() for ‘Future’ ...
[08:27:57.523] - state: ‘created’
[08:27:57.523] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:57.523] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:57.523] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:57.523]   - Field: ‘label’
[08:27:57.523]   - Field: ‘local’
[08:27:57.523]   - Field: ‘owner’
[08:27:57.523]   - Field: ‘envir’
[08:27:57.523]   - Field: ‘packages’
[08:27:57.524]   - Field: ‘gc’
[08:27:57.524]   - Field: ‘conditions’
[08:27:57.524]   - Field: ‘expr’
[08:27:57.524]   - Field: ‘uuid’
[08:27:57.524]   - Field: ‘seed’
[08:27:57.524]   - Field: ‘version’
[08:27:57.524]   - Field: ‘result’
[08:27:57.524]   - Field: ‘asynchronous’
[08:27:57.524]   - Field: ‘calls’
[08:27:57.524]   - Field: ‘globals’
[08:27:57.524]   - Field: ‘stdout’
[08:27:57.524]   - Field: ‘earlySignal’
[08:27:57.525]   - Field: ‘lazy’
[08:27:57.525]   - Field: ‘state’
[08:27:57.525] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:57.525] - Launch lazy future ...
[08:27:57.525] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[08:27:57.525] Packages needed by future strategies (n = 0): <none>
[08:27:57.526] {
[08:27:57.526]     {
[08:27:57.526]         {
[08:27:57.526]             ...future.startTime <- base::Sys.time()
[08:27:57.526]             {
[08:27:57.526]                 {
[08:27:57.526]                   {
[08:27:57.526]                     {
[08:27:57.526]                       base::local({
[08:27:57.526]                         has_future <- base::requireNamespace("future", 
[08:27:57.526]                           quietly = TRUE)
[08:27:57.526]                         if (has_future) {
[08:27:57.526]                           ns <- base::getNamespace("future")
[08:27:57.526]                           version <- ns[[".package"]][["version"]]
[08:27:57.526]                           if (is.null(version)) 
[08:27:57.526]                             version <- utils::packageVersion("future")
[08:27:57.526]                         }
[08:27:57.526]                         else {
[08:27:57.526]                           version <- NULL
[08:27:57.526]                         }
[08:27:57.526]                         if (!has_future || version < "1.8.0") {
[08:27:57.526]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.526]                             "", base::R.version$version.string), 
[08:27:57.526]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:57.526]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:57.526]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.526]                               "release", "version")], collapse = " "), 
[08:27:57.526]                             hostname = base::Sys.info()[["nodename"]])
[08:27:57.526]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.526]                             info)
[08:27:57.526]                           info <- base::paste(info, collapse = "; ")
[08:27:57.526]                           if (!has_future) {
[08:27:57.526]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.526]                               info)
[08:27:57.526]                           }
[08:27:57.526]                           else {
[08:27:57.526]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.526]                               info, version)
[08:27:57.526]                           }
[08:27:57.526]                           base::stop(msg)
[08:27:57.526]                         }
[08:27:57.526]                       })
[08:27:57.526]                     }
[08:27:57.526]                     base::local({
[08:27:57.526]                       for (pkg in c("stats", "datasets")) {
[08:27:57.526]                         base::loadNamespace(pkg)
[08:27:57.526]                         base::library(pkg, character.only = TRUE)
[08:27:57.526]                       }
[08:27:57.526]                     })
[08:27:57.526]                   }
[08:27:57.526]                   ...future.strategy.old <- future::plan("list")
[08:27:57.526]                   options(future.plan = NULL)
[08:27:57.526]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.526]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.526]                 }
[08:27:57.526]                 ...future.workdir <- getwd()
[08:27:57.526]             }
[08:27:57.526]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.526]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.526]         }
[08:27:57.526]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.526]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.526]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.526]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.526]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.526]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.526]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.526]             base::names(...future.oldOptions))
[08:27:57.526]     }
[08:27:57.526]     if (FALSE) {
[08:27:57.526]     }
[08:27:57.526]     else {
[08:27:57.526]         if (TRUE) {
[08:27:57.526]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.526]                 open = "w")
[08:27:57.526]         }
[08:27:57.526]         else {
[08:27:57.526]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.526]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.526]         }
[08:27:57.526]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.526]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.526]             base::sink(type = "output", split = FALSE)
[08:27:57.526]             base::close(...future.stdout)
[08:27:57.526]         }, add = TRUE)
[08:27:57.526]     }
[08:27:57.526]     ...future.frame <- base::sys.nframe()
[08:27:57.526]     ...future.conditions <- base::list()
[08:27:57.526]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.526]     if (FALSE) {
[08:27:57.526]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.526]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.526]     }
[08:27:57.526]     ...future.result <- base::tryCatch({
[08:27:57.526]         base::withCallingHandlers({
[08:27:57.526]             ...future.value <- base::withVisible(base::local({
[08:27:57.526]                 lm(dist ~ . + 0, data = cars)
[08:27:57.526]             }))
[08:27:57.526]             future::FutureResult(value = ...future.value$value, 
[08:27:57.526]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.526]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.526]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.526]                     ...future.globalenv.names))
[08:27:57.526]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.526]         }, condition = base::local({
[08:27:57.526]             c <- base::c
[08:27:57.526]             inherits <- base::inherits
[08:27:57.526]             invokeRestart <- base::invokeRestart
[08:27:57.526]             length <- base::length
[08:27:57.526]             list <- base::list
[08:27:57.526]             seq.int <- base::seq.int
[08:27:57.526]             signalCondition <- base::signalCondition
[08:27:57.526]             sys.calls <- base::sys.calls
[08:27:57.526]             `[[` <- base::`[[`
[08:27:57.526]             `+` <- base::`+`
[08:27:57.526]             `<<-` <- base::`<<-`
[08:27:57.526]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.526]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.526]                   3L)]
[08:27:57.526]             }
[08:27:57.526]             function(cond) {
[08:27:57.526]                 is_error <- inherits(cond, "error")
[08:27:57.526]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.526]                   NULL)
[08:27:57.526]                 if (is_error) {
[08:27:57.526]                   sessionInformation <- function() {
[08:27:57.526]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.526]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.526]                       search = base::search(), system = base::Sys.info())
[08:27:57.526]                   }
[08:27:57.526]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.526]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.526]                     cond$call), session = sessionInformation(), 
[08:27:57.526]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.526]                   signalCondition(cond)
[08:27:57.526]                 }
[08:27:57.526]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.526]                 "immediateCondition"))) {
[08:27:57.526]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.526]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.526]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.526]                   if (TRUE && !signal) {
[08:27:57.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.526]                     {
[08:27:57.526]                       inherits <- base::inherits
[08:27:57.526]                       invokeRestart <- base::invokeRestart
[08:27:57.526]                       is.null <- base::is.null
[08:27:57.526]                       muffled <- FALSE
[08:27:57.526]                       if (inherits(cond, "message")) {
[08:27:57.526]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.526]                         if (muffled) 
[08:27:57.526]                           invokeRestart("muffleMessage")
[08:27:57.526]                       }
[08:27:57.526]                       else if (inherits(cond, "warning")) {
[08:27:57.526]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.526]                         if (muffled) 
[08:27:57.526]                           invokeRestart("muffleWarning")
[08:27:57.526]                       }
[08:27:57.526]                       else if (inherits(cond, "condition")) {
[08:27:57.526]                         if (!is.null(pattern)) {
[08:27:57.526]                           computeRestarts <- base::computeRestarts
[08:27:57.526]                           grepl <- base::grepl
[08:27:57.526]                           restarts <- computeRestarts(cond)
[08:27:57.526]                           for (restart in restarts) {
[08:27:57.526]                             name <- restart$name
[08:27:57.526]                             if (is.null(name)) 
[08:27:57.526]                               next
[08:27:57.526]                             if (!grepl(pattern, name)) 
[08:27:57.526]                               next
[08:27:57.526]                             invokeRestart(restart)
[08:27:57.526]                             muffled <- TRUE
[08:27:57.526]                             break
[08:27:57.526]                           }
[08:27:57.526]                         }
[08:27:57.526]                       }
[08:27:57.526]                       invisible(muffled)
[08:27:57.526]                     }
[08:27:57.526]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.526]                   }
[08:27:57.526]                 }
[08:27:57.526]                 else {
[08:27:57.526]                   if (TRUE) {
[08:27:57.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.526]                     {
[08:27:57.526]                       inherits <- base::inherits
[08:27:57.526]                       invokeRestart <- base::invokeRestart
[08:27:57.526]                       is.null <- base::is.null
[08:27:57.526]                       muffled <- FALSE
[08:27:57.526]                       if (inherits(cond, "message")) {
[08:27:57.526]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.526]                         if (muffled) 
[08:27:57.526]                           invokeRestart("muffleMessage")
[08:27:57.526]                       }
[08:27:57.526]                       else if (inherits(cond, "warning")) {
[08:27:57.526]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.526]                         if (muffled) 
[08:27:57.526]                           invokeRestart("muffleWarning")
[08:27:57.526]                       }
[08:27:57.526]                       else if (inherits(cond, "condition")) {
[08:27:57.526]                         if (!is.null(pattern)) {
[08:27:57.526]                           computeRestarts <- base::computeRestarts
[08:27:57.526]                           grepl <- base::grepl
[08:27:57.526]                           restarts <- computeRestarts(cond)
[08:27:57.526]                           for (restart in restarts) {
[08:27:57.526]                             name <- restart$name
[08:27:57.526]                             if (is.null(name)) 
[08:27:57.526]                               next
[08:27:57.526]                             if (!grepl(pattern, name)) 
[08:27:57.526]                               next
[08:27:57.526]                             invokeRestart(restart)
[08:27:57.526]                             muffled <- TRUE
[08:27:57.526]                             break
[08:27:57.526]                           }
[08:27:57.526]                         }
[08:27:57.526]                       }
[08:27:57.526]                       invisible(muffled)
[08:27:57.526]                     }
[08:27:57.526]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.526]                   }
[08:27:57.526]                 }
[08:27:57.526]             }
[08:27:57.526]         }))
[08:27:57.526]     }, error = function(ex) {
[08:27:57.526]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.526]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.526]                 ...future.rng), started = ...future.startTime, 
[08:27:57.526]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.526]             version = "1.8"), class = "FutureResult")
[08:27:57.526]     }, finally = {
[08:27:57.526]         if (!identical(...future.workdir, getwd())) 
[08:27:57.526]             setwd(...future.workdir)
[08:27:57.526]         {
[08:27:57.526]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.526]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.526]             }
[08:27:57.526]             base::options(...future.oldOptions)
[08:27:57.526]             if (.Platform$OS.type == "windows") {
[08:27:57.526]                 old_names <- names(...future.oldEnvVars)
[08:27:57.526]                 envs <- base::Sys.getenv()
[08:27:57.526]                 names <- names(envs)
[08:27:57.526]                 common <- intersect(names, old_names)
[08:27:57.526]                 added <- setdiff(names, old_names)
[08:27:57.526]                 removed <- setdiff(old_names, names)
[08:27:57.526]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.526]                   envs[common]]
[08:27:57.526]                 NAMES <- toupper(changed)
[08:27:57.526]                 args <- list()
[08:27:57.526]                 for (kk in seq_along(NAMES)) {
[08:27:57.526]                   name <- changed[[kk]]
[08:27:57.526]                   NAME <- NAMES[[kk]]
[08:27:57.526]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.526]                     next
[08:27:57.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.526]                 }
[08:27:57.526]                 NAMES <- toupper(added)
[08:27:57.526]                 for (kk in seq_along(NAMES)) {
[08:27:57.526]                   name <- added[[kk]]
[08:27:57.526]                   NAME <- NAMES[[kk]]
[08:27:57.526]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.526]                     next
[08:27:57.526]                   args[[name]] <- ""
[08:27:57.526]                 }
[08:27:57.526]                 NAMES <- toupper(removed)
[08:27:57.526]                 for (kk in seq_along(NAMES)) {
[08:27:57.526]                   name <- removed[[kk]]
[08:27:57.526]                   NAME <- NAMES[[kk]]
[08:27:57.526]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.526]                     next
[08:27:57.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.526]                 }
[08:27:57.526]                 if (length(args) > 0) 
[08:27:57.526]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.526]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.526]             }
[08:27:57.526]             else {
[08:27:57.526]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.526]             }
[08:27:57.526]             {
[08:27:57.526]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.526]                   0L) {
[08:27:57.526]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.526]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.526]                   base::options(opts)
[08:27:57.526]                 }
[08:27:57.526]                 {
[08:27:57.526]                   {
[08:27:57.526]                     NULL
[08:27:57.526]                     RNGkind("Mersenne-Twister")
[08:27:57.526]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:57.526]                       inherits = FALSE)
[08:27:57.526]                   }
[08:27:57.526]                   options(future.plan = NULL)
[08:27:57.526]                   if (is.na(NA_character_)) 
[08:27:57.526]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.526]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.526]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.526]                     .init = FALSE)
[08:27:57.526]                 }
[08:27:57.526]             }
[08:27:57.526]         }
[08:27:57.526]     })
[08:27:57.526]     if (TRUE) {
[08:27:57.526]         base::sink(type = "output", split = FALSE)
[08:27:57.526]         if (TRUE) {
[08:27:57.526]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.526]         }
[08:27:57.526]         else {
[08:27:57.526]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.526]         }
[08:27:57.526]         base::close(...future.stdout)
[08:27:57.526]         ...future.stdout <- NULL
[08:27:57.526]     }
[08:27:57.526]     ...future.result$conditions <- ...future.conditions
[08:27:57.526]     ...future.result$finished <- base::Sys.time()
[08:27:57.526]     ...future.result
[08:27:57.526] }
[08:27:57.528] plan(): Setting new future strategy stack:
[08:27:57.528] List of future strategies:
[08:27:57.528] 1. sequential:
[08:27:57.528]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.528]    - tweaked: FALSE
[08:27:57.528]    - call: NULL
[08:27:57.528] plan(): nbrOfWorkers() = 1
[08:27:57.529] plan(): Setting new future strategy stack:
[08:27:57.529] List of future strategies:
[08:27:57.529] 1. sequential:
[08:27:57.529]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.529]    - tweaked: FALSE
[08:27:57.529]    - call: plan(strategy)
[08:27:57.530] plan(): nbrOfWorkers() = 1
[08:27:57.530] SequentialFuture started (and completed)
[08:27:57.530] - Launch lazy future ... done
[08:27:57.530] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[08:27:57.532] getGlobalsAndPackages() ...
[08:27:57.532] Searching for globals...
[08:27:57.535] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[08:27:57.536] Searching for globals ... DONE
[08:27:57.536] Resolving globals: FALSE
[08:27:57.536] 
[08:27:57.536] - packages: [2] ‘stats’, ‘datasets’
[08:27:57.536] getGlobalsAndPackages() ... DONE
[08:27:57.537] run() for ‘Future’ ...
[08:27:57.537] - state: ‘created’
[08:27:57.537] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:57.537] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:57.537] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:57.537]   - Field: ‘label’
[08:27:57.537]   - Field: ‘local’
[08:27:57.537]   - Field: ‘owner’
[08:27:57.538]   - Field: ‘envir’
[08:27:57.538]   - Field: ‘packages’
[08:27:57.538]   - Field: ‘gc’
[08:27:57.538]   - Field: ‘conditions’
[08:27:57.538]   - Field: ‘expr’
[08:27:57.538]   - Field: ‘uuid’
[08:27:57.538]   - Field: ‘seed’
[08:27:57.538]   - Field: ‘version’
[08:27:57.538]   - Field: ‘result’
[08:27:57.538]   - Field: ‘asynchronous’
[08:27:57.538]   - Field: ‘calls’
[08:27:57.538]   - Field: ‘globals’
[08:27:57.539]   - Field: ‘stdout’
[08:27:57.539]   - Field: ‘earlySignal’
[08:27:57.539]   - Field: ‘lazy’
[08:27:57.539]   - Field: ‘state’
[08:27:57.539] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:57.539] - Launch lazy future ...
[08:27:57.539] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[08:27:57.539] Packages needed by future strategies (n = 0): <none>
[08:27:57.540] {
[08:27:57.540]     {
[08:27:57.540]         {
[08:27:57.540]             ...future.startTime <- base::Sys.time()
[08:27:57.540]             {
[08:27:57.540]                 {
[08:27:57.540]                   {
[08:27:57.540]                     {
[08:27:57.540]                       base::local({
[08:27:57.540]                         has_future <- base::requireNamespace("future", 
[08:27:57.540]                           quietly = TRUE)
[08:27:57.540]                         if (has_future) {
[08:27:57.540]                           ns <- base::getNamespace("future")
[08:27:57.540]                           version <- ns[[".package"]][["version"]]
[08:27:57.540]                           if (is.null(version)) 
[08:27:57.540]                             version <- utils::packageVersion("future")
[08:27:57.540]                         }
[08:27:57.540]                         else {
[08:27:57.540]                           version <- NULL
[08:27:57.540]                         }
[08:27:57.540]                         if (!has_future || version < "1.8.0") {
[08:27:57.540]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.540]                             "", base::R.version$version.string), 
[08:27:57.540]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:57.540]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:57.540]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.540]                               "release", "version")], collapse = " "), 
[08:27:57.540]                             hostname = base::Sys.info()[["nodename"]])
[08:27:57.540]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.540]                             info)
[08:27:57.540]                           info <- base::paste(info, collapse = "; ")
[08:27:57.540]                           if (!has_future) {
[08:27:57.540]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.540]                               info)
[08:27:57.540]                           }
[08:27:57.540]                           else {
[08:27:57.540]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.540]                               info, version)
[08:27:57.540]                           }
[08:27:57.540]                           base::stop(msg)
[08:27:57.540]                         }
[08:27:57.540]                       })
[08:27:57.540]                     }
[08:27:57.540]                     base::local({
[08:27:57.540]                       for (pkg in c("stats", "datasets")) {
[08:27:57.540]                         base::loadNamespace(pkg)
[08:27:57.540]                         base::library(pkg, character.only = TRUE)
[08:27:57.540]                       }
[08:27:57.540]                     })
[08:27:57.540]                   }
[08:27:57.540]                   ...future.strategy.old <- future::plan("list")
[08:27:57.540]                   options(future.plan = NULL)
[08:27:57.540]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.540]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.540]                 }
[08:27:57.540]                 ...future.workdir <- getwd()
[08:27:57.540]             }
[08:27:57.540]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.540]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.540]         }
[08:27:57.540]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.540]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.540]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.540]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.540]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.540]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.540]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.540]             base::names(...future.oldOptions))
[08:27:57.540]     }
[08:27:57.540]     if (FALSE) {
[08:27:57.540]     }
[08:27:57.540]     else {
[08:27:57.540]         if (TRUE) {
[08:27:57.540]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.540]                 open = "w")
[08:27:57.540]         }
[08:27:57.540]         else {
[08:27:57.540]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.540]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.540]         }
[08:27:57.540]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.540]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.540]             base::sink(type = "output", split = FALSE)
[08:27:57.540]             base::close(...future.stdout)
[08:27:57.540]         }, add = TRUE)
[08:27:57.540]     }
[08:27:57.540]     ...future.frame <- base::sys.nframe()
[08:27:57.540]     ...future.conditions <- base::list()
[08:27:57.540]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.540]     if (FALSE) {
[08:27:57.540]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.540]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.540]     }
[08:27:57.540]     ...future.result <- base::tryCatch({
[08:27:57.540]         base::withCallingHandlers({
[08:27:57.540]             ...future.value <- base::withVisible(base::local({
[08:27:57.540]                 lm(dist ~ speed + speed^2, data = cars)
[08:27:57.540]             }))
[08:27:57.540]             future::FutureResult(value = ...future.value$value, 
[08:27:57.540]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.540]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.540]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.540]                     ...future.globalenv.names))
[08:27:57.540]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.540]         }, condition = base::local({
[08:27:57.540]             c <- base::c
[08:27:57.540]             inherits <- base::inherits
[08:27:57.540]             invokeRestart <- base::invokeRestart
[08:27:57.540]             length <- base::length
[08:27:57.540]             list <- base::list
[08:27:57.540]             seq.int <- base::seq.int
[08:27:57.540]             signalCondition <- base::signalCondition
[08:27:57.540]             sys.calls <- base::sys.calls
[08:27:57.540]             `[[` <- base::`[[`
[08:27:57.540]             `+` <- base::`+`
[08:27:57.540]             `<<-` <- base::`<<-`
[08:27:57.540]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.540]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.540]                   3L)]
[08:27:57.540]             }
[08:27:57.540]             function(cond) {
[08:27:57.540]                 is_error <- inherits(cond, "error")
[08:27:57.540]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.540]                   NULL)
[08:27:57.540]                 if (is_error) {
[08:27:57.540]                   sessionInformation <- function() {
[08:27:57.540]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.540]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.540]                       search = base::search(), system = base::Sys.info())
[08:27:57.540]                   }
[08:27:57.540]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.540]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.540]                     cond$call), session = sessionInformation(), 
[08:27:57.540]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.540]                   signalCondition(cond)
[08:27:57.540]                 }
[08:27:57.540]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.540]                 "immediateCondition"))) {
[08:27:57.540]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.540]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.540]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.540]                   if (TRUE && !signal) {
[08:27:57.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.540]                     {
[08:27:57.540]                       inherits <- base::inherits
[08:27:57.540]                       invokeRestart <- base::invokeRestart
[08:27:57.540]                       is.null <- base::is.null
[08:27:57.540]                       muffled <- FALSE
[08:27:57.540]                       if (inherits(cond, "message")) {
[08:27:57.540]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.540]                         if (muffled) 
[08:27:57.540]                           invokeRestart("muffleMessage")
[08:27:57.540]                       }
[08:27:57.540]                       else if (inherits(cond, "warning")) {
[08:27:57.540]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.540]                         if (muffled) 
[08:27:57.540]                           invokeRestart("muffleWarning")
[08:27:57.540]                       }
[08:27:57.540]                       else if (inherits(cond, "condition")) {
[08:27:57.540]                         if (!is.null(pattern)) {
[08:27:57.540]                           computeRestarts <- base::computeRestarts
[08:27:57.540]                           grepl <- base::grepl
[08:27:57.540]                           restarts <- computeRestarts(cond)
[08:27:57.540]                           for (restart in restarts) {
[08:27:57.540]                             name <- restart$name
[08:27:57.540]                             if (is.null(name)) 
[08:27:57.540]                               next
[08:27:57.540]                             if (!grepl(pattern, name)) 
[08:27:57.540]                               next
[08:27:57.540]                             invokeRestart(restart)
[08:27:57.540]                             muffled <- TRUE
[08:27:57.540]                             break
[08:27:57.540]                           }
[08:27:57.540]                         }
[08:27:57.540]                       }
[08:27:57.540]                       invisible(muffled)
[08:27:57.540]                     }
[08:27:57.540]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.540]                   }
[08:27:57.540]                 }
[08:27:57.540]                 else {
[08:27:57.540]                   if (TRUE) {
[08:27:57.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.540]                     {
[08:27:57.540]                       inherits <- base::inherits
[08:27:57.540]                       invokeRestart <- base::invokeRestart
[08:27:57.540]                       is.null <- base::is.null
[08:27:57.540]                       muffled <- FALSE
[08:27:57.540]                       if (inherits(cond, "message")) {
[08:27:57.540]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.540]                         if (muffled) 
[08:27:57.540]                           invokeRestart("muffleMessage")
[08:27:57.540]                       }
[08:27:57.540]                       else if (inherits(cond, "warning")) {
[08:27:57.540]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.540]                         if (muffled) 
[08:27:57.540]                           invokeRestart("muffleWarning")
[08:27:57.540]                       }
[08:27:57.540]                       else if (inherits(cond, "condition")) {
[08:27:57.540]                         if (!is.null(pattern)) {
[08:27:57.540]                           computeRestarts <- base::computeRestarts
[08:27:57.540]                           grepl <- base::grepl
[08:27:57.540]                           restarts <- computeRestarts(cond)
[08:27:57.540]                           for (restart in restarts) {
[08:27:57.540]                             name <- restart$name
[08:27:57.540]                             if (is.null(name)) 
[08:27:57.540]                               next
[08:27:57.540]                             if (!grepl(pattern, name)) 
[08:27:57.540]                               next
[08:27:57.540]                             invokeRestart(restart)
[08:27:57.540]                             muffled <- TRUE
[08:27:57.540]                             break
[08:27:57.540]                           }
[08:27:57.540]                         }
[08:27:57.540]                       }
[08:27:57.540]                       invisible(muffled)
[08:27:57.540]                     }
[08:27:57.540]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.540]                   }
[08:27:57.540]                 }
[08:27:57.540]             }
[08:27:57.540]         }))
[08:27:57.540]     }, error = function(ex) {
[08:27:57.540]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.540]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.540]                 ...future.rng), started = ...future.startTime, 
[08:27:57.540]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.540]             version = "1.8"), class = "FutureResult")
[08:27:57.540]     }, finally = {
[08:27:57.540]         if (!identical(...future.workdir, getwd())) 
[08:27:57.540]             setwd(...future.workdir)
[08:27:57.540]         {
[08:27:57.540]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.540]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.540]             }
[08:27:57.540]             base::options(...future.oldOptions)
[08:27:57.540]             if (.Platform$OS.type == "windows") {
[08:27:57.540]                 old_names <- names(...future.oldEnvVars)
[08:27:57.540]                 envs <- base::Sys.getenv()
[08:27:57.540]                 names <- names(envs)
[08:27:57.540]                 common <- intersect(names, old_names)
[08:27:57.540]                 added <- setdiff(names, old_names)
[08:27:57.540]                 removed <- setdiff(old_names, names)
[08:27:57.540]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.540]                   envs[common]]
[08:27:57.540]                 NAMES <- toupper(changed)
[08:27:57.540]                 args <- list()
[08:27:57.540]                 for (kk in seq_along(NAMES)) {
[08:27:57.540]                   name <- changed[[kk]]
[08:27:57.540]                   NAME <- NAMES[[kk]]
[08:27:57.540]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.540]                     next
[08:27:57.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.540]                 }
[08:27:57.540]                 NAMES <- toupper(added)
[08:27:57.540]                 for (kk in seq_along(NAMES)) {
[08:27:57.540]                   name <- added[[kk]]
[08:27:57.540]                   NAME <- NAMES[[kk]]
[08:27:57.540]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.540]                     next
[08:27:57.540]                   args[[name]] <- ""
[08:27:57.540]                 }
[08:27:57.540]                 NAMES <- toupper(removed)
[08:27:57.540]                 for (kk in seq_along(NAMES)) {
[08:27:57.540]                   name <- removed[[kk]]
[08:27:57.540]                   NAME <- NAMES[[kk]]
[08:27:57.540]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.540]                     next
[08:27:57.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.540]                 }
[08:27:57.540]                 if (length(args) > 0) 
[08:27:57.540]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.540]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.540]             }
[08:27:57.540]             else {
[08:27:57.540]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.540]             }
[08:27:57.540]             {
[08:27:57.540]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.540]                   0L) {
[08:27:57.540]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.540]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.540]                   base::options(opts)
[08:27:57.540]                 }
[08:27:57.540]                 {
[08:27:57.540]                   {
[08:27:57.540]                     NULL
[08:27:57.540]                     RNGkind("Mersenne-Twister")
[08:27:57.540]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:57.540]                       inherits = FALSE)
[08:27:57.540]                   }
[08:27:57.540]                   options(future.plan = NULL)
[08:27:57.540]                   if (is.na(NA_character_)) 
[08:27:57.540]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.540]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.540]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.540]                     .init = FALSE)
[08:27:57.540]                 }
[08:27:57.540]             }
[08:27:57.540]         }
[08:27:57.540]     })
[08:27:57.540]     if (TRUE) {
[08:27:57.540]         base::sink(type = "output", split = FALSE)
[08:27:57.540]         if (TRUE) {
[08:27:57.540]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.540]         }
[08:27:57.540]         else {
[08:27:57.540]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.540]         }
[08:27:57.540]         base::close(...future.stdout)
[08:27:57.540]         ...future.stdout <- NULL
[08:27:57.540]     }
[08:27:57.540]     ...future.result$conditions <- ...future.conditions
[08:27:57.540]     ...future.result$finished <- base::Sys.time()
[08:27:57.540]     ...future.result
[08:27:57.540] }
[08:27:57.542] plan(): Setting new future strategy stack:
[08:27:57.542] List of future strategies:
[08:27:57.542] 1. sequential:
[08:27:57.542]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.542]    - tweaked: FALSE
[08:27:57.542]    - call: NULL
[08:27:57.542] plan(): nbrOfWorkers() = 1
[08:27:57.543] plan(): Setting new future strategy stack:
[08:27:57.544] List of future strategies:
[08:27:57.544] 1. sequential:
[08:27:57.544]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.544]    - tweaked: FALSE
[08:27:57.544]    - call: plan(strategy)
[08:27:57.544] plan(): nbrOfWorkers() = 1
[08:27:57.544] SequentialFuture started (and completed)
[08:27:57.544] - Launch lazy future ... done
[08:27:57.544] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[08:27:57.547] getGlobalsAndPackages() ...
[08:27:57.547] Searching for globals...
[08:27:57.549] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[08:27:57.549] Searching for globals ... DONE
[08:27:57.549] Resolving globals: FALSE
[08:27:57.549] 
[08:27:57.549] - packages: [2] ‘stats’, ‘datasets’
[08:27:57.549] getGlobalsAndPackages() ... DONE
[08:27:57.550] run() for ‘Future’ ...
[08:27:57.550] - state: ‘created’
[08:27:57.550] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:57.550] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:57.550] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:57.550]   - Field: ‘label’
[08:27:57.550]   - Field: ‘local’
[08:27:57.551]   - Field: ‘owner’
[08:27:57.551]   - Field: ‘envir’
[08:27:57.551]   - Field: ‘packages’
[08:27:57.551]   - Field: ‘gc’
[08:27:57.551]   - Field: ‘conditions’
[08:27:57.551]   - Field: ‘expr’
[08:27:57.551]   - Field: ‘uuid’
[08:27:57.551]   - Field: ‘seed’
[08:27:57.551]   - Field: ‘version’
[08:27:57.551]   - Field: ‘result’
[08:27:57.551]   - Field: ‘asynchronous’
[08:27:57.551]   - Field: ‘calls’
[08:27:57.552]   - Field: ‘globals’
[08:27:57.552]   - Field: ‘stdout’
[08:27:57.552]   - Field: ‘earlySignal’
[08:27:57.552]   - Field: ‘lazy’
[08:27:57.552]   - Field: ‘state’
[08:27:57.552] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:57.552] - Launch lazy future ...
[08:27:57.552] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[08:27:57.552] Packages needed by future strategies (n = 0): <none>
[08:27:57.553] {
[08:27:57.553]     {
[08:27:57.553]         {
[08:27:57.553]             ...future.startTime <- base::Sys.time()
[08:27:57.553]             {
[08:27:57.553]                 {
[08:27:57.553]                   {
[08:27:57.553]                     {
[08:27:57.553]                       base::local({
[08:27:57.553]                         has_future <- base::requireNamespace("future", 
[08:27:57.553]                           quietly = TRUE)
[08:27:57.553]                         if (has_future) {
[08:27:57.553]                           ns <- base::getNamespace("future")
[08:27:57.553]                           version <- ns[[".package"]][["version"]]
[08:27:57.553]                           if (is.null(version)) 
[08:27:57.553]                             version <- utils::packageVersion("future")
[08:27:57.553]                         }
[08:27:57.553]                         else {
[08:27:57.553]                           version <- NULL
[08:27:57.553]                         }
[08:27:57.553]                         if (!has_future || version < "1.8.0") {
[08:27:57.553]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.553]                             "", base::R.version$version.string), 
[08:27:57.553]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:57.553]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:57.553]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.553]                               "release", "version")], collapse = " "), 
[08:27:57.553]                             hostname = base::Sys.info()[["nodename"]])
[08:27:57.553]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.553]                             info)
[08:27:57.553]                           info <- base::paste(info, collapse = "; ")
[08:27:57.553]                           if (!has_future) {
[08:27:57.553]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.553]                               info)
[08:27:57.553]                           }
[08:27:57.553]                           else {
[08:27:57.553]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.553]                               info, version)
[08:27:57.553]                           }
[08:27:57.553]                           base::stop(msg)
[08:27:57.553]                         }
[08:27:57.553]                       })
[08:27:57.553]                     }
[08:27:57.553]                     base::local({
[08:27:57.553]                       for (pkg in c("stats", "datasets")) {
[08:27:57.553]                         base::loadNamespace(pkg)
[08:27:57.553]                         base::library(pkg, character.only = TRUE)
[08:27:57.553]                       }
[08:27:57.553]                     })
[08:27:57.553]                   }
[08:27:57.553]                   ...future.strategy.old <- future::plan("list")
[08:27:57.553]                   options(future.plan = NULL)
[08:27:57.553]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.553]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.553]                 }
[08:27:57.553]                 ...future.workdir <- getwd()
[08:27:57.553]             }
[08:27:57.553]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.553]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.553]         }
[08:27:57.553]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.553]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.553]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.553]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.553]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.553]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.553]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.553]             base::names(...future.oldOptions))
[08:27:57.553]     }
[08:27:57.553]     if (FALSE) {
[08:27:57.553]     }
[08:27:57.553]     else {
[08:27:57.553]         if (TRUE) {
[08:27:57.553]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.553]                 open = "w")
[08:27:57.553]         }
[08:27:57.553]         else {
[08:27:57.553]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.553]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.553]         }
[08:27:57.553]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.553]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.553]             base::sink(type = "output", split = FALSE)
[08:27:57.553]             base::close(...future.stdout)
[08:27:57.553]         }, add = TRUE)
[08:27:57.553]     }
[08:27:57.553]     ...future.frame <- base::sys.nframe()
[08:27:57.553]     ...future.conditions <- base::list()
[08:27:57.553]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.553]     if (FALSE) {
[08:27:57.553]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.553]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.553]     }
[08:27:57.553]     ...future.result <- base::tryCatch({
[08:27:57.553]         base::withCallingHandlers({
[08:27:57.553]             ...future.value <- base::withVisible(base::local({
[08:27:57.553]                 lm(dist ~ speed + I(speed^2), data = cars)
[08:27:57.553]             }))
[08:27:57.553]             future::FutureResult(value = ...future.value$value, 
[08:27:57.553]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.553]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.553]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.553]                     ...future.globalenv.names))
[08:27:57.553]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.553]         }, condition = base::local({
[08:27:57.553]             c <- base::c
[08:27:57.553]             inherits <- base::inherits
[08:27:57.553]             invokeRestart <- base::invokeRestart
[08:27:57.553]             length <- base::length
[08:27:57.553]             list <- base::list
[08:27:57.553]             seq.int <- base::seq.int
[08:27:57.553]             signalCondition <- base::signalCondition
[08:27:57.553]             sys.calls <- base::sys.calls
[08:27:57.553]             `[[` <- base::`[[`
[08:27:57.553]             `+` <- base::`+`
[08:27:57.553]             `<<-` <- base::`<<-`
[08:27:57.553]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.553]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.553]                   3L)]
[08:27:57.553]             }
[08:27:57.553]             function(cond) {
[08:27:57.553]                 is_error <- inherits(cond, "error")
[08:27:57.553]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.553]                   NULL)
[08:27:57.553]                 if (is_error) {
[08:27:57.553]                   sessionInformation <- function() {
[08:27:57.553]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.553]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.553]                       search = base::search(), system = base::Sys.info())
[08:27:57.553]                   }
[08:27:57.553]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.553]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.553]                     cond$call), session = sessionInformation(), 
[08:27:57.553]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.553]                   signalCondition(cond)
[08:27:57.553]                 }
[08:27:57.553]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.553]                 "immediateCondition"))) {
[08:27:57.553]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.553]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.553]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.553]                   if (TRUE && !signal) {
[08:27:57.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.553]                     {
[08:27:57.553]                       inherits <- base::inherits
[08:27:57.553]                       invokeRestart <- base::invokeRestart
[08:27:57.553]                       is.null <- base::is.null
[08:27:57.553]                       muffled <- FALSE
[08:27:57.553]                       if (inherits(cond, "message")) {
[08:27:57.553]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.553]                         if (muffled) 
[08:27:57.553]                           invokeRestart("muffleMessage")
[08:27:57.553]                       }
[08:27:57.553]                       else if (inherits(cond, "warning")) {
[08:27:57.553]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.553]                         if (muffled) 
[08:27:57.553]                           invokeRestart("muffleWarning")
[08:27:57.553]                       }
[08:27:57.553]                       else if (inherits(cond, "condition")) {
[08:27:57.553]                         if (!is.null(pattern)) {
[08:27:57.553]                           computeRestarts <- base::computeRestarts
[08:27:57.553]                           grepl <- base::grepl
[08:27:57.553]                           restarts <- computeRestarts(cond)
[08:27:57.553]                           for (restart in restarts) {
[08:27:57.553]                             name <- restart$name
[08:27:57.553]                             if (is.null(name)) 
[08:27:57.553]                               next
[08:27:57.553]                             if (!grepl(pattern, name)) 
[08:27:57.553]                               next
[08:27:57.553]                             invokeRestart(restart)
[08:27:57.553]                             muffled <- TRUE
[08:27:57.553]                             break
[08:27:57.553]                           }
[08:27:57.553]                         }
[08:27:57.553]                       }
[08:27:57.553]                       invisible(muffled)
[08:27:57.553]                     }
[08:27:57.553]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.553]                   }
[08:27:57.553]                 }
[08:27:57.553]                 else {
[08:27:57.553]                   if (TRUE) {
[08:27:57.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.553]                     {
[08:27:57.553]                       inherits <- base::inherits
[08:27:57.553]                       invokeRestart <- base::invokeRestart
[08:27:57.553]                       is.null <- base::is.null
[08:27:57.553]                       muffled <- FALSE
[08:27:57.553]                       if (inherits(cond, "message")) {
[08:27:57.553]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.553]                         if (muffled) 
[08:27:57.553]                           invokeRestart("muffleMessage")
[08:27:57.553]                       }
[08:27:57.553]                       else if (inherits(cond, "warning")) {
[08:27:57.553]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.553]                         if (muffled) 
[08:27:57.553]                           invokeRestart("muffleWarning")
[08:27:57.553]                       }
[08:27:57.553]                       else if (inherits(cond, "condition")) {
[08:27:57.553]                         if (!is.null(pattern)) {
[08:27:57.553]                           computeRestarts <- base::computeRestarts
[08:27:57.553]                           grepl <- base::grepl
[08:27:57.553]                           restarts <- computeRestarts(cond)
[08:27:57.553]                           for (restart in restarts) {
[08:27:57.553]                             name <- restart$name
[08:27:57.553]                             if (is.null(name)) 
[08:27:57.553]                               next
[08:27:57.553]                             if (!grepl(pattern, name)) 
[08:27:57.553]                               next
[08:27:57.553]                             invokeRestart(restart)
[08:27:57.553]                             muffled <- TRUE
[08:27:57.553]                             break
[08:27:57.553]                           }
[08:27:57.553]                         }
[08:27:57.553]                       }
[08:27:57.553]                       invisible(muffled)
[08:27:57.553]                     }
[08:27:57.553]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.553]                   }
[08:27:57.553]                 }
[08:27:57.553]             }
[08:27:57.553]         }))
[08:27:57.553]     }, error = function(ex) {
[08:27:57.553]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.553]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.553]                 ...future.rng), started = ...future.startTime, 
[08:27:57.553]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.553]             version = "1.8"), class = "FutureResult")
[08:27:57.553]     }, finally = {
[08:27:57.553]         if (!identical(...future.workdir, getwd())) 
[08:27:57.553]             setwd(...future.workdir)
[08:27:57.553]         {
[08:27:57.553]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.553]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.553]             }
[08:27:57.553]             base::options(...future.oldOptions)
[08:27:57.553]             if (.Platform$OS.type == "windows") {
[08:27:57.553]                 old_names <- names(...future.oldEnvVars)
[08:27:57.553]                 envs <- base::Sys.getenv()
[08:27:57.553]                 names <- names(envs)
[08:27:57.553]                 common <- intersect(names, old_names)
[08:27:57.553]                 added <- setdiff(names, old_names)
[08:27:57.553]                 removed <- setdiff(old_names, names)
[08:27:57.553]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.553]                   envs[common]]
[08:27:57.553]                 NAMES <- toupper(changed)
[08:27:57.553]                 args <- list()
[08:27:57.553]                 for (kk in seq_along(NAMES)) {
[08:27:57.553]                   name <- changed[[kk]]
[08:27:57.553]                   NAME <- NAMES[[kk]]
[08:27:57.553]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.553]                     next
[08:27:57.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.553]                 }
[08:27:57.553]                 NAMES <- toupper(added)
[08:27:57.553]                 for (kk in seq_along(NAMES)) {
[08:27:57.553]                   name <- added[[kk]]
[08:27:57.553]                   NAME <- NAMES[[kk]]
[08:27:57.553]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.553]                     next
[08:27:57.553]                   args[[name]] <- ""
[08:27:57.553]                 }
[08:27:57.553]                 NAMES <- toupper(removed)
[08:27:57.553]                 for (kk in seq_along(NAMES)) {
[08:27:57.553]                   name <- removed[[kk]]
[08:27:57.553]                   NAME <- NAMES[[kk]]
[08:27:57.553]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.553]                     next
[08:27:57.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.553]                 }
[08:27:57.553]                 if (length(args) > 0) 
[08:27:57.553]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.553]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.553]             }
[08:27:57.553]             else {
[08:27:57.553]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.553]             }
[08:27:57.553]             {
[08:27:57.553]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.553]                   0L) {
[08:27:57.553]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.553]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.553]                   base::options(opts)
[08:27:57.553]                 }
[08:27:57.553]                 {
[08:27:57.553]                   {
[08:27:57.553]                     NULL
[08:27:57.553]                     RNGkind("Mersenne-Twister")
[08:27:57.553]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:57.553]                       inherits = FALSE)
[08:27:57.553]                   }
[08:27:57.553]                   options(future.plan = NULL)
[08:27:57.553]                   if (is.na(NA_character_)) 
[08:27:57.553]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.553]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.553]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.553]                     .init = FALSE)
[08:27:57.553]                 }
[08:27:57.553]             }
[08:27:57.553]         }
[08:27:57.553]     })
[08:27:57.553]     if (TRUE) {
[08:27:57.553]         base::sink(type = "output", split = FALSE)
[08:27:57.553]         if (TRUE) {
[08:27:57.553]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.553]         }
[08:27:57.553]         else {
[08:27:57.553]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.553]         }
[08:27:57.553]         base::close(...future.stdout)
[08:27:57.553]         ...future.stdout <- NULL
[08:27:57.553]     }
[08:27:57.553]     ...future.result$conditions <- ...future.conditions
[08:27:57.553]     ...future.result$finished <- base::Sys.time()
[08:27:57.553]     ...future.result
[08:27:57.553] }
[08:27:57.555] plan(): Setting new future strategy stack:
[08:27:57.555] List of future strategies:
[08:27:57.555] 1. sequential:
[08:27:57.555]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.555]    - tweaked: FALSE
[08:27:57.555]    - call: NULL
[08:27:57.555] plan(): nbrOfWorkers() = 1
[08:27:57.557] plan(): Setting new future strategy stack:
[08:27:57.557] List of future strategies:
[08:27:57.557] 1. sequential:
[08:27:57.557]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.557]    - tweaked: FALSE
[08:27:57.557]    - call: plan(strategy)
[08:27:57.557] plan(): nbrOfWorkers() = 1
[08:27:57.557] SequentialFuture started (and completed)
[08:27:57.557] - Launch lazy future ... done
[08:27:57.559] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[08:27:57.562] getGlobalsAndPackages() ...
[08:27:57.562] Searching for globals...
[08:27:57.563] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[08:27:57.564] Searching for globals ... DONE
[08:27:57.564] Resolving globals: FALSE
[08:27:57.564] 
[08:27:57.564] - packages: [2] ‘stats’, ‘datasets’
[08:27:57.564] getGlobalsAndPackages() ... DONE
[08:27:57.565] run() for ‘Future’ ...
[08:27:57.565] - state: ‘created’
[08:27:57.565] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:57.565] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:57.565] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:57.565]   - Field: ‘label’
[08:27:57.565]   - Field: ‘local’
[08:27:57.565]   - Field: ‘owner’
[08:27:57.565]   - Field: ‘envir’
[08:27:57.566]   - Field: ‘packages’
[08:27:57.566]   - Field: ‘gc’
[08:27:57.566]   - Field: ‘conditions’
[08:27:57.566]   - Field: ‘expr’
[08:27:57.566]   - Field: ‘uuid’
[08:27:57.566]   - Field: ‘seed’
[08:27:57.566]   - Field: ‘version’
[08:27:57.566]   - Field: ‘result’
[08:27:57.566]   - Field: ‘asynchronous’
[08:27:57.566]   - Field: ‘calls’
[08:27:57.566]   - Field: ‘globals’
[08:27:57.566]   - Field: ‘stdout’
[08:27:57.567]   - Field: ‘earlySignal’
[08:27:57.567]   - Field: ‘lazy’
[08:27:57.567]   - Field: ‘state’
[08:27:57.567] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:57.567] - Launch lazy future ...
[08:27:57.567] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[08:27:57.567] Packages needed by future strategies (n = 0): <none>
[08:27:57.568] {
[08:27:57.568]     {
[08:27:57.568]         {
[08:27:57.568]             ...future.startTime <- base::Sys.time()
[08:27:57.568]             {
[08:27:57.568]                 {
[08:27:57.568]                   {
[08:27:57.568]                     {
[08:27:57.568]                       base::local({
[08:27:57.568]                         has_future <- base::requireNamespace("future", 
[08:27:57.568]                           quietly = TRUE)
[08:27:57.568]                         if (has_future) {
[08:27:57.568]                           ns <- base::getNamespace("future")
[08:27:57.568]                           version <- ns[[".package"]][["version"]]
[08:27:57.568]                           if (is.null(version)) 
[08:27:57.568]                             version <- utils::packageVersion("future")
[08:27:57.568]                         }
[08:27:57.568]                         else {
[08:27:57.568]                           version <- NULL
[08:27:57.568]                         }
[08:27:57.568]                         if (!has_future || version < "1.8.0") {
[08:27:57.568]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.568]                             "", base::R.version$version.string), 
[08:27:57.568]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:57.568]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:57.568]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.568]                               "release", "version")], collapse = " "), 
[08:27:57.568]                             hostname = base::Sys.info()[["nodename"]])
[08:27:57.568]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.568]                             info)
[08:27:57.568]                           info <- base::paste(info, collapse = "; ")
[08:27:57.568]                           if (!has_future) {
[08:27:57.568]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.568]                               info)
[08:27:57.568]                           }
[08:27:57.568]                           else {
[08:27:57.568]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.568]                               info, version)
[08:27:57.568]                           }
[08:27:57.568]                           base::stop(msg)
[08:27:57.568]                         }
[08:27:57.568]                       })
[08:27:57.568]                     }
[08:27:57.568]                     base::local({
[08:27:57.568]                       for (pkg in c("stats", "datasets")) {
[08:27:57.568]                         base::loadNamespace(pkg)
[08:27:57.568]                         base::library(pkg, character.only = TRUE)
[08:27:57.568]                       }
[08:27:57.568]                     })
[08:27:57.568]                   }
[08:27:57.568]                   ...future.strategy.old <- future::plan("list")
[08:27:57.568]                   options(future.plan = NULL)
[08:27:57.568]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.568]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.568]                 }
[08:27:57.568]                 ...future.workdir <- getwd()
[08:27:57.568]             }
[08:27:57.568]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.568]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.568]         }
[08:27:57.568]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.568]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.568]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.568]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.568]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.568]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.568]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.568]             base::names(...future.oldOptions))
[08:27:57.568]     }
[08:27:57.568]     if (FALSE) {
[08:27:57.568]     }
[08:27:57.568]     else {
[08:27:57.568]         if (TRUE) {
[08:27:57.568]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.568]                 open = "w")
[08:27:57.568]         }
[08:27:57.568]         else {
[08:27:57.568]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.568]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.568]         }
[08:27:57.568]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.568]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.568]             base::sink(type = "output", split = FALSE)
[08:27:57.568]             base::close(...future.stdout)
[08:27:57.568]         }, add = TRUE)
[08:27:57.568]     }
[08:27:57.568]     ...future.frame <- base::sys.nframe()
[08:27:57.568]     ...future.conditions <- base::list()
[08:27:57.568]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.568]     if (FALSE) {
[08:27:57.568]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.568]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.568]     }
[08:27:57.568]     ...future.result <- base::tryCatch({
[08:27:57.568]         base::withCallingHandlers({
[08:27:57.568]             ...future.value <- base::withVisible(base::local({
[08:27:57.568]                 lm(dist ~ poly(speed, 2), data = cars)
[08:27:57.568]             }))
[08:27:57.568]             future::FutureResult(value = ...future.value$value, 
[08:27:57.568]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.568]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.568]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.568]                     ...future.globalenv.names))
[08:27:57.568]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.568]         }, condition = base::local({
[08:27:57.568]             c <- base::c
[08:27:57.568]             inherits <- base::inherits
[08:27:57.568]             invokeRestart <- base::invokeRestart
[08:27:57.568]             length <- base::length
[08:27:57.568]             list <- base::list
[08:27:57.568]             seq.int <- base::seq.int
[08:27:57.568]             signalCondition <- base::signalCondition
[08:27:57.568]             sys.calls <- base::sys.calls
[08:27:57.568]             `[[` <- base::`[[`
[08:27:57.568]             `+` <- base::`+`
[08:27:57.568]             `<<-` <- base::`<<-`
[08:27:57.568]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.568]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.568]                   3L)]
[08:27:57.568]             }
[08:27:57.568]             function(cond) {
[08:27:57.568]                 is_error <- inherits(cond, "error")
[08:27:57.568]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.568]                   NULL)
[08:27:57.568]                 if (is_error) {
[08:27:57.568]                   sessionInformation <- function() {
[08:27:57.568]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.568]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.568]                       search = base::search(), system = base::Sys.info())
[08:27:57.568]                   }
[08:27:57.568]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.568]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.568]                     cond$call), session = sessionInformation(), 
[08:27:57.568]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.568]                   signalCondition(cond)
[08:27:57.568]                 }
[08:27:57.568]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.568]                 "immediateCondition"))) {
[08:27:57.568]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.568]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.568]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.568]                   if (TRUE && !signal) {
[08:27:57.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.568]                     {
[08:27:57.568]                       inherits <- base::inherits
[08:27:57.568]                       invokeRestart <- base::invokeRestart
[08:27:57.568]                       is.null <- base::is.null
[08:27:57.568]                       muffled <- FALSE
[08:27:57.568]                       if (inherits(cond, "message")) {
[08:27:57.568]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.568]                         if (muffled) 
[08:27:57.568]                           invokeRestart("muffleMessage")
[08:27:57.568]                       }
[08:27:57.568]                       else if (inherits(cond, "warning")) {
[08:27:57.568]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.568]                         if (muffled) 
[08:27:57.568]                           invokeRestart("muffleWarning")
[08:27:57.568]                       }
[08:27:57.568]                       else if (inherits(cond, "condition")) {
[08:27:57.568]                         if (!is.null(pattern)) {
[08:27:57.568]                           computeRestarts <- base::computeRestarts
[08:27:57.568]                           grepl <- base::grepl
[08:27:57.568]                           restarts <- computeRestarts(cond)
[08:27:57.568]                           for (restart in restarts) {
[08:27:57.568]                             name <- restart$name
[08:27:57.568]                             if (is.null(name)) 
[08:27:57.568]                               next
[08:27:57.568]                             if (!grepl(pattern, name)) 
[08:27:57.568]                               next
[08:27:57.568]                             invokeRestart(restart)
[08:27:57.568]                             muffled <- TRUE
[08:27:57.568]                             break
[08:27:57.568]                           }
[08:27:57.568]                         }
[08:27:57.568]                       }
[08:27:57.568]                       invisible(muffled)
[08:27:57.568]                     }
[08:27:57.568]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.568]                   }
[08:27:57.568]                 }
[08:27:57.568]                 else {
[08:27:57.568]                   if (TRUE) {
[08:27:57.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.568]                     {
[08:27:57.568]                       inherits <- base::inherits
[08:27:57.568]                       invokeRestart <- base::invokeRestart
[08:27:57.568]                       is.null <- base::is.null
[08:27:57.568]                       muffled <- FALSE
[08:27:57.568]                       if (inherits(cond, "message")) {
[08:27:57.568]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.568]                         if (muffled) 
[08:27:57.568]                           invokeRestart("muffleMessage")
[08:27:57.568]                       }
[08:27:57.568]                       else if (inherits(cond, "warning")) {
[08:27:57.568]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.568]                         if (muffled) 
[08:27:57.568]                           invokeRestart("muffleWarning")
[08:27:57.568]                       }
[08:27:57.568]                       else if (inherits(cond, "condition")) {
[08:27:57.568]                         if (!is.null(pattern)) {
[08:27:57.568]                           computeRestarts <- base::computeRestarts
[08:27:57.568]                           grepl <- base::grepl
[08:27:57.568]                           restarts <- computeRestarts(cond)
[08:27:57.568]                           for (restart in restarts) {
[08:27:57.568]                             name <- restart$name
[08:27:57.568]                             if (is.null(name)) 
[08:27:57.568]                               next
[08:27:57.568]                             if (!grepl(pattern, name)) 
[08:27:57.568]                               next
[08:27:57.568]                             invokeRestart(restart)
[08:27:57.568]                             muffled <- TRUE
[08:27:57.568]                             break
[08:27:57.568]                           }
[08:27:57.568]                         }
[08:27:57.568]                       }
[08:27:57.568]                       invisible(muffled)
[08:27:57.568]                     }
[08:27:57.568]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.568]                   }
[08:27:57.568]                 }
[08:27:57.568]             }
[08:27:57.568]         }))
[08:27:57.568]     }, error = function(ex) {
[08:27:57.568]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.568]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.568]                 ...future.rng), started = ...future.startTime, 
[08:27:57.568]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.568]             version = "1.8"), class = "FutureResult")
[08:27:57.568]     }, finally = {
[08:27:57.568]         if (!identical(...future.workdir, getwd())) 
[08:27:57.568]             setwd(...future.workdir)
[08:27:57.568]         {
[08:27:57.568]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.568]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.568]             }
[08:27:57.568]             base::options(...future.oldOptions)
[08:27:57.568]             if (.Platform$OS.type == "windows") {
[08:27:57.568]                 old_names <- names(...future.oldEnvVars)
[08:27:57.568]                 envs <- base::Sys.getenv()
[08:27:57.568]                 names <- names(envs)
[08:27:57.568]                 common <- intersect(names, old_names)
[08:27:57.568]                 added <- setdiff(names, old_names)
[08:27:57.568]                 removed <- setdiff(old_names, names)
[08:27:57.568]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.568]                   envs[common]]
[08:27:57.568]                 NAMES <- toupper(changed)
[08:27:57.568]                 args <- list()
[08:27:57.568]                 for (kk in seq_along(NAMES)) {
[08:27:57.568]                   name <- changed[[kk]]
[08:27:57.568]                   NAME <- NAMES[[kk]]
[08:27:57.568]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.568]                     next
[08:27:57.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.568]                 }
[08:27:57.568]                 NAMES <- toupper(added)
[08:27:57.568]                 for (kk in seq_along(NAMES)) {
[08:27:57.568]                   name <- added[[kk]]
[08:27:57.568]                   NAME <- NAMES[[kk]]
[08:27:57.568]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.568]                     next
[08:27:57.568]                   args[[name]] <- ""
[08:27:57.568]                 }
[08:27:57.568]                 NAMES <- toupper(removed)
[08:27:57.568]                 for (kk in seq_along(NAMES)) {
[08:27:57.568]                   name <- removed[[kk]]
[08:27:57.568]                   NAME <- NAMES[[kk]]
[08:27:57.568]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.568]                     next
[08:27:57.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.568]                 }
[08:27:57.568]                 if (length(args) > 0) 
[08:27:57.568]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.568]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.568]             }
[08:27:57.568]             else {
[08:27:57.568]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.568]             }
[08:27:57.568]             {
[08:27:57.568]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.568]                   0L) {
[08:27:57.568]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.568]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.568]                   base::options(opts)
[08:27:57.568]                 }
[08:27:57.568]                 {
[08:27:57.568]                   {
[08:27:57.568]                     NULL
[08:27:57.568]                     RNGkind("Mersenne-Twister")
[08:27:57.568]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:57.568]                       inherits = FALSE)
[08:27:57.568]                   }
[08:27:57.568]                   options(future.plan = NULL)
[08:27:57.568]                   if (is.na(NA_character_)) 
[08:27:57.568]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.568]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.568]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.568]                     .init = FALSE)
[08:27:57.568]                 }
[08:27:57.568]             }
[08:27:57.568]         }
[08:27:57.568]     })
[08:27:57.568]     if (TRUE) {
[08:27:57.568]         base::sink(type = "output", split = FALSE)
[08:27:57.568]         if (TRUE) {
[08:27:57.568]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.568]         }
[08:27:57.568]         else {
[08:27:57.568]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.568]         }
[08:27:57.568]         base::close(...future.stdout)
[08:27:57.568]         ...future.stdout <- NULL
[08:27:57.568]     }
[08:27:57.568]     ...future.result$conditions <- ...future.conditions
[08:27:57.568]     ...future.result$finished <- base::Sys.time()
[08:27:57.568]     ...future.result
[08:27:57.568] }
[08:27:57.570] plan(): Setting new future strategy stack:
[08:27:57.570] List of future strategies:
[08:27:57.570] 1. sequential:
[08:27:57.570]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.570]    - tweaked: FALSE
[08:27:57.570]    - call: NULL
[08:27:57.570] plan(): nbrOfWorkers() = 1
[08:27:57.571] plan(): Setting new future strategy stack:
[08:27:57.572] List of future strategies:
[08:27:57.572] 1. sequential:
[08:27:57.572]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.572]    - tweaked: FALSE
[08:27:57.572]    - call: plan(strategy)
[08:27:57.572] plan(): nbrOfWorkers() = 1
[08:27:57.572] SequentialFuture started (and completed)
[08:27:57.572] - Launch lazy future ... done
[08:27:57.572] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[08:27:57.574] getGlobalsAndPackages() ...
[08:27:57.574] Searching for globals...
[08:27:57.579] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[08:27:57.579] Searching for globals ... DONE
[08:27:57.579] Resolving globals: FALSE
[08:27:57.581] The total size of the 3 globals is 1.22 KiB (1254 bytes)
[08:27:57.581] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (633 bytes of class ‘function’), ‘inner_function’ (371 bytes of class ‘function’) and ‘outer_function’ (250 bytes of class ‘function’)
[08:27:57.581] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[08:27:57.582] 
[08:27:57.582] getGlobalsAndPackages() ... DONE
[08:27:57.582] run() for ‘Future’ ...
[08:27:57.582] - state: ‘created’
[08:27:57.582] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:57.582] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:57.582] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:57.583]   - Field: ‘label’
[08:27:57.583]   - Field: ‘local’
[08:27:57.583]   - Field: ‘owner’
[08:27:57.583]   - Field: ‘envir’
[08:27:57.583]   - Field: ‘packages’
[08:27:57.583]   - Field: ‘gc’
[08:27:57.583]   - Field: ‘conditions’
[08:27:57.583]   - Field: ‘expr’
[08:27:57.583]   - Field: ‘uuid’
[08:27:57.583]   - Field: ‘seed’
[08:27:57.583]   - Field: ‘version’
[08:27:57.583]   - Field: ‘result’
[08:27:57.584]   - Field: ‘asynchronous’
[08:27:57.584]   - Field: ‘calls’
[08:27:57.584]   - Field: ‘globals’
[08:27:57.584]   - Field: ‘stdout’
[08:27:57.584]   - Field: ‘earlySignal’
[08:27:57.584]   - Field: ‘lazy’
[08:27:57.584]   - Field: ‘state’
[08:27:57.584] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:57.584] - Launch lazy future ...
[08:27:57.584] Packages needed by the future expression (n = 0): <none>
[08:27:57.584] Packages needed by future strategies (n = 0): <none>
[08:27:57.585] {
[08:27:57.585]     {
[08:27:57.585]         {
[08:27:57.585]             ...future.startTime <- base::Sys.time()
[08:27:57.585]             {
[08:27:57.585]                 {
[08:27:57.585]                   {
[08:27:57.585]                     base::local({
[08:27:57.585]                       has_future <- base::requireNamespace("future", 
[08:27:57.585]                         quietly = TRUE)
[08:27:57.585]                       if (has_future) {
[08:27:57.585]                         ns <- base::getNamespace("future")
[08:27:57.585]                         version <- ns[[".package"]][["version"]]
[08:27:57.585]                         if (is.null(version)) 
[08:27:57.585]                           version <- utils::packageVersion("future")
[08:27:57.585]                       }
[08:27:57.585]                       else {
[08:27:57.585]                         version <- NULL
[08:27:57.585]                       }
[08:27:57.585]                       if (!has_future || version < "1.8.0") {
[08:27:57.585]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.585]                           "", base::R.version$version.string), 
[08:27:57.585]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:57.585]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:57.585]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.585]                             "release", "version")], collapse = " "), 
[08:27:57.585]                           hostname = base::Sys.info()[["nodename"]])
[08:27:57.585]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.585]                           info)
[08:27:57.585]                         info <- base::paste(info, collapse = "; ")
[08:27:57.585]                         if (!has_future) {
[08:27:57.585]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.585]                             info)
[08:27:57.585]                         }
[08:27:57.585]                         else {
[08:27:57.585]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.585]                             info, version)
[08:27:57.585]                         }
[08:27:57.585]                         base::stop(msg)
[08:27:57.585]                       }
[08:27:57.585]                     })
[08:27:57.585]                   }
[08:27:57.585]                   ...future.strategy.old <- future::plan("list")
[08:27:57.585]                   options(future.plan = NULL)
[08:27:57.585]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.585]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.585]                 }
[08:27:57.585]                 ...future.workdir <- getwd()
[08:27:57.585]             }
[08:27:57.585]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.585]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.585]         }
[08:27:57.585]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.585]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.585]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.585]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.585]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.585]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.585]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.585]             base::names(...future.oldOptions))
[08:27:57.585]     }
[08:27:57.585]     if (FALSE) {
[08:27:57.585]     }
[08:27:57.585]     else {
[08:27:57.585]         if (TRUE) {
[08:27:57.585]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.585]                 open = "w")
[08:27:57.585]         }
[08:27:57.585]         else {
[08:27:57.585]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.585]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.585]         }
[08:27:57.585]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.585]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.585]             base::sink(type = "output", split = FALSE)
[08:27:57.585]             base::close(...future.stdout)
[08:27:57.585]         }, add = TRUE)
[08:27:57.585]     }
[08:27:57.585]     ...future.frame <- base::sys.nframe()
[08:27:57.585]     ...future.conditions <- base::list()
[08:27:57.585]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.585]     if (FALSE) {
[08:27:57.585]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.585]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.585]     }
[08:27:57.585]     ...future.result <- base::tryCatch({
[08:27:57.585]         base::withCallingHandlers({
[08:27:57.585]             ...future.value <- base::withVisible(base::local({
[08:27:57.585]                 outer_function(1L)
[08:27:57.585]             }))
[08:27:57.585]             future::FutureResult(value = ...future.value$value, 
[08:27:57.585]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.585]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.585]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.585]                     ...future.globalenv.names))
[08:27:57.585]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.585]         }, condition = base::local({
[08:27:57.585]             c <- base::c
[08:27:57.585]             inherits <- base::inherits
[08:27:57.585]             invokeRestart <- base::invokeRestart
[08:27:57.585]             length <- base::length
[08:27:57.585]             list <- base::list
[08:27:57.585]             seq.int <- base::seq.int
[08:27:57.585]             signalCondition <- base::signalCondition
[08:27:57.585]             sys.calls <- base::sys.calls
[08:27:57.585]             `[[` <- base::`[[`
[08:27:57.585]             `+` <- base::`+`
[08:27:57.585]             `<<-` <- base::`<<-`
[08:27:57.585]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.585]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.585]                   3L)]
[08:27:57.585]             }
[08:27:57.585]             function(cond) {
[08:27:57.585]                 is_error <- inherits(cond, "error")
[08:27:57.585]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.585]                   NULL)
[08:27:57.585]                 if (is_error) {
[08:27:57.585]                   sessionInformation <- function() {
[08:27:57.585]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.585]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.585]                       search = base::search(), system = base::Sys.info())
[08:27:57.585]                   }
[08:27:57.585]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.585]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.585]                     cond$call), session = sessionInformation(), 
[08:27:57.585]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.585]                   signalCondition(cond)
[08:27:57.585]                 }
[08:27:57.585]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.585]                 "immediateCondition"))) {
[08:27:57.585]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.585]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.585]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.585]                   if (TRUE && !signal) {
[08:27:57.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.585]                     {
[08:27:57.585]                       inherits <- base::inherits
[08:27:57.585]                       invokeRestart <- base::invokeRestart
[08:27:57.585]                       is.null <- base::is.null
[08:27:57.585]                       muffled <- FALSE
[08:27:57.585]                       if (inherits(cond, "message")) {
[08:27:57.585]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.585]                         if (muffled) 
[08:27:57.585]                           invokeRestart("muffleMessage")
[08:27:57.585]                       }
[08:27:57.585]                       else if (inherits(cond, "warning")) {
[08:27:57.585]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.585]                         if (muffled) 
[08:27:57.585]                           invokeRestart("muffleWarning")
[08:27:57.585]                       }
[08:27:57.585]                       else if (inherits(cond, "condition")) {
[08:27:57.585]                         if (!is.null(pattern)) {
[08:27:57.585]                           computeRestarts <- base::computeRestarts
[08:27:57.585]                           grepl <- base::grepl
[08:27:57.585]                           restarts <- computeRestarts(cond)
[08:27:57.585]                           for (restart in restarts) {
[08:27:57.585]                             name <- restart$name
[08:27:57.585]                             if (is.null(name)) 
[08:27:57.585]                               next
[08:27:57.585]                             if (!grepl(pattern, name)) 
[08:27:57.585]                               next
[08:27:57.585]                             invokeRestart(restart)
[08:27:57.585]                             muffled <- TRUE
[08:27:57.585]                             break
[08:27:57.585]                           }
[08:27:57.585]                         }
[08:27:57.585]                       }
[08:27:57.585]                       invisible(muffled)
[08:27:57.585]                     }
[08:27:57.585]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.585]                   }
[08:27:57.585]                 }
[08:27:57.585]                 else {
[08:27:57.585]                   if (TRUE) {
[08:27:57.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.585]                     {
[08:27:57.585]                       inherits <- base::inherits
[08:27:57.585]                       invokeRestart <- base::invokeRestart
[08:27:57.585]                       is.null <- base::is.null
[08:27:57.585]                       muffled <- FALSE
[08:27:57.585]                       if (inherits(cond, "message")) {
[08:27:57.585]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.585]                         if (muffled) 
[08:27:57.585]                           invokeRestart("muffleMessage")
[08:27:57.585]                       }
[08:27:57.585]                       else if (inherits(cond, "warning")) {
[08:27:57.585]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.585]                         if (muffled) 
[08:27:57.585]                           invokeRestart("muffleWarning")
[08:27:57.585]                       }
[08:27:57.585]                       else if (inherits(cond, "condition")) {
[08:27:57.585]                         if (!is.null(pattern)) {
[08:27:57.585]                           computeRestarts <- base::computeRestarts
[08:27:57.585]                           grepl <- base::grepl
[08:27:57.585]                           restarts <- computeRestarts(cond)
[08:27:57.585]                           for (restart in restarts) {
[08:27:57.585]                             name <- restart$name
[08:27:57.585]                             if (is.null(name)) 
[08:27:57.585]                               next
[08:27:57.585]                             if (!grepl(pattern, name)) 
[08:27:57.585]                               next
[08:27:57.585]                             invokeRestart(restart)
[08:27:57.585]                             muffled <- TRUE
[08:27:57.585]                             break
[08:27:57.585]                           }
[08:27:57.585]                         }
[08:27:57.585]                       }
[08:27:57.585]                       invisible(muffled)
[08:27:57.585]                     }
[08:27:57.585]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.585]                   }
[08:27:57.585]                 }
[08:27:57.585]             }
[08:27:57.585]         }))
[08:27:57.585]     }, error = function(ex) {
[08:27:57.585]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.585]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.585]                 ...future.rng), started = ...future.startTime, 
[08:27:57.585]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.585]             version = "1.8"), class = "FutureResult")
[08:27:57.585]     }, finally = {
[08:27:57.585]         if (!identical(...future.workdir, getwd())) 
[08:27:57.585]             setwd(...future.workdir)
[08:27:57.585]         {
[08:27:57.585]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.585]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.585]             }
[08:27:57.585]             base::options(...future.oldOptions)
[08:27:57.585]             if (.Platform$OS.type == "windows") {
[08:27:57.585]                 old_names <- names(...future.oldEnvVars)
[08:27:57.585]                 envs <- base::Sys.getenv()
[08:27:57.585]                 names <- names(envs)
[08:27:57.585]                 common <- intersect(names, old_names)
[08:27:57.585]                 added <- setdiff(names, old_names)
[08:27:57.585]                 removed <- setdiff(old_names, names)
[08:27:57.585]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.585]                   envs[common]]
[08:27:57.585]                 NAMES <- toupper(changed)
[08:27:57.585]                 args <- list()
[08:27:57.585]                 for (kk in seq_along(NAMES)) {
[08:27:57.585]                   name <- changed[[kk]]
[08:27:57.585]                   NAME <- NAMES[[kk]]
[08:27:57.585]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.585]                     next
[08:27:57.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.585]                 }
[08:27:57.585]                 NAMES <- toupper(added)
[08:27:57.585]                 for (kk in seq_along(NAMES)) {
[08:27:57.585]                   name <- added[[kk]]
[08:27:57.585]                   NAME <- NAMES[[kk]]
[08:27:57.585]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.585]                     next
[08:27:57.585]                   args[[name]] <- ""
[08:27:57.585]                 }
[08:27:57.585]                 NAMES <- toupper(removed)
[08:27:57.585]                 for (kk in seq_along(NAMES)) {
[08:27:57.585]                   name <- removed[[kk]]
[08:27:57.585]                   NAME <- NAMES[[kk]]
[08:27:57.585]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.585]                     next
[08:27:57.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.585]                 }
[08:27:57.585]                 if (length(args) > 0) 
[08:27:57.585]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.585]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.585]             }
[08:27:57.585]             else {
[08:27:57.585]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.585]             }
[08:27:57.585]             {
[08:27:57.585]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.585]                   0L) {
[08:27:57.585]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.585]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.585]                   base::options(opts)
[08:27:57.585]                 }
[08:27:57.585]                 {
[08:27:57.585]                   {
[08:27:57.585]                     NULL
[08:27:57.585]                     RNGkind("Mersenne-Twister")
[08:27:57.585]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:57.585]                       inherits = FALSE)
[08:27:57.585]                   }
[08:27:57.585]                   options(future.plan = NULL)
[08:27:57.585]                   if (is.na(NA_character_)) 
[08:27:57.585]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.585]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.585]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.585]                     .init = FALSE)
[08:27:57.585]                 }
[08:27:57.585]             }
[08:27:57.585]         }
[08:27:57.585]     })
[08:27:57.585]     if (TRUE) {
[08:27:57.585]         base::sink(type = "output", split = FALSE)
[08:27:57.585]         if (TRUE) {
[08:27:57.585]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.585]         }
[08:27:57.585]         else {
[08:27:57.585]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.585]         }
[08:27:57.585]         base::close(...future.stdout)
[08:27:57.585]         ...future.stdout <- NULL
[08:27:57.585]     }
[08:27:57.585]     ...future.result$conditions <- ...future.conditions
[08:27:57.585]     ...future.result$finished <- base::Sys.time()
[08:27:57.585]     ...future.result
[08:27:57.585] }
[08:27:57.586] assign_globals() ...
[08:27:57.587] List of 3
[08:27:57.587]  $ outer_function:function (x)  
[08:27:57.587]  $ map           :function (.x, .f, ...)  
[08:27:57.587]  $ inner_function:function (x)  
[08:27:57.587]  - attr(*, "where")=List of 3
[08:27:57.587]   ..$ outer_function:<environment: R_EmptyEnv> 
[08:27:57.587]   ..$ map           :<environment: R_EmptyEnv> 
[08:27:57.587]   ..$ inner_function:<environment: R_EmptyEnv> 
[08:27:57.587]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:57.587]  - attr(*, "resolved")= logi FALSE
[08:27:57.587]  - attr(*, "total_size")= num 1254
[08:27:57.587]  - attr(*, "already-done")= logi TRUE
[08:27:57.590] - reassign environment for ‘outer_function’
[08:27:57.590] - copied ‘outer_function’ to environment
[08:27:57.590] - reassign environment for ‘map’
[08:27:57.590] - copied ‘map’ to environment
[08:27:57.590] - reassign environment for ‘inner_function’
[08:27:57.590] - copied ‘inner_function’ to environment
[08:27:57.590] assign_globals() ... done
[08:27:57.591] plan(): Setting new future strategy stack:
[08:27:57.591] List of future strategies:
[08:27:57.591] 1. sequential:
[08:27:57.591]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.591]    - tweaked: FALSE
[08:27:57.591]    - call: NULL
[08:27:57.591] plan(): nbrOfWorkers() = 1
[08:27:57.596] plan(): Setting new future strategy stack:
[08:27:57.596] List of future strategies:
[08:27:57.596] 1. sequential:
[08:27:57.596]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.596]    - tweaked: FALSE
[08:27:57.596]    - call: plan(strategy)
[08:27:57.597] plan(): nbrOfWorkers() = 1
[08:27:57.597] SequentialFuture started (and completed)
[08:27:57.597] - Launch lazy future ... done
[08:27:57.597] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[08:27:57.598] getGlobalsAndPackages() ...
[08:27:57.598] Searching for globals...
[08:27:57.603] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[08:27:57.604] Searching for globals ... DONE
[08:27:57.604] Resolving globals: FALSE
[08:27:57.604] The total size of the 3 globals is 1.22 KiB (1254 bytes)
[08:27:57.605] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (633 bytes of class ‘function’), ‘inner_function’ (371 bytes of class ‘function’) and ‘outer_function’ (250 bytes of class ‘function’)
[08:27:57.605] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[08:27:57.605] 
[08:27:57.605] getGlobalsAndPackages() ... DONE
[08:27:57.605] run() for ‘Future’ ...
[08:27:57.605] - state: ‘created’
[08:27:57.605] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:57.606] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:57.606] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:57.606]   - Field: ‘label’
[08:27:57.606]   - Field: ‘local’
[08:27:57.606]   - Field: ‘owner’
[08:27:57.606]   - Field: ‘envir’
[08:27:57.606]   - Field: ‘packages’
[08:27:57.606]   - Field: ‘gc’
[08:27:57.606]   - Field: ‘conditions’
[08:27:57.606]   - Field: ‘expr’
[08:27:57.606]   - Field: ‘uuid’
[08:27:57.607]   - Field: ‘seed’
[08:27:57.607]   - Field: ‘version’
[08:27:57.607]   - Field: ‘result’
[08:27:57.607]   - Field: ‘asynchronous’
[08:27:57.607]   - Field: ‘calls’
[08:27:57.607]   - Field: ‘globals’
[08:27:57.607]   - Field: ‘stdout’
[08:27:57.607]   - Field: ‘earlySignal’
[08:27:57.607]   - Field: ‘lazy’
[08:27:57.607]   - Field: ‘state’
[08:27:57.607] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:57.607] - Launch lazy future ...
[08:27:57.608] Packages needed by the future expression (n = 0): <none>
[08:27:57.608] Packages needed by future strategies (n = 0): <none>
[08:27:57.608] {
[08:27:57.608]     {
[08:27:57.608]         {
[08:27:57.608]             ...future.startTime <- base::Sys.time()
[08:27:57.608]             {
[08:27:57.608]                 {
[08:27:57.608]                   {
[08:27:57.608]                     base::local({
[08:27:57.608]                       has_future <- base::requireNamespace("future", 
[08:27:57.608]                         quietly = TRUE)
[08:27:57.608]                       if (has_future) {
[08:27:57.608]                         ns <- base::getNamespace("future")
[08:27:57.608]                         version <- ns[[".package"]][["version"]]
[08:27:57.608]                         if (is.null(version)) 
[08:27:57.608]                           version <- utils::packageVersion("future")
[08:27:57.608]                       }
[08:27:57.608]                       else {
[08:27:57.608]                         version <- NULL
[08:27:57.608]                       }
[08:27:57.608]                       if (!has_future || version < "1.8.0") {
[08:27:57.608]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.608]                           "", base::R.version$version.string), 
[08:27:57.608]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:57.608]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:57.608]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.608]                             "release", "version")], collapse = " "), 
[08:27:57.608]                           hostname = base::Sys.info()[["nodename"]])
[08:27:57.608]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.608]                           info)
[08:27:57.608]                         info <- base::paste(info, collapse = "; ")
[08:27:57.608]                         if (!has_future) {
[08:27:57.608]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.608]                             info)
[08:27:57.608]                         }
[08:27:57.608]                         else {
[08:27:57.608]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.608]                             info, version)
[08:27:57.608]                         }
[08:27:57.608]                         base::stop(msg)
[08:27:57.608]                       }
[08:27:57.608]                     })
[08:27:57.608]                   }
[08:27:57.608]                   ...future.strategy.old <- future::plan("list")
[08:27:57.608]                   options(future.plan = NULL)
[08:27:57.608]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.608]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.608]                 }
[08:27:57.608]                 ...future.workdir <- getwd()
[08:27:57.608]             }
[08:27:57.608]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.608]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.608]         }
[08:27:57.608]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.608]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.608]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.608]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.608]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.608]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.608]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.608]             base::names(...future.oldOptions))
[08:27:57.608]     }
[08:27:57.608]     if (FALSE) {
[08:27:57.608]     }
[08:27:57.608]     else {
[08:27:57.608]         if (TRUE) {
[08:27:57.608]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.608]                 open = "w")
[08:27:57.608]         }
[08:27:57.608]         else {
[08:27:57.608]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.608]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.608]         }
[08:27:57.608]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.608]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.608]             base::sink(type = "output", split = FALSE)
[08:27:57.608]             base::close(...future.stdout)
[08:27:57.608]         }, add = TRUE)
[08:27:57.608]     }
[08:27:57.608]     ...future.frame <- base::sys.nframe()
[08:27:57.608]     ...future.conditions <- base::list()
[08:27:57.608]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.608]     if (FALSE) {
[08:27:57.608]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.608]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.608]     }
[08:27:57.608]     ...future.result <- base::tryCatch({
[08:27:57.608]         base::withCallingHandlers({
[08:27:57.608]             ...future.value <- base::withVisible(base::local({
[08:27:57.608]                 outer_function(1L)
[08:27:57.608]             }))
[08:27:57.608]             future::FutureResult(value = ...future.value$value, 
[08:27:57.608]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.608]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.608]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.608]                     ...future.globalenv.names))
[08:27:57.608]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.608]         }, condition = base::local({
[08:27:57.608]             c <- base::c
[08:27:57.608]             inherits <- base::inherits
[08:27:57.608]             invokeRestart <- base::invokeRestart
[08:27:57.608]             length <- base::length
[08:27:57.608]             list <- base::list
[08:27:57.608]             seq.int <- base::seq.int
[08:27:57.608]             signalCondition <- base::signalCondition
[08:27:57.608]             sys.calls <- base::sys.calls
[08:27:57.608]             `[[` <- base::`[[`
[08:27:57.608]             `+` <- base::`+`
[08:27:57.608]             `<<-` <- base::`<<-`
[08:27:57.608]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.608]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.608]                   3L)]
[08:27:57.608]             }
[08:27:57.608]             function(cond) {
[08:27:57.608]                 is_error <- inherits(cond, "error")
[08:27:57.608]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.608]                   NULL)
[08:27:57.608]                 if (is_error) {
[08:27:57.608]                   sessionInformation <- function() {
[08:27:57.608]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.608]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.608]                       search = base::search(), system = base::Sys.info())
[08:27:57.608]                   }
[08:27:57.608]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.608]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.608]                     cond$call), session = sessionInformation(), 
[08:27:57.608]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.608]                   signalCondition(cond)
[08:27:57.608]                 }
[08:27:57.608]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.608]                 "immediateCondition"))) {
[08:27:57.608]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.608]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.608]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.608]                   if (TRUE && !signal) {
[08:27:57.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.608]                     {
[08:27:57.608]                       inherits <- base::inherits
[08:27:57.608]                       invokeRestart <- base::invokeRestart
[08:27:57.608]                       is.null <- base::is.null
[08:27:57.608]                       muffled <- FALSE
[08:27:57.608]                       if (inherits(cond, "message")) {
[08:27:57.608]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.608]                         if (muffled) 
[08:27:57.608]                           invokeRestart("muffleMessage")
[08:27:57.608]                       }
[08:27:57.608]                       else if (inherits(cond, "warning")) {
[08:27:57.608]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.608]                         if (muffled) 
[08:27:57.608]                           invokeRestart("muffleWarning")
[08:27:57.608]                       }
[08:27:57.608]                       else if (inherits(cond, "condition")) {
[08:27:57.608]                         if (!is.null(pattern)) {
[08:27:57.608]                           computeRestarts <- base::computeRestarts
[08:27:57.608]                           grepl <- base::grepl
[08:27:57.608]                           restarts <- computeRestarts(cond)
[08:27:57.608]                           for (restart in restarts) {
[08:27:57.608]                             name <- restart$name
[08:27:57.608]                             if (is.null(name)) 
[08:27:57.608]                               next
[08:27:57.608]                             if (!grepl(pattern, name)) 
[08:27:57.608]                               next
[08:27:57.608]                             invokeRestart(restart)
[08:27:57.608]                             muffled <- TRUE
[08:27:57.608]                             break
[08:27:57.608]                           }
[08:27:57.608]                         }
[08:27:57.608]                       }
[08:27:57.608]                       invisible(muffled)
[08:27:57.608]                     }
[08:27:57.608]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.608]                   }
[08:27:57.608]                 }
[08:27:57.608]                 else {
[08:27:57.608]                   if (TRUE) {
[08:27:57.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.608]                     {
[08:27:57.608]                       inherits <- base::inherits
[08:27:57.608]                       invokeRestart <- base::invokeRestart
[08:27:57.608]                       is.null <- base::is.null
[08:27:57.608]                       muffled <- FALSE
[08:27:57.608]                       if (inherits(cond, "message")) {
[08:27:57.608]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.608]                         if (muffled) 
[08:27:57.608]                           invokeRestart("muffleMessage")
[08:27:57.608]                       }
[08:27:57.608]                       else if (inherits(cond, "warning")) {
[08:27:57.608]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.608]                         if (muffled) 
[08:27:57.608]                           invokeRestart("muffleWarning")
[08:27:57.608]                       }
[08:27:57.608]                       else if (inherits(cond, "condition")) {
[08:27:57.608]                         if (!is.null(pattern)) {
[08:27:57.608]                           computeRestarts <- base::computeRestarts
[08:27:57.608]                           grepl <- base::grepl
[08:27:57.608]                           restarts <- computeRestarts(cond)
[08:27:57.608]                           for (restart in restarts) {
[08:27:57.608]                             name <- restart$name
[08:27:57.608]                             if (is.null(name)) 
[08:27:57.608]                               next
[08:27:57.608]                             if (!grepl(pattern, name)) 
[08:27:57.608]                               next
[08:27:57.608]                             invokeRestart(restart)
[08:27:57.608]                             muffled <- TRUE
[08:27:57.608]                             break
[08:27:57.608]                           }
[08:27:57.608]                         }
[08:27:57.608]                       }
[08:27:57.608]                       invisible(muffled)
[08:27:57.608]                     }
[08:27:57.608]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.608]                   }
[08:27:57.608]                 }
[08:27:57.608]             }
[08:27:57.608]         }))
[08:27:57.608]     }, error = function(ex) {
[08:27:57.608]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.608]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.608]                 ...future.rng), started = ...future.startTime, 
[08:27:57.608]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.608]             version = "1.8"), class = "FutureResult")
[08:27:57.608]     }, finally = {
[08:27:57.608]         if (!identical(...future.workdir, getwd())) 
[08:27:57.608]             setwd(...future.workdir)
[08:27:57.608]         {
[08:27:57.608]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.608]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.608]             }
[08:27:57.608]             base::options(...future.oldOptions)
[08:27:57.608]             if (.Platform$OS.type == "windows") {
[08:27:57.608]                 old_names <- names(...future.oldEnvVars)
[08:27:57.608]                 envs <- base::Sys.getenv()
[08:27:57.608]                 names <- names(envs)
[08:27:57.608]                 common <- intersect(names, old_names)
[08:27:57.608]                 added <- setdiff(names, old_names)
[08:27:57.608]                 removed <- setdiff(old_names, names)
[08:27:57.608]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.608]                   envs[common]]
[08:27:57.608]                 NAMES <- toupper(changed)
[08:27:57.608]                 args <- list()
[08:27:57.608]                 for (kk in seq_along(NAMES)) {
[08:27:57.608]                   name <- changed[[kk]]
[08:27:57.608]                   NAME <- NAMES[[kk]]
[08:27:57.608]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.608]                     next
[08:27:57.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.608]                 }
[08:27:57.608]                 NAMES <- toupper(added)
[08:27:57.608]                 for (kk in seq_along(NAMES)) {
[08:27:57.608]                   name <- added[[kk]]
[08:27:57.608]                   NAME <- NAMES[[kk]]
[08:27:57.608]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.608]                     next
[08:27:57.608]                   args[[name]] <- ""
[08:27:57.608]                 }
[08:27:57.608]                 NAMES <- toupper(removed)
[08:27:57.608]                 for (kk in seq_along(NAMES)) {
[08:27:57.608]                   name <- removed[[kk]]
[08:27:57.608]                   NAME <- NAMES[[kk]]
[08:27:57.608]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.608]                     next
[08:27:57.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.608]                 }
[08:27:57.608]                 if (length(args) > 0) 
[08:27:57.608]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.608]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.608]             }
[08:27:57.608]             else {
[08:27:57.608]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.608]             }
[08:27:57.608]             {
[08:27:57.608]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.608]                   0L) {
[08:27:57.608]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.608]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.608]                   base::options(opts)
[08:27:57.608]                 }
[08:27:57.608]                 {
[08:27:57.608]                   {
[08:27:57.608]                     NULL
[08:27:57.608]                     RNGkind("Mersenne-Twister")
[08:27:57.608]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:57.608]                       inherits = FALSE)
[08:27:57.608]                   }
[08:27:57.608]                   options(future.plan = NULL)
[08:27:57.608]                   if (is.na(NA_character_)) 
[08:27:57.608]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.608]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.608]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.608]                     .init = FALSE)
[08:27:57.608]                 }
[08:27:57.608]             }
[08:27:57.608]         }
[08:27:57.608]     })
[08:27:57.608]     if (TRUE) {
[08:27:57.608]         base::sink(type = "output", split = FALSE)
[08:27:57.608]         if (TRUE) {
[08:27:57.608]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.608]         }
[08:27:57.608]         else {
[08:27:57.608]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.608]         }
[08:27:57.608]         base::close(...future.stdout)
[08:27:57.608]         ...future.stdout <- NULL
[08:27:57.608]     }
[08:27:57.608]     ...future.result$conditions <- ...future.conditions
[08:27:57.608]     ...future.result$finished <- base::Sys.time()
[08:27:57.608]     ...future.result
[08:27:57.608] }
[08:27:57.610] assign_globals() ...
[08:27:57.610] List of 3
[08:27:57.610]  $ outer_function:function (x)  
[08:27:57.610]  $ map           :function (.x, .f, ...)  
[08:27:57.610]  $ inner_function:function (x)  
[08:27:57.610]  - attr(*, "where")=List of 3
[08:27:57.610]   ..$ outer_function:<environment: R_EmptyEnv> 
[08:27:57.610]   ..$ map           :<environment: R_EmptyEnv> 
[08:27:57.610]   ..$ inner_function:<environment: R_EmptyEnv> 
[08:27:57.610]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:57.610]  - attr(*, "resolved")= logi FALSE
[08:27:57.610]  - attr(*, "total_size")= num 1254
[08:27:57.610]  - attr(*, "already-done")= logi TRUE
[08:27:57.613] - reassign environment for ‘outer_function’
[08:27:57.613] - copied ‘outer_function’ to environment
[08:27:57.613] - reassign environment for ‘map’
[08:27:57.613] - copied ‘map’ to environment
[08:27:57.613] - reassign environment for ‘inner_function’
[08:27:57.613] - copied ‘inner_function’ to environment
[08:27:57.613] assign_globals() ... done
[08:27:57.614] plan(): Setting new future strategy stack:
[08:27:57.614] List of future strategies:
[08:27:57.614] 1. sequential:
[08:27:57.614]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.614]    - tweaked: FALSE
[08:27:57.614]    - call: NULL
[08:27:57.614] plan(): nbrOfWorkers() = 1
[08:27:57.615] plan(): Setting new future strategy stack:
[08:27:57.615] List of future strategies:
[08:27:57.615] 1. sequential:
[08:27:57.615]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.615]    - tweaked: FALSE
[08:27:57.615]    - call: plan(strategy)
[08:27:57.615] plan(): nbrOfWorkers() = 1
[08:27:57.616] SequentialFuture started (and completed)
[08:27:57.616] - Launch lazy future ... done
[08:27:57.616] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[08:27:57.624] plan(): Setting new future strategy stack:
[08:27:57.624] List of future strategies:
[08:27:57.624] 1. multicore:
[08:27:57.624]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:57.624]    - tweaked: FALSE
[08:27:57.624]    - call: plan(strategy)
[08:27:57.626] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[08:27:57.626] getGlobalsAndPackages() ...
[08:27:57.626] Searching for globals...
[08:27:57.628] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[08:27:57.628] Searching for globals ... DONE
[08:27:57.628] Resolving globals: FALSE
[08:27:57.628] The total size of the 2 globals is 401 bytes (401 bytes)
[08:27:57.629] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[08:27:57.629] - globals: [2] ‘weight’, ‘group’
[08:27:57.629] - packages: [1] ‘stats’
[08:27:57.629] getGlobalsAndPackages() ... DONE
[08:27:57.629] run() for ‘Future’ ...
[08:27:57.629] - state: ‘created’
[08:27:57.630] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:57.631] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:57.631] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:57.631]   - Field: ‘label’
[08:27:57.631]   - Field: ‘local’
[08:27:57.632]   - Field: ‘owner’
[08:27:57.632]   - Field: ‘envir’
[08:27:57.632]   - Field: ‘workers’
[08:27:57.632]   - Field: ‘packages’
[08:27:57.632]   - Field: ‘gc’
[08:27:57.632]   - Field: ‘job’
[08:27:57.632]   - Field: ‘conditions’
[08:27:57.632]   - Field: ‘expr’
[08:27:57.632]   - Field: ‘uuid’
[08:27:57.632]   - Field: ‘seed’
[08:27:57.632]   - Field: ‘version’
[08:27:57.632]   - Field: ‘result’
[08:27:57.633]   - Field: ‘asynchronous’
[08:27:57.633]   - Field: ‘calls’
[08:27:57.633]   - Field: ‘globals’
[08:27:57.633]   - Field: ‘stdout’
[08:27:57.633]   - Field: ‘earlySignal’
[08:27:57.633]   - Field: ‘lazy’
[08:27:57.633]   - Field: ‘state’
[08:27:57.633] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:57.633] - Launch lazy future ...
[08:27:57.634] Packages needed by the future expression (n = 1): ‘stats’
[08:27:57.634] Packages needed by future strategies (n = 0): <none>
[08:27:57.635] {
[08:27:57.635]     {
[08:27:57.635]         {
[08:27:57.635]             ...future.startTime <- base::Sys.time()
[08:27:57.635]             {
[08:27:57.635]                 {
[08:27:57.635]                   {
[08:27:57.635]                     {
[08:27:57.635]                       {
[08:27:57.635]                         base::local({
[08:27:57.635]                           has_future <- base::requireNamespace("future", 
[08:27:57.635]                             quietly = TRUE)
[08:27:57.635]                           if (has_future) {
[08:27:57.635]                             ns <- base::getNamespace("future")
[08:27:57.635]                             version <- ns[[".package"]][["version"]]
[08:27:57.635]                             if (is.null(version)) 
[08:27:57.635]                               version <- utils::packageVersion("future")
[08:27:57.635]                           }
[08:27:57.635]                           else {
[08:27:57.635]                             version <- NULL
[08:27:57.635]                           }
[08:27:57.635]                           if (!has_future || version < "1.8.0") {
[08:27:57.635]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.635]                               "", base::R.version$version.string), 
[08:27:57.635]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:57.635]                                 base::R.version$platform, 8 * 
[08:27:57.635]                                   base::.Machine$sizeof.pointer), 
[08:27:57.635]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.635]                                 "release", "version")], collapse = " "), 
[08:27:57.635]                               hostname = base::Sys.info()[["nodename"]])
[08:27:57.635]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.635]                               info)
[08:27:57.635]                             info <- base::paste(info, collapse = "; ")
[08:27:57.635]                             if (!has_future) {
[08:27:57.635]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.635]                                 info)
[08:27:57.635]                             }
[08:27:57.635]                             else {
[08:27:57.635]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.635]                                 info, version)
[08:27:57.635]                             }
[08:27:57.635]                             base::stop(msg)
[08:27:57.635]                           }
[08:27:57.635]                         })
[08:27:57.635]                       }
[08:27:57.635]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:57.635]                       base::options(mc.cores = 1L)
[08:27:57.635]                     }
[08:27:57.635]                     base::local({
[08:27:57.635]                       for (pkg in "stats") {
[08:27:57.635]                         base::loadNamespace(pkg)
[08:27:57.635]                         base::library(pkg, character.only = TRUE)
[08:27:57.635]                       }
[08:27:57.635]                     })
[08:27:57.635]                   }
[08:27:57.635]                   ...future.strategy.old <- future::plan("list")
[08:27:57.635]                   options(future.plan = NULL)
[08:27:57.635]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.635]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.635]                 }
[08:27:57.635]                 ...future.workdir <- getwd()
[08:27:57.635]             }
[08:27:57.635]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.635]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.635]         }
[08:27:57.635]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.635]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.635]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.635]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.635]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.635]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.635]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.635]             base::names(...future.oldOptions))
[08:27:57.635]     }
[08:27:57.635]     if (FALSE) {
[08:27:57.635]     }
[08:27:57.635]     else {
[08:27:57.635]         if (TRUE) {
[08:27:57.635]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.635]                 open = "w")
[08:27:57.635]         }
[08:27:57.635]         else {
[08:27:57.635]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.635]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.635]         }
[08:27:57.635]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.635]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.635]             base::sink(type = "output", split = FALSE)
[08:27:57.635]             base::close(...future.stdout)
[08:27:57.635]         }, add = TRUE)
[08:27:57.635]     }
[08:27:57.635]     ...future.frame <- base::sys.nframe()
[08:27:57.635]     ...future.conditions <- base::list()
[08:27:57.635]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.635]     if (FALSE) {
[08:27:57.635]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.635]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.635]     }
[08:27:57.635]     ...future.result <- base::tryCatch({
[08:27:57.635]         base::withCallingHandlers({
[08:27:57.635]             ...future.value <- base::withVisible(base::local({
[08:27:57.635]                 withCallingHandlers({
[08:27:57.635]                   {
[08:27:57.635]                     lm(weight ~ group - 1)
[08:27:57.635]                   }
[08:27:57.635]                 }, immediateCondition = function(cond) {
[08:27:57.635]                   save_rds <- function (object, pathname, ...) 
[08:27:57.635]                   {
[08:27:57.635]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:57.635]                     if (file_test("-f", pathname_tmp)) {
[08:27:57.635]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.635]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:57.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.635]                         fi_tmp[["mtime"]])
[08:27:57.635]                     }
[08:27:57.635]                     tryCatch({
[08:27:57.635]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:57.635]                     }, error = function(ex) {
[08:27:57.635]                       msg <- conditionMessage(ex)
[08:27:57.635]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.635]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:57.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.635]                         fi_tmp[["mtime"]], msg)
[08:27:57.635]                       ex$message <- msg
[08:27:57.635]                       stop(ex)
[08:27:57.635]                     })
[08:27:57.635]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:57.635]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:57.635]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:57.635]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.635]                       fi <- file.info(pathname)
[08:27:57.635]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:57.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.635]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:57.635]                         fi[["size"]], fi[["mtime"]])
[08:27:57.635]                       stop(msg)
[08:27:57.635]                     }
[08:27:57.635]                     invisible(pathname)
[08:27:57.635]                   }
[08:27:57.635]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:57.635]                     rootPath = tempdir()) 
[08:27:57.635]                   {
[08:27:57.635]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:57.635]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:57.635]                       tmpdir = path, fileext = ".rds")
[08:27:57.635]                     save_rds(obj, file)
[08:27:57.635]                   }
[08:27:57.635]                   saveImmediateCondition(cond, path = "/tmp/RtmpUQjont/.future/immediateConditions")
[08:27:57.635]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.635]                   {
[08:27:57.635]                     inherits <- base::inherits
[08:27:57.635]                     invokeRestart <- base::invokeRestart
[08:27:57.635]                     is.null <- base::is.null
[08:27:57.635]                     muffled <- FALSE
[08:27:57.635]                     if (inherits(cond, "message")) {
[08:27:57.635]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:57.635]                       if (muffled) 
[08:27:57.635]                         invokeRestart("muffleMessage")
[08:27:57.635]                     }
[08:27:57.635]                     else if (inherits(cond, "warning")) {
[08:27:57.635]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:57.635]                       if (muffled) 
[08:27:57.635]                         invokeRestart("muffleWarning")
[08:27:57.635]                     }
[08:27:57.635]                     else if (inherits(cond, "condition")) {
[08:27:57.635]                       if (!is.null(pattern)) {
[08:27:57.635]                         computeRestarts <- base::computeRestarts
[08:27:57.635]                         grepl <- base::grepl
[08:27:57.635]                         restarts <- computeRestarts(cond)
[08:27:57.635]                         for (restart in restarts) {
[08:27:57.635]                           name <- restart$name
[08:27:57.635]                           if (is.null(name)) 
[08:27:57.635]                             next
[08:27:57.635]                           if (!grepl(pattern, name)) 
[08:27:57.635]                             next
[08:27:57.635]                           invokeRestart(restart)
[08:27:57.635]                           muffled <- TRUE
[08:27:57.635]                           break
[08:27:57.635]                         }
[08:27:57.635]                       }
[08:27:57.635]                     }
[08:27:57.635]                     invisible(muffled)
[08:27:57.635]                   }
[08:27:57.635]                   muffleCondition(cond)
[08:27:57.635]                 })
[08:27:57.635]             }))
[08:27:57.635]             future::FutureResult(value = ...future.value$value, 
[08:27:57.635]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.635]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.635]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.635]                     ...future.globalenv.names))
[08:27:57.635]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.635]         }, condition = base::local({
[08:27:57.635]             c <- base::c
[08:27:57.635]             inherits <- base::inherits
[08:27:57.635]             invokeRestart <- base::invokeRestart
[08:27:57.635]             length <- base::length
[08:27:57.635]             list <- base::list
[08:27:57.635]             seq.int <- base::seq.int
[08:27:57.635]             signalCondition <- base::signalCondition
[08:27:57.635]             sys.calls <- base::sys.calls
[08:27:57.635]             `[[` <- base::`[[`
[08:27:57.635]             `+` <- base::`+`
[08:27:57.635]             `<<-` <- base::`<<-`
[08:27:57.635]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.635]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.635]                   3L)]
[08:27:57.635]             }
[08:27:57.635]             function(cond) {
[08:27:57.635]                 is_error <- inherits(cond, "error")
[08:27:57.635]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.635]                   NULL)
[08:27:57.635]                 if (is_error) {
[08:27:57.635]                   sessionInformation <- function() {
[08:27:57.635]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.635]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.635]                       search = base::search(), system = base::Sys.info())
[08:27:57.635]                   }
[08:27:57.635]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.635]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.635]                     cond$call), session = sessionInformation(), 
[08:27:57.635]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.635]                   signalCondition(cond)
[08:27:57.635]                 }
[08:27:57.635]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.635]                 "immediateCondition"))) {
[08:27:57.635]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.635]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.635]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.635]                   if (TRUE && !signal) {
[08:27:57.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.635]                     {
[08:27:57.635]                       inherits <- base::inherits
[08:27:57.635]                       invokeRestart <- base::invokeRestart
[08:27:57.635]                       is.null <- base::is.null
[08:27:57.635]                       muffled <- FALSE
[08:27:57.635]                       if (inherits(cond, "message")) {
[08:27:57.635]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.635]                         if (muffled) 
[08:27:57.635]                           invokeRestart("muffleMessage")
[08:27:57.635]                       }
[08:27:57.635]                       else if (inherits(cond, "warning")) {
[08:27:57.635]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.635]                         if (muffled) 
[08:27:57.635]                           invokeRestart("muffleWarning")
[08:27:57.635]                       }
[08:27:57.635]                       else if (inherits(cond, "condition")) {
[08:27:57.635]                         if (!is.null(pattern)) {
[08:27:57.635]                           computeRestarts <- base::computeRestarts
[08:27:57.635]                           grepl <- base::grepl
[08:27:57.635]                           restarts <- computeRestarts(cond)
[08:27:57.635]                           for (restart in restarts) {
[08:27:57.635]                             name <- restart$name
[08:27:57.635]                             if (is.null(name)) 
[08:27:57.635]                               next
[08:27:57.635]                             if (!grepl(pattern, name)) 
[08:27:57.635]                               next
[08:27:57.635]                             invokeRestart(restart)
[08:27:57.635]                             muffled <- TRUE
[08:27:57.635]                             break
[08:27:57.635]                           }
[08:27:57.635]                         }
[08:27:57.635]                       }
[08:27:57.635]                       invisible(muffled)
[08:27:57.635]                     }
[08:27:57.635]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.635]                   }
[08:27:57.635]                 }
[08:27:57.635]                 else {
[08:27:57.635]                   if (TRUE) {
[08:27:57.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.635]                     {
[08:27:57.635]                       inherits <- base::inherits
[08:27:57.635]                       invokeRestart <- base::invokeRestart
[08:27:57.635]                       is.null <- base::is.null
[08:27:57.635]                       muffled <- FALSE
[08:27:57.635]                       if (inherits(cond, "message")) {
[08:27:57.635]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.635]                         if (muffled) 
[08:27:57.635]                           invokeRestart("muffleMessage")
[08:27:57.635]                       }
[08:27:57.635]                       else if (inherits(cond, "warning")) {
[08:27:57.635]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.635]                         if (muffled) 
[08:27:57.635]                           invokeRestart("muffleWarning")
[08:27:57.635]                       }
[08:27:57.635]                       else if (inherits(cond, "condition")) {
[08:27:57.635]                         if (!is.null(pattern)) {
[08:27:57.635]                           computeRestarts <- base::computeRestarts
[08:27:57.635]                           grepl <- base::grepl
[08:27:57.635]                           restarts <- computeRestarts(cond)
[08:27:57.635]                           for (restart in restarts) {
[08:27:57.635]                             name <- restart$name
[08:27:57.635]                             if (is.null(name)) 
[08:27:57.635]                               next
[08:27:57.635]                             if (!grepl(pattern, name)) 
[08:27:57.635]                               next
[08:27:57.635]                             invokeRestart(restart)
[08:27:57.635]                             muffled <- TRUE
[08:27:57.635]                             break
[08:27:57.635]                           }
[08:27:57.635]                         }
[08:27:57.635]                       }
[08:27:57.635]                       invisible(muffled)
[08:27:57.635]                     }
[08:27:57.635]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.635]                   }
[08:27:57.635]                 }
[08:27:57.635]             }
[08:27:57.635]         }))
[08:27:57.635]     }, error = function(ex) {
[08:27:57.635]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.635]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.635]                 ...future.rng), started = ...future.startTime, 
[08:27:57.635]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.635]             version = "1.8"), class = "FutureResult")
[08:27:57.635]     }, finally = {
[08:27:57.635]         if (!identical(...future.workdir, getwd())) 
[08:27:57.635]             setwd(...future.workdir)
[08:27:57.635]         {
[08:27:57.635]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.635]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.635]             }
[08:27:57.635]             base::options(...future.oldOptions)
[08:27:57.635]             if (.Platform$OS.type == "windows") {
[08:27:57.635]                 old_names <- names(...future.oldEnvVars)
[08:27:57.635]                 envs <- base::Sys.getenv()
[08:27:57.635]                 names <- names(envs)
[08:27:57.635]                 common <- intersect(names, old_names)
[08:27:57.635]                 added <- setdiff(names, old_names)
[08:27:57.635]                 removed <- setdiff(old_names, names)
[08:27:57.635]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.635]                   envs[common]]
[08:27:57.635]                 NAMES <- toupper(changed)
[08:27:57.635]                 args <- list()
[08:27:57.635]                 for (kk in seq_along(NAMES)) {
[08:27:57.635]                   name <- changed[[kk]]
[08:27:57.635]                   NAME <- NAMES[[kk]]
[08:27:57.635]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.635]                     next
[08:27:57.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.635]                 }
[08:27:57.635]                 NAMES <- toupper(added)
[08:27:57.635]                 for (kk in seq_along(NAMES)) {
[08:27:57.635]                   name <- added[[kk]]
[08:27:57.635]                   NAME <- NAMES[[kk]]
[08:27:57.635]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.635]                     next
[08:27:57.635]                   args[[name]] <- ""
[08:27:57.635]                 }
[08:27:57.635]                 NAMES <- toupper(removed)
[08:27:57.635]                 for (kk in seq_along(NAMES)) {
[08:27:57.635]                   name <- removed[[kk]]
[08:27:57.635]                   NAME <- NAMES[[kk]]
[08:27:57.635]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.635]                     next
[08:27:57.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.635]                 }
[08:27:57.635]                 if (length(args) > 0) 
[08:27:57.635]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.635]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.635]             }
[08:27:57.635]             else {
[08:27:57.635]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.635]             }
[08:27:57.635]             {
[08:27:57.635]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.635]                   0L) {
[08:27:57.635]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.635]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.635]                   base::options(opts)
[08:27:57.635]                 }
[08:27:57.635]                 {
[08:27:57.635]                   {
[08:27:57.635]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:57.635]                     NULL
[08:27:57.635]                   }
[08:27:57.635]                   options(future.plan = NULL)
[08:27:57.635]                   if (is.na(NA_character_)) 
[08:27:57.635]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.635]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.635]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.635]                     .init = FALSE)
[08:27:57.635]                 }
[08:27:57.635]             }
[08:27:57.635]         }
[08:27:57.635]     })
[08:27:57.635]     if (TRUE) {
[08:27:57.635]         base::sink(type = "output", split = FALSE)
[08:27:57.635]         if (TRUE) {
[08:27:57.635]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.635]         }
[08:27:57.635]         else {
[08:27:57.635]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.635]         }
[08:27:57.635]         base::close(...future.stdout)
[08:27:57.635]         ...future.stdout <- NULL
[08:27:57.635]     }
[08:27:57.635]     ...future.result$conditions <- ...future.conditions
[08:27:57.635]     ...future.result$finished <- base::Sys.time()
[08:27:57.635]     ...future.result
[08:27:57.635] }
[08:27:57.637] assign_globals() ...
[08:27:57.637] List of 2
[08:27:57.637]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[08:27:57.637]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[08:27:57.637]  - attr(*, "where")=List of 2
[08:27:57.637]   ..$ weight:<environment: R_EmptyEnv> 
[08:27:57.637]   ..$ group :<environment: R_EmptyEnv> 
[08:27:57.637]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:57.637]  - attr(*, "resolved")= logi FALSE
[08:27:57.637]  - attr(*, "total_size")= num 401
[08:27:57.637]  - attr(*, "already-done")= logi TRUE
[08:27:57.640] - copied ‘weight’ to environment
[08:27:57.640] - copied ‘group’ to environment
[08:27:57.640] assign_globals() ... done
[08:27:57.640] requestCore(): workers = 2
[08:27:57.643] MulticoreFuture started
[08:27:57.644] - Launch lazy future ... done
[08:27:57.644] run() for ‘MulticoreFuture’ ... done
[08:27:57.644] plan(): Setting new future strategy stack:
[08:27:57.645] result() for MulticoreFuture ...
[08:27:57.644] List of future strategies:
[08:27:57.644] 1. sequential:
[08:27:57.644]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.644]    - tweaked: FALSE
[08:27:57.644]    - call: NULL
[08:27:57.645] plan(): nbrOfWorkers() = 1
[08:27:57.649] plan(): Setting new future strategy stack:
[08:27:57.649] List of future strategies:
[08:27:57.649] 1. multicore:
[08:27:57.649]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:57.649]    - tweaked: FALSE
[08:27:57.649]    - call: plan(strategy)
[08:27:57.652] plan(): nbrOfWorkers() = 2
[08:27:57.658] result() for MulticoreFuture ...
[08:27:57.658] result() for MulticoreFuture ... done
[08:27:57.658] result() for MulticoreFuture ... done
[08:27:57.659] result() for MulticoreFuture ...
[08:27:57.659] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[08:27:57.661] getGlobalsAndPackages() ...
[08:27:57.661] Searching for globals...
[08:27:57.666] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[08:27:57.666] Searching for globals ... DONE
[08:27:57.666] Resolving globals: FALSE
[08:27:57.667] The total size of the 2 globals is 401 bytes (401 bytes)
[08:27:57.667] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[08:27:57.667] - globals: [2] ‘weight’, ‘group’
[08:27:57.667] - packages: [1] ‘stats’
[08:27:57.668] getGlobalsAndPackages() ... DONE
[08:27:57.668] run() for ‘Future’ ...
[08:27:57.668] - state: ‘created’
[08:27:57.668] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:57.670] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:57.670] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:57.671]   - Field: ‘label’
[08:27:57.671]   - Field: ‘local’
[08:27:57.671]   - Field: ‘owner’
[08:27:57.671]   - Field: ‘envir’
[08:27:57.671]   - Field: ‘workers’
[08:27:57.671]   - Field: ‘packages’
[08:27:57.671]   - Field: ‘gc’
[08:27:57.671]   - Field: ‘job’
[08:27:57.671]   - Field: ‘conditions’
[08:27:57.672]   - Field: ‘expr’
[08:27:57.672]   - Field: ‘uuid’
[08:27:57.672]   - Field: ‘seed’
[08:27:57.672]   - Field: ‘version’
[08:27:57.672]   - Field: ‘result’
[08:27:57.672]   - Field: ‘asynchronous’
[08:27:57.672]   - Field: ‘calls’
[08:27:57.672]   - Field: ‘globals’
[08:27:57.672]   - Field: ‘stdout’
[08:27:57.673]   - Field: ‘earlySignal’
[08:27:57.673]   - Field: ‘lazy’
[08:27:57.673]   - Field: ‘state’
[08:27:57.673] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:57.673] - Launch lazy future ...
[08:27:57.673] Packages needed by the future expression (n = 1): ‘stats’
[08:27:57.673] Packages needed by future strategies (n = 0): <none>
[08:27:57.674] {
[08:27:57.674]     {
[08:27:57.674]         {
[08:27:57.674]             ...future.startTime <- base::Sys.time()
[08:27:57.674]             {
[08:27:57.674]                 {
[08:27:57.674]                   {
[08:27:57.674]                     {
[08:27:57.674]                       {
[08:27:57.674]                         base::local({
[08:27:57.674]                           has_future <- base::requireNamespace("future", 
[08:27:57.674]                             quietly = TRUE)
[08:27:57.674]                           if (has_future) {
[08:27:57.674]                             ns <- base::getNamespace("future")
[08:27:57.674]                             version <- ns[[".package"]][["version"]]
[08:27:57.674]                             if (is.null(version)) 
[08:27:57.674]                               version <- utils::packageVersion("future")
[08:27:57.674]                           }
[08:27:57.674]                           else {
[08:27:57.674]                             version <- NULL
[08:27:57.674]                           }
[08:27:57.674]                           if (!has_future || version < "1.8.0") {
[08:27:57.674]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.674]                               "", base::R.version$version.string), 
[08:27:57.674]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:57.674]                                 base::R.version$platform, 8 * 
[08:27:57.674]                                   base::.Machine$sizeof.pointer), 
[08:27:57.674]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.674]                                 "release", "version")], collapse = " "), 
[08:27:57.674]                               hostname = base::Sys.info()[["nodename"]])
[08:27:57.674]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.674]                               info)
[08:27:57.674]                             info <- base::paste(info, collapse = "; ")
[08:27:57.674]                             if (!has_future) {
[08:27:57.674]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.674]                                 info)
[08:27:57.674]                             }
[08:27:57.674]                             else {
[08:27:57.674]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.674]                                 info, version)
[08:27:57.674]                             }
[08:27:57.674]                             base::stop(msg)
[08:27:57.674]                           }
[08:27:57.674]                         })
[08:27:57.674]                       }
[08:27:57.674]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:57.674]                       base::options(mc.cores = 1L)
[08:27:57.674]                     }
[08:27:57.674]                     base::local({
[08:27:57.674]                       for (pkg in "stats") {
[08:27:57.674]                         base::loadNamespace(pkg)
[08:27:57.674]                         base::library(pkg, character.only = TRUE)
[08:27:57.674]                       }
[08:27:57.674]                     })
[08:27:57.674]                   }
[08:27:57.674]                   ...future.strategy.old <- future::plan("list")
[08:27:57.674]                   options(future.plan = NULL)
[08:27:57.674]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.674]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.674]                 }
[08:27:57.674]                 ...future.workdir <- getwd()
[08:27:57.674]             }
[08:27:57.674]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.674]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.674]         }
[08:27:57.674]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.674]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.674]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.674]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.674]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.674]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.674]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.674]             base::names(...future.oldOptions))
[08:27:57.674]     }
[08:27:57.674]     if (FALSE) {
[08:27:57.674]     }
[08:27:57.674]     else {
[08:27:57.674]         if (TRUE) {
[08:27:57.674]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.674]                 open = "w")
[08:27:57.674]         }
[08:27:57.674]         else {
[08:27:57.674]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.674]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.674]         }
[08:27:57.674]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.674]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.674]             base::sink(type = "output", split = FALSE)
[08:27:57.674]             base::close(...future.stdout)
[08:27:57.674]         }, add = TRUE)
[08:27:57.674]     }
[08:27:57.674]     ...future.frame <- base::sys.nframe()
[08:27:57.674]     ...future.conditions <- base::list()
[08:27:57.674]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.674]     if (FALSE) {
[08:27:57.674]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.674]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.674]     }
[08:27:57.674]     ...future.result <- base::tryCatch({
[08:27:57.674]         base::withCallingHandlers({
[08:27:57.674]             ...future.value <- base::withVisible(base::local({
[08:27:57.674]                 withCallingHandlers({
[08:27:57.674]                   {
[08:27:57.674]                     lm(weight ~ group - 1)
[08:27:57.674]                   }
[08:27:57.674]                 }, immediateCondition = function(cond) {
[08:27:57.674]                   save_rds <- function (object, pathname, ...) 
[08:27:57.674]                   {
[08:27:57.674]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:57.674]                     if (file_test("-f", pathname_tmp)) {
[08:27:57.674]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.674]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:57.674]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.674]                         fi_tmp[["mtime"]])
[08:27:57.674]                     }
[08:27:57.674]                     tryCatch({
[08:27:57.674]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:57.674]                     }, error = function(ex) {
[08:27:57.674]                       msg <- conditionMessage(ex)
[08:27:57.674]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.674]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:57.674]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.674]                         fi_tmp[["mtime"]], msg)
[08:27:57.674]                       ex$message <- msg
[08:27:57.674]                       stop(ex)
[08:27:57.674]                     })
[08:27:57.674]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:57.674]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:57.674]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:57.674]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.674]                       fi <- file.info(pathname)
[08:27:57.674]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:57.674]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.674]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:57.674]                         fi[["size"]], fi[["mtime"]])
[08:27:57.674]                       stop(msg)
[08:27:57.674]                     }
[08:27:57.674]                     invisible(pathname)
[08:27:57.674]                   }
[08:27:57.674]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:57.674]                     rootPath = tempdir()) 
[08:27:57.674]                   {
[08:27:57.674]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:57.674]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:57.674]                       tmpdir = path, fileext = ".rds")
[08:27:57.674]                     save_rds(obj, file)
[08:27:57.674]                   }
[08:27:57.674]                   saveImmediateCondition(cond, path = "/tmp/RtmpUQjont/.future/immediateConditions")
[08:27:57.674]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.674]                   {
[08:27:57.674]                     inherits <- base::inherits
[08:27:57.674]                     invokeRestart <- base::invokeRestart
[08:27:57.674]                     is.null <- base::is.null
[08:27:57.674]                     muffled <- FALSE
[08:27:57.674]                     if (inherits(cond, "message")) {
[08:27:57.674]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:57.674]                       if (muffled) 
[08:27:57.674]                         invokeRestart("muffleMessage")
[08:27:57.674]                     }
[08:27:57.674]                     else if (inherits(cond, "warning")) {
[08:27:57.674]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:57.674]                       if (muffled) 
[08:27:57.674]                         invokeRestart("muffleWarning")
[08:27:57.674]                     }
[08:27:57.674]                     else if (inherits(cond, "condition")) {
[08:27:57.674]                       if (!is.null(pattern)) {
[08:27:57.674]                         computeRestarts <- base::computeRestarts
[08:27:57.674]                         grepl <- base::grepl
[08:27:57.674]                         restarts <- computeRestarts(cond)
[08:27:57.674]                         for (restart in restarts) {
[08:27:57.674]                           name <- restart$name
[08:27:57.674]                           if (is.null(name)) 
[08:27:57.674]                             next
[08:27:57.674]                           if (!grepl(pattern, name)) 
[08:27:57.674]                             next
[08:27:57.674]                           invokeRestart(restart)
[08:27:57.674]                           muffled <- TRUE
[08:27:57.674]                           break
[08:27:57.674]                         }
[08:27:57.674]                       }
[08:27:57.674]                     }
[08:27:57.674]                     invisible(muffled)
[08:27:57.674]                   }
[08:27:57.674]                   muffleCondition(cond)
[08:27:57.674]                 })
[08:27:57.674]             }))
[08:27:57.674]             future::FutureResult(value = ...future.value$value, 
[08:27:57.674]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.674]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.674]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.674]                     ...future.globalenv.names))
[08:27:57.674]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.674]         }, condition = base::local({
[08:27:57.674]             c <- base::c
[08:27:57.674]             inherits <- base::inherits
[08:27:57.674]             invokeRestart <- base::invokeRestart
[08:27:57.674]             length <- base::length
[08:27:57.674]             list <- base::list
[08:27:57.674]             seq.int <- base::seq.int
[08:27:57.674]             signalCondition <- base::signalCondition
[08:27:57.674]             sys.calls <- base::sys.calls
[08:27:57.674]             `[[` <- base::`[[`
[08:27:57.674]             `+` <- base::`+`
[08:27:57.674]             `<<-` <- base::`<<-`
[08:27:57.674]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.674]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.674]                   3L)]
[08:27:57.674]             }
[08:27:57.674]             function(cond) {
[08:27:57.674]                 is_error <- inherits(cond, "error")
[08:27:57.674]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.674]                   NULL)
[08:27:57.674]                 if (is_error) {
[08:27:57.674]                   sessionInformation <- function() {
[08:27:57.674]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.674]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.674]                       search = base::search(), system = base::Sys.info())
[08:27:57.674]                   }
[08:27:57.674]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.674]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.674]                     cond$call), session = sessionInformation(), 
[08:27:57.674]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.674]                   signalCondition(cond)
[08:27:57.674]                 }
[08:27:57.674]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.674]                 "immediateCondition"))) {
[08:27:57.674]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.674]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.674]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.674]                   if (TRUE && !signal) {
[08:27:57.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.674]                     {
[08:27:57.674]                       inherits <- base::inherits
[08:27:57.674]                       invokeRestart <- base::invokeRestart
[08:27:57.674]                       is.null <- base::is.null
[08:27:57.674]                       muffled <- FALSE
[08:27:57.674]                       if (inherits(cond, "message")) {
[08:27:57.674]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.674]                         if (muffled) 
[08:27:57.674]                           invokeRestart("muffleMessage")
[08:27:57.674]                       }
[08:27:57.674]                       else if (inherits(cond, "warning")) {
[08:27:57.674]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.674]                         if (muffled) 
[08:27:57.674]                           invokeRestart("muffleWarning")
[08:27:57.674]                       }
[08:27:57.674]                       else if (inherits(cond, "condition")) {
[08:27:57.674]                         if (!is.null(pattern)) {
[08:27:57.674]                           computeRestarts <- base::computeRestarts
[08:27:57.674]                           grepl <- base::grepl
[08:27:57.674]                           restarts <- computeRestarts(cond)
[08:27:57.674]                           for (restart in restarts) {
[08:27:57.674]                             name <- restart$name
[08:27:57.674]                             if (is.null(name)) 
[08:27:57.674]                               next
[08:27:57.674]                             if (!grepl(pattern, name)) 
[08:27:57.674]                               next
[08:27:57.674]                             invokeRestart(restart)
[08:27:57.674]                             muffled <- TRUE
[08:27:57.674]                             break
[08:27:57.674]                           }
[08:27:57.674]                         }
[08:27:57.674]                       }
[08:27:57.674]                       invisible(muffled)
[08:27:57.674]                     }
[08:27:57.674]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.674]                   }
[08:27:57.674]                 }
[08:27:57.674]                 else {
[08:27:57.674]                   if (TRUE) {
[08:27:57.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.674]                     {
[08:27:57.674]                       inherits <- base::inherits
[08:27:57.674]                       invokeRestart <- base::invokeRestart
[08:27:57.674]                       is.null <- base::is.null
[08:27:57.674]                       muffled <- FALSE
[08:27:57.674]                       if (inherits(cond, "message")) {
[08:27:57.674]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.674]                         if (muffled) 
[08:27:57.674]                           invokeRestart("muffleMessage")
[08:27:57.674]                       }
[08:27:57.674]                       else if (inherits(cond, "warning")) {
[08:27:57.674]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.674]                         if (muffled) 
[08:27:57.674]                           invokeRestart("muffleWarning")
[08:27:57.674]                       }
[08:27:57.674]                       else if (inherits(cond, "condition")) {
[08:27:57.674]                         if (!is.null(pattern)) {
[08:27:57.674]                           computeRestarts <- base::computeRestarts
[08:27:57.674]                           grepl <- base::grepl
[08:27:57.674]                           restarts <- computeRestarts(cond)
[08:27:57.674]                           for (restart in restarts) {
[08:27:57.674]                             name <- restart$name
[08:27:57.674]                             if (is.null(name)) 
[08:27:57.674]                               next
[08:27:57.674]                             if (!grepl(pattern, name)) 
[08:27:57.674]                               next
[08:27:57.674]                             invokeRestart(restart)
[08:27:57.674]                             muffled <- TRUE
[08:27:57.674]                             break
[08:27:57.674]                           }
[08:27:57.674]                         }
[08:27:57.674]                       }
[08:27:57.674]                       invisible(muffled)
[08:27:57.674]                     }
[08:27:57.674]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.674]                   }
[08:27:57.674]                 }
[08:27:57.674]             }
[08:27:57.674]         }))
[08:27:57.674]     }, error = function(ex) {
[08:27:57.674]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.674]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.674]                 ...future.rng), started = ...future.startTime, 
[08:27:57.674]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.674]             version = "1.8"), class = "FutureResult")
[08:27:57.674]     }, finally = {
[08:27:57.674]         if (!identical(...future.workdir, getwd())) 
[08:27:57.674]             setwd(...future.workdir)
[08:27:57.674]         {
[08:27:57.674]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.674]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.674]             }
[08:27:57.674]             base::options(...future.oldOptions)
[08:27:57.674]             if (.Platform$OS.type == "windows") {
[08:27:57.674]                 old_names <- names(...future.oldEnvVars)
[08:27:57.674]                 envs <- base::Sys.getenv()
[08:27:57.674]                 names <- names(envs)
[08:27:57.674]                 common <- intersect(names, old_names)
[08:27:57.674]                 added <- setdiff(names, old_names)
[08:27:57.674]                 removed <- setdiff(old_names, names)
[08:27:57.674]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.674]                   envs[common]]
[08:27:57.674]                 NAMES <- toupper(changed)
[08:27:57.674]                 args <- list()
[08:27:57.674]                 for (kk in seq_along(NAMES)) {
[08:27:57.674]                   name <- changed[[kk]]
[08:27:57.674]                   NAME <- NAMES[[kk]]
[08:27:57.674]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.674]                     next
[08:27:57.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.674]                 }
[08:27:57.674]                 NAMES <- toupper(added)
[08:27:57.674]                 for (kk in seq_along(NAMES)) {
[08:27:57.674]                   name <- added[[kk]]
[08:27:57.674]                   NAME <- NAMES[[kk]]
[08:27:57.674]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.674]                     next
[08:27:57.674]                   args[[name]] <- ""
[08:27:57.674]                 }
[08:27:57.674]                 NAMES <- toupper(removed)
[08:27:57.674]                 for (kk in seq_along(NAMES)) {
[08:27:57.674]                   name <- removed[[kk]]
[08:27:57.674]                   NAME <- NAMES[[kk]]
[08:27:57.674]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.674]                     next
[08:27:57.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.674]                 }
[08:27:57.674]                 if (length(args) > 0) 
[08:27:57.674]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.674]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.674]             }
[08:27:57.674]             else {
[08:27:57.674]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.674]             }
[08:27:57.674]             {
[08:27:57.674]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.674]                   0L) {
[08:27:57.674]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.674]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.674]                   base::options(opts)
[08:27:57.674]                 }
[08:27:57.674]                 {
[08:27:57.674]                   {
[08:27:57.674]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:57.674]                     NULL
[08:27:57.674]                   }
[08:27:57.674]                   options(future.plan = NULL)
[08:27:57.674]                   if (is.na(NA_character_)) 
[08:27:57.674]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.674]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.674]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.674]                     .init = FALSE)
[08:27:57.674]                 }
[08:27:57.674]             }
[08:27:57.674]         }
[08:27:57.674]     })
[08:27:57.674]     if (TRUE) {
[08:27:57.674]         base::sink(type = "output", split = FALSE)
[08:27:57.674]         if (TRUE) {
[08:27:57.674]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.674]         }
[08:27:57.674]         else {
[08:27:57.674]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.674]         }
[08:27:57.674]         base::close(...future.stdout)
[08:27:57.674]         ...future.stdout <- NULL
[08:27:57.674]     }
[08:27:57.674]     ...future.result$conditions <- ...future.conditions
[08:27:57.674]     ...future.result$finished <- base::Sys.time()
[08:27:57.674]     ...future.result
[08:27:57.674] }
[08:27:57.676] assign_globals() ...
[08:27:57.676] List of 2
[08:27:57.676]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[08:27:57.676]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[08:27:57.676]  - attr(*, "where")=List of 2
[08:27:57.676]   ..$ weight:<environment: R_EmptyEnv> 
[08:27:57.676]   ..$ group :<environment: R_EmptyEnv> 
[08:27:57.676]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:57.676]  - attr(*, "resolved")= logi FALSE
[08:27:57.676]  - attr(*, "total_size")= num 401
[08:27:57.676]  - attr(*, "already-done")= logi TRUE
[08:27:57.680] - copied ‘weight’ to environment
[08:27:57.680] - copied ‘group’ to environment
[08:27:57.680] assign_globals() ... done
[08:27:57.681] requestCore(): workers = 2
[08:27:57.683] MulticoreFuture started
[08:27:57.683] - Launch lazy future ... done
[08:27:57.683] run() for ‘MulticoreFuture’ ... done
[08:27:57.683] result() for MulticoreFuture ...
[08:27:57.684] plan(): Setting new future strategy stack:
[08:27:57.684] List of future strategies:
[08:27:57.684] 1. sequential:
[08:27:57.684]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.684]    - tweaked: FALSE
[08:27:57.684]    - call: NULL
[08:27:57.685] plan(): nbrOfWorkers() = 1
[08:27:57.688] plan(): Setting new future strategy stack:
[08:27:57.688] List of future strategies:
[08:27:57.688] 1. multicore:
[08:27:57.688]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:57.688]    - tweaked: FALSE
[08:27:57.688]    - call: plan(strategy)
[08:27:57.692] plan(): nbrOfWorkers() = 2
[08:27:57.694] result() for MulticoreFuture ...
[08:27:57.694] result() for MulticoreFuture ... done
[08:27:57.694] result() for MulticoreFuture ... done
[08:27:57.694] result() for MulticoreFuture ...
[08:27:57.694] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[08:27:57.697] getGlobalsAndPackages() ...
[08:27:57.697] Searching for globals...
[08:27:57.699] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[08:27:57.699] Searching for globals ... DONE
[08:27:57.700] Resolving globals: FALSE
[08:27:57.700] The total size of the 2 globals is 401 bytes (401 bytes)
[08:27:57.701] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[08:27:57.701] - globals: [2] ‘weight’, ‘group’
[08:27:57.701] - packages: [1] ‘stats’
[08:27:57.701] getGlobalsAndPackages() ... DONE
[08:27:57.701] run() for ‘Future’ ...
[08:27:57.702] - state: ‘created’
[08:27:57.702] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:57.704] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:57.704] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:57.704]   - Field: ‘label’
[08:27:57.704]   - Field: ‘local’
[08:27:57.704]   - Field: ‘owner’
[08:27:57.704]   - Field: ‘envir’
[08:27:57.705]   - Field: ‘workers’
[08:27:57.707]   - Field: ‘packages’
[08:27:57.707]   - Field: ‘gc’
[08:27:57.707]   - Field: ‘job’
[08:27:57.707]   - Field: ‘conditions’
[08:27:57.707]   - Field: ‘expr’
[08:27:57.708]   - Field: ‘uuid’
[08:27:57.708]   - Field: ‘seed’
[08:27:57.708]   - Field: ‘version’
[08:27:57.708]   - Field: ‘result’
[08:27:57.708]   - Field: ‘asynchronous’
[08:27:57.708]   - Field: ‘calls’
[08:27:57.708]   - Field: ‘globals’
[08:27:57.708]   - Field: ‘stdout’
[08:27:57.709]   - Field: ‘earlySignal’
[08:27:57.709]   - Field: ‘lazy’
[08:27:57.709]   - Field: ‘state’
[08:27:57.709] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:57.709] - Launch lazy future ...
[08:27:57.709] Packages needed by the future expression (n = 1): ‘stats’
[08:27:57.710] Packages needed by future strategies (n = 0): <none>
[08:27:57.710] {
[08:27:57.710]     {
[08:27:57.710]         {
[08:27:57.710]             ...future.startTime <- base::Sys.time()
[08:27:57.710]             {
[08:27:57.710]                 {
[08:27:57.710]                   {
[08:27:57.710]                     {
[08:27:57.710]                       {
[08:27:57.710]                         base::local({
[08:27:57.710]                           has_future <- base::requireNamespace("future", 
[08:27:57.710]                             quietly = TRUE)
[08:27:57.710]                           if (has_future) {
[08:27:57.710]                             ns <- base::getNamespace("future")
[08:27:57.710]                             version <- ns[[".package"]][["version"]]
[08:27:57.710]                             if (is.null(version)) 
[08:27:57.710]                               version <- utils::packageVersion("future")
[08:27:57.710]                           }
[08:27:57.710]                           else {
[08:27:57.710]                             version <- NULL
[08:27:57.710]                           }
[08:27:57.710]                           if (!has_future || version < "1.8.0") {
[08:27:57.710]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.710]                               "", base::R.version$version.string), 
[08:27:57.710]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:57.710]                                 base::R.version$platform, 8 * 
[08:27:57.710]                                   base::.Machine$sizeof.pointer), 
[08:27:57.710]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.710]                                 "release", "version")], collapse = " "), 
[08:27:57.710]                               hostname = base::Sys.info()[["nodename"]])
[08:27:57.710]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.710]                               info)
[08:27:57.710]                             info <- base::paste(info, collapse = "; ")
[08:27:57.710]                             if (!has_future) {
[08:27:57.710]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.710]                                 info)
[08:27:57.710]                             }
[08:27:57.710]                             else {
[08:27:57.710]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.710]                                 info, version)
[08:27:57.710]                             }
[08:27:57.710]                             base::stop(msg)
[08:27:57.710]                           }
[08:27:57.710]                         })
[08:27:57.710]                       }
[08:27:57.710]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:57.710]                       base::options(mc.cores = 1L)
[08:27:57.710]                     }
[08:27:57.710]                     base::local({
[08:27:57.710]                       for (pkg in "stats") {
[08:27:57.710]                         base::loadNamespace(pkg)
[08:27:57.710]                         base::library(pkg, character.only = TRUE)
[08:27:57.710]                       }
[08:27:57.710]                     })
[08:27:57.710]                   }
[08:27:57.710]                   ...future.strategy.old <- future::plan("list")
[08:27:57.710]                   options(future.plan = NULL)
[08:27:57.710]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.710]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.710]                 }
[08:27:57.710]                 ...future.workdir <- getwd()
[08:27:57.710]             }
[08:27:57.710]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.710]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.710]         }
[08:27:57.710]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.710]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.710]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.710]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.710]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.710]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.710]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.710]             base::names(...future.oldOptions))
[08:27:57.710]     }
[08:27:57.710]     if (FALSE) {
[08:27:57.710]     }
[08:27:57.710]     else {
[08:27:57.710]         if (TRUE) {
[08:27:57.710]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.710]                 open = "w")
[08:27:57.710]         }
[08:27:57.710]         else {
[08:27:57.710]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.710]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.710]         }
[08:27:57.710]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.710]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.710]             base::sink(type = "output", split = FALSE)
[08:27:57.710]             base::close(...future.stdout)
[08:27:57.710]         }, add = TRUE)
[08:27:57.710]     }
[08:27:57.710]     ...future.frame <- base::sys.nframe()
[08:27:57.710]     ...future.conditions <- base::list()
[08:27:57.710]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.710]     if (FALSE) {
[08:27:57.710]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.710]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.710]     }
[08:27:57.710]     ...future.result <- base::tryCatch({
[08:27:57.710]         base::withCallingHandlers({
[08:27:57.710]             ...future.value <- base::withVisible(base::local({
[08:27:57.710]                 withCallingHandlers({
[08:27:57.710]                   {
[08:27:57.710]                     lm(weight ~ group - 1)
[08:27:57.710]                   }
[08:27:57.710]                 }, immediateCondition = function(cond) {
[08:27:57.710]                   save_rds <- function (object, pathname, ...) 
[08:27:57.710]                   {
[08:27:57.710]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:57.710]                     if (file_test("-f", pathname_tmp)) {
[08:27:57.710]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.710]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:57.710]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.710]                         fi_tmp[["mtime"]])
[08:27:57.710]                     }
[08:27:57.710]                     tryCatch({
[08:27:57.710]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:57.710]                     }, error = function(ex) {
[08:27:57.710]                       msg <- conditionMessage(ex)
[08:27:57.710]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.710]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:57.710]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.710]                         fi_tmp[["mtime"]], msg)
[08:27:57.710]                       ex$message <- msg
[08:27:57.710]                       stop(ex)
[08:27:57.710]                     })
[08:27:57.710]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:57.710]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:57.710]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:57.710]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.710]                       fi <- file.info(pathname)
[08:27:57.710]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:57.710]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.710]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:57.710]                         fi[["size"]], fi[["mtime"]])
[08:27:57.710]                       stop(msg)
[08:27:57.710]                     }
[08:27:57.710]                     invisible(pathname)
[08:27:57.710]                   }
[08:27:57.710]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:57.710]                     rootPath = tempdir()) 
[08:27:57.710]                   {
[08:27:57.710]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:57.710]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:57.710]                       tmpdir = path, fileext = ".rds")
[08:27:57.710]                     save_rds(obj, file)
[08:27:57.710]                   }
[08:27:57.710]                   saveImmediateCondition(cond, path = "/tmp/RtmpUQjont/.future/immediateConditions")
[08:27:57.710]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.710]                   {
[08:27:57.710]                     inherits <- base::inherits
[08:27:57.710]                     invokeRestart <- base::invokeRestart
[08:27:57.710]                     is.null <- base::is.null
[08:27:57.710]                     muffled <- FALSE
[08:27:57.710]                     if (inherits(cond, "message")) {
[08:27:57.710]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:57.710]                       if (muffled) 
[08:27:57.710]                         invokeRestart("muffleMessage")
[08:27:57.710]                     }
[08:27:57.710]                     else if (inherits(cond, "warning")) {
[08:27:57.710]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:57.710]                       if (muffled) 
[08:27:57.710]                         invokeRestart("muffleWarning")
[08:27:57.710]                     }
[08:27:57.710]                     else if (inherits(cond, "condition")) {
[08:27:57.710]                       if (!is.null(pattern)) {
[08:27:57.710]                         computeRestarts <- base::computeRestarts
[08:27:57.710]                         grepl <- base::grepl
[08:27:57.710]                         restarts <- computeRestarts(cond)
[08:27:57.710]                         for (restart in restarts) {
[08:27:57.710]                           name <- restart$name
[08:27:57.710]                           if (is.null(name)) 
[08:27:57.710]                             next
[08:27:57.710]                           if (!grepl(pattern, name)) 
[08:27:57.710]                             next
[08:27:57.710]                           invokeRestart(restart)
[08:27:57.710]                           muffled <- TRUE
[08:27:57.710]                           break
[08:27:57.710]                         }
[08:27:57.710]                       }
[08:27:57.710]                     }
[08:27:57.710]                     invisible(muffled)
[08:27:57.710]                   }
[08:27:57.710]                   muffleCondition(cond)
[08:27:57.710]                 })
[08:27:57.710]             }))
[08:27:57.710]             future::FutureResult(value = ...future.value$value, 
[08:27:57.710]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.710]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.710]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.710]                     ...future.globalenv.names))
[08:27:57.710]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.710]         }, condition = base::local({
[08:27:57.710]             c <- base::c
[08:27:57.710]             inherits <- base::inherits
[08:27:57.710]             invokeRestart <- base::invokeRestart
[08:27:57.710]             length <- base::length
[08:27:57.710]             list <- base::list
[08:27:57.710]             seq.int <- base::seq.int
[08:27:57.710]             signalCondition <- base::signalCondition
[08:27:57.710]             sys.calls <- base::sys.calls
[08:27:57.710]             `[[` <- base::`[[`
[08:27:57.710]             `+` <- base::`+`
[08:27:57.710]             `<<-` <- base::`<<-`
[08:27:57.710]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.710]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.710]                   3L)]
[08:27:57.710]             }
[08:27:57.710]             function(cond) {
[08:27:57.710]                 is_error <- inherits(cond, "error")
[08:27:57.710]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.710]                   NULL)
[08:27:57.710]                 if (is_error) {
[08:27:57.710]                   sessionInformation <- function() {
[08:27:57.710]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.710]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.710]                       search = base::search(), system = base::Sys.info())
[08:27:57.710]                   }
[08:27:57.710]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.710]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.710]                     cond$call), session = sessionInformation(), 
[08:27:57.710]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.710]                   signalCondition(cond)
[08:27:57.710]                 }
[08:27:57.710]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.710]                 "immediateCondition"))) {
[08:27:57.710]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.710]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.710]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.710]                   if (TRUE && !signal) {
[08:27:57.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.710]                     {
[08:27:57.710]                       inherits <- base::inherits
[08:27:57.710]                       invokeRestart <- base::invokeRestart
[08:27:57.710]                       is.null <- base::is.null
[08:27:57.710]                       muffled <- FALSE
[08:27:57.710]                       if (inherits(cond, "message")) {
[08:27:57.710]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.710]                         if (muffled) 
[08:27:57.710]                           invokeRestart("muffleMessage")
[08:27:57.710]                       }
[08:27:57.710]                       else if (inherits(cond, "warning")) {
[08:27:57.710]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.710]                         if (muffled) 
[08:27:57.710]                           invokeRestart("muffleWarning")
[08:27:57.710]                       }
[08:27:57.710]                       else if (inherits(cond, "condition")) {
[08:27:57.710]                         if (!is.null(pattern)) {
[08:27:57.710]                           computeRestarts <- base::computeRestarts
[08:27:57.710]                           grepl <- base::grepl
[08:27:57.710]                           restarts <- computeRestarts(cond)
[08:27:57.710]                           for (restart in restarts) {
[08:27:57.710]                             name <- restart$name
[08:27:57.710]                             if (is.null(name)) 
[08:27:57.710]                               next
[08:27:57.710]                             if (!grepl(pattern, name)) 
[08:27:57.710]                               next
[08:27:57.710]                             invokeRestart(restart)
[08:27:57.710]                             muffled <- TRUE
[08:27:57.710]                             break
[08:27:57.710]                           }
[08:27:57.710]                         }
[08:27:57.710]                       }
[08:27:57.710]                       invisible(muffled)
[08:27:57.710]                     }
[08:27:57.710]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.710]                   }
[08:27:57.710]                 }
[08:27:57.710]                 else {
[08:27:57.710]                   if (TRUE) {
[08:27:57.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.710]                     {
[08:27:57.710]                       inherits <- base::inherits
[08:27:57.710]                       invokeRestart <- base::invokeRestart
[08:27:57.710]                       is.null <- base::is.null
[08:27:57.710]                       muffled <- FALSE
[08:27:57.710]                       if (inherits(cond, "message")) {
[08:27:57.710]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.710]                         if (muffled) 
[08:27:57.710]                           invokeRestart("muffleMessage")
[08:27:57.710]                       }
[08:27:57.710]                       else if (inherits(cond, "warning")) {
[08:27:57.710]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.710]                         if (muffled) 
[08:27:57.710]                           invokeRestart("muffleWarning")
[08:27:57.710]                       }
[08:27:57.710]                       else if (inherits(cond, "condition")) {
[08:27:57.710]                         if (!is.null(pattern)) {
[08:27:57.710]                           computeRestarts <- base::computeRestarts
[08:27:57.710]                           grepl <- base::grepl
[08:27:57.710]                           restarts <- computeRestarts(cond)
[08:27:57.710]                           for (restart in restarts) {
[08:27:57.710]                             name <- restart$name
[08:27:57.710]                             if (is.null(name)) 
[08:27:57.710]                               next
[08:27:57.710]                             if (!grepl(pattern, name)) 
[08:27:57.710]                               next
[08:27:57.710]                             invokeRestart(restart)
[08:27:57.710]                             muffled <- TRUE
[08:27:57.710]                             break
[08:27:57.710]                           }
[08:27:57.710]                         }
[08:27:57.710]                       }
[08:27:57.710]                       invisible(muffled)
[08:27:57.710]                     }
[08:27:57.710]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.710]                   }
[08:27:57.710]                 }
[08:27:57.710]             }
[08:27:57.710]         }))
[08:27:57.710]     }, error = function(ex) {
[08:27:57.710]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.710]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.710]                 ...future.rng), started = ...future.startTime, 
[08:27:57.710]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.710]             version = "1.8"), class = "FutureResult")
[08:27:57.710]     }, finally = {
[08:27:57.710]         if (!identical(...future.workdir, getwd())) 
[08:27:57.710]             setwd(...future.workdir)
[08:27:57.710]         {
[08:27:57.710]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.710]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.710]             }
[08:27:57.710]             base::options(...future.oldOptions)
[08:27:57.710]             if (.Platform$OS.type == "windows") {
[08:27:57.710]                 old_names <- names(...future.oldEnvVars)
[08:27:57.710]                 envs <- base::Sys.getenv()
[08:27:57.710]                 names <- names(envs)
[08:27:57.710]                 common <- intersect(names, old_names)
[08:27:57.710]                 added <- setdiff(names, old_names)
[08:27:57.710]                 removed <- setdiff(old_names, names)
[08:27:57.710]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.710]                   envs[common]]
[08:27:57.710]                 NAMES <- toupper(changed)
[08:27:57.710]                 args <- list()
[08:27:57.710]                 for (kk in seq_along(NAMES)) {
[08:27:57.710]                   name <- changed[[kk]]
[08:27:57.710]                   NAME <- NAMES[[kk]]
[08:27:57.710]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.710]                     next
[08:27:57.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.710]                 }
[08:27:57.710]                 NAMES <- toupper(added)
[08:27:57.710]                 for (kk in seq_along(NAMES)) {
[08:27:57.710]                   name <- added[[kk]]
[08:27:57.710]                   NAME <- NAMES[[kk]]
[08:27:57.710]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.710]                     next
[08:27:57.710]                   args[[name]] <- ""
[08:27:57.710]                 }
[08:27:57.710]                 NAMES <- toupper(removed)
[08:27:57.710]                 for (kk in seq_along(NAMES)) {
[08:27:57.710]                   name <- removed[[kk]]
[08:27:57.710]                   NAME <- NAMES[[kk]]
[08:27:57.710]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.710]                     next
[08:27:57.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.710]                 }
[08:27:57.710]                 if (length(args) > 0) 
[08:27:57.710]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.710]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.710]             }
[08:27:57.710]             else {
[08:27:57.710]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.710]             }
[08:27:57.710]             {
[08:27:57.710]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.710]                   0L) {
[08:27:57.710]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.710]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.710]                   base::options(opts)
[08:27:57.710]                 }
[08:27:57.710]                 {
[08:27:57.710]                   {
[08:27:57.710]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:57.710]                     NULL
[08:27:57.710]                   }
[08:27:57.710]                   options(future.plan = NULL)
[08:27:57.710]                   if (is.na(NA_character_)) 
[08:27:57.710]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.710]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.710]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.710]                     .init = FALSE)
[08:27:57.710]                 }
[08:27:57.710]             }
[08:27:57.710]         }
[08:27:57.710]     })
[08:27:57.710]     if (TRUE) {
[08:27:57.710]         base::sink(type = "output", split = FALSE)
[08:27:57.710]         if (TRUE) {
[08:27:57.710]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.710]         }
[08:27:57.710]         else {
[08:27:57.710]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.710]         }
[08:27:57.710]         base::close(...future.stdout)
[08:27:57.710]         ...future.stdout <- NULL
[08:27:57.710]     }
[08:27:57.710]     ...future.result$conditions <- ...future.conditions
[08:27:57.710]     ...future.result$finished <- base::Sys.time()
[08:27:57.710]     ...future.result
[08:27:57.710] }
[08:27:57.713] assign_globals() ...
[08:27:57.713] List of 2
[08:27:57.713]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[08:27:57.713]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[08:27:57.713]  - attr(*, "where")=List of 2
[08:27:57.713]   ..$ weight:<environment: R_EmptyEnv> 
[08:27:57.713]   ..$ group :<environment: R_EmptyEnv> 
[08:27:57.713]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:57.713]  - attr(*, "resolved")= logi FALSE
[08:27:57.713]  - attr(*, "total_size")= num 401
[08:27:57.713]  - attr(*, "already-done")= logi TRUE
[08:27:57.717] - copied ‘weight’ to environment
[08:27:57.717] - copied ‘group’ to environment
[08:27:57.717] assign_globals() ... done
[08:27:57.717] requestCore(): workers = 2
[08:27:57.719] MulticoreFuture started
[08:27:57.720] - Launch lazy future ... done
[08:27:57.720] run() for ‘MulticoreFuture’ ... done
[08:27:57.720] plan(): Setting new future strategy stack:
[08:27:57.720] result() for MulticoreFuture ...
[08:27:57.721] List of future strategies:
[08:27:57.721] 1. sequential:
[08:27:57.721]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.721]    - tweaked: FALSE
[08:27:57.721]    - call: NULL
[08:27:57.722] plan(): nbrOfWorkers() = 1
[08:27:57.725] plan(): Setting new future strategy stack:
[08:27:57.725] List of future strategies:
[08:27:57.725] 1. multicore:
[08:27:57.725]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:57.725]    - tweaked: FALSE
[08:27:57.725]    - call: plan(strategy)
[08:27:57.728] plan(): nbrOfWorkers() = 2
[08:27:57.731] result() for MulticoreFuture ...
[08:27:57.731] result() for MulticoreFuture ... done
[08:27:57.731] result() for MulticoreFuture ... done
[08:27:57.731] result() for MulticoreFuture ...
[08:27:57.731] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[08:27:57.734] getGlobalsAndPackages() ...
[08:27:57.734] Searching for globals...
[08:27:57.736] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[08:27:57.736] Searching for globals ... DONE
[08:27:57.736] Resolving globals: FALSE
[08:27:57.737] The total size of the 2 globals is 401 bytes (401 bytes)
[08:27:57.737] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[08:27:57.737] - globals: [2] ‘weight’, ‘group’
[08:27:57.738] - packages: [1] ‘stats’
[08:27:57.738] getGlobalsAndPackages() ... DONE
[08:27:57.738] run() for ‘Future’ ...
[08:27:57.738] - state: ‘created’
[08:27:57.738] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:57.740] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:57.741] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:57.741]   - Field: ‘label’
[08:27:57.741]   - Field: ‘local’
[08:27:57.741]   - Field: ‘owner’
[08:27:57.741]   - Field: ‘envir’
[08:27:57.741]   - Field: ‘workers’
[08:27:57.741]   - Field: ‘packages’
[08:27:57.741]   - Field: ‘gc’
[08:27:57.742]   - Field: ‘job’
[08:27:57.742]   - Field: ‘conditions’
[08:27:57.742]   - Field: ‘expr’
[08:27:57.742]   - Field: ‘uuid’
[08:27:57.742]   - Field: ‘seed’
[08:27:57.742]   - Field: ‘version’
[08:27:57.742]   - Field: ‘result’
[08:27:57.742]   - Field: ‘asynchronous’
[08:27:57.742]   - Field: ‘calls’
[08:27:57.742]   - Field: ‘globals’
[08:27:57.743]   - Field: ‘stdout’
[08:27:57.743]   - Field: ‘earlySignal’
[08:27:57.743]   - Field: ‘lazy’
[08:27:57.743]   - Field: ‘state’
[08:27:57.743] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:57.743] - Launch lazy future ...
[08:27:57.744] Packages needed by the future expression (n = 1): ‘stats’
[08:27:57.744] Packages needed by future strategies (n = 0): <none>
[08:27:57.744] {
[08:27:57.744]     {
[08:27:57.744]         {
[08:27:57.744]             ...future.startTime <- base::Sys.time()
[08:27:57.744]             {
[08:27:57.744]                 {
[08:27:57.744]                   {
[08:27:57.744]                     {
[08:27:57.744]                       {
[08:27:57.744]                         base::local({
[08:27:57.744]                           has_future <- base::requireNamespace("future", 
[08:27:57.744]                             quietly = TRUE)
[08:27:57.744]                           if (has_future) {
[08:27:57.744]                             ns <- base::getNamespace("future")
[08:27:57.744]                             version <- ns[[".package"]][["version"]]
[08:27:57.744]                             if (is.null(version)) 
[08:27:57.744]                               version <- utils::packageVersion("future")
[08:27:57.744]                           }
[08:27:57.744]                           else {
[08:27:57.744]                             version <- NULL
[08:27:57.744]                           }
[08:27:57.744]                           if (!has_future || version < "1.8.0") {
[08:27:57.744]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.744]                               "", base::R.version$version.string), 
[08:27:57.744]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:57.744]                                 base::R.version$platform, 8 * 
[08:27:57.744]                                   base::.Machine$sizeof.pointer), 
[08:27:57.744]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.744]                                 "release", "version")], collapse = " "), 
[08:27:57.744]                               hostname = base::Sys.info()[["nodename"]])
[08:27:57.744]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.744]                               info)
[08:27:57.744]                             info <- base::paste(info, collapse = "; ")
[08:27:57.744]                             if (!has_future) {
[08:27:57.744]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.744]                                 info)
[08:27:57.744]                             }
[08:27:57.744]                             else {
[08:27:57.744]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.744]                                 info, version)
[08:27:57.744]                             }
[08:27:57.744]                             base::stop(msg)
[08:27:57.744]                           }
[08:27:57.744]                         })
[08:27:57.744]                       }
[08:27:57.744]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:57.744]                       base::options(mc.cores = 1L)
[08:27:57.744]                     }
[08:27:57.744]                     base::local({
[08:27:57.744]                       for (pkg in "stats") {
[08:27:57.744]                         base::loadNamespace(pkg)
[08:27:57.744]                         base::library(pkg, character.only = TRUE)
[08:27:57.744]                       }
[08:27:57.744]                     })
[08:27:57.744]                   }
[08:27:57.744]                   ...future.strategy.old <- future::plan("list")
[08:27:57.744]                   options(future.plan = NULL)
[08:27:57.744]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.744]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.744]                 }
[08:27:57.744]                 ...future.workdir <- getwd()
[08:27:57.744]             }
[08:27:57.744]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.744]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.744]         }
[08:27:57.744]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.744]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.744]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.744]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.744]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.744]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.744]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.744]             base::names(...future.oldOptions))
[08:27:57.744]     }
[08:27:57.744]     if (FALSE) {
[08:27:57.744]     }
[08:27:57.744]     else {
[08:27:57.744]         if (TRUE) {
[08:27:57.744]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.744]                 open = "w")
[08:27:57.744]         }
[08:27:57.744]         else {
[08:27:57.744]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.744]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.744]         }
[08:27:57.744]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.744]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.744]             base::sink(type = "output", split = FALSE)
[08:27:57.744]             base::close(...future.stdout)
[08:27:57.744]         }, add = TRUE)
[08:27:57.744]     }
[08:27:57.744]     ...future.frame <- base::sys.nframe()
[08:27:57.744]     ...future.conditions <- base::list()
[08:27:57.744]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.744]     if (FALSE) {
[08:27:57.744]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.744]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.744]     }
[08:27:57.744]     ...future.result <- base::tryCatch({
[08:27:57.744]         base::withCallingHandlers({
[08:27:57.744]             ...future.value <- base::withVisible(base::local({
[08:27:57.744]                 withCallingHandlers({
[08:27:57.744]                   {
[08:27:57.744]                     lm(weight ~ group - 1)
[08:27:57.744]                   }
[08:27:57.744]                 }, immediateCondition = function(cond) {
[08:27:57.744]                   save_rds <- function (object, pathname, ...) 
[08:27:57.744]                   {
[08:27:57.744]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:57.744]                     if (file_test("-f", pathname_tmp)) {
[08:27:57.744]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.744]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:57.744]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.744]                         fi_tmp[["mtime"]])
[08:27:57.744]                     }
[08:27:57.744]                     tryCatch({
[08:27:57.744]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:57.744]                     }, error = function(ex) {
[08:27:57.744]                       msg <- conditionMessage(ex)
[08:27:57.744]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.744]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:57.744]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.744]                         fi_tmp[["mtime"]], msg)
[08:27:57.744]                       ex$message <- msg
[08:27:57.744]                       stop(ex)
[08:27:57.744]                     })
[08:27:57.744]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:57.744]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:57.744]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:57.744]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.744]                       fi <- file.info(pathname)
[08:27:57.744]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:57.744]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.744]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:57.744]                         fi[["size"]], fi[["mtime"]])
[08:27:57.744]                       stop(msg)
[08:27:57.744]                     }
[08:27:57.744]                     invisible(pathname)
[08:27:57.744]                   }
[08:27:57.744]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:57.744]                     rootPath = tempdir()) 
[08:27:57.744]                   {
[08:27:57.744]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:57.744]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:57.744]                       tmpdir = path, fileext = ".rds")
[08:27:57.744]                     save_rds(obj, file)
[08:27:57.744]                   }
[08:27:57.744]                   saveImmediateCondition(cond, path = "/tmp/RtmpUQjont/.future/immediateConditions")
[08:27:57.744]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.744]                   {
[08:27:57.744]                     inherits <- base::inherits
[08:27:57.744]                     invokeRestart <- base::invokeRestart
[08:27:57.744]                     is.null <- base::is.null
[08:27:57.744]                     muffled <- FALSE
[08:27:57.744]                     if (inherits(cond, "message")) {
[08:27:57.744]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:57.744]                       if (muffled) 
[08:27:57.744]                         invokeRestart("muffleMessage")
[08:27:57.744]                     }
[08:27:57.744]                     else if (inherits(cond, "warning")) {
[08:27:57.744]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:57.744]                       if (muffled) 
[08:27:57.744]                         invokeRestart("muffleWarning")
[08:27:57.744]                     }
[08:27:57.744]                     else if (inherits(cond, "condition")) {
[08:27:57.744]                       if (!is.null(pattern)) {
[08:27:57.744]                         computeRestarts <- base::computeRestarts
[08:27:57.744]                         grepl <- base::grepl
[08:27:57.744]                         restarts <- computeRestarts(cond)
[08:27:57.744]                         for (restart in restarts) {
[08:27:57.744]                           name <- restart$name
[08:27:57.744]                           if (is.null(name)) 
[08:27:57.744]                             next
[08:27:57.744]                           if (!grepl(pattern, name)) 
[08:27:57.744]                             next
[08:27:57.744]                           invokeRestart(restart)
[08:27:57.744]                           muffled <- TRUE
[08:27:57.744]                           break
[08:27:57.744]                         }
[08:27:57.744]                       }
[08:27:57.744]                     }
[08:27:57.744]                     invisible(muffled)
[08:27:57.744]                   }
[08:27:57.744]                   muffleCondition(cond)
[08:27:57.744]                 })
[08:27:57.744]             }))
[08:27:57.744]             future::FutureResult(value = ...future.value$value, 
[08:27:57.744]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.744]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.744]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.744]                     ...future.globalenv.names))
[08:27:57.744]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.744]         }, condition = base::local({
[08:27:57.744]             c <- base::c
[08:27:57.744]             inherits <- base::inherits
[08:27:57.744]             invokeRestart <- base::invokeRestart
[08:27:57.744]             length <- base::length
[08:27:57.744]             list <- base::list
[08:27:57.744]             seq.int <- base::seq.int
[08:27:57.744]             signalCondition <- base::signalCondition
[08:27:57.744]             sys.calls <- base::sys.calls
[08:27:57.744]             `[[` <- base::`[[`
[08:27:57.744]             `+` <- base::`+`
[08:27:57.744]             `<<-` <- base::`<<-`
[08:27:57.744]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.744]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.744]                   3L)]
[08:27:57.744]             }
[08:27:57.744]             function(cond) {
[08:27:57.744]                 is_error <- inherits(cond, "error")
[08:27:57.744]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.744]                   NULL)
[08:27:57.744]                 if (is_error) {
[08:27:57.744]                   sessionInformation <- function() {
[08:27:57.744]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.744]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.744]                       search = base::search(), system = base::Sys.info())
[08:27:57.744]                   }
[08:27:57.744]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.744]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.744]                     cond$call), session = sessionInformation(), 
[08:27:57.744]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.744]                   signalCondition(cond)
[08:27:57.744]                 }
[08:27:57.744]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.744]                 "immediateCondition"))) {
[08:27:57.744]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.744]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.744]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.744]                   if (TRUE && !signal) {
[08:27:57.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.744]                     {
[08:27:57.744]                       inherits <- base::inherits
[08:27:57.744]                       invokeRestart <- base::invokeRestart
[08:27:57.744]                       is.null <- base::is.null
[08:27:57.744]                       muffled <- FALSE
[08:27:57.744]                       if (inherits(cond, "message")) {
[08:27:57.744]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.744]                         if (muffled) 
[08:27:57.744]                           invokeRestart("muffleMessage")
[08:27:57.744]                       }
[08:27:57.744]                       else if (inherits(cond, "warning")) {
[08:27:57.744]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.744]                         if (muffled) 
[08:27:57.744]                           invokeRestart("muffleWarning")
[08:27:57.744]                       }
[08:27:57.744]                       else if (inherits(cond, "condition")) {
[08:27:57.744]                         if (!is.null(pattern)) {
[08:27:57.744]                           computeRestarts <- base::computeRestarts
[08:27:57.744]                           grepl <- base::grepl
[08:27:57.744]                           restarts <- computeRestarts(cond)
[08:27:57.744]                           for (restart in restarts) {
[08:27:57.744]                             name <- restart$name
[08:27:57.744]                             if (is.null(name)) 
[08:27:57.744]                               next
[08:27:57.744]                             if (!grepl(pattern, name)) 
[08:27:57.744]                               next
[08:27:57.744]                             invokeRestart(restart)
[08:27:57.744]                             muffled <- TRUE
[08:27:57.744]                             break
[08:27:57.744]                           }
[08:27:57.744]                         }
[08:27:57.744]                       }
[08:27:57.744]                       invisible(muffled)
[08:27:57.744]                     }
[08:27:57.744]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.744]                   }
[08:27:57.744]                 }
[08:27:57.744]                 else {
[08:27:57.744]                   if (TRUE) {
[08:27:57.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.744]                     {
[08:27:57.744]                       inherits <- base::inherits
[08:27:57.744]                       invokeRestart <- base::invokeRestart
[08:27:57.744]                       is.null <- base::is.null
[08:27:57.744]                       muffled <- FALSE
[08:27:57.744]                       if (inherits(cond, "message")) {
[08:27:57.744]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.744]                         if (muffled) 
[08:27:57.744]                           invokeRestart("muffleMessage")
[08:27:57.744]                       }
[08:27:57.744]                       else if (inherits(cond, "warning")) {
[08:27:57.744]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.744]                         if (muffled) 
[08:27:57.744]                           invokeRestart("muffleWarning")
[08:27:57.744]                       }
[08:27:57.744]                       else if (inherits(cond, "condition")) {
[08:27:57.744]                         if (!is.null(pattern)) {
[08:27:57.744]                           computeRestarts <- base::computeRestarts
[08:27:57.744]                           grepl <- base::grepl
[08:27:57.744]                           restarts <- computeRestarts(cond)
[08:27:57.744]                           for (restart in restarts) {
[08:27:57.744]                             name <- restart$name
[08:27:57.744]                             if (is.null(name)) 
[08:27:57.744]                               next
[08:27:57.744]                             if (!grepl(pattern, name)) 
[08:27:57.744]                               next
[08:27:57.744]                             invokeRestart(restart)
[08:27:57.744]                             muffled <- TRUE
[08:27:57.744]                             break
[08:27:57.744]                           }
[08:27:57.744]                         }
[08:27:57.744]                       }
[08:27:57.744]                       invisible(muffled)
[08:27:57.744]                     }
[08:27:57.744]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.744]                   }
[08:27:57.744]                 }
[08:27:57.744]             }
[08:27:57.744]         }))
[08:27:57.744]     }, error = function(ex) {
[08:27:57.744]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.744]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.744]                 ...future.rng), started = ...future.startTime, 
[08:27:57.744]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.744]             version = "1.8"), class = "FutureResult")
[08:27:57.744]     }, finally = {
[08:27:57.744]         if (!identical(...future.workdir, getwd())) 
[08:27:57.744]             setwd(...future.workdir)
[08:27:57.744]         {
[08:27:57.744]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.744]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.744]             }
[08:27:57.744]             base::options(...future.oldOptions)
[08:27:57.744]             if (.Platform$OS.type == "windows") {
[08:27:57.744]                 old_names <- names(...future.oldEnvVars)
[08:27:57.744]                 envs <- base::Sys.getenv()
[08:27:57.744]                 names <- names(envs)
[08:27:57.744]                 common <- intersect(names, old_names)
[08:27:57.744]                 added <- setdiff(names, old_names)
[08:27:57.744]                 removed <- setdiff(old_names, names)
[08:27:57.744]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.744]                   envs[common]]
[08:27:57.744]                 NAMES <- toupper(changed)
[08:27:57.744]                 args <- list()
[08:27:57.744]                 for (kk in seq_along(NAMES)) {
[08:27:57.744]                   name <- changed[[kk]]
[08:27:57.744]                   NAME <- NAMES[[kk]]
[08:27:57.744]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.744]                     next
[08:27:57.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.744]                 }
[08:27:57.744]                 NAMES <- toupper(added)
[08:27:57.744]                 for (kk in seq_along(NAMES)) {
[08:27:57.744]                   name <- added[[kk]]
[08:27:57.744]                   NAME <- NAMES[[kk]]
[08:27:57.744]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.744]                     next
[08:27:57.744]                   args[[name]] <- ""
[08:27:57.744]                 }
[08:27:57.744]                 NAMES <- toupper(removed)
[08:27:57.744]                 for (kk in seq_along(NAMES)) {
[08:27:57.744]                   name <- removed[[kk]]
[08:27:57.744]                   NAME <- NAMES[[kk]]
[08:27:57.744]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.744]                     next
[08:27:57.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.744]                 }
[08:27:57.744]                 if (length(args) > 0) 
[08:27:57.744]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.744]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.744]             }
[08:27:57.744]             else {
[08:27:57.744]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.744]             }
[08:27:57.744]             {
[08:27:57.744]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.744]                   0L) {
[08:27:57.744]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.744]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.744]                   base::options(opts)
[08:27:57.744]                 }
[08:27:57.744]                 {
[08:27:57.744]                   {
[08:27:57.744]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:57.744]                     NULL
[08:27:57.744]                   }
[08:27:57.744]                   options(future.plan = NULL)
[08:27:57.744]                   if (is.na(NA_character_)) 
[08:27:57.744]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.744]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.744]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.744]                     .init = FALSE)
[08:27:57.744]                 }
[08:27:57.744]             }
[08:27:57.744]         }
[08:27:57.744]     })
[08:27:57.744]     if (TRUE) {
[08:27:57.744]         base::sink(type = "output", split = FALSE)
[08:27:57.744]         if (TRUE) {
[08:27:57.744]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.744]         }
[08:27:57.744]         else {
[08:27:57.744]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.744]         }
[08:27:57.744]         base::close(...future.stdout)
[08:27:57.744]         ...future.stdout <- NULL
[08:27:57.744]     }
[08:27:57.744]     ...future.result$conditions <- ...future.conditions
[08:27:57.744]     ...future.result$finished <- base::Sys.time()
[08:27:57.744]     ...future.result
[08:27:57.744] }
[08:27:57.747] assign_globals() ...
[08:27:57.747] List of 2
[08:27:57.747]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[08:27:57.747]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[08:27:57.747]  - attr(*, "where")=List of 2
[08:27:57.747]   ..$ weight:<environment: R_EmptyEnv> 
[08:27:57.747]   ..$ group :<environment: R_EmptyEnv> 
[08:27:57.747]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:57.747]  - attr(*, "resolved")= logi FALSE
[08:27:57.747]  - attr(*, "total_size")= num 401
[08:27:57.747]  - attr(*, "already-done")= logi TRUE
[08:27:57.753] - copied ‘weight’ to environment
[08:27:57.754] - copied ‘group’ to environment
[08:27:57.754] assign_globals() ... done
[08:27:57.754] requestCore(): workers = 2
[08:27:57.756] MulticoreFuture started
[08:27:57.756] - Launch lazy future ... done
[08:27:57.756] run() for ‘MulticoreFuture’ ... done
[08:27:57.757] result() for MulticoreFuture ...
[08:27:57.757] plan(): Setting new future strategy stack:
[08:27:57.757] List of future strategies:
[08:27:57.757] 1. sequential:
[08:27:57.757]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.757]    - tweaked: FALSE
[08:27:57.757]    - call: NULL
[08:27:57.758] plan(): nbrOfWorkers() = 1
[08:27:57.762] plan(): Setting new future strategy stack:
[08:27:57.762] List of future strategies:
[08:27:57.762] 1. multicore:
[08:27:57.762]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:57.762]    - tweaked: FALSE
[08:27:57.762]    - call: plan(strategy)
[08:27:57.765] plan(): nbrOfWorkers() = 2
[08:27:57.767] result() for MulticoreFuture ...
[08:27:57.768] result() for MulticoreFuture ... done
[08:27:57.768] result() for MulticoreFuture ... done
[08:27:57.768] result() for MulticoreFuture ...
[08:27:57.768] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[08:27:57.771] getGlobalsAndPackages() ...
[08:27:57.771] Searching for globals...
[08:27:57.773] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[08:27:57.773] Searching for globals ... DONE
[08:27:57.773] Resolving globals: FALSE
[08:27:57.774] The total size of the 2 globals is 401 bytes (401 bytes)
[08:27:57.774] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[08:27:57.774] - globals: [2] ‘weight’, ‘group’
[08:27:57.775] - packages: [1] ‘stats’
[08:27:57.775] getGlobalsAndPackages() ... DONE
[08:27:57.775] run() for ‘Future’ ...
[08:27:57.775] - state: ‘created’
[08:27:57.775] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:57.777] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:57.778] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:57.778]   - Field: ‘label’
[08:27:57.778]   - Field: ‘local’
[08:27:57.778]   - Field: ‘owner’
[08:27:57.778]   - Field: ‘envir’
[08:27:57.778]   - Field: ‘workers’
[08:27:57.778]   - Field: ‘packages’
[08:27:57.778]   - Field: ‘gc’
[08:27:57.779]   - Field: ‘job’
[08:27:57.779]   - Field: ‘conditions’
[08:27:57.779]   - Field: ‘expr’
[08:27:57.779]   - Field: ‘uuid’
[08:27:57.779]   - Field: ‘seed’
[08:27:57.779]   - Field: ‘version’
[08:27:57.779]   - Field: ‘result’
[08:27:57.779]   - Field: ‘asynchronous’
[08:27:57.779]   - Field: ‘calls’
[08:27:57.780]   - Field: ‘globals’
[08:27:57.780]   - Field: ‘stdout’
[08:27:57.780]   - Field: ‘earlySignal’
[08:27:57.780]   - Field: ‘lazy’
[08:27:57.780]   - Field: ‘state’
[08:27:57.780] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:57.780] - Launch lazy future ...
[08:27:57.781] Packages needed by the future expression (n = 1): ‘stats’
[08:27:57.781] Packages needed by future strategies (n = 0): <none>
[08:27:57.781] {
[08:27:57.781]     {
[08:27:57.781]         {
[08:27:57.781]             ...future.startTime <- base::Sys.time()
[08:27:57.781]             {
[08:27:57.781]                 {
[08:27:57.781]                   {
[08:27:57.781]                     {
[08:27:57.781]                       {
[08:27:57.781]                         base::local({
[08:27:57.781]                           has_future <- base::requireNamespace("future", 
[08:27:57.781]                             quietly = TRUE)
[08:27:57.781]                           if (has_future) {
[08:27:57.781]                             ns <- base::getNamespace("future")
[08:27:57.781]                             version <- ns[[".package"]][["version"]]
[08:27:57.781]                             if (is.null(version)) 
[08:27:57.781]                               version <- utils::packageVersion("future")
[08:27:57.781]                           }
[08:27:57.781]                           else {
[08:27:57.781]                             version <- NULL
[08:27:57.781]                           }
[08:27:57.781]                           if (!has_future || version < "1.8.0") {
[08:27:57.781]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.781]                               "", base::R.version$version.string), 
[08:27:57.781]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:57.781]                                 base::R.version$platform, 8 * 
[08:27:57.781]                                   base::.Machine$sizeof.pointer), 
[08:27:57.781]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.781]                                 "release", "version")], collapse = " "), 
[08:27:57.781]                               hostname = base::Sys.info()[["nodename"]])
[08:27:57.781]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.781]                               info)
[08:27:57.781]                             info <- base::paste(info, collapse = "; ")
[08:27:57.781]                             if (!has_future) {
[08:27:57.781]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.781]                                 info)
[08:27:57.781]                             }
[08:27:57.781]                             else {
[08:27:57.781]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.781]                                 info, version)
[08:27:57.781]                             }
[08:27:57.781]                             base::stop(msg)
[08:27:57.781]                           }
[08:27:57.781]                         })
[08:27:57.781]                       }
[08:27:57.781]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:57.781]                       base::options(mc.cores = 1L)
[08:27:57.781]                     }
[08:27:57.781]                     base::local({
[08:27:57.781]                       for (pkg in "stats") {
[08:27:57.781]                         base::loadNamespace(pkg)
[08:27:57.781]                         base::library(pkg, character.only = TRUE)
[08:27:57.781]                       }
[08:27:57.781]                     })
[08:27:57.781]                   }
[08:27:57.781]                   ...future.strategy.old <- future::plan("list")
[08:27:57.781]                   options(future.plan = NULL)
[08:27:57.781]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.781]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.781]                 }
[08:27:57.781]                 ...future.workdir <- getwd()
[08:27:57.781]             }
[08:27:57.781]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.781]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.781]         }
[08:27:57.781]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.781]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.781]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.781]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.781]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.781]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.781]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.781]             base::names(...future.oldOptions))
[08:27:57.781]     }
[08:27:57.781]     if (FALSE) {
[08:27:57.781]     }
[08:27:57.781]     else {
[08:27:57.781]         if (TRUE) {
[08:27:57.781]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.781]                 open = "w")
[08:27:57.781]         }
[08:27:57.781]         else {
[08:27:57.781]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.781]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.781]         }
[08:27:57.781]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.781]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.781]             base::sink(type = "output", split = FALSE)
[08:27:57.781]             base::close(...future.stdout)
[08:27:57.781]         }, add = TRUE)
[08:27:57.781]     }
[08:27:57.781]     ...future.frame <- base::sys.nframe()
[08:27:57.781]     ...future.conditions <- base::list()
[08:27:57.781]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.781]     if (FALSE) {
[08:27:57.781]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.781]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.781]     }
[08:27:57.781]     ...future.result <- base::tryCatch({
[08:27:57.781]         base::withCallingHandlers({
[08:27:57.781]             ...future.value <- base::withVisible(base::local({
[08:27:57.781]                 withCallingHandlers({
[08:27:57.781]                   {
[08:27:57.781]                     lm(weight ~ group - 1)
[08:27:57.781]                   }
[08:27:57.781]                 }, immediateCondition = function(cond) {
[08:27:57.781]                   save_rds <- function (object, pathname, ...) 
[08:27:57.781]                   {
[08:27:57.781]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:57.781]                     if (file_test("-f", pathname_tmp)) {
[08:27:57.781]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.781]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:57.781]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.781]                         fi_tmp[["mtime"]])
[08:27:57.781]                     }
[08:27:57.781]                     tryCatch({
[08:27:57.781]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:57.781]                     }, error = function(ex) {
[08:27:57.781]                       msg <- conditionMessage(ex)
[08:27:57.781]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.781]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:57.781]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.781]                         fi_tmp[["mtime"]], msg)
[08:27:57.781]                       ex$message <- msg
[08:27:57.781]                       stop(ex)
[08:27:57.781]                     })
[08:27:57.781]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:57.781]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:57.781]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:57.781]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.781]                       fi <- file.info(pathname)
[08:27:57.781]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:57.781]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.781]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:57.781]                         fi[["size"]], fi[["mtime"]])
[08:27:57.781]                       stop(msg)
[08:27:57.781]                     }
[08:27:57.781]                     invisible(pathname)
[08:27:57.781]                   }
[08:27:57.781]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:57.781]                     rootPath = tempdir()) 
[08:27:57.781]                   {
[08:27:57.781]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:57.781]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:57.781]                       tmpdir = path, fileext = ".rds")
[08:27:57.781]                     save_rds(obj, file)
[08:27:57.781]                   }
[08:27:57.781]                   saveImmediateCondition(cond, path = "/tmp/RtmpUQjont/.future/immediateConditions")
[08:27:57.781]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.781]                   {
[08:27:57.781]                     inherits <- base::inherits
[08:27:57.781]                     invokeRestart <- base::invokeRestart
[08:27:57.781]                     is.null <- base::is.null
[08:27:57.781]                     muffled <- FALSE
[08:27:57.781]                     if (inherits(cond, "message")) {
[08:27:57.781]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:57.781]                       if (muffled) 
[08:27:57.781]                         invokeRestart("muffleMessage")
[08:27:57.781]                     }
[08:27:57.781]                     else if (inherits(cond, "warning")) {
[08:27:57.781]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:57.781]                       if (muffled) 
[08:27:57.781]                         invokeRestart("muffleWarning")
[08:27:57.781]                     }
[08:27:57.781]                     else if (inherits(cond, "condition")) {
[08:27:57.781]                       if (!is.null(pattern)) {
[08:27:57.781]                         computeRestarts <- base::computeRestarts
[08:27:57.781]                         grepl <- base::grepl
[08:27:57.781]                         restarts <- computeRestarts(cond)
[08:27:57.781]                         for (restart in restarts) {
[08:27:57.781]                           name <- restart$name
[08:27:57.781]                           if (is.null(name)) 
[08:27:57.781]                             next
[08:27:57.781]                           if (!grepl(pattern, name)) 
[08:27:57.781]                             next
[08:27:57.781]                           invokeRestart(restart)
[08:27:57.781]                           muffled <- TRUE
[08:27:57.781]                           break
[08:27:57.781]                         }
[08:27:57.781]                       }
[08:27:57.781]                     }
[08:27:57.781]                     invisible(muffled)
[08:27:57.781]                   }
[08:27:57.781]                   muffleCondition(cond)
[08:27:57.781]                 })
[08:27:57.781]             }))
[08:27:57.781]             future::FutureResult(value = ...future.value$value, 
[08:27:57.781]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.781]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.781]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.781]                     ...future.globalenv.names))
[08:27:57.781]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.781]         }, condition = base::local({
[08:27:57.781]             c <- base::c
[08:27:57.781]             inherits <- base::inherits
[08:27:57.781]             invokeRestart <- base::invokeRestart
[08:27:57.781]             length <- base::length
[08:27:57.781]             list <- base::list
[08:27:57.781]             seq.int <- base::seq.int
[08:27:57.781]             signalCondition <- base::signalCondition
[08:27:57.781]             sys.calls <- base::sys.calls
[08:27:57.781]             `[[` <- base::`[[`
[08:27:57.781]             `+` <- base::`+`
[08:27:57.781]             `<<-` <- base::`<<-`
[08:27:57.781]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.781]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.781]                   3L)]
[08:27:57.781]             }
[08:27:57.781]             function(cond) {
[08:27:57.781]                 is_error <- inherits(cond, "error")
[08:27:57.781]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.781]                   NULL)
[08:27:57.781]                 if (is_error) {
[08:27:57.781]                   sessionInformation <- function() {
[08:27:57.781]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.781]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.781]                       search = base::search(), system = base::Sys.info())
[08:27:57.781]                   }
[08:27:57.781]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.781]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.781]                     cond$call), session = sessionInformation(), 
[08:27:57.781]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.781]                   signalCondition(cond)
[08:27:57.781]                 }
[08:27:57.781]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.781]                 "immediateCondition"))) {
[08:27:57.781]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.781]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.781]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.781]                   if (TRUE && !signal) {
[08:27:57.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.781]                     {
[08:27:57.781]                       inherits <- base::inherits
[08:27:57.781]                       invokeRestart <- base::invokeRestart
[08:27:57.781]                       is.null <- base::is.null
[08:27:57.781]                       muffled <- FALSE
[08:27:57.781]                       if (inherits(cond, "message")) {
[08:27:57.781]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.781]                         if (muffled) 
[08:27:57.781]                           invokeRestart("muffleMessage")
[08:27:57.781]                       }
[08:27:57.781]                       else if (inherits(cond, "warning")) {
[08:27:57.781]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.781]                         if (muffled) 
[08:27:57.781]                           invokeRestart("muffleWarning")
[08:27:57.781]                       }
[08:27:57.781]                       else if (inherits(cond, "condition")) {
[08:27:57.781]                         if (!is.null(pattern)) {
[08:27:57.781]                           computeRestarts <- base::computeRestarts
[08:27:57.781]                           grepl <- base::grepl
[08:27:57.781]                           restarts <- computeRestarts(cond)
[08:27:57.781]                           for (restart in restarts) {
[08:27:57.781]                             name <- restart$name
[08:27:57.781]                             if (is.null(name)) 
[08:27:57.781]                               next
[08:27:57.781]                             if (!grepl(pattern, name)) 
[08:27:57.781]                               next
[08:27:57.781]                             invokeRestart(restart)
[08:27:57.781]                             muffled <- TRUE
[08:27:57.781]                             break
[08:27:57.781]                           }
[08:27:57.781]                         }
[08:27:57.781]                       }
[08:27:57.781]                       invisible(muffled)
[08:27:57.781]                     }
[08:27:57.781]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.781]                   }
[08:27:57.781]                 }
[08:27:57.781]                 else {
[08:27:57.781]                   if (TRUE) {
[08:27:57.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.781]                     {
[08:27:57.781]                       inherits <- base::inherits
[08:27:57.781]                       invokeRestart <- base::invokeRestart
[08:27:57.781]                       is.null <- base::is.null
[08:27:57.781]                       muffled <- FALSE
[08:27:57.781]                       if (inherits(cond, "message")) {
[08:27:57.781]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.781]                         if (muffled) 
[08:27:57.781]                           invokeRestart("muffleMessage")
[08:27:57.781]                       }
[08:27:57.781]                       else if (inherits(cond, "warning")) {
[08:27:57.781]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.781]                         if (muffled) 
[08:27:57.781]                           invokeRestart("muffleWarning")
[08:27:57.781]                       }
[08:27:57.781]                       else if (inherits(cond, "condition")) {
[08:27:57.781]                         if (!is.null(pattern)) {
[08:27:57.781]                           computeRestarts <- base::computeRestarts
[08:27:57.781]                           grepl <- base::grepl
[08:27:57.781]                           restarts <- computeRestarts(cond)
[08:27:57.781]                           for (restart in restarts) {
[08:27:57.781]                             name <- restart$name
[08:27:57.781]                             if (is.null(name)) 
[08:27:57.781]                               next
[08:27:57.781]                             if (!grepl(pattern, name)) 
[08:27:57.781]                               next
[08:27:57.781]                             invokeRestart(restart)
[08:27:57.781]                             muffled <- TRUE
[08:27:57.781]                             break
[08:27:57.781]                           }
[08:27:57.781]                         }
[08:27:57.781]                       }
[08:27:57.781]                       invisible(muffled)
[08:27:57.781]                     }
[08:27:57.781]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.781]                   }
[08:27:57.781]                 }
[08:27:57.781]             }
[08:27:57.781]         }))
[08:27:57.781]     }, error = function(ex) {
[08:27:57.781]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.781]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.781]                 ...future.rng), started = ...future.startTime, 
[08:27:57.781]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.781]             version = "1.8"), class = "FutureResult")
[08:27:57.781]     }, finally = {
[08:27:57.781]         if (!identical(...future.workdir, getwd())) 
[08:27:57.781]             setwd(...future.workdir)
[08:27:57.781]         {
[08:27:57.781]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.781]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.781]             }
[08:27:57.781]             base::options(...future.oldOptions)
[08:27:57.781]             if (.Platform$OS.type == "windows") {
[08:27:57.781]                 old_names <- names(...future.oldEnvVars)
[08:27:57.781]                 envs <- base::Sys.getenv()
[08:27:57.781]                 names <- names(envs)
[08:27:57.781]                 common <- intersect(names, old_names)
[08:27:57.781]                 added <- setdiff(names, old_names)
[08:27:57.781]                 removed <- setdiff(old_names, names)
[08:27:57.781]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.781]                   envs[common]]
[08:27:57.781]                 NAMES <- toupper(changed)
[08:27:57.781]                 args <- list()
[08:27:57.781]                 for (kk in seq_along(NAMES)) {
[08:27:57.781]                   name <- changed[[kk]]
[08:27:57.781]                   NAME <- NAMES[[kk]]
[08:27:57.781]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.781]                     next
[08:27:57.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.781]                 }
[08:27:57.781]                 NAMES <- toupper(added)
[08:27:57.781]                 for (kk in seq_along(NAMES)) {
[08:27:57.781]                   name <- added[[kk]]
[08:27:57.781]                   NAME <- NAMES[[kk]]
[08:27:57.781]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.781]                     next
[08:27:57.781]                   args[[name]] <- ""
[08:27:57.781]                 }
[08:27:57.781]                 NAMES <- toupper(removed)
[08:27:57.781]                 for (kk in seq_along(NAMES)) {
[08:27:57.781]                   name <- removed[[kk]]
[08:27:57.781]                   NAME <- NAMES[[kk]]
[08:27:57.781]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.781]                     next
[08:27:57.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.781]                 }
[08:27:57.781]                 if (length(args) > 0) 
[08:27:57.781]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.781]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.781]             }
[08:27:57.781]             else {
[08:27:57.781]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.781]             }
[08:27:57.781]             {
[08:27:57.781]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.781]                   0L) {
[08:27:57.781]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.781]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.781]                   base::options(opts)
[08:27:57.781]                 }
[08:27:57.781]                 {
[08:27:57.781]                   {
[08:27:57.781]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:57.781]                     NULL
[08:27:57.781]                   }
[08:27:57.781]                   options(future.plan = NULL)
[08:27:57.781]                   if (is.na(NA_character_)) 
[08:27:57.781]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.781]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.781]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.781]                     .init = FALSE)
[08:27:57.781]                 }
[08:27:57.781]             }
[08:27:57.781]         }
[08:27:57.781]     })
[08:27:57.781]     if (TRUE) {
[08:27:57.781]         base::sink(type = "output", split = FALSE)
[08:27:57.781]         if (TRUE) {
[08:27:57.781]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.781]         }
[08:27:57.781]         else {
[08:27:57.781]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.781]         }
[08:27:57.781]         base::close(...future.stdout)
[08:27:57.781]         ...future.stdout <- NULL
[08:27:57.781]     }
[08:27:57.781]     ...future.result$conditions <- ...future.conditions
[08:27:57.781]     ...future.result$finished <- base::Sys.time()
[08:27:57.781]     ...future.result
[08:27:57.781] }
[08:27:57.784] assign_globals() ...
[08:27:57.784] List of 2
[08:27:57.784]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[08:27:57.784]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[08:27:57.784]  - attr(*, "where")=List of 2
[08:27:57.784]   ..$ weight:<environment: R_EmptyEnv> 
[08:27:57.784]   ..$ group :<environment: R_EmptyEnv> 
[08:27:57.784]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:57.784]  - attr(*, "resolved")= logi FALSE
[08:27:57.784]  - attr(*, "total_size")= num 401
[08:27:57.784]  - attr(*, "already-done")= logi TRUE
[08:27:57.788] - copied ‘weight’ to environment
[08:27:57.788] - copied ‘group’ to environment
[08:27:57.788] assign_globals() ... done
[08:27:57.788] requestCore(): workers = 2
[08:27:57.790] MulticoreFuture started
[08:27:57.791] - Launch lazy future ... done
[08:27:57.791] run() for ‘MulticoreFuture’ ... done
[08:27:57.791] result() for MulticoreFuture ...
[08:27:57.792] plan(): Setting new future strategy stack:
[08:27:57.792] List of future strategies:
[08:27:57.792] 1. sequential:
[08:27:57.792]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.792]    - tweaked: FALSE
[08:27:57.792]    - call: NULL
[08:27:57.793] plan(): nbrOfWorkers() = 1
[08:27:57.801] plan(): Setting new future strategy stack:
[08:27:57.801] List of future strategies:
[08:27:57.801] 1. multicore:
[08:27:57.801]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:57.801]    - tweaked: FALSE
[08:27:57.801]    - call: plan(strategy)
[08:27:57.804] plan(): nbrOfWorkers() = 2
[08:27:57.806] result() for MulticoreFuture ...
[08:27:57.806] result() for MulticoreFuture ... done
[08:27:57.806] result() for MulticoreFuture ... done
[08:27:57.807] result() for MulticoreFuture ...
[08:27:57.809] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[08:27:57.812] getGlobalsAndPackages() ...
[08:27:57.812] Searching for globals...
[08:27:57.813] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[08:27:57.814] Searching for globals ... DONE
[08:27:57.814] Resolving globals: FALSE
[08:27:57.814] The total size of the 1 globals is 71 bytes (71 bytes)
[08:27:57.815] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 71 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (71 bytes of class ‘numeric’)
[08:27:57.815] - globals: [1] ‘x’
[08:27:57.815] - packages: [1] ‘stats’
[08:27:57.815] getGlobalsAndPackages() ... DONE
[08:27:57.816] run() for ‘Future’ ...
[08:27:57.816] - state: ‘created’
[08:27:57.816] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:57.818] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:57.818] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:57.818]   - Field: ‘label’
[08:27:57.818]   - Field: ‘local’
[08:27:57.819]   - Field: ‘owner’
[08:27:57.819]   - Field: ‘envir’
[08:27:57.819]   - Field: ‘workers’
[08:27:57.819]   - Field: ‘packages’
[08:27:57.819]   - Field: ‘gc’
[08:27:57.819]   - Field: ‘job’
[08:27:57.819]   - Field: ‘conditions’
[08:27:57.819]   - Field: ‘expr’
[08:27:57.819]   - Field: ‘uuid’
[08:27:57.820]   - Field: ‘seed’
[08:27:57.820]   - Field: ‘version’
[08:27:57.820]   - Field: ‘result’
[08:27:57.820]   - Field: ‘asynchronous’
[08:27:57.820]   - Field: ‘calls’
[08:27:57.820]   - Field: ‘globals’
[08:27:57.820]   - Field: ‘stdout’
[08:27:57.820]   - Field: ‘earlySignal’
[08:27:57.820]   - Field: ‘lazy’
[08:27:57.820]   - Field: ‘state’
[08:27:57.821] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:57.821] - Launch lazy future ...
[08:27:57.821] Packages needed by the future expression (n = 1): ‘stats’
[08:27:57.821] Packages needed by future strategies (n = 0): <none>
[08:27:57.822] {
[08:27:57.822]     {
[08:27:57.822]         {
[08:27:57.822]             ...future.startTime <- base::Sys.time()
[08:27:57.822]             {
[08:27:57.822]                 {
[08:27:57.822]                   {
[08:27:57.822]                     {
[08:27:57.822]                       {
[08:27:57.822]                         base::local({
[08:27:57.822]                           has_future <- base::requireNamespace("future", 
[08:27:57.822]                             quietly = TRUE)
[08:27:57.822]                           if (has_future) {
[08:27:57.822]                             ns <- base::getNamespace("future")
[08:27:57.822]                             version <- ns[[".package"]][["version"]]
[08:27:57.822]                             if (is.null(version)) 
[08:27:57.822]                               version <- utils::packageVersion("future")
[08:27:57.822]                           }
[08:27:57.822]                           else {
[08:27:57.822]                             version <- NULL
[08:27:57.822]                           }
[08:27:57.822]                           if (!has_future || version < "1.8.0") {
[08:27:57.822]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.822]                               "", base::R.version$version.string), 
[08:27:57.822]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:57.822]                                 base::R.version$platform, 8 * 
[08:27:57.822]                                   base::.Machine$sizeof.pointer), 
[08:27:57.822]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.822]                                 "release", "version")], collapse = " "), 
[08:27:57.822]                               hostname = base::Sys.info()[["nodename"]])
[08:27:57.822]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.822]                               info)
[08:27:57.822]                             info <- base::paste(info, collapse = "; ")
[08:27:57.822]                             if (!has_future) {
[08:27:57.822]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.822]                                 info)
[08:27:57.822]                             }
[08:27:57.822]                             else {
[08:27:57.822]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.822]                                 info, version)
[08:27:57.822]                             }
[08:27:57.822]                             base::stop(msg)
[08:27:57.822]                           }
[08:27:57.822]                         })
[08:27:57.822]                       }
[08:27:57.822]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:57.822]                       base::options(mc.cores = 1L)
[08:27:57.822]                     }
[08:27:57.822]                     base::local({
[08:27:57.822]                       for (pkg in "stats") {
[08:27:57.822]                         base::loadNamespace(pkg)
[08:27:57.822]                         base::library(pkg, character.only = TRUE)
[08:27:57.822]                       }
[08:27:57.822]                     })
[08:27:57.822]                   }
[08:27:57.822]                   ...future.strategy.old <- future::plan("list")
[08:27:57.822]                   options(future.plan = NULL)
[08:27:57.822]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.822]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.822]                 }
[08:27:57.822]                 ...future.workdir <- getwd()
[08:27:57.822]             }
[08:27:57.822]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.822]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.822]         }
[08:27:57.822]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.822]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.822]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.822]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.822]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.822]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.822]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.822]             base::names(...future.oldOptions))
[08:27:57.822]     }
[08:27:57.822]     if (FALSE) {
[08:27:57.822]     }
[08:27:57.822]     else {
[08:27:57.822]         if (TRUE) {
[08:27:57.822]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.822]                 open = "w")
[08:27:57.822]         }
[08:27:57.822]         else {
[08:27:57.822]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.822]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.822]         }
[08:27:57.822]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.822]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.822]             base::sink(type = "output", split = FALSE)
[08:27:57.822]             base::close(...future.stdout)
[08:27:57.822]         }, add = TRUE)
[08:27:57.822]     }
[08:27:57.822]     ...future.frame <- base::sys.nframe()
[08:27:57.822]     ...future.conditions <- base::list()
[08:27:57.822]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.822]     if (FALSE) {
[08:27:57.822]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.822]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.822]     }
[08:27:57.822]     ...future.result <- base::tryCatch({
[08:27:57.822]         base::withCallingHandlers({
[08:27:57.822]             ...future.value <- base::withVisible(base::local({
[08:27:57.822]                 withCallingHandlers({
[08:27:57.822]                   {
[08:27:57.822]                     xtabs(~x)
[08:27:57.822]                   }
[08:27:57.822]                 }, immediateCondition = function(cond) {
[08:27:57.822]                   save_rds <- function (object, pathname, ...) 
[08:27:57.822]                   {
[08:27:57.822]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:57.822]                     if (file_test("-f", pathname_tmp)) {
[08:27:57.822]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.822]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:57.822]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.822]                         fi_tmp[["mtime"]])
[08:27:57.822]                     }
[08:27:57.822]                     tryCatch({
[08:27:57.822]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:57.822]                     }, error = function(ex) {
[08:27:57.822]                       msg <- conditionMessage(ex)
[08:27:57.822]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.822]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:57.822]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.822]                         fi_tmp[["mtime"]], msg)
[08:27:57.822]                       ex$message <- msg
[08:27:57.822]                       stop(ex)
[08:27:57.822]                     })
[08:27:57.822]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:57.822]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:57.822]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:57.822]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.822]                       fi <- file.info(pathname)
[08:27:57.822]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:57.822]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.822]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:57.822]                         fi[["size"]], fi[["mtime"]])
[08:27:57.822]                       stop(msg)
[08:27:57.822]                     }
[08:27:57.822]                     invisible(pathname)
[08:27:57.822]                   }
[08:27:57.822]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:57.822]                     rootPath = tempdir()) 
[08:27:57.822]                   {
[08:27:57.822]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:57.822]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:57.822]                       tmpdir = path, fileext = ".rds")
[08:27:57.822]                     save_rds(obj, file)
[08:27:57.822]                   }
[08:27:57.822]                   saveImmediateCondition(cond, path = "/tmp/RtmpUQjont/.future/immediateConditions")
[08:27:57.822]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.822]                   {
[08:27:57.822]                     inherits <- base::inherits
[08:27:57.822]                     invokeRestart <- base::invokeRestart
[08:27:57.822]                     is.null <- base::is.null
[08:27:57.822]                     muffled <- FALSE
[08:27:57.822]                     if (inherits(cond, "message")) {
[08:27:57.822]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:57.822]                       if (muffled) 
[08:27:57.822]                         invokeRestart("muffleMessage")
[08:27:57.822]                     }
[08:27:57.822]                     else if (inherits(cond, "warning")) {
[08:27:57.822]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:57.822]                       if (muffled) 
[08:27:57.822]                         invokeRestart("muffleWarning")
[08:27:57.822]                     }
[08:27:57.822]                     else if (inherits(cond, "condition")) {
[08:27:57.822]                       if (!is.null(pattern)) {
[08:27:57.822]                         computeRestarts <- base::computeRestarts
[08:27:57.822]                         grepl <- base::grepl
[08:27:57.822]                         restarts <- computeRestarts(cond)
[08:27:57.822]                         for (restart in restarts) {
[08:27:57.822]                           name <- restart$name
[08:27:57.822]                           if (is.null(name)) 
[08:27:57.822]                             next
[08:27:57.822]                           if (!grepl(pattern, name)) 
[08:27:57.822]                             next
[08:27:57.822]                           invokeRestart(restart)
[08:27:57.822]                           muffled <- TRUE
[08:27:57.822]                           break
[08:27:57.822]                         }
[08:27:57.822]                       }
[08:27:57.822]                     }
[08:27:57.822]                     invisible(muffled)
[08:27:57.822]                   }
[08:27:57.822]                   muffleCondition(cond)
[08:27:57.822]                 })
[08:27:57.822]             }))
[08:27:57.822]             future::FutureResult(value = ...future.value$value, 
[08:27:57.822]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.822]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.822]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.822]                     ...future.globalenv.names))
[08:27:57.822]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.822]         }, condition = base::local({
[08:27:57.822]             c <- base::c
[08:27:57.822]             inherits <- base::inherits
[08:27:57.822]             invokeRestart <- base::invokeRestart
[08:27:57.822]             length <- base::length
[08:27:57.822]             list <- base::list
[08:27:57.822]             seq.int <- base::seq.int
[08:27:57.822]             signalCondition <- base::signalCondition
[08:27:57.822]             sys.calls <- base::sys.calls
[08:27:57.822]             `[[` <- base::`[[`
[08:27:57.822]             `+` <- base::`+`
[08:27:57.822]             `<<-` <- base::`<<-`
[08:27:57.822]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.822]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.822]                   3L)]
[08:27:57.822]             }
[08:27:57.822]             function(cond) {
[08:27:57.822]                 is_error <- inherits(cond, "error")
[08:27:57.822]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.822]                   NULL)
[08:27:57.822]                 if (is_error) {
[08:27:57.822]                   sessionInformation <- function() {
[08:27:57.822]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.822]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.822]                       search = base::search(), system = base::Sys.info())
[08:27:57.822]                   }
[08:27:57.822]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.822]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.822]                     cond$call), session = sessionInformation(), 
[08:27:57.822]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.822]                   signalCondition(cond)
[08:27:57.822]                 }
[08:27:57.822]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.822]                 "immediateCondition"))) {
[08:27:57.822]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.822]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.822]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.822]                   if (TRUE && !signal) {
[08:27:57.822]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.822]                     {
[08:27:57.822]                       inherits <- base::inherits
[08:27:57.822]                       invokeRestart <- base::invokeRestart
[08:27:57.822]                       is.null <- base::is.null
[08:27:57.822]                       muffled <- FALSE
[08:27:57.822]                       if (inherits(cond, "message")) {
[08:27:57.822]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.822]                         if (muffled) 
[08:27:57.822]                           invokeRestart("muffleMessage")
[08:27:57.822]                       }
[08:27:57.822]                       else if (inherits(cond, "warning")) {
[08:27:57.822]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.822]                         if (muffled) 
[08:27:57.822]                           invokeRestart("muffleWarning")
[08:27:57.822]                       }
[08:27:57.822]                       else if (inherits(cond, "condition")) {
[08:27:57.822]                         if (!is.null(pattern)) {
[08:27:57.822]                           computeRestarts <- base::computeRestarts
[08:27:57.822]                           grepl <- base::grepl
[08:27:57.822]                           restarts <- computeRestarts(cond)
[08:27:57.822]                           for (restart in restarts) {
[08:27:57.822]                             name <- restart$name
[08:27:57.822]                             if (is.null(name)) 
[08:27:57.822]                               next
[08:27:57.822]                             if (!grepl(pattern, name)) 
[08:27:57.822]                               next
[08:27:57.822]                             invokeRestart(restart)
[08:27:57.822]                             muffled <- TRUE
[08:27:57.822]                             break
[08:27:57.822]                           }
[08:27:57.822]                         }
[08:27:57.822]                       }
[08:27:57.822]                       invisible(muffled)
[08:27:57.822]                     }
[08:27:57.822]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.822]                   }
[08:27:57.822]                 }
[08:27:57.822]                 else {
[08:27:57.822]                   if (TRUE) {
[08:27:57.822]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.822]                     {
[08:27:57.822]                       inherits <- base::inherits
[08:27:57.822]                       invokeRestart <- base::invokeRestart
[08:27:57.822]                       is.null <- base::is.null
[08:27:57.822]                       muffled <- FALSE
[08:27:57.822]                       if (inherits(cond, "message")) {
[08:27:57.822]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.822]                         if (muffled) 
[08:27:57.822]                           invokeRestart("muffleMessage")
[08:27:57.822]                       }
[08:27:57.822]                       else if (inherits(cond, "warning")) {
[08:27:57.822]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.822]                         if (muffled) 
[08:27:57.822]                           invokeRestart("muffleWarning")
[08:27:57.822]                       }
[08:27:57.822]                       else if (inherits(cond, "condition")) {
[08:27:57.822]                         if (!is.null(pattern)) {
[08:27:57.822]                           computeRestarts <- base::computeRestarts
[08:27:57.822]                           grepl <- base::grepl
[08:27:57.822]                           restarts <- computeRestarts(cond)
[08:27:57.822]                           for (restart in restarts) {
[08:27:57.822]                             name <- restart$name
[08:27:57.822]                             if (is.null(name)) 
[08:27:57.822]                               next
[08:27:57.822]                             if (!grepl(pattern, name)) 
[08:27:57.822]                               next
[08:27:57.822]                             invokeRestart(restart)
[08:27:57.822]                             muffled <- TRUE
[08:27:57.822]                             break
[08:27:57.822]                           }
[08:27:57.822]                         }
[08:27:57.822]                       }
[08:27:57.822]                       invisible(muffled)
[08:27:57.822]                     }
[08:27:57.822]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.822]                   }
[08:27:57.822]                 }
[08:27:57.822]             }
[08:27:57.822]         }))
[08:27:57.822]     }, error = function(ex) {
[08:27:57.822]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.822]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.822]                 ...future.rng), started = ...future.startTime, 
[08:27:57.822]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.822]             version = "1.8"), class = "FutureResult")
[08:27:57.822]     }, finally = {
[08:27:57.822]         if (!identical(...future.workdir, getwd())) 
[08:27:57.822]             setwd(...future.workdir)
[08:27:57.822]         {
[08:27:57.822]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.822]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.822]             }
[08:27:57.822]             base::options(...future.oldOptions)
[08:27:57.822]             if (.Platform$OS.type == "windows") {
[08:27:57.822]                 old_names <- names(...future.oldEnvVars)
[08:27:57.822]                 envs <- base::Sys.getenv()
[08:27:57.822]                 names <- names(envs)
[08:27:57.822]                 common <- intersect(names, old_names)
[08:27:57.822]                 added <- setdiff(names, old_names)
[08:27:57.822]                 removed <- setdiff(old_names, names)
[08:27:57.822]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.822]                   envs[common]]
[08:27:57.822]                 NAMES <- toupper(changed)
[08:27:57.822]                 args <- list()
[08:27:57.822]                 for (kk in seq_along(NAMES)) {
[08:27:57.822]                   name <- changed[[kk]]
[08:27:57.822]                   NAME <- NAMES[[kk]]
[08:27:57.822]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.822]                     next
[08:27:57.822]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.822]                 }
[08:27:57.822]                 NAMES <- toupper(added)
[08:27:57.822]                 for (kk in seq_along(NAMES)) {
[08:27:57.822]                   name <- added[[kk]]
[08:27:57.822]                   NAME <- NAMES[[kk]]
[08:27:57.822]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.822]                     next
[08:27:57.822]                   args[[name]] <- ""
[08:27:57.822]                 }
[08:27:57.822]                 NAMES <- toupper(removed)
[08:27:57.822]                 for (kk in seq_along(NAMES)) {
[08:27:57.822]                   name <- removed[[kk]]
[08:27:57.822]                   NAME <- NAMES[[kk]]
[08:27:57.822]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.822]                     next
[08:27:57.822]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.822]                 }
[08:27:57.822]                 if (length(args) > 0) 
[08:27:57.822]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.822]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.822]             }
[08:27:57.822]             else {
[08:27:57.822]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.822]             }
[08:27:57.822]             {
[08:27:57.822]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.822]                   0L) {
[08:27:57.822]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.822]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.822]                   base::options(opts)
[08:27:57.822]                 }
[08:27:57.822]                 {
[08:27:57.822]                   {
[08:27:57.822]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:57.822]                     NULL
[08:27:57.822]                   }
[08:27:57.822]                   options(future.plan = NULL)
[08:27:57.822]                   if (is.na(NA_character_)) 
[08:27:57.822]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.822]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.822]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.822]                     .init = FALSE)
[08:27:57.822]                 }
[08:27:57.822]             }
[08:27:57.822]         }
[08:27:57.822]     })
[08:27:57.822]     if (TRUE) {
[08:27:57.822]         base::sink(type = "output", split = FALSE)
[08:27:57.822]         if (TRUE) {
[08:27:57.822]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.822]         }
[08:27:57.822]         else {
[08:27:57.822]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.822]         }
[08:27:57.822]         base::close(...future.stdout)
[08:27:57.822]         ...future.stdout <- NULL
[08:27:57.822]     }
[08:27:57.822]     ...future.result$conditions <- ...future.conditions
[08:27:57.822]     ...future.result$finished <- base::Sys.time()
[08:27:57.822]     ...future.result
[08:27:57.822] }
[08:27:57.824] assign_globals() ...
[08:27:57.824] List of 1
[08:27:57.824]  $ x: num [1:5] 1 1 2 2 2
[08:27:57.824]  - attr(*, "where")=List of 1
[08:27:57.824]   ..$ x:<environment: R_EmptyEnv> 
[08:27:57.824]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:57.824]  - attr(*, "resolved")= logi FALSE
[08:27:57.824]  - attr(*, "total_size")= num 71
[08:27:57.824]  - attr(*, "already-done")= logi TRUE
[08:27:57.827] - copied ‘x’ to environment
[08:27:57.827] assign_globals() ... done
[08:27:57.828] requestCore(): workers = 2
[08:27:57.830] MulticoreFuture started
[08:27:57.830] - Launch lazy future ... done
[08:27:57.830] run() for ‘MulticoreFuture’ ... done
[08:27:57.830] result() for MulticoreFuture ...
[08:27:57.831] plan(): Setting new future strategy stack:
[08:27:57.831] List of future strategies:
[08:27:57.831] 1. sequential:
[08:27:57.831]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.831]    - tweaked: FALSE
[08:27:57.831]    - call: NULL
[08:27:57.832] plan(): nbrOfWorkers() = 1
[08:27:57.835] plan(): Setting new future strategy stack:
[08:27:57.835] List of future strategies:
[08:27:57.835] 1. multicore:
[08:27:57.835]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:57.835]    - tweaked: FALSE
[08:27:57.835]    - call: plan(strategy)
[08:27:57.838] plan(): nbrOfWorkers() = 2
[08:27:57.839] result() for MulticoreFuture ...
[08:27:57.839] result() for MulticoreFuture ... done
[08:27:57.839] result() for MulticoreFuture ... done
[08:27:57.839] result() for MulticoreFuture ...
[08:27:57.839] result() for MulticoreFuture ... done
x
1 2 
2 3 
[08:27:57.841] getGlobalsAndPackages() ...
[08:27:57.841] Searching for globals...
[08:27:57.842] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[08:27:57.843] Searching for globals ... DONE
[08:27:57.843] Resolving globals: FALSE
[08:27:57.843] The total size of the 1 globals is 71 bytes (71 bytes)
[08:27:57.844] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 71 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (71 bytes of class ‘numeric’)
[08:27:57.844] - globals: [1] ‘x’
[08:27:57.844] - packages: [1] ‘stats’
[08:27:57.844] getGlobalsAndPackages() ... DONE
[08:27:57.845] run() for ‘Future’ ...
[08:27:57.845] - state: ‘created’
[08:27:57.845] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:57.847] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:57.850] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:57.850]   - Field: ‘label’
[08:27:57.850]   - Field: ‘local’
[08:27:57.850]   - Field: ‘owner’
[08:27:57.850]   - Field: ‘envir’
[08:27:57.850]   - Field: ‘workers’
[08:27:57.851]   - Field: ‘packages’
[08:27:57.851]   - Field: ‘gc’
[08:27:57.851]   - Field: ‘job’
[08:27:57.851]   - Field: ‘conditions’
[08:27:57.851]   - Field: ‘expr’
[08:27:57.851]   - Field: ‘uuid’
[08:27:57.851]   - Field: ‘seed’
[08:27:57.851]   - Field: ‘version’
[08:27:57.852]   - Field: ‘result’
[08:27:57.852]   - Field: ‘asynchronous’
[08:27:57.852]   - Field: ‘calls’
[08:27:57.852]   - Field: ‘globals’
[08:27:57.852]   - Field: ‘stdout’
[08:27:57.852]   - Field: ‘earlySignal’
[08:27:57.852]   - Field: ‘lazy’
[08:27:57.852]   - Field: ‘state’
[08:27:57.853] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:57.853] - Launch lazy future ...
[08:27:57.853] Packages needed by the future expression (n = 1): ‘stats’
[08:27:57.853] Packages needed by future strategies (n = 0): <none>
[08:27:57.854] {
[08:27:57.854]     {
[08:27:57.854]         {
[08:27:57.854]             ...future.startTime <- base::Sys.time()
[08:27:57.854]             {
[08:27:57.854]                 {
[08:27:57.854]                   {
[08:27:57.854]                     {
[08:27:57.854]                       {
[08:27:57.854]                         base::local({
[08:27:57.854]                           has_future <- base::requireNamespace("future", 
[08:27:57.854]                             quietly = TRUE)
[08:27:57.854]                           if (has_future) {
[08:27:57.854]                             ns <- base::getNamespace("future")
[08:27:57.854]                             version <- ns[[".package"]][["version"]]
[08:27:57.854]                             if (is.null(version)) 
[08:27:57.854]                               version <- utils::packageVersion("future")
[08:27:57.854]                           }
[08:27:57.854]                           else {
[08:27:57.854]                             version <- NULL
[08:27:57.854]                           }
[08:27:57.854]                           if (!has_future || version < "1.8.0") {
[08:27:57.854]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.854]                               "", base::R.version$version.string), 
[08:27:57.854]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:57.854]                                 base::R.version$platform, 8 * 
[08:27:57.854]                                   base::.Machine$sizeof.pointer), 
[08:27:57.854]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.854]                                 "release", "version")], collapse = " "), 
[08:27:57.854]                               hostname = base::Sys.info()[["nodename"]])
[08:27:57.854]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.854]                               info)
[08:27:57.854]                             info <- base::paste(info, collapse = "; ")
[08:27:57.854]                             if (!has_future) {
[08:27:57.854]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.854]                                 info)
[08:27:57.854]                             }
[08:27:57.854]                             else {
[08:27:57.854]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.854]                                 info, version)
[08:27:57.854]                             }
[08:27:57.854]                             base::stop(msg)
[08:27:57.854]                           }
[08:27:57.854]                         })
[08:27:57.854]                       }
[08:27:57.854]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:57.854]                       base::options(mc.cores = 1L)
[08:27:57.854]                     }
[08:27:57.854]                     base::local({
[08:27:57.854]                       for (pkg in "stats") {
[08:27:57.854]                         base::loadNamespace(pkg)
[08:27:57.854]                         base::library(pkg, character.only = TRUE)
[08:27:57.854]                       }
[08:27:57.854]                     })
[08:27:57.854]                   }
[08:27:57.854]                   ...future.strategy.old <- future::plan("list")
[08:27:57.854]                   options(future.plan = NULL)
[08:27:57.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.854]                 }
[08:27:57.854]                 ...future.workdir <- getwd()
[08:27:57.854]             }
[08:27:57.854]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.854]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.854]         }
[08:27:57.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.854]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.854]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.854]             base::names(...future.oldOptions))
[08:27:57.854]     }
[08:27:57.854]     if (FALSE) {
[08:27:57.854]     }
[08:27:57.854]     else {
[08:27:57.854]         if (TRUE) {
[08:27:57.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.854]                 open = "w")
[08:27:57.854]         }
[08:27:57.854]         else {
[08:27:57.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.854]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.854]         }
[08:27:57.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.854]             base::sink(type = "output", split = FALSE)
[08:27:57.854]             base::close(...future.stdout)
[08:27:57.854]         }, add = TRUE)
[08:27:57.854]     }
[08:27:57.854]     ...future.frame <- base::sys.nframe()
[08:27:57.854]     ...future.conditions <- base::list()
[08:27:57.854]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.854]     if (FALSE) {
[08:27:57.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.854]     }
[08:27:57.854]     ...future.result <- base::tryCatch({
[08:27:57.854]         base::withCallingHandlers({
[08:27:57.854]             ...future.value <- base::withVisible(base::local({
[08:27:57.854]                 withCallingHandlers({
[08:27:57.854]                   {
[08:27:57.854]                     xtabs(~x)
[08:27:57.854]                   }
[08:27:57.854]                 }, immediateCondition = function(cond) {
[08:27:57.854]                   save_rds <- function (object, pathname, ...) 
[08:27:57.854]                   {
[08:27:57.854]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:57.854]                     if (file_test("-f", pathname_tmp)) {
[08:27:57.854]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.854]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:57.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.854]                         fi_tmp[["mtime"]])
[08:27:57.854]                     }
[08:27:57.854]                     tryCatch({
[08:27:57.854]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:57.854]                     }, error = function(ex) {
[08:27:57.854]                       msg <- conditionMessage(ex)
[08:27:57.854]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.854]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:57.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.854]                         fi_tmp[["mtime"]], msg)
[08:27:57.854]                       ex$message <- msg
[08:27:57.854]                       stop(ex)
[08:27:57.854]                     })
[08:27:57.854]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:57.854]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:57.854]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:57.854]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.854]                       fi <- file.info(pathname)
[08:27:57.854]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:57.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.854]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:57.854]                         fi[["size"]], fi[["mtime"]])
[08:27:57.854]                       stop(msg)
[08:27:57.854]                     }
[08:27:57.854]                     invisible(pathname)
[08:27:57.854]                   }
[08:27:57.854]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:57.854]                     rootPath = tempdir()) 
[08:27:57.854]                   {
[08:27:57.854]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:57.854]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:57.854]                       tmpdir = path, fileext = ".rds")
[08:27:57.854]                     save_rds(obj, file)
[08:27:57.854]                   }
[08:27:57.854]                   saveImmediateCondition(cond, path = "/tmp/RtmpUQjont/.future/immediateConditions")
[08:27:57.854]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.854]                   {
[08:27:57.854]                     inherits <- base::inherits
[08:27:57.854]                     invokeRestart <- base::invokeRestart
[08:27:57.854]                     is.null <- base::is.null
[08:27:57.854]                     muffled <- FALSE
[08:27:57.854]                     if (inherits(cond, "message")) {
[08:27:57.854]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:57.854]                       if (muffled) 
[08:27:57.854]                         invokeRestart("muffleMessage")
[08:27:57.854]                     }
[08:27:57.854]                     else if (inherits(cond, "warning")) {
[08:27:57.854]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:57.854]                       if (muffled) 
[08:27:57.854]                         invokeRestart("muffleWarning")
[08:27:57.854]                     }
[08:27:57.854]                     else if (inherits(cond, "condition")) {
[08:27:57.854]                       if (!is.null(pattern)) {
[08:27:57.854]                         computeRestarts <- base::computeRestarts
[08:27:57.854]                         grepl <- base::grepl
[08:27:57.854]                         restarts <- computeRestarts(cond)
[08:27:57.854]                         for (restart in restarts) {
[08:27:57.854]                           name <- restart$name
[08:27:57.854]                           if (is.null(name)) 
[08:27:57.854]                             next
[08:27:57.854]                           if (!grepl(pattern, name)) 
[08:27:57.854]                             next
[08:27:57.854]                           invokeRestart(restart)
[08:27:57.854]                           muffled <- TRUE
[08:27:57.854]                           break
[08:27:57.854]                         }
[08:27:57.854]                       }
[08:27:57.854]                     }
[08:27:57.854]                     invisible(muffled)
[08:27:57.854]                   }
[08:27:57.854]                   muffleCondition(cond)
[08:27:57.854]                 })
[08:27:57.854]             }))
[08:27:57.854]             future::FutureResult(value = ...future.value$value, 
[08:27:57.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.854]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.854]                     ...future.globalenv.names))
[08:27:57.854]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.854]         }, condition = base::local({
[08:27:57.854]             c <- base::c
[08:27:57.854]             inherits <- base::inherits
[08:27:57.854]             invokeRestart <- base::invokeRestart
[08:27:57.854]             length <- base::length
[08:27:57.854]             list <- base::list
[08:27:57.854]             seq.int <- base::seq.int
[08:27:57.854]             signalCondition <- base::signalCondition
[08:27:57.854]             sys.calls <- base::sys.calls
[08:27:57.854]             `[[` <- base::`[[`
[08:27:57.854]             `+` <- base::`+`
[08:27:57.854]             `<<-` <- base::`<<-`
[08:27:57.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.854]                   3L)]
[08:27:57.854]             }
[08:27:57.854]             function(cond) {
[08:27:57.854]                 is_error <- inherits(cond, "error")
[08:27:57.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.854]                   NULL)
[08:27:57.854]                 if (is_error) {
[08:27:57.854]                   sessionInformation <- function() {
[08:27:57.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.854]                       search = base::search(), system = base::Sys.info())
[08:27:57.854]                   }
[08:27:57.854]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.854]                     cond$call), session = sessionInformation(), 
[08:27:57.854]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.854]                   signalCondition(cond)
[08:27:57.854]                 }
[08:27:57.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.854]                 "immediateCondition"))) {
[08:27:57.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.854]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.854]                   if (TRUE && !signal) {
[08:27:57.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.854]                     {
[08:27:57.854]                       inherits <- base::inherits
[08:27:57.854]                       invokeRestart <- base::invokeRestart
[08:27:57.854]                       is.null <- base::is.null
[08:27:57.854]                       muffled <- FALSE
[08:27:57.854]                       if (inherits(cond, "message")) {
[08:27:57.854]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.854]                         if (muffled) 
[08:27:57.854]                           invokeRestart("muffleMessage")
[08:27:57.854]                       }
[08:27:57.854]                       else if (inherits(cond, "warning")) {
[08:27:57.854]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.854]                         if (muffled) 
[08:27:57.854]                           invokeRestart("muffleWarning")
[08:27:57.854]                       }
[08:27:57.854]                       else if (inherits(cond, "condition")) {
[08:27:57.854]                         if (!is.null(pattern)) {
[08:27:57.854]                           computeRestarts <- base::computeRestarts
[08:27:57.854]                           grepl <- base::grepl
[08:27:57.854]                           restarts <- computeRestarts(cond)
[08:27:57.854]                           for (restart in restarts) {
[08:27:57.854]                             name <- restart$name
[08:27:57.854]                             if (is.null(name)) 
[08:27:57.854]                               next
[08:27:57.854]                             if (!grepl(pattern, name)) 
[08:27:57.854]                               next
[08:27:57.854]                             invokeRestart(restart)
[08:27:57.854]                             muffled <- TRUE
[08:27:57.854]                             break
[08:27:57.854]                           }
[08:27:57.854]                         }
[08:27:57.854]                       }
[08:27:57.854]                       invisible(muffled)
[08:27:57.854]                     }
[08:27:57.854]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.854]                   }
[08:27:57.854]                 }
[08:27:57.854]                 else {
[08:27:57.854]                   if (TRUE) {
[08:27:57.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.854]                     {
[08:27:57.854]                       inherits <- base::inherits
[08:27:57.854]                       invokeRestart <- base::invokeRestart
[08:27:57.854]                       is.null <- base::is.null
[08:27:57.854]                       muffled <- FALSE
[08:27:57.854]                       if (inherits(cond, "message")) {
[08:27:57.854]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.854]                         if (muffled) 
[08:27:57.854]                           invokeRestart("muffleMessage")
[08:27:57.854]                       }
[08:27:57.854]                       else if (inherits(cond, "warning")) {
[08:27:57.854]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.854]                         if (muffled) 
[08:27:57.854]                           invokeRestart("muffleWarning")
[08:27:57.854]                       }
[08:27:57.854]                       else if (inherits(cond, "condition")) {
[08:27:57.854]                         if (!is.null(pattern)) {
[08:27:57.854]                           computeRestarts <- base::computeRestarts
[08:27:57.854]                           grepl <- base::grepl
[08:27:57.854]                           restarts <- computeRestarts(cond)
[08:27:57.854]                           for (restart in restarts) {
[08:27:57.854]                             name <- restart$name
[08:27:57.854]                             if (is.null(name)) 
[08:27:57.854]                               next
[08:27:57.854]                             if (!grepl(pattern, name)) 
[08:27:57.854]                               next
[08:27:57.854]                             invokeRestart(restart)
[08:27:57.854]                             muffled <- TRUE
[08:27:57.854]                             break
[08:27:57.854]                           }
[08:27:57.854]                         }
[08:27:57.854]                       }
[08:27:57.854]                       invisible(muffled)
[08:27:57.854]                     }
[08:27:57.854]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.854]                   }
[08:27:57.854]                 }
[08:27:57.854]             }
[08:27:57.854]         }))
[08:27:57.854]     }, error = function(ex) {
[08:27:57.854]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.854]                 ...future.rng), started = ...future.startTime, 
[08:27:57.854]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.854]             version = "1.8"), class = "FutureResult")
[08:27:57.854]     }, finally = {
[08:27:57.854]         if (!identical(...future.workdir, getwd())) 
[08:27:57.854]             setwd(...future.workdir)
[08:27:57.854]         {
[08:27:57.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.854]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.854]             }
[08:27:57.854]             base::options(...future.oldOptions)
[08:27:57.854]             if (.Platform$OS.type == "windows") {
[08:27:57.854]                 old_names <- names(...future.oldEnvVars)
[08:27:57.854]                 envs <- base::Sys.getenv()
[08:27:57.854]                 names <- names(envs)
[08:27:57.854]                 common <- intersect(names, old_names)
[08:27:57.854]                 added <- setdiff(names, old_names)
[08:27:57.854]                 removed <- setdiff(old_names, names)
[08:27:57.854]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.854]                   envs[common]]
[08:27:57.854]                 NAMES <- toupper(changed)
[08:27:57.854]                 args <- list()
[08:27:57.854]                 for (kk in seq_along(NAMES)) {
[08:27:57.854]                   name <- changed[[kk]]
[08:27:57.854]                   NAME <- NAMES[[kk]]
[08:27:57.854]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.854]                     next
[08:27:57.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.854]                 }
[08:27:57.854]                 NAMES <- toupper(added)
[08:27:57.854]                 for (kk in seq_along(NAMES)) {
[08:27:57.854]                   name <- added[[kk]]
[08:27:57.854]                   NAME <- NAMES[[kk]]
[08:27:57.854]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.854]                     next
[08:27:57.854]                   args[[name]] <- ""
[08:27:57.854]                 }
[08:27:57.854]                 NAMES <- toupper(removed)
[08:27:57.854]                 for (kk in seq_along(NAMES)) {
[08:27:57.854]                   name <- removed[[kk]]
[08:27:57.854]                   NAME <- NAMES[[kk]]
[08:27:57.854]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.854]                     next
[08:27:57.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.854]                 }
[08:27:57.854]                 if (length(args) > 0) 
[08:27:57.854]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.854]             }
[08:27:57.854]             else {
[08:27:57.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.854]             }
[08:27:57.854]             {
[08:27:57.854]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.854]                   0L) {
[08:27:57.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.854]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.854]                   base::options(opts)
[08:27:57.854]                 }
[08:27:57.854]                 {
[08:27:57.854]                   {
[08:27:57.854]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:57.854]                     NULL
[08:27:57.854]                   }
[08:27:57.854]                   options(future.plan = NULL)
[08:27:57.854]                   if (is.na(NA_character_)) 
[08:27:57.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.854]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.854]                     .init = FALSE)
[08:27:57.854]                 }
[08:27:57.854]             }
[08:27:57.854]         }
[08:27:57.854]     })
[08:27:57.854]     if (TRUE) {
[08:27:57.854]         base::sink(type = "output", split = FALSE)
[08:27:57.854]         if (TRUE) {
[08:27:57.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.854]         }
[08:27:57.854]         else {
[08:27:57.854]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.854]         }
[08:27:57.854]         base::close(...future.stdout)
[08:27:57.854]         ...future.stdout <- NULL
[08:27:57.854]     }
[08:27:57.854]     ...future.result$conditions <- ...future.conditions
[08:27:57.854]     ...future.result$finished <- base::Sys.time()
[08:27:57.854]     ...future.result
[08:27:57.854] }
[08:27:57.856] assign_globals() ...
[08:27:57.857] List of 1
[08:27:57.857]  $ x: num [1:5] 1 1 2 2 2
[08:27:57.857]  - attr(*, "where")=List of 1
[08:27:57.857]   ..$ x:<environment: R_EmptyEnv> 
[08:27:57.857]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:57.857]  - attr(*, "resolved")= logi FALSE
[08:27:57.857]  - attr(*, "total_size")= num 71
[08:27:57.857]  - attr(*, "already-done")= logi TRUE
[08:27:57.860] - copied ‘x’ to environment
[08:27:57.860] assign_globals() ... done
[08:27:57.860] requestCore(): workers = 2
[08:27:57.862] MulticoreFuture started
[08:27:57.863] - Launch lazy future ... done
[08:27:57.863] run() for ‘MulticoreFuture’ ... done
[08:27:57.863] result() for MulticoreFuture ...
[08:27:57.864] plan(): Setting new future strategy stack:
[08:27:57.864] List of future strategies:
[08:27:57.864] 1. sequential:
[08:27:57.864]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.864]    - tweaked: FALSE
[08:27:57.864]    - call: NULL
[08:27:57.865] plan(): nbrOfWorkers() = 1
[08:27:57.868] plan(): Setting new future strategy stack:
[08:27:57.868] List of future strategies:
[08:27:57.868] 1. multicore:
[08:27:57.868]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:57.868]    - tweaked: FALSE
[08:27:57.868]    - call: plan(strategy)
[08:27:57.871] plan(): nbrOfWorkers() = 2
[08:27:57.872] result() for MulticoreFuture ...
[08:27:57.872] result() for MulticoreFuture ... done
[08:27:57.872] result() for MulticoreFuture ... done
[08:27:57.873] result() for MulticoreFuture ...
[08:27:57.873] result() for MulticoreFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[08:27:57.875] getGlobalsAndPackages() ...
[08:27:57.875] Searching for globals...
[08:27:57.877] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[08:27:57.878] Searching for globals ... DONE
[08:27:57.878] Resolving globals: FALSE
[08:27:57.878] 
[08:27:57.878] - packages: [2] ‘stats’, ‘datasets’
[08:27:57.879] getGlobalsAndPackages() ... DONE
[08:27:57.879] run() for ‘Future’ ...
[08:27:57.879] - state: ‘created’
[08:27:57.879] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:57.881] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:57.882] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:57.882]   - Field: ‘label’
[08:27:57.882]   - Field: ‘local’
[08:27:57.882]   - Field: ‘owner’
[08:27:57.882]   - Field: ‘envir’
[08:27:57.882]   - Field: ‘workers’
[08:27:57.882]   - Field: ‘packages’
[08:27:57.882]   - Field: ‘gc’
[08:27:57.882]   - Field: ‘job’
[08:27:57.883]   - Field: ‘conditions’
[08:27:57.883]   - Field: ‘expr’
[08:27:57.883]   - Field: ‘uuid’
[08:27:57.883]   - Field: ‘seed’
[08:27:57.883]   - Field: ‘version’
[08:27:57.883]   - Field: ‘result’
[08:27:57.883]   - Field: ‘asynchronous’
[08:27:57.883]   - Field: ‘calls’
[08:27:57.883]   - Field: ‘globals’
[08:27:57.883]   - Field: ‘stdout’
[08:27:57.884]   - Field: ‘earlySignal’
[08:27:57.884]   - Field: ‘lazy’
[08:27:57.884]   - Field: ‘state’
[08:27:57.884] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:57.884] - Launch lazy future ...
[08:27:57.884] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[08:27:57.885] Packages needed by future strategies (n = 0): <none>
[08:27:57.885] {
[08:27:57.885]     {
[08:27:57.885]         {
[08:27:57.885]             ...future.startTime <- base::Sys.time()
[08:27:57.885]             {
[08:27:57.885]                 {
[08:27:57.885]                   {
[08:27:57.885]                     {
[08:27:57.885]                       {
[08:27:57.885]                         base::local({
[08:27:57.885]                           has_future <- base::requireNamespace("future", 
[08:27:57.885]                             quietly = TRUE)
[08:27:57.885]                           if (has_future) {
[08:27:57.885]                             ns <- base::getNamespace("future")
[08:27:57.885]                             version <- ns[[".package"]][["version"]]
[08:27:57.885]                             if (is.null(version)) 
[08:27:57.885]                               version <- utils::packageVersion("future")
[08:27:57.885]                           }
[08:27:57.885]                           else {
[08:27:57.885]                             version <- NULL
[08:27:57.885]                           }
[08:27:57.885]                           if (!has_future || version < "1.8.0") {
[08:27:57.885]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.885]                               "", base::R.version$version.string), 
[08:27:57.885]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:57.885]                                 base::R.version$platform, 8 * 
[08:27:57.885]                                   base::.Machine$sizeof.pointer), 
[08:27:57.885]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.885]                                 "release", "version")], collapse = " "), 
[08:27:57.885]                               hostname = base::Sys.info()[["nodename"]])
[08:27:57.885]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.885]                               info)
[08:27:57.885]                             info <- base::paste(info, collapse = "; ")
[08:27:57.885]                             if (!has_future) {
[08:27:57.885]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.885]                                 info)
[08:27:57.885]                             }
[08:27:57.885]                             else {
[08:27:57.885]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.885]                                 info, version)
[08:27:57.885]                             }
[08:27:57.885]                             base::stop(msg)
[08:27:57.885]                           }
[08:27:57.885]                         })
[08:27:57.885]                       }
[08:27:57.885]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:57.885]                       base::options(mc.cores = 1L)
[08:27:57.885]                     }
[08:27:57.885]                     base::local({
[08:27:57.885]                       for (pkg in c("stats", "datasets")) {
[08:27:57.885]                         base::loadNamespace(pkg)
[08:27:57.885]                         base::library(pkg, character.only = TRUE)
[08:27:57.885]                       }
[08:27:57.885]                     })
[08:27:57.885]                   }
[08:27:57.885]                   ...future.strategy.old <- future::plan("list")
[08:27:57.885]                   options(future.plan = NULL)
[08:27:57.885]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.885]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.885]                 }
[08:27:57.885]                 ...future.workdir <- getwd()
[08:27:57.885]             }
[08:27:57.885]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.885]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.885]         }
[08:27:57.885]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.885]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.885]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.885]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.885]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.885]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.885]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.885]             base::names(...future.oldOptions))
[08:27:57.885]     }
[08:27:57.885]     if (FALSE) {
[08:27:57.885]     }
[08:27:57.885]     else {
[08:27:57.885]         if (TRUE) {
[08:27:57.885]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.885]                 open = "w")
[08:27:57.885]         }
[08:27:57.885]         else {
[08:27:57.885]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.885]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.885]         }
[08:27:57.885]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.885]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.885]             base::sink(type = "output", split = FALSE)
[08:27:57.885]             base::close(...future.stdout)
[08:27:57.885]         }, add = TRUE)
[08:27:57.885]     }
[08:27:57.885]     ...future.frame <- base::sys.nframe()
[08:27:57.885]     ...future.conditions <- base::list()
[08:27:57.885]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.885]     if (FALSE) {
[08:27:57.885]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.885]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.885]     }
[08:27:57.885]     ...future.result <- base::tryCatch({
[08:27:57.885]         base::withCallingHandlers({
[08:27:57.885]             ...future.value <- base::withVisible(base::local({
[08:27:57.885]                 withCallingHandlers({
[08:27:57.885]                   {
[08:27:57.885]                     lm(dist ~ . - 1, data = cars)
[08:27:57.885]                   }
[08:27:57.885]                 }, immediateCondition = function(cond) {
[08:27:57.885]                   save_rds <- function (object, pathname, ...) 
[08:27:57.885]                   {
[08:27:57.885]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:57.885]                     if (file_test("-f", pathname_tmp)) {
[08:27:57.885]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.885]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:57.885]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.885]                         fi_tmp[["mtime"]])
[08:27:57.885]                     }
[08:27:57.885]                     tryCatch({
[08:27:57.885]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:57.885]                     }, error = function(ex) {
[08:27:57.885]                       msg <- conditionMessage(ex)
[08:27:57.885]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.885]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:57.885]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.885]                         fi_tmp[["mtime"]], msg)
[08:27:57.885]                       ex$message <- msg
[08:27:57.885]                       stop(ex)
[08:27:57.885]                     })
[08:27:57.885]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:57.885]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:57.885]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:57.885]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.885]                       fi <- file.info(pathname)
[08:27:57.885]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:57.885]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.885]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:57.885]                         fi[["size"]], fi[["mtime"]])
[08:27:57.885]                       stop(msg)
[08:27:57.885]                     }
[08:27:57.885]                     invisible(pathname)
[08:27:57.885]                   }
[08:27:57.885]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:57.885]                     rootPath = tempdir()) 
[08:27:57.885]                   {
[08:27:57.885]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:57.885]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:57.885]                       tmpdir = path, fileext = ".rds")
[08:27:57.885]                     save_rds(obj, file)
[08:27:57.885]                   }
[08:27:57.885]                   saveImmediateCondition(cond, path = "/tmp/RtmpUQjont/.future/immediateConditions")
[08:27:57.885]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.885]                   {
[08:27:57.885]                     inherits <- base::inherits
[08:27:57.885]                     invokeRestart <- base::invokeRestart
[08:27:57.885]                     is.null <- base::is.null
[08:27:57.885]                     muffled <- FALSE
[08:27:57.885]                     if (inherits(cond, "message")) {
[08:27:57.885]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:57.885]                       if (muffled) 
[08:27:57.885]                         invokeRestart("muffleMessage")
[08:27:57.885]                     }
[08:27:57.885]                     else if (inherits(cond, "warning")) {
[08:27:57.885]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:57.885]                       if (muffled) 
[08:27:57.885]                         invokeRestart("muffleWarning")
[08:27:57.885]                     }
[08:27:57.885]                     else if (inherits(cond, "condition")) {
[08:27:57.885]                       if (!is.null(pattern)) {
[08:27:57.885]                         computeRestarts <- base::computeRestarts
[08:27:57.885]                         grepl <- base::grepl
[08:27:57.885]                         restarts <- computeRestarts(cond)
[08:27:57.885]                         for (restart in restarts) {
[08:27:57.885]                           name <- restart$name
[08:27:57.885]                           if (is.null(name)) 
[08:27:57.885]                             next
[08:27:57.885]                           if (!grepl(pattern, name)) 
[08:27:57.885]                             next
[08:27:57.885]                           invokeRestart(restart)
[08:27:57.885]                           muffled <- TRUE
[08:27:57.885]                           break
[08:27:57.885]                         }
[08:27:57.885]                       }
[08:27:57.885]                     }
[08:27:57.885]                     invisible(muffled)
[08:27:57.885]                   }
[08:27:57.885]                   muffleCondition(cond)
[08:27:57.885]                 })
[08:27:57.885]             }))
[08:27:57.885]             future::FutureResult(value = ...future.value$value, 
[08:27:57.885]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.885]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.885]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.885]                     ...future.globalenv.names))
[08:27:57.885]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.885]         }, condition = base::local({
[08:27:57.885]             c <- base::c
[08:27:57.885]             inherits <- base::inherits
[08:27:57.885]             invokeRestart <- base::invokeRestart
[08:27:57.885]             length <- base::length
[08:27:57.885]             list <- base::list
[08:27:57.885]             seq.int <- base::seq.int
[08:27:57.885]             signalCondition <- base::signalCondition
[08:27:57.885]             sys.calls <- base::sys.calls
[08:27:57.885]             `[[` <- base::`[[`
[08:27:57.885]             `+` <- base::`+`
[08:27:57.885]             `<<-` <- base::`<<-`
[08:27:57.885]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.885]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.885]                   3L)]
[08:27:57.885]             }
[08:27:57.885]             function(cond) {
[08:27:57.885]                 is_error <- inherits(cond, "error")
[08:27:57.885]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.885]                   NULL)
[08:27:57.885]                 if (is_error) {
[08:27:57.885]                   sessionInformation <- function() {
[08:27:57.885]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.885]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.885]                       search = base::search(), system = base::Sys.info())
[08:27:57.885]                   }
[08:27:57.885]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.885]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.885]                     cond$call), session = sessionInformation(), 
[08:27:57.885]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.885]                   signalCondition(cond)
[08:27:57.885]                 }
[08:27:57.885]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.885]                 "immediateCondition"))) {
[08:27:57.885]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.885]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.885]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.885]                   if (TRUE && !signal) {
[08:27:57.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.885]                     {
[08:27:57.885]                       inherits <- base::inherits
[08:27:57.885]                       invokeRestart <- base::invokeRestart
[08:27:57.885]                       is.null <- base::is.null
[08:27:57.885]                       muffled <- FALSE
[08:27:57.885]                       if (inherits(cond, "message")) {
[08:27:57.885]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.885]                         if (muffled) 
[08:27:57.885]                           invokeRestart("muffleMessage")
[08:27:57.885]                       }
[08:27:57.885]                       else if (inherits(cond, "warning")) {
[08:27:57.885]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.885]                         if (muffled) 
[08:27:57.885]                           invokeRestart("muffleWarning")
[08:27:57.885]                       }
[08:27:57.885]                       else if (inherits(cond, "condition")) {
[08:27:57.885]                         if (!is.null(pattern)) {
[08:27:57.885]                           computeRestarts <- base::computeRestarts
[08:27:57.885]                           grepl <- base::grepl
[08:27:57.885]                           restarts <- computeRestarts(cond)
[08:27:57.885]                           for (restart in restarts) {
[08:27:57.885]                             name <- restart$name
[08:27:57.885]                             if (is.null(name)) 
[08:27:57.885]                               next
[08:27:57.885]                             if (!grepl(pattern, name)) 
[08:27:57.885]                               next
[08:27:57.885]                             invokeRestart(restart)
[08:27:57.885]                             muffled <- TRUE
[08:27:57.885]                             break
[08:27:57.885]                           }
[08:27:57.885]                         }
[08:27:57.885]                       }
[08:27:57.885]                       invisible(muffled)
[08:27:57.885]                     }
[08:27:57.885]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.885]                   }
[08:27:57.885]                 }
[08:27:57.885]                 else {
[08:27:57.885]                   if (TRUE) {
[08:27:57.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.885]                     {
[08:27:57.885]                       inherits <- base::inherits
[08:27:57.885]                       invokeRestart <- base::invokeRestart
[08:27:57.885]                       is.null <- base::is.null
[08:27:57.885]                       muffled <- FALSE
[08:27:57.885]                       if (inherits(cond, "message")) {
[08:27:57.885]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.885]                         if (muffled) 
[08:27:57.885]                           invokeRestart("muffleMessage")
[08:27:57.885]                       }
[08:27:57.885]                       else if (inherits(cond, "warning")) {
[08:27:57.885]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.885]                         if (muffled) 
[08:27:57.885]                           invokeRestart("muffleWarning")
[08:27:57.885]                       }
[08:27:57.885]                       else if (inherits(cond, "condition")) {
[08:27:57.885]                         if (!is.null(pattern)) {
[08:27:57.885]                           computeRestarts <- base::computeRestarts
[08:27:57.885]                           grepl <- base::grepl
[08:27:57.885]                           restarts <- computeRestarts(cond)
[08:27:57.885]                           for (restart in restarts) {
[08:27:57.885]                             name <- restart$name
[08:27:57.885]                             if (is.null(name)) 
[08:27:57.885]                               next
[08:27:57.885]                             if (!grepl(pattern, name)) 
[08:27:57.885]                               next
[08:27:57.885]                             invokeRestart(restart)
[08:27:57.885]                             muffled <- TRUE
[08:27:57.885]                             break
[08:27:57.885]                           }
[08:27:57.885]                         }
[08:27:57.885]                       }
[08:27:57.885]                       invisible(muffled)
[08:27:57.885]                     }
[08:27:57.885]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.885]                   }
[08:27:57.885]                 }
[08:27:57.885]             }
[08:27:57.885]         }))
[08:27:57.885]     }, error = function(ex) {
[08:27:57.885]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.885]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.885]                 ...future.rng), started = ...future.startTime, 
[08:27:57.885]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.885]             version = "1.8"), class = "FutureResult")
[08:27:57.885]     }, finally = {
[08:27:57.885]         if (!identical(...future.workdir, getwd())) 
[08:27:57.885]             setwd(...future.workdir)
[08:27:57.885]         {
[08:27:57.885]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.885]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.885]             }
[08:27:57.885]             base::options(...future.oldOptions)
[08:27:57.885]             if (.Platform$OS.type == "windows") {
[08:27:57.885]                 old_names <- names(...future.oldEnvVars)
[08:27:57.885]                 envs <- base::Sys.getenv()
[08:27:57.885]                 names <- names(envs)
[08:27:57.885]                 common <- intersect(names, old_names)
[08:27:57.885]                 added <- setdiff(names, old_names)
[08:27:57.885]                 removed <- setdiff(old_names, names)
[08:27:57.885]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.885]                   envs[common]]
[08:27:57.885]                 NAMES <- toupper(changed)
[08:27:57.885]                 args <- list()
[08:27:57.885]                 for (kk in seq_along(NAMES)) {
[08:27:57.885]                   name <- changed[[kk]]
[08:27:57.885]                   NAME <- NAMES[[kk]]
[08:27:57.885]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.885]                     next
[08:27:57.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.885]                 }
[08:27:57.885]                 NAMES <- toupper(added)
[08:27:57.885]                 for (kk in seq_along(NAMES)) {
[08:27:57.885]                   name <- added[[kk]]
[08:27:57.885]                   NAME <- NAMES[[kk]]
[08:27:57.885]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.885]                     next
[08:27:57.885]                   args[[name]] <- ""
[08:27:57.885]                 }
[08:27:57.885]                 NAMES <- toupper(removed)
[08:27:57.885]                 for (kk in seq_along(NAMES)) {
[08:27:57.885]                   name <- removed[[kk]]
[08:27:57.885]                   NAME <- NAMES[[kk]]
[08:27:57.885]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.885]                     next
[08:27:57.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.885]                 }
[08:27:57.885]                 if (length(args) > 0) 
[08:27:57.885]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.885]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.885]             }
[08:27:57.885]             else {
[08:27:57.885]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.885]             }
[08:27:57.885]             {
[08:27:57.885]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.885]                   0L) {
[08:27:57.885]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.885]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.885]                   base::options(opts)
[08:27:57.885]                 }
[08:27:57.885]                 {
[08:27:57.885]                   {
[08:27:57.885]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:57.885]                     NULL
[08:27:57.885]                   }
[08:27:57.885]                   options(future.plan = NULL)
[08:27:57.885]                   if (is.na(NA_character_)) 
[08:27:57.885]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.885]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.885]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.885]                     .init = FALSE)
[08:27:57.885]                 }
[08:27:57.885]             }
[08:27:57.885]         }
[08:27:57.885]     })
[08:27:57.885]     if (TRUE) {
[08:27:57.885]         base::sink(type = "output", split = FALSE)
[08:27:57.885]         if (TRUE) {
[08:27:57.885]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.885]         }
[08:27:57.885]         else {
[08:27:57.885]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.885]         }
[08:27:57.885]         base::close(...future.stdout)
[08:27:57.885]         ...future.stdout <- NULL
[08:27:57.885]     }
[08:27:57.885]     ...future.result$conditions <- ...future.conditions
[08:27:57.885]     ...future.result$finished <- base::Sys.time()
[08:27:57.885]     ...future.result
[08:27:57.885] }
[08:27:57.888] requestCore(): workers = 2
[08:27:57.890] MulticoreFuture started
[08:27:57.890] - Launch lazy future ... done
[08:27:57.890] run() for ‘MulticoreFuture’ ... done
[08:27:57.891] result() for MulticoreFuture ...
[08:27:57.891] plan(): Setting new future strategy stack:
[08:27:57.891] List of future strategies:
[08:27:57.891] 1. sequential:
[08:27:57.891]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.891]    - tweaked: FALSE
[08:27:57.891]    - call: NULL
[08:27:57.892] plan(): nbrOfWorkers() = 1
[08:27:57.900] plan(): Setting new future strategy stack:
[08:27:57.900] List of future strategies:
[08:27:57.900] 1. multicore:
[08:27:57.900]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:57.900]    - tweaked: FALSE
[08:27:57.900]    - call: plan(strategy)
[08:27:57.904] plan(): nbrOfWorkers() = 2
[08:27:57.906] result() for MulticoreFuture ...
[08:27:57.906] result() for MulticoreFuture ... done
[08:27:57.906] result() for MulticoreFuture ... done
[08:27:57.906] result() for MulticoreFuture ...
[08:27:57.906] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[08:27:57.913] getGlobalsAndPackages() ...
[08:27:57.913] Searching for globals...
[08:27:57.915] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[08:27:57.915] Searching for globals ... DONE
[08:27:57.915] Resolving globals: FALSE
[08:27:57.916] 
[08:27:57.916] - packages: [2] ‘stats’, ‘datasets’
[08:27:57.916] getGlobalsAndPackages() ... DONE
[08:27:57.917] run() for ‘Future’ ...
[08:27:57.917] - state: ‘created’
[08:27:57.917] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:57.919] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:57.919] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:57.919]   - Field: ‘label’
[08:27:57.919]   - Field: ‘local’
[08:27:57.920]   - Field: ‘owner’
[08:27:57.920]   - Field: ‘envir’
[08:27:57.920]   - Field: ‘workers’
[08:27:57.920]   - Field: ‘packages’
[08:27:57.920]   - Field: ‘gc’
[08:27:57.920]   - Field: ‘job’
[08:27:57.920]   - Field: ‘conditions’
[08:27:57.920]   - Field: ‘expr’
[08:27:57.920]   - Field: ‘uuid’
[08:27:57.921]   - Field: ‘seed’
[08:27:57.921]   - Field: ‘version’
[08:27:57.921]   - Field: ‘result’
[08:27:57.921]   - Field: ‘asynchronous’
[08:27:57.921]   - Field: ‘calls’
[08:27:57.921]   - Field: ‘globals’
[08:27:57.921]   - Field: ‘stdout’
[08:27:57.921]   - Field: ‘earlySignal’
[08:27:57.921]   - Field: ‘lazy’
[08:27:57.921]   - Field: ‘state’
[08:27:57.922] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:57.922] - Launch lazy future ...
[08:27:57.922] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[08:27:57.922] Packages needed by future strategies (n = 0): <none>
[08:27:57.923] {
[08:27:57.923]     {
[08:27:57.923]         {
[08:27:57.923]             ...future.startTime <- base::Sys.time()
[08:27:57.923]             {
[08:27:57.923]                 {
[08:27:57.923]                   {
[08:27:57.923]                     {
[08:27:57.923]                       {
[08:27:57.923]                         base::local({
[08:27:57.923]                           has_future <- base::requireNamespace("future", 
[08:27:57.923]                             quietly = TRUE)
[08:27:57.923]                           if (has_future) {
[08:27:57.923]                             ns <- base::getNamespace("future")
[08:27:57.923]                             version <- ns[[".package"]][["version"]]
[08:27:57.923]                             if (is.null(version)) 
[08:27:57.923]                               version <- utils::packageVersion("future")
[08:27:57.923]                           }
[08:27:57.923]                           else {
[08:27:57.923]                             version <- NULL
[08:27:57.923]                           }
[08:27:57.923]                           if (!has_future || version < "1.8.0") {
[08:27:57.923]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.923]                               "", base::R.version$version.string), 
[08:27:57.923]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:57.923]                                 base::R.version$platform, 8 * 
[08:27:57.923]                                   base::.Machine$sizeof.pointer), 
[08:27:57.923]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.923]                                 "release", "version")], collapse = " "), 
[08:27:57.923]                               hostname = base::Sys.info()[["nodename"]])
[08:27:57.923]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.923]                               info)
[08:27:57.923]                             info <- base::paste(info, collapse = "; ")
[08:27:57.923]                             if (!has_future) {
[08:27:57.923]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.923]                                 info)
[08:27:57.923]                             }
[08:27:57.923]                             else {
[08:27:57.923]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.923]                                 info, version)
[08:27:57.923]                             }
[08:27:57.923]                             base::stop(msg)
[08:27:57.923]                           }
[08:27:57.923]                         })
[08:27:57.923]                       }
[08:27:57.923]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:57.923]                       base::options(mc.cores = 1L)
[08:27:57.923]                     }
[08:27:57.923]                     base::local({
[08:27:57.923]                       for (pkg in c("stats", "datasets")) {
[08:27:57.923]                         base::loadNamespace(pkg)
[08:27:57.923]                         base::library(pkg, character.only = TRUE)
[08:27:57.923]                       }
[08:27:57.923]                     })
[08:27:57.923]                   }
[08:27:57.923]                   ...future.strategy.old <- future::plan("list")
[08:27:57.923]                   options(future.plan = NULL)
[08:27:57.923]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.923]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.923]                 }
[08:27:57.923]                 ...future.workdir <- getwd()
[08:27:57.923]             }
[08:27:57.923]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.923]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.923]         }
[08:27:57.923]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.923]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.923]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.923]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.923]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.923]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.923]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.923]             base::names(...future.oldOptions))
[08:27:57.923]     }
[08:27:57.923]     if (FALSE) {
[08:27:57.923]     }
[08:27:57.923]     else {
[08:27:57.923]         if (TRUE) {
[08:27:57.923]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.923]                 open = "w")
[08:27:57.923]         }
[08:27:57.923]         else {
[08:27:57.923]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.923]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.923]         }
[08:27:57.923]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.923]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.923]             base::sink(type = "output", split = FALSE)
[08:27:57.923]             base::close(...future.stdout)
[08:27:57.923]         }, add = TRUE)
[08:27:57.923]     }
[08:27:57.923]     ...future.frame <- base::sys.nframe()
[08:27:57.923]     ...future.conditions <- base::list()
[08:27:57.923]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.923]     if (FALSE) {
[08:27:57.923]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.923]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.923]     }
[08:27:57.923]     ...future.result <- base::tryCatch({
[08:27:57.923]         base::withCallingHandlers({
[08:27:57.923]             ...future.value <- base::withVisible(base::local({
[08:27:57.923]                 withCallingHandlers({
[08:27:57.923]                   {
[08:27:57.923]                     lm(dist ~ . + 0, data = cars)
[08:27:57.923]                   }
[08:27:57.923]                 }, immediateCondition = function(cond) {
[08:27:57.923]                   save_rds <- function (object, pathname, ...) 
[08:27:57.923]                   {
[08:27:57.923]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:57.923]                     if (file_test("-f", pathname_tmp)) {
[08:27:57.923]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.923]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:57.923]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.923]                         fi_tmp[["mtime"]])
[08:27:57.923]                     }
[08:27:57.923]                     tryCatch({
[08:27:57.923]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:57.923]                     }, error = function(ex) {
[08:27:57.923]                       msg <- conditionMessage(ex)
[08:27:57.923]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.923]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:57.923]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.923]                         fi_tmp[["mtime"]], msg)
[08:27:57.923]                       ex$message <- msg
[08:27:57.923]                       stop(ex)
[08:27:57.923]                     })
[08:27:57.923]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:57.923]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:57.923]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:57.923]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.923]                       fi <- file.info(pathname)
[08:27:57.923]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:57.923]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.923]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:57.923]                         fi[["size"]], fi[["mtime"]])
[08:27:57.923]                       stop(msg)
[08:27:57.923]                     }
[08:27:57.923]                     invisible(pathname)
[08:27:57.923]                   }
[08:27:57.923]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:57.923]                     rootPath = tempdir()) 
[08:27:57.923]                   {
[08:27:57.923]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:57.923]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:57.923]                       tmpdir = path, fileext = ".rds")
[08:27:57.923]                     save_rds(obj, file)
[08:27:57.923]                   }
[08:27:57.923]                   saveImmediateCondition(cond, path = "/tmp/RtmpUQjont/.future/immediateConditions")
[08:27:57.923]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.923]                   {
[08:27:57.923]                     inherits <- base::inherits
[08:27:57.923]                     invokeRestart <- base::invokeRestart
[08:27:57.923]                     is.null <- base::is.null
[08:27:57.923]                     muffled <- FALSE
[08:27:57.923]                     if (inherits(cond, "message")) {
[08:27:57.923]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:57.923]                       if (muffled) 
[08:27:57.923]                         invokeRestart("muffleMessage")
[08:27:57.923]                     }
[08:27:57.923]                     else if (inherits(cond, "warning")) {
[08:27:57.923]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:57.923]                       if (muffled) 
[08:27:57.923]                         invokeRestart("muffleWarning")
[08:27:57.923]                     }
[08:27:57.923]                     else if (inherits(cond, "condition")) {
[08:27:57.923]                       if (!is.null(pattern)) {
[08:27:57.923]                         computeRestarts <- base::computeRestarts
[08:27:57.923]                         grepl <- base::grepl
[08:27:57.923]                         restarts <- computeRestarts(cond)
[08:27:57.923]                         for (restart in restarts) {
[08:27:57.923]                           name <- restart$name
[08:27:57.923]                           if (is.null(name)) 
[08:27:57.923]                             next
[08:27:57.923]                           if (!grepl(pattern, name)) 
[08:27:57.923]                             next
[08:27:57.923]                           invokeRestart(restart)
[08:27:57.923]                           muffled <- TRUE
[08:27:57.923]                           break
[08:27:57.923]                         }
[08:27:57.923]                       }
[08:27:57.923]                     }
[08:27:57.923]                     invisible(muffled)
[08:27:57.923]                   }
[08:27:57.923]                   muffleCondition(cond)
[08:27:57.923]                 })
[08:27:57.923]             }))
[08:27:57.923]             future::FutureResult(value = ...future.value$value, 
[08:27:57.923]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.923]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.923]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.923]                     ...future.globalenv.names))
[08:27:57.923]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.923]         }, condition = base::local({
[08:27:57.923]             c <- base::c
[08:27:57.923]             inherits <- base::inherits
[08:27:57.923]             invokeRestart <- base::invokeRestart
[08:27:57.923]             length <- base::length
[08:27:57.923]             list <- base::list
[08:27:57.923]             seq.int <- base::seq.int
[08:27:57.923]             signalCondition <- base::signalCondition
[08:27:57.923]             sys.calls <- base::sys.calls
[08:27:57.923]             `[[` <- base::`[[`
[08:27:57.923]             `+` <- base::`+`
[08:27:57.923]             `<<-` <- base::`<<-`
[08:27:57.923]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.923]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.923]                   3L)]
[08:27:57.923]             }
[08:27:57.923]             function(cond) {
[08:27:57.923]                 is_error <- inherits(cond, "error")
[08:27:57.923]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.923]                   NULL)
[08:27:57.923]                 if (is_error) {
[08:27:57.923]                   sessionInformation <- function() {
[08:27:57.923]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.923]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.923]                       search = base::search(), system = base::Sys.info())
[08:27:57.923]                   }
[08:27:57.923]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.923]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.923]                     cond$call), session = sessionInformation(), 
[08:27:57.923]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.923]                   signalCondition(cond)
[08:27:57.923]                 }
[08:27:57.923]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.923]                 "immediateCondition"))) {
[08:27:57.923]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.923]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.923]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.923]                   if (TRUE && !signal) {
[08:27:57.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.923]                     {
[08:27:57.923]                       inherits <- base::inherits
[08:27:57.923]                       invokeRestart <- base::invokeRestart
[08:27:57.923]                       is.null <- base::is.null
[08:27:57.923]                       muffled <- FALSE
[08:27:57.923]                       if (inherits(cond, "message")) {
[08:27:57.923]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.923]                         if (muffled) 
[08:27:57.923]                           invokeRestart("muffleMessage")
[08:27:57.923]                       }
[08:27:57.923]                       else if (inherits(cond, "warning")) {
[08:27:57.923]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.923]                         if (muffled) 
[08:27:57.923]                           invokeRestart("muffleWarning")
[08:27:57.923]                       }
[08:27:57.923]                       else if (inherits(cond, "condition")) {
[08:27:57.923]                         if (!is.null(pattern)) {
[08:27:57.923]                           computeRestarts <- base::computeRestarts
[08:27:57.923]                           grepl <- base::grepl
[08:27:57.923]                           restarts <- computeRestarts(cond)
[08:27:57.923]                           for (restart in restarts) {
[08:27:57.923]                             name <- restart$name
[08:27:57.923]                             if (is.null(name)) 
[08:27:57.923]                               next
[08:27:57.923]                             if (!grepl(pattern, name)) 
[08:27:57.923]                               next
[08:27:57.923]                             invokeRestart(restart)
[08:27:57.923]                             muffled <- TRUE
[08:27:57.923]                             break
[08:27:57.923]                           }
[08:27:57.923]                         }
[08:27:57.923]                       }
[08:27:57.923]                       invisible(muffled)
[08:27:57.923]                     }
[08:27:57.923]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.923]                   }
[08:27:57.923]                 }
[08:27:57.923]                 else {
[08:27:57.923]                   if (TRUE) {
[08:27:57.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.923]                     {
[08:27:57.923]                       inherits <- base::inherits
[08:27:57.923]                       invokeRestart <- base::invokeRestart
[08:27:57.923]                       is.null <- base::is.null
[08:27:57.923]                       muffled <- FALSE
[08:27:57.923]                       if (inherits(cond, "message")) {
[08:27:57.923]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.923]                         if (muffled) 
[08:27:57.923]                           invokeRestart("muffleMessage")
[08:27:57.923]                       }
[08:27:57.923]                       else if (inherits(cond, "warning")) {
[08:27:57.923]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.923]                         if (muffled) 
[08:27:57.923]                           invokeRestart("muffleWarning")
[08:27:57.923]                       }
[08:27:57.923]                       else if (inherits(cond, "condition")) {
[08:27:57.923]                         if (!is.null(pattern)) {
[08:27:57.923]                           computeRestarts <- base::computeRestarts
[08:27:57.923]                           grepl <- base::grepl
[08:27:57.923]                           restarts <- computeRestarts(cond)
[08:27:57.923]                           for (restart in restarts) {
[08:27:57.923]                             name <- restart$name
[08:27:57.923]                             if (is.null(name)) 
[08:27:57.923]                               next
[08:27:57.923]                             if (!grepl(pattern, name)) 
[08:27:57.923]                               next
[08:27:57.923]                             invokeRestart(restart)
[08:27:57.923]                             muffled <- TRUE
[08:27:57.923]                             break
[08:27:57.923]                           }
[08:27:57.923]                         }
[08:27:57.923]                       }
[08:27:57.923]                       invisible(muffled)
[08:27:57.923]                     }
[08:27:57.923]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.923]                   }
[08:27:57.923]                 }
[08:27:57.923]             }
[08:27:57.923]         }))
[08:27:57.923]     }, error = function(ex) {
[08:27:57.923]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.923]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.923]                 ...future.rng), started = ...future.startTime, 
[08:27:57.923]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.923]             version = "1.8"), class = "FutureResult")
[08:27:57.923]     }, finally = {
[08:27:57.923]         if (!identical(...future.workdir, getwd())) 
[08:27:57.923]             setwd(...future.workdir)
[08:27:57.923]         {
[08:27:57.923]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.923]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.923]             }
[08:27:57.923]             base::options(...future.oldOptions)
[08:27:57.923]             if (.Platform$OS.type == "windows") {
[08:27:57.923]                 old_names <- names(...future.oldEnvVars)
[08:27:57.923]                 envs <- base::Sys.getenv()
[08:27:57.923]                 names <- names(envs)
[08:27:57.923]                 common <- intersect(names, old_names)
[08:27:57.923]                 added <- setdiff(names, old_names)
[08:27:57.923]                 removed <- setdiff(old_names, names)
[08:27:57.923]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.923]                   envs[common]]
[08:27:57.923]                 NAMES <- toupper(changed)
[08:27:57.923]                 args <- list()
[08:27:57.923]                 for (kk in seq_along(NAMES)) {
[08:27:57.923]                   name <- changed[[kk]]
[08:27:57.923]                   NAME <- NAMES[[kk]]
[08:27:57.923]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.923]                     next
[08:27:57.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.923]                 }
[08:27:57.923]                 NAMES <- toupper(added)
[08:27:57.923]                 for (kk in seq_along(NAMES)) {
[08:27:57.923]                   name <- added[[kk]]
[08:27:57.923]                   NAME <- NAMES[[kk]]
[08:27:57.923]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.923]                     next
[08:27:57.923]                   args[[name]] <- ""
[08:27:57.923]                 }
[08:27:57.923]                 NAMES <- toupper(removed)
[08:27:57.923]                 for (kk in seq_along(NAMES)) {
[08:27:57.923]                   name <- removed[[kk]]
[08:27:57.923]                   NAME <- NAMES[[kk]]
[08:27:57.923]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.923]                     next
[08:27:57.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.923]                 }
[08:27:57.923]                 if (length(args) > 0) 
[08:27:57.923]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.923]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.923]             }
[08:27:57.923]             else {
[08:27:57.923]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.923]             }
[08:27:57.923]             {
[08:27:57.923]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.923]                   0L) {
[08:27:57.923]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.923]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.923]                   base::options(opts)
[08:27:57.923]                 }
[08:27:57.923]                 {
[08:27:57.923]                   {
[08:27:57.923]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:57.923]                     NULL
[08:27:57.923]                   }
[08:27:57.923]                   options(future.plan = NULL)
[08:27:57.923]                   if (is.na(NA_character_)) 
[08:27:57.923]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.923]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.923]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.923]                     .init = FALSE)
[08:27:57.923]                 }
[08:27:57.923]             }
[08:27:57.923]         }
[08:27:57.923]     })
[08:27:57.923]     if (TRUE) {
[08:27:57.923]         base::sink(type = "output", split = FALSE)
[08:27:57.923]         if (TRUE) {
[08:27:57.923]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.923]         }
[08:27:57.923]         else {
[08:27:57.923]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.923]         }
[08:27:57.923]         base::close(...future.stdout)
[08:27:57.923]         ...future.stdout <- NULL
[08:27:57.923]     }
[08:27:57.923]     ...future.result$conditions <- ...future.conditions
[08:27:57.923]     ...future.result$finished <- base::Sys.time()
[08:27:57.923]     ...future.result
[08:27:57.923] }
[08:27:57.925] requestCore(): workers = 2
[08:27:57.928] MulticoreFuture started
[08:27:57.928] - Launch lazy future ... done
[08:27:57.928] run() for ‘MulticoreFuture’ ... done
[08:27:57.928] result() for MulticoreFuture ...
[08:27:57.929] plan(): Setting new future strategy stack:
[08:27:57.929] List of future strategies:
[08:27:57.929] 1. sequential:
[08:27:57.929]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.929]    - tweaked: FALSE
[08:27:57.929]    - call: NULL
[08:27:57.930] plan(): nbrOfWorkers() = 1
[08:27:57.934] plan(): Setting new future strategy stack:
[08:27:57.934] List of future strategies:
[08:27:57.934] 1. multicore:
[08:27:57.934]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:57.934]    - tweaked: FALSE
[08:27:57.934]    - call: plan(strategy)
[08:27:57.937] plan(): nbrOfWorkers() = 2
[08:27:57.939] result() for MulticoreFuture ...
[08:27:57.940] result() for MulticoreFuture ... done
[08:27:57.940] result() for MulticoreFuture ... done
[08:27:57.940] result() for MulticoreFuture ...
[08:27:57.940] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[08:27:57.943] getGlobalsAndPackages() ...
[08:27:57.943] Searching for globals...
[08:27:57.946] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[08:27:57.946] Searching for globals ... DONE
[08:27:57.946] Resolving globals: FALSE
[08:27:57.947] 
[08:27:57.947] - packages: [2] ‘stats’, ‘datasets’
[08:27:57.947] getGlobalsAndPackages() ... DONE
[08:27:57.947] run() for ‘Future’ ...
[08:27:57.948] - state: ‘created’
[08:27:57.985] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:57.987] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:57.987] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:57.987]   - Field: ‘label’
[08:27:57.988]   - Field: ‘local’
[08:27:57.988]   - Field: ‘owner’
[08:27:57.988]   - Field: ‘envir’
[08:27:57.988]   - Field: ‘workers’
[08:27:57.988]   - Field: ‘packages’
[08:27:57.988]   - Field: ‘gc’
[08:27:57.988]   - Field: ‘job’
[08:27:57.988]   - Field: ‘conditions’
[08:27:57.988]   - Field: ‘expr’
[08:27:57.988]   - Field: ‘uuid’
[08:27:57.989]   - Field: ‘seed’
[08:27:57.989]   - Field: ‘version’
[08:27:57.989]   - Field: ‘result’
[08:27:57.989]   - Field: ‘asynchronous’
[08:27:57.989]   - Field: ‘calls’
[08:27:57.989]   - Field: ‘globals’
[08:27:57.989]   - Field: ‘stdout’
[08:27:57.989]   - Field: ‘earlySignal’
[08:27:57.989]   - Field: ‘lazy’
[08:27:57.989]   - Field: ‘state’
[08:27:57.989] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:57.990] - Launch lazy future ...
[08:27:57.990] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[08:27:57.990] Packages needed by future strategies (n = 0): <none>
[08:27:57.990] {
[08:27:57.990]     {
[08:27:57.990]         {
[08:27:57.990]             ...future.startTime <- base::Sys.time()
[08:27:57.990]             {
[08:27:57.990]                 {
[08:27:57.990]                   {
[08:27:57.990]                     {
[08:27:57.990]                       {
[08:27:57.990]                         base::local({
[08:27:57.990]                           has_future <- base::requireNamespace("future", 
[08:27:57.990]                             quietly = TRUE)
[08:27:57.990]                           if (has_future) {
[08:27:57.990]                             ns <- base::getNamespace("future")
[08:27:57.990]                             version <- ns[[".package"]][["version"]]
[08:27:57.990]                             if (is.null(version)) 
[08:27:57.990]                               version <- utils::packageVersion("future")
[08:27:57.990]                           }
[08:27:57.990]                           else {
[08:27:57.990]                             version <- NULL
[08:27:57.990]                           }
[08:27:57.990]                           if (!has_future || version < "1.8.0") {
[08:27:57.990]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:57.990]                               "", base::R.version$version.string), 
[08:27:57.990]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:57.990]                                 base::R.version$platform, 8 * 
[08:27:57.990]                                   base::.Machine$sizeof.pointer), 
[08:27:57.990]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:57.990]                                 "release", "version")], collapse = " "), 
[08:27:57.990]                               hostname = base::Sys.info()[["nodename"]])
[08:27:57.990]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:57.990]                               info)
[08:27:57.990]                             info <- base::paste(info, collapse = "; ")
[08:27:57.990]                             if (!has_future) {
[08:27:57.990]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:57.990]                                 info)
[08:27:57.990]                             }
[08:27:57.990]                             else {
[08:27:57.990]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:57.990]                                 info, version)
[08:27:57.990]                             }
[08:27:57.990]                             base::stop(msg)
[08:27:57.990]                           }
[08:27:57.990]                         })
[08:27:57.990]                       }
[08:27:57.990]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:57.990]                       base::options(mc.cores = 1L)
[08:27:57.990]                     }
[08:27:57.990]                     base::local({
[08:27:57.990]                       for (pkg in c("stats", "datasets")) {
[08:27:57.990]                         base::loadNamespace(pkg)
[08:27:57.990]                         base::library(pkg, character.only = TRUE)
[08:27:57.990]                       }
[08:27:57.990]                     })
[08:27:57.990]                   }
[08:27:57.990]                   ...future.strategy.old <- future::plan("list")
[08:27:57.990]                   options(future.plan = NULL)
[08:27:57.990]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.990]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:57.990]                 }
[08:27:57.990]                 ...future.workdir <- getwd()
[08:27:57.990]             }
[08:27:57.990]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:57.990]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:57.990]         }
[08:27:57.990]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:57.990]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:57.990]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:57.990]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:57.990]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:57.990]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:57.990]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:57.990]             base::names(...future.oldOptions))
[08:27:57.990]     }
[08:27:57.990]     if (FALSE) {
[08:27:57.990]     }
[08:27:57.990]     else {
[08:27:57.990]         if (TRUE) {
[08:27:57.990]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:57.990]                 open = "w")
[08:27:57.990]         }
[08:27:57.990]         else {
[08:27:57.990]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:57.990]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:57.990]         }
[08:27:57.990]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:57.990]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:57.990]             base::sink(type = "output", split = FALSE)
[08:27:57.990]             base::close(...future.stdout)
[08:27:57.990]         }, add = TRUE)
[08:27:57.990]     }
[08:27:57.990]     ...future.frame <- base::sys.nframe()
[08:27:57.990]     ...future.conditions <- base::list()
[08:27:57.990]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:57.990]     if (FALSE) {
[08:27:57.990]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:57.990]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:57.990]     }
[08:27:57.990]     ...future.result <- base::tryCatch({
[08:27:57.990]         base::withCallingHandlers({
[08:27:57.990]             ...future.value <- base::withVisible(base::local({
[08:27:57.990]                 withCallingHandlers({
[08:27:57.990]                   {
[08:27:57.990]                     lm(dist ~ speed + speed^2, data = cars)
[08:27:57.990]                   }
[08:27:57.990]                 }, immediateCondition = function(cond) {
[08:27:57.990]                   save_rds <- function (object, pathname, ...) 
[08:27:57.990]                   {
[08:27:57.990]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:57.990]                     if (file_test("-f", pathname_tmp)) {
[08:27:57.990]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.990]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:57.990]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.990]                         fi_tmp[["mtime"]])
[08:27:57.990]                     }
[08:27:57.990]                     tryCatch({
[08:27:57.990]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:57.990]                     }, error = function(ex) {
[08:27:57.990]                       msg <- conditionMessage(ex)
[08:27:57.990]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.990]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:57.990]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.990]                         fi_tmp[["mtime"]], msg)
[08:27:57.990]                       ex$message <- msg
[08:27:57.990]                       stop(ex)
[08:27:57.990]                     })
[08:27:57.990]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:57.990]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:57.990]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:57.990]                       fi_tmp <- file.info(pathname_tmp)
[08:27:57.990]                       fi <- file.info(pathname)
[08:27:57.990]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:57.990]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:57.990]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:57.990]                         fi[["size"]], fi[["mtime"]])
[08:27:57.990]                       stop(msg)
[08:27:57.990]                     }
[08:27:57.990]                     invisible(pathname)
[08:27:57.990]                   }
[08:27:57.990]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:57.990]                     rootPath = tempdir()) 
[08:27:57.990]                   {
[08:27:57.990]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:57.990]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:57.990]                       tmpdir = path, fileext = ".rds")
[08:27:57.990]                     save_rds(obj, file)
[08:27:57.990]                   }
[08:27:57.990]                   saveImmediateCondition(cond, path = "/tmp/RtmpUQjont/.future/immediateConditions")
[08:27:57.990]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.990]                   {
[08:27:57.990]                     inherits <- base::inherits
[08:27:57.990]                     invokeRestart <- base::invokeRestart
[08:27:57.990]                     is.null <- base::is.null
[08:27:57.990]                     muffled <- FALSE
[08:27:57.990]                     if (inherits(cond, "message")) {
[08:27:57.990]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:57.990]                       if (muffled) 
[08:27:57.990]                         invokeRestart("muffleMessage")
[08:27:57.990]                     }
[08:27:57.990]                     else if (inherits(cond, "warning")) {
[08:27:57.990]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:57.990]                       if (muffled) 
[08:27:57.990]                         invokeRestart("muffleWarning")
[08:27:57.990]                     }
[08:27:57.990]                     else if (inherits(cond, "condition")) {
[08:27:57.990]                       if (!is.null(pattern)) {
[08:27:57.990]                         computeRestarts <- base::computeRestarts
[08:27:57.990]                         grepl <- base::grepl
[08:27:57.990]                         restarts <- computeRestarts(cond)
[08:27:57.990]                         for (restart in restarts) {
[08:27:57.990]                           name <- restart$name
[08:27:57.990]                           if (is.null(name)) 
[08:27:57.990]                             next
[08:27:57.990]                           if (!grepl(pattern, name)) 
[08:27:57.990]                             next
[08:27:57.990]                           invokeRestart(restart)
[08:27:57.990]                           muffled <- TRUE
[08:27:57.990]                           break
[08:27:57.990]                         }
[08:27:57.990]                       }
[08:27:57.990]                     }
[08:27:57.990]                     invisible(muffled)
[08:27:57.990]                   }
[08:27:57.990]                   muffleCondition(cond)
[08:27:57.990]                 })
[08:27:57.990]             }))
[08:27:57.990]             future::FutureResult(value = ...future.value$value, 
[08:27:57.990]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.990]                   ...future.rng), globalenv = if (FALSE) 
[08:27:57.990]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:57.990]                     ...future.globalenv.names))
[08:27:57.990]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:57.990]         }, condition = base::local({
[08:27:57.990]             c <- base::c
[08:27:57.990]             inherits <- base::inherits
[08:27:57.990]             invokeRestart <- base::invokeRestart
[08:27:57.990]             length <- base::length
[08:27:57.990]             list <- base::list
[08:27:57.990]             seq.int <- base::seq.int
[08:27:57.990]             signalCondition <- base::signalCondition
[08:27:57.990]             sys.calls <- base::sys.calls
[08:27:57.990]             `[[` <- base::`[[`
[08:27:57.990]             `+` <- base::`+`
[08:27:57.990]             `<<-` <- base::`<<-`
[08:27:57.990]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:57.990]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:57.990]                   3L)]
[08:27:57.990]             }
[08:27:57.990]             function(cond) {
[08:27:57.990]                 is_error <- inherits(cond, "error")
[08:27:57.990]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:57.990]                   NULL)
[08:27:57.990]                 if (is_error) {
[08:27:57.990]                   sessionInformation <- function() {
[08:27:57.990]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:57.990]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:57.990]                       search = base::search(), system = base::Sys.info())
[08:27:57.990]                   }
[08:27:57.990]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.990]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:57.990]                     cond$call), session = sessionInformation(), 
[08:27:57.990]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:57.990]                   signalCondition(cond)
[08:27:57.990]                 }
[08:27:57.990]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:57.990]                 "immediateCondition"))) {
[08:27:57.990]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:57.990]                   ...future.conditions[[length(...future.conditions) + 
[08:27:57.990]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:57.990]                   if (TRUE && !signal) {
[08:27:57.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.990]                     {
[08:27:57.990]                       inherits <- base::inherits
[08:27:57.990]                       invokeRestart <- base::invokeRestart
[08:27:57.990]                       is.null <- base::is.null
[08:27:57.990]                       muffled <- FALSE
[08:27:57.990]                       if (inherits(cond, "message")) {
[08:27:57.990]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.990]                         if (muffled) 
[08:27:57.990]                           invokeRestart("muffleMessage")
[08:27:57.990]                       }
[08:27:57.990]                       else if (inherits(cond, "warning")) {
[08:27:57.990]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.990]                         if (muffled) 
[08:27:57.990]                           invokeRestart("muffleWarning")
[08:27:57.990]                       }
[08:27:57.990]                       else if (inherits(cond, "condition")) {
[08:27:57.990]                         if (!is.null(pattern)) {
[08:27:57.990]                           computeRestarts <- base::computeRestarts
[08:27:57.990]                           grepl <- base::grepl
[08:27:57.990]                           restarts <- computeRestarts(cond)
[08:27:57.990]                           for (restart in restarts) {
[08:27:57.990]                             name <- restart$name
[08:27:57.990]                             if (is.null(name)) 
[08:27:57.990]                               next
[08:27:57.990]                             if (!grepl(pattern, name)) 
[08:27:57.990]                               next
[08:27:57.990]                             invokeRestart(restart)
[08:27:57.990]                             muffled <- TRUE
[08:27:57.990]                             break
[08:27:57.990]                           }
[08:27:57.990]                         }
[08:27:57.990]                       }
[08:27:57.990]                       invisible(muffled)
[08:27:57.990]                     }
[08:27:57.990]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.990]                   }
[08:27:57.990]                 }
[08:27:57.990]                 else {
[08:27:57.990]                   if (TRUE) {
[08:27:57.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:57.990]                     {
[08:27:57.990]                       inherits <- base::inherits
[08:27:57.990]                       invokeRestart <- base::invokeRestart
[08:27:57.990]                       is.null <- base::is.null
[08:27:57.990]                       muffled <- FALSE
[08:27:57.990]                       if (inherits(cond, "message")) {
[08:27:57.990]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:57.990]                         if (muffled) 
[08:27:57.990]                           invokeRestart("muffleMessage")
[08:27:57.990]                       }
[08:27:57.990]                       else if (inherits(cond, "warning")) {
[08:27:57.990]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:57.990]                         if (muffled) 
[08:27:57.990]                           invokeRestart("muffleWarning")
[08:27:57.990]                       }
[08:27:57.990]                       else if (inherits(cond, "condition")) {
[08:27:57.990]                         if (!is.null(pattern)) {
[08:27:57.990]                           computeRestarts <- base::computeRestarts
[08:27:57.990]                           grepl <- base::grepl
[08:27:57.990]                           restarts <- computeRestarts(cond)
[08:27:57.990]                           for (restart in restarts) {
[08:27:57.990]                             name <- restart$name
[08:27:57.990]                             if (is.null(name)) 
[08:27:57.990]                               next
[08:27:57.990]                             if (!grepl(pattern, name)) 
[08:27:57.990]                               next
[08:27:57.990]                             invokeRestart(restart)
[08:27:57.990]                             muffled <- TRUE
[08:27:57.990]                             break
[08:27:57.990]                           }
[08:27:57.990]                         }
[08:27:57.990]                       }
[08:27:57.990]                       invisible(muffled)
[08:27:57.990]                     }
[08:27:57.990]                     muffleCondition(cond, pattern = "^muffle")
[08:27:57.990]                   }
[08:27:57.990]                 }
[08:27:57.990]             }
[08:27:57.990]         }))
[08:27:57.990]     }, error = function(ex) {
[08:27:57.990]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:57.990]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:57.990]                 ...future.rng), started = ...future.startTime, 
[08:27:57.990]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:57.990]             version = "1.8"), class = "FutureResult")
[08:27:57.990]     }, finally = {
[08:27:57.990]         if (!identical(...future.workdir, getwd())) 
[08:27:57.990]             setwd(...future.workdir)
[08:27:57.990]         {
[08:27:57.990]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:57.990]                 ...future.oldOptions$nwarnings <- NULL
[08:27:57.990]             }
[08:27:57.990]             base::options(...future.oldOptions)
[08:27:57.990]             if (.Platform$OS.type == "windows") {
[08:27:57.990]                 old_names <- names(...future.oldEnvVars)
[08:27:57.990]                 envs <- base::Sys.getenv()
[08:27:57.990]                 names <- names(envs)
[08:27:57.990]                 common <- intersect(names, old_names)
[08:27:57.990]                 added <- setdiff(names, old_names)
[08:27:57.990]                 removed <- setdiff(old_names, names)
[08:27:57.990]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:57.990]                   envs[common]]
[08:27:57.990]                 NAMES <- toupper(changed)
[08:27:57.990]                 args <- list()
[08:27:57.990]                 for (kk in seq_along(NAMES)) {
[08:27:57.990]                   name <- changed[[kk]]
[08:27:57.990]                   NAME <- NAMES[[kk]]
[08:27:57.990]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.990]                     next
[08:27:57.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.990]                 }
[08:27:57.990]                 NAMES <- toupper(added)
[08:27:57.990]                 for (kk in seq_along(NAMES)) {
[08:27:57.990]                   name <- added[[kk]]
[08:27:57.990]                   NAME <- NAMES[[kk]]
[08:27:57.990]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.990]                     next
[08:27:57.990]                   args[[name]] <- ""
[08:27:57.990]                 }
[08:27:57.990]                 NAMES <- toupper(removed)
[08:27:57.990]                 for (kk in seq_along(NAMES)) {
[08:27:57.990]                   name <- removed[[kk]]
[08:27:57.990]                   NAME <- NAMES[[kk]]
[08:27:57.990]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:57.990]                     next
[08:27:57.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:57.990]                 }
[08:27:57.990]                 if (length(args) > 0) 
[08:27:57.990]                   base::do.call(base::Sys.setenv, args = args)
[08:27:57.990]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:57.990]             }
[08:27:57.990]             else {
[08:27:57.990]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:57.990]             }
[08:27:57.990]             {
[08:27:57.990]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:57.990]                   0L) {
[08:27:57.990]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:57.990]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:57.990]                   base::options(opts)
[08:27:57.990]                 }
[08:27:57.990]                 {
[08:27:57.990]                   {
[08:27:57.990]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:57.990]                     NULL
[08:27:57.990]                   }
[08:27:57.990]                   options(future.plan = NULL)
[08:27:57.990]                   if (is.na(NA_character_)) 
[08:27:57.990]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:57.990]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:57.990]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:57.990]                     .init = FALSE)
[08:27:57.990]                 }
[08:27:57.990]             }
[08:27:57.990]         }
[08:27:57.990]     })
[08:27:57.990]     if (TRUE) {
[08:27:57.990]         base::sink(type = "output", split = FALSE)
[08:27:57.990]         if (TRUE) {
[08:27:57.990]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:57.990]         }
[08:27:57.990]         else {
[08:27:57.990]             ...future.result["stdout"] <- base::list(NULL)
[08:27:57.990]         }
[08:27:57.990]         base::close(...future.stdout)
[08:27:57.990]         ...future.stdout <- NULL
[08:27:57.990]     }
[08:27:57.990]     ...future.result$conditions <- ...future.conditions
[08:27:57.990]     ...future.result$finished <- base::Sys.time()
[08:27:57.990]     ...future.result
[08:27:57.990] }
[08:27:57.993] requestCore(): workers = 2
[08:27:57.995] MulticoreFuture started
[08:27:57.995] - Launch lazy future ... done
[08:27:57.996] run() for ‘MulticoreFuture’ ... done
[08:27:57.996] result() for MulticoreFuture ...
[08:27:57.997] plan(): Setting new future strategy stack:
[08:27:57.997] List of future strategies:
[08:27:57.997] 1. sequential:
[08:27:57.997]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:57.997]    - tweaked: FALSE
[08:27:57.997]    - call: NULL
[08:27:57.998] plan(): nbrOfWorkers() = 1
[08:27:58.002] plan(): Setting new future strategy stack:
[08:27:58.002] List of future strategies:
[08:27:58.002] 1. multicore:
[08:27:58.002]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:58.002]    - tweaked: FALSE
[08:27:58.002]    - call: plan(strategy)
[08:27:58.005] plan(): nbrOfWorkers() = 2
[08:27:58.008] result() for MulticoreFuture ...
[08:27:58.008] result() for MulticoreFuture ... done
[08:27:58.008] result() for MulticoreFuture ... done
[08:27:58.008] result() for MulticoreFuture ...
[08:27:58.008] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[08:27:58.012] getGlobalsAndPackages() ...
[08:27:58.012] Searching for globals...
[08:27:58.015] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[08:27:58.015] Searching for globals ... DONE
[08:27:58.015] Resolving globals: FALSE
[08:27:58.016] 
[08:27:58.016] - packages: [2] ‘stats’, ‘datasets’
[08:27:58.016] getGlobalsAndPackages() ... DONE
[08:27:58.016] run() for ‘Future’ ...
[08:27:58.016] - state: ‘created’
[08:27:58.017] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:58.019] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:58.019] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:58.019]   - Field: ‘label’
[08:27:58.019]   - Field: ‘local’
[08:27:58.019]   - Field: ‘owner’
[08:27:58.019]   - Field: ‘envir’
[08:27:58.019]   - Field: ‘workers’
[08:27:58.020]   - Field: ‘packages’
[08:27:58.020]   - Field: ‘gc’
[08:27:58.020]   - Field: ‘job’
[08:27:58.020]   - Field: ‘conditions’
[08:27:58.020]   - Field: ‘expr’
[08:27:58.020]   - Field: ‘uuid’
[08:27:58.020]   - Field: ‘seed’
[08:27:58.020]   - Field: ‘version’
[08:27:58.020]   - Field: ‘result’
[08:27:58.021]   - Field: ‘asynchronous’
[08:27:58.021]   - Field: ‘calls’
[08:27:58.021]   - Field: ‘globals’
[08:27:58.021]   - Field: ‘stdout’
[08:27:58.021]   - Field: ‘earlySignal’
[08:27:58.021]   - Field: ‘lazy’
[08:27:58.021]   - Field: ‘state’
[08:27:58.021] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:58.022] - Launch lazy future ...
[08:27:58.022] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[08:27:58.022] Packages needed by future strategies (n = 0): <none>
[08:27:58.023] {
[08:27:58.023]     {
[08:27:58.023]         {
[08:27:58.023]             ...future.startTime <- base::Sys.time()
[08:27:58.023]             {
[08:27:58.023]                 {
[08:27:58.023]                   {
[08:27:58.023]                     {
[08:27:58.023]                       {
[08:27:58.023]                         base::local({
[08:27:58.023]                           has_future <- base::requireNamespace("future", 
[08:27:58.023]                             quietly = TRUE)
[08:27:58.023]                           if (has_future) {
[08:27:58.023]                             ns <- base::getNamespace("future")
[08:27:58.023]                             version <- ns[[".package"]][["version"]]
[08:27:58.023]                             if (is.null(version)) 
[08:27:58.023]                               version <- utils::packageVersion("future")
[08:27:58.023]                           }
[08:27:58.023]                           else {
[08:27:58.023]                             version <- NULL
[08:27:58.023]                           }
[08:27:58.023]                           if (!has_future || version < "1.8.0") {
[08:27:58.023]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:58.023]                               "", base::R.version$version.string), 
[08:27:58.023]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:58.023]                                 base::R.version$platform, 8 * 
[08:27:58.023]                                   base::.Machine$sizeof.pointer), 
[08:27:58.023]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:58.023]                                 "release", "version")], collapse = " "), 
[08:27:58.023]                               hostname = base::Sys.info()[["nodename"]])
[08:27:58.023]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:58.023]                               info)
[08:27:58.023]                             info <- base::paste(info, collapse = "; ")
[08:27:58.023]                             if (!has_future) {
[08:27:58.023]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:58.023]                                 info)
[08:27:58.023]                             }
[08:27:58.023]                             else {
[08:27:58.023]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:58.023]                                 info, version)
[08:27:58.023]                             }
[08:27:58.023]                             base::stop(msg)
[08:27:58.023]                           }
[08:27:58.023]                         })
[08:27:58.023]                       }
[08:27:58.023]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:58.023]                       base::options(mc.cores = 1L)
[08:27:58.023]                     }
[08:27:58.023]                     base::local({
[08:27:58.023]                       for (pkg in c("stats", "datasets")) {
[08:27:58.023]                         base::loadNamespace(pkg)
[08:27:58.023]                         base::library(pkg, character.only = TRUE)
[08:27:58.023]                       }
[08:27:58.023]                     })
[08:27:58.023]                   }
[08:27:58.023]                   ...future.strategy.old <- future::plan("list")
[08:27:58.023]                   options(future.plan = NULL)
[08:27:58.023]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:58.023]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:58.023]                 }
[08:27:58.023]                 ...future.workdir <- getwd()
[08:27:58.023]             }
[08:27:58.023]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:58.023]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:58.023]         }
[08:27:58.023]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:58.023]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:58.023]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:58.023]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:58.023]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:58.023]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:58.023]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:58.023]             base::names(...future.oldOptions))
[08:27:58.023]     }
[08:27:58.023]     if (FALSE) {
[08:27:58.023]     }
[08:27:58.023]     else {
[08:27:58.023]         if (TRUE) {
[08:27:58.023]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:58.023]                 open = "w")
[08:27:58.023]         }
[08:27:58.023]         else {
[08:27:58.023]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:58.023]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:58.023]         }
[08:27:58.023]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:58.023]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:58.023]             base::sink(type = "output", split = FALSE)
[08:27:58.023]             base::close(...future.stdout)
[08:27:58.023]         }, add = TRUE)
[08:27:58.023]     }
[08:27:58.023]     ...future.frame <- base::sys.nframe()
[08:27:58.023]     ...future.conditions <- base::list()
[08:27:58.023]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:58.023]     if (FALSE) {
[08:27:58.023]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:58.023]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:58.023]     }
[08:27:58.023]     ...future.result <- base::tryCatch({
[08:27:58.023]         base::withCallingHandlers({
[08:27:58.023]             ...future.value <- base::withVisible(base::local({
[08:27:58.023]                 withCallingHandlers({
[08:27:58.023]                   {
[08:27:58.023]                     lm(dist ~ speed + I(speed^2), data = cars)
[08:27:58.023]                   }
[08:27:58.023]                 }, immediateCondition = function(cond) {
[08:27:58.023]                   save_rds <- function (object, pathname, ...) 
[08:27:58.023]                   {
[08:27:58.023]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:58.023]                     if (file_test("-f", pathname_tmp)) {
[08:27:58.023]                       fi_tmp <- file.info(pathname_tmp)
[08:27:58.023]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:58.023]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:58.023]                         fi_tmp[["mtime"]])
[08:27:58.023]                     }
[08:27:58.023]                     tryCatch({
[08:27:58.023]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:58.023]                     }, error = function(ex) {
[08:27:58.023]                       msg <- conditionMessage(ex)
[08:27:58.023]                       fi_tmp <- file.info(pathname_tmp)
[08:27:58.023]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:58.023]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:58.023]                         fi_tmp[["mtime"]], msg)
[08:27:58.023]                       ex$message <- msg
[08:27:58.023]                       stop(ex)
[08:27:58.023]                     })
[08:27:58.023]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:58.023]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:58.023]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:58.023]                       fi_tmp <- file.info(pathname_tmp)
[08:27:58.023]                       fi <- file.info(pathname)
[08:27:58.023]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:58.023]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:58.023]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:58.023]                         fi[["size"]], fi[["mtime"]])
[08:27:58.023]                       stop(msg)
[08:27:58.023]                     }
[08:27:58.023]                     invisible(pathname)
[08:27:58.023]                   }
[08:27:58.023]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:58.023]                     rootPath = tempdir()) 
[08:27:58.023]                   {
[08:27:58.023]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:58.023]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:58.023]                       tmpdir = path, fileext = ".rds")
[08:27:58.023]                     save_rds(obj, file)
[08:27:58.023]                   }
[08:27:58.023]                   saveImmediateCondition(cond, path = "/tmp/RtmpUQjont/.future/immediateConditions")
[08:27:58.023]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.023]                   {
[08:27:58.023]                     inherits <- base::inherits
[08:27:58.023]                     invokeRestart <- base::invokeRestart
[08:27:58.023]                     is.null <- base::is.null
[08:27:58.023]                     muffled <- FALSE
[08:27:58.023]                     if (inherits(cond, "message")) {
[08:27:58.023]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:58.023]                       if (muffled) 
[08:27:58.023]                         invokeRestart("muffleMessage")
[08:27:58.023]                     }
[08:27:58.023]                     else if (inherits(cond, "warning")) {
[08:27:58.023]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:58.023]                       if (muffled) 
[08:27:58.023]                         invokeRestart("muffleWarning")
[08:27:58.023]                     }
[08:27:58.023]                     else if (inherits(cond, "condition")) {
[08:27:58.023]                       if (!is.null(pattern)) {
[08:27:58.023]                         computeRestarts <- base::computeRestarts
[08:27:58.023]                         grepl <- base::grepl
[08:27:58.023]                         restarts <- computeRestarts(cond)
[08:27:58.023]                         for (restart in restarts) {
[08:27:58.023]                           name <- restart$name
[08:27:58.023]                           if (is.null(name)) 
[08:27:58.023]                             next
[08:27:58.023]                           if (!grepl(pattern, name)) 
[08:27:58.023]                             next
[08:27:58.023]                           invokeRestart(restart)
[08:27:58.023]                           muffled <- TRUE
[08:27:58.023]                           break
[08:27:58.023]                         }
[08:27:58.023]                       }
[08:27:58.023]                     }
[08:27:58.023]                     invisible(muffled)
[08:27:58.023]                   }
[08:27:58.023]                   muffleCondition(cond)
[08:27:58.023]                 })
[08:27:58.023]             }))
[08:27:58.023]             future::FutureResult(value = ...future.value$value, 
[08:27:58.023]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:58.023]                   ...future.rng), globalenv = if (FALSE) 
[08:27:58.023]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:58.023]                     ...future.globalenv.names))
[08:27:58.023]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:58.023]         }, condition = base::local({
[08:27:58.023]             c <- base::c
[08:27:58.023]             inherits <- base::inherits
[08:27:58.023]             invokeRestart <- base::invokeRestart
[08:27:58.023]             length <- base::length
[08:27:58.023]             list <- base::list
[08:27:58.023]             seq.int <- base::seq.int
[08:27:58.023]             signalCondition <- base::signalCondition
[08:27:58.023]             sys.calls <- base::sys.calls
[08:27:58.023]             `[[` <- base::`[[`
[08:27:58.023]             `+` <- base::`+`
[08:27:58.023]             `<<-` <- base::`<<-`
[08:27:58.023]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:58.023]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:58.023]                   3L)]
[08:27:58.023]             }
[08:27:58.023]             function(cond) {
[08:27:58.023]                 is_error <- inherits(cond, "error")
[08:27:58.023]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:58.023]                   NULL)
[08:27:58.023]                 if (is_error) {
[08:27:58.023]                   sessionInformation <- function() {
[08:27:58.023]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:58.023]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:58.023]                       search = base::search(), system = base::Sys.info())
[08:27:58.023]                   }
[08:27:58.023]                   ...future.conditions[[length(...future.conditions) + 
[08:27:58.023]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:58.023]                     cond$call), session = sessionInformation(), 
[08:27:58.023]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:58.023]                   signalCondition(cond)
[08:27:58.023]                 }
[08:27:58.023]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:58.023]                 "immediateCondition"))) {
[08:27:58.023]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:58.023]                   ...future.conditions[[length(...future.conditions) + 
[08:27:58.023]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:58.023]                   if (TRUE && !signal) {
[08:27:58.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.023]                     {
[08:27:58.023]                       inherits <- base::inherits
[08:27:58.023]                       invokeRestart <- base::invokeRestart
[08:27:58.023]                       is.null <- base::is.null
[08:27:58.023]                       muffled <- FALSE
[08:27:58.023]                       if (inherits(cond, "message")) {
[08:27:58.023]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:58.023]                         if (muffled) 
[08:27:58.023]                           invokeRestart("muffleMessage")
[08:27:58.023]                       }
[08:27:58.023]                       else if (inherits(cond, "warning")) {
[08:27:58.023]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:58.023]                         if (muffled) 
[08:27:58.023]                           invokeRestart("muffleWarning")
[08:27:58.023]                       }
[08:27:58.023]                       else if (inherits(cond, "condition")) {
[08:27:58.023]                         if (!is.null(pattern)) {
[08:27:58.023]                           computeRestarts <- base::computeRestarts
[08:27:58.023]                           grepl <- base::grepl
[08:27:58.023]                           restarts <- computeRestarts(cond)
[08:27:58.023]                           for (restart in restarts) {
[08:27:58.023]                             name <- restart$name
[08:27:58.023]                             if (is.null(name)) 
[08:27:58.023]                               next
[08:27:58.023]                             if (!grepl(pattern, name)) 
[08:27:58.023]                               next
[08:27:58.023]                             invokeRestart(restart)
[08:27:58.023]                             muffled <- TRUE
[08:27:58.023]                             break
[08:27:58.023]                           }
[08:27:58.023]                         }
[08:27:58.023]                       }
[08:27:58.023]                       invisible(muffled)
[08:27:58.023]                     }
[08:27:58.023]                     muffleCondition(cond, pattern = "^muffle")
[08:27:58.023]                   }
[08:27:58.023]                 }
[08:27:58.023]                 else {
[08:27:58.023]                   if (TRUE) {
[08:27:58.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.023]                     {
[08:27:58.023]                       inherits <- base::inherits
[08:27:58.023]                       invokeRestart <- base::invokeRestart
[08:27:58.023]                       is.null <- base::is.null
[08:27:58.023]                       muffled <- FALSE
[08:27:58.023]                       if (inherits(cond, "message")) {
[08:27:58.023]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:58.023]                         if (muffled) 
[08:27:58.023]                           invokeRestart("muffleMessage")
[08:27:58.023]                       }
[08:27:58.023]                       else if (inherits(cond, "warning")) {
[08:27:58.023]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:58.023]                         if (muffled) 
[08:27:58.023]                           invokeRestart("muffleWarning")
[08:27:58.023]                       }
[08:27:58.023]                       else if (inherits(cond, "condition")) {
[08:27:58.023]                         if (!is.null(pattern)) {
[08:27:58.023]                           computeRestarts <- base::computeRestarts
[08:27:58.023]                           grepl <- base::grepl
[08:27:58.023]                           restarts <- computeRestarts(cond)
[08:27:58.023]                           for (restart in restarts) {
[08:27:58.023]                             name <- restart$name
[08:27:58.023]                             if (is.null(name)) 
[08:27:58.023]                               next
[08:27:58.023]                             if (!grepl(pattern, name)) 
[08:27:58.023]                               next
[08:27:58.023]                             invokeRestart(restart)
[08:27:58.023]                             muffled <- TRUE
[08:27:58.023]                             break
[08:27:58.023]                           }
[08:27:58.023]                         }
[08:27:58.023]                       }
[08:27:58.023]                       invisible(muffled)
[08:27:58.023]                     }
[08:27:58.023]                     muffleCondition(cond, pattern = "^muffle")
[08:27:58.023]                   }
[08:27:58.023]                 }
[08:27:58.023]             }
[08:27:58.023]         }))
[08:27:58.023]     }, error = function(ex) {
[08:27:58.023]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:58.023]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:58.023]                 ...future.rng), started = ...future.startTime, 
[08:27:58.023]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:58.023]             version = "1.8"), class = "FutureResult")
[08:27:58.023]     }, finally = {
[08:27:58.023]         if (!identical(...future.workdir, getwd())) 
[08:27:58.023]             setwd(...future.workdir)
[08:27:58.023]         {
[08:27:58.023]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:58.023]                 ...future.oldOptions$nwarnings <- NULL
[08:27:58.023]             }
[08:27:58.023]             base::options(...future.oldOptions)
[08:27:58.023]             if (.Platform$OS.type == "windows") {
[08:27:58.023]                 old_names <- names(...future.oldEnvVars)
[08:27:58.023]                 envs <- base::Sys.getenv()
[08:27:58.023]                 names <- names(envs)
[08:27:58.023]                 common <- intersect(names, old_names)
[08:27:58.023]                 added <- setdiff(names, old_names)
[08:27:58.023]                 removed <- setdiff(old_names, names)
[08:27:58.023]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:58.023]                   envs[common]]
[08:27:58.023]                 NAMES <- toupper(changed)
[08:27:58.023]                 args <- list()
[08:27:58.023]                 for (kk in seq_along(NAMES)) {
[08:27:58.023]                   name <- changed[[kk]]
[08:27:58.023]                   NAME <- NAMES[[kk]]
[08:27:58.023]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.023]                     next
[08:27:58.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:58.023]                 }
[08:27:58.023]                 NAMES <- toupper(added)
[08:27:58.023]                 for (kk in seq_along(NAMES)) {
[08:27:58.023]                   name <- added[[kk]]
[08:27:58.023]                   NAME <- NAMES[[kk]]
[08:27:58.023]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.023]                     next
[08:27:58.023]                   args[[name]] <- ""
[08:27:58.023]                 }
[08:27:58.023]                 NAMES <- toupper(removed)
[08:27:58.023]                 for (kk in seq_along(NAMES)) {
[08:27:58.023]                   name <- removed[[kk]]
[08:27:58.023]                   NAME <- NAMES[[kk]]
[08:27:58.023]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.023]                     next
[08:27:58.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:58.023]                 }
[08:27:58.023]                 if (length(args) > 0) 
[08:27:58.023]                   base::do.call(base::Sys.setenv, args = args)
[08:27:58.023]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:58.023]             }
[08:27:58.023]             else {
[08:27:58.023]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:58.023]             }
[08:27:58.023]             {
[08:27:58.023]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:58.023]                   0L) {
[08:27:58.023]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:58.023]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:58.023]                   base::options(opts)
[08:27:58.023]                 }
[08:27:58.023]                 {
[08:27:58.023]                   {
[08:27:58.023]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:58.023]                     NULL
[08:27:58.023]                   }
[08:27:58.023]                   options(future.plan = NULL)
[08:27:58.023]                   if (is.na(NA_character_)) 
[08:27:58.023]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:58.023]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:58.023]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:58.023]                     .init = FALSE)
[08:27:58.023]                 }
[08:27:58.023]             }
[08:27:58.023]         }
[08:27:58.023]     })
[08:27:58.023]     if (TRUE) {
[08:27:58.023]         base::sink(type = "output", split = FALSE)
[08:27:58.023]         if (TRUE) {
[08:27:58.023]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:58.023]         }
[08:27:58.023]         else {
[08:27:58.023]             ...future.result["stdout"] <- base::list(NULL)
[08:27:58.023]         }
[08:27:58.023]         base::close(...future.stdout)
[08:27:58.023]         ...future.stdout <- NULL
[08:27:58.023]     }
[08:27:58.023]     ...future.result$conditions <- ...future.conditions
[08:27:58.023]     ...future.result$finished <- base::Sys.time()
[08:27:58.023]     ...future.result
[08:27:58.023] }
[08:27:58.025] requestCore(): workers = 2
[08:27:58.027] MulticoreFuture started
[08:27:58.028] - Launch lazy future ... done
[08:27:58.028] run() for ‘MulticoreFuture’ ... done
[08:27:58.028] result() for MulticoreFuture ...
[08:27:58.029] plan(): Setting new future strategy stack:
[08:27:58.029] List of future strategies:
[08:27:58.029] 1. sequential:
[08:27:58.029]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:58.029]    - tweaked: FALSE
[08:27:58.029]    - call: NULL
[08:27:58.030] plan(): nbrOfWorkers() = 1
[08:27:58.034] plan(): Setting new future strategy stack:
[08:27:58.034] List of future strategies:
[08:27:58.034] 1. multicore:
[08:27:58.034]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:58.034]    - tweaked: FALSE
[08:27:58.034]    - call: plan(strategy)
[08:27:58.037] plan(): nbrOfWorkers() = 2
[08:27:58.040] result() for MulticoreFuture ...
[08:27:58.040] result() for MulticoreFuture ... done
[08:27:58.040] result() for MulticoreFuture ... done
[08:27:58.040] result() for MulticoreFuture ...
[08:27:58.040] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[08:27:58.044] getGlobalsAndPackages() ...
[08:27:58.044] Searching for globals...
[08:27:58.050] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[08:27:58.050] Searching for globals ... DONE
[08:27:58.050] Resolving globals: FALSE
[08:27:58.051] 
[08:27:58.051] - packages: [2] ‘stats’, ‘datasets’
[08:27:58.051] getGlobalsAndPackages() ... DONE
[08:27:58.051] run() for ‘Future’ ...
[08:27:58.052] - state: ‘created’
[08:27:58.052] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:58.054] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:58.054] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:58.054]   - Field: ‘label’
[08:27:58.054]   - Field: ‘local’
[08:27:58.054]   - Field: ‘owner’
[08:27:58.054]   - Field: ‘envir’
[08:27:58.054]   - Field: ‘workers’
[08:27:58.055]   - Field: ‘packages’
[08:27:58.055]   - Field: ‘gc’
[08:27:58.055]   - Field: ‘job’
[08:27:58.055]   - Field: ‘conditions’
[08:27:58.055]   - Field: ‘expr’
[08:27:58.055]   - Field: ‘uuid’
[08:27:58.055]   - Field: ‘seed’
[08:27:58.055]   - Field: ‘version’
[08:27:58.055]   - Field: ‘result’
[08:27:58.056]   - Field: ‘asynchronous’
[08:27:58.056]   - Field: ‘calls’
[08:27:58.056]   - Field: ‘globals’
[08:27:58.056]   - Field: ‘stdout’
[08:27:58.056]   - Field: ‘earlySignal’
[08:27:58.056]   - Field: ‘lazy’
[08:27:58.056]   - Field: ‘state’
[08:27:58.056] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:58.056] - Launch lazy future ...
[08:27:58.057] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[08:27:58.057] Packages needed by future strategies (n = 0): <none>
[08:27:58.057] {
[08:27:58.057]     {
[08:27:58.057]         {
[08:27:58.057]             ...future.startTime <- base::Sys.time()
[08:27:58.057]             {
[08:27:58.057]                 {
[08:27:58.057]                   {
[08:27:58.057]                     {
[08:27:58.057]                       {
[08:27:58.057]                         base::local({
[08:27:58.057]                           has_future <- base::requireNamespace("future", 
[08:27:58.057]                             quietly = TRUE)
[08:27:58.057]                           if (has_future) {
[08:27:58.057]                             ns <- base::getNamespace("future")
[08:27:58.057]                             version <- ns[[".package"]][["version"]]
[08:27:58.057]                             if (is.null(version)) 
[08:27:58.057]                               version <- utils::packageVersion("future")
[08:27:58.057]                           }
[08:27:58.057]                           else {
[08:27:58.057]                             version <- NULL
[08:27:58.057]                           }
[08:27:58.057]                           if (!has_future || version < "1.8.0") {
[08:27:58.057]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:58.057]                               "", base::R.version$version.string), 
[08:27:58.057]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:58.057]                                 base::R.version$platform, 8 * 
[08:27:58.057]                                   base::.Machine$sizeof.pointer), 
[08:27:58.057]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:58.057]                                 "release", "version")], collapse = " "), 
[08:27:58.057]                               hostname = base::Sys.info()[["nodename"]])
[08:27:58.057]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:58.057]                               info)
[08:27:58.057]                             info <- base::paste(info, collapse = "; ")
[08:27:58.057]                             if (!has_future) {
[08:27:58.057]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:58.057]                                 info)
[08:27:58.057]                             }
[08:27:58.057]                             else {
[08:27:58.057]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:58.057]                                 info, version)
[08:27:58.057]                             }
[08:27:58.057]                             base::stop(msg)
[08:27:58.057]                           }
[08:27:58.057]                         })
[08:27:58.057]                       }
[08:27:58.057]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:58.057]                       base::options(mc.cores = 1L)
[08:27:58.057]                     }
[08:27:58.057]                     base::local({
[08:27:58.057]                       for (pkg in c("stats", "datasets")) {
[08:27:58.057]                         base::loadNamespace(pkg)
[08:27:58.057]                         base::library(pkg, character.only = TRUE)
[08:27:58.057]                       }
[08:27:58.057]                     })
[08:27:58.057]                   }
[08:27:58.057]                   ...future.strategy.old <- future::plan("list")
[08:27:58.057]                   options(future.plan = NULL)
[08:27:58.057]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:58.057]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:58.057]                 }
[08:27:58.057]                 ...future.workdir <- getwd()
[08:27:58.057]             }
[08:27:58.057]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:58.057]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:58.057]         }
[08:27:58.057]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:58.057]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:58.057]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:58.057]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:58.057]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:58.057]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:58.057]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:58.057]             base::names(...future.oldOptions))
[08:27:58.057]     }
[08:27:58.057]     if (FALSE) {
[08:27:58.057]     }
[08:27:58.057]     else {
[08:27:58.057]         if (TRUE) {
[08:27:58.057]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:58.057]                 open = "w")
[08:27:58.057]         }
[08:27:58.057]         else {
[08:27:58.057]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:58.057]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:58.057]         }
[08:27:58.057]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:58.057]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:58.057]             base::sink(type = "output", split = FALSE)
[08:27:58.057]             base::close(...future.stdout)
[08:27:58.057]         }, add = TRUE)
[08:27:58.057]     }
[08:27:58.057]     ...future.frame <- base::sys.nframe()
[08:27:58.057]     ...future.conditions <- base::list()
[08:27:58.057]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:58.057]     if (FALSE) {
[08:27:58.057]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:58.057]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:58.057]     }
[08:27:58.057]     ...future.result <- base::tryCatch({
[08:27:58.057]         base::withCallingHandlers({
[08:27:58.057]             ...future.value <- base::withVisible(base::local({
[08:27:58.057]                 withCallingHandlers({
[08:27:58.057]                   {
[08:27:58.057]                     lm(dist ~ poly(speed, 2), data = cars)
[08:27:58.057]                   }
[08:27:58.057]                 }, immediateCondition = function(cond) {
[08:27:58.057]                   save_rds <- function (object, pathname, ...) 
[08:27:58.057]                   {
[08:27:58.057]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:58.057]                     if (file_test("-f", pathname_tmp)) {
[08:27:58.057]                       fi_tmp <- file.info(pathname_tmp)
[08:27:58.057]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:58.057]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:58.057]                         fi_tmp[["mtime"]])
[08:27:58.057]                     }
[08:27:58.057]                     tryCatch({
[08:27:58.057]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:58.057]                     }, error = function(ex) {
[08:27:58.057]                       msg <- conditionMessage(ex)
[08:27:58.057]                       fi_tmp <- file.info(pathname_tmp)
[08:27:58.057]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:58.057]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:58.057]                         fi_tmp[["mtime"]], msg)
[08:27:58.057]                       ex$message <- msg
[08:27:58.057]                       stop(ex)
[08:27:58.057]                     })
[08:27:58.057]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:58.057]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:58.057]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:58.057]                       fi_tmp <- file.info(pathname_tmp)
[08:27:58.057]                       fi <- file.info(pathname)
[08:27:58.057]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:58.057]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:58.057]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:58.057]                         fi[["size"]], fi[["mtime"]])
[08:27:58.057]                       stop(msg)
[08:27:58.057]                     }
[08:27:58.057]                     invisible(pathname)
[08:27:58.057]                   }
[08:27:58.057]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:58.057]                     rootPath = tempdir()) 
[08:27:58.057]                   {
[08:27:58.057]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:58.057]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:58.057]                       tmpdir = path, fileext = ".rds")
[08:27:58.057]                     save_rds(obj, file)
[08:27:58.057]                   }
[08:27:58.057]                   saveImmediateCondition(cond, path = "/tmp/RtmpUQjont/.future/immediateConditions")
[08:27:58.057]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.057]                   {
[08:27:58.057]                     inherits <- base::inherits
[08:27:58.057]                     invokeRestart <- base::invokeRestart
[08:27:58.057]                     is.null <- base::is.null
[08:27:58.057]                     muffled <- FALSE
[08:27:58.057]                     if (inherits(cond, "message")) {
[08:27:58.057]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:58.057]                       if (muffled) 
[08:27:58.057]                         invokeRestart("muffleMessage")
[08:27:58.057]                     }
[08:27:58.057]                     else if (inherits(cond, "warning")) {
[08:27:58.057]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:58.057]                       if (muffled) 
[08:27:58.057]                         invokeRestart("muffleWarning")
[08:27:58.057]                     }
[08:27:58.057]                     else if (inherits(cond, "condition")) {
[08:27:58.057]                       if (!is.null(pattern)) {
[08:27:58.057]                         computeRestarts <- base::computeRestarts
[08:27:58.057]                         grepl <- base::grepl
[08:27:58.057]                         restarts <- computeRestarts(cond)
[08:27:58.057]                         for (restart in restarts) {
[08:27:58.057]                           name <- restart$name
[08:27:58.057]                           if (is.null(name)) 
[08:27:58.057]                             next
[08:27:58.057]                           if (!grepl(pattern, name)) 
[08:27:58.057]                             next
[08:27:58.057]                           invokeRestart(restart)
[08:27:58.057]                           muffled <- TRUE
[08:27:58.057]                           break
[08:27:58.057]                         }
[08:27:58.057]                       }
[08:27:58.057]                     }
[08:27:58.057]                     invisible(muffled)
[08:27:58.057]                   }
[08:27:58.057]                   muffleCondition(cond)
[08:27:58.057]                 })
[08:27:58.057]             }))
[08:27:58.057]             future::FutureResult(value = ...future.value$value, 
[08:27:58.057]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:58.057]                   ...future.rng), globalenv = if (FALSE) 
[08:27:58.057]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:58.057]                     ...future.globalenv.names))
[08:27:58.057]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:58.057]         }, condition = base::local({
[08:27:58.057]             c <- base::c
[08:27:58.057]             inherits <- base::inherits
[08:27:58.057]             invokeRestart <- base::invokeRestart
[08:27:58.057]             length <- base::length
[08:27:58.057]             list <- base::list
[08:27:58.057]             seq.int <- base::seq.int
[08:27:58.057]             signalCondition <- base::signalCondition
[08:27:58.057]             sys.calls <- base::sys.calls
[08:27:58.057]             `[[` <- base::`[[`
[08:27:58.057]             `+` <- base::`+`
[08:27:58.057]             `<<-` <- base::`<<-`
[08:27:58.057]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:58.057]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:58.057]                   3L)]
[08:27:58.057]             }
[08:27:58.057]             function(cond) {
[08:27:58.057]                 is_error <- inherits(cond, "error")
[08:27:58.057]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:58.057]                   NULL)
[08:27:58.057]                 if (is_error) {
[08:27:58.057]                   sessionInformation <- function() {
[08:27:58.057]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:58.057]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:58.057]                       search = base::search(), system = base::Sys.info())
[08:27:58.057]                   }
[08:27:58.057]                   ...future.conditions[[length(...future.conditions) + 
[08:27:58.057]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:58.057]                     cond$call), session = sessionInformation(), 
[08:27:58.057]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:58.057]                   signalCondition(cond)
[08:27:58.057]                 }
[08:27:58.057]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:58.057]                 "immediateCondition"))) {
[08:27:58.057]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:58.057]                   ...future.conditions[[length(...future.conditions) + 
[08:27:58.057]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:58.057]                   if (TRUE && !signal) {
[08:27:58.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.057]                     {
[08:27:58.057]                       inherits <- base::inherits
[08:27:58.057]                       invokeRestart <- base::invokeRestart
[08:27:58.057]                       is.null <- base::is.null
[08:27:58.057]                       muffled <- FALSE
[08:27:58.057]                       if (inherits(cond, "message")) {
[08:27:58.057]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:58.057]                         if (muffled) 
[08:27:58.057]                           invokeRestart("muffleMessage")
[08:27:58.057]                       }
[08:27:58.057]                       else if (inherits(cond, "warning")) {
[08:27:58.057]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:58.057]                         if (muffled) 
[08:27:58.057]                           invokeRestart("muffleWarning")
[08:27:58.057]                       }
[08:27:58.057]                       else if (inherits(cond, "condition")) {
[08:27:58.057]                         if (!is.null(pattern)) {
[08:27:58.057]                           computeRestarts <- base::computeRestarts
[08:27:58.057]                           grepl <- base::grepl
[08:27:58.057]                           restarts <- computeRestarts(cond)
[08:27:58.057]                           for (restart in restarts) {
[08:27:58.057]                             name <- restart$name
[08:27:58.057]                             if (is.null(name)) 
[08:27:58.057]                               next
[08:27:58.057]                             if (!grepl(pattern, name)) 
[08:27:58.057]                               next
[08:27:58.057]                             invokeRestart(restart)
[08:27:58.057]                             muffled <- TRUE
[08:27:58.057]                             break
[08:27:58.057]                           }
[08:27:58.057]                         }
[08:27:58.057]                       }
[08:27:58.057]                       invisible(muffled)
[08:27:58.057]                     }
[08:27:58.057]                     muffleCondition(cond, pattern = "^muffle")
[08:27:58.057]                   }
[08:27:58.057]                 }
[08:27:58.057]                 else {
[08:27:58.057]                   if (TRUE) {
[08:27:58.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.057]                     {
[08:27:58.057]                       inherits <- base::inherits
[08:27:58.057]                       invokeRestart <- base::invokeRestart
[08:27:58.057]                       is.null <- base::is.null
[08:27:58.057]                       muffled <- FALSE
[08:27:58.057]                       if (inherits(cond, "message")) {
[08:27:58.057]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:58.057]                         if (muffled) 
[08:27:58.057]                           invokeRestart("muffleMessage")
[08:27:58.057]                       }
[08:27:58.057]                       else if (inherits(cond, "warning")) {
[08:27:58.057]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:58.057]                         if (muffled) 
[08:27:58.057]                           invokeRestart("muffleWarning")
[08:27:58.057]                       }
[08:27:58.057]                       else if (inherits(cond, "condition")) {
[08:27:58.057]                         if (!is.null(pattern)) {
[08:27:58.057]                           computeRestarts <- base::computeRestarts
[08:27:58.057]                           grepl <- base::grepl
[08:27:58.057]                           restarts <- computeRestarts(cond)
[08:27:58.057]                           for (restart in restarts) {
[08:27:58.057]                             name <- restart$name
[08:27:58.057]                             if (is.null(name)) 
[08:27:58.057]                               next
[08:27:58.057]                             if (!grepl(pattern, name)) 
[08:27:58.057]                               next
[08:27:58.057]                             invokeRestart(restart)
[08:27:58.057]                             muffled <- TRUE
[08:27:58.057]                             break
[08:27:58.057]                           }
[08:27:58.057]                         }
[08:27:58.057]                       }
[08:27:58.057]                       invisible(muffled)
[08:27:58.057]                     }
[08:27:58.057]                     muffleCondition(cond, pattern = "^muffle")
[08:27:58.057]                   }
[08:27:58.057]                 }
[08:27:58.057]             }
[08:27:58.057]         }))
[08:27:58.057]     }, error = function(ex) {
[08:27:58.057]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:58.057]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:58.057]                 ...future.rng), started = ...future.startTime, 
[08:27:58.057]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:58.057]             version = "1.8"), class = "FutureResult")
[08:27:58.057]     }, finally = {
[08:27:58.057]         if (!identical(...future.workdir, getwd())) 
[08:27:58.057]             setwd(...future.workdir)
[08:27:58.057]         {
[08:27:58.057]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:58.057]                 ...future.oldOptions$nwarnings <- NULL
[08:27:58.057]             }
[08:27:58.057]             base::options(...future.oldOptions)
[08:27:58.057]             if (.Platform$OS.type == "windows") {
[08:27:58.057]                 old_names <- names(...future.oldEnvVars)
[08:27:58.057]                 envs <- base::Sys.getenv()
[08:27:58.057]                 names <- names(envs)
[08:27:58.057]                 common <- intersect(names, old_names)
[08:27:58.057]                 added <- setdiff(names, old_names)
[08:27:58.057]                 removed <- setdiff(old_names, names)
[08:27:58.057]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:58.057]                   envs[common]]
[08:27:58.057]                 NAMES <- toupper(changed)
[08:27:58.057]                 args <- list()
[08:27:58.057]                 for (kk in seq_along(NAMES)) {
[08:27:58.057]                   name <- changed[[kk]]
[08:27:58.057]                   NAME <- NAMES[[kk]]
[08:27:58.057]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.057]                     next
[08:27:58.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:58.057]                 }
[08:27:58.057]                 NAMES <- toupper(added)
[08:27:58.057]                 for (kk in seq_along(NAMES)) {
[08:27:58.057]                   name <- added[[kk]]
[08:27:58.057]                   NAME <- NAMES[[kk]]
[08:27:58.057]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.057]                     next
[08:27:58.057]                   args[[name]] <- ""
[08:27:58.057]                 }
[08:27:58.057]                 NAMES <- toupper(removed)
[08:27:58.057]                 for (kk in seq_along(NAMES)) {
[08:27:58.057]                   name <- removed[[kk]]
[08:27:58.057]                   NAME <- NAMES[[kk]]
[08:27:58.057]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.057]                     next
[08:27:58.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:58.057]                 }
[08:27:58.057]                 if (length(args) > 0) 
[08:27:58.057]                   base::do.call(base::Sys.setenv, args = args)
[08:27:58.057]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:58.057]             }
[08:27:58.057]             else {
[08:27:58.057]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:58.057]             }
[08:27:58.057]             {
[08:27:58.057]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:58.057]                   0L) {
[08:27:58.057]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:58.057]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:58.057]                   base::options(opts)
[08:27:58.057]                 }
[08:27:58.057]                 {
[08:27:58.057]                   {
[08:27:58.057]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:58.057]                     NULL
[08:27:58.057]                   }
[08:27:58.057]                   options(future.plan = NULL)
[08:27:58.057]                   if (is.na(NA_character_)) 
[08:27:58.057]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:58.057]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:58.057]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:58.057]                     .init = FALSE)
[08:27:58.057]                 }
[08:27:58.057]             }
[08:27:58.057]         }
[08:27:58.057]     })
[08:27:58.057]     if (TRUE) {
[08:27:58.057]         base::sink(type = "output", split = FALSE)
[08:27:58.057]         if (TRUE) {
[08:27:58.057]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:58.057]         }
[08:27:58.057]         else {
[08:27:58.057]             ...future.result["stdout"] <- base::list(NULL)
[08:27:58.057]         }
[08:27:58.057]         base::close(...future.stdout)
[08:27:58.057]         ...future.stdout <- NULL
[08:27:58.057]     }
[08:27:58.057]     ...future.result$conditions <- ...future.conditions
[08:27:58.057]     ...future.result$finished <- base::Sys.time()
[08:27:58.057]     ...future.result
[08:27:58.057] }
[08:27:58.060] requestCore(): workers = 2
[08:27:58.062] MulticoreFuture started
[08:27:58.062] - Launch lazy future ... done
[08:27:58.062] run() for ‘MulticoreFuture’ ... done
[08:27:58.063] result() for MulticoreFuture ...
[08:27:58.063] plan(): Setting new future strategy stack:
[08:27:58.064] List of future strategies:
[08:27:58.064] 1. sequential:
[08:27:58.064]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:58.064]    - tweaked: FALSE
[08:27:58.064]    - call: NULL
[08:27:58.065] plan(): nbrOfWorkers() = 1
[08:27:58.069] plan(): Setting new future strategy stack:
[08:27:58.069] List of future strategies:
[08:27:58.069] 1. multicore:
[08:27:58.069]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:58.069]    - tweaked: FALSE
[08:27:58.069]    - call: plan(strategy)
[08:27:58.072] plan(): nbrOfWorkers() = 2
[08:27:58.075] result() for MulticoreFuture ...
[08:27:58.075] result() for MulticoreFuture ... done
[08:27:58.075] result() for MulticoreFuture ... done
[08:27:58.075] result() for MulticoreFuture ...
[08:27:58.076] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[08:27:58.078] getGlobalsAndPackages() ...
[08:27:58.078] Searching for globals...
[08:27:58.084] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[08:27:58.084] Searching for globals ... DONE
[08:27:58.084] Resolving globals: FALSE
[08:27:58.085] The total size of the 3 globals is 1.22 KiB (1254 bytes)
[08:27:58.086] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (633 bytes of class ‘function’), ‘inner_function’ (371 bytes of class ‘function’) and ‘outer_function’ (250 bytes of class ‘function’)
[08:27:58.086] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[08:27:58.086] 
[08:27:58.086] getGlobalsAndPackages() ... DONE
[08:27:58.086] run() for ‘Future’ ...
[08:27:58.086] - state: ‘created’
[08:27:58.087] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:58.089] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:58.089] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:58.089]   - Field: ‘label’
[08:27:58.089]   - Field: ‘local’
[08:27:58.089]   - Field: ‘owner’
[08:27:58.089]   - Field: ‘envir’
[08:27:58.089]   - Field: ‘workers’
[08:27:58.090]   - Field: ‘packages’
[08:27:58.090]   - Field: ‘gc’
[08:27:58.090]   - Field: ‘job’
[08:27:58.090]   - Field: ‘conditions’
[08:27:58.090]   - Field: ‘expr’
[08:27:58.090]   - Field: ‘uuid’
[08:27:58.090]   - Field: ‘seed’
[08:27:58.090]   - Field: ‘version’
[08:27:58.090]   - Field: ‘result’
[08:27:58.092]   - Field: ‘asynchronous’
[08:27:58.092]   - Field: ‘calls’
[08:27:58.093]   - Field: ‘globals’
[08:27:58.093]   - Field: ‘stdout’
[08:27:58.093]   - Field: ‘earlySignal’
[08:27:58.093]   - Field: ‘lazy’
[08:27:58.093]   - Field: ‘state’
[08:27:58.093] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:58.094] - Launch lazy future ...
[08:27:58.094] Packages needed by the future expression (n = 0): <none>
[08:27:58.094] Packages needed by future strategies (n = 0): <none>
[08:27:58.095] {
[08:27:58.095]     {
[08:27:58.095]         {
[08:27:58.095]             ...future.startTime <- base::Sys.time()
[08:27:58.095]             {
[08:27:58.095]                 {
[08:27:58.095]                   {
[08:27:58.095]                     {
[08:27:58.095]                       base::local({
[08:27:58.095]                         has_future <- base::requireNamespace("future", 
[08:27:58.095]                           quietly = TRUE)
[08:27:58.095]                         if (has_future) {
[08:27:58.095]                           ns <- base::getNamespace("future")
[08:27:58.095]                           version <- ns[[".package"]][["version"]]
[08:27:58.095]                           if (is.null(version)) 
[08:27:58.095]                             version <- utils::packageVersion("future")
[08:27:58.095]                         }
[08:27:58.095]                         else {
[08:27:58.095]                           version <- NULL
[08:27:58.095]                         }
[08:27:58.095]                         if (!has_future || version < "1.8.0") {
[08:27:58.095]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:58.095]                             "", base::R.version$version.string), 
[08:27:58.095]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:58.095]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:58.095]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:58.095]                               "release", "version")], collapse = " "), 
[08:27:58.095]                             hostname = base::Sys.info()[["nodename"]])
[08:27:58.095]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:58.095]                             info)
[08:27:58.095]                           info <- base::paste(info, collapse = "; ")
[08:27:58.095]                           if (!has_future) {
[08:27:58.095]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:58.095]                               info)
[08:27:58.095]                           }
[08:27:58.095]                           else {
[08:27:58.095]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:58.095]                               info, version)
[08:27:58.095]                           }
[08:27:58.095]                           base::stop(msg)
[08:27:58.095]                         }
[08:27:58.095]                       })
[08:27:58.095]                     }
[08:27:58.095]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:58.095]                     base::options(mc.cores = 1L)
[08:27:58.095]                   }
[08:27:58.095]                   ...future.strategy.old <- future::plan("list")
[08:27:58.095]                   options(future.plan = NULL)
[08:27:58.095]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:58.095]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:58.095]                 }
[08:27:58.095]                 ...future.workdir <- getwd()
[08:27:58.095]             }
[08:27:58.095]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:58.095]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:58.095]         }
[08:27:58.095]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:58.095]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:58.095]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:58.095]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:58.095]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:58.095]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:58.095]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:58.095]             base::names(...future.oldOptions))
[08:27:58.095]     }
[08:27:58.095]     if (FALSE) {
[08:27:58.095]     }
[08:27:58.095]     else {
[08:27:58.095]         if (TRUE) {
[08:27:58.095]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:58.095]                 open = "w")
[08:27:58.095]         }
[08:27:58.095]         else {
[08:27:58.095]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:58.095]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:58.095]         }
[08:27:58.095]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:58.095]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:58.095]             base::sink(type = "output", split = FALSE)
[08:27:58.095]             base::close(...future.stdout)
[08:27:58.095]         }, add = TRUE)
[08:27:58.095]     }
[08:27:58.095]     ...future.frame <- base::sys.nframe()
[08:27:58.095]     ...future.conditions <- base::list()
[08:27:58.095]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:58.095]     if (FALSE) {
[08:27:58.095]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:58.095]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:58.095]     }
[08:27:58.095]     ...future.result <- base::tryCatch({
[08:27:58.095]         base::withCallingHandlers({
[08:27:58.095]             ...future.value <- base::withVisible(base::local({
[08:27:58.095]                 withCallingHandlers({
[08:27:58.095]                   {
[08:27:58.095]                     outer_function(1L)
[08:27:58.095]                   }
[08:27:58.095]                 }, immediateCondition = function(cond) {
[08:27:58.095]                   save_rds <- function (object, pathname, ...) 
[08:27:58.095]                   {
[08:27:58.095]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:58.095]                     if (file_test("-f", pathname_tmp)) {
[08:27:58.095]                       fi_tmp <- file.info(pathname_tmp)
[08:27:58.095]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:58.095]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:58.095]                         fi_tmp[["mtime"]])
[08:27:58.095]                     }
[08:27:58.095]                     tryCatch({
[08:27:58.095]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:58.095]                     }, error = function(ex) {
[08:27:58.095]                       msg <- conditionMessage(ex)
[08:27:58.095]                       fi_tmp <- file.info(pathname_tmp)
[08:27:58.095]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:58.095]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:58.095]                         fi_tmp[["mtime"]], msg)
[08:27:58.095]                       ex$message <- msg
[08:27:58.095]                       stop(ex)
[08:27:58.095]                     })
[08:27:58.095]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:58.095]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:58.095]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:58.095]                       fi_tmp <- file.info(pathname_tmp)
[08:27:58.095]                       fi <- file.info(pathname)
[08:27:58.095]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:58.095]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:58.095]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:58.095]                         fi[["size"]], fi[["mtime"]])
[08:27:58.095]                       stop(msg)
[08:27:58.095]                     }
[08:27:58.095]                     invisible(pathname)
[08:27:58.095]                   }
[08:27:58.095]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:58.095]                     rootPath = tempdir()) 
[08:27:58.095]                   {
[08:27:58.095]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:58.095]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:58.095]                       tmpdir = path, fileext = ".rds")
[08:27:58.095]                     save_rds(obj, file)
[08:27:58.095]                   }
[08:27:58.095]                   saveImmediateCondition(cond, path = "/tmp/RtmpUQjont/.future/immediateConditions")
[08:27:58.095]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.095]                   {
[08:27:58.095]                     inherits <- base::inherits
[08:27:58.095]                     invokeRestart <- base::invokeRestart
[08:27:58.095]                     is.null <- base::is.null
[08:27:58.095]                     muffled <- FALSE
[08:27:58.095]                     if (inherits(cond, "message")) {
[08:27:58.095]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:58.095]                       if (muffled) 
[08:27:58.095]                         invokeRestart("muffleMessage")
[08:27:58.095]                     }
[08:27:58.095]                     else if (inherits(cond, "warning")) {
[08:27:58.095]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:58.095]                       if (muffled) 
[08:27:58.095]                         invokeRestart("muffleWarning")
[08:27:58.095]                     }
[08:27:58.095]                     else if (inherits(cond, "condition")) {
[08:27:58.095]                       if (!is.null(pattern)) {
[08:27:58.095]                         computeRestarts <- base::computeRestarts
[08:27:58.095]                         grepl <- base::grepl
[08:27:58.095]                         restarts <- computeRestarts(cond)
[08:27:58.095]                         for (restart in restarts) {
[08:27:58.095]                           name <- restart$name
[08:27:58.095]                           if (is.null(name)) 
[08:27:58.095]                             next
[08:27:58.095]                           if (!grepl(pattern, name)) 
[08:27:58.095]                             next
[08:27:58.095]                           invokeRestart(restart)
[08:27:58.095]                           muffled <- TRUE
[08:27:58.095]                           break
[08:27:58.095]                         }
[08:27:58.095]                       }
[08:27:58.095]                     }
[08:27:58.095]                     invisible(muffled)
[08:27:58.095]                   }
[08:27:58.095]                   muffleCondition(cond)
[08:27:58.095]                 })
[08:27:58.095]             }))
[08:27:58.095]             future::FutureResult(value = ...future.value$value, 
[08:27:58.095]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:58.095]                   ...future.rng), globalenv = if (FALSE) 
[08:27:58.095]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:58.095]                     ...future.globalenv.names))
[08:27:58.095]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:58.095]         }, condition = base::local({
[08:27:58.095]             c <- base::c
[08:27:58.095]             inherits <- base::inherits
[08:27:58.095]             invokeRestart <- base::invokeRestart
[08:27:58.095]             length <- base::length
[08:27:58.095]             list <- base::list
[08:27:58.095]             seq.int <- base::seq.int
[08:27:58.095]             signalCondition <- base::signalCondition
[08:27:58.095]             sys.calls <- base::sys.calls
[08:27:58.095]             `[[` <- base::`[[`
[08:27:58.095]             `+` <- base::`+`
[08:27:58.095]             `<<-` <- base::`<<-`
[08:27:58.095]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:58.095]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:58.095]                   3L)]
[08:27:58.095]             }
[08:27:58.095]             function(cond) {
[08:27:58.095]                 is_error <- inherits(cond, "error")
[08:27:58.095]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:58.095]                   NULL)
[08:27:58.095]                 if (is_error) {
[08:27:58.095]                   sessionInformation <- function() {
[08:27:58.095]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:58.095]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:58.095]                       search = base::search(), system = base::Sys.info())
[08:27:58.095]                   }
[08:27:58.095]                   ...future.conditions[[length(...future.conditions) + 
[08:27:58.095]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:58.095]                     cond$call), session = sessionInformation(), 
[08:27:58.095]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:58.095]                   signalCondition(cond)
[08:27:58.095]                 }
[08:27:58.095]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:58.095]                 "immediateCondition"))) {
[08:27:58.095]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:58.095]                   ...future.conditions[[length(...future.conditions) + 
[08:27:58.095]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:58.095]                   if (TRUE && !signal) {
[08:27:58.095]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.095]                     {
[08:27:58.095]                       inherits <- base::inherits
[08:27:58.095]                       invokeRestart <- base::invokeRestart
[08:27:58.095]                       is.null <- base::is.null
[08:27:58.095]                       muffled <- FALSE
[08:27:58.095]                       if (inherits(cond, "message")) {
[08:27:58.095]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:58.095]                         if (muffled) 
[08:27:58.095]                           invokeRestart("muffleMessage")
[08:27:58.095]                       }
[08:27:58.095]                       else if (inherits(cond, "warning")) {
[08:27:58.095]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:58.095]                         if (muffled) 
[08:27:58.095]                           invokeRestart("muffleWarning")
[08:27:58.095]                       }
[08:27:58.095]                       else if (inherits(cond, "condition")) {
[08:27:58.095]                         if (!is.null(pattern)) {
[08:27:58.095]                           computeRestarts <- base::computeRestarts
[08:27:58.095]                           grepl <- base::grepl
[08:27:58.095]                           restarts <- computeRestarts(cond)
[08:27:58.095]                           for (restart in restarts) {
[08:27:58.095]                             name <- restart$name
[08:27:58.095]                             if (is.null(name)) 
[08:27:58.095]                               next
[08:27:58.095]                             if (!grepl(pattern, name)) 
[08:27:58.095]                               next
[08:27:58.095]                             invokeRestart(restart)
[08:27:58.095]                             muffled <- TRUE
[08:27:58.095]                             break
[08:27:58.095]                           }
[08:27:58.095]                         }
[08:27:58.095]                       }
[08:27:58.095]                       invisible(muffled)
[08:27:58.095]                     }
[08:27:58.095]                     muffleCondition(cond, pattern = "^muffle")
[08:27:58.095]                   }
[08:27:58.095]                 }
[08:27:58.095]                 else {
[08:27:58.095]                   if (TRUE) {
[08:27:58.095]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.095]                     {
[08:27:58.095]                       inherits <- base::inherits
[08:27:58.095]                       invokeRestart <- base::invokeRestart
[08:27:58.095]                       is.null <- base::is.null
[08:27:58.095]                       muffled <- FALSE
[08:27:58.095]                       if (inherits(cond, "message")) {
[08:27:58.095]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:58.095]                         if (muffled) 
[08:27:58.095]                           invokeRestart("muffleMessage")
[08:27:58.095]                       }
[08:27:58.095]                       else if (inherits(cond, "warning")) {
[08:27:58.095]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:58.095]                         if (muffled) 
[08:27:58.095]                           invokeRestart("muffleWarning")
[08:27:58.095]                       }
[08:27:58.095]                       else if (inherits(cond, "condition")) {
[08:27:58.095]                         if (!is.null(pattern)) {
[08:27:58.095]                           computeRestarts <- base::computeRestarts
[08:27:58.095]                           grepl <- base::grepl
[08:27:58.095]                           restarts <- computeRestarts(cond)
[08:27:58.095]                           for (restart in restarts) {
[08:27:58.095]                             name <- restart$name
[08:27:58.095]                             if (is.null(name)) 
[08:27:58.095]                               next
[08:27:58.095]                             if (!grepl(pattern, name)) 
[08:27:58.095]                               next
[08:27:58.095]                             invokeRestart(restart)
[08:27:58.095]                             muffled <- TRUE
[08:27:58.095]                             break
[08:27:58.095]                           }
[08:27:58.095]                         }
[08:27:58.095]                       }
[08:27:58.095]                       invisible(muffled)
[08:27:58.095]                     }
[08:27:58.095]                     muffleCondition(cond, pattern = "^muffle")
[08:27:58.095]                   }
[08:27:58.095]                 }
[08:27:58.095]             }
[08:27:58.095]         }))
[08:27:58.095]     }, error = function(ex) {
[08:27:58.095]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:58.095]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:58.095]                 ...future.rng), started = ...future.startTime, 
[08:27:58.095]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:58.095]             version = "1.8"), class = "FutureResult")
[08:27:58.095]     }, finally = {
[08:27:58.095]         if (!identical(...future.workdir, getwd())) 
[08:27:58.095]             setwd(...future.workdir)
[08:27:58.095]         {
[08:27:58.095]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:58.095]                 ...future.oldOptions$nwarnings <- NULL
[08:27:58.095]             }
[08:27:58.095]             base::options(...future.oldOptions)
[08:27:58.095]             if (.Platform$OS.type == "windows") {
[08:27:58.095]                 old_names <- names(...future.oldEnvVars)
[08:27:58.095]                 envs <- base::Sys.getenv()
[08:27:58.095]                 names <- names(envs)
[08:27:58.095]                 common <- intersect(names, old_names)
[08:27:58.095]                 added <- setdiff(names, old_names)
[08:27:58.095]                 removed <- setdiff(old_names, names)
[08:27:58.095]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:58.095]                   envs[common]]
[08:27:58.095]                 NAMES <- toupper(changed)
[08:27:58.095]                 args <- list()
[08:27:58.095]                 for (kk in seq_along(NAMES)) {
[08:27:58.095]                   name <- changed[[kk]]
[08:27:58.095]                   NAME <- NAMES[[kk]]
[08:27:58.095]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.095]                     next
[08:27:58.095]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:58.095]                 }
[08:27:58.095]                 NAMES <- toupper(added)
[08:27:58.095]                 for (kk in seq_along(NAMES)) {
[08:27:58.095]                   name <- added[[kk]]
[08:27:58.095]                   NAME <- NAMES[[kk]]
[08:27:58.095]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.095]                     next
[08:27:58.095]                   args[[name]] <- ""
[08:27:58.095]                 }
[08:27:58.095]                 NAMES <- toupper(removed)
[08:27:58.095]                 for (kk in seq_along(NAMES)) {
[08:27:58.095]                   name <- removed[[kk]]
[08:27:58.095]                   NAME <- NAMES[[kk]]
[08:27:58.095]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.095]                     next
[08:27:58.095]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:58.095]                 }
[08:27:58.095]                 if (length(args) > 0) 
[08:27:58.095]                   base::do.call(base::Sys.setenv, args = args)
[08:27:58.095]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:58.095]             }
[08:27:58.095]             else {
[08:27:58.095]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:58.095]             }
[08:27:58.095]             {
[08:27:58.095]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:58.095]                   0L) {
[08:27:58.095]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:58.095]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:58.095]                   base::options(opts)
[08:27:58.095]                 }
[08:27:58.095]                 {
[08:27:58.095]                   {
[08:27:58.095]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:58.095]                     NULL
[08:27:58.095]                   }
[08:27:58.095]                   options(future.plan = NULL)
[08:27:58.095]                   if (is.na(NA_character_)) 
[08:27:58.095]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:58.095]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:58.095]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:58.095]                     .init = FALSE)
[08:27:58.095]                 }
[08:27:58.095]             }
[08:27:58.095]         }
[08:27:58.095]     })
[08:27:58.095]     if (TRUE) {
[08:27:58.095]         base::sink(type = "output", split = FALSE)
[08:27:58.095]         if (TRUE) {
[08:27:58.095]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:58.095]         }
[08:27:58.095]         else {
[08:27:58.095]             ...future.result["stdout"] <- base::list(NULL)
[08:27:58.095]         }
[08:27:58.095]         base::close(...future.stdout)
[08:27:58.095]         ...future.stdout <- NULL
[08:27:58.095]     }
[08:27:58.095]     ...future.result$conditions <- ...future.conditions
[08:27:58.095]     ...future.result$finished <- base::Sys.time()
[08:27:58.095]     ...future.result
[08:27:58.095] }
[08:27:58.097] assign_globals() ...
[08:27:58.097] List of 3
[08:27:58.097]  $ outer_function:function (x)  
[08:27:58.097]  $ map           :function (.x, .f, ...)  
[08:27:58.097]  $ inner_function:function (x)  
[08:27:58.097]  - attr(*, "where")=List of 3
[08:27:58.097]   ..$ outer_function:<environment: R_EmptyEnv> 
[08:27:58.097]   ..$ map           :<environment: R_EmptyEnv> 
[08:27:58.097]   ..$ inner_function:<environment: R_EmptyEnv> 
[08:27:58.097]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:58.097]  - attr(*, "resolved")= logi FALSE
[08:27:58.097]  - attr(*, "total_size")= num 1254
[08:27:58.097]  - attr(*, "already-done")= logi TRUE
[08:27:58.101] - reassign environment for ‘outer_function’
[08:27:58.101] - copied ‘outer_function’ to environment
[08:27:58.102] - reassign environment for ‘map’
[08:27:58.102] - copied ‘map’ to environment
[08:27:58.102] - reassign environment for ‘inner_function’
[08:27:58.102] - copied ‘inner_function’ to environment
[08:27:58.102] assign_globals() ... done
[08:27:58.102] requestCore(): workers = 2
[08:27:58.104] MulticoreFuture started
[08:27:58.105] - Launch lazy future ... done
[08:27:58.105] run() for ‘MulticoreFuture’ ... done
[08:27:58.105] result() for MulticoreFuture ...
[08:27:58.106] plan(): Setting new future strategy stack:
[08:27:58.106] List of future strategies:
[08:27:58.106] 1. sequential:
[08:27:58.106]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:58.106]    - tweaked: FALSE
[08:27:58.106]    - call: NULL
[08:27:58.107] plan(): nbrOfWorkers() = 1
[08:27:58.110] plan(): Setting new future strategy stack:
[08:27:58.110] List of future strategies:
[08:27:58.110] 1. multicore:
[08:27:58.110]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:58.110]    - tweaked: FALSE
[08:27:58.110]    - call: plan(strategy)
[08:27:58.113] plan(): nbrOfWorkers() = 2
[08:27:58.114] result() for MulticoreFuture ...
[08:27:58.114] result() for MulticoreFuture ... done
[08:27:58.115] result() for MulticoreFuture ... done
[08:27:58.115] result() for MulticoreFuture ...
[08:27:58.115] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[08:27:58.117] getGlobalsAndPackages() ...
[08:27:58.117] Searching for globals...
[08:27:58.123] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[08:27:58.123] Searching for globals ... DONE
[08:27:58.123] Resolving globals: FALSE
[08:27:58.124] The total size of the 3 globals is 1.22 KiB (1254 bytes)
[08:27:58.124] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (633 bytes of class ‘function’), ‘inner_function’ (371 bytes of class ‘function’) and ‘outer_function’ (250 bytes of class ‘function’)
[08:27:58.125] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[08:27:58.125] 
[08:27:58.125] getGlobalsAndPackages() ... DONE
[08:27:58.125] run() for ‘Future’ ...
[08:27:58.125] - state: ‘created’
[08:27:58.126] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:58.128] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:58.128] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:58.128]   - Field: ‘label’
[08:27:58.128]   - Field: ‘local’
[08:27:58.128]   - Field: ‘owner’
[08:27:58.128]   - Field: ‘envir’
[08:27:58.128]   - Field: ‘workers’
[08:27:58.129]   - Field: ‘packages’
[08:27:58.129]   - Field: ‘gc’
[08:27:58.129]   - Field: ‘job’
[08:27:58.129]   - Field: ‘conditions’
[08:27:58.129]   - Field: ‘expr’
[08:27:58.129]   - Field: ‘uuid’
[08:27:58.129]   - Field: ‘seed’
[08:27:58.129]   - Field: ‘version’
[08:27:58.129]   - Field: ‘result’
[08:27:58.130]   - Field: ‘asynchronous’
[08:27:58.130]   - Field: ‘calls’
[08:27:58.130]   - Field: ‘globals’
[08:27:58.130]   - Field: ‘stdout’
[08:27:58.130]   - Field: ‘earlySignal’
[08:27:58.130]   - Field: ‘lazy’
[08:27:58.130]   - Field: ‘state’
[08:27:58.130] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:58.131] - Launch lazy future ...
[08:27:58.131] Packages needed by the future expression (n = 0): <none>
[08:27:58.131] Packages needed by future strategies (n = 0): <none>
[08:27:58.132] {
[08:27:58.132]     {
[08:27:58.132]         {
[08:27:58.132]             ...future.startTime <- base::Sys.time()
[08:27:58.132]             {
[08:27:58.132]                 {
[08:27:58.132]                   {
[08:27:58.132]                     {
[08:27:58.132]                       base::local({
[08:27:58.132]                         has_future <- base::requireNamespace("future", 
[08:27:58.132]                           quietly = TRUE)
[08:27:58.132]                         if (has_future) {
[08:27:58.132]                           ns <- base::getNamespace("future")
[08:27:58.132]                           version <- ns[[".package"]][["version"]]
[08:27:58.132]                           if (is.null(version)) 
[08:27:58.132]                             version <- utils::packageVersion("future")
[08:27:58.132]                         }
[08:27:58.132]                         else {
[08:27:58.132]                           version <- NULL
[08:27:58.132]                         }
[08:27:58.132]                         if (!has_future || version < "1.8.0") {
[08:27:58.132]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:58.132]                             "", base::R.version$version.string), 
[08:27:58.132]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:58.132]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:58.132]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:58.132]                               "release", "version")], collapse = " "), 
[08:27:58.132]                             hostname = base::Sys.info()[["nodename"]])
[08:27:58.132]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:58.132]                             info)
[08:27:58.132]                           info <- base::paste(info, collapse = "; ")
[08:27:58.132]                           if (!has_future) {
[08:27:58.132]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:58.132]                               info)
[08:27:58.132]                           }
[08:27:58.132]                           else {
[08:27:58.132]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:58.132]                               info, version)
[08:27:58.132]                           }
[08:27:58.132]                           base::stop(msg)
[08:27:58.132]                         }
[08:27:58.132]                       })
[08:27:58.132]                     }
[08:27:58.132]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:58.132]                     base::options(mc.cores = 1L)
[08:27:58.132]                   }
[08:27:58.132]                   ...future.strategy.old <- future::plan("list")
[08:27:58.132]                   options(future.plan = NULL)
[08:27:58.132]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:58.132]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:58.132]                 }
[08:27:58.132]                 ...future.workdir <- getwd()
[08:27:58.132]             }
[08:27:58.132]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:58.132]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:58.132]         }
[08:27:58.132]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:58.132]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:58.132]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:58.132]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:58.132]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:58.132]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:58.132]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:58.132]             base::names(...future.oldOptions))
[08:27:58.132]     }
[08:27:58.132]     if (FALSE) {
[08:27:58.132]     }
[08:27:58.132]     else {
[08:27:58.132]         if (TRUE) {
[08:27:58.132]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:58.132]                 open = "w")
[08:27:58.132]         }
[08:27:58.132]         else {
[08:27:58.132]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:58.132]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:58.132]         }
[08:27:58.132]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:58.132]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:58.132]             base::sink(type = "output", split = FALSE)
[08:27:58.132]             base::close(...future.stdout)
[08:27:58.132]         }, add = TRUE)
[08:27:58.132]     }
[08:27:58.132]     ...future.frame <- base::sys.nframe()
[08:27:58.132]     ...future.conditions <- base::list()
[08:27:58.132]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:58.132]     if (FALSE) {
[08:27:58.132]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:58.132]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:58.132]     }
[08:27:58.132]     ...future.result <- base::tryCatch({
[08:27:58.132]         base::withCallingHandlers({
[08:27:58.132]             ...future.value <- base::withVisible(base::local({
[08:27:58.132]                 withCallingHandlers({
[08:27:58.132]                   {
[08:27:58.132]                     outer_function(1L)
[08:27:58.132]                   }
[08:27:58.132]                 }, immediateCondition = function(cond) {
[08:27:58.132]                   save_rds <- function (object, pathname, ...) 
[08:27:58.132]                   {
[08:27:58.132]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:58.132]                     if (file_test("-f", pathname_tmp)) {
[08:27:58.132]                       fi_tmp <- file.info(pathname_tmp)
[08:27:58.132]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:58.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:58.132]                         fi_tmp[["mtime"]])
[08:27:58.132]                     }
[08:27:58.132]                     tryCatch({
[08:27:58.132]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:58.132]                     }, error = function(ex) {
[08:27:58.132]                       msg <- conditionMessage(ex)
[08:27:58.132]                       fi_tmp <- file.info(pathname_tmp)
[08:27:58.132]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:58.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:58.132]                         fi_tmp[["mtime"]], msg)
[08:27:58.132]                       ex$message <- msg
[08:27:58.132]                       stop(ex)
[08:27:58.132]                     })
[08:27:58.132]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:58.132]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:58.132]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:58.132]                       fi_tmp <- file.info(pathname_tmp)
[08:27:58.132]                       fi <- file.info(pathname)
[08:27:58.132]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:58.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:58.132]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:58.132]                         fi[["size"]], fi[["mtime"]])
[08:27:58.132]                       stop(msg)
[08:27:58.132]                     }
[08:27:58.132]                     invisible(pathname)
[08:27:58.132]                   }
[08:27:58.132]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:58.132]                     rootPath = tempdir()) 
[08:27:58.132]                   {
[08:27:58.132]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:58.132]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:58.132]                       tmpdir = path, fileext = ".rds")
[08:27:58.132]                     save_rds(obj, file)
[08:27:58.132]                   }
[08:27:58.132]                   saveImmediateCondition(cond, path = "/tmp/RtmpUQjont/.future/immediateConditions")
[08:27:58.132]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.132]                   {
[08:27:58.132]                     inherits <- base::inherits
[08:27:58.132]                     invokeRestart <- base::invokeRestart
[08:27:58.132]                     is.null <- base::is.null
[08:27:58.132]                     muffled <- FALSE
[08:27:58.132]                     if (inherits(cond, "message")) {
[08:27:58.132]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:58.132]                       if (muffled) 
[08:27:58.132]                         invokeRestart("muffleMessage")
[08:27:58.132]                     }
[08:27:58.132]                     else if (inherits(cond, "warning")) {
[08:27:58.132]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:58.132]                       if (muffled) 
[08:27:58.132]                         invokeRestart("muffleWarning")
[08:27:58.132]                     }
[08:27:58.132]                     else if (inherits(cond, "condition")) {
[08:27:58.132]                       if (!is.null(pattern)) {
[08:27:58.132]                         computeRestarts <- base::computeRestarts
[08:27:58.132]                         grepl <- base::grepl
[08:27:58.132]                         restarts <- computeRestarts(cond)
[08:27:58.132]                         for (restart in restarts) {
[08:27:58.132]                           name <- restart$name
[08:27:58.132]                           if (is.null(name)) 
[08:27:58.132]                             next
[08:27:58.132]                           if (!grepl(pattern, name)) 
[08:27:58.132]                             next
[08:27:58.132]                           invokeRestart(restart)
[08:27:58.132]                           muffled <- TRUE
[08:27:58.132]                           break
[08:27:58.132]                         }
[08:27:58.132]                       }
[08:27:58.132]                     }
[08:27:58.132]                     invisible(muffled)
[08:27:58.132]                   }
[08:27:58.132]                   muffleCondition(cond)
[08:27:58.132]                 })
[08:27:58.132]             }))
[08:27:58.132]             future::FutureResult(value = ...future.value$value, 
[08:27:58.132]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:58.132]                   ...future.rng), globalenv = if (FALSE) 
[08:27:58.132]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:58.132]                     ...future.globalenv.names))
[08:27:58.132]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:58.132]         }, condition = base::local({
[08:27:58.132]             c <- base::c
[08:27:58.132]             inherits <- base::inherits
[08:27:58.132]             invokeRestart <- base::invokeRestart
[08:27:58.132]             length <- base::length
[08:27:58.132]             list <- base::list
[08:27:58.132]             seq.int <- base::seq.int
[08:27:58.132]             signalCondition <- base::signalCondition
[08:27:58.132]             sys.calls <- base::sys.calls
[08:27:58.132]             `[[` <- base::`[[`
[08:27:58.132]             `+` <- base::`+`
[08:27:58.132]             `<<-` <- base::`<<-`
[08:27:58.132]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:58.132]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:58.132]                   3L)]
[08:27:58.132]             }
[08:27:58.132]             function(cond) {
[08:27:58.132]                 is_error <- inherits(cond, "error")
[08:27:58.132]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:58.132]                   NULL)
[08:27:58.132]                 if (is_error) {
[08:27:58.132]                   sessionInformation <- function() {
[08:27:58.132]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:58.132]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:58.132]                       search = base::search(), system = base::Sys.info())
[08:27:58.132]                   }
[08:27:58.132]                   ...future.conditions[[length(...future.conditions) + 
[08:27:58.132]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:58.132]                     cond$call), session = sessionInformation(), 
[08:27:58.132]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:58.132]                   signalCondition(cond)
[08:27:58.132]                 }
[08:27:58.132]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:58.132]                 "immediateCondition"))) {
[08:27:58.132]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:58.132]                   ...future.conditions[[length(...future.conditions) + 
[08:27:58.132]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:58.132]                   if (TRUE && !signal) {
[08:27:58.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.132]                     {
[08:27:58.132]                       inherits <- base::inherits
[08:27:58.132]                       invokeRestart <- base::invokeRestart
[08:27:58.132]                       is.null <- base::is.null
[08:27:58.132]                       muffled <- FALSE
[08:27:58.132]                       if (inherits(cond, "message")) {
[08:27:58.132]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:58.132]                         if (muffled) 
[08:27:58.132]                           invokeRestart("muffleMessage")
[08:27:58.132]                       }
[08:27:58.132]                       else if (inherits(cond, "warning")) {
[08:27:58.132]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:58.132]                         if (muffled) 
[08:27:58.132]                           invokeRestart("muffleWarning")
[08:27:58.132]                       }
[08:27:58.132]                       else if (inherits(cond, "condition")) {
[08:27:58.132]                         if (!is.null(pattern)) {
[08:27:58.132]                           computeRestarts <- base::computeRestarts
[08:27:58.132]                           grepl <- base::grepl
[08:27:58.132]                           restarts <- computeRestarts(cond)
[08:27:58.132]                           for (restart in restarts) {
[08:27:58.132]                             name <- restart$name
[08:27:58.132]                             if (is.null(name)) 
[08:27:58.132]                               next
[08:27:58.132]                             if (!grepl(pattern, name)) 
[08:27:58.132]                               next
[08:27:58.132]                             invokeRestart(restart)
[08:27:58.132]                             muffled <- TRUE
[08:27:58.132]                             break
[08:27:58.132]                           }
[08:27:58.132]                         }
[08:27:58.132]                       }
[08:27:58.132]                       invisible(muffled)
[08:27:58.132]                     }
[08:27:58.132]                     muffleCondition(cond, pattern = "^muffle")
[08:27:58.132]                   }
[08:27:58.132]                 }
[08:27:58.132]                 else {
[08:27:58.132]                   if (TRUE) {
[08:27:58.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.132]                     {
[08:27:58.132]                       inherits <- base::inherits
[08:27:58.132]                       invokeRestart <- base::invokeRestart
[08:27:58.132]                       is.null <- base::is.null
[08:27:58.132]                       muffled <- FALSE
[08:27:58.132]                       if (inherits(cond, "message")) {
[08:27:58.132]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:58.132]                         if (muffled) 
[08:27:58.132]                           invokeRestart("muffleMessage")
[08:27:58.132]                       }
[08:27:58.132]                       else if (inherits(cond, "warning")) {
[08:27:58.132]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:58.132]                         if (muffled) 
[08:27:58.132]                           invokeRestart("muffleWarning")
[08:27:58.132]                       }
[08:27:58.132]                       else if (inherits(cond, "condition")) {
[08:27:58.132]                         if (!is.null(pattern)) {
[08:27:58.132]                           computeRestarts <- base::computeRestarts
[08:27:58.132]                           grepl <- base::grepl
[08:27:58.132]                           restarts <- computeRestarts(cond)
[08:27:58.132]                           for (restart in restarts) {
[08:27:58.132]                             name <- restart$name
[08:27:58.132]                             if (is.null(name)) 
[08:27:58.132]                               next
[08:27:58.132]                             if (!grepl(pattern, name)) 
[08:27:58.132]                               next
[08:27:58.132]                             invokeRestart(restart)
[08:27:58.132]                             muffled <- TRUE
[08:27:58.132]                             break
[08:27:58.132]                           }
[08:27:58.132]                         }
[08:27:58.132]                       }
[08:27:58.132]                       invisible(muffled)
[08:27:58.132]                     }
[08:27:58.132]                     muffleCondition(cond, pattern = "^muffle")
[08:27:58.132]                   }
[08:27:58.132]                 }
[08:27:58.132]             }
[08:27:58.132]         }))
[08:27:58.132]     }, error = function(ex) {
[08:27:58.132]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:58.132]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:58.132]                 ...future.rng), started = ...future.startTime, 
[08:27:58.132]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:58.132]             version = "1.8"), class = "FutureResult")
[08:27:58.132]     }, finally = {
[08:27:58.132]         if (!identical(...future.workdir, getwd())) 
[08:27:58.132]             setwd(...future.workdir)
[08:27:58.132]         {
[08:27:58.132]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:58.132]                 ...future.oldOptions$nwarnings <- NULL
[08:27:58.132]             }
[08:27:58.132]             base::options(...future.oldOptions)
[08:27:58.132]             if (.Platform$OS.type == "windows") {
[08:27:58.132]                 old_names <- names(...future.oldEnvVars)
[08:27:58.132]                 envs <- base::Sys.getenv()
[08:27:58.132]                 names <- names(envs)
[08:27:58.132]                 common <- intersect(names, old_names)
[08:27:58.132]                 added <- setdiff(names, old_names)
[08:27:58.132]                 removed <- setdiff(old_names, names)
[08:27:58.132]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:58.132]                   envs[common]]
[08:27:58.132]                 NAMES <- toupper(changed)
[08:27:58.132]                 args <- list()
[08:27:58.132]                 for (kk in seq_along(NAMES)) {
[08:27:58.132]                   name <- changed[[kk]]
[08:27:58.132]                   NAME <- NAMES[[kk]]
[08:27:58.132]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.132]                     next
[08:27:58.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:58.132]                 }
[08:27:58.132]                 NAMES <- toupper(added)
[08:27:58.132]                 for (kk in seq_along(NAMES)) {
[08:27:58.132]                   name <- added[[kk]]
[08:27:58.132]                   NAME <- NAMES[[kk]]
[08:27:58.132]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.132]                     next
[08:27:58.132]                   args[[name]] <- ""
[08:27:58.132]                 }
[08:27:58.132]                 NAMES <- toupper(removed)
[08:27:58.132]                 for (kk in seq_along(NAMES)) {
[08:27:58.132]                   name <- removed[[kk]]
[08:27:58.132]                   NAME <- NAMES[[kk]]
[08:27:58.132]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.132]                     next
[08:27:58.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:58.132]                 }
[08:27:58.132]                 if (length(args) > 0) 
[08:27:58.132]                   base::do.call(base::Sys.setenv, args = args)
[08:27:58.132]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:58.132]             }
[08:27:58.132]             else {
[08:27:58.132]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:58.132]             }
[08:27:58.132]             {
[08:27:58.132]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:58.132]                   0L) {
[08:27:58.132]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:58.132]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:58.132]                   base::options(opts)
[08:27:58.132]                 }
[08:27:58.132]                 {
[08:27:58.132]                   {
[08:27:58.132]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:58.132]                     NULL
[08:27:58.132]                   }
[08:27:58.132]                   options(future.plan = NULL)
[08:27:58.132]                   if (is.na(NA_character_)) 
[08:27:58.132]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:58.132]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:58.132]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:58.132]                     .init = FALSE)
[08:27:58.132]                 }
[08:27:58.132]             }
[08:27:58.132]         }
[08:27:58.132]     })
[08:27:58.132]     if (TRUE) {
[08:27:58.132]         base::sink(type = "output", split = FALSE)
[08:27:58.132]         if (TRUE) {
[08:27:58.132]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:58.132]         }
[08:27:58.132]         else {
[08:27:58.132]             ...future.result["stdout"] <- base::list(NULL)
[08:27:58.132]         }
[08:27:58.132]         base::close(...future.stdout)
[08:27:58.132]         ...future.stdout <- NULL
[08:27:58.132]     }
[08:27:58.132]     ...future.result$conditions <- ...future.conditions
[08:27:58.132]     ...future.result$finished <- base::Sys.time()
[08:27:58.132]     ...future.result
[08:27:58.132] }
[08:27:58.134] assign_globals() ...
[08:27:58.134] List of 3
[08:27:58.134]  $ outer_function:function (x)  
[08:27:58.134]  $ map           :function (.x, .f, ...)  
[08:27:58.134]  $ inner_function:function (x)  
[08:27:58.134]  - attr(*, "where")=List of 3
[08:27:58.134]   ..$ outer_function:<environment: R_EmptyEnv> 
[08:27:58.134]   ..$ map           :<environment: R_EmptyEnv> 
[08:27:58.134]   ..$ inner_function:<environment: R_EmptyEnv> 
[08:27:58.134]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:27:58.134]  - attr(*, "resolved")= logi FALSE
[08:27:58.134]  - attr(*, "total_size")= num 1254
[08:27:58.134]  - attr(*, "already-done")= logi TRUE
[08:27:58.141] - reassign environment for ‘outer_function’
[08:27:58.141] - copied ‘outer_function’ to environment
[08:27:58.141] - reassign environment for ‘map’
[08:27:58.141] - copied ‘map’ to environment
[08:27:58.141] - reassign environment for ‘inner_function’
[08:27:58.141] - copied ‘inner_function’ to environment
[08:27:58.141] assign_globals() ... done
[08:27:58.142] requestCore(): workers = 2
[08:27:58.144] MulticoreFuture started
[08:27:58.144] - Launch lazy future ... done
[08:27:58.145] run() for ‘MulticoreFuture’ ... done
[08:27:58.145] plan(): Setting new future strategy stack:
[08:27:58.145] result() for MulticoreFuture ...
[08:27:58.145] List of future strategies:
[08:27:58.145] 1. sequential:
[08:27:58.145]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:58.145]    - tweaked: FALSE
[08:27:58.145]    - call: NULL
[08:27:58.147] plan(): nbrOfWorkers() = 1
[08:27:58.149] plan(): Setting new future strategy stack:
[08:27:58.149] List of future strategies:
[08:27:58.149] 1. multicore:
[08:27:58.149]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:58.149]    - tweaked: FALSE
[08:27:58.149]    - call: plan(strategy)
[08:27:58.153] plan(): nbrOfWorkers() = 2
[08:27:58.154] result() for MulticoreFuture ...
[08:27:58.154] result() for MulticoreFuture ... done
[08:27:58.154] result() for MulticoreFuture ... done
[08:27:58.154] result() for MulticoreFuture ...
[08:27:58.155] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
- plan('multisession') ...
[08:27:58.157] plan(): Setting new future strategy stack:
[08:27:58.157] List of future strategies:
[08:27:58.157] 1. multisession:
[08:27:58.157]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:27:58.157]    - tweaked: FALSE
[08:27:58.157]    - call: plan(strategy)
[08:27:58.157] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:27:58.157] multisession:
[08:27:58.157] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:27:58.157] - tweaked: FALSE
[08:27:58.157] - call: plan(strategy)
[08:27:58.162] getGlobalsAndPackages() ...
[08:27:58.163] Not searching for globals
[08:27:58.163] - globals: [0] <none>
[08:27:58.163] getGlobalsAndPackages() ... DONE
[08:27:58.660] Packages needed by the future expression (n = 0): <none>
[08:27:58.661] Packages needed by future strategies (n = 0): <none>
[08:27:58.661] {
[08:27:58.661]     {
[08:27:58.661]         {
[08:27:58.661]             ...future.startTime <- base::Sys.time()
[08:27:58.661]             {
[08:27:58.661]                 {
[08:27:58.661]                   {
[08:27:58.661]                     {
[08:27:58.661]                       base::local({
[08:27:58.661]                         has_future <- base::requireNamespace("future", 
[08:27:58.661]                           quietly = TRUE)
[08:27:58.661]                         if (has_future) {
[08:27:58.661]                           ns <- base::getNamespace("future")
[08:27:58.661]                           version <- ns[[".package"]][["version"]]
[08:27:58.661]                           if (is.null(version)) 
[08:27:58.661]                             version <- utils::packageVersion("future")
[08:27:58.661]                         }
[08:27:58.661]                         else {
[08:27:58.661]                           version <- NULL
[08:27:58.661]                         }
[08:27:58.661]                         if (!has_future || version < "1.8.0") {
[08:27:58.661]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:58.661]                             "", base::R.version$version.string), 
[08:27:58.661]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:58.661]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:58.661]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:58.661]                               "release", "version")], collapse = " "), 
[08:27:58.661]                             hostname = base::Sys.info()[["nodename"]])
[08:27:58.661]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:58.661]                             info)
[08:27:58.661]                           info <- base::paste(info, collapse = "; ")
[08:27:58.661]                           if (!has_future) {
[08:27:58.661]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:58.661]                               info)
[08:27:58.661]                           }
[08:27:58.661]                           else {
[08:27:58.661]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:58.661]                               info, version)
[08:27:58.661]                           }
[08:27:58.661]                           base::stop(msg)
[08:27:58.661]                         }
[08:27:58.661]                       })
[08:27:58.661]                     }
[08:27:58.661]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:58.661]                     base::options(mc.cores = 1L)
[08:27:58.661]                   }
[08:27:58.661]                   ...future.strategy.old <- future::plan("list")
[08:27:58.661]                   options(future.plan = NULL)
[08:27:58.661]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:58.661]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:58.661]                 }
[08:27:58.661]                 ...future.workdir <- getwd()
[08:27:58.661]             }
[08:27:58.661]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:58.661]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:58.661]         }
[08:27:58.661]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:58.661]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:58.661]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:58.661]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:58.661]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:58.661]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:58.661]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:58.661]             base::names(...future.oldOptions))
[08:27:58.661]     }
[08:27:58.661]     if (FALSE) {
[08:27:58.661]     }
[08:27:58.661]     else {
[08:27:58.661]         if (TRUE) {
[08:27:58.661]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:58.661]                 open = "w")
[08:27:58.661]         }
[08:27:58.661]         else {
[08:27:58.661]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:58.661]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:58.661]         }
[08:27:58.661]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:58.661]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:58.661]             base::sink(type = "output", split = FALSE)
[08:27:58.661]             base::close(...future.stdout)
[08:27:58.661]         }, add = TRUE)
[08:27:58.661]     }
[08:27:58.661]     ...future.frame <- base::sys.nframe()
[08:27:58.661]     ...future.conditions <- base::list()
[08:27:58.661]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:58.661]     if (FALSE) {
[08:27:58.661]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:58.661]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:58.661]     }
[08:27:58.661]     ...future.result <- base::tryCatch({
[08:27:58.661]         base::withCallingHandlers({
[08:27:58.661]             ...future.value <- base::withVisible(base::local({
[08:27:58.661]                 ...future.makeSendCondition <- base::local({
[08:27:58.661]                   sendCondition <- NULL
[08:27:58.661]                   function(frame = 1L) {
[08:27:58.661]                     if (is.function(sendCondition)) 
[08:27:58.661]                       return(sendCondition)
[08:27:58.661]                     ns <- getNamespace("parallel")
[08:27:58.661]                     if (exists("sendData", mode = "function", 
[08:27:58.661]                       envir = ns)) {
[08:27:58.661]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:58.661]                         envir = ns)
[08:27:58.661]                       envir <- sys.frame(frame)
[08:27:58.661]                       master <- NULL
[08:27:58.661]                       while (!identical(envir, .GlobalEnv) && 
[08:27:58.661]                         !identical(envir, emptyenv())) {
[08:27:58.661]                         if (exists("master", mode = "list", envir = envir, 
[08:27:58.661]                           inherits = FALSE)) {
[08:27:58.661]                           master <- get("master", mode = "list", 
[08:27:58.661]                             envir = envir, inherits = FALSE)
[08:27:58.661]                           if (inherits(master, c("SOCKnode", 
[08:27:58.661]                             "SOCK0node"))) {
[08:27:58.661]                             sendCondition <<- function(cond) {
[08:27:58.661]                               data <- list(type = "VALUE", value = cond, 
[08:27:58.661]                                 success = TRUE)
[08:27:58.661]                               parallel_sendData(master, data)
[08:27:58.661]                             }
[08:27:58.661]                             return(sendCondition)
[08:27:58.661]                           }
[08:27:58.661]                         }
[08:27:58.661]                         frame <- frame + 1L
[08:27:58.661]                         envir <- sys.frame(frame)
[08:27:58.661]                       }
[08:27:58.661]                     }
[08:27:58.661]                     sendCondition <<- function(cond) NULL
[08:27:58.661]                   }
[08:27:58.661]                 })
[08:27:58.661]                 withCallingHandlers({
[08:27:58.661]                   NA
[08:27:58.661]                 }, immediateCondition = function(cond) {
[08:27:58.661]                   sendCondition <- ...future.makeSendCondition()
[08:27:58.661]                   sendCondition(cond)
[08:27:58.661]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.661]                   {
[08:27:58.661]                     inherits <- base::inherits
[08:27:58.661]                     invokeRestart <- base::invokeRestart
[08:27:58.661]                     is.null <- base::is.null
[08:27:58.661]                     muffled <- FALSE
[08:27:58.661]                     if (inherits(cond, "message")) {
[08:27:58.661]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:58.661]                       if (muffled) 
[08:27:58.661]                         invokeRestart("muffleMessage")
[08:27:58.661]                     }
[08:27:58.661]                     else if (inherits(cond, "warning")) {
[08:27:58.661]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:58.661]                       if (muffled) 
[08:27:58.661]                         invokeRestart("muffleWarning")
[08:27:58.661]                     }
[08:27:58.661]                     else if (inherits(cond, "condition")) {
[08:27:58.661]                       if (!is.null(pattern)) {
[08:27:58.661]                         computeRestarts <- base::computeRestarts
[08:27:58.661]                         grepl <- base::grepl
[08:27:58.661]                         restarts <- computeRestarts(cond)
[08:27:58.661]                         for (restart in restarts) {
[08:27:58.661]                           name <- restart$name
[08:27:58.661]                           if (is.null(name)) 
[08:27:58.661]                             next
[08:27:58.661]                           if (!grepl(pattern, name)) 
[08:27:58.661]                             next
[08:27:58.661]                           invokeRestart(restart)
[08:27:58.661]                           muffled <- TRUE
[08:27:58.661]                           break
[08:27:58.661]                         }
[08:27:58.661]                       }
[08:27:58.661]                     }
[08:27:58.661]                     invisible(muffled)
[08:27:58.661]                   }
[08:27:58.661]                   muffleCondition(cond)
[08:27:58.661]                 })
[08:27:58.661]             }))
[08:27:58.661]             future::FutureResult(value = ...future.value$value, 
[08:27:58.661]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:58.661]                   ...future.rng), globalenv = if (FALSE) 
[08:27:58.661]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:58.661]                     ...future.globalenv.names))
[08:27:58.661]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:58.661]         }, condition = base::local({
[08:27:58.661]             c <- base::c
[08:27:58.661]             inherits <- base::inherits
[08:27:58.661]             invokeRestart <- base::invokeRestart
[08:27:58.661]             length <- base::length
[08:27:58.661]             list <- base::list
[08:27:58.661]             seq.int <- base::seq.int
[08:27:58.661]             signalCondition <- base::signalCondition
[08:27:58.661]             sys.calls <- base::sys.calls
[08:27:58.661]             `[[` <- base::`[[`
[08:27:58.661]             `+` <- base::`+`
[08:27:58.661]             `<<-` <- base::`<<-`
[08:27:58.661]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:58.661]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:58.661]                   3L)]
[08:27:58.661]             }
[08:27:58.661]             function(cond) {
[08:27:58.661]                 is_error <- inherits(cond, "error")
[08:27:58.661]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:58.661]                   NULL)
[08:27:58.661]                 if (is_error) {
[08:27:58.661]                   sessionInformation <- function() {
[08:27:58.661]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:58.661]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:58.661]                       search = base::search(), system = base::Sys.info())
[08:27:58.661]                   }
[08:27:58.661]                   ...future.conditions[[length(...future.conditions) + 
[08:27:58.661]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:58.661]                     cond$call), session = sessionInformation(), 
[08:27:58.661]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:58.661]                   signalCondition(cond)
[08:27:58.661]                 }
[08:27:58.661]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:58.661]                 "immediateCondition"))) {
[08:27:58.661]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:58.661]                   ...future.conditions[[length(...future.conditions) + 
[08:27:58.661]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:58.661]                   if (TRUE && !signal) {
[08:27:58.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.661]                     {
[08:27:58.661]                       inherits <- base::inherits
[08:27:58.661]                       invokeRestart <- base::invokeRestart
[08:27:58.661]                       is.null <- base::is.null
[08:27:58.661]                       muffled <- FALSE
[08:27:58.661]                       if (inherits(cond, "message")) {
[08:27:58.661]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:58.661]                         if (muffled) 
[08:27:58.661]                           invokeRestart("muffleMessage")
[08:27:58.661]                       }
[08:27:58.661]                       else if (inherits(cond, "warning")) {
[08:27:58.661]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:58.661]                         if (muffled) 
[08:27:58.661]                           invokeRestart("muffleWarning")
[08:27:58.661]                       }
[08:27:58.661]                       else if (inherits(cond, "condition")) {
[08:27:58.661]                         if (!is.null(pattern)) {
[08:27:58.661]                           computeRestarts <- base::computeRestarts
[08:27:58.661]                           grepl <- base::grepl
[08:27:58.661]                           restarts <- computeRestarts(cond)
[08:27:58.661]                           for (restart in restarts) {
[08:27:58.661]                             name <- restart$name
[08:27:58.661]                             if (is.null(name)) 
[08:27:58.661]                               next
[08:27:58.661]                             if (!grepl(pattern, name)) 
[08:27:58.661]                               next
[08:27:58.661]                             invokeRestart(restart)
[08:27:58.661]                             muffled <- TRUE
[08:27:58.661]                             break
[08:27:58.661]                           }
[08:27:58.661]                         }
[08:27:58.661]                       }
[08:27:58.661]                       invisible(muffled)
[08:27:58.661]                     }
[08:27:58.661]                     muffleCondition(cond, pattern = "^muffle")
[08:27:58.661]                   }
[08:27:58.661]                 }
[08:27:58.661]                 else {
[08:27:58.661]                   if (TRUE) {
[08:27:58.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.661]                     {
[08:27:58.661]                       inherits <- base::inherits
[08:27:58.661]                       invokeRestart <- base::invokeRestart
[08:27:58.661]                       is.null <- base::is.null
[08:27:58.661]                       muffled <- FALSE
[08:27:58.661]                       if (inherits(cond, "message")) {
[08:27:58.661]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:58.661]                         if (muffled) 
[08:27:58.661]                           invokeRestart("muffleMessage")
[08:27:58.661]                       }
[08:27:58.661]                       else if (inherits(cond, "warning")) {
[08:27:58.661]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:58.661]                         if (muffled) 
[08:27:58.661]                           invokeRestart("muffleWarning")
[08:27:58.661]                       }
[08:27:58.661]                       else if (inherits(cond, "condition")) {
[08:27:58.661]                         if (!is.null(pattern)) {
[08:27:58.661]                           computeRestarts <- base::computeRestarts
[08:27:58.661]                           grepl <- base::grepl
[08:27:58.661]                           restarts <- computeRestarts(cond)
[08:27:58.661]                           for (restart in restarts) {
[08:27:58.661]                             name <- restart$name
[08:27:58.661]                             if (is.null(name)) 
[08:27:58.661]                               next
[08:27:58.661]                             if (!grepl(pattern, name)) 
[08:27:58.661]                               next
[08:27:58.661]                             invokeRestart(restart)
[08:27:58.661]                             muffled <- TRUE
[08:27:58.661]                             break
[08:27:58.661]                           }
[08:27:58.661]                         }
[08:27:58.661]                       }
[08:27:58.661]                       invisible(muffled)
[08:27:58.661]                     }
[08:27:58.661]                     muffleCondition(cond, pattern = "^muffle")
[08:27:58.661]                   }
[08:27:58.661]                 }
[08:27:58.661]             }
[08:27:58.661]         }))
[08:27:58.661]     }, error = function(ex) {
[08:27:58.661]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:58.661]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:58.661]                 ...future.rng), started = ...future.startTime, 
[08:27:58.661]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:58.661]             version = "1.8"), class = "FutureResult")
[08:27:58.661]     }, finally = {
[08:27:58.661]         if (!identical(...future.workdir, getwd())) 
[08:27:58.661]             setwd(...future.workdir)
[08:27:58.661]         {
[08:27:58.661]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:58.661]                 ...future.oldOptions$nwarnings <- NULL
[08:27:58.661]             }
[08:27:58.661]             base::options(...future.oldOptions)
[08:27:58.661]             if (.Platform$OS.type == "windows") {
[08:27:58.661]                 old_names <- names(...future.oldEnvVars)
[08:27:58.661]                 envs <- base::Sys.getenv()
[08:27:58.661]                 names <- names(envs)
[08:27:58.661]                 common <- intersect(names, old_names)
[08:27:58.661]                 added <- setdiff(names, old_names)
[08:27:58.661]                 removed <- setdiff(old_names, names)
[08:27:58.661]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:58.661]                   envs[common]]
[08:27:58.661]                 NAMES <- toupper(changed)
[08:27:58.661]                 args <- list()
[08:27:58.661]                 for (kk in seq_along(NAMES)) {
[08:27:58.661]                   name <- changed[[kk]]
[08:27:58.661]                   NAME <- NAMES[[kk]]
[08:27:58.661]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.661]                     next
[08:27:58.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:58.661]                 }
[08:27:58.661]                 NAMES <- toupper(added)
[08:27:58.661]                 for (kk in seq_along(NAMES)) {
[08:27:58.661]                   name <- added[[kk]]
[08:27:58.661]                   NAME <- NAMES[[kk]]
[08:27:58.661]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.661]                     next
[08:27:58.661]                   args[[name]] <- ""
[08:27:58.661]                 }
[08:27:58.661]                 NAMES <- toupper(removed)
[08:27:58.661]                 for (kk in seq_along(NAMES)) {
[08:27:58.661]                   name <- removed[[kk]]
[08:27:58.661]                   NAME <- NAMES[[kk]]
[08:27:58.661]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.661]                     next
[08:27:58.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:58.661]                 }
[08:27:58.661]                 if (length(args) > 0) 
[08:27:58.661]                   base::do.call(base::Sys.setenv, args = args)
[08:27:58.661]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:58.661]             }
[08:27:58.661]             else {
[08:27:58.661]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:58.661]             }
[08:27:58.661]             {
[08:27:58.661]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:58.661]                   0L) {
[08:27:58.661]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:58.661]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:58.661]                   base::options(opts)
[08:27:58.661]                 }
[08:27:58.661]                 {
[08:27:58.661]                   {
[08:27:58.661]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:58.661]                     NULL
[08:27:58.661]                   }
[08:27:58.661]                   options(future.plan = NULL)
[08:27:58.661]                   if (is.na(NA_character_)) 
[08:27:58.661]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:58.661]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:58.661]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:58.661]                     .init = FALSE)
[08:27:58.661]                 }
[08:27:58.661]             }
[08:27:58.661]         }
[08:27:58.661]     })
[08:27:58.661]     if (TRUE) {
[08:27:58.661]         base::sink(type = "output", split = FALSE)
[08:27:58.661]         if (TRUE) {
[08:27:58.661]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:58.661]         }
[08:27:58.661]         else {
[08:27:58.661]             ...future.result["stdout"] <- base::list(NULL)
[08:27:58.661]         }
[08:27:58.661]         base::close(...future.stdout)
[08:27:58.661]         ...future.stdout <- NULL
[08:27:58.661]     }
[08:27:58.661]     ...future.result$conditions <- ...future.conditions
[08:27:58.661]     ...future.result$finished <- base::Sys.time()
[08:27:58.661]     ...future.result
[08:27:58.661] }
[08:27:58.713] MultisessionFuture started
[08:27:58.713] result() for ClusterFuture ...
[08:27:58.714] receiveMessageFromWorker() for ClusterFuture ...
[08:27:58.714] - Validating connection of MultisessionFuture
[08:27:58.744] - received message: FutureResult
[08:27:58.744] - Received FutureResult
[08:27:58.744] - Erased future from FutureRegistry
[08:27:58.744] result() for ClusterFuture ...
[08:27:58.744] - result already collected: FutureResult
[08:27:58.744] result() for ClusterFuture ... done
[08:27:58.744] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:58.745] result() for ClusterFuture ... done
[08:27:58.745] result() for ClusterFuture ...
[08:27:58.745] - result already collected: FutureResult
[08:27:58.745] result() for ClusterFuture ... done
[08:27:58.745] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:27:58.746] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[08:27:58.747] getGlobalsAndPackages() ...
[08:27:58.747] Searching for globals...
[08:27:58.748] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[08:27:58.748] Searching for globals ... DONE
[08:27:58.748] Resolving globals: FALSE
[08:27:58.749] The total size of the 2 globals is 401 bytes (401 bytes)
[08:27:58.749] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[08:27:58.749] - globals: [2] ‘weight’, ‘group’
[08:27:58.750] - packages: [1] ‘stats’
[08:27:58.750] getGlobalsAndPackages() ... DONE
[08:27:58.750] run() for ‘Future’ ...
[08:27:58.750] - state: ‘created’
[08:27:58.750] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:58.764] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:58.764] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:58.764]   - Field: ‘node’
[08:27:58.764]   - Field: ‘label’
[08:27:58.764]   - Field: ‘local’
[08:27:58.764]   - Field: ‘owner’
[08:27:58.764]   - Field: ‘envir’
[08:27:58.764]   - Field: ‘workers’
[08:27:58.765]   - Field: ‘packages’
[08:27:58.765]   - Field: ‘gc’
[08:27:58.765]   - Field: ‘conditions’
[08:27:58.765]   - Field: ‘persistent’
[08:27:58.765]   - Field: ‘expr’
[08:27:58.765]   - Field: ‘uuid’
[08:27:58.765]   - Field: ‘seed’
[08:27:58.765]   - Field: ‘version’
[08:27:58.765]   - Field: ‘result’
[08:27:58.765]   - Field: ‘asynchronous’
[08:27:58.765]   - Field: ‘calls’
[08:27:58.765]   - Field: ‘globals’
[08:27:58.766]   - Field: ‘stdout’
[08:27:58.766]   - Field: ‘earlySignal’
[08:27:58.766]   - Field: ‘lazy’
[08:27:58.766]   - Field: ‘state’
[08:27:58.766] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:58.766] - Launch lazy future ...
[08:27:58.766] Packages needed by the future expression (n = 1): ‘stats’
[08:27:58.766] Packages needed by future strategies (n = 0): <none>
[08:27:58.767] {
[08:27:58.767]     {
[08:27:58.767]         {
[08:27:58.767]             ...future.startTime <- base::Sys.time()
[08:27:58.767]             {
[08:27:58.767]                 {
[08:27:58.767]                   {
[08:27:58.767]                     {
[08:27:58.767]                       {
[08:27:58.767]                         base::local({
[08:27:58.767]                           has_future <- base::requireNamespace("future", 
[08:27:58.767]                             quietly = TRUE)
[08:27:58.767]                           if (has_future) {
[08:27:58.767]                             ns <- base::getNamespace("future")
[08:27:58.767]                             version <- ns[[".package"]][["version"]]
[08:27:58.767]                             if (is.null(version)) 
[08:27:58.767]                               version <- utils::packageVersion("future")
[08:27:58.767]                           }
[08:27:58.767]                           else {
[08:27:58.767]                             version <- NULL
[08:27:58.767]                           }
[08:27:58.767]                           if (!has_future || version < "1.8.0") {
[08:27:58.767]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:58.767]                               "", base::R.version$version.string), 
[08:27:58.767]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:58.767]                                 base::R.version$platform, 8 * 
[08:27:58.767]                                   base::.Machine$sizeof.pointer), 
[08:27:58.767]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:58.767]                                 "release", "version")], collapse = " "), 
[08:27:58.767]                               hostname = base::Sys.info()[["nodename"]])
[08:27:58.767]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:58.767]                               info)
[08:27:58.767]                             info <- base::paste(info, collapse = "; ")
[08:27:58.767]                             if (!has_future) {
[08:27:58.767]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:58.767]                                 info)
[08:27:58.767]                             }
[08:27:58.767]                             else {
[08:27:58.767]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:58.767]                                 info, version)
[08:27:58.767]                             }
[08:27:58.767]                             base::stop(msg)
[08:27:58.767]                           }
[08:27:58.767]                         })
[08:27:58.767]                       }
[08:27:58.767]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:58.767]                       base::options(mc.cores = 1L)
[08:27:58.767]                     }
[08:27:58.767]                     base::local({
[08:27:58.767]                       for (pkg in "stats") {
[08:27:58.767]                         base::loadNamespace(pkg)
[08:27:58.767]                         base::library(pkg, character.only = TRUE)
[08:27:58.767]                       }
[08:27:58.767]                     })
[08:27:58.767]                   }
[08:27:58.767]                   ...future.strategy.old <- future::plan("list")
[08:27:58.767]                   options(future.plan = NULL)
[08:27:58.767]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:58.767]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:58.767]                 }
[08:27:58.767]                 ...future.workdir <- getwd()
[08:27:58.767]             }
[08:27:58.767]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:58.767]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:58.767]         }
[08:27:58.767]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:58.767]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:58.767]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:58.767]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:58.767]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:58.767]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:58.767]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:58.767]             base::names(...future.oldOptions))
[08:27:58.767]     }
[08:27:58.767]     if (FALSE) {
[08:27:58.767]     }
[08:27:58.767]     else {
[08:27:58.767]         if (TRUE) {
[08:27:58.767]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:58.767]                 open = "w")
[08:27:58.767]         }
[08:27:58.767]         else {
[08:27:58.767]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:58.767]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:58.767]         }
[08:27:58.767]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:58.767]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:58.767]             base::sink(type = "output", split = FALSE)
[08:27:58.767]             base::close(...future.stdout)
[08:27:58.767]         }, add = TRUE)
[08:27:58.767]     }
[08:27:58.767]     ...future.frame <- base::sys.nframe()
[08:27:58.767]     ...future.conditions <- base::list()
[08:27:58.767]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:58.767]     if (FALSE) {
[08:27:58.767]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:58.767]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:58.767]     }
[08:27:58.767]     ...future.result <- base::tryCatch({
[08:27:58.767]         base::withCallingHandlers({
[08:27:58.767]             ...future.value <- base::withVisible(base::local({
[08:27:58.767]                 ...future.makeSendCondition <- base::local({
[08:27:58.767]                   sendCondition <- NULL
[08:27:58.767]                   function(frame = 1L) {
[08:27:58.767]                     if (is.function(sendCondition)) 
[08:27:58.767]                       return(sendCondition)
[08:27:58.767]                     ns <- getNamespace("parallel")
[08:27:58.767]                     if (exists("sendData", mode = "function", 
[08:27:58.767]                       envir = ns)) {
[08:27:58.767]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:58.767]                         envir = ns)
[08:27:58.767]                       envir <- sys.frame(frame)
[08:27:58.767]                       master <- NULL
[08:27:58.767]                       while (!identical(envir, .GlobalEnv) && 
[08:27:58.767]                         !identical(envir, emptyenv())) {
[08:27:58.767]                         if (exists("master", mode = "list", envir = envir, 
[08:27:58.767]                           inherits = FALSE)) {
[08:27:58.767]                           master <- get("master", mode = "list", 
[08:27:58.767]                             envir = envir, inherits = FALSE)
[08:27:58.767]                           if (inherits(master, c("SOCKnode", 
[08:27:58.767]                             "SOCK0node"))) {
[08:27:58.767]                             sendCondition <<- function(cond) {
[08:27:58.767]                               data <- list(type = "VALUE", value = cond, 
[08:27:58.767]                                 success = TRUE)
[08:27:58.767]                               parallel_sendData(master, data)
[08:27:58.767]                             }
[08:27:58.767]                             return(sendCondition)
[08:27:58.767]                           }
[08:27:58.767]                         }
[08:27:58.767]                         frame <- frame + 1L
[08:27:58.767]                         envir <- sys.frame(frame)
[08:27:58.767]                       }
[08:27:58.767]                     }
[08:27:58.767]                     sendCondition <<- function(cond) NULL
[08:27:58.767]                   }
[08:27:58.767]                 })
[08:27:58.767]                 withCallingHandlers({
[08:27:58.767]                   {
[08:27:58.767]                     lm(weight ~ group - 1)
[08:27:58.767]                   }
[08:27:58.767]                 }, immediateCondition = function(cond) {
[08:27:58.767]                   sendCondition <- ...future.makeSendCondition()
[08:27:58.767]                   sendCondition(cond)
[08:27:58.767]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.767]                   {
[08:27:58.767]                     inherits <- base::inherits
[08:27:58.767]                     invokeRestart <- base::invokeRestart
[08:27:58.767]                     is.null <- base::is.null
[08:27:58.767]                     muffled <- FALSE
[08:27:58.767]                     if (inherits(cond, "message")) {
[08:27:58.767]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:58.767]                       if (muffled) 
[08:27:58.767]                         invokeRestart("muffleMessage")
[08:27:58.767]                     }
[08:27:58.767]                     else if (inherits(cond, "warning")) {
[08:27:58.767]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:58.767]                       if (muffled) 
[08:27:58.767]                         invokeRestart("muffleWarning")
[08:27:58.767]                     }
[08:27:58.767]                     else if (inherits(cond, "condition")) {
[08:27:58.767]                       if (!is.null(pattern)) {
[08:27:58.767]                         computeRestarts <- base::computeRestarts
[08:27:58.767]                         grepl <- base::grepl
[08:27:58.767]                         restarts <- computeRestarts(cond)
[08:27:58.767]                         for (restart in restarts) {
[08:27:58.767]                           name <- restart$name
[08:27:58.767]                           if (is.null(name)) 
[08:27:58.767]                             next
[08:27:58.767]                           if (!grepl(pattern, name)) 
[08:27:58.767]                             next
[08:27:58.767]                           invokeRestart(restart)
[08:27:58.767]                           muffled <- TRUE
[08:27:58.767]                           break
[08:27:58.767]                         }
[08:27:58.767]                       }
[08:27:58.767]                     }
[08:27:58.767]                     invisible(muffled)
[08:27:58.767]                   }
[08:27:58.767]                   muffleCondition(cond)
[08:27:58.767]                 })
[08:27:58.767]             }))
[08:27:58.767]             future::FutureResult(value = ...future.value$value, 
[08:27:58.767]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:58.767]                   ...future.rng), globalenv = if (FALSE) 
[08:27:58.767]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:58.767]                     ...future.globalenv.names))
[08:27:58.767]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:58.767]         }, condition = base::local({
[08:27:58.767]             c <- base::c
[08:27:58.767]             inherits <- base::inherits
[08:27:58.767]             invokeRestart <- base::invokeRestart
[08:27:58.767]             length <- base::length
[08:27:58.767]             list <- base::list
[08:27:58.767]             seq.int <- base::seq.int
[08:27:58.767]             signalCondition <- base::signalCondition
[08:27:58.767]             sys.calls <- base::sys.calls
[08:27:58.767]             `[[` <- base::`[[`
[08:27:58.767]             `+` <- base::`+`
[08:27:58.767]             `<<-` <- base::`<<-`
[08:27:58.767]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:58.767]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:58.767]                   3L)]
[08:27:58.767]             }
[08:27:58.767]             function(cond) {
[08:27:58.767]                 is_error <- inherits(cond, "error")
[08:27:58.767]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:58.767]                   NULL)
[08:27:58.767]                 if (is_error) {
[08:27:58.767]                   sessionInformation <- function() {
[08:27:58.767]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:58.767]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:58.767]                       search = base::search(), system = base::Sys.info())
[08:27:58.767]                   }
[08:27:58.767]                   ...future.conditions[[length(...future.conditions) + 
[08:27:58.767]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:58.767]                     cond$call), session = sessionInformation(), 
[08:27:58.767]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:58.767]                   signalCondition(cond)
[08:27:58.767]                 }
[08:27:58.767]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:58.767]                 "immediateCondition"))) {
[08:27:58.767]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:58.767]                   ...future.conditions[[length(...future.conditions) + 
[08:27:58.767]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:58.767]                   if (TRUE && !signal) {
[08:27:58.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.767]                     {
[08:27:58.767]                       inherits <- base::inherits
[08:27:58.767]                       invokeRestart <- base::invokeRestart
[08:27:58.767]                       is.null <- base::is.null
[08:27:58.767]                       muffled <- FALSE
[08:27:58.767]                       if (inherits(cond, "message")) {
[08:27:58.767]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:58.767]                         if (muffled) 
[08:27:58.767]                           invokeRestart("muffleMessage")
[08:27:58.767]                       }
[08:27:58.767]                       else if (inherits(cond, "warning")) {
[08:27:58.767]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:58.767]                         if (muffled) 
[08:27:58.767]                           invokeRestart("muffleWarning")
[08:27:58.767]                       }
[08:27:58.767]                       else if (inherits(cond, "condition")) {
[08:27:58.767]                         if (!is.null(pattern)) {
[08:27:58.767]                           computeRestarts <- base::computeRestarts
[08:27:58.767]                           grepl <- base::grepl
[08:27:58.767]                           restarts <- computeRestarts(cond)
[08:27:58.767]                           for (restart in restarts) {
[08:27:58.767]                             name <- restart$name
[08:27:58.767]                             if (is.null(name)) 
[08:27:58.767]                               next
[08:27:58.767]                             if (!grepl(pattern, name)) 
[08:27:58.767]                               next
[08:27:58.767]                             invokeRestart(restart)
[08:27:58.767]                             muffled <- TRUE
[08:27:58.767]                             break
[08:27:58.767]                           }
[08:27:58.767]                         }
[08:27:58.767]                       }
[08:27:58.767]                       invisible(muffled)
[08:27:58.767]                     }
[08:27:58.767]                     muffleCondition(cond, pattern = "^muffle")
[08:27:58.767]                   }
[08:27:58.767]                 }
[08:27:58.767]                 else {
[08:27:58.767]                   if (TRUE) {
[08:27:58.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.767]                     {
[08:27:58.767]                       inherits <- base::inherits
[08:27:58.767]                       invokeRestart <- base::invokeRestart
[08:27:58.767]                       is.null <- base::is.null
[08:27:58.767]                       muffled <- FALSE
[08:27:58.767]                       if (inherits(cond, "message")) {
[08:27:58.767]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:58.767]                         if (muffled) 
[08:27:58.767]                           invokeRestart("muffleMessage")
[08:27:58.767]                       }
[08:27:58.767]                       else if (inherits(cond, "warning")) {
[08:27:58.767]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:58.767]                         if (muffled) 
[08:27:58.767]                           invokeRestart("muffleWarning")
[08:27:58.767]                       }
[08:27:58.767]                       else if (inherits(cond, "condition")) {
[08:27:58.767]                         if (!is.null(pattern)) {
[08:27:58.767]                           computeRestarts <- base::computeRestarts
[08:27:58.767]                           grepl <- base::grepl
[08:27:58.767]                           restarts <- computeRestarts(cond)
[08:27:58.767]                           for (restart in restarts) {
[08:27:58.767]                             name <- restart$name
[08:27:58.767]                             if (is.null(name)) 
[08:27:58.767]                               next
[08:27:58.767]                             if (!grepl(pattern, name)) 
[08:27:58.767]                               next
[08:27:58.767]                             invokeRestart(restart)
[08:27:58.767]                             muffled <- TRUE
[08:27:58.767]                             break
[08:27:58.767]                           }
[08:27:58.767]                         }
[08:27:58.767]                       }
[08:27:58.767]                       invisible(muffled)
[08:27:58.767]                     }
[08:27:58.767]                     muffleCondition(cond, pattern = "^muffle")
[08:27:58.767]                   }
[08:27:58.767]                 }
[08:27:58.767]             }
[08:27:58.767]         }))
[08:27:58.767]     }, error = function(ex) {
[08:27:58.767]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:58.767]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:58.767]                 ...future.rng), started = ...future.startTime, 
[08:27:58.767]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:58.767]             version = "1.8"), class = "FutureResult")
[08:27:58.767]     }, finally = {
[08:27:58.767]         if (!identical(...future.workdir, getwd())) 
[08:27:58.767]             setwd(...future.workdir)
[08:27:58.767]         {
[08:27:58.767]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:58.767]                 ...future.oldOptions$nwarnings <- NULL
[08:27:58.767]             }
[08:27:58.767]             base::options(...future.oldOptions)
[08:27:58.767]             if (.Platform$OS.type == "windows") {
[08:27:58.767]                 old_names <- names(...future.oldEnvVars)
[08:27:58.767]                 envs <- base::Sys.getenv()
[08:27:58.767]                 names <- names(envs)
[08:27:58.767]                 common <- intersect(names, old_names)
[08:27:58.767]                 added <- setdiff(names, old_names)
[08:27:58.767]                 removed <- setdiff(old_names, names)
[08:27:58.767]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:58.767]                   envs[common]]
[08:27:58.767]                 NAMES <- toupper(changed)
[08:27:58.767]                 args <- list()
[08:27:58.767]                 for (kk in seq_along(NAMES)) {
[08:27:58.767]                   name <- changed[[kk]]
[08:27:58.767]                   NAME <- NAMES[[kk]]
[08:27:58.767]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.767]                     next
[08:27:58.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:58.767]                 }
[08:27:58.767]                 NAMES <- toupper(added)
[08:27:58.767]                 for (kk in seq_along(NAMES)) {
[08:27:58.767]                   name <- added[[kk]]
[08:27:58.767]                   NAME <- NAMES[[kk]]
[08:27:58.767]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.767]                     next
[08:27:58.767]                   args[[name]] <- ""
[08:27:58.767]                 }
[08:27:58.767]                 NAMES <- toupper(removed)
[08:27:58.767]                 for (kk in seq_along(NAMES)) {
[08:27:58.767]                   name <- removed[[kk]]
[08:27:58.767]                   NAME <- NAMES[[kk]]
[08:27:58.767]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.767]                     next
[08:27:58.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:58.767]                 }
[08:27:58.767]                 if (length(args) > 0) 
[08:27:58.767]                   base::do.call(base::Sys.setenv, args = args)
[08:27:58.767]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:58.767]             }
[08:27:58.767]             else {
[08:27:58.767]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:58.767]             }
[08:27:58.767]             {
[08:27:58.767]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:58.767]                   0L) {
[08:27:58.767]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:58.767]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:58.767]                   base::options(opts)
[08:27:58.767]                 }
[08:27:58.767]                 {
[08:27:58.767]                   {
[08:27:58.767]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:58.767]                     NULL
[08:27:58.767]                   }
[08:27:58.767]                   options(future.plan = NULL)
[08:27:58.767]                   if (is.na(NA_character_)) 
[08:27:58.767]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:58.767]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:58.767]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:58.767]                     .init = FALSE)
[08:27:58.767]                 }
[08:27:58.767]             }
[08:27:58.767]         }
[08:27:58.767]     })
[08:27:58.767]     if (TRUE) {
[08:27:58.767]         base::sink(type = "output", split = FALSE)
[08:27:58.767]         if (TRUE) {
[08:27:58.767]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:58.767]         }
[08:27:58.767]         else {
[08:27:58.767]             ...future.result["stdout"] <- base::list(NULL)
[08:27:58.767]         }
[08:27:58.767]         base::close(...future.stdout)
[08:27:58.767]         ...future.stdout <- NULL
[08:27:58.767]     }
[08:27:58.767]     ...future.result$conditions <- ...future.conditions
[08:27:58.767]     ...future.result$finished <- base::Sys.time()
[08:27:58.767]     ...future.result
[08:27:58.767] }
[08:27:58.770] Exporting 2 global objects (712 bytes) to cluster node #1 ...
[08:27:58.770] Exporting ‘weight’ (191 bytes) to cluster node #1 ...
[08:27:58.770] Exporting ‘weight’ (191 bytes) to cluster node #1 ... DONE
[08:27:58.770] Exporting ‘group’ (210 bytes) to cluster node #1 ...
[08:27:58.771] Exporting ‘group’ (210 bytes) to cluster node #1 ... DONE
[08:27:58.771] Exporting 2 global objects (712 bytes) to cluster node #1 ... DONE
[08:27:58.771] MultisessionFuture started
[08:27:58.771] - Launch lazy future ... done
[08:27:58.771] run() for ‘MultisessionFuture’ ... done
[08:27:58.771] result() for ClusterFuture ...
[08:27:58.772] receiveMessageFromWorker() for ClusterFuture ...
[08:27:58.772] - Validating connection of MultisessionFuture
[08:27:58.819] - received message: FutureResult
[08:27:58.820] - Received FutureResult
[08:27:58.820] - Erased future from FutureRegistry
[08:27:58.820] result() for ClusterFuture ...
[08:27:58.820] - result already collected: FutureResult
[08:27:58.820] result() for ClusterFuture ... done
[08:27:58.820] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:58.820] result() for ClusterFuture ... done
[08:27:58.820] result() for ClusterFuture ...
[08:27:58.821] - result already collected: FutureResult
[08:27:58.821] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[08:27:58.822] getGlobalsAndPackages() ...
[08:27:58.822] Searching for globals...
[08:27:58.824] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[08:27:58.824] Searching for globals ... DONE
[08:27:58.825] Resolving globals: FALSE
[08:27:58.825] The total size of the 2 globals is 401 bytes (401 bytes)
[08:27:58.826] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[08:27:58.826] - globals: [2] ‘weight’, ‘group’
[08:27:58.826] - packages: [1] ‘stats’
[08:27:58.826] getGlobalsAndPackages() ... DONE
[08:27:58.826] run() for ‘Future’ ...
[08:27:58.826] - state: ‘created’
[08:27:58.827] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:58.841] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:58.842] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:58.842]   - Field: ‘node’
[08:27:58.842]   - Field: ‘label’
[08:27:58.842]   - Field: ‘local’
[08:27:58.842]   - Field: ‘owner’
[08:27:58.842]   - Field: ‘envir’
[08:27:58.842]   - Field: ‘workers’
[08:27:58.842]   - Field: ‘packages’
[08:27:58.842]   - Field: ‘gc’
[08:27:58.842]   - Field: ‘conditions’
[08:27:58.843]   - Field: ‘persistent’
[08:27:58.843]   - Field: ‘expr’
[08:27:58.843]   - Field: ‘uuid’
[08:27:58.843]   - Field: ‘seed’
[08:27:58.843]   - Field: ‘version’
[08:27:58.843]   - Field: ‘result’
[08:27:58.843]   - Field: ‘asynchronous’
[08:27:58.843]   - Field: ‘calls’
[08:27:58.843]   - Field: ‘globals’
[08:27:58.844]   - Field: ‘stdout’
[08:27:58.844]   - Field: ‘earlySignal’
[08:27:58.844]   - Field: ‘lazy’
[08:27:58.844]   - Field: ‘state’
[08:27:58.844] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:58.844] - Launch lazy future ...
[08:27:58.844] Packages needed by the future expression (n = 1): ‘stats’
[08:27:58.845] Packages needed by future strategies (n = 0): <none>
[08:27:58.845] {
[08:27:58.845]     {
[08:27:58.845]         {
[08:27:58.845]             ...future.startTime <- base::Sys.time()
[08:27:58.845]             {
[08:27:58.845]                 {
[08:27:58.845]                   {
[08:27:58.845]                     {
[08:27:58.845]                       {
[08:27:58.845]                         base::local({
[08:27:58.845]                           has_future <- base::requireNamespace("future", 
[08:27:58.845]                             quietly = TRUE)
[08:27:58.845]                           if (has_future) {
[08:27:58.845]                             ns <- base::getNamespace("future")
[08:27:58.845]                             version <- ns[[".package"]][["version"]]
[08:27:58.845]                             if (is.null(version)) 
[08:27:58.845]                               version <- utils::packageVersion("future")
[08:27:58.845]                           }
[08:27:58.845]                           else {
[08:27:58.845]                             version <- NULL
[08:27:58.845]                           }
[08:27:58.845]                           if (!has_future || version < "1.8.0") {
[08:27:58.845]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:58.845]                               "", base::R.version$version.string), 
[08:27:58.845]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:58.845]                                 base::R.version$platform, 8 * 
[08:27:58.845]                                   base::.Machine$sizeof.pointer), 
[08:27:58.845]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:58.845]                                 "release", "version")], collapse = " "), 
[08:27:58.845]                               hostname = base::Sys.info()[["nodename"]])
[08:27:58.845]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:58.845]                               info)
[08:27:58.845]                             info <- base::paste(info, collapse = "; ")
[08:27:58.845]                             if (!has_future) {
[08:27:58.845]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:58.845]                                 info)
[08:27:58.845]                             }
[08:27:58.845]                             else {
[08:27:58.845]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:58.845]                                 info, version)
[08:27:58.845]                             }
[08:27:58.845]                             base::stop(msg)
[08:27:58.845]                           }
[08:27:58.845]                         })
[08:27:58.845]                       }
[08:27:58.845]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:58.845]                       base::options(mc.cores = 1L)
[08:27:58.845]                     }
[08:27:58.845]                     base::local({
[08:27:58.845]                       for (pkg in "stats") {
[08:27:58.845]                         base::loadNamespace(pkg)
[08:27:58.845]                         base::library(pkg, character.only = TRUE)
[08:27:58.845]                       }
[08:27:58.845]                     })
[08:27:58.845]                   }
[08:27:58.845]                   ...future.strategy.old <- future::plan("list")
[08:27:58.845]                   options(future.plan = NULL)
[08:27:58.845]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:58.845]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:58.845]                 }
[08:27:58.845]                 ...future.workdir <- getwd()
[08:27:58.845]             }
[08:27:58.845]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:58.845]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:58.845]         }
[08:27:58.845]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:58.845]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:58.845]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:58.845]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:58.845]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:58.845]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:58.845]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:58.845]             base::names(...future.oldOptions))
[08:27:58.845]     }
[08:27:58.845]     if (FALSE) {
[08:27:58.845]     }
[08:27:58.845]     else {
[08:27:58.845]         if (TRUE) {
[08:27:58.845]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:58.845]                 open = "w")
[08:27:58.845]         }
[08:27:58.845]         else {
[08:27:58.845]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:58.845]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:58.845]         }
[08:27:58.845]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:58.845]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:58.845]             base::sink(type = "output", split = FALSE)
[08:27:58.845]             base::close(...future.stdout)
[08:27:58.845]         }, add = TRUE)
[08:27:58.845]     }
[08:27:58.845]     ...future.frame <- base::sys.nframe()
[08:27:58.845]     ...future.conditions <- base::list()
[08:27:58.845]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:58.845]     if (FALSE) {
[08:27:58.845]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:58.845]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:58.845]     }
[08:27:58.845]     ...future.result <- base::tryCatch({
[08:27:58.845]         base::withCallingHandlers({
[08:27:58.845]             ...future.value <- base::withVisible(base::local({
[08:27:58.845]                 ...future.makeSendCondition <- base::local({
[08:27:58.845]                   sendCondition <- NULL
[08:27:58.845]                   function(frame = 1L) {
[08:27:58.845]                     if (is.function(sendCondition)) 
[08:27:58.845]                       return(sendCondition)
[08:27:58.845]                     ns <- getNamespace("parallel")
[08:27:58.845]                     if (exists("sendData", mode = "function", 
[08:27:58.845]                       envir = ns)) {
[08:27:58.845]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:58.845]                         envir = ns)
[08:27:58.845]                       envir <- sys.frame(frame)
[08:27:58.845]                       master <- NULL
[08:27:58.845]                       while (!identical(envir, .GlobalEnv) && 
[08:27:58.845]                         !identical(envir, emptyenv())) {
[08:27:58.845]                         if (exists("master", mode = "list", envir = envir, 
[08:27:58.845]                           inherits = FALSE)) {
[08:27:58.845]                           master <- get("master", mode = "list", 
[08:27:58.845]                             envir = envir, inherits = FALSE)
[08:27:58.845]                           if (inherits(master, c("SOCKnode", 
[08:27:58.845]                             "SOCK0node"))) {
[08:27:58.845]                             sendCondition <<- function(cond) {
[08:27:58.845]                               data <- list(type = "VALUE", value = cond, 
[08:27:58.845]                                 success = TRUE)
[08:27:58.845]                               parallel_sendData(master, data)
[08:27:58.845]                             }
[08:27:58.845]                             return(sendCondition)
[08:27:58.845]                           }
[08:27:58.845]                         }
[08:27:58.845]                         frame <- frame + 1L
[08:27:58.845]                         envir <- sys.frame(frame)
[08:27:58.845]                       }
[08:27:58.845]                     }
[08:27:58.845]                     sendCondition <<- function(cond) NULL
[08:27:58.845]                   }
[08:27:58.845]                 })
[08:27:58.845]                 withCallingHandlers({
[08:27:58.845]                   {
[08:27:58.845]                     lm(weight ~ group - 1)
[08:27:58.845]                   }
[08:27:58.845]                 }, immediateCondition = function(cond) {
[08:27:58.845]                   sendCondition <- ...future.makeSendCondition()
[08:27:58.845]                   sendCondition(cond)
[08:27:58.845]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.845]                   {
[08:27:58.845]                     inherits <- base::inherits
[08:27:58.845]                     invokeRestart <- base::invokeRestart
[08:27:58.845]                     is.null <- base::is.null
[08:27:58.845]                     muffled <- FALSE
[08:27:58.845]                     if (inherits(cond, "message")) {
[08:27:58.845]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:58.845]                       if (muffled) 
[08:27:58.845]                         invokeRestart("muffleMessage")
[08:27:58.845]                     }
[08:27:58.845]                     else if (inherits(cond, "warning")) {
[08:27:58.845]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:58.845]                       if (muffled) 
[08:27:58.845]                         invokeRestart("muffleWarning")
[08:27:58.845]                     }
[08:27:58.845]                     else if (inherits(cond, "condition")) {
[08:27:58.845]                       if (!is.null(pattern)) {
[08:27:58.845]                         computeRestarts <- base::computeRestarts
[08:27:58.845]                         grepl <- base::grepl
[08:27:58.845]                         restarts <- computeRestarts(cond)
[08:27:58.845]                         for (restart in restarts) {
[08:27:58.845]                           name <- restart$name
[08:27:58.845]                           if (is.null(name)) 
[08:27:58.845]                             next
[08:27:58.845]                           if (!grepl(pattern, name)) 
[08:27:58.845]                             next
[08:27:58.845]                           invokeRestart(restart)
[08:27:58.845]                           muffled <- TRUE
[08:27:58.845]                           break
[08:27:58.845]                         }
[08:27:58.845]                       }
[08:27:58.845]                     }
[08:27:58.845]                     invisible(muffled)
[08:27:58.845]                   }
[08:27:58.845]                   muffleCondition(cond)
[08:27:58.845]                 })
[08:27:58.845]             }))
[08:27:58.845]             future::FutureResult(value = ...future.value$value, 
[08:27:58.845]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:58.845]                   ...future.rng), globalenv = if (FALSE) 
[08:27:58.845]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:58.845]                     ...future.globalenv.names))
[08:27:58.845]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:58.845]         }, condition = base::local({
[08:27:58.845]             c <- base::c
[08:27:58.845]             inherits <- base::inherits
[08:27:58.845]             invokeRestart <- base::invokeRestart
[08:27:58.845]             length <- base::length
[08:27:58.845]             list <- base::list
[08:27:58.845]             seq.int <- base::seq.int
[08:27:58.845]             signalCondition <- base::signalCondition
[08:27:58.845]             sys.calls <- base::sys.calls
[08:27:58.845]             `[[` <- base::`[[`
[08:27:58.845]             `+` <- base::`+`
[08:27:58.845]             `<<-` <- base::`<<-`
[08:27:58.845]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:58.845]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:58.845]                   3L)]
[08:27:58.845]             }
[08:27:58.845]             function(cond) {
[08:27:58.845]                 is_error <- inherits(cond, "error")
[08:27:58.845]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:58.845]                   NULL)
[08:27:58.845]                 if (is_error) {
[08:27:58.845]                   sessionInformation <- function() {
[08:27:58.845]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:58.845]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:58.845]                       search = base::search(), system = base::Sys.info())
[08:27:58.845]                   }
[08:27:58.845]                   ...future.conditions[[length(...future.conditions) + 
[08:27:58.845]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:58.845]                     cond$call), session = sessionInformation(), 
[08:27:58.845]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:58.845]                   signalCondition(cond)
[08:27:58.845]                 }
[08:27:58.845]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:58.845]                 "immediateCondition"))) {
[08:27:58.845]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:58.845]                   ...future.conditions[[length(...future.conditions) + 
[08:27:58.845]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:58.845]                   if (TRUE && !signal) {
[08:27:58.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.845]                     {
[08:27:58.845]                       inherits <- base::inherits
[08:27:58.845]                       invokeRestart <- base::invokeRestart
[08:27:58.845]                       is.null <- base::is.null
[08:27:58.845]                       muffled <- FALSE
[08:27:58.845]                       if (inherits(cond, "message")) {
[08:27:58.845]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:58.845]                         if (muffled) 
[08:27:58.845]                           invokeRestart("muffleMessage")
[08:27:58.845]                       }
[08:27:58.845]                       else if (inherits(cond, "warning")) {
[08:27:58.845]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:58.845]                         if (muffled) 
[08:27:58.845]                           invokeRestart("muffleWarning")
[08:27:58.845]                       }
[08:27:58.845]                       else if (inherits(cond, "condition")) {
[08:27:58.845]                         if (!is.null(pattern)) {
[08:27:58.845]                           computeRestarts <- base::computeRestarts
[08:27:58.845]                           grepl <- base::grepl
[08:27:58.845]                           restarts <- computeRestarts(cond)
[08:27:58.845]                           for (restart in restarts) {
[08:27:58.845]                             name <- restart$name
[08:27:58.845]                             if (is.null(name)) 
[08:27:58.845]                               next
[08:27:58.845]                             if (!grepl(pattern, name)) 
[08:27:58.845]                               next
[08:27:58.845]                             invokeRestart(restart)
[08:27:58.845]                             muffled <- TRUE
[08:27:58.845]                             break
[08:27:58.845]                           }
[08:27:58.845]                         }
[08:27:58.845]                       }
[08:27:58.845]                       invisible(muffled)
[08:27:58.845]                     }
[08:27:58.845]                     muffleCondition(cond, pattern = "^muffle")
[08:27:58.845]                   }
[08:27:58.845]                 }
[08:27:58.845]                 else {
[08:27:58.845]                   if (TRUE) {
[08:27:58.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.845]                     {
[08:27:58.845]                       inherits <- base::inherits
[08:27:58.845]                       invokeRestart <- base::invokeRestart
[08:27:58.845]                       is.null <- base::is.null
[08:27:58.845]                       muffled <- FALSE
[08:27:58.845]                       if (inherits(cond, "message")) {
[08:27:58.845]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:58.845]                         if (muffled) 
[08:27:58.845]                           invokeRestart("muffleMessage")
[08:27:58.845]                       }
[08:27:58.845]                       else if (inherits(cond, "warning")) {
[08:27:58.845]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:58.845]                         if (muffled) 
[08:27:58.845]                           invokeRestart("muffleWarning")
[08:27:58.845]                       }
[08:27:58.845]                       else if (inherits(cond, "condition")) {
[08:27:58.845]                         if (!is.null(pattern)) {
[08:27:58.845]                           computeRestarts <- base::computeRestarts
[08:27:58.845]                           grepl <- base::grepl
[08:27:58.845]                           restarts <- computeRestarts(cond)
[08:27:58.845]                           for (restart in restarts) {
[08:27:58.845]                             name <- restart$name
[08:27:58.845]                             if (is.null(name)) 
[08:27:58.845]                               next
[08:27:58.845]                             if (!grepl(pattern, name)) 
[08:27:58.845]                               next
[08:27:58.845]                             invokeRestart(restart)
[08:27:58.845]                             muffled <- TRUE
[08:27:58.845]                             break
[08:27:58.845]                           }
[08:27:58.845]                         }
[08:27:58.845]                       }
[08:27:58.845]                       invisible(muffled)
[08:27:58.845]                     }
[08:27:58.845]                     muffleCondition(cond, pattern = "^muffle")
[08:27:58.845]                   }
[08:27:58.845]                 }
[08:27:58.845]             }
[08:27:58.845]         }))
[08:27:58.845]     }, error = function(ex) {
[08:27:58.845]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:58.845]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:58.845]                 ...future.rng), started = ...future.startTime, 
[08:27:58.845]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:58.845]             version = "1.8"), class = "FutureResult")
[08:27:58.845]     }, finally = {
[08:27:58.845]         if (!identical(...future.workdir, getwd())) 
[08:27:58.845]             setwd(...future.workdir)
[08:27:58.845]         {
[08:27:58.845]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:58.845]                 ...future.oldOptions$nwarnings <- NULL
[08:27:58.845]             }
[08:27:58.845]             base::options(...future.oldOptions)
[08:27:58.845]             if (.Platform$OS.type == "windows") {
[08:27:58.845]                 old_names <- names(...future.oldEnvVars)
[08:27:58.845]                 envs <- base::Sys.getenv()
[08:27:58.845]                 names <- names(envs)
[08:27:58.845]                 common <- intersect(names, old_names)
[08:27:58.845]                 added <- setdiff(names, old_names)
[08:27:58.845]                 removed <- setdiff(old_names, names)
[08:27:58.845]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:58.845]                   envs[common]]
[08:27:58.845]                 NAMES <- toupper(changed)
[08:27:58.845]                 args <- list()
[08:27:58.845]                 for (kk in seq_along(NAMES)) {
[08:27:58.845]                   name <- changed[[kk]]
[08:27:58.845]                   NAME <- NAMES[[kk]]
[08:27:58.845]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.845]                     next
[08:27:58.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:58.845]                 }
[08:27:58.845]                 NAMES <- toupper(added)
[08:27:58.845]                 for (kk in seq_along(NAMES)) {
[08:27:58.845]                   name <- added[[kk]]
[08:27:58.845]                   NAME <- NAMES[[kk]]
[08:27:58.845]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.845]                     next
[08:27:58.845]                   args[[name]] <- ""
[08:27:58.845]                 }
[08:27:58.845]                 NAMES <- toupper(removed)
[08:27:58.845]                 for (kk in seq_along(NAMES)) {
[08:27:58.845]                   name <- removed[[kk]]
[08:27:58.845]                   NAME <- NAMES[[kk]]
[08:27:58.845]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.845]                     next
[08:27:58.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:58.845]                 }
[08:27:58.845]                 if (length(args) > 0) 
[08:27:58.845]                   base::do.call(base::Sys.setenv, args = args)
[08:27:58.845]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:58.845]             }
[08:27:58.845]             else {
[08:27:58.845]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:58.845]             }
[08:27:58.845]             {
[08:27:58.845]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:58.845]                   0L) {
[08:27:58.845]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:58.845]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:58.845]                   base::options(opts)
[08:27:58.845]                 }
[08:27:58.845]                 {
[08:27:58.845]                   {
[08:27:58.845]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:58.845]                     NULL
[08:27:58.845]                   }
[08:27:58.845]                   options(future.plan = NULL)
[08:27:58.845]                   if (is.na(NA_character_)) 
[08:27:58.845]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:58.845]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:58.845]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:58.845]                     .init = FALSE)
[08:27:58.845]                 }
[08:27:58.845]             }
[08:27:58.845]         }
[08:27:58.845]     })
[08:27:58.845]     if (TRUE) {
[08:27:58.845]         base::sink(type = "output", split = FALSE)
[08:27:58.845]         if (TRUE) {
[08:27:58.845]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:58.845]         }
[08:27:58.845]         else {
[08:27:58.845]             ...future.result["stdout"] <- base::list(NULL)
[08:27:58.845]         }
[08:27:58.845]         base::close(...future.stdout)
[08:27:58.845]         ...future.stdout <- NULL
[08:27:58.845]     }
[08:27:58.845]     ...future.result$conditions <- ...future.conditions
[08:27:58.845]     ...future.result$finished <- base::Sys.time()
[08:27:58.845]     ...future.result
[08:27:58.845] }
[08:27:58.848] Exporting 2 global objects (712 bytes) to cluster node #1 ...
[08:27:58.848] Exporting ‘weight’ (191 bytes) to cluster node #1 ...
[08:27:58.849] Exporting ‘weight’ (191 bytes) to cluster node #1 ... DONE
[08:27:58.849] Exporting ‘group’ (210 bytes) to cluster node #1 ...
[08:27:58.849] Exporting ‘group’ (210 bytes) to cluster node #1 ... DONE
[08:27:58.849] Exporting 2 global objects (712 bytes) to cluster node #1 ... DONE
[08:27:58.850] MultisessionFuture started
[08:27:58.850] - Launch lazy future ... done
[08:27:58.850] run() for ‘MultisessionFuture’ ... done
[08:27:58.850] result() for ClusterFuture ...
[08:27:58.850] receiveMessageFromWorker() for ClusterFuture ...
[08:27:58.851] - Validating connection of MultisessionFuture
[08:27:58.893] - received message: FutureResult
[08:27:58.893] - Received FutureResult
[08:27:58.893] - Erased future from FutureRegistry
[08:27:58.893] result() for ClusterFuture ...
[08:27:58.894] - result already collected: FutureResult
[08:27:58.894] result() for ClusterFuture ... done
[08:27:58.894] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:58.894] result() for ClusterFuture ... done
[08:27:58.894] result() for ClusterFuture ...
[08:27:58.894] - result already collected: FutureResult
[08:27:58.894] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[08:27:58.896] getGlobalsAndPackages() ...
[08:27:58.897] Searching for globals...
[08:27:58.898] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[08:27:58.899] Searching for globals ... DONE
[08:27:58.899] Resolving globals: FALSE
[08:27:58.899] The total size of the 2 globals is 401 bytes (401 bytes)
[08:27:58.900] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[08:27:58.900] - globals: [2] ‘weight’, ‘group’
[08:27:58.900] - packages: [1] ‘stats’
[08:27:58.900] getGlobalsAndPackages() ... DONE
[08:27:58.900] run() for ‘Future’ ...
[08:27:58.901] - state: ‘created’
[08:27:58.901] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:58.915] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:58.916] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:58.916]   - Field: ‘node’
[08:27:58.916]   - Field: ‘label’
[08:27:58.916]   - Field: ‘local’
[08:27:58.916]   - Field: ‘owner’
[08:27:58.916]   - Field: ‘envir’
[08:27:58.916]   - Field: ‘workers’
[08:27:58.916]   - Field: ‘packages’
[08:27:58.916]   - Field: ‘gc’
[08:27:58.916]   - Field: ‘conditions’
[08:27:58.916]   - Field: ‘persistent’
[08:27:58.917]   - Field: ‘expr’
[08:27:58.917]   - Field: ‘uuid’
[08:27:58.917]   - Field: ‘seed’
[08:27:58.917]   - Field: ‘version’
[08:27:58.917]   - Field: ‘result’
[08:27:58.917]   - Field: ‘asynchronous’
[08:27:58.917]   - Field: ‘calls’
[08:27:58.917]   - Field: ‘globals’
[08:27:58.917]   - Field: ‘stdout’
[08:27:58.918]   - Field: ‘earlySignal’
[08:27:58.918]   - Field: ‘lazy’
[08:27:58.918]   - Field: ‘state’
[08:27:58.918] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:58.918] - Launch lazy future ...
[08:27:58.918] Packages needed by the future expression (n = 1): ‘stats’
[08:27:58.918] Packages needed by future strategies (n = 0): <none>
[08:27:58.919] {
[08:27:58.919]     {
[08:27:58.919]         {
[08:27:58.919]             ...future.startTime <- base::Sys.time()
[08:27:58.919]             {
[08:27:58.919]                 {
[08:27:58.919]                   {
[08:27:58.919]                     {
[08:27:58.919]                       {
[08:27:58.919]                         base::local({
[08:27:58.919]                           has_future <- base::requireNamespace("future", 
[08:27:58.919]                             quietly = TRUE)
[08:27:58.919]                           if (has_future) {
[08:27:58.919]                             ns <- base::getNamespace("future")
[08:27:58.919]                             version <- ns[[".package"]][["version"]]
[08:27:58.919]                             if (is.null(version)) 
[08:27:58.919]                               version <- utils::packageVersion("future")
[08:27:58.919]                           }
[08:27:58.919]                           else {
[08:27:58.919]                             version <- NULL
[08:27:58.919]                           }
[08:27:58.919]                           if (!has_future || version < "1.8.0") {
[08:27:58.919]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:58.919]                               "", base::R.version$version.string), 
[08:27:58.919]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:58.919]                                 base::R.version$platform, 8 * 
[08:27:58.919]                                   base::.Machine$sizeof.pointer), 
[08:27:58.919]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:58.919]                                 "release", "version")], collapse = " "), 
[08:27:58.919]                               hostname = base::Sys.info()[["nodename"]])
[08:27:58.919]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:58.919]                               info)
[08:27:58.919]                             info <- base::paste(info, collapse = "; ")
[08:27:58.919]                             if (!has_future) {
[08:27:58.919]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:58.919]                                 info)
[08:27:58.919]                             }
[08:27:58.919]                             else {
[08:27:58.919]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:58.919]                                 info, version)
[08:27:58.919]                             }
[08:27:58.919]                             base::stop(msg)
[08:27:58.919]                           }
[08:27:58.919]                         })
[08:27:58.919]                       }
[08:27:58.919]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:58.919]                       base::options(mc.cores = 1L)
[08:27:58.919]                     }
[08:27:58.919]                     base::local({
[08:27:58.919]                       for (pkg in "stats") {
[08:27:58.919]                         base::loadNamespace(pkg)
[08:27:58.919]                         base::library(pkg, character.only = TRUE)
[08:27:58.919]                       }
[08:27:58.919]                     })
[08:27:58.919]                   }
[08:27:58.919]                   ...future.strategy.old <- future::plan("list")
[08:27:58.919]                   options(future.plan = NULL)
[08:27:58.919]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:58.919]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:58.919]                 }
[08:27:58.919]                 ...future.workdir <- getwd()
[08:27:58.919]             }
[08:27:58.919]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:58.919]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:58.919]         }
[08:27:58.919]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:58.919]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:58.919]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:58.919]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:58.919]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:58.919]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:58.919]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:58.919]             base::names(...future.oldOptions))
[08:27:58.919]     }
[08:27:58.919]     if (FALSE) {
[08:27:58.919]     }
[08:27:58.919]     else {
[08:27:58.919]         if (TRUE) {
[08:27:58.919]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:58.919]                 open = "w")
[08:27:58.919]         }
[08:27:58.919]         else {
[08:27:58.919]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:58.919]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:58.919]         }
[08:27:58.919]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:58.919]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:58.919]             base::sink(type = "output", split = FALSE)
[08:27:58.919]             base::close(...future.stdout)
[08:27:58.919]         }, add = TRUE)
[08:27:58.919]     }
[08:27:58.919]     ...future.frame <- base::sys.nframe()
[08:27:58.919]     ...future.conditions <- base::list()
[08:27:58.919]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:58.919]     if (FALSE) {
[08:27:58.919]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:58.919]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:58.919]     }
[08:27:58.919]     ...future.result <- base::tryCatch({
[08:27:58.919]         base::withCallingHandlers({
[08:27:58.919]             ...future.value <- base::withVisible(base::local({
[08:27:58.919]                 ...future.makeSendCondition <- base::local({
[08:27:58.919]                   sendCondition <- NULL
[08:27:58.919]                   function(frame = 1L) {
[08:27:58.919]                     if (is.function(sendCondition)) 
[08:27:58.919]                       return(sendCondition)
[08:27:58.919]                     ns <- getNamespace("parallel")
[08:27:58.919]                     if (exists("sendData", mode = "function", 
[08:27:58.919]                       envir = ns)) {
[08:27:58.919]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:58.919]                         envir = ns)
[08:27:58.919]                       envir <- sys.frame(frame)
[08:27:58.919]                       master <- NULL
[08:27:58.919]                       while (!identical(envir, .GlobalEnv) && 
[08:27:58.919]                         !identical(envir, emptyenv())) {
[08:27:58.919]                         if (exists("master", mode = "list", envir = envir, 
[08:27:58.919]                           inherits = FALSE)) {
[08:27:58.919]                           master <- get("master", mode = "list", 
[08:27:58.919]                             envir = envir, inherits = FALSE)
[08:27:58.919]                           if (inherits(master, c("SOCKnode", 
[08:27:58.919]                             "SOCK0node"))) {
[08:27:58.919]                             sendCondition <<- function(cond) {
[08:27:58.919]                               data <- list(type = "VALUE", value = cond, 
[08:27:58.919]                                 success = TRUE)
[08:27:58.919]                               parallel_sendData(master, data)
[08:27:58.919]                             }
[08:27:58.919]                             return(sendCondition)
[08:27:58.919]                           }
[08:27:58.919]                         }
[08:27:58.919]                         frame <- frame + 1L
[08:27:58.919]                         envir <- sys.frame(frame)
[08:27:58.919]                       }
[08:27:58.919]                     }
[08:27:58.919]                     sendCondition <<- function(cond) NULL
[08:27:58.919]                   }
[08:27:58.919]                 })
[08:27:58.919]                 withCallingHandlers({
[08:27:58.919]                   {
[08:27:58.919]                     lm(weight ~ group - 1)
[08:27:58.919]                   }
[08:27:58.919]                 }, immediateCondition = function(cond) {
[08:27:58.919]                   sendCondition <- ...future.makeSendCondition()
[08:27:58.919]                   sendCondition(cond)
[08:27:58.919]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.919]                   {
[08:27:58.919]                     inherits <- base::inherits
[08:27:58.919]                     invokeRestart <- base::invokeRestart
[08:27:58.919]                     is.null <- base::is.null
[08:27:58.919]                     muffled <- FALSE
[08:27:58.919]                     if (inherits(cond, "message")) {
[08:27:58.919]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:58.919]                       if (muffled) 
[08:27:58.919]                         invokeRestart("muffleMessage")
[08:27:58.919]                     }
[08:27:58.919]                     else if (inherits(cond, "warning")) {
[08:27:58.919]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:58.919]                       if (muffled) 
[08:27:58.919]                         invokeRestart("muffleWarning")
[08:27:58.919]                     }
[08:27:58.919]                     else if (inherits(cond, "condition")) {
[08:27:58.919]                       if (!is.null(pattern)) {
[08:27:58.919]                         computeRestarts <- base::computeRestarts
[08:27:58.919]                         grepl <- base::grepl
[08:27:58.919]                         restarts <- computeRestarts(cond)
[08:27:58.919]                         for (restart in restarts) {
[08:27:58.919]                           name <- restart$name
[08:27:58.919]                           if (is.null(name)) 
[08:27:58.919]                             next
[08:27:58.919]                           if (!grepl(pattern, name)) 
[08:27:58.919]                             next
[08:27:58.919]                           invokeRestart(restart)
[08:27:58.919]                           muffled <- TRUE
[08:27:58.919]                           break
[08:27:58.919]                         }
[08:27:58.919]                       }
[08:27:58.919]                     }
[08:27:58.919]                     invisible(muffled)
[08:27:58.919]                   }
[08:27:58.919]                   muffleCondition(cond)
[08:27:58.919]                 })
[08:27:58.919]             }))
[08:27:58.919]             future::FutureResult(value = ...future.value$value, 
[08:27:58.919]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:58.919]                   ...future.rng), globalenv = if (FALSE) 
[08:27:58.919]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:58.919]                     ...future.globalenv.names))
[08:27:58.919]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:58.919]         }, condition = base::local({
[08:27:58.919]             c <- base::c
[08:27:58.919]             inherits <- base::inherits
[08:27:58.919]             invokeRestart <- base::invokeRestart
[08:27:58.919]             length <- base::length
[08:27:58.919]             list <- base::list
[08:27:58.919]             seq.int <- base::seq.int
[08:27:58.919]             signalCondition <- base::signalCondition
[08:27:58.919]             sys.calls <- base::sys.calls
[08:27:58.919]             `[[` <- base::`[[`
[08:27:58.919]             `+` <- base::`+`
[08:27:58.919]             `<<-` <- base::`<<-`
[08:27:58.919]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:58.919]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:58.919]                   3L)]
[08:27:58.919]             }
[08:27:58.919]             function(cond) {
[08:27:58.919]                 is_error <- inherits(cond, "error")
[08:27:58.919]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:58.919]                   NULL)
[08:27:58.919]                 if (is_error) {
[08:27:58.919]                   sessionInformation <- function() {
[08:27:58.919]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:58.919]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:58.919]                       search = base::search(), system = base::Sys.info())
[08:27:58.919]                   }
[08:27:58.919]                   ...future.conditions[[length(...future.conditions) + 
[08:27:58.919]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:58.919]                     cond$call), session = sessionInformation(), 
[08:27:58.919]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:58.919]                   signalCondition(cond)
[08:27:58.919]                 }
[08:27:58.919]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:58.919]                 "immediateCondition"))) {
[08:27:58.919]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:58.919]                   ...future.conditions[[length(...future.conditions) + 
[08:27:58.919]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:58.919]                   if (TRUE && !signal) {
[08:27:58.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.919]                     {
[08:27:58.919]                       inherits <- base::inherits
[08:27:58.919]                       invokeRestart <- base::invokeRestart
[08:27:58.919]                       is.null <- base::is.null
[08:27:58.919]                       muffled <- FALSE
[08:27:58.919]                       if (inherits(cond, "message")) {
[08:27:58.919]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:58.919]                         if (muffled) 
[08:27:58.919]                           invokeRestart("muffleMessage")
[08:27:58.919]                       }
[08:27:58.919]                       else if (inherits(cond, "warning")) {
[08:27:58.919]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:58.919]                         if (muffled) 
[08:27:58.919]                           invokeRestart("muffleWarning")
[08:27:58.919]                       }
[08:27:58.919]                       else if (inherits(cond, "condition")) {
[08:27:58.919]                         if (!is.null(pattern)) {
[08:27:58.919]                           computeRestarts <- base::computeRestarts
[08:27:58.919]                           grepl <- base::grepl
[08:27:58.919]                           restarts <- computeRestarts(cond)
[08:27:58.919]                           for (restart in restarts) {
[08:27:58.919]                             name <- restart$name
[08:27:58.919]                             if (is.null(name)) 
[08:27:58.919]                               next
[08:27:58.919]                             if (!grepl(pattern, name)) 
[08:27:58.919]                               next
[08:27:58.919]                             invokeRestart(restart)
[08:27:58.919]                             muffled <- TRUE
[08:27:58.919]                             break
[08:27:58.919]                           }
[08:27:58.919]                         }
[08:27:58.919]                       }
[08:27:58.919]                       invisible(muffled)
[08:27:58.919]                     }
[08:27:58.919]                     muffleCondition(cond, pattern = "^muffle")
[08:27:58.919]                   }
[08:27:58.919]                 }
[08:27:58.919]                 else {
[08:27:58.919]                   if (TRUE) {
[08:27:58.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.919]                     {
[08:27:58.919]                       inherits <- base::inherits
[08:27:58.919]                       invokeRestart <- base::invokeRestart
[08:27:58.919]                       is.null <- base::is.null
[08:27:58.919]                       muffled <- FALSE
[08:27:58.919]                       if (inherits(cond, "message")) {
[08:27:58.919]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:58.919]                         if (muffled) 
[08:27:58.919]                           invokeRestart("muffleMessage")
[08:27:58.919]                       }
[08:27:58.919]                       else if (inherits(cond, "warning")) {
[08:27:58.919]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:58.919]                         if (muffled) 
[08:27:58.919]                           invokeRestart("muffleWarning")
[08:27:58.919]                       }
[08:27:58.919]                       else if (inherits(cond, "condition")) {
[08:27:58.919]                         if (!is.null(pattern)) {
[08:27:58.919]                           computeRestarts <- base::computeRestarts
[08:27:58.919]                           grepl <- base::grepl
[08:27:58.919]                           restarts <- computeRestarts(cond)
[08:27:58.919]                           for (restart in restarts) {
[08:27:58.919]                             name <- restart$name
[08:27:58.919]                             if (is.null(name)) 
[08:27:58.919]                               next
[08:27:58.919]                             if (!grepl(pattern, name)) 
[08:27:58.919]                               next
[08:27:58.919]                             invokeRestart(restart)
[08:27:58.919]                             muffled <- TRUE
[08:27:58.919]                             break
[08:27:58.919]                           }
[08:27:58.919]                         }
[08:27:58.919]                       }
[08:27:58.919]                       invisible(muffled)
[08:27:58.919]                     }
[08:27:58.919]                     muffleCondition(cond, pattern = "^muffle")
[08:27:58.919]                   }
[08:27:58.919]                 }
[08:27:58.919]             }
[08:27:58.919]         }))
[08:27:58.919]     }, error = function(ex) {
[08:27:58.919]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:58.919]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:58.919]                 ...future.rng), started = ...future.startTime, 
[08:27:58.919]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:58.919]             version = "1.8"), class = "FutureResult")
[08:27:58.919]     }, finally = {
[08:27:58.919]         if (!identical(...future.workdir, getwd())) 
[08:27:58.919]             setwd(...future.workdir)
[08:27:58.919]         {
[08:27:58.919]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:58.919]                 ...future.oldOptions$nwarnings <- NULL
[08:27:58.919]             }
[08:27:58.919]             base::options(...future.oldOptions)
[08:27:58.919]             if (.Platform$OS.type == "windows") {
[08:27:58.919]                 old_names <- names(...future.oldEnvVars)
[08:27:58.919]                 envs <- base::Sys.getenv()
[08:27:58.919]                 names <- names(envs)
[08:27:58.919]                 common <- intersect(names, old_names)
[08:27:58.919]                 added <- setdiff(names, old_names)
[08:27:58.919]                 removed <- setdiff(old_names, names)
[08:27:58.919]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:58.919]                   envs[common]]
[08:27:58.919]                 NAMES <- toupper(changed)
[08:27:58.919]                 args <- list()
[08:27:58.919]                 for (kk in seq_along(NAMES)) {
[08:27:58.919]                   name <- changed[[kk]]
[08:27:58.919]                   NAME <- NAMES[[kk]]
[08:27:58.919]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.919]                     next
[08:27:58.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:58.919]                 }
[08:27:58.919]                 NAMES <- toupper(added)
[08:27:58.919]                 for (kk in seq_along(NAMES)) {
[08:27:58.919]                   name <- added[[kk]]
[08:27:58.919]                   NAME <- NAMES[[kk]]
[08:27:58.919]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.919]                     next
[08:27:58.919]                   args[[name]] <- ""
[08:27:58.919]                 }
[08:27:58.919]                 NAMES <- toupper(removed)
[08:27:58.919]                 for (kk in seq_along(NAMES)) {
[08:27:58.919]                   name <- removed[[kk]]
[08:27:58.919]                   NAME <- NAMES[[kk]]
[08:27:58.919]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.919]                     next
[08:27:58.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:58.919]                 }
[08:27:58.919]                 if (length(args) > 0) 
[08:27:58.919]                   base::do.call(base::Sys.setenv, args = args)
[08:27:58.919]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:58.919]             }
[08:27:58.919]             else {
[08:27:58.919]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:58.919]             }
[08:27:58.919]             {
[08:27:58.919]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:58.919]                   0L) {
[08:27:58.919]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:58.919]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:58.919]                   base::options(opts)
[08:27:58.919]                 }
[08:27:58.919]                 {
[08:27:58.919]                   {
[08:27:58.919]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:58.919]                     NULL
[08:27:58.919]                   }
[08:27:58.919]                   options(future.plan = NULL)
[08:27:58.919]                   if (is.na(NA_character_)) 
[08:27:58.919]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:58.919]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:58.919]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:58.919]                     .init = FALSE)
[08:27:58.919]                 }
[08:27:58.919]             }
[08:27:58.919]         }
[08:27:58.919]     })
[08:27:58.919]     if (TRUE) {
[08:27:58.919]         base::sink(type = "output", split = FALSE)
[08:27:58.919]         if (TRUE) {
[08:27:58.919]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:58.919]         }
[08:27:58.919]         else {
[08:27:58.919]             ...future.result["stdout"] <- base::list(NULL)
[08:27:58.919]         }
[08:27:58.919]         base::close(...future.stdout)
[08:27:58.919]         ...future.stdout <- NULL
[08:27:58.919]     }
[08:27:58.919]     ...future.result$conditions <- ...future.conditions
[08:27:58.919]     ...future.result$finished <- base::Sys.time()
[08:27:58.919]     ...future.result
[08:27:58.919] }
[08:27:58.922] Exporting 2 global objects (712 bytes) to cluster node #1 ...
[08:27:58.922] Exporting ‘weight’ (191 bytes) to cluster node #1 ...
[08:27:58.923] Exporting ‘weight’ (191 bytes) to cluster node #1 ... DONE
[08:27:58.923] Exporting ‘group’ (210 bytes) to cluster node #1 ...
[08:27:58.923] Exporting ‘group’ (210 bytes) to cluster node #1 ... DONE
[08:27:58.923] Exporting 2 global objects (712 bytes) to cluster node #1 ... DONE
[08:27:58.924] MultisessionFuture started
[08:27:58.924] - Launch lazy future ... done
[08:27:58.924] run() for ‘MultisessionFuture’ ... done
[08:27:58.924] result() for ClusterFuture ...
[08:27:58.924] receiveMessageFromWorker() for ClusterFuture ...
[08:27:58.924] - Validating connection of MultisessionFuture
[08:27:58.967] - received message: FutureResult
[08:27:58.967] - Received FutureResult
[08:27:58.968] - Erased future from FutureRegistry
[08:27:58.968] result() for ClusterFuture ...
[08:27:58.968] - result already collected: FutureResult
[08:27:58.968] result() for ClusterFuture ... done
[08:27:58.968] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:58.968] result() for ClusterFuture ... done
[08:27:58.968] result() for ClusterFuture ...
[08:27:58.968] - result already collected: FutureResult
[08:27:58.969] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[08:27:58.971] getGlobalsAndPackages() ...
[08:27:58.971] Searching for globals...
[08:27:58.973] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[08:27:58.973] Searching for globals ... DONE
[08:27:58.973] Resolving globals: FALSE
[08:27:58.974] The total size of the 2 globals is 401 bytes (401 bytes)
[08:27:58.974] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[08:27:58.974] - globals: [2] ‘weight’, ‘group’
[08:27:58.975] - packages: [1] ‘stats’
[08:27:58.975] getGlobalsAndPackages() ... DONE
[08:27:58.975] run() for ‘Future’ ...
[08:27:58.975] - state: ‘created’
[08:27:58.975] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:58.990] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:58.991] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:58.991]   - Field: ‘node’
[08:27:58.991]   - Field: ‘label’
[08:27:58.991]   - Field: ‘local’
[08:27:58.991]   - Field: ‘owner’
[08:27:58.991]   - Field: ‘envir’
[08:27:58.991]   - Field: ‘workers’
[08:27:58.991]   - Field: ‘packages’
[08:27:58.991]   - Field: ‘gc’
[08:27:58.991]   - Field: ‘conditions’
[08:27:58.992]   - Field: ‘persistent’
[08:27:58.992]   - Field: ‘expr’
[08:27:58.992]   - Field: ‘uuid’
[08:27:58.992]   - Field: ‘seed’
[08:27:58.992]   - Field: ‘version’
[08:27:58.992]   - Field: ‘result’
[08:27:58.992]   - Field: ‘asynchronous’
[08:27:58.992]   - Field: ‘calls’
[08:27:58.992]   - Field: ‘globals’
[08:27:58.993]   - Field: ‘stdout’
[08:27:58.993]   - Field: ‘earlySignal’
[08:27:58.993]   - Field: ‘lazy’
[08:27:58.993]   - Field: ‘state’
[08:27:58.993] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:58.993] - Launch lazy future ...
[08:27:58.993] Packages needed by the future expression (n = 1): ‘stats’
[08:27:58.994] Packages needed by future strategies (n = 0): <none>
[08:27:58.994] {
[08:27:58.994]     {
[08:27:58.994]         {
[08:27:58.994]             ...future.startTime <- base::Sys.time()
[08:27:58.994]             {
[08:27:58.994]                 {
[08:27:58.994]                   {
[08:27:58.994]                     {
[08:27:58.994]                       {
[08:27:58.994]                         base::local({
[08:27:58.994]                           has_future <- base::requireNamespace("future", 
[08:27:58.994]                             quietly = TRUE)
[08:27:58.994]                           if (has_future) {
[08:27:58.994]                             ns <- base::getNamespace("future")
[08:27:58.994]                             version <- ns[[".package"]][["version"]]
[08:27:58.994]                             if (is.null(version)) 
[08:27:58.994]                               version <- utils::packageVersion("future")
[08:27:58.994]                           }
[08:27:58.994]                           else {
[08:27:58.994]                             version <- NULL
[08:27:58.994]                           }
[08:27:58.994]                           if (!has_future || version < "1.8.0") {
[08:27:58.994]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:58.994]                               "", base::R.version$version.string), 
[08:27:58.994]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:58.994]                                 base::R.version$platform, 8 * 
[08:27:58.994]                                   base::.Machine$sizeof.pointer), 
[08:27:58.994]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:58.994]                                 "release", "version")], collapse = " "), 
[08:27:58.994]                               hostname = base::Sys.info()[["nodename"]])
[08:27:58.994]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:58.994]                               info)
[08:27:58.994]                             info <- base::paste(info, collapse = "; ")
[08:27:58.994]                             if (!has_future) {
[08:27:58.994]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:58.994]                                 info)
[08:27:58.994]                             }
[08:27:58.994]                             else {
[08:27:58.994]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:58.994]                                 info, version)
[08:27:58.994]                             }
[08:27:58.994]                             base::stop(msg)
[08:27:58.994]                           }
[08:27:58.994]                         })
[08:27:58.994]                       }
[08:27:58.994]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:58.994]                       base::options(mc.cores = 1L)
[08:27:58.994]                     }
[08:27:58.994]                     base::local({
[08:27:58.994]                       for (pkg in "stats") {
[08:27:58.994]                         base::loadNamespace(pkg)
[08:27:58.994]                         base::library(pkg, character.only = TRUE)
[08:27:58.994]                       }
[08:27:58.994]                     })
[08:27:58.994]                   }
[08:27:58.994]                   ...future.strategy.old <- future::plan("list")
[08:27:58.994]                   options(future.plan = NULL)
[08:27:58.994]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:58.994]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:58.994]                 }
[08:27:58.994]                 ...future.workdir <- getwd()
[08:27:58.994]             }
[08:27:58.994]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:58.994]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:58.994]         }
[08:27:58.994]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:58.994]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:58.994]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:58.994]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:58.994]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:58.994]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:58.994]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:58.994]             base::names(...future.oldOptions))
[08:27:58.994]     }
[08:27:58.994]     if (FALSE) {
[08:27:58.994]     }
[08:27:58.994]     else {
[08:27:58.994]         if (TRUE) {
[08:27:58.994]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:58.994]                 open = "w")
[08:27:58.994]         }
[08:27:58.994]         else {
[08:27:58.994]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:58.994]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:58.994]         }
[08:27:58.994]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:58.994]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:58.994]             base::sink(type = "output", split = FALSE)
[08:27:58.994]             base::close(...future.stdout)
[08:27:58.994]         }, add = TRUE)
[08:27:58.994]     }
[08:27:58.994]     ...future.frame <- base::sys.nframe()
[08:27:58.994]     ...future.conditions <- base::list()
[08:27:58.994]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:58.994]     if (FALSE) {
[08:27:58.994]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:58.994]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:58.994]     }
[08:27:58.994]     ...future.result <- base::tryCatch({
[08:27:58.994]         base::withCallingHandlers({
[08:27:58.994]             ...future.value <- base::withVisible(base::local({
[08:27:58.994]                 ...future.makeSendCondition <- base::local({
[08:27:58.994]                   sendCondition <- NULL
[08:27:58.994]                   function(frame = 1L) {
[08:27:58.994]                     if (is.function(sendCondition)) 
[08:27:58.994]                       return(sendCondition)
[08:27:58.994]                     ns <- getNamespace("parallel")
[08:27:58.994]                     if (exists("sendData", mode = "function", 
[08:27:58.994]                       envir = ns)) {
[08:27:58.994]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:58.994]                         envir = ns)
[08:27:58.994]                       envir <- sys.frame(frame)
[08:27:58.994]                       master <- NULL
[08:27:58.994]                       while (!identical(envir, .GlobalEnv) && 
[08:27:58.994]                         !identical(envir, emptyenv())) {
[08:27:58.994]                         if (exists("master", mode = "list", envir = envir, 
[08:27:58.994]                           inherits = FALSE)) {
[08:27:58.994]                           master <- get("master", mode = "list", 
[08:27:58.994]                             envir = envir, inherits = FALSE)
[08:27:58.994]                           if (inherits(master, c("SOCKnode", 
[08:27:58.994]                             "SOCK0node"))) {
[08:27:58.994]                             sendCondition <<- function(cond) {
[08:27:58.994]                               data <- list(type = "VALUE", value = cond, 
[08:27:58.994]                                 success = TRUE)
[08:27:58.994]                               parallel_sendData(master, data)
[08:27:58.994]                             }
[08:27:58.994]                             return(sendCondition)
[08:27:58.994]                           }
[08:27:58.994]                         }
[08:27:58.994]                         frame <- frame + 1L
[08:27:58.994]                         envir <- sys.frame(frame)
[08:27:58.994]                       }
[08:27:58.994]                     }
[08:27:58.994]                     sendCondition <<- function(cond) NULL
[08:27:58.994]                   }
[08:27:58.994]                 })
[08:27:58.994]                 withCallingHandlers({
[08:27:58.994]                   {
[08:27:58.994]                     lm(weight ~ group - 1)
[08:27:58.994]                   }
[08:27:58.994]                 }, immediateCondition = function(cond) {
[08:27:58.994]                   sendCondition <- ...future.makeSendCondition()
[08:27:58.994]                   sendCondition(cond)
[08:27:58.994]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.994]                   {
[08:27:58.994]                     inherits <- base::inherits
[08:27:58.994]                     invokeRestart <- base::invokeRestart
[08:27:58.994]                     is.null <- base::is.null
[08:27:58.994]                     muffled <- FALSE
[08:27:58.994]                     if (inherits(cond, "message")) {
[08:27:58.994]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:58.994]                       if (muffled) 
[08:27:58.994]                         invokeRestart("muffleMessage")
[08:27:58.994]                     }
[08:27:58.994]                     else if (inherits(cond, "warning")) {
[08:27:58.994]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:58.994]                       if (muffled) 
[08:27:58.994]                         invokeRestart("muffleWarning")
[08:27:58.994]                     }
[08:27:58.994]                     else if (inherits(cond, "condition")) {
[08:27:58.994]                       if (!is.null(pattern)) {
[08:27:58.994]                         computeRestarts <- base::computeRestarts
[08:27:58.994]                         grepl <- base::grepl
[08:27:58.994]                         restarts <- computeRestarts(cond)
[08:27:58.994]                         for (restart in restarts) {
[08:27:58.994]                           name <- restart$name
[08:27:58.994]                           if (is.null(name)) 
[08:27:58.994]                             next
[08:27:58.994]                           if (!grepl(pattern, name)) 
[08:27:58.994]                             next
[08:27:58.994]                           invokeRestart(restart)
[08:27:58.994]                           muffled <- TRUE
[08:27:58.994]                           break
[08:27:58.994]                         }
[08:27:58.994]                       }
[08:27:58.994]                     }
[08:27:58.994]                     invisible(muffled)
[08:27:58.994]                   }
[08:27:58.994]                   muffleCondition(cond)
[08:27:58.994]                 })
[08:27:58.994]             }))
[08:27:58.994]             future::FutureResult(value = ...future.value$value, 
[08:27:58.994]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:58.994]                   ...future.rng), globalenv = if (FALSE) 
[08:27:58.994]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:58.994]                     ...future.globalenv.names))
[08:27:58.994]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:58.994]         }, condition = base::local({
[08:27:58.994]             c <- base::c
[08:27:58.994]             inherits <- base::inherits
[08:27:58.994]             invokeRestart <- base::invokeRestart
[08:27:58.994]             length <- base::length
[08:27:58.994]             list <- base::list
[08:27:58.994]             seq.int <- base::seq.int
[08:27:58.994]             signalCondition <- base::signalCondition
[08:27:58.994]             sys.calls <- base::sys.calls
[08:27:58.994]             `[[` <- base::`[[`
[08:27:58.994]             `+` <- base::`+`
[08:27:58.994]             `<<-` <- base::`<<-`
[08:27:58.994]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:58.994]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:58.994]                   3L)]
[08:27:58.994]             }
[08:27:58.994]             function(cond) {
[08:27:58.994]                 is_error <- inherits(cond, "error")
[08:27:58.994]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:58.994]                   NULL)
[08:27:58.994]                 if (is_error) {
[08:27:58.994]                   sessionInformation <- function() {
[08:27:58.994]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:58.994]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:58.994]                       search = base::search(), system = base::Sys.info())
[08:27:58.994]                   }
[08:27:58.994]                   ...future.conditions[[length(...future.conditions) + 
[08:27:58.994]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:58.994]                     cond$call), session = sessionInformation(), 
[08:27:58.994]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:58.994]                   signalCondition(cond)
[08:27:58.994]                 }
[08:27:58.994]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:58.994]                 "immediateCondition"))) {
[08:27:58.994]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:58.994]                   ...future.conditions[[length(...future.conditions) + 
[08:27:58.994]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:58.994]                   if (TRUE && !signal) {
[08:27:58.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.994]                     {
[08:27:58.994]                       inherits <- base::inherits
[08:27:58.994]                       invokeRestart <- base::invokeRestart
[08:27:58.994]                       is.null <- base::is.null
[08:27:58.994]                       muffled <- FALSE
[08:27:58.994]                       if (inherits(cond, "message")) {
[08:27:58.994]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:58.994]                         if (muffled) 
[08:27:58.994]                           invokeRestart("muffleMessage")
[08:27:58.994]                       }
[08:27:58.994]                       else if (inherits(cond, "warning")) {
[08:27:58.994]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:58.994]                         if (muffled) 
[08:27:58.994]                           invokeRestart("muffleWarning")
[08:27:58.994]                       }
[08:27:58.994]                       else if (inherits(cond, "condition")) {
[08:27:58.994]                         if (!is.null(pattern)) {
[08:27:58.994]                           computeRestarts <- base::computeRestarts
[08:27:58.994]                           grepl <- base::grepl
[08:27:58.994]                           restarts <- computeRestarts(cond)
[08:27:58.994]                           for (restart in restarts) {
[08:27:58.994]                             name <- restart$name
[08:27:58.994]                             if (is.null(name)) 
[08:27:58.994]                               next
[08:27:58.994]                             if (!grepl(pattern, name)) 
[08:27:58.994]                               next
[08:27:58.994]                             invokeRestart(restart)
[08:27:58.994]                             muffled <- TRUE
[08:27:58.994]                             break
[08:27:58.994]                           }
[08:27:58.994]                         }
[08:27:58.994]                       }
[08:27:58.994]                       invisible(muffled)
[08:27:58.994]                     }
[08:27:58.994]                     muffleCondition(cond, pattern = "^muffle")
[08:27:58.994]                   }
[08:27:58.994]                 }
[08:27:58.994]                 else {
[08:27:58.994]                   if (TRUE) {
[08:27:58.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:58.994]                     {
[08:27:58.994]                       inherits <- base::inherits
[08:27:58.994]                       invokeRestart <- base::invokeRestart
[08:27:58.994]                       is.null <- base::is.null
[08:27:58.994]                       muffled <- FALSE
[08:27:58.994]                       if (inherits(cond, "message")) {
[08:27:58.994]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:58.994]                         if (muffled) 
[08:27:58.994]                           invokeRestart("muffleMessage")
[08:27:58.994]                       }
[08:27:58.994]                       else if (inherits(cond, "warning")) {
[08:27:58.994]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:58.994]                         if (muffled) 
[08:27:58.994]                           invokeRestart("muffleWarning")
[08:27:58.994]                       }
[08:27:58.994]                       else if (inherits(cond, "condition")) {
[08:27:58.994]                         if (!is.null(pattern)) {
[08:27:58.994]                           computeRestarts <- base::computeRestarts
[08:27:58.994]                           grepl <- base::grepl
[08:27:58.994]                           restarts <- computeRestarts(cond)
[08:27:58.994]                           for (restart in restarts) {
[08:27:58.994]                             name <- restart$name
[08:27:58.994]                             if (is.null(name)) 
[08:27:58.994]                               next
[08:27:58.994]                             if (!grepl(pattern, name)) 
[08:27:58.994]                               next
[08:27:58.994]                             invokeRestart(restart)
[08:27:58.994]                             muffled <- TRUE
[08:27:58.994]                             break
[08:27:58.994]                           }
[08:27:58.994]                         }
[08:27:58.994]                       }
[08:27:58.994]                       invisible(muffled)
[08:27:58.994]                     }
[08:27:58.994]                     muffleCondition(cond, pattern = "^muffle")
[08:27:58.994]                   }
[08:27:58.994]                 }
[08:27:58.994]             }
[08:27:58.994]         }))
[08:27:58.994]     }, error = function(ex) {
[08:27:58.994]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:58.994]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:58.994]                 ...future.rng), started = ...future.startTime, 
[08:27:58.994]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:58.994]             version = "1.8"), class = "FutureResult")
[08:27:58.994]     }, finally = {
[08:27:58.994]         if (!identical(...future.workdir, getwd())) 
[08:27:58.994]             setwd(...future.workdir)
[08:27:58.994]         {
[08:27:58.994]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:58.994]                 ...future.oldOptions$nwarnings <- NULL
[08:27:58.994]             }
[08:27:58.994]             base::options(...future.oldOptions)
[08:27:58.994]             if (.Platform$OS.type == "windows") {
[08:27:58.994]                 old_names <- names(...future.oldEnvVars)
[08:27:58.994]                 envs <- base::Sys.getenv()
[08:27:58.994]                 names <- names(envs)
[08:27:58.994]                 common <- intersect(names, old_names)
[08:27:58.994]                 added <- setdiff(names, old_names)
[08:27:58.994]                 removed <- setdiff(old_names, names)
[08:27:58.994]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:58.994]                   envs[common]]
[08:27:58.994]                 NAMES <- toupper(changed)
[08:27:58.994]                 args <- list()
[08:27:58.994]                 for (kk in seq_along(NAMES)) {
[08:27:58.994]                   name <- changed[[kk]]
[08:27:58.994]                   NAME <- NAMES[[kk]]
[08:27:58.994]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.994]                     next
[08:27:58.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:58.994]                 }
[08:27:58.994]                 NAMES <- toupper(added)
[08:27:58.994]                 for (kk in seq_along(NAMES)) {
[08:27:58.994]                   name <- added[[kk]]
[08:27:58.994]                   NAME <- NAMES[[kk]]
[08:27:58.994]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.994]                     next
[08:27:58.994]                   args[[name]] <- ""
[08:27:58.994]                 }
[08:27:58.994]                 NAMES <- toupper(removed)
[08:27:58.994]                 for (kk in seq_along(NAMES)) {
[08:27:58.994]                   name <- removed[[kk]]
[08:27:58.994]                   NAME <- NAMES[[kk]]
[08:27:58.994]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:58.994]                     next
[08:27:58.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:58.994]                 }
[08:27:58.994]                 if (length(args) > 0) 
[08:27:58.994]                   base::do.call(base::Sys.setenv, args = args)
[08:27:58.994]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:58.994]             }
[08:27:58.994]             else {
[08:27:58.994]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:58.994]             }
[08:27:58.994]             {
[08:27:58.994]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:58.994]                   0L) {
[08:27:58.994]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:58.994]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:58.994]                   base::options(opts)
[08:27:58.994]                 }
[08:27:58.994]                 {
[08:27:58.994]                   {
[08:27:58.994]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:58.994]                     NULL
[08:27:58.994]                   }
[08:27:58.994]                   options(future.plan = NULL)
[08:27:58.994]                   if (is.na(NA_character_)) 
[08:27:58.994]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:58.994]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:58.994]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:58.994]                     .init = FALSE)
[08:27:58.994]                 }
[08:27:58.994]             }
[08:27:58.994]         }
[08:27:58.994]     })
[08:27:58.994]     if (TRUE) {
[08:27:58.994]         base::sink(type = "output", split = FALSE)
[08:27:58.994]         if (TRUE) {
[08:27:58.994]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:58.994]         }
[08:27:58.994]         else {
[08:27:58.994]             ...future.result["stdout"] <- base::list(NULL)
[08:27:58.994]         }
[08:27:58.994]         base::close(...future.stdout)
[08:27:58.994]         ...future.stdout <- NULL
[08:27:58.994]     }
[08:27:58.994]     ...future.result$conditions <- ...future.conditions
[08:27:58.994]     ...future.result$finished <- base::Sys.time()
[08:27:58.994]     ...future.result
[08:27:58.994] }
[08:27:58.997] Exporting 2 global objects (712 bytes) to cluster node #1 ...
[08:27:58.997] Exporting ‘weight’ (191 bytes) to cluster node #1 ...
[08:27:58.998] Exporting ‘weight’ (191 bytes) to cluster node #1 ... DONE
[08:27:58.998] Exporting ‘group’ (210 bytes) to cluster node #1 ...
[08:27:58.998] Exporting ‘group’ (210 bytes) to cluster node #1 ... DONE
[08:27:58.998] Exporting 2 global objects (712 bytes) to cluster node #1 ... DONE
[08:27:58.999] MultisessionFuture started
[08:27:58.999] - Launch lazy future ... done
[08:27:58.999] run() for ‘MultisessionFuture’ ... done
[08:27:58.999] result() for ClusterFuture ...
[08:27:59.000] receiveMessageFromWorker() for ClusterFuture ...
[08:27:59.000] - Validating connection of MultisessionFuture
[08:27:59.042] - received message: FutureResult
[08:27:59.042] - Received FutureResult
[08:27:59.043] - Erased future from FutureRegistry
[08:27:59.043] result() for ClusterFuture ...
[08:27:59.043] - result already collected: FutureResult
[08:27:59.043] result() for ClusterFuture ... done
[08:27:59.043] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:59.043] result() for ClusterFuture ... done
[08:27:59.043] result() for ClusterFuture ...
[08:27:59.043] - result already collected: FutureResult
[08:27:59.044] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[08:27:59.046] getGlobalsAndPackages() ...
[08:27:59.046] Searching for globals...
[08:27:59.048] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[08:27:59.048] Searching for globals ... DONE
[08:27:59.048] Resolving globals: FALSE
[08:27:59.049] The total size of the 2 globals is 401 bytes (401 bytes)
[08:27:59.049] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[08:27:59.049] - globals: [2] ‘weight’, ‘group’
[08:27:59.050] - packages: [1] ‘stats’
[08:27:59.050] getGlobalsAndPackages() ... DONE
[08:27:59.050] run() for ‘Future’ ...
[08:27:59.050] - state: ‘created’
[08:27:59.050] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:59.067] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:59.068] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:59.068]   - Field: ‘node’
[08:27:59.068]   - Field: ‘label’
[08:27:59.068]   - Field: ‘local’
[08:27:59.068]   - Field: ‘owner’
[08:27:59.068]   - Field: ‘envir’
[08:27:59.068]   - Field: ‘workers’
[08:27:59.068]   - Field: ‘packages’
[08:27:59.068]   - Field: ‘gc’
[08:27:59.068]   - Field: ‘conditions’
[08:27:59.068]   - Field: ‘persistent’
[08:27:59.069]   - Field: ‘expr’
[08:27:59.069]   - Field: ‘uuid’
[08:27:59.069]   - Field: ‘seed’
[08:27:59.069]   - Field: ‘version’
[08:27:59.069]   - Field: ‘result’
[08:27:59.069]   - Field: ‘asynchronous’
[08:27:59.069]   - Field: ‘calls’
[08:27:59.069]   - Field: ‘globals’
[08:27:59.069]   - Field: ‘stdout’
[08:27:59.069]   - Field: ‘earlySignal’
[08:27:59.069]   - Field: ‘lazy’
[08:27:59.069]   - Field: ‘state’
[08:27:59.070] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:59.070] - Launch lazy future ...
[08:27:59.070] Packages needed by the future expression (n = 1): ‘stats’
[08:27:59.070] Packages needed by future strategies (n = 0): <none>
[08:27:59.070] {
[08:27:59.070]     {
[08:27:59.070]         {
[08:27:59.070]             ...future.startTime <- base::Sys.time()
[08:27:59.070]             {
[08:27:59.070]                 {
[08:27:59.070]                   {
[08:27:59.070]                     {
[08:27:59.070]                       {
[08:27:59.070]                         base::local({
[08:27:59.070]                           has_future <- base::requireNamespace("future", 
[08:27:59.070]                             quietly = TRUE)
[08:27:59.070]                           if (has_future) {
[08:27:59.070]                             ns <- base::getNamespace("future")
[08:27:59.070]                             version <- ns[[".package"]][["version"]]
[08:27:59.070]                             if (is.null(version)) 
[08:27:59.070]                               version <- utils::packageVersion("future")
[08:27:59.070]                           }
[08:27:59.070]                           else {
[08:27:59.070]                             version <- NULL
[08:27:59.070]                           }
[08:27:59.070]                           if (!has_future || version < "1.8.0") {
[08:27:59.070]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:59.070]                               "", base::R.version$version.string), 
[08:27:59.070]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:59.070]                                 base::R.version$platform, 8 * 
[08:27:59.070]                                   base::.Machine$sizeof.pointer), 
[08:27:59.070]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:59.070]                                 "release", "version")], collapse = " "), 
[08:27:59.070]                               hostname = base::Sys.info()[["nodename"]])
[08:27:59.070]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:59.070]                               info)
[08:27:59.070]                             info <- base::paste(info, collapse = "; ")
[08:27:59.070]                             if (!has_future) {
[08:27:59.070]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:59.070]                                 info)
[08:27:59.070]                             }
[08:27:59.070]                             else {
[08:27:59.070]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:59.070]                                 info, version)
[08:27:59.070]                             }
[08:27:59.070]                             base::stop(msg)
[08:27:59.070]                           }
[08:27:59.070]                         })
[08:27:59.070]                       }
[08:27:59.070]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:59.070]                       base::options(mc.cores = 1L)
[08:27:59.070]                     }
[08:27:59.070]                     base::local({
[08:27:59.070]                       for (pkg in "stats") {
[08:27:59.070]                         base::loadNamespace(pkg)
[08:27:59.070]                         base::library(pkg, character.only = TRUE)
[08:27:59.070]                       }
[08:27:59.070]                     })
[08:27:59.070]                   }
[08:27:59.070]                   ...future.strategy.old <- future::plan("list")
[08:27:59.070]                   options(future.plan = NULL)
[08:27:59.070]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:59.070]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:59.070]                 }
[08:27:59.070]                 ...future.workdir <- getwd()
[08:27:59.070]             }
[08:27:59.070]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:59.070]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:59.070]         }
[08:27:59.070]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:59.070]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:59.070]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:59.070]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:59.070]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:59.070]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:59.070]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:59.070]             base::names(...future.oldOptions))
[08:27:59.070]     }
[08:27:59.070]     if (FALSE) {
[08:27:59.070]     }
[08:27:59.070]     else {
[08:27:59.070]         if (TRUE) {
[08:27:59.070]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:59.070]                 open = "w")
[08:27:59.070]         }
[08:27:59.070]         else {
[08:27:59.070]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:59.070]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:59.070]         }
[08:27:59.070]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:59.070]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:59.070]             base::sink(type = "output", split = FALSE)
[08:27:59.070]             base::close(...future.stdout)
[08:27:59.070]         }, add = TRUE)
[08:27:59.070]     }
[08:27:59.070]     ...future.frame <- base::sys.nframe()
[08:27:59.070]     ...future.conditions <- base::list()
[08:27:59.070]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:59.070]     if (FALSE) {
[08:27:59.070]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:59.070]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:59.070]     }
[08:27:59.070]     ...future.result <- base::tryCatch({
[08:27:59.070]         base::withCallingHandlers({
[08:27:59.070]             ...future.value <- base::withVisible(base::local({
[08:27:59.070]                 ...future.makeSendCondition <- base::local({
[08:27:59.070]                   sendCondition <- NULL
[08:27:59.070]                   function(frame = 1L) {
[08:27:59.070]                     if (is.function(sendCondition)) 
[08:27:59.070]                       return(sendCondition)
[08:27:59.070]                     ns <- getNamespace("parallel")
[08:27:59.070]                     if (exists("sendData", mode = "function", 
[08:27:59.070]                       envir = ns)) {
[08:27:59.070]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:59.070]                         envir = ns)
[08:27:59.070]                       envir <- sys.frame(frame)
[08:27:59.070]                       master <- NULL
[08:27:59.070]                       while (!identical(envir, .GlobalEnv) && 
[08:27:59.070]                         !identical(envir, emptyenv())) {
[08:27:59.070]                         if (exists("master", mode = "list", envir = envir, 
[08:27:59.070]                           inherits = FALSE)) {
[08:27:59.070]                           master <- get("master", mode = "list", 
[08:27:59.070]                             envir = envir, inherits = FALSE)
[08:27:59.070]                           if (inherits(master, c("SOCKnode", 
[08:27:59.070]                             "SOCK0node"))) {
[08:27:59.070]                             sendCondition <<- function(cond) {
[08:27:59.070]                               data <- list(type = "VALUE", value = cond, 
[08:27:59.070]                                 success = TRUE)
[08:27:59.070]                               parallel_sendData(master, data)
[08:27:59.070]                             }
[08:27:59.070]                             return(sendCondition)
[08:27:59.070]                           }
[08:27:59.070]                         }
[08:27:59.070]                         frame <- frame + 1L
[08:27:59.070]                         envir <- sys.frame(frame)
[08:27:59.070]                       }
[08:27:59.070]                     }
[08:27:59.070]                     sendCondition <<- function(cond) NULL
[08:27:59.070]                   }
[08:27:59.070]                 })
[08:27:59.070]                 withCallingHandlers({
[08:27:59.070]                   {
[08:27:59.070]                     lm(weight ~ group - 1)
[08:27:59.070]                   }
[08:27:59.070]                 }, immediateCondition = function(cond) {
[08:27:59.070]                   sendCondition <- ...future.makeSendCondition()
[08:27:59.070]                   sendCondition(cond)
[08:27:59.070]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.070]                   {
[08:27:59.070]                     inherits <- base::inherits
[08:27:59.070]                     invokeRestart <- base::invokeRestart
[08:27:59.070]                     is.null <- base::is.null
[08:27:59.070]                     muffled <- FALSE
[08:27:59.070]                     if (inherits(cond, "message")) {
[08:27:59.070]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:59.070]                       if (muffled) 
[08:27:59.070]                         invokeRestart("muffleMessage")
[08:27:59.070]                     }
[08:27:59.070]                     else if (inherits(cond, "warning")) {
[08:27:59.070]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:59.070]                       if (muffled) 
[08:27:59.070]                         invokeRestart("muffleWarning")
[08:27:59.070]                     }
[08:27:59.070]                     else if (inherits(cond, "condition")) {
[08:27:59.070]                       if (!is.null(pattern)) {
[08:27:59.070]                         computeRestarts <- base::computeRestarts
[08:27:59.070]                         grepl <- base::grepl
[08:27:59.070]                         restarts <- computeRestarts(cond)
[08:27:59.070]                         for (restart in restarts) {
[08:27:59.070]                           name <- restart$name
[08:27:59.070]                           if (is.null(name)) 
[08:27:59.070]                             next
[08:27:59.070]                           if (!grepl(pattern, name)) 
[08:27:59.070]                             next
[08:27:59.070]                           invokeRestart(restart)
[08:27:59.070]                           muffled <- TRUE
[08:27:59.070]                           break
[08:27:59.070]                         }
[08:27:59.070]                       }
[08:27:59.070]                     }
[08:27:59.070]                     invisible(muffled)
[08:27:59.070]                   }
[08:27:59.070]                   muffleCondition(cond)
[08:27:59.070]                 })
[08:27:59.070]             }))
[08:27:59.070]             future::FutureResult(value = ...future.value$value, 
[08:27:59.070]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:59.070]                   ...future.rng), globalenv = if (FALSE) 
[08:27:59.070]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:59.070]                     ...future.globalenv.names))
[08:27:59.070]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:59.070]         }, condition = base::local({
[08:27:59.070]             c <- base::c
[08:27:59.070]             inherits <- base::inherits
[08:27:59.070]             invokeRestart <- base::invokeRestart
[08:27:59.070]             length <- base::length
[08:27:59.070]             list <- base::list
[08:27:59.070]             seq.int <- base::seq.int
[08:27:59.070]             signalCondition <- base::signalCondition
[08:27:59.070]             sys.calls <- base::sys.calls
[08:27:59.070]             `[[` <- base::`[[`
[08:27:59.070]             `+` <- base::`+`
[08:27:59.070]             `<<-` <- base::`<<-`
[08:27:59.070]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:59.070]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:59.070]                   3L)]
[08:27:59.070]             }
[08:27:59.070]             function(cond) {
[08:27:59.070]                 is_error <- inherits(cond, "error")
[08:27:59.070]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:59.070]                   NULL)
[08:27:59.070]                 if (is_error) {
[08:27:59.070]                   sessionInformation <- function() {
[08:27:59.070]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:59.070]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:59.070]                       search = base::search(), system = base::Sys.info())
[08:27:59.070]                   }
[08:27:59.070]                   ...future.conditions[[length(...future.conditions) + 
[08:27:59.070]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:59.070]                     cond$call), session = sessionInformation(), 
[08:27:59.070]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:59.070]                   signalCondition(cond)
[08:27:59.070]                 }
[08:27:59.070]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:59.070]                 "immediateCondition"))) {
[08:27:59.070]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:59.070]                   ...future.conditions[[length(...future.conditions) + 
[08:27:59.070]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:59.070]                   if (TRUE && !signal) {
[08:27:59.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.070]                     {
[08:27:59.070]                       inherits <- base::inherits
[08:27:59.070]                       invokeRestart <- base::invokeRestart
[08:27:59.070]                       is.null <- base::is.null
[08:27:59.070]                       muffled <- FALSE
[08:27:59.070]                       if (inherits(cond, "message")) {
[08:27:59.070]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:59.070]                         if (muffled) 
[08:27:59.070]                           invokeRestart("muffleMessage")
[08:27:59.070]                       }
[08:27:59.070]                       else if (inherits(cond, "warning")) {
[08:27:59.070]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:59.070]                         if (muffled) 
[08:27:59.070]                           invokeRestart("muffleWarning")
[08:27:59.070]                       }
[08:27:59.070]                       else if (inherits(cond, "condition")) {
[08:27:59.070]                         if (!is.null(pattern)) {
[08:27:59.070]                           computeRestarts <- base::computeRestarts
[08:27:59.070]                           grepl <- base::grepl
[08:27:59.070]                           restarts <- computeRestarts(cond)
[08:27:59.070]                           for (restart in restarts) {
[08:27:59.070]                             name <- restart$name
[08:27:59.070]                             if (is.null(name)) 
[08:27:59.070]                               next
[08:27:59.070]                             if (!grepl(pattern, name)) 
[08:27:59.070]                               next
[08:27:59.070]                             invokeRestart(restart)
[08:27:59.070]                             muffled <- TRUE
[08:27:59.070]                             break
[08:27:59.070]                           }
[08:27:59.070]                         }
[08:27:59.070]                       }
[08:27:59.070]                       invisible(muffled)
[08:27:59.070]                     }
[08:27:59.070]                     muffleCondition(cond, pattern = "^muffle")
[08:27:59.070]                   }
[08:27:59.070]                 }
[08:27:59.070]                 else {
[08:27:59.070]                   if (TRUE) {
[08:27:59.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.070]                     {
[08:27:59.070]                       inherits <- base::inherits
[08:27:59.070]                       invokeRestart <- base::invokeRestart
[08:27:59.070]                       is.null <- base::is.null
[08:27:59.070]                       muffled <- FALSE
[08:27:59.070]                       if (inherits(cond, "message")) {
[08:27:59.070]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:59.070]                         if (muffled) 
[08:27:59.070]                           invokeRestart("muffleMessage")
[08:27:59.070]                       }
[08:27:59.070]                       else if (inherits(cond, "warning")) {
[08:27:59.070]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:59.070]                         if (muffled) 
[08:27:59.070]                           invokeRestart("muffleWarning")
[08:27:59.070]                       }
[08:27:59.070]                       else if (inherits(cond, "condition")) {
[08:27:59.070]                         if (!is.null(pattern)) {
[08:27:59.070]                           computeRestarts <- base::computeRestarts
[08:27:59.070]                           grepl <- base::grepl
[08:27:59.070]                           restarts <- computeRestarts(cond)
[08:27:59.070]                           for (restart in restarts) {
[08:27:59.070]                             name <- restart$name
[08:27:59.070]                             if (is.null(name)) 
[08:27:59.070]                               next
[08:27:59.070]                             if (!grepl(pattern, name)) 
[08:27:59.070]                               next
[08:27:59.070]                             invokeRestart(restart)
[08:27:59.070]                             muffled <- TRUE
[08:27:59.070]                             break
[08:27:59.070]                           }
[08:27:59.070]                         }
[08:27:59.070]                       }
[08:27:59.070]                       invisible(muffled)
[08:27:59.070]                     }
[08:27:59.070]                     muffleCondition(cond, pattern = "^muffle")
[08:27:59.070]                   }
[08:27:59.070]                 }
[08:27:59.070]             }
[08:27:59.070]         }))
[08:27:59.070]     }, error = function(ex) {
[08:27:59.070]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:59.070]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:59.070]                 ...future.rng), started = ...future.startTime, 
[08:27:59.070]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:59.070]             version = "1.8"), class = "FutureResult")
[08:27:59.070]     }, finally = {
[08:27:59.070]         if (!identical(...future.workdir, getwd())) 
[08:27:59.070]             setwd(...future.workdir)
[08:27:59.070]         {
[08:27:59.070]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:59.070]                 ...future.oldOptions$nwarnings <- NULL
[08:27:59.070]             }
[08:27:59.070]             base::options(...future.oldOptions)
[08:27:59.070]             if (.Platform$OS.type == "windows") {
[08:27:59.070]                 old_names <- names(...future.oldEnvVars)
[08:27:59.070]                 envs <- base::Sys.getenv()
[08:27:59.070]                 names <- names(envs)
[08:27:59.070]                 common <- intersect(names, old_names)
[08:27:59.070]                 added <- setdiff(names, old_names)
[08:27:59.070]                 removed <- setdiff(old_names, names)
[08:27:59.070]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:59.070]                   envs[common]]
[08:27:59.070]                 NAMES <- toupper(changed)
[08:27:59.070]                 args <- list()
[08:27:59.070]                 for (kk in seq_along(NAMES)) {
[08:27:59.070]                   name <- changed[[kk]]
[08:27:59.070]                   NAME <- NAMES[[kk]]
[08:27:59.070]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.070]                     next
[08:27:59.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:59.070]                 }
[08:27:59.070]                 NAMES <- toupper(added)
[08:27:59.070]                 for (kk in seq_along(NAMES)) {
[08:27:59.070]                   name <- added[[kk]]
[08:27:59.070]                   NAME <- NAMES[[kk]]
[08:27:59.070]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.070]                     next
[08:27:59.070]                   args[[name]] <- ""
[08:27:59.070]                 }
[08:27:59.070]                 NAMES <- toupper(removed)
[08:27:59.070]                 for (kk in seq_along(NAMES)) {
[08:27:59.070]                   name <- removed[[kk]]
[08:27:59.070]                   NAME <- NAMES[[kk]]
[08:27:59.070]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.070]                     next
[08:27:59.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:59.070]                 }
[08:27:59.070]                 if (length(args) > 0) 
[08:27:59.070]                   base::do.call(base::Sys.setenv, args = args)
[08:27:59.070]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:59.070]             }
[08:27:59.070]             else {
[08:27:59.070]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:59.070]             }
[08:27:59.070]             {
[08:27:59.070]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:59.070]                   0L) {
[08:27:59.070]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:59.070]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:59.070]                   base::options(opts)
[08:27:59.070]                 }
[08:27:59.070]                 {
[08:27:59.070]                   {
[08:27:59.070]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:59.070]                     NULL
[08:27:59.070]                   }
[08:27:59.070]                   options(future.plan = NULL)
[08:27:59.070]                   if (is.na(NA_character_)) 
[08:27:59.070]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:59.070]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:59.070]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:59.070]                     .init = FALSE)
[08:27:59.070]                 }
[08:27:59.070]             }
[08:27:59.070]         }
[08:27:59.070]     })
[08:27:59.070]     if (TRUE) {
[08:27:59.070]         base::sink(type = "output", split = FALSE)
[08:27:59.070]         if (TRUE) {
[08:27:59.070]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:59.070]         }
[08:27:59.070]         else {
[08:27:59.070]             ...future.result["stdout"] <- base::list(NULL)
[08:27:59.070]         }
[08:27:59.070]         base::close(...future.stdout)
[08:27:59.070]         ...future.stdout <- NULL
[08:27:59.070]     }
[08:27:59.070]     ...future.result$conditions <- ...future.conditions
[08:27:59.070]     ...future.result$finished <- base::Sys.time()
[08:27:59.070]     ...future.result
[08:27:59.070] }
[08:27:59.073] Exporting 2 global objects (712 bytes) to cluster node #1 ...
[08:27:59.073] Exporting ‘weight’ (191 bytes) to cluster node #1 ...
[08:27:59.074] Exporting ‘weight’ (191 bytes) to cluster node #1 ... DONE
[08:27:59.074] Exporting ‘group’ (210 bytes) to cluster node #1 ...
[08:27:59.074] Exporting ‘group’ (210 bytes) to cluster node #1 ... DONE
[08:27:59.074] Exporting 2 global objects (712 bytes) to cluster node #1 ... DONE
[08:27:59.075] MultisessionFuture started
[08:27:59.075] - Launch lazy future ... done
[08:27:59.075] run() for ‘MultisessionFuture’ ... done
[08:27:59.075] result() for ClusterFuture ...
[08:27:59.075] receiveMessageFromWorker() for ClusterFuture ...
[08:27:59.075] - Validating connection of MultisessionFuture
[08:27:59.118] - received message: FutureResult
[08:27:59.118] - Received FutureResult
[08:27:59.118] - Erased future from FutureRegistry
[08:27:59.119] result() for ClusterFuture ...
[08:27:59.119] - result already collected: FutureResult
[08:27:59.119] result() for ClusterFuture ... done
[08:27:59.119] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:59.119] result() for ClusterFuture ... done
[08:27:59.119] result() for ClusterFuture ...
[08:27:59.119] - result already collected: FutureResult
[08:27:59.119] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[08:27:59.121] getGlobalsAndPackages() ...
[08:27:59.121] Searching for globals...
[08:27:59.122] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[08:27:59.122] Searching for globals ... DONE
[08:27:59.122] Resolving globals: FALSE
[08:27:59.123] The total size of the 1 globals is 71 bytes (71 bytes)
[08:27:59.123] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 71 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (71 bytes of class ‘numeric’)
[08:27:59.123] - globals: [1] ‘x’
[08:27:59.123] - packages: [1] ‘stats’
[08:27:59.123] getGlobalsAndPackages() ... DONE
[08:27:59.124] run() for ‘Future’ ...
[08:27:59.124] - state: ‘created’
[08:27:59.124] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:59.138] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:59.138] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:59.138]   - Field: ‘node’
[08:27:59.138]   - Field: ‘label’
[08:27:59.138]   - Field: ‘local’
[08:27:59.138]   - Field: ‘owner’
[08:27:59.138]   - Field: ‘envir’
[08:27:59.138]   - Field: ‘workers’
[08:27:59.138]   - Field: ‘packages’
[08:27:59.138]   - Field: ‘gc’
[08:27:59.139]   - Field: ‘conditions’
[08:27:59.139]   - Field: ‘persistent’
[08:27:59.139]   - Field: ‘expr’
[08:27:59.139]   - Field: ‘uuid’
[08:27:59.139]   - Field: ‘seed’
[08:27:59.139]   - Field: ‘version’
[08:27:59.139]   - Field: ‘result’
[08:27:59.139]   - Field: ‘asynchronous’
[08:27:59.139]   - Field: ‘calls’
[08:27:59.139]   - Field: ‘globals’
[08:27:59.139]   - Field: ‘stdout’
[08:27:59.139]   - Field: ‘earlySignal’
[08:27:59.140]   - Field: ‘lazy’
[08:27:59.140]   - Field: ‘state’
[08:27:59.140] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:59.140] - Launch lazy future ...
[08:27:59.140] Packages needed by the future expression (n = 1): ‘stats’
[08:27:59.140] Packages needed by future strategies (n = 0): <none>
[08:27:59.141] {
[08:27:59.141]     {
[08:27:59.141]         {
[08:27:59.141]             ...future.startTime <- base::Sys.time()
[08:27:59.141]             {
[08:27:59.141]                 {
[08:27:59.141]                   {
[08:27:59.141]                     {
[08:27:59.141]                       {
[08:27:59.141]                         base::local({
[08:27:59.141]                           has_future <- base::requireNamespace("future", 
[08:27:59.141]                             quietly = TRUE)
[08:27:59.141]                           if (has_future) {
[08:27:59.141]                             ns <- base::getNamespace("future")
[08:27:59.141]                             version <- ns[[".package"]][["version"]]
[08:27:59.141]                             if (is.null(version)) 
[08:27:59.141]                               version <- utils::packageVersion("future")
[08:27:59.141]                           }
[08:27:59.141]                           else {
[08:27:59.141]                             version <- NULL
[08:27:59.141]                           }
[08:27:59.141]                           if (!has_future || version < "1.8.0") {
[08:27:59.141]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:59.141]                               "", base::R.version$version.string), 
[08:27:59.141]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:59.141]                                 base::R.version$platform, 8 * 
[08:27:59.141]                                   base::.Machine$sizeof.pointer), 
[08:27:59.141]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:59.141]                                 "release", "version")], collapse = " "), 
[08:27:59.141]                               hostname = base::Sys.info()[["nodename"]])
[08:27:59.141]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:59.141]                               info)
[08:27:59.141]                             info <- base::paste(info, collapse = "; ")
[08:27:59.141]                             if (!has_future) {
[08:27:59.141]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:59.141]                                 info)
[08:27:59.141]                             }
[08:27:59.141]                             else {
[08:27:59.141]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:59.141]                                 info, version)
[08:27:59.141]                             }
[08:27:59.141]                             base::stop(msg)
[08:27:59.141]                           }
[08:27:59.141]                         })
[08:27:59.141]                       }
[08:27:59.141]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:59.141]                       base::options(mc.cores = 1L)
[08:27:59.141]                     }
[08:27:59.141]                     base::local({
[08:27:59.141]                       for (pkg in "stats") {
[08:27:59.141]                         base::loadNamespace(pkg)
[08:27:59.141]                         base::library(pkg, character.only = TRUE)
[08:27:59.141]                       }
[08:27:59.141]                     })
[08:27:59.141]                   }
[08:27:59.141]                   ...future.strategy.old <- future::plan("list")
[08:27:59.141]                   options(future.plan = NULL)
[08:27:59.141]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:59.141]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:59.141]                 }
[08:27:59.141]                 ...future.workdir <- getwd()
[08:27:59.141]             }
[08:27:59.141]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:59.141]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:59.141]         }
[08:27:59.141]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:59.141]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:59.141]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:59.141]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:59.141]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:59.141]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:59.141]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:59.141]             base::names(...future.oldOptions))
[08:27:59.141]     }
[08:27:59.141]     if (FALSE) {
[08:27:59.141]     }
[08:27:59.141]     else {
[08:27:59.141]         if (TRUE) {
[08:27:59.141]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:59.141]                 open = "w")
[08:27:59.141]         }
[08:27:59.141]         else {
[08:27:59.141]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:59.141]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:59.141]         }
[08:27:59.141]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:59.141]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:59.141]             base::sink(type = "output", split = FALSE)
[08:27:59.141]             base::close(...future.stdout)
[08:27:59.141]         }, add = TRUE)
[08:27:59.141]     }
[08:27:59.141]     ...future.frame <- base::sys.nframe()
[08:27:59.141]     ...future.conditions <- base::list()
[08:27:59.141]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:59.141]     if (FALSE) {
[08:27:59.141]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:59.141]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:59.141]     }
[08:27:59.141]     ...future.result <- base::tryCatch({
[08:27:59.141]         base::withCallingHandlers({
[08:27:59.141]             ...future.value <- base::withVisible(base::local({
[08:27:59.141]                 ...future.makeSendCondition <- base::local({
[08:27:59.141]                   sendCondition <- NULL
[08:27:59.141]                   function(frame = 1L) {
[08:27:59.141]                     if (is.function(sendCondition)) 
[08:27:59.141]                       return(sendCondition)
[08:27:59.141]                     ns <- getNamespace("parallel")
[08:27:59.141]                     if (exists("sendData", mode = "function", 
[08:27:59.141]                       envir = ns)) {
[08:27:59.141]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:59.141]                         envir = ns)
[08:27:59.141]                       envir <- sys.frame(frame)
[08:27:59.141]                       master <- NULL
[08:27:59.141]                       while (!identical(envir, .GlobalEnv) && 
[08:27:59.141]                         !identical(envir, emptyenv())) {
[08:27:59.141]                         if (exists("master", mode = "list", envir = envir, 
[08:27:59.141]                           inherits = FALSE)) {
[08:27:59.141]                           master <- get("master", mode = "list", 
[08:27:59.141]                             envir = envir, inherits = FALSE)
[08:27:59.141]                           if (inherits(master, c("SOCKnode", 
[08:27:59.141]                             "SOCK0node"))) {
[08:27:59.141]                             sendCondition <<- function(cond) {
[08:27:59.141]                               data <- list(type = "VALUE", value = cond, 
[08:27:59.141]                                 success = TRUE)
[08:27:59.141]                               parallel_sendData(master, data)
[08:27:59.141]                             }
[08:27:59.141]                             return(sendCondition)
[08:27:59.141]                           }
[08:27:59.141]                         }
[08:27:59.141]                         frame <- frame + 1L
[08:27:59.141]                         envir <- sys.frame(frame)
[08:27:59.141]                       }
[08:27:59.141]                     }
[08:27:59.141]                     sendCondition <<- function(cond) NULL
[08:27:59.141]                   }
[08:27:59.141]                 })
[08:27:59.141]                 withCallingHandlers({
[08:27:59.141]                   {
[08:27:59.141]                     xtabs(~x)
[08:27:59.141]                   }
[08:27:59.141]                 }, immediateCondition = function(cond) {
[08:27:59.141]                   sendCondition <- ...future.makeSendCondition()
[08:27:59.141]                   sendCondition(cond)
[08:27:59.141]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.141]                   {
[08:27:59.141]                     inherits <- base::inherits
[08:27:59.141]                     invokeRestart <- base::invokeRestart
[08:27:59.141]                     is.null <- base::is.null
[08:27:59.141]                     muffled <- FALSE
[08:27:59.141]                     if (inherits(cond, "message")) {
[08:27:59.141]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:59.141]                       if (muffled) 
[08:27:59.141]                         invokeRestart("muffleMessage")
[08:27:59.141]                     }
[08:27:59.141]                     else if (inherits(cond, "warning")) {
[08:27:59.141]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:59.141]                       if (muffled) 
[08:27:59.141]                         invokeRestart("muffleWarning")
[08:27:59.141]                     }
[08:27:59.141]                     else if (inherits(cond, "condition")) {
[08:27:59.141]                       if (!is.null(pattern)) {
[08:27:59.141]                         computeRestarts <- base::computeRestarts
[08:27:59.141]                         grepl <- base::grepl
[08:27:59.141]                         restarts <- computeRestarts(cond)
[08:27:59.141]                         for (restart in restarts) {
[08:27:59.141]                           name <- restart$name
[08:27:59.141]                           if (is.null(name)) 
[08:27:59.141]                             next
[08:27:59.141]                           if (!grepl(pattern, name)) 
[08:27:59.141]                             next
[08:27:59.141]                           invokeRestart(restart)
[08:27:59.141]                           muffled <- TRUE
[08:27:59.141]                           break
[08:27:59.141]                         }
[08:27:59.141]                       }
[08:27:59.141]                     }
[08:27:59.141]                     invisible(muffled)
[08:27:59.141]                   }
[08:27:59.141]                   muffleCondition(cond)
[08:27:59.141]                 })
[08:27:59.141]             }))
[08:27:59.141]             future::FutureResult(value = ...future.value$value, 
[08:27:59.141]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:59.141]                   ...future.rng), globalenv = if (FALSE) 
[08:27:59.141]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:59.141]                     ...future.globalenv.names))
[08:27:59.141]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:59.141]         }, condition = base::local({
[08:27:59.141]             c <- base::c
[08:27:59.141]             inherits <- base::inherits
[08:27:59.141]             invokeRestart <- base::invokeRestart
[08:27:59.141]             length <- base::length
[08:27:59.141]             list <- base::list
[08:27:59.141]             seq.int <- base::seq.int
[08:27:59.141]             signalCondition <- base::signalCondition
[08:27:59.141]             sys.calls <- base::sys.calls
[08:27:59.141]             `[[` <- base::`[[`
[08:27:59.141]             `+` <- base::`+`
[08:27:59.141]             `<<-` <- base::`<<-`
[08:27:59.141]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:59.141]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:59.141]                   3L)]
[08:27:59.141]             }
[08:27:59.141]             function(cond) {
[08:27:59.141]                 is_error <- inherits(cond, "error")
[08:27:59.141]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:59.141]                   NULL)
[08:27:59.141]                 if (is_error) {
[08:27:59.141]                   sessionInformation <- function() {
[08:27:59.141]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:59.141]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:59.141]                       search = base::search(), system = base::Sys.info())
[08:27:59.141]                   }
[08:27:59.141]                   ...future.conditions[[length(...future.conditions) + 
[08:27:59.141]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:59.141]                     cond$call), session = sessionInformation(), 
[08:27:59.141]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:59.141]                   signalCondition(cond)
[08:27:59.141]                 }
[08:27:59.141]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:59.141]                 "immediateCondition"))) {
[08:27:59.141]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:59.141]                   ...future.conditions[[length(...future.conditions) + 
[08:27:59.141]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:59.141]                   if (TRUE && !signal) {
[08:27:59.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.141]                     {
[08:27:59.141]                       inherits <- base::inherits
[08:27:59.141]                       invokeRestart <- base::invokeRestart
[08:27:59.141]                       is.null <- base::is.null
[08:27:59.141]                       muffled <- FALSE
[08:27:59.141]                       if (inherits(cond, "message")) {
[08:27:59.141]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:59.141]                         if (muffled) 
[08:27:59.141]                           invokeRestart("muffleMessage")
[08:27:59.141]                       }
[08:27:59.141]                       else if (inherits(cond, "warning")) {
[08:27:59.141]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:59.141]                         if (muffled) 
[08:27:59.141]                           invokeRestart("muffleWarning")
[08:27:59.141]                       }
[08:27:59.141]                       else if (inherits(cond, "condition")) {
[08:27:59.141]                         if (!is.null(pattern)) {
[08:27:59.141]                           computeRestarts <- base::computeRestarts
[08:27:59.141]                           grepl <- base::grepl
[08:27:59.141]                           restarts <- computeRestarts(cond)
[08:27:59.141]                           for (restart in restarts) {
[08:27:59.141]                             name <- restart$name
[08:27:59.141]                             if (is.null(name)) 
[08:27:59.141]                               next
[08:27:59.141]                             if (!grepl(pattern, name)) 
[08:27:59.141]                               next
[08:27:59.141]                             invokeRestart(restart)
[08:27:59.141]                             muffled <- TRUE
[08:27:59.141]                             break
[08:27:59.141]                           }
[08:27:59.141]                         }
[08:27:59.141]                       }
[08:27:59.141]                       invisible(muffled)
[08:27:59.141]                     }
[08:27:59.141]                     muffleCondition(cond, pattern = "^muffle")
[08:27:59.141]                   }
[08:27:59.141]                 }
[08:27:59.141]                 else {
[08:27:59.141]                   if (TRUE) {
[08:27:59.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.141]                     {
[08:27:59.141]                       inherits <- base::inherits
[08:27:59.141]                       invokeRestart <- base::invokeRestart
[08:27:59.141]                       is.null <- base::is.null
[08:27:59.141]                       muffled <- FALSE
[08:27:59.141]                       if (inherits(cond, "message")) {
[08:27:59.141]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:59.141]                         if (muffled) 
[08:27:59.141]                           invokeRestart("muffleMessage")
[08:27:59.141]                       }
[08:27:59.141]                       else if (inherits(cond, "warning")) {
[08:27:59.141]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:59.141]                         if (muffled) 
[08:27:59.141]                           invokeRestart("muffleWarning")
[08:27:59.141]                       }
[08:27:59.141]                       else if (inherits(cond, "condition")) {
[08:27:59.141]                         if (!is.null(pattern)) {
[08:27:59.141]                           computeRestarts <- base::computeRestarts
[08:27:59.141]                           grepl <- base::grepl
[08:27:59.141]                           restarts <- computeRestarts(cond)
[08:27:59.141]                           for (restart in restarts) {
[08:27:59.141]                             name <- restart$name
[08:27:59.141]                             if (is.null(name)) 
[08:27:59.141]                               next
[08:27:59.141]                             if (!grepl(pattern, name)) 
[08:27:59.141]                               next
[08:27:59.141]                             invokeRestart(restart)
[08:27:59.141]                             muffled <- TRUE
[08:27:59.141]                             break
[08:27:59.141]                           }
[08:27:59.141]                         }
[08:27:59.141]                       }
[08:27:59.141]                       invisible(muffled)
[08:27:59.141]                     }
[08:27:59.141]                     muffleCondition(cond, pattern = "^muffle")
[08:27:59.141]                   }
[08:27:59.141]                 }
[08:27:59.141]             }
[08:27:59.141]         }))
[08:27:59.141]     }, error = function(ex) {
[08:27:59.141]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:59.141]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:59.141]                 ...future.rng), started = ...future.startTime, 
[08:27:59.141]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:59.141]             version = "1.8"), class = "FutureResult")
[08:27:59.141]     }, finally = {
[08:27:59.141]         if (!identical(...future.workdir, getwd())) 
[08:27:59.141]             setwd(...future.workdir)
[08:27:59.141]         {
[08:27:59.141]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:59.141]                 ...future.oldOptions$nwarnings <- NULL
[08:27:59.141]             }
[08:27:59.141]             base::options(...future.oldOptions)
[08:27:59.141]             if (.Platform$OS.type == "windows") {
[08:27:59.141]                 old_names <- names(...future.oldEnvVars)
[08:27:59.141]                 envs <- base::Sys.getenv()
[08:27:59.141]                 names <- names(envs)
[08:27:59.141]                 common <- intersect(names, old_names)
[08:27:59.141]                 added <- setdiff(names, old_names)
[08:27:59.141]                 removed <- setdiff(old_names, names)
[08:27:59.141]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:59.141]                   envs[common]]
[08:27:59.141]                 NAMES <- toupper(changed)
[08:27:59.141]                 args <- list()
[08:27:59.141]                 for (kk in seq_along(NAMES)) {
[08:27:59.141]                   name <- changed[[kk]]
[08:27:59.141]                   NAME <- NAMES[[kk]]
[08:27:59.141]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.141]                     next
[08:27:59.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:59.141]                 }
[08:27:59.141]                 NAMES <- toupper(added)
[08:27:59.141]                 for (kk in seq_along(NAMES)) {
[08:27:59.141]                   name <- added[[kk]]
[08:27:59.141]                   NAME <- NAMES[[kk]]
[08:27:59.141]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.141]                     next
[08:27:59.141]                   args[[name]] <- ""
[08:27:59.141]                 }
[08:27:59.141]                 NAMES <- toupper(removed)
[08:27:59.141]                 for (kk in seq_along(NAMES)) {
[08:27:59.141]                   name <- removed[[kk]]
[08:27:59.141]                   NAME <- NAMES[[kk]]
[08:27:59.141]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.141]                     next
[08:27:59.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:59.141]                 }
[08:27:59.141]                 if (length(args) > 0) 
[08:27:59.141]                   base::do.call(base::Sys.setenv, args = args)
[08:27:59.141]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:59.141]             }
[08:27:59.141]             else {
[08:27:59.141]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:59.141]             }
[08:27:59.141]             {
[08:27:59.141]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:59.141]                   0L) {
[08:27:59.141]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:59.141]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:59.141]                   base::options(opts)
[08:27:59.141]                 }
[08:27:59.141]                 {
[08:27:59.141]                   {
[08:27:59.141]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:59.141]                     NULL
[08:27:59.141]                   }
[08:27:59.141]                   options(future.plan = NULL)
[08:27:59.141]                   if (is.na(NA_character_)) 
[08:27:59.141]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:59.141]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:59.141]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:59.141]                     .init = FALSE)
[08:27:59.141]                 }
[08:27:59.141]             }
[08:27:59.141]         }
[08:27:59.141]     })
[08:27:59.141]     if (TRUE) {
[08:27:59.141]         base::sink(type = "output", split = FALSE)
[08:27:59.141]         if (TRUE) {
[08:27:59.141]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:59.141]         }
[08:27:59.141]         else {
[08:27:59.141]             ...future.result["stdout"] <- base::list(NULL)
[08:27:59.141]         }
[08:27:59.141]         base::close(...future.stdout)
[08:27:59.141]         ...future.stdout <- NULL
[08:27:59.141]     }
[08:27:59.141]     ...future.result$conditions <- ...future.conditions
[08:27:59.141]     ...future.result$finished <- base::Sys.time()
[08:27:59.141]     ...future.result
[08:27:59.141] }
[08:27:59.143] Exporting 1 global objects (378 bytes) to cluster node #1 ...
[08:27:59.143] Exporting ‘x’ (71 bytes) to cluster node #1 ...
[08:27:59.144] Exporting ‘x’ (71 bytes) to cluster node #1 ... DONE
[08:27:59.144] Exporting 1 global objects (378 bytes) to cluster node #1 ... DONE
[08:27:59.144] MultisessionFuture started
[08:27:59.145] - Launch lazy future ... done
[08:27:59.145] run() for ‘MultisessionFuture’ ... done
[08:27:59.145] result() for ClusterFuture ...
[08:27:59.145] receiveMessageFromWorker() for ClusterFuture ...
[08:27:59.145] - Validating connection of MultisessionFuture
[08:27:59.188] - received message: FutureResult
[08:27:59.188] - Received FutureResult
[08:27:59.188] - Erased future from FutureRegistry
[08:27:59.188] result() for ClusterFuture ...
[08:27:59.188] - result already collected: FutureResult
[08:27:59.188] result() for ClusterFuture ... done
[08:27:59.188] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:59.188] result() for ClusterFuture ... done
[08:27:59.189] result() for ClusterFuture ...
[08:27:59.189] - result already collected: FutureResult
[08:27:59.189] result() for ClusterFuture ... done
x
1 2 
2 3 
[08:27:59.189] getGlobalsAndPackages() ...
[08:27:59.189] Searching for globals...
[08:27:59.191] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[08:27:59.191] Searching for globals ... DONE
[08:27:59.191] Resolving globals: FALSE
[08:27:59.191] The total size of the 1 globals is 71 bytes (71 bytes)
[08:27:59.191] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 71 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (71 bytes of class ‘numeric’)
[08:27:59.192] - globals: [1] ‘x’
[08:27:59.192] - packages: [1] ‘stats’
[08:27:59.192] getGlobalsAndPackages() ... DONE
[08:27:59.192] run() for ‘Future’ ...
[08:27:59.192] - state: ‘created’
[08:27:59.192] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:59.206] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:59.207] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:59.207]   - Field: ‘node’
[08:27:59.207]   - Field: ‘label’
[08:27:59.207]   - Field: ‘local’
[08:27:59.207]   - Field: ‘owner’
[08:27:59.207]   - Field: ‘envir’
[08:27:59.207]   - Field: ‘workers’
[08:27:59.207]   - Field: ‘packages’
[08:27:59.207]   - Field: ‘gc’
[08:27:59.207]   - Field: ‘conditions’
[08:27:59.208]   - Field: ‘persistent’
[08:27:59.208]   - Field: ‘expr’
[08:27:59.208]   - Field: ‘uuid’
[08:27:59.208]   - Field: ‘seed’
[08:27:59.208]   - Field: ‘version’
[08:27:59.208]   - Field: ‘result’
[08:27:59.208]   - Field: ‘asynchronous’
[08:27:59.208]   - Field: ‘calls’
[08:27:59.208]   - Field: ‘globals’
[08:27:59.208]   - Field: ‘stdout’
[08:27:59.208]   - Field: ‘earlySignal’
[08:27:59.208]   - Field: ‘lazy’
[08:27:59.209]   - Field: ‘state’
[08:27:59.209] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:59.209] - Launch lazy future ...
[08:27:59.209] Packages needed by the future expression (n = 1): ‘stats’
[08:27:59.209] Packages needed by future strategies (n = 0): <none>
[08:27:59.210] {
[08:27:59.210]     {
[08:27:59.210]         {
[08:27:59.210]             ...future.startTime <- base::Sys.time()
[08:27:59.210]             {
[08:27:59.210]                 {
[08:27:59.210]                   {
[08:27:59.210]                     {
[08:27:59.210]                       {
[08:27:59.210]                         base::local({
[08:27:59.210]                           has_future <- base::requireNamespace("future", 
[08:27:59.210]                             quietly = TRUE)
[08:27:59.210]                           if (has_future) {
[08:27:59.210]                             ns <- base::getNamespace("future")
[08:27:59.210]                             version <- ns[[".package"]][["version"]]
[08:27:59.210]                             if (is.null(version)) 
[08:27:59.210]                               version <- utils::packageVersion("future")
[08:27:59.210]                           }
[08:27:59.210]                           else {
[08:27:59.210]                             version <- NULL
[08:27:59.210]                           }
[08:27:59.210]                           if (!has_future || version < "1.8.0") {
[08:27:59.210]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:59.210]                               "", base::R.version$version.string), 
[08:27:59.210]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:59.210]                                 base::R.version$platform, 8 * 
[08:27:59.210]                                   base::.Machine$sizeof.pointer), 
[08:27:59.210]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:59.210]                                 "release", "version")], collapse = " "), 
[08:27:59.210]                               hostname = base::Sys.info()[["nodename"]])
[08:27:59.210]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:59.210]                               info)
[08:27:59.210]                             info <- base::paste(info, collapse = "; ")
[08:27:59.210]                             if (!has_future) {
[08:27:59.210]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:59.210]                                 info)
[08:27:59.210]                             }
[08:27:59.210]                             else {
[08:27:59.210]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:59.210]                                 info, version)
[08:27:59.210]                             }
[08:27:59.210]                             base::stop(msg)
[08:27:59.210]                           }
[08:27:59.210]                         })
[08:27:59.210]                       }
[08:27:59.210]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:59.210]                       base::options(mc.cores = 1L)
[08:27:59.210]                     }
[08:27:59.210]                     base::local({
[08:27:59.210]                       for (pkg in "stats") {
[08:27:59.210]                         base::loadNamespace(pkg)
[08:27:59.210]                         base::library(pkg, character.only = TRUE)
[08:27:59.210]                       }
[08:27:59.210]                     })
[08:27:59.210]                   }
[08:27:59.210]                   ...future.strategy.old <- future::plan("list")
[08:27:59.210]                   options(future.plan = NULL)
[08:27:59.210]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:59.210]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:59.210]                 }
[08:27:59.210]                 ...future.workdir <- getwd()
[08:27:59.210]             }
[08:27:59.210]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:59.210]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:59.210]         }
[08:27:59.210]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:59.210]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:59.210]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:59.210]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:59.210]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:59.210]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:59.210]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:59.210]             base::names(...future.oldOptions))
[08:27:59.210]     }
[08:27:59.210]     if (FALSE) {
[08:27:59.210]     }
[08:27:59.210]     else {
[08:27:59.210]         if (TRUE) {
[08:27:59.210]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:59.210]                 open = "w")
[08:27:59.210]         }
[08:27:59.210]         else {
[08:27:59.210]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:59.210]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:59.210]         }
[08:27:59.210]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:59.210]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:59.210]             base::sink(type = "output", split = FALSE)
[08:27:59.210]             base::close(...future.stdout)
[08:27:59.210]         }, add = TRUE)
[08:27:59.210]     }
[08:27:59.210]     ...future.frame <- base::sys.nframe()
[08:27:59.210]     ...future.conditions <- base::list()
[08:27:59.210]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:59.210]     if (FALSE) {
[08:27:59.210]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:59.210]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:59.210]     }
[08:27:59.210]     ...future.result <- base::tryCatch({
[08:27:59.210]         base::withCallingHandlers({
[08:27:59.210]             ...future.value <- base::withVisible(base::local({
[08:27:59.210]                 ...future.makeSendCondition <- base::local({
[08:27:59.210]                   sendCondition <- NULL
[08:27:59.210]                   function(frame = 1L) {
[08:27:59.210]                     if (is.function(sendCondition)) 
[08:27:59.210]                       return(sendCondition)
[08:27:59.210]                     ns <- getNamespace("parallel")
[08:27:59.210]                     if (exists("sendData", mode = "function", 
[08:27:59.210]                       envir = ns)) {
[08:27:59.210]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:59.210]                         envir = ns)
[08:27:59.210]                       envir <- sys.frame(frame)
[08:27:59.210]                       master <- NULL
[08:27:59.210]                       while (!identical(envir, .GlobalEnv) && 
[08:27:59.210]                         !identical(envir, emptyenv())) {
[08:27:59.210]                         if (exists("master", mode = "list", envir = envir, 
[08:27:59.210]                           inherits = FALSE)) {
[08:27:59.210]                           master <- get("master", mode = "list", 
[08:27:59.210]                             envir = envir, inherits = FALSE)
[08:27:59.210]                           if (inherits(master, c("SOCKnode", 
[08:27:59.210]                             "SOCK0node"))) {
[08:27:59.210]                             sendCondition <<- function(cond) {
[08:27:59.210]                               data <- list(type = "VALUE", value = cond, 
[08:27:59.210]                                 success = TRUE)
[08:27:59.210]                               parallel_sendData(master, data)
[08:27:59.210]                             }
[08:27:59.210]                             return(sendCondition)
[08:27:59.210]                           }
[08:27:59.210]                         }
[08:27:59.210]                         frame <- frame + 1L
[08:27:59.210]                         envir <- sys.frame(frame)
[08:27:59.210]                       }
[08:27:59.210]                     }
[08:27:59.210]                     sendCondition <<- function(cond) NULL
[08:27:59.210]                   }
[08:27:59.210]                 })
[08:27:59.210]                 withCallingHandlers({
[08:27:59.210]                   {
[08:27:59.210]                     xtabs(~x)
[08:27:59.210]                   }
[08:27:59.210]                 }, immediateCondition = function(cond) {
[08:27:59.210]                   sendCondition <- ...future.makeSendCondition()
[08:27:59.210]                   sendCondition(cond)
[08:27:59.210]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.210]                   {
[08:27:59.210]                     inherits <- base::inherits
[08:27:59.210]                     invokeRestart <- base::invokeRestart
[08:27:59.210]                     is.null <- base::is.null
[08:27:59.210]                     muffled <- FALSE
[08:27:59.210]                     if (inherits(cond, "message")) {
[08:27:59.210]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:59.210]                       if (muffled) 
[08:27:59.210]                         invokeRestart("muffleMessage")
[08:27:59.210]                     }
[08:27:59.210]                     else if (inherits(cond, "warning")) {
[08:27:59.210]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:59.210]                       if (muffled) 
[08:27:59.210]                         invokeRestart("muffleWarning")
[08:27:59.210]                     }
[08:27:59.210]                     else if (inherits(cond, "condition")) {
[08:27:59.210]                       if (!is.null(pattern)) {
[08:27:59.210]                         computeRestarts <- base::computeRestarts
[08:27:59.210]                         grepl <- base::grepl
[08:27:59.210]                         restarts <- computeRestarts(cond)
[08:27:59.210]                         for (restart in restarts) {
[08:27:59.210]                           name <- restart$name
[08:27:59.210]                           if (is.null(name)) 
[08:27:59.210]                             next
[08:27:59.210]                           if (!grepl(pattern, name)) 
[08:27:59.210]                             next
[08:27:59.210]                           invokeRestart(restart)
[08:27:59.210]                           muffled <- TRUE
[08:27:59.210]                           break
[08:27:59.210]                         }
[08:27:59.210]                       }
[08:27:59.210]                     }
[08:27:59.210]                     invisible(muffled)
[08:27:59.210]                   }
[08:27:59.210]                   muffleCondition(cond)
[08:27:59.210]                 })
[08:27:59.210]             }))
[08:27:59.210]             future::FutureResult(value = ...future.value$value, 
[08:27:59.210]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:59.210]                   ...future.rng), globalenv = if (FALSE) 
[08:27:59.210]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:59.210]                     ...future.globalenv.names))
[08:27:59.210]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:59.210]         }, condition = base::local({
[08:27:59.210]             c <- base::c
[08:27:59.210]             inherits <- base::inherits
[08:27:59.210]             invokeRestart <- base::invokeRestart
[08:27:59.210]             length <- base::length
[08:27:59.210]             list <- base::list
[08:27:59.210]             seq.int <- base::seq.int
[08:27:59.210]             signalCondition <- base::signalCondition
[08:27:59.210]             sys.calls <- base::sys.calls
[08:27:59.210]             `[[` <- base::`[[`
[08:27:59.210]             `+` <- base::`+`
[08:27:59.210]             `<<-` <- base::`<<-`
[08:27:59.210]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:59.210]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:59.210]                   3L)]
[08:27:59.210]             }
[08:27:59.210]             function(cond) {
[08:27:59.210]                 is_error <- inherits(cond, "error")
[08:27:59.210]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:59.210]                   NULL)
[08:27:59.210]                 if (is_error) {
[08:27:59.210]                   sessionInformation <- function() {
[08:27:59.210]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:59.210]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:59.210]                       search = base::search(), system = base::Sys.info())
[08:27:59.210]                   }
[08:27:59.210]                   ...future.conditions[[length(...future.conditions) + 
[08:27:59.210]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:59.210]                     cond$call), session = sessionInformation(), 
[08:27:59.210]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:59.210]                   signalCondition(cond)
[08:27:59.210]                 }
[08:27:59.210]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:59.210]                 "immediateCondition"))) {
[08:27:59.210]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:59.210]                   ...future.conditions[[length(...future.conditions) + 
[08:27:59.210]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:59.210]                   if (TRUE && !signal) {
[08:27:59.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.210]                     {
[08:27:59.210]                       inherits <- base::inherits
[08:27:59.210]                       invokeRestart <- base::invokeRestart
[08:27:59.210]                       is.null <- base::is.null
[08:27:59.210]                       muffled <- FALSE
[08:27:59.210]                       if (inherits(cond, "message")) {
[08:27:59.210]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:59.210]                         if (muffled) 
[08:27:59.210]                           invokeRestart("muffleMessage")
[08:27:59.210]                       }
[08:27:59.210]                       else if (inherits(cond, "warning")) {
[08:27:59.210]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:59.210]                         if (muffled) 
[08:27:59.210]                           invokeRestart("muffleWarning")
[08:27:59.210]                       }
[08:27:59.210]                       else if (inherits(cond, "condition")) {
[08:27:59.210]                         if (!is.null(pattern)) {
[08:27:59.210]                           computeRestarts <- base::computeRestarts
[08:27:59.210]                           grepl <- base::grepl
[08:27:59.210]                           restarts <- computeRestarts(cond)
[08:27:59.210]                           for (restart in restarts) {
[08:27:59.210]                             name <- restart$name
[08:27:59.210]                             if (is.null(name)) 
[08:27:59.210]                               next
[08:27:59.210]                             if (!grepl(pattern, name)) 
[08:27:59.210]                               next
[08:27:59.210]                             invokeRestart(restart)
[08:27:59.210]                             muffled <- TRUE
[08:27:59.210]                             break
[08:27:59.210]                           }
[08:27:59.210]                         }
[08:27:59.210]                       }
[08:27:59.210]                       invisible(muffled)
[08:27:59.210]                     }
[08:27:59.210]                     muffleCondition(cond, pattern = "^muffle")
[08:27:59.210]                   }
[08:27:59.210]                 }
[08:27:59.210]                 else {
[08:27:59.210]                   if (TRUE) {
[08:27:59.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.210]                     {
[08:27:59.210]                       inherits <- base::inherits
[08:27:59.210]                       invokeRestart <- base::invokeRestart
[08:27:59.210]                       is.null <- base::is.null
[08:27:59.210]                       muffled <- FALSE
[08:27:59.210]                       if (inherits(cond, "message")) {
[08:27:59.210]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:59.210]                         if (muffled) 
[08:27:59.210]                           invokeRestart("muffleMessage")
[08:27:59.210]                       }
[08:27:59.210]                       else if (inherits(cond, "warning")) {
[08:27:59.210]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:59.210]                         if (muffled) 
[08:27:59.210]                           invokeRestart("muffleWarning")
[08:27:59.210]                       }
[08:27:59.210]                       else if (inherits(cond, "condition")) {
[08:27:59.210]                         if (!is.null(pattern)) {
[08:27:59.210]                           computeRestarts <- base::computeRestarts
[08:27:59.210]                           grepl <- base::grepl
[08:27:59.210]                           restarts <- computeRestarts(cond)
[08:27:59.210]                           for (restart in restarts) {
[08:27:59.210]                             name <- restart$name
[08:27:59.210]                             if (is.null(name)) 
[08:27:59.210]                               next
[08:27:59.210]                             if (!grepl(pattern, name)) 
[08:27:59.210]                               next
[08:27:59.210]                             invokeRestart(restart)
[08:27:59.210]                             muffled <- TRUE
[08:27:59.210]                             break
[08:27:59.210]                           }
[08:27:59.210]                         }
[08:27:59.210]                       }
[08:27:59.210]                       invisible(muffled)
[08:27:59.210]                     }
[08:27:59.210]                     muffleCondition(cond, pattern = "^muffle")
[08:27:59.210]                   }
[08:27:59.210]                 }
[08:27:59.210]             }
[08:27:59.210]         }))
[08:27:59.210]     }, error = function(ex) {
[08:27:59.210]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:59.210]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:59.210]                 ...future.rng), started = ...future.startTime, 
[08:27:59.210]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:59.210]             version = "1.8"), class = "FutureResult")
[08:27:59.210]     }, finally = {
[08:27:59.210]         if (!identical(...future.workdir, getwd())) 
[08:27:59.210]             setwd(...future.workdir)
[08:27:59.210]         {
[08:27:59.210]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:59.210]                 ...future.oldOptions$nwarnings <- NULL
[08:27:59.210]             }
[08:27:59.210]             base::options(...future.oldOptions)
[08:27:59.210]             if (.Platform$OS.type == "windows") {
[08:27:59.210]                 old_names <- names(...future.oldEnvVars)
[08:27:59.210]                 envs <- base::Sys.getenv()
[08:27:59.210]                 names <- names(envs)
[08:27:59.210]                 common <- intersect(names, old_names)
[08:27:59.210]                 added <- setdiff(names, old_names)
[08:27:59.210]                 removed <- setdiff(old_names, names)
[08:27:59.210]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:59.210]                   envs[common]]
[08:27:59.210]                 NAMES <- toupper(changed)
[08:27:59.210]                 args <- list()
[08:27:59.210]                 for (kk in seq_along(NAMES)) {
[08:27:59.210]                   name <- changed[[kk]]
[08:27:59.210]                   NAME <- NAMES[[kk]]
[08:27:59.210]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.210]                     next
[08:27:59.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:59.210]                 }
[08:27:59.210]                 NAMES <- toupper(added)
[08:27:59.210]                 for (kk in seq_along(NAMES)) {
[08:27:59.210]                   name <- added[[kk]]
[08:27:59.210]                   NAME <- NAMES[[kk]]
[08:27:59.210]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.210]                     next
[08:27:59.210]                   args[[name]] <- ""
[08:27:59.210]                 }
[08:27:59.210]                 NAMES <- toupper(removed)
[08:27:59.210]                 for (kk in seq_along(NAMES)) {
[08:27:59.210]                   name <- removed[[kk]]
[08:27:59.210]                   NAME <- NAMES[[kk]]
[08:27:59.210]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.210]                     next
[08:27:59.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:59.210]                 }
[08:27:59.210]                 if (length(args) > 0) 
[08:27:59.210]                   base::do.call(base::Sys.setenv, args = args)
[08:27:59.210]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:59.210]             }
[08:27:59.210]             else {
[08:27:59.210]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:59.210]             }
[08:27:59.210]             {
[08:27:59.210]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:59.210]                   0L) {
[08:27:59.210]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:59.210]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:59.210]                   base::options(opts)
[08:27:59.210]                 }
[08:27:59.210]                 {
[08:27:59.210]                   {
[08:27:59.210]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:59.210]                     NULL
[08:27:59.210]                   }
[08:27:59.210]                   options(future.plan = NULL)
[08:27:59.210]                   if (is.na(NA_character_)) 
[08:27:59.210]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:59.210]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:59.210]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:59.210]                     .init = FALSE)
[08:27:59.210]                 }
[08:27:59.210]             }
[08:27:59.210]         }
[08:27:59.210]     })
[08:27:59.210]     if (TRUE) {
[08:27:59.210]         base::sink(type = "output", split = FALSE)
[08:27:59.210]         if (TRUE) {
[08:27:59.210]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:59.210]         }
[08:27:59.210]         else {
[08:27:59.210]             ...future.result["stdout"] <- base::list(NULL)
[08:27:59.210]         }
[08:27:59.210]         base::close(...future.stdout)
[08:27:59.210]         ...future.stdout <- NULL
[08:27:59.210]     }
[08:27:59.210]     ...future.result$conditions <- ...future.conditions
[08:27:59.210]     ...future.result$finished <- base::Sys.time()
[08:27:59.210]     ...future.result
[08:27:59.210] }
[08:27:59.212] Exporting 1 global objects (378 bytes) to cluster node #1 ...
[08:27:59.212] Exporting ‘x’ (71 bytes) to cluster node #1 ...
[08:27:59.213] Exporting ‘x’ (71 bytes) to cluster node #1 ... DONE
[08:27:59.213] Exporting 1 global objects (378 bytes) to cluster node #1 ... DONE
[08:27:59.213] MultisessionFuture started
[08:27:59.213] - Launch lazy future ... done
[08:27:59.213] run() for ‘MultisessionFuture’ ... done
[08:27:59.214] result() for ClusterFuture ...
[08:27:59.214] receiveMessageFromWorker() for ClusterFuture ...
[08:27:59.214] - Validating connection of MultisessionFuture
[08:27:59.255] - received message: FutureResult
[08:27:59.255] - Received FutureResult
[08:27:59.256] - Erased future from FutureRegistry
[08:27:59.256] result() for ClusterFuture ...
[08:27:59.256] - result already collected: FutureResult
[08:27:59.256] result() for ClusterFuture ... done
[08:27:59.256] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:59.256] result() for ClusterFuture ... done
[08:27:59.256] result() for ClusterFuture ...
[08:27:59.256] - result already collected: FutureResult
[08:27:59.256] result() for ClusterFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[08:27:59.258] getGlobalsAndPackages() ...
[08:27:59.258] Searching for globals...
[08:27:59.259] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[08:27:59.259] Searching for globals ... DONE
[08:27:59.260] Resolving globals: FALSE
[08:27:59.260] 
[08:27:59.260] - packages: [2] ‘stats’, ‘datasets’
[08:27:59.260] getGlobalsAndPackages() ... DONE
[08:27:59.261] run() for ‘Future’ ...
[08:27:59.261] - state: ‘created’
[08:27:59.261] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:59.278] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:59.278] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:59.279]   - Field: ‘node’
[08:27:59.279]   - Field: ‘label’
[08:27:59.279]   - Field: ‘local’
[08:27:59.279]   - Field: ‘owner’
[08:27:59.279]   - Field: ‘envir’
[08:27:59.280]   - Field: ‘workers’
[08:27:59.280]   - Field: ‘packages’
[08:27:59.280]   - Field: ‘gc’
[08:27:59.280]   - Field: ‘conditions’
[08:27:59.280]   - Field: ‘persistent’
[08:27:59.280]   - Field: ‘expr’
[08:27:59.280]   - Field: ‘uuid’
[08:27:59.280]   - Field: ‘seed’
[08:27:59.281]   - Field: ‘version’
[08:27:59.281]   - Field: ‘result’
[08:27:59.281]   - Field: ‘asynchronous’
[08:27:59.281]   - Field: ‘calls’
[08:27:59.281]   - Field: ‘globals’
[08:27:59.281]   - Field: ‘stdout’
[08:27:59.281]   - Field: ‘earlySignal’
[08:27:59.282]   - Field: ‘lazy’
[08:27:59.282]   - Field: ‘state’
[08:27:59.282] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:59.282] - Launch lazy future ...
[08:27:59.282] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[08:27:59.283] Packages needed by future strategies (n = 0): <none>
[08:27:59.284] {
[08:27:59.284]     {
[08:27:59.284]         {
[08:27:59.284]             ...future.startTime <- base::Sys.time()
[08:27:59.284]             {
[08:27:59.284]                 {
[08:27:59.284]                   {
[08:27:59.284]                     {
[08:27:59.284]                       {
[08:27:59.284]                         base::local({
[08:27:59.284]                           has_future <- base::requireNamespace("future", 
[08:27:59.284]                             quietly = TRUE)
[08:27:59.284]                           if (has_future) {
[08:27:59.284]                             ns <- base::getNamespace("future")
[08:27:59.284]                             version <- ns[[".package"]][["version"]]
[08:27:59.284]                             if (is.null(version)) 
[08:27:59.284]                               version <- utils::packageVersion("future")
[08:27:59.284]                           }
[08:27:59.284]                           else {
[08:27:59.284]                             version <- NULL
[08:27:59.284]                           }
[08:27:59.284]                           if (!has_future || version < "1.8.0") {
[08:27:59.284]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:59.284]                               "", base::R.version$version.string), 
[08:27:59.284]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:59.284]                                 base::R.version$platform, 8 * 
[08:27:59.284]                                   base::.Machine$sizeof.pointer), 
[08:27:59.284]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:59.284]                                 "release", "version")], collapse = " "), 
[08:27:59.284]                               hostname = base::Sys.info()[["nodename"]])
[08:27:59.284]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:59.284]                               info)
[08:27:59.284]                             info <- base::paste(info, collapse = "; ")
[08:27:59.284]                             if (!has_future) {
[08:27:59.284]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:59.284]                                 info)
[08:27:59.284]                             }
[08:27:59.284]                             else {
[08:27:59.284]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:59.284]                                 info, version)
[08:27:59.284]                             }
[08:27:59.284]                             base::stop(msg)
[08:27:59.284]                           }
[08:27:59.284]                         })
[08:27:59.284]                       }
[08:27:59.284]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:59.284]                       base::options(mc.cores = 1L)
[08:27:59.284]                     }
[08:27:59.284]                     base::local({
[08:27:59.284]                       for (pkg in c("stats", "datasets")) {
[08:27:59.284]                         base::loadNamespace(pkg)
[08:27:59.284]                         base::library(pkg, character.only = TRUE)
[08:27:59.284]                       }
[08:27:59.284]                     })
[08:27:59.284]                   }
[08:27:59.284]                   ...future.strategy.old <- future::plan("list")
[08:27:59.284]                   options(future.plan = NULL)
[08:27:59.284]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:59.284]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:59.284]                 }
[08:27:59.284]                 ...future.workdir <- getwd()
[08:27:59.284]             }
[08:27:59.284]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:59.284]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:59.284]         }
[08:27:59.284]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:59.284]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:59.284]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:59.284]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:59.284]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:59.284]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:59.284]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:59.284]             base::names(...future.oldOptions))
[08:27:59.284]     }
[08:27:59.284]     if (FALSE) {
[08:27:59.284]     }
[08:27:59.284]     else {
[08:27:59.284]         if (TRUE) {
[08:27:59.284]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:59.284]                 open = "w")
[08:27:59.284]         }
[08:27:59.284]         else {
[08:27:59.284]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:59.284]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:59.284]         }
[08:27:59.284]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:59.284]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:59.284]             base::sink(type = "output", split = FALSE)
[08:27:59.284]             base::close(...future.stdout)
[08:27:59.284]         }, add = TRUE)
[08:27:59.284]     }
[08:27:59.284]     ...future.frame <- base::sys.nframe()
[08:27:59.284]     ...future.conditions <- base::list()
[08:27:59.284]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:59.284]     if (FALSE) {
[08:27:59.284]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:59.284]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:59.284]     }
[08:27:59.284]     ...future.result <- base::tryCatch({
[08:27:59.284]         base::withCallingHandlers({
[08:27:59.284]             ...future.value <- base::withVisible(base::local({
[08:27:59.284]                 ...future.makeSendCondition <- base::local({
[08:27:59.284]                   sendCondition <- NULL
[08:27:59.284]                   function(frame = 1L) {
[08:27:59.284]                     if (is.function(sendCondition)) 
[08:27:59.284]                       return(sendCondition)
[08:27:59.284]                     ns <- getNamespace("parallel")
[08:27:59.284]                     if (exists("sendData", mode = "function", 
[08:27:59.284]                       envir = ns)) {
[08:27:59.284]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:59.284]                         envir = ns)
[08:27:59.284]                       envir <- sys.frame(frame)
[08:27:59.284]                       master <- NULL
[08:27:59.284]                       while (!identical(envir, .GlobalEnv) && 
[08:27:59.284]                         !identical(envir, emptyenv())) {
[08:27:59.284]                         if (exists("master", mode = "list", envir = envir, 
[08:27:59.284]                           inherits = FALSE)) {
[08:27:59.284]                           master <- get("master", mode = "list", 
[08:27:59.284]                             envir = envir, inherits = FALSE)
[08:27:59.284]                           if (inherits(master, c("SOCKnode", 
[08:27:59.284]                             "SOCK0node"))) {
[08:27:59.284]                             sendCondition <<- function(cond) {
[08:27:59.284]                               data <- list(type = "VALUE", value = cond, 
[08:27:59.284]                                 success = TRUE)
[08:27:59.284]                               parallel_sendData(master, data)
[08:27:59.284]                             }
[08:27:59.284]                             return(sendCondition)
[08:27:59.284]                           }
[08:27:59.284]                         }
[08:27:59.284]                         frame <- frame + 1L
[08:27:59.284]                         envir <- sys.frame(frame)
[08:27:59.284]                       }
[08:27:59.284]                     }
[08:27:59.284]                     sendCondition <<- function(cond) NULL
[08:27:59.284]                   }
[08:27:59.284]                 })
[08:27:59.284]                 withCallingHandlers({
[08:27:59.284]                   {
[08:27:59.284]                     lm(dist ~ . - 1, data = cars)
[08:27:59.284]                   }
[08:27:59.284]                 }, immediateCondition = function(cond) {
[08:27:59.284]                   sendCondition <- ...future.makeSendCondition()
[08:27:59.284]                   sendCondition(cond)
[08:27:59.284]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.284]                   {
[08:27:59.284]                     inherits <- base::inherits
[08:27:59.284]                     invokeRestart <- base::invokeRestart
[08:27:59.284]                     is.null <- base::is.null
[08:27:59.284]                     muffled <- FALSE
[08:27:59.284]                     if (inherits(cond, "message")) {
[08:27:59.284]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:59.284]                       if (muffled) 
[08:27:59.284]                         invokeRestart("muffleMessage")
[08:27:59.284]                     }
[08:27:59.284]                     else if (inherits(cond, "warning")) {
[08:27:59.284]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:59.284]                       if (muffled) 
[08:27:59.284]                         invokeRestart("muffleWarning")
[08:27:59.284]                     }
[08:27:59.284]                     else if (inherits(cond, "condition")) {
[08:27:59.284]                       if (!is.null(pattern)) {
[08:27:59.284]                         computeRestarts <- base::computeRestarts
[08:27:59.284]                         grepl <- base::grepl
[08:27:59.284]                         restarts <- computeRestarts(cond)
[08:27:59.284]                         for (restart in restarts) {
[08:27:59.284]                           name <- restart$name
[08:27:59.284]                           if (is.null(name)) 
[08:27:59.284]                             next
[08:27:59.284]                           if (!grepl(pattern, name)) 
[08:27:59.284]                             next
[08:27:59.284]                           invokeRestart(restart)
[08:27:59.284]                           muffled <- TRUE
[08:27:59.284]                           break
[08:27:59.284]                         }
[08:27:59.284]                       }
[08:27:59.284]                     }
[08:27:59.284]                     invisible(muffled)
[08:27:59.284]                   }
[08:27:59.284]                   muffleCondition(cond)
[08:27:59.284]                 })
[08:27:59.284]             }))
[08:27:59.284]             future::FutureResult(value = ...future.value$value, 
[08:27:59.284]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:59.284]                   ...future.rng), globalenv = if (FALSE) 
[08:27:59.284]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:59.284]                     ...future.globalenv.names))
[08:27:59.284]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:59.284]         }, condition = base::local({
[08:27:59.284]             c <- base::c
[08:27:59.284]             inherits <- base::inherits
[08:27:59.284]             invokeRestart <- base::invokeRestart
[08:27:59.284]             length <- base::length
[08:27:59.284]             list <- base::list
[08:27:59.284]             seq.int <- base::seq.int
[08:27:59.284]             signalCondition <- base::signalCondition
[08:27:59.284]             sys.calls <- base::sys.calls
[08:27:59.284]             `[[` <- base::`[[`
[08:27:59.284]             `+` <- base::`+`
[08:27:59.284]             `<<-` <- base::`<<-`
[08:27:59.284]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:59.284]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:59.284]                   3L)]
[08:27:59.284]             }
[08:27:59.284]             function(cond) {
[08:27:59.284]                 is_error <- inherits(cond, "error")
[08:27:59.284]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:59.284]                   NULL)
[08:27:59.284]                 if (is_error) {
[08:27:59.284]                   sessionInformation <- function() {
[08:27:59.284]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:59.284]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:59.284]                       search = base::search(), system = base::Sys.info())
[08:27:59.284]                   }
[08:27:59.284]                   ...future.conditions[[length(...future.conditions) + 
[08:27:59.284]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:59.284]                     cond$call), session = sessionInformation(), 
[08:27:59.284]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:59.284]                   signalCondition(cond)
[08:27:59.284]                 }
[08:27:59.284]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:59.284]                 "immediateCondition"))) {
[08:27:59.284]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:59.284]                   ...future.conditions[[length(...future.conditions) + 
[08:27:59.284]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:59.284]                   if (TRUE && !signal) {
[08:27:59.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.284]                     {
[08:27:59.284]                       inherits <- base::inherits
[08:27:59.284]                       invokeRestart <- base::invokeRestart
[08:27:59.284]                       is.null <- base::is.null
[08:27:59.284]                       muffled <- FALSE
[08:27:59.284]                       if (inherits(cond, "message")) {
[08:27:59.284]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:59.284]                         if (muffled) 
[08:27:59.284]                           invokeRestart("muffleMessage")
[08:27:59.284]                       }
[08:27:59.284]                       else if (inherits(cond, "warning")) {
[08:27:59.284]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:59.284]                         if (muffled) 
[08:27:59.284]                           invokeRestart("muffleWarning")
[08:27:59.284]                       }
[08:27:59.284]                       else if (inherits(cond, "condition")) {
[08:27:59.284]                         if (!is.null(pattern)) {
[08:27:59.284]                           computeRestarts <- base::computeRestarts
[08:27:59.284]                           grepl <- base::grepl
[08:27:59.284]                           restarts <- computeRestarts(cond)
[08:27:59.284]                           for (restart in restarts) {
[08:27:59.284]                             name <- restart$name
[08:27:59.284]                             if (is.null(name)) 
[08:27:59.284]                               next
[08:27:59.284]                             if (!grepl(pattern, name)) 
[08:27:59.284]                               next
[08:27:59.284]                             invokeRestart(restart)
[08:27:59.284]                             muffled <- TRUE
[08:27:59.284]                             break
[08:27:59.284]                           }
[08:27:59.284]                         }
[08:27:59.284]                       }
[08:27:59.284]                       invisible(muffled)
[08:27:59.284]                     }
[08:27:59.284]                     muffleCondition(cond, pattern = "^muffle")
[08:27:59.284]                   }
[08:27:59.284]                 }
[08:27:59.284]                 else {
[08:27:59.284]                   if (TRUE) {
[08:27:59.284]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.284]                     {
[08:27:59.284]                       inherits <- base::inherits
[08:27:59.284]                       invokeRestart <- base::invokeRestart
[08:27:59.284]                       is.null <- base::is.null
[08:27:59.284]                       muffled <- FALSE
[08:27:59.284]                       if (inherits(cond, "message")) {
[08:27:59.284]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:59.284]                         if (muffled) 
[08:27:59.284]                           invokeRestart("muffleMessage")
[08:27:59.284]                       }
[08:27:59.284]                       else if (inherits(cond, "warning")) {
[08:27:59.284]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:59.284]                         if (muffled) 
[08:27:59.284]                           invokeRestart("muffleWarning")
[08:27:59.284]                       }
[08:27:59.284]                       else if (inherits(cond, "condition")) {
[08:27:59.284]                         if (!is.null(pattern)) {
[08:27:59.284]                           computeRestarts <- base::computeRestarts
[08:27:59.284]                           grepl <- base::grepl
[08:27:59.284]                           restarts <- computeRestarts(cond)
[08:27:59.284]                           for (restart in restarts) {
[08:27:59.284]                             name <- restart$name
[08:27:59.284]                             if (is.null(name)) 
[08:27:59.284]                               next
[08:27:59.284]                             if (!grepl(pattern, name)) 
[08:27:59.284]                               next
[08:27:59.284]                             invokeRestart(restart)
[08:27:59.284]                             muffled <- TRUE
[08:27:59.284]                             break
[08:27:59.284]                           }
[08:27:59.284]                         }
[08:27:59.284]                       }
[08:27:59.284]                       invisible(muffled)
[08:27:59.284]                     }
[08:27:59.284]                     muffleCondition(cond, pattern = "^muffle")
[08:27:59.284]                   }
[08:27:59.284]                 }
[08:27:59.284]             }
[08:27:59.284]         }))
[08:27:59.284]     }, error = function(ex) {
[08:27:59.284]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:59.284]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:59.284]                 ...future.rng), started = ...future.startTime, 
[08:27:59.284]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:59.284]             version = "1.8"), class = "FutureResult")
[08:27:59.284]     }, finally = {
[08:27:59.284]         if (!identical(...future.workdir, getwd())) 
[08:27:59.284]             setwd(...future.workdir)
[08:27:59.284]         {
[08:27:59.284]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:59.284]                 ...future.oldOptions$nwarnings <- NULL
[08:27:59.284]             }
[08:27:59.284]             base::options(...future.oldOptions)
[08:27:59.284]             if (.Platform$OS.type == "windows") {
[08:27:59.284]                 old_names <- names(...future.oldEnvVars)
[08:27:59.284]                 envs <- base::Sys.getenv()
[08:27:59.284]                 names <- names(envs)
[08:27:59.284]                 common <- intersect(names, old_names)
[08:27:59.284]                 added <- setdiff(names, old_names)
[08:27:59.284]                 removed <- setdiff(old_names, names)
[08:27:59.284]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:59.284]                   envs[common]]
[08:27:59.284]                 NAMES <- toupper(changed)
[08:27:59.284]                 args <- list()
[08:27:59.284]                 for (kk in seq_along(NAMES)) {
[08:27:59.284]                   name <- changed[[kk]]
[08:27:59.284]                   NAME <- NAMES[[kk]]
[08:27:59.284]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.284]                     next
[08:27:59.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:59.284]                 }
[08:27:59.284]                 NAMES <- toupper(added)
[08:27:59.284]                 for (kk in seq_along(NAMES)) {
[08:27:59.284]                   name <- added[[kk]]
[08:27:59.284]                   NAME <- NAMES[[kk]]
[08:27:59.284]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.284]                     next
[08:27:59.284]                   args[[name]] <- ""
[08:27:59.284]                 }
[08:27:59.284]                 NAMES <- toupper(removed)
[08:27:59.284]                 for (kk in seq_along(NAMES)) {
[08:27:59.284]                   name <- removed[[kk]]
[08:27:59.284]                   NAME <- NAMES[[kk]]
[08:27:59.284]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.284]                     next
[08:27:59.284]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:59.284]                 }
[08:27:59.284]                 if (length(args) > 0) 
[08:27:59.284]                   base::do.call(base::Sys.setenv, args = args)
[08:27:59.284]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:59.284]             }
[08:27:59.284]             else {
[08:27:59.284]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:59.284]             }
[08:27:59.284]             {
[08:27:59.284]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:59.284]                   0L) {
[08:27:59.284]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:59.284]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:59.284]                   base::options(opts)
[08:27:59.284]                 }
[08:27:59.284]                 {
[08:27:59.284]                   {
[08:27:59.284]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:59.284]                     NULL
[08:27:59.284]                   }
[08:27:59.284]                   options(future.plan = NULL)
[08:27:59.284]                   if (is.na(NA_character_)) 
[08:27:59.284]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:59.284]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:59.284]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:59.284]                     .init = FALSE)
[08:27:59.284]                 }
[08:27:59.284]             }
[08:27:59.284]         }
[08:27:59.284]     })
[08:27:59.284]     if (TRUE) {
[08:27:59.284]         base::sink(type = "output", split = FALSE)
[08:27:59.284]         if (TRUE) {
[08:27:59.284]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:59.284]         }
[08:27:59.284]         else {
[08:27:59.284]             ...future.result["stdout"] <- base::list(NULL)
[08:27:59.284]         }
[08:27:59.284]         base::close(...future.stdout)
[08:27:59.284]         ...future.stdout <- NULL
[08:27:59.284]     }
[08:27:59.284]     ...future.result$conditions <- ...future.conditions
[08:27:59.284]     ...future.result$finished <- base::Sys.time()
[08:27:59.284]     ...future.result
[08:27:59.284] }
[08:27:59.289] MultisessionFuture started
[08:27:59.289] - Launch lazy future ... done
[08:27:59.289] run() for ‘MultisessionFuture’ ... done
[08:27:59.290] result() for ClusterFuture ...
[08:27:59.290] receiveMessageFromWorker() for ClusterFuture ...
[08:27:59.290] - Validating connection of MultisessionFuture
[08:27:59.333] - received message: FutureResult
[08:27:59.333] - Received FutureResult
[08:27:59.334] - Erased future from FutureRegistry
[08:27:59.334] result() for ClusterFuture ...
[08:27:59.334] - result already collected: FutureResult
[08:27:59.334] result() for ClusterFuture ... done
[08:27:59.334] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:59.334] result() for ClusterFuture ... done
[08:27:59.334] result() for ClusterFuture ...
[08:27:59.334] - result already collected: FutureResult
[08:27:59.334] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[08:27:59.337] getGlobalsAndPackages() ...
[08:27:59.337] Searching for globals...
[08:27:59.338] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[08:27:59.339] Searching for globals ... DONE
[08:27:59.339] Resolving globals: FALSE
[08:27:59.339] 
[08:27:59.339] - packages: [2] ‘stats’, ‘datasets’
[08:27:59.339] getGlobalsAndPackages() ... DONE
[08:27:59.340] run() for ‘Future’ ...
[08:27:59.340] - state: ‘created’
[08:27:59.340] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:59.354] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:59.354] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:59.354]   - Field: ‘node’
[08:27:59.354]   - Field: ‘label’
[08:27:59.354]   - Field: ‘local’
[08:27:59.354]   - Field: ‘owner’
[08:27:59.354]   - Field: ‘envir’
[08:27:59.355]   - Field: ‘workers’
[08:27:59.355]   - Field: ‘packages’
[08:27:59.355]   - Field: ‘gc’
[08:27:59.355]   - Field: ‘conditions’
[08:27:59.355]   - Field: ‘persistent’
[08:27:59.355]   - Field: ‘expr’
[08:27:59.355]   - Field: ‘uuid’
[08:27:59.355]   - Field: ‘seed’
[08:27:59.355]   - Field: ‘version’
[08:27:59.355]   - Field: ‘result’
[08:27:59.355]   - Field: ‘asynchronous’
[08:27:59.356]   - Field: ‘calls’
[08:27:59.356]   - Field: ‘globals’
[08:27:59.356]   - Field: ‘stdout’
[08:27:59.356]   - Field: ‘earlySignal’
[08:27:59.356]   - Field: ‘lazy’
[08:27:59.356]   - Field: ‘state’
[08:27:59.356] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:59.356] - Launch lazy future ...
[08:27:59.356] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[08:27:59.357] Packages needed by future strategies (n = 0): <none>
[08:27:59.357] {
[08:27:59.357]     {
[08:27:59.357]         {
[08:27:59.357]             ...future.startTime <- base::Sys.time()
[08:27:59.357]             {
[08:27:59.357]                 {
[08:27:59.357]                   {
[08:27:59.357]                     {
[08:27:59.357]                       {
[08:27:59.357]                         base::local({
[08:27:59.357]                           has_future <- base::requireNamespace("future", 
[08:27:59.357]                             quietly = TRUE)
[08:27:59.357]                           if (has_future) {
[08:27:59.357]                             ns <- base::getNamespace("future")
[08:27:59.357]                             version <- ns[[".package"]][["version"]]
[08:27:59.357]                             if (is.null(version)) 
[08:27:59.357]                               version <- utils::packageVersion("future")
[08:27:59.357]                           }
[08:27:59.357]                           else {
[08:27:59.357]                             version <- NULL
[08:27:59.357]                           }
[08:27:59.357]                           if (!has_future || version < "1.8.0") {
[08:27:59.357]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:59.357]                               "", base::R.version$version.string), 
[08:27:59.357]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:59.357]                                 base::R.version$platform, 8 * 
[08:27:59.357]                                   base::.Machine$sizeof.pointer), 
[08:27:59.357]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:59.357]                                 "release", "version")], collapse = " "), 
[08:27:59.357]                               hostname = base::Sys.info()[["nodename"]])
[08:27:59.357]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:59.357]                               info)
[08:27:59.357]                             info <- base::paste(info, collapse = "; ")
[08:27:59.357]                             if (!has_future) {
[08:27:59.357]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:59.357]                                 info)
[08:27:59.357]                             }
[08:27:59.357]                             else {
[08:27:59.357]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:59.357]                                 info, version)
[08:27:59.357]                             }
[08:27:59.357]                             base::stop(msg)
[08:27:59.357]                           }
[08:27:59.357]                         })
[08:27:59.357]                       }
[08:27:59.357]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:59.357]                       base::options(mc.cores = 1L)
[08:27:59.357]                     }
[08:27:59.357]                     base::local({
[08:27:59.357]                       for (pkg in c("stats", "datasets")) {
[08:27:59.357]                         base::loadNamespace(pkg)
[08:27:59.357]                         base::library(pkg, character.only = TRUE)
[08:27:59.357]                       }
[08:27:59.357]                     })
[08:27:59.357]                   }
[08:27:59.357]                   ...future.strategy.old <- future::plan("list")
[08:27:59.357]                   options(future.plan = NULL)
[08:27:59.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:59.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:59.357]                 }
[08:27:59.357]                 ...future.workdir <- getwd()
[08:27:59.357]             }
[08:27:59.357]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:59.357]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:59.357]         }
[08:27:59.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:59.357]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:59.357]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:59.357]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:59.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:59.357]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:59.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:59.357]             base::names(...future.oldOptions))
[08:27:59.357]     }
[08:27:59.357]     if (FALSE) {
[08:27:59.357]     }
[08:27:59.357]     else {
[08:27:59.357]         if (TRUE) {
[08:27:59.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:59.357]                 open = "w")
[08:27:59.357]         }
[08:27:59.357]         else {
[08:27:59.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:59.357]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:59.357]         }
[08:27:59.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:59.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:59.357]             base::sink(type = "output", split = FALSE)
[08:27:59.357]             base::close(...future.stdout)
[08:27:59.357]         }, add = TRUE)
[08:27:59.357]     }
[08:27:59.357]     ...future.frame <- base::sys.nframe()
[08:27:59.357]     ...future.conditions <- base::list()
[08:27:59.357]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:59.357]     if (FALSE) {
[08:27:59.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:59.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:59.357]     }
[08:27:59.357]     ...future.result <- base::tryCatch({
[08:27:59.357]         base::withCallingHandlers({
[08:27:59.357]             ...future.value <- base::withVisible(base::local({
[08:27:59.357]                 ...future.makeSendCondition <- base::local({
[08:27:59.357]                   sendCondition <- NULL
[08:27:59.357]                   function(frame = 1L) {
[08:27:59.357]                     if (is.function(sendCondition)) 
[08:27:59.357]                       return(sendCondition)
[08:27:59.357]                     ns <- getNamespace("parallel")
[08:27:59.357]                     if (exists("sendData", mode = "function", 
[08:27:59.357]                       envir = ns)) {
[08:27:59.357]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:59.357]                         envir = ns)
[08:27:59.357]                       envir <- sys.frame(frame)
[08:27:59.357]                       master <- NULL
[08:27:59.357]                       while (!identical(envir, .GlobalEnv) && 
[08:27:59.357]                         !identical(envir, emptyenv())) {
[08:27:59.357]                         if (exists("master", mode = "list", envir = envir, 
[08:27:59.357]                           inherits = FALSE)) {
[08:27:59.357]                           master <- get("master", mode = "list", 
[08:27:59.357]                             envir = envir, inherits = FALSE)
[08:27:59.357]                           if (inherits(master, c("SOCKnode", 
[08:27:59.357]                             "SOCK0node"))) {
[08:27:59.357]                             sendCondition <<- function(cond) {
[08:27:59.357]                               data <- list(type = "VALUE", value = cond, 
[08:27:59.357]                                 success = TRUE)
[08:27:59.357]                               parallel_sendData(master, data)
[08:27:59.357]                             }
[08:27:59.357]                             return(sendCondition)
[08:27:59.357]                           }
[08:27:59.357]                         }
[08:27:59.357]                         frame <- frame + 1L
[08:27:59.357]                         envir <- sys.frame(frame)
[08:27:59.357]                       }
[08:27:59.357]                     }
[08:27:59.357]                     sendCondition <<- function(cond) NULL
[08:27:59.357]                   }
[08:27:59.357]                 })
[08:27:59.357]                 withCallingHandlers({
[08:27:59.357]                   {
[08:27:59.357]                     lm(dist ~ . + 0, data = cars)
[08:27:59.357]                   }
[08:27:59.357]                 }, immediateCondition = function(cond) {
[08:27:59.357]                   sendCondition <- ...future.makeSendCondition()
[08:27:59.357]                   sendCondition(cond)
[08:27:59.357]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.357]                   {
[08:27:59.357]                     inherits <- base::inherits
[08:27:59.357]                     invokeRestart <- base::invokeRestart
[08:27:59.357]                     is.null <- base::is.null
[08:27:59.357]                     muffled <- FALSE
[08:27:59.357]                     if (inherits(cond, "message")) {
[08:27:59.357]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:59.357]                       if (muffled) 
[08:27:59.357]                         invokeRestart("muffleMessage")
[08:27:59.357]                     }
[08:27:59.357]                     else if (inherits(cond, "warning")) {
[08:27:59.357]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:59.357]                       if (muffled) 
[08:27:59.357]                         invokeRestart("muffleWarning")
[08:27:59.357]                     }
[08:27:59.357]                     else if (inherits(cond, "condition")) {
[08:27:59.357]                       if (!is.null(pattern)) {
[08:27:59.357]                         computeRestarts <- base::computeRestarts
[08:27:59.357]                         grepl <- base::grepl
[08:27:59.357]                         restarts <- computeRestarts(cond)
[08:27:59.357]                         for (restart in restarts) {
[08:27:59.357]                           name <- restart$name
[08:27:59.357]                           if (is.null(name)) 
[08:27:59.357]                             next
[08:27:59.357]                           if (!grepl(pattern, name)) 
[08:27:59.357]                             next
[08:27:59.357]                           invokeRestart(restart)
[08:27:59.357]                           muffled <- TRUE
[08:27:59.357]                           break
[08:27:59.357]                         }
[08:27:59.357]                       }
[08:27:59.357]                     }
[08:27:59.357]                     invisible(muffled)
[08:27:59.357]                   }
[08:27:59.357]                   muffleCondition(cond)
[08:27:59.357]                 })
[08:27:59.357]             }))
[08:27:59.357]             future::FutureResult(value = ...future.value$value, 
[08:27:59.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:59.357]                   ...future.rng), globalenv = if (FALSE) 
[08:27:59.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:59.357]                     ...future.globalenv.names))
[08:27:59.357]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:59.357]         }, condition = base::local({
[08:27:59.357]             c <- base::c
[08:27:59.357]             inherits <- base::inherits
[08:27:59.357]             invokeRestart <- base::invokeRestart
[08:27:59.357]             length <- base::length
[08:27:59.357]             list <- base::list
[08:27:59.357]             seq.int <- base::seq.int
[08:27:59.357]             signalCondition <- base::signalCondition
[08:27:59.357]             sys.calls <- base::sys.calls
[08:27:59.357]             `[[` <- base::`[[`
[08:27:59.357]             `+` <- base::`+`
[08:27:59.357]             `<<-` <- base::`<<-`
[08:27:59.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:59.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:59.357]                   3L)]
[08:27:59.357]             }
[08:27:59.357]             function(cond) {
[08:27:59.357]                 is_error <- inherits(cond, "error")
[08:27:59.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:59.357]                   NULL)
[08:27:59.357]                 if (is_error) {
[08:27:59.357]                   sessionInformation <- function() {
[08:27:59.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:59.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:59.357]                       search = base::search(), system = base::Sys.info())
[08:27:59.357]                   }
[08:27:59.357]                   ...future.conditions[[length(...future.conditions) + 
[08:27:59.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:59.357]                     cond$call), session = sessionInformation(), 
[08:27:59.357]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:59.357]                   signalCondition(cond)
[08:27:59.357]                 }
[08:27:59.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:59.357]                 "immediateCondition"))) {
[08:27:59.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:59.357]                   ...future.conditions[[length(...future.conditions) + 
[08:27:59.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:59.357]                   if (TRUE && !signal) {
[08:27:59.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.357]                     {
[08:27:59.357]                       inherits <- base::inherits
[08:27:59.357]                       invokeRestart <- base::invokeRestart
[08:27:59.357]                       is.null <- base::is.null
[08:27:59.357]                       muffled <- FALSE
[08:27:59.357]                       if (inherits(cond, "message")) {
[08:27:59.357]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:59.357]                         if (muffled) 
[08:27:59.357]                           invokeRestart("muffleMessage")
[08:27:59.357]                       }
[08:27:59.357]                       else if (inherits(cond, "warning")) {
[08:27:59.357]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:59.357]                         if (muffled) 
[08:27:59.357]                           invokeRestart("muffleWarning")
[08:27:59.357]                       }
[08:27:59.357]                       else if (inherits(cond, "condition")) {
[08:27:59.357]                         if (!is.null(pattern)) {
[08:27:59.357]                           computeRestarts <- base::computeRestarts
[08:27:59.357]                           grepl <- base::grepl
[08:27:59.357]                           restarts <- computeRestarts(cond)
[08:27:59.357]                           for (restart in restarts) {
[08:27:59.357]                             name <- restart$name
[08:27:59.357]                             if (is.null(name)) 
[08:27:59.357]                               next
[08:27:59.357]                             if (!grepl(pattern, name)) 
[08:27:59.357]                               next
[08:27:59.357]                             invokeRestart(restart)
[08:27:59.357]                             muffled <- TRUE
[08:27:59.357]                             break
[08:27:59.357]                           }
[08:27:59.357]                         }
[08:27:59.357]                       }
[08:27:59.357]                       invisible(muffled)
[08:27:59.357]                     }
[08:27:59.357]                     muffleCondition(cond, pattern = "^muffle")
[08:27:59.357]                   }
[08:27:59.357]                 }
[08:27:59.357]                 else {
[08:27:59.357]                   if (TRUE) {
[08:27:59.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.357]                     {
[08:27:59.357]                       inherits <- base::inherits
[08:27:59.357]                       invokeRestart <- base::invokeRestart
[08:27:59.357]                       is.null <- base::is.null
[08:27:59.357]                       muffled <- FALSE
[08:27:59.357]                       if (inherits(cond, "message")) {
[08:27:59.357]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:59.357]                         if (muffled) 
[08:27:59.357]                           invokeRestart("muffleMessage")
[08:27:59.357]                       }
[08:27:59.357]                       else if (inherits(cond, "warning")) {
[08:27:59.357]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:59.357]                         if (muffled) 
[08:27:59.357]                           invokeRestart("muffleWarning")
[08:27:59.357]                       }
[08:27:59.357]                       else if (inherits(cond, "condition")) {
[08:27:59.357]                         if (!is.null(pattern)) {
[08:27:59.357]                           computeRestarts <- base::computeRestarts
[08:27:59.357]                           grepl <- base::grepl
[08:27:59.357]                           restarts <- computeRestarts(cond)
[08:27:59.357]                           for (restart in restarts) {
[08:27:59.357]                             name <- restart$name
[08:27:59.357]                             if (is.null(name)) 
[08:27:59.357]                               next
[08:27:59.357]                             if (!grepl(pattern, name)) 
[08:27:59.357]                               next
[08:27:59.357]                             invokeRestart(restart)
[08:27:59.357]                             muffled <- TRUE
[08:27:59.357]                             break
[08:27:59.357]                           }
[08:27:59.357]                         }
[08:27:59.357]                       }
[08:27:59.357]                       invisible(muffled)
[08:27:59.357]                     }
[08:27:59.357]                     muffleCondition(cond, pattern = "^muffle")
[08:27:59.357]                   }
[08:27:59.357]                 }
[08:27:59.357]             }
[08:27:59.357]         }))
[08:27:59.357]     }, error = function(ex) {
[08:27:59.357]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:59.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:59.357]                 ...future.rng), started = ...future.startTime, 
[08:27:59.357]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:59.357]             version = "1.8"), class = "FutureResult")
[08:27:59.357]     }, finally = {
[08:27:59.357]         if (!identical(...future.workdir, getwd())) 
[08:27:59.357]             setwd(...future.workdir)
[08:27:59.357]         {
[08:27:59.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:59.357]                 ...future.oldOptions$nwarnings <- NULL
[08:27:59.357]             }
[08:27:59.357]             base::options(...future.oldOptions)
[08:27:59.357]             if (.Platform$OS.type == "windows") {
[08:27:59.357]                 old_names <- names(...future.oldEnvVars)
[08:27:59.357]                 envs <- base::Sys.getenv()
[08:27:59.357]                 names <- names(envs)
[08:27:59.357]                 common <- intersect(names, old_names)
[08:27:59.357]                 added <- setdiff(names, old_names)
[08:27:59.357]                 removed <- setdiff(old_names, names)
[08:27:59.357]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:59.357]                   envs[common]]
[08:27:59.357]                 NAMES <- toupper(changed)
[08:27:59.357]                 args <- list()
[08:27:59.357]                 for (kk in seq_along(NAMES)) {
[08:27:59.357]                   name <- changed[[kk]]
[08:27:59.357]                   NAME <- NAMES[[kk]]
[08:27:59.357]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.357]                     next
[08:27:59.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:59.357]                 }
[08:27:59.357]                 NAMES <- toupper(added)
[08:27:59.357]                 for (kk in seq_along(NAMES)) {
[08:27:59.357]                   name <- added[[kk]]
[08:27:59.357]                   NAME <- NAMES[[kk]]
[08:27:59.357]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.357]                     next
[08:27:59.357]                   args[[name]] <- ""
[08:27:59.357]                 }
[08:27:59.357]                 NAMES <- toupper(removed)
[08:27:59.357]                 for (kk in seq_along(NAMES)) {
[08:27:59.357]                   name <- removed[[kk]]
[08:27:59.357]                   NAME <- NAMES[[kk]]
[08:27:59.357]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.357]                     next
[08:27:59.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:59.357]                 }
[08:27:59.357]                 if (length(args) > 0) 
[08:27:59.357]                   base::do.call(base::Sys.setenv, args = args)
[08:27:59.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:59.357]             }
[08:27:59.357]             else {
[08:27:59.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:59.357]             }
[08:27:59.357]             {
[08:27:59.357]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:59.357]                   0L) {
[08:27:59.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:59.357]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:59.357]                   base::options(opts)
[08:27:59.357]                 }
[08:27:59.357]                 {
[08:27:59.357]                   {
[08:27:59.357]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:59.357]                     NULL
[08:27:59.357]                   }
[08:27:59.357]                   options(future.plan = NULL)
[08:27:59.357]                   if (is.na(NA_character_)) 
[08:27:59.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:59.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:59.357]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:59.357]                     .init = FALSE)
[08:27:59.357]                 }
[08:27:59.357]             }
[08:27:59.357]         }
[08:27:59.357]     })
[08:27:59.357]     if (TRUE) {
[08:27:59.357]         base::sink(type = "output", split = FALSE)
[08:27:59.357]         if (TRUE) {
[08:27:59.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:59.357]         }
[08:27:59.357]         else {
[08:27:59.357]             ...future.result["stdout"] <- base::list(NULL)
[08:27:59.357]         }
[08:27:59.357]         base::close(...future.stdout)
[08:27:59.357]         ...future.stdout <- NULL
[08:27:59.357]     }
[08:27:59.357]     ...future.result$conditions <- ...future.conditions
[08:27:59.357]     ...future.result$finished <- base::Sys.time()
[08:27:59.357]     ...future.result
[08:27:59.357] }
[08:27:59.360] MultisessionFuture started
[08:27:59.360] - Launch lazy future ... done
[08:27:59.360] run() for ‘MultisessionFuture’ ... done
[08:27:59.360] result() for ClusterFuture ...
[08:27:59.361] receiveMessageFromWorker() for ClusterFuture ...
[08:27:59.361] - Validating connection of MultisessionFuture
[08:27:59.403] - received message: FutureResult
[08:27:59.403] - Received FutureResult
[08:27:59.403] - Erased future from FutureRegistry
[08:27:59.403] result() for ClusterFuture ...
[08:27:59.404] - result already collected: FutureResult
[08:27:59.404] result() for ClusterFuture ... done
[08:27:59.404] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:59.404] result() for ClusterFuture ... done
[08:27:59.404] result() for ClusterFuture ...
[08:27:59.404] - result already collected: FutureResult
[08:27:59.404] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[08:27:59.406] getGlobalsAndPackages() ...
[08:27:59.406] Searching for globals...
[08:27:59.408] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[08:27:59.408] Searching for globals ... DONE
[08:27:59.408] Resolving globals: FALSE
[08:27:59.409] 
[08:27:59.409] - packages: [2] ‘stats’, ‘datasets’
[08:27:59.409] getGlobalsAndPackages() ... DONE
[08:27:59.409] run() for ‘Future’ ...
[08:27:59.409] - state: ‘created’
[08:27:59.410] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:59.423] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:59.424] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:59.424]   - Field: ‘node’
[08:27:59.424]   - Field: ‘label’
[08:27:59.424]   - Field: ‘local’
[08:27:59.424]   - Field: ‘owner’
[08:27:59.424]   - Field: ‘envir’
[08:27:59.424]   - Field: ‘workers’
[08:27:59.424]   - Field: ‘packages’
[08:27:59.424]   - Field: ‘gc’
[08:27:59.424]   - Field: ‘conditions’
[08:27:59.424]   - Field: ‘persistent’
[08:27:59.425]   - Field: ‘expr’
[08:27:59.425]   - Field: ‘uuid’
[08:27:59.425]   - Field: ‘seed’
[08:27:59.425]   - Field: ‘version’
[08:27:59.425]   - Field: ‘result’
[08:27:59.425]   - Field: ‘asynchronous’
[08:27:59.425]   - Field: ‘calls’
[08:27:59.425]   - Field: ‘globals’
[08:27:59.425]   - Field: ‘stdout’
[08:27:59.425]   - Field: ‘earlySignal’
[08:27:59.425]   - Field: ‘lazy’
[08:27:59.425]   - Field: ‘state’
[08:27:59.426] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:59.426] - Launch lazy future ...
[08:27:59.426] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[08:27:59.426] Packages needed by future strategies (n = 0): <none>
[08:27:59.427] {
[08:27:59.427]     {
[08:27:59.427]         {
[08:27:59.427]             ...future.startTime <- base::Sys.time()
[08:27:59.427]             {
[08:27:59.427]                 {
[08:27:59.427]                   {
[08:27:59.427]                     {
[08:27:59.427]                       {
[08:27:59.427]                         base::local({
[08:27:59.427]                           has_future <- base::requireNamespace("future", 
[08:27:59.427]                             quietly = TRUE)
[08:27:59.427]                           if (has_future) {
[08:27:59.427]                             ns <- base::getNamespace("future")
[08:27:59.427]                             version <- ns[[".package"]][["version"]]
[08:27:59.427]                             if (is.null(version)) 
[08:27:59.427]                               version <- utils::packageVersion("future")
[08:27:59.427]                           }
[08:27:59.427]                           else {
[08:27:59.427]                             version <- NULL
[08:27:59.427]                           }
[08:27:59.427]                           if (!has_future || version < "1.8.0") {
[08:27:59.427]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:59.427]                               "", base::R.version$version.string), 
[08:27:59.427]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:59.427]                                 base::R.version$platform, 8 * 
[08:27:59.427]                                   base::.Machine$sizeof.pointer), 
[08:27:59.427]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:59.427]                                 "release", "version")], collapse = " "), 
[08:27:59.427]                               hostname = base::Sys.info()[["nodename"]])
[08:27:59.427]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:59.427]                               info)
[08:27:59.427]                             info <- base::paste(info, collapse = "; ")
[08:27:59.427]                             if (!has_future) {
[08:27:59.427]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:59.427]                                 info)
[08:27:59.427]                             }
[08:27:59.427]                             else {
[08:27:59.427]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:59.427]                                 info, version)
[08:27:59.427]                             }
[08:27:59.427]                             base::stop(msg)
[08:27:59.427]                           }
[08:27:59.427]                         })
[08:27:59.427]                       }
[08:27:59.427]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:59.427]                       base::options(mc.cores = 1L)
[08:27:59.427]                     }
[08:27:59.427]                     base::local({
[08:27:59.427]                       for (pkg in c("stats", "datasets")) {
[08:27:59.427]                         base::loadNamespace(pkg)
[08:27:59.427]                         base::library(pkg, character.only = TRUE)
[08:27:59.427]                       }
[08:27:59.427]                     })
[08:27:59.427]                   }
[08:27:59.427]                   ...future.strategy.old <- future::plan("list")
[08:27:59.427]                   options(future.plan = NULL)
[08:27:59.427]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:59.427]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:59.427]                 }
[08:27:59.427]                 ...future.workdir <- getwd()
[08:27:59.427]             }
[08:27:59.427]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:59.427]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:59.427]         }
[08:27:59.427]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:59.427]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:59.427]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:59.427]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:59.427]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:59.427]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:59.427]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:59.427]             base::names(...future.oldOptions))
[08:27:59.427]     }
[08:27:59.427]     if (FALSE) {
[08:27:59.427]     }
[08:27:59.427]     else {
[08:27:59.427]         if (TRUE) {
[08:27:59.427]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:59.427]                 open = "w")
[08:27:59.427]         }
[08:27:59.427]         else {
[08:27:59.427]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:59.427]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:59.427]         }
[08:27:59.427]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:59.427]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:59.427]             base::sink(type = "output", split = FALSE)
[08:27:59.427]             base::close(...future.stdout)
[08:27:59.427]         }, add = TRUE)
[08:27:59.427]     }
[08:27:59.427]     ...future.frame <- base::sys.nframe()
[08:27:59.427]     ...future.conditions <- base::list()
[08:27:59.427]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:59.427]     if (FALSE) {
[08:27:59.427]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:59.427]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:59.427]     }
[08:27:59.427]     ...future.result <- base::tryCatch({
[08:27:59.427]         base::withCallingHandlers({
[08:27:59.427]             ...future.value <- base::withVisible(base::local({
[08:27:59.427]                 ...future.makeSendCondition <- base::local({
[08:27:59.427]                   sendCondition <- NULL
[08:27:59.427]                   function(frame = 1L) {
[08:27:59.427]                     if (is.function(sendCondition)) 
[08:27:59.427]                       return(sendCondition)
[08:27:59.427]                     ns <- getNamespace("parallel")
[08:27:59.427]                     if (exists("sendData", mode = "function", 
[08:27:59.427]                       envir = ns)) {
[08:27:59.427]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:59.427]                         envir = ns)
[08:27:59.427]                       envir <- sys.frame(frame)
[08:27:59.427]                       master <- NULL
[08:27:59.427]                       while (!identical(envir, .GlobalEnv) && 
[08:27:59.427]                         !identical(envir, emptyenv())) {
[08:27:59.427]                         if (exists("master", mode = "list", envir = envir, 
[08:27:59.427]                           inherits = FALSE)) {
[08:27:59.427]                           master <- get("master", mode = "list", 
[08:27:59.427]                             envir = envir, inherits = FALSE)
[08:27:59.427]                           if (inherits(master, c("SOCKnode", 
[08:27:59.427]                             "SOCK0node"))) {
[08:27:59.427]                             sendCondition <<- function(cond) {
[08:27:59.427]                               data <- list(type = "VALUE", value = cond, 
[08:27:59.427]                                 success = TRUE)
[08:27:59.427]                               parallel_sendData(master, data)
[08:27:59.427]                             }
[08:27:59.427]                             return(sendCondition)
[08:27:59.427]                           }
[08:27:59.427]                         }
[08:27:59.427]                         frame <- frame + 1L
[08:27:59.427]                         envir <- sys.frame(frame)
[08:27:59.427]                       }
[08:27:59.427]                     }
[08:27:59.427]                     sendCondition <<- function(cond) NULL
[08:27:59.427]                   }
[08:27:59.427]                 })
[08:27:59.427]                 withCallingHandlers({
[08:27:59.427]                   {
[08:27:59.427]                     lm(dist ~ speed + speed^2, data = cars)
[08:27:59.427]                   }
[08:27:59.427]                 }, immediateCondition = function(cond) {
[08:27:59.427]                   sendCondition <- ...future.makeSendCondition()
[08:27:59.427]                   sendCondition(cond)
[08:27:59.427]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.427]                   {
[08:27:59.427]                     inherits <- base::inherits
[08:27:59.427]                     invokeRestart <- base::invokeRestart
[08:27:59.427]                     is.null <- base::is.null
[08:27:59.427]                     muffled <- FALSE
[08:27:59.427]                     if (inherits(cond, "message")) {
[08:27:59.427]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:59.427]                       if (muffled) 
[08:27:59.427]                         invokeRestart("muffleMessage")
[08:27:59.427]                     }
[08:27:59.427]                     else if (inherits(cond, "warning")) {
[08:27:59.427]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:59.427]                       if (muffled) 
[08:27:59.427]                         invokeRestart("muffleWarning")
[08:27:59.427]                     }
[08:27:59.427]                     else if (inherits(cond, "condition")) {
[08:27:59.427]                       if (!is.null(pattern)) {
[08:27:59.427]                         computeRestarts <- base::computeRestarts
[08:27:59.427]                         grepl <- base::grepl
[08:27:59.427]                         restarts <- computeRestarts(cond)
[08:27:59.427]                         for (restart in restarts) {
[08:27:59.427]                           name <- restart$name
[08:27:59.427]                           if (is.null(name)) 
[08:27:59.427]                             next
[08:27:59.427]                           if (!grepl(pattern, name)) 
[08:27:59.427]                             next
[08:27:59.427]                           invokeRestart(restart)
[08:27:59.427]                           muffled <- TRUE
[08:27:59.427]                           break
[08:27:59.427]                         }
[08:27:59.427]                       }
[08:27:59.427]                     }
[08:27:59.427]                     invisible(muffled)
[08:27:59.427]                   }
[08:27:59.427]                   muffleCondition(cond)
[08:27:59.427]                 })
[08:27:59.427]             }))
[08:27:59.427]             future::FutureResult(value = ...future.value$value, 
[08:27:59.427]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:59.427]                   ...future.rng), globalenv = if (FALSE) 
[08:27:59.427]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:59.427]                     ...future.globalenv.names))
[08:27:59.427]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:59.427]         }, condition = base::local({
[08:27:59.427]             c <- base::c
[08:27:59.427]             inherits <- base::inherits
[08:27:59.427]             invokeRestart <- base::invokeRestart
[08:27:59.427]             length <- base::length
[08:27:59.427]             list <- base::list
[08:27:59.427]             seq.int <- base::seq.int
[08:27:59.427]             signalCondition <- base::signalCondition
[08:27:59.427]             sys.calls <- base::sys.calls
[08:27:59.427]             `[[` <- base::`[[`
[08:27:59.427]             `+` <- base::`+`
[08:27:59.427]             `<<-` <- base::`<<-`
[08:27:59.427]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:59.427]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:59.427]                   3L)]
[08:27:59.427]             }
[08:27:59.427]             function(cond) {
[08:27:59.427]                 is_error <- inherits(cond, "error")
[08:27:59.427]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:59.427]                   NULL)
[08:27:59.427]                 if (is_error) {
[08:27:59.427]                   sessionInformation <- function() {
[08:27:59.427]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:59.427]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:59.427]                       search = base::search(), system = base::Sys.info())
[08:27:59.427]                   }
[08:27:59.427]                   ...future.conditions[[length(...future.conditions) + 
[08:27:59.427]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:59.427]                     cond$call), session = sessionInformation(), 
[08:27:59.427]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:59.427]                   signalCondition(cond)
[08:27:59.427]                 }
[08:27:59.427]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:59.427]                 "immediateCondition"))) {
[08:27:59.427]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:59.427]                   ...future.conditions[[length(...future.conditions) + 
[08:27:59.427]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:59.427]                   if (TRUE && !signal) {
[08:27:59.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.427]                     {
[08:27:59.427]                       inherits <- base::inherits
[08:27:59.427]                       invokeRestart <- base::invokeRestart
[08:27:59.427]                       is.null <- base::is.null
[08:27:59.427]                       muffled <- FALSE
[08:27:59.427]                       if (inherits(cond, "message")) {
[08:27:59.427]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:59.427]                         if (muffled) 
[08:27:59.427]                           invokeRestart("muffleMessage")
[08:27:59.427]                       }
[08:27:59.427]                       else if (inherits(cond, "warning")) {
[08:27:59.427]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:59.427]                         if (muffled) 
[08:27:59.427]                           invokeRestart("muffleWarning")
[08:27:59.427]                       }
[08:27:59.427]                       else if (inherits(cond, "condition")) {
[08:27:59.427]                         if (!is.null(pattern)) {
[08:27:59.427]                           computeRestarts <- base::computeRestarts
[08:27:59.427]                           grepl <- base::grepl
[08:27:59.427]                           restarts <- computeRestarts(cond)
[08:27:59.427]                           for (restart in restarts) {
[08:27:59.427]                             name <- restart$name
[08:27:59.427]                             if (is.null(name)) 
[08:27:59.427]                               next
[08:27:59.427]                             if (!grepl(pattern, name)) 
[08:27:59.427]                               next
[08:27:59.427]                             invokeRestart(restart)
[08:27:59.427]                             muffled <- TRUE
[08:27:59.427]                             break
[08:27:59.427]                           }
[08:27:59.427]                         }
[08:27:59.427]                       }
[08:27:59.427]                       invisible(muffled)
[08:27:59.427]                     }
[08:27:59.427]                     muffleCondition(cond, pattern = "^muffle")
[08:27:59.427]                   }
[08:27:59.427]                 }
[08:27:59.427]                 else {
[08:27:59.427]                   if (TRUE) {
[08:27:59.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.427]                     {
[08:27:59.427]                       inherits <- base::inherits
[08:27:59.427]                       invokeRestart <- base::invokeRestart
[08:27:59.427]                       is.null <- base::is.null
[08:27:59.427]                       muffled <- FALSE
[08:27:59.427]                       if (inherits(cond, "message")) {
[08:27:59.427]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:59.427]                         if (muffled) 
[08:27:59.427]                           invokeRestart("muffleMessage")
[08:27:59.427]                       }
[08:27:59.427]                       else if (inherits(cond, "warning")) {
[08:27:59.427]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:59.427]                         if (muffled) 
[08:27:59.427]                           invokeRestart("muffleWarning")
[08:27:59.427]                       }
[08:27:59.427]                       else if (inherits(cond, "condition")) {
[08:27:59.427]                         if (!is.null(pattern)) {
[08:27:59.427]                           computeRestarts <- base::computeRestarts
[08:27:59.427]                           grepl <- base::grepl
[08:27:59.427]                           restarts <- computeRestarts(cond)
[08:27:59.427]                           for (restart in restarts) {
[08:27:59.427]                             name <- restart$name
[08:27:59.427]                             if (is.null(name)) 
[08:27:59.427]                               next
[08:27:59.427]                             if (!grepl(pattern, name)) 
[08:27:59.427]                               next
[08:27:59.427]                             invokeRestart(restart)
[08:27:59.427]                             muffled <- TRUE
[08:27:59.427]                             break
[08:27:59.427]                           }
[08:27:59.427]                         }
[08:27:59.427]                       }
[08:27:59.427]                       invisible(muffled)
[08:27:59.427]                     }
[08:27:59.427]                     muffleCondition(cond, pattern = "^muffle")
[08:27:59.427]                   }
[08:27:59.427]                 }
[08:27:59.427]             }
[08:27:59.427]         }))
[08:27:59.427]     }, error = function(ex) {
[08:27:59.427]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:59.427]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:59.427]                 ...future.rng), started = ...future.startTime, 
[08:27:59.427]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:59.427]             version = "1.8"), class = "FutureResult")
[08:27:59.427]     }, finally = {
[08:27:59.427]         if (!identical(...future.workdir, getwd())) 
[08:27:59.427]             setwd(...future.workdir)
[08:27:59.427]         {
[08:27:59.427]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:59.427]                 ...future.oldOptions$nwarnings <- NULL
[08:27:59.427]             }
[08:27:59.427]             base::options(...future.oldOptions)
[08:27:59.427]             if (.Platform$OS.type == "windows") {
[08:27:59.427]                 old_names <- names(...future.oldEnvVars)
[08:27:59.427]                 envs <- base::Sys.getenv()
[08:27:59.427]                 names <- names(envs)
[08:27:59.427]                 common <- intersect(names, old_names)
[08:27:59.427]                 added <- setdiff(names, old_names)
[08:27:59.427]                 removed <- setdiff(old_names, names)
[08:27:59.427]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:59.427]                   envs[common]]
[08:27:59.427]                 NAMES <- toupper(changed)
[08:27:59.427]                 args <- list()
[08:27:59.427]                 for (kk in seq_along(NAMES)) {
[08:27:59.427]                   name <- changed[[kk]]
[08:27:59.427]                   NAME <- NAMES[[kk]]
[08:27:59.427]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.427]                     next
[08:27:59.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:59.427]                 }
[08:27:59.427]                 NAMES <- toupper(added)
[08:27:59.427]                 for (kk in seq_along(NAMES)) {
[08:27:59.427]                   name <- added[[kk]]
[08:27:59.427]                   NAME <- NAMES[[kk]]
[08:27:59.427]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.427]                     next
[08:27:59.427]                   args[[name]] <- ""
[08:27:59.427]                 }
[08:27:59.427]                 NAMES <- toupper(removed)
[08:27:59.427]                 for (kk in seq_along(NAMES)) {
[08:27:59.427]                   name <- removed[[kk]]
[08:27:59.427]                   NAME <- NAMES[[kk]]
[08:27:59.427]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.427]                     next
[08:27:59.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:59.427]                 }
[08:27:59.427]                 if (length(args) > 0) 
[08:27:59.427]                   base::do.call(base::Sys.setenv, args = args)
[08:27:59.427]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:59.427]             }
[08:27:59.427]             else {
[08:27:59.427]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:59.427]             }
[08:27:59.427]             {
[08:27:59.427]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:59.427]                   0L) {
[08:27:59.427]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:59.427]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:59.427]                   base::options(opts)
[08:27:59.427]                 }
[08:27:59.427]                 {
[08:27:59.427]                   {
[08:27:59.427]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:59.427]                     NULL
[08:27:59.427]                   }
[08:27:59.427]                   options(future.plan = NULL)
[08:27:59.427]                   if (is.na(NA_character_)) 
[08:27:59.427]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:59.427]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:59.427]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:59.427]                     .init = FALSE)
[08:27:59.427]                 }
[08:27:59.427]             }
[08:27:59.427]         }
[08:27:59.427]     })
[08:27:59.427]     if (TRUE) {
[08:27:59.427]         base::sink(type = "output", split = FALSE)
[08:27:59.427]         if (TRUE) {
[08:27:59.427]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:59.427]         }
[08:27:59.427]         else {
[08:27:59.427]             ...future.result["stdout"] <- base::list(NULL)
[08:27:59.427]         }
[08:27:59.427]         base::close(...future.stdout)
[08:27:59.427]         ...future.stdout <- NULL
[08:27:59.427]     }
[08:27:59.427]     ...future.result$conditions <- ...future.conditions
[08:27:59.427]     ...future.result$finished <- base::Sys.time()
[08:27:59.427]     ...future.result
[08:27:59.427] }
[08:27:59.430] MultisessionFuture started
[08:27:59.430] - Launch lazy future ... done
[08:27:59.430] run() for ‘MultisessionFuture’ ... done
[08:27:59.430] result() for ClusterFuture ...
[08:27:59.430] receiveMessageFromWorker() for ClusterFuture ...
[08:27:59.430] - Validating connection of MultisessionFuture
[08:27:59.473] - received message: FutureResult
[08:27:59.473] - Received FutureResult
[08:27:59.473] - Erased future from FutureRegistry
[08:27:59.473] result() for ClusterFuture ...
[08:27:59.473] - result already collected: FutureResult
[08:27:59.473] result() for ClusterFuture ... done
[08:27:59.475] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:59.476] result() for ClusterFuture ... done
[08:27:59.476] result() for ClusterFuture ...
[08:27:59.476] - result already collected: FutureResult
[08:27:59.476] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[08:27:59.478] getGlobalsAndPackages() ...
[08:27:59.478] Searching for globals...
[08:27:59.480] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[08:27:59.480] Searching for globals ... DONE
[08:27:59.480] Resolving globals: FALSE
[08:27:59.481] 
[08:27:59.481] - packages: [2] ‘stats’, ‘datasets’
[08:27:59.481] getGlobalsAndPackages() ... DONE
[08:27:59.481] run() for ‘Future’ ...
[08:27:59.481] - state: ‘created’
[08:27:59.481] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:59.495] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:59.495] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:59.495]   - Field: ‘node’
[08:27:59.495]   - Field: ‘label’
[08:27:59.496]   - Field: ‘local’
[08:27:59.496]   - Field: ‘owner’
[08:27:59.496]   - Field: ‘envir’
[08:27:59.496]   - Field: ‘workers’
[08:27:59.496]   - Field: ‘packages’
[08:27:59.496]   - Field: ‘gc’
[08:27:59.496]   - Field: ‘conditions’
[08:27:59.496]   - Field: ‘persistent’
[08:27:59.496]   - Field: ‘expr’
[08:27:59.496]   - Field: ‘uuid’
[08:27:59.496]   - Field: ‘seed’
[08:27:59.496]   - Field: ‘version’
[08:27:59.497]   - Field: ‘result’
[08:27:59.497]   - Field: ‘asynchronous’
[08:27:59.497]   - Field: ‘calls’
[08:27:59.497]   - Field: ‘globals’
[08:27:59.497]   - Field: ‘stdout’
[08:27:59.497]   - Field: ‘earlySignal’
[08:27:59.497]   - Field: ‘lazy’
[08:27:59.497]   - Field: ‘state’
[08:27:59.497] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:59.497] - Launch lazy future ...
[08:27:59.497] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[08:27:59.498] Packages needed by future strategies (n = 0): <none>
[08:27:59.498] {
[08:27:59.498]     {
[08:27:59.498]         {
[08:27:59.498]             ...future.startTime <- base::Sys.time()
[08:27:59.498]             {
[08:27:59.498]                 {
[08:27:59.498]                   {
[08:27:59.498]                     {
[08:27:59.498]                       {
[08:27:59.498]                         base::local({
[08:27:59.498]                           has_future <- base::requireNamespace("future", 
[08:27:59.498]                             quietly = TRUE)
[08:27:59.498]                           if (has_future) {
[08:27:59.498]                             ns <- base::getNamespace("future")
[08:27:59.498]                             version <- ns[[".package"]][["version"]]
[08:27:59.498]                             if (is.null(version)) 
[08:27:59.498]                               version <- utils::packageVersion("future")
[08:27:59.498]                           }
[08:27:59.498]                           else {
[08:27:59.498]                             version <- NULL
[08:27:59.498]                           }
[08:27:59.498]                           if (!has_future || version < "1.8.0") {
[08:27:59.498]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:59.498]                               "", base::R.version$version.string), 
[08:27:59.498]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:59.498]                                 base::R.version$platform, 8 * 
[08:27:59.498]                                   base::.Machine$sizeof.pointer), 
[08:27:59.498]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:59.498]                                 "release", "version")], collapse = " "), 
[08:27:59.498]                               hostname = base::Sys.info()[["nodename"]])
[08:27:59.498]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:59.498]                               info)
[08:27:59.498]                             info <- base::paste(info, collapse = "; ")
[08:27:59.498]                             if (!has_future) {
[08:27:59.498]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:59.498]                                 info)
[08:27:59.498]                             }
[08:27:59.498]                             else {
[08:27:59.498]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:59.498]                                 info, version)
[08:27:59.498]                             }
[08:27:59.498]                             base::stop(msg)
[08:27:59.498]                           }
[08:27:59.498]                         })
[08:27:59.498]                       }
[08:27:59.498]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:59.498]                       base::options(mc.cores = 1L)
[08:27:59.498]                     }
[08:27:59.498]                     base::local({
[08:27:59.498]                       for (pkg in c("stats", "datasets")) {
[08:27:59.498]                         base::loadNamespace(pkg)
[08:27:59.498]                         base::library(pkg, character.only = TRUE)
[08:27:59.498]                       }
[08:27:59.498]                     })
[08:27:59.498]                   }
[08:27:59.498]                   ...future.strategy.old <- future::plan("list")
[08:27:59.498]                   options(future.plan = NULL)
[08:27:59.498]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:59.498]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:59.498]                 }
[08:27:59.498]                 ...future.workdir <- getwd()
[08:27:59.498]             }
[08:27:59.498]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:59.498]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:59.498]         }
[08:27:59.498]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:59.498]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:59.498]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:59.498]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:59.498]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:59.498]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:59.498]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:59.498]             base::names(...future.oldOptions))
[08:27:59.498]     }
[08:27:59.498]     if (FALSE) {
[08:27:59.498]     }
[08:27:59.498]     else {
[08:27:59.498]         if (TRUE) {
[08:27:59.498]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:59.498]                 open = "w")
[08:27:59.498]         }
[08:27:59.498]         else {
[08:27:59.498]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:59.498]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:59.498]         }
[08:27:59.498]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:59.498]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:59.498]             base::sink(type = "output", split = FALSE)
[08:27:59.498]             base::close(...future.stdout)
[08:27:59.498]         }, add = TRUE)
[08:27:59.498]     }
[08:27:59.498]     ...future.frame <- base::sys.nframe()
[08:27:59.498]     ...future.conditions <- base::list()
[08:27:59.498]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:59.498]     if (FALSE) {
[08:27:59.498]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:59.498]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:59.498]     }
[08:27:59.498]     ...future.result <- base::tryCatch({
[08:27:59.498]         base::withCallingHandlers({
[08:27:59.498]             ...future.value <- base::withVisible(base::local({
[08:27:59.498]                 ...future.makeSendCondition <- base::local({
[08:27:59.498]                   sendCondition <- NULL
[08:27:59.498]                   function(frame = 1L) {
[08:27:59.498]                     if (is.function(sendCondition)) 
[08:27:59.498]                       return(sendCondition)
[08:27:59.498]                     ns <- getNamespace("parallel")
[08:27:59.498]                     if (exists("sendData", mode = "function", 
[08:27:59.498]                       envir = ns)) {
[08:27:59.498]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:59.498]                         envir = ns)
[08:27:59.498]                       envir <- sys.frame(frame)
[08:27:59.498]                       master <- NULL
[08:27:59.498]                       while (!identical(envir, .GlobalEnv) && 
[08:27:59.498]                         !identical(envir, emptyenv())) {
[08:27:59.498]                         if (exists("master", mode = "list", envir = envir, 
[08:27:59.498]                           inherits = FALSE)) {
[08:27:59.498]                           master <- get("master", mode = "list", 
[08:27:59.498]                             envir = envir, inherits = FALSE)
[08:27:59.498]                           if (inherits(master, c("SOCKnode", 
[08:27:59.498]                             "SOCK0node"))) {
[08:27:59.498]                             sendCondition <<- function(cond) {
[08:27:59.498]                               data <- list(type = "VALUE", value = cond, 
[08:27:59.498]                                 success = TRUE)
[08:27:59.498]                               parallel_sendData(master, data)
[08:27:59.498]                             }
[08:27:59.498]                             return(sendCondition)
[08:27:59.498]                           }
[08:27:59.498]                         }
[08:27:59.498]                         frame <- frame + 1L
[08:27:59.498]                         envir <- sys.frame(frame)
[08:27:59.498]                       }
[08:27:59.498]                     }
[08:27:59.498]                     sendCondition <<- function(cond) NULL
[08:27:59.498]                   }
[08:27:59.498]                 })
[08:27:59.498]                 withCallingHandlers({
[08:27:59.498]                   {
[08:27:59.498]                     lm(dist ~ speed + I(speed^2), data = cars)
[08:27:59.498]                   }
[08:27:59.498]                 }, immediateCondition = function(cond) {
[08:27:59.498]                   sendCondition <- ...future.makeSendCondition()
[08:27:59.498]                   sendCondition(cond)
[08:27:59.498]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.498]                   {
[08:27:59.498]                     inherits <- base::inherits
[08:27:59.498]                     invokeRestart <- base::invokeRestart
[08:27:59.498]                     is.null <- base::is.null
[08:27:59.498]                     muffled <- FALSE
[08:27:59.498]                     if (inherits(cond, "message")) {
[08:27:59.498]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:59.498]                       if (muffled) 
[08:27:59.498]                         invokeRestart("muffleMessage")
[08:27:59.498]                     }
[08:27:59.498]                     else if (inherits(cond, "warning")) {
[08:27:59.498]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:59.498]                       if (muffled) 
[08:27:59.498]                         invokeRestart("muffleWarning")
[08:27:59.498]                     }
[08:27:59.498]                     else if (inherits(cond, "condition")) {
[08:27:59.498]                       if (!is.null(pattern)) {
[08:27:59.498]                         computeRestarts <- base::computeRestarts
[08:27:59.498]                         grepl <- base::grepl
[08:27:59.498]                         restarts <- computeRestarts(cond)
[08:27:59.498]                         for (restart in restarts) {
[08:27:59.498]                           name <- restart$name
[08:27:59.498]                           if (is.null(name)) 
[08:27:59.498]                             next
[08:27:59.498]                           if (!grepl(pattern, name)) 
[08:27:59.498]                             next
[08:27:59.498]                           invokeRestart(restart)
[08:27:59.498]                           muffled <- TRUE
[08:27:59.498]                           break
[08:27:59.498]                         }
[08:27:59.498]                       }
[08:27:59.498]                     }
[08:27:59.498]                     invisible(muffled)
[08:27:59.498]                   }
[08:27:59.498]                   muffleCondition(cond)
[08:27:59.498]                 })
[08:27:59.498]             }))
[08:27:59.498]             future::FutureResult(value = ...future.value$value, 
[08:27:59.498]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:59.498]                   ...future.rng), globalenv = if (FALSE) 
[08:27:59.498]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:59.498]                     ...future.globalenv.names))
[08:27:59.498]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:59.498]         }, condition = base::local({
[08:27:59.498]             c <- base::c
[08:27:59.498]             inherits <- base::inherits
[08:27:59.498]             invokeRestart <- base::invokeRestart
[08:27:59.498]             length <- base::length
[08:27:59.498]             list <- base::list
[08:27:59.498]             seq.int <- base::seq.int
[08:27:59.498]             signalCondition <- base::signalCondition
[08:27:59.498]             sys.calls <- base::sys.calls
[08:27:59.498]             `[[` <- base::`[[`
[08:27:59.498]             `+` <- base::`+`
[08:27:59.498]             `<<-` <- base::`<<-`
[08:27:59.498]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:59.498]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:59.498]                   3L)]
[08:27:59.498]             }
[08:27:59.498]             function(cond) {
[08:27:59.498]                 is_error <- inherits(cond, "error")
[08:27:59.498]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:59.498]                   NULL)
[08:27:59.498]                 if (is_error) {
[08:27:59.498]                   sessionInformation <- function() {
[08:27:59.498]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:59.498]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:59.498]                       search = base::search(), system = base::Sys.info())
[08:27:59.498]                   }
[08:27:59.498]                   ...future.conditions[[length(...future.conditions) + 
[08:27:59.498]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:59.498]                     cond$call), session = sessionInformation(), 
[08:27:59.498]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:59.498]                   signalCondition(cond)
[08:27:59.498]                 }
[08:27:59.498]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:59.498]                 "immediateCondition"))) {
[08:27:59.498]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:59.498]                   ...future.conditions[[length(...future.conditions) + 
[08:27:59.498]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:59.498]                   if (TRUE && !signal) {
[08:27:59.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.498]                     {
[08:27:59.498]                       inherits <- base::inherits
[08:27:59.498]                       invokeRestart <- base::invokeRestart
[08:27:59.498]                       is.null <- base::is.null
[08:27:59.498]                       muffled <- FALSE
[08:27:59.498]                       if (inherits(cond, "message")) {
[08:27:59.498]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:59.498]                         if (muffled) 
[08:27:59.498]                           invokeRestart("muffleMessage")
[08:27:59.498]                       }
[08:27:59.498]                       else if (inherits(cond, "warning")) {
[08:27:59.498]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:59.498]                         if (muffled) 
[08:27:59.498]                           invokeRestart("muffleWarning")
[08:27:59.498]                       }
[08:27:59.498]                       else if (inherits(cond, "condition")) {
[08:27:59.498]                         if (!is.null(pattern)) {
[08:27:59.498]                           computeRestarts <- base::computeRestarts
[08:27:59.498]                           grepl <- base::grepl
[08:27:59.498]                           restarts <- computeRestarts(cond)
[08:27:59.498]                           for (restart in restarts) {
[08:27:59.498]                             name <- restart$name
[08:27:59.498]                             if (is.null(name)) 
[08:27:59.498]                               next
[08:27:59.498]                             if (!grepl(pattern, name)) 
[08:27:59.498]                               next
[08:27:59.498]                             invokeRestart(restart)
[08:27:59.498]                             muffled <- TRUE
[08:27:59.498]                             break
[08:27:59.498]                           }
[08:27:59.498]                         }
[08:27:59.498]                       }
[08:27:59.498]                       invisible(muffled)
[08:27:59.498]                     }
[08:27:59.498]                     muffleCondition(cond, pattern = "^muffle")
[08:27:59.498]                   }
[08:27:59.498]                 }
[08:27:59.498]                 else {
[08:27:59.498]                   if (TRUE) {
[08:27:59.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.498]                     {
[08:27:59.498]                       inherits <- base::inherits
[08:27:59.498]                       invokeRestart <- base::invokeRestart
[08:27:59.498]                       is.null <- base::is.null
[08:27:59.498]                       muffled <- FALSE
[08:27:59.498]                       if (inherits(cond, "message")) {
[08:27:59.498]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:59.498]                         if (muffled) 
[08:27:59.498]                           invokeRestart("muffleMessage")
[08:27:59.498]                       }
[08:27:59.498]                       else if (inherits(cond, "warning")) {
[08:27:59.498]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:59.498]                         if (muffled) 
[08:27:59.498]                           invokeRestart("muffleWarning")
[08:27:59.498]                       }
[08:27:59.498]                       else if (inherits(cond, "condition")) {
[08:27:59.498]                         if (!is.null(pattern)) {
[08:27:59.498]                           computeRestarts <- base::computeRestarts
[08:27:59.498]                           grepl <- base::grepl
[08:27:59.498]                           restarts <- computeRestarts(cond)
[08:27:59.498]                           for (restart in restarts) {
[08:27:59.498]                             name <- restart$name
[08:27:59.498]                             if (is.null(name)) 
[08:27:59.498]                               next
[08:27:59.498]                             if (!grepl(pattern, name)) 
[08:27:59.498]                               next
[08:27:59.498]                             invokeRestart(restart)
[08:27:59.498]                             muffled <- TRUE
[08:27:59.498]                             break
[08:27:59.498]                           }
[08:27:59.498]                         }
[08:27:59.498]                       }
[08:27:59.498]                       invisible(muffled)
[08:27:59.498]                     }
[08:27:59.498]                     muffleCondition(cond, pattern = "^muffle")
[08:27:59.498]                   }
[08:27:59.498]                 }
[08:27:59.498]             }
[08:27:59.498]         }))
[08:27:59.498]     }, error = function(ex) {
[08:27:59.498]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:59.498]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:59.498]                 ...future.rng), started = ...future.startTime, 
[08:27:59.498]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:59.498]             version = "1.8"), class = "FutureResult")
[08:27:59.498]     }, finally = {
[08:27:59.498]         if (!identical(...future.workdir, getwd())) 
[08:27:59.498]             setwd(...future.workdir)
[08:27:59.498]         {
[08:27:59.498]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:59.498]                 ...future.oldOptions$nwarnings <- NULL
[08:27:59.498]             }
[08:27:59.498]             base::options(...future.oldOptions)
[08:27:59.498]             if (.Platform$OS.type == "windows") {
[08:27:59.498]                 old_names <- names(...future.oldEnvVars)
[08:27:59.498]                 envs <- base::Sys.getenv()
[08:27:59.498]                 names <- names(envs)
[08:27:59.498]                 common <- intersect(names, old_names)
[08:27:59.498]                 added <- setdiff(names, old_names)
[08:27:59.498]                 removed <- setdiff(old_names, names)
[08:27:59.498]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:59.498]                   envs[common]]
[08:27:59.498]                 NAMES <- toupper(changed)
[08:27:59.498]                 args <- list()
[08:27:59.498]                 for (kk in seq_along(NAMES)) {
[08:27:59.498]                   name <- changed[[kk]]
[08:27:59.498]                   NAME <- NAMES[[kk]]
[08:27:59.498]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.498]                     next
[08:27:59.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:59.498]                 }
[08:27:59.498]                 NAMES <- toupper(added)
[08:27:59.498]                 for (kk in seq_along(NAMES)) {
[08:27:59.498]                   name <- added[[kk]]
[08:27:59.498]                   NAME <- NAMES[[kk]]
[08:27:59.498]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.498]                     next
[08:27:59.498]                   args[[name]] <- ""
[08:27:59.498]                 }
[08:27:59.498]                 NAMES <- toupper(removed)
[08:27:59.498]                 for (kk in seq_along(NAMES)) {
[08:27:59.498]                   name <- removed[[kk]]
[08:27:59.498]                   NAME <- NAMES[[kk]]
[08:27:59.498]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.498]                     next
[08:27:59.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:59.498]                 }
[08:27:59.498]                 if (length(args) > 0) 
[08:27:59.498]                   base::do.call(base::Sys.setenv, args = args)
[08:27:59.498]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:59.498]             }
[08:27:59.498]             else {
[08:27:59.498]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:59.498]             }
[08:27:59.498]             {
[08:27:59.498]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:59.498]                   0L) {
[08:27:59.498]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:59.498]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:59.498]                   base::options(opts)
[08:27:59.498]                 }
[08:27:59.498]                 {
[08:27:59.498]                   {
[08:27:59.498]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:59.498]                     NULL
[08:27:59.498]                   }
[08:27:59.498]                   options(future.plan = NULL)
[08:27:59.498]                   if (is.na(NA_character_)) 
[08:27:59.498]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:59.498]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:59.498]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:59.498]                     .init = FALSE)
[08:27:59.498]                 }
[08:27:59.498]             }
[08:27:59.498]         }
[08:27:59.498]     })
[08:27:59.498]     if (TRUE) {
[08:27:59.498]         base::sink(type = "output", split = FALSE)
[08:27:59.498]         if (TRUE) {
[08:27:59.498]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:59.498]         }
[08:27:59.498]         else {
[08:27:59.498]             ...future.result["stdout"] <- base::list(NULL)
[08:27:59.498]         }
[08:27:59.498]         base::close(...future.stdout)
[08:27:59.498]         ...future.stdout <- NULL
[08:27:59.498]     }
[08:27:59.498]     ...future.result$conditions <- ...future.conditions
[08:27:59.498]     ...future.result$finished <- base::Sys.time()
[08:27:59.498]     ...future.result
[08:27:59.498] }
[08:27:59.501] MultisessionFuture started
[08:27:59.501] - Launch lazy future ... done
[08:27:59.501] run() for ‘MultisessionFuture’ ... done
[08:27:59.501] result() for ClusterFuture ...
[08:27:59.501] receiveMessageFromWorker() for ClusterFuture ...
[08:27:59.502] - Validating connection of MultisessionFuture
[08:27:59.544] - received message: FutureResult
[08:27:59.544] - Received FutureResult
[08:27:59.544] - Erased future from FutureRegistry
[08:27:59.544] result() for ClusterFuture ...
[08:27:59.545] - result already collected: FutureResult
[08:27:59.545] result() for ClusterFuture ... done
[08:27:59.545] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:59.545] result() for ClusterFuture ... done
[08:27:59.545] result() for ClusterFuture ...
[08:27:59.545] - result already collected: FutureResult
[08:27:59.545] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[08:27:59.548] getGlobalsAndPackages() ...
[08:27:59.548] Searching for globals...
[08:27:59.549] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[08:27:59.549] Searching for globals ... DONE
[08:27:59.550] Resolving globals: FALSE
[08:27:59.550] 
[08:27:59.550] - packages: [2] ‘stats’, ‘datasets’
[08:27:59.550] getGlobalsAndPackages() ... DONE
[08:27:59.550] run() for ‘Future’ ...
[08:27:59.551] - state: ‘created’
[08:27:59.551] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:59.565] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:59.565] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:59.565]   - Field: ‘node’
[08:27:59.565]   - Field: ‘label’
[08:27:59.565]   - Field: ‘local’
[08:27:59.566]   - Field: ‘owner’
[08:27:59.566]   - Field: ‘envir’
[08:27:59.566]   - Field: ‘workers’
[08:27:59.566]   - Field: ‘packages’
[08:27:59.566]   - Field: ‘gc’
[08:27:59.566]   - Field: ‘conditions’
[08:27:59.566]   - Field: ‘persistent’
[08:27:59.566]   - Field: ‘expr’
[08:27:59.566]   - Field: ‘uuid’
[08:27:59.566]   - Field: ‘seed’
[08:27:59.566]   - Field: ‘version’
[08:27:59.567]   - Field: ‘result’
[08:27:59.567]   - Field: ‘asynchronous’
[08:27:59.567]   - Field: ‘calls’
[08:27:59.567]   - Field: ‘globals’
[08:27:59.567]   - Field: ‘stdout’
[08:27:59.567]   - Field: ‘earlySignal’
[08:27:59.567]   - Field: ‘lazy’
[08:27:59.567]   - Field: ‘state’
[08:27:59.567] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:59.567] - Launch lazy future ...
[08:27:59.568] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[08:27:59.568] Packages needed by future strategies (n = 0): <none>
[08:27:59.568] {
[08:27:59.568]     {
[08:27:59.568]         {
[08:27:59.568]             ...future.startTime <- base::Sys.time()
[08:27:59.568]             {
[08:27:59.568]                 {
[08:27:59.568]                   {
[08:27:59.568]                     {
[08:27:59.568]                       {
[08:27:59.568]                         base::local({
[08:27:59.568]                           has_future <- base::requireNamespace("future", 
[08:27:59.568]                             quietly = TRUE)
[08:27:59.568]                           if (has_future) {
[08:27:59.568]                             ns <- base::getNamespace("future")
[08:27:59.568]                             version <- ns[[".package"]][["version"]]
[08:27:59.568]                             if (is.null(version)) 
[08:27:59.568]                               version <- utils::packageVersion("future")
[08:27:59.568]                           }
[08:27:59.568]                           else {
[08:27:59.568]                             version <- NULL
[08:27:59.568]                           }
[08:27:59.568]                           if (!has_future || version < "1.8.0") {
[08:27:59.568]                             info <- base::c(r_version = base::gsub("R version ", 
[08:27:59.568]                               "", base::R.version$version.string), 
[08:27:59.568]                               platform = base::sprintf("%s (%s-bit)", 
[08:27:59.568]                                 base::R.version$platform, 8 * 
[08:27:59.568]                                   base::.Machine$sizeof.pointer), 
[08:27:59.568]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:59.568]                                 "release", "version")], collapse = " "), 
[08:27:59.568]                               hostname = base::Sys.info()[["nodename"]])
[08:27:59.568]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:27:59.568]                               info)
[08:27:59.568]                             info <- base::paste(info, collapse = "; ")
[08:27:59.568]                             if (!has_future) {
[08:27:59.568]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:59.568]                                 info)
[08:27:59.568]                             }
[08:27:59.568]                             else {
[08:27:59.568]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:59.568]                                 info, version)
[08:27:59.568]                             }
[08:27:59.568]                             base::stop(msg)
[08:27:59.568]                           }
[08:27:59.568]                         })
[08:27:59.568]                       }
[08:27:59.568]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:59.568]                       base::options(mc.cores = 1L)
[08:27:59.568]                     }
[08:27:59.568]                     base::local({
[08:27:59.568]                       for (pkg in c("stats", "datasets")) {
[08:27:59.568]                         base::loadNamespace(pkg)
[08:27:59.568]                         base::library(pkg, character.only = TRUE)
[08:27:59.568]                       }
[08:27:59.568]                     })
[08:27:59.568]                   }
[08:27:59.568]                   ...future.strategy.old <- future::plan("list")
[08:27:59.568]                   options(future.plan = NULL)
[08:27:59.568]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:59.568]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:59.568]                 }
[08:27:59.568]                 ...future.workdir <- getwd()
[08:27:59.568]             }
[08:27:59.568]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:59.568]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:59.568]         }
[08:27:59.568]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:59.568]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:59.568]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:59.568]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:59.568]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:59.568]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:59.568]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:59.568]             base::names(...future.oldOptions))
[08:27:59.568]     }
[08:27:59.568]     if (FALSE) {
[08:27:59.568]     }
[08:27:59.568]     else {
[08:27:59.568]         if (TRUE) {
[08:27:59.568]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:59.568]                 open = "w")
[08:27:59.568]         }
[08:27:59.568]         else {
[08:27:59.568]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:59.568]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:59.568]         }
[08:27:59.568]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:59.568]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:59.568]             base::sink(type = "output", split = FALSE)
[08:27:59.568]             base::close(...future.stdout)
[08:27:59.568]         }, add = TRUE)
[08:27:59.568]     }
[08:27:59.568]     ...future.frame <- base::sys.nframe()
[08:27:59.568]     ...future.conditions <- base::list()
[08:27:59.568]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:59.568]     if (FALSE) {
[08:27:59.568]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:59.568]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:59.568]     }
[08:27:59.568]     ...future.result <- base::tryCatch({
[08:27:59.568]         base::withCallingHandlers({
[08:27:59.568]             ...future.value <- base::withVisible(base::local({
[08:27:59.568]                 ...future.makeSendCondition <- base::local({
[08:27:59.568]                   sendCondition <- NULL
[08:27:59.568]                   function(frame = 1L) {
[08:27:59.568]                     if (is.function(sendCondition)) 
[08:27:59.568]                       return(sendCondition)
[08:27:59.568]                     ns <- getNamespace("parallel")
[08:27:59.568]                     if (exists("sendData", mode = "function", 
[08:27:59.568]                       envir = ns)) {
[08:27:59.568]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:59.568]                         envir = ns)
[08:27:59.568]                       envir <- sys.frame(frame)
[08:27:59.568]                       master <- NULL
[08:27:59.568]                       while (!identical(envir, .GlobalEnv) && 
[08:27:59.568]                         !identical(envir, emptyenv())) {
[08:27:59.568]                         if (exists("master", mode = "list", envir = envir, 
[08:27:59.568]                           inherits = FALSE)) {
[08:27:59.568]                           master <- get("master", mode = "list", 
[08:27:59.568]                             envir = envir, inherits = FALSE)
[08:27:59.568]                           if (inherits(master, c("SOCKnode", 
[08:27:59.568]                             "SOCK0node"))) {
[08:27:59.568]                             sendCondition <<- function(cond) {
[08:27:59.568]                               data <- list(type = "VALUE", value = cond, 
[08:27:59.568]                                 success = TRUE)
[08:27:59.568]                               parallel_sendData(master, data)
[08:27:59.568]                             }
[08:27:59.568]                             return(sendCondition)
[08:27:59.568]                           }
[08:27:59.568]                         }
[08:27:59.568]                         frame <- frame + 1L
[08:27:59.568]                         envir <- sys.frame(frame)
[08:27:59.568]                       }
[08:27:59.568]                     }
[08:27:59.568]                     sendCondition <<- function(cond) NULL
[08:27:59.568]                   }
[08:27:59.568]                 })
[08:27:59.568]                 withCallingHandlers({
[08:27:59.568]                   {
[08:27:59.568]                     lm(dist ~ poly(speed, 2), data = cars)
[08:27:59.568]                   }
[08:27:59.568]                 }, immediateCondition = function(cond) {
[08:27:59.568]                   sendCondition <- ...future.makeSendCondition()
[08:27:59.568]                   sendCondition(cond)
[08:27:59.568]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.568]                   {
[08:27:59.568]                     inherits <- base::inherits
[08:27:59.568]                     invokeRestart <- base::invokeRestart
[08:27:59.568]                     is.null <- base::is.null
[08:27:59.568]                     muffled <- FALSE
[08:27:59.568]                     if (inherits(cond, "message")) {
[08:27:59.568]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:59.568]                       if (muffled) 
[08:27:59.568]                         invokeRestart("muffleMessage")
[08:27:59.568]                     }
[08:27:59.568]                     else if (inherits(cond, "warning")) {
[08:27:59.568]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:59.568]                       if (muffled) 
[08:27:59.568]                         invokeRestart("muffleWarning")
[08:27:59.568]                     }
[08:27:59.568]                     else if (inherits(cond, "condition")) {
[08:27:59.568]                       if (!is.null(pattern)) {
[08:27:59.568]                         computeRestarts <- base::computeRestarts
[08:27:59.568]                         grepl <- base::grepl
[08:27:59.568]                         restarts <- computeRestarts(cond)
[08:27:59.568]                         for (restart in restarts) {
[08:27:59.568]                           name <- restart$name
[08:27:59.568]                           if (is.null(name)) 
[08:27:59.568]                             next
[08:27:59.568]                           if (!grepl(pattern, name)) 
[08:27:59.568]                             next
[08:27:59.568]                           invokeRestart(restart)
[08:27:59.568]                           muffled <- TRUE
[08:27:59.568]                           break
[08:27:59.568]                         }
[08:27:59.568]                       }
[08:27:59.568]                     }
[08:27:59.568]                     invisible(muffled)
[08:27:59.568]                   }
[08:27:59.568]                   muffleCondition(cond)
[08:27:59.568]                 })
[08:27:59.568]             }))
[08:27:59.568]             future::FutureResult(value = ...future.value$value, 
[08:27:59.568]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:59.568]                   ...future.rng), globalenv = if (FALSE) 
[08:27:59.568]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:59.568]                     ...future.globalenv.names))
[08:27:59.568]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:59.568]         }, condition = base::local({
[08:27:59.568]             c <- base::c
[08:27:59.568]             inherits <- base::inherits
[08:27:59.568]             invokeRestart <- base::invokeRestart
[08:27:59.568]             length <- base::length
[08:27:59.568]             list <- base::list
[08:27:59.568]             seq.int <- base::seq.int
[08:27:59.568]             signalCondition <- base::signalCondition
[08:27:59.568]             sys.calls <- base::sys.calls
[08:27:59.568]             `[[` <- base::`[[`
[08:27:59.568]             `+` <- base::`+`
[08:27:59.568]             `<<-` <- base::`<<-`
[08:27:59.568]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:59.568]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:59.568]                   3L)]
[08:27:59.568]             }
[08:27:59.568]             function(cond) {
[08:27:59.568]                 is_error <- inherits(cond, "error")
[08:27:59.568]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:59.568]                   NULL)
[08:27:59.568]                 if (is_error) {
[08:27:59.568]                   sessionInformation <- function() {
[08:27:59.568]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:59.568]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:59.568]                       search = base::search(), system = base::Sys.info())
[08:27:59.568]                   }
[08:27:59.568]                   ...future.conditions[[length(...future.conditions) + 
[08:27:59.568]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:59.568]                     cond$call), session = sessionInformation(), 
[08:27:59.568]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:59.568]                   signalCondition(cond)
[08:27:59.568]                 }
[08:27:59.568]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:59.568]                 "immediateCondition"))) {
[08:27:59.568]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:59.568]                   ...future.conditions[[length(...future.conditions) + 
[08:27:59.568]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:59.568]                   if (TRUE && !signal) {
[08:27:59.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.568]                     {
[08:27:59.568]                       inherits <- base::inherits
[08:27:59.568]                       invokeRestart <- base::invokeRestart
[08:27:59.568]                       is.null <- base::is.null
[08:27:59.568]                       muffled <- FALSE
[08:27:59.568]                       if (inherits(cond, "message")) {
[08:27:59.568]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:59.568]                         if (muffled) 
[08:27:59.568]                           invokeRestart("muffleMessage")
[08:27:59.568]                       }
[08:27:59.568]                       else if (inherits(cond, "warning")) {
[08:27:59.568]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:59.568]                         if (muffled) 
[08:27:59.568]                           invokeRestart("muffleWarning")
[08:27:59.568]                       }
[08:27:59.568]                       else if (inherits(cond, "condition")) {
[08:27:59.568]                         if (!is.null(pattern)) {
[08:27:59.568]                           computeRestarts <- base::computeRestarts
[08:27:59.568]                           grepl <- base::grepl
[08:27:59.568]                           restarts <- computeRestarts(cond)
[08:27:59.568]                           for (restart in restarts) {
[08:27:59.568]                             name <- restart$name
[08:27:59.568]                             if (is.null(name)) 
[08:27:59.568]                               next
[08:27:59.568]                             if (!grepl(pattern, name)) 
[08:27:59.568]                               next
[08:27:59.568]                             invokeRestart(restart)
[08:27:59.568]                             muffled <- TRUE
[08:27:59.568]                             break
[08:27:59.568]                           }
[08:27:59.568]                         }
[08:27:59.568]                       }
[08:27:59.568]                       invisible(muffled)
[08:27:59.568]                     }
[08:27:59.568]                     muffleCondition(cond, pattern = "^muffle")
[08:27:59.568]                   }
[08:27:59.568]                 }
[08:27:59.568]                 else {
[08:27:59.568]                   if (TRUE) {
[08:27:59.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.568]                     {
[08:27:59.568]                       inherits <- base::inherits
[08:27:59.568]                       invokeRestart <- base::invokeRestart
[08:27:59.568]                       is.null <- base::is.null
[08:27:59.568]                       muffled <- FALSE
[08:27:59.568]                       if (inherits(cond, "message")) {
[08:27:59.568]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:59.568]                         if (muffled) 
[08:27:59.568]                           invokeRestart("muffleMessage")
[08:27:59.568]                       }
[08:27:59.568]                       else if (inherits(cond, "warning")) {
[08:27:59.568]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:59.568]                         if (muffled) 
[08:27:59.568]                           invokeRestart("muffleWarning")
[08:27:59.568]                       }
[08:27:59.568]                       else if (inherits(cond, "condition")) {
[08:27:59.568]                         if (!is.null(pattern)) {
[08:27:59.568]                           computeRestarts <- base::computeRestarts
[08:27:59.568]                           grepl <- base::grepl
[08:27:59.568]                           restarts <- computeRestarts(cond)
[08:27:59.568]                           for (restart in restarts) {
[08:27:59.568]                             name <- restart$name
[08:27:59.568]                             if (is.null(name)) 
[08:27:59.568]                               next
[08:27:59.568]                             if (!grepl(pattern, name)) 
[08:27:59.568]                               next
[08:27:59.568]                             invokeRestart(restart)
[08:27:59.568]                             muffled <- TRUE
[08:27:59.568]                             break
[08:27:59.568]                           }
[08:27:59.568]                         }
[08:27:59.568]                       }
[08:27:59.568]                       invisible(muffled)
[08:27:59.568]                     }
[08:27:59.568]                     muffleCondition(cond, pattern = "^muffle")
[08:27:59.568]                   }
[08:27:59.568]                 }
[08:27:59.568]             }
[08:27:59.568]         }))
[08:27:59.568]     }, error = function(ex) {
[08:27:59.568]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:59.568]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:59.568]                 ...future.rng), started = ...future.startTime, 
[08:27:59.568]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:59.568]             version = "1.8"), class = "FutureResult")
[08:27:59.568]     }, finally = {
[08:27:59.568]         if (!identical(...future.workdir, getwd())) 
[08:27:59.568]             setwd(...future.workdir)
[08:27:59.568]         {
[08:27:59.568]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:59.568]                 ...future.oldOptions$nwarnings <- NULL
[08:27:59.568]             }
[08:27:59.568]             base::options(...future.oldOptions)
[08:27:59.568]             if (.Platform$OS.type == "windows") {
[08:27:59.568]                 old_names <- names(...future.oldEnvVars)
[08:27:59.568]                 envs <- base::Sys.getenv()
[08:27:59.568]                 names <- names(envs)
[08:27:59.568]                 common <- intersect(names, old_names)
[08:27:59.568]                 added <- setdiff(names, old_names)
[08:27:59.568]                 removed <- setdiff(old_names, names)
[08:27:59.568]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:59.568]                   envs[common]]
[08:27:59.568]                 NAMES <- toupper(changed)
[08:27:59.568]                 args <- list()
[08:27:59.568]                 for (kk in seq_along(NAMES)) {
[08:27:59.568]                   name <- changed[[kk]]
[08:27:59.568]                   NAME <- NAMES[[kk]]
[08:27:59.568]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.568]                     next
[08:27:59.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:59.568]                 }
[08:27:59.568]                 NAMES <- toupper(added)
[08:27:59.568]                 for (kk in seq_along(NAMES)) {
[08:27:59.568]                   name <- added[[kk]]
[08:27:59.568]                   NAME <- NAMES[[kk]]
[08:27:59.568]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.568]                     next
[08:27:59.568]                   args[[name]] <- ""
[08:27:59.568]                 }
[08:27:59.568]                 NAMES <- toupper(removed)
[08:27:59.568]                 for (kk in seq_along(NAMES)) {
[08:27:59.568]                   name <- removed[[kk]]
[08:27:59.568]                   NAME <- NAMES[[kk]]
[08:27:59.568]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.568]                     next
[08:27:59.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:59.568]                 }
[08:27:59.568]                 if (length(args) > 0) 
[08:27:59.568]                   base::do.call(base::Sys.setenv, args = args)
[08:27:59.568]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:59.568]             }
[08:27:59.568]             else {
[08:27:59.568]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:59.568]             }
[08:27:59.568]             {
[08:27:59.568]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:59.568]                   0L) {
[08:27:59.568]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:59.568]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:59.568]                   base::options(opts)
[08:27:59.568]                 }
[08:27:59.568]                 {
[08:27:59.568]                   {
[08:27:59.568]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:59.568]                     NULL
[08:27:59.568]                   }
[08:27:59.568]                   options(future.plan = NULL)
[08:27:59.568]                   if (is.na(NA_character_)) 
[08:27:59.568]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:59.568]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:59.568]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:59.568]                     .init = FALSE)
[08:27:59.568]                 }
[08:27:59.568]             }
[08:27:59.568]         }
[08:27:59.568]     })
[08:27:59.568]     if (TRUE) {
[08:27:59.568]         base::sink(type = "output", split = FALSE)
[08:27:59.568]         if (TRUE) {
[08:27:59.568]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:59.568]         }
[08:27:59.568]         else {
[08:27:59.568]             ...future.result["stdout"] <- base::list(NULL)
[08:27:59.568]         }
[08:27:59.568]         base::close(...future.stdout)
[08:27:59.568]         ...future.stdout <- NULL
[08:27:59.568]     }
[08:27:59.568]     ...future.result$conditions <- ...future.conditions
[08:27:59.568]     ...future.result$finished <- base::Sys.time()
[08:27:59.568]     ...future.result
[08:27:59.568] }
[08:27:59.571] MultisessionFuture started
[08:27:59.571] - Launch lazy future ... done
[08:27:59.571] run() for ‘MultisessionFuture’ ... done
[08:27:59.572] result() for ClusterFuture ...
[08:27:59.572] receiveMessageFromWorker() for ClusterFuture ...
[08:27:59.572] - Validating connection of MultisessionFuture
[08:27:59.615] - received message: FutureResult
[08:27:59.615] - Received FutureResult
[08:27:59.615] - Erased future from FutureRegistry
[08:27:59.615] result() for ClusterFuture ...
[08:27:59.615] - result already collected: FutureResult
[08:27:59.615] result() for ClusterFuture ... done
[08:27:59.615] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:59.615] result() for ClusterFuture ... done
[08:27:59.615] result() for ClusterFuture ...
[08:27:59.616] - result already collected: FutureResult
[08:27:59.616] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[08:27:59.617] getGlobalsAndPackages() ...
[08:27:59.617] Searching for globals...
[08:27:59.621] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[08:27:59.621] Searching for globals ... DONE
[08:27:59.622] Resolving globals: FALSE
[08:27:59.622] The total size of the 3 globals is 1.22 KiB (1254 bytes)
[08:27:59.623] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (633 bytes of class ‘function’), ‘inner_function’ (371 bytes of class ‘function’) and ‘outer_function’ (250 bytes of class ‘function’)
[08:27:59.623] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[08:27:59.623] 
[08:27:59.623] getGlobalsAndPackages() ... DONE
[08:27:59.623] run() for ‘Future’ ...
[08:27:59.623] - state: ‘created’
[08:27:59.623] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:59.637] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:59.637] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:59.637]   - Field: ‘node’
[08:27:59.637]   - Field: ‘label’
[08:27:59.637]   - Field: ‘local’
[08:27:59.637]   - Field: ‘owner’
[08:27:59.637]   - Field: ‘envir’
[08:27:59.638]   - Field: ‘workers’
[08:27:59.638]   - Field: ‘packages’
[08:27:59.638]   - Field: ‘gc’
[08:27:59.638]   - Field: ‘conditions’
[08:27:59.638]   - Field: ‘persistent’
[08:27:59.638]   - Field: ‘expr’
[08:27:59.638]   - Field: ‘uuid’
[08:27:59.638]   - Field: ‘seed’
[08:27:59.638]   - Field: ‘version’
[08:27:59.638]   - Field: ‘result’
[08:27:59.638]   - Field: ‘asynchronous’
[08:27:59.638]   - Field: ‘calls’
[08:27:59.639]   - Field: ‘globals’
[08:27:59.639]   - Field: ‘stdout’
[08:27:59.639]   - Field: ‘earlySignal’
[08:27:59.639]   - Field: ‘lazy’
[08:27:59.639]   - Field: ‘state’
[08:27:59.639] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:59.639] - Launch lazy future ...
[08:27:59.639] Packages needed by the future expression (n = 0): <none>
[08:27:59.639] Packages needed by future strategies (n = 0): <none>
[08:27:59.640] {
[08:27:59.640]     {
[08:27:59.640]         {
[08:27:59.640]             ...future.startTime <- base::Sys.time()
[08:27:59.640]             {
[08:27:59.640]                 {
[08:27:59.640]                   {
[08:27:59.640]                     {
[08:27:59.640]                       base::local({
[08:27:59.640]                         has_future <- base::requireNamespace("future", 
[08:27:59.640]                           quietly = TRUE)
[08:27:59.640]                         if (has_future) {
[08:27:59.640]                           ns <- base::getNamespace("future")
[08:27:59.640]                           version <- ns[[".package"]][["version"]]
[08:27:59.640]                           if (is.null(version)) 
[08:27:59.640]                             version <- utils::packageVersion("future")
[08:27:59.640]                         }
[08:27:59.640]                         else {
[08:27:59.640]                           version <- NULL
[08:27:59.640]                         }
[08:27:59.640]                         if (!has_future || version < "1.8.0") {
[08:27:59.640]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:59.640]                             "", base::R.version$version.string), 
[08:27:59.640]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:59.640]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:59.640]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:59.640]                               "release", "version")], collapse = " "), 
[08:27:59.640]                             hostname = base::Sys.info()[["nodename"]])
[08:27:59.640]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:59.640]                             info)
[08:27:59.640]                           info <- base::paste(info, collapse = "; ")
[08:27:59.640]                           if (!has_future) {
[08:27:59.640]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:59.640]                               info)
[08:27:59.640]                           }
[08:27:59.640]                           else {
[08:27:59.640]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:59.640]                               info, version)
[08:27:59.640]                           }
[08:27:59.640]                           base::stop(msg)
[08:27:59.640]                         }
[08:27:59.640]                       })
[08:27:59.640]                     }
[08:27:59.640]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:59.640]                     base::options(mc.cores = 1L)
[08:27:59.640]                   }
[08:27:59.640]                   ...future.strategy.old <- future::plan("list")
[08:27:59.640]                   options(future.plan = NULL)
[08:27:59.640]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:59.640]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:59.640]                 }
[08:27:59.640]                 ...future.workdir <- getwd()
[08:27:59.640]             }
[08:27:59.640]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:59.640]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:59.640]         }
[08:27:59.640]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:59.640]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:59.640]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:59.640]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:59.640]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:59.640]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:59.640]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:59.640]             base::names(...future.oldOptions))
[08:27:59.640]     }
[08:27:59.640]     if (FALSE) {
[08:27:59.640]     }
[08:27:59.640]     else {
[08:27:59.640]         if (TRUE) {
[08:27:59.640]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:59.640]                 open = "w")
[08:27:59.640]         }
[08:27:59.640]         else {
[08:27:59.640]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:59.640]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:59.640]         }
[08:27:59.640]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:59.640]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:59.640]             base::sink(type = "output", split = FALSE)
[08:27:59.640]             base::close(...future.stdout)
[08:27:59.640]         }, add = TRUE)
[08:27:59.640]     }
[08:27:59.640]     ...future.frame <- base::sys.nframe()
[08:27:59.640]     ...future.conditions <- base::list()
[08:27:59.640]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:59.640]     if (FALSE) {
[08:27:59.640]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:59.640]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:59.640]     }
[08:27:59.640]     ...future.result <- base::tryCatch({
[08:27:59.640]         base::withCallingHandlers({
[08:27:59.640]             ...future.value <- base::withVisible(base::local({
[08:27:59.640]                 ...future.makeSendCondition <- base::local({
[08:27:59.640]                   sendCondition <- NULL
[08:27:59.640]                   function(frame = 1L) {
[08:27:59.640]                     if (is.function(sendCondition)) 
[08:27:59.640]                       return(sendCondition)
[08:27:59.640]                     ns <- getNamespace("parallel")
[08:27:59.640]                     if (exists("sendData", mode = "function", 
[08:27:59.640]                       envir = ns)) {
[08:27:59.640]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:59.640]                         envir = ns)
[08:27:59.640]                       envir <- sys.frame(frame)
[08:27:59.640]                       master <- NULL
[08:27:59.640]                       while (!identical(envir, .GlobalEnv) && 
[08:27:59.640]                         !identical(envir, emptyenv())) {
[08:27:59.640]                         if (exists("master", mode = "list", envir = envir, 
[08:27:59.640]                           inherits = FALSE)) {
[08:27:59.640]                           master <- get("master", mode = "list", 
[08:27:59.640]                             envir = envir, inherits = FALSE)
[08:27:59.640]                           if (inherits(master, c("SOCKnode", 
[08:27:59.640]                             "SOCK0node"))) {
[08:27:59.640]                             sendCondition <<- function(cond) {
[08:27:59.640]                               data <- list(type = "VALUE", value = cond, 
[08:27:59.640]                                 success = TRUE)
[08:27:59.640]                               parallel_sendData(master, data)
[08:27:59.640]                             }
[08:27:59.640]                             return(sendCondition)
[08:27:59.640]                           }
[08:27:59.640]                         }
[08:27:59.640]                         frame <- frame + 1L
[08:27:59.640]                         envir <- sys.frame(frame)
[08:27:59.640]                       }
[08:27:59.640]                     }
[08:27:59.640]                     sendCondition <<- function(cond) NULL
[08:27:59.640]                   }
[08:27:59.640]                 })
[08:27:59.640]                 withCallingHandlers({
[08:27:59.640]                   {
[08:27:59.640]                     outer_function(1L)
[08:27:59.640]                   }
[08:27:59.640]                 }, immediateCondition = function(cond) {
[08:27:59.640]                   sendCondition <- ...future.makeSendCondition()
[08:27:59.640]                   sendCondition(cond)
[08:27:59.640]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.640]                   {
[08:27:59.640]                     inherits <- base::inherits
[08:27:59.640]                     invokeRestart <- base::invokeRestart
[08:27:59.640]                     is.null <- base::is.null
[08:27:59.640]                     muffled <- FALSE
[08:27:59.640]                     if (inherits(cond, "message")) {
[08:27:59.640]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:59.640]                       if (muffled) 
[08:27:59.640]                         invokeRestart("muffleMessage")
[08:27:59.640]                     }
[08:27:59.640]                     else if (inherits(cond, "warning")) {
[08:27:59.640]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:59.640]                       if (muffled) 
[08:27:59.640]                         invokeRestart("muffleWarning")
[08:27:59.640]                     }
[08:27:59.640]                     else if (inherits(cond, "condition")) {
[08:27:59.640]                       if (!is.null(pattern)) {
[08:27:59.640]                         computeRestarts <- base::computeRestarts
[08:27:59.640]                         grepl <- base::grepl
[08:27:59.640]                         restarts <- computeRestarts(cond)
[08:27:59.640]                         for (restart in restarts) {
[08:27:59.640]                           name <- restart$name
[08:27:59.640]                           if (is.null(name)) 
[08:27:59.640]                             next
[08:27:59.640]                           if (!grepl(pattern, name)) 
[08:27:59.640]                             next
[08:27:59.640]                           invokeRestart(restart)
[08:27:59.640]                           muffled <- TRUE
[08:27:59.640]                           break
[08:27:59.640]                         }
[08:27:59.640]                       }
[08:27:59.640]                     }
[08:27:59.640]                     invisible(muffled)
[08:27:59.640]                   }
[08:27:59.640]                   muffleCondition(cond)
[08:27:59.640]                 })
[08:27:59.640]             }))
[08:27:59.640]             future::FutureResult(value = ...future.value$value, 
[08:27:59.640]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:59.640]                   ...future.rng), globalenv = if (FALSE) 
[08:27:59.640]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:59.640]                     ...future.globalenv.names))
[08:27:59.640]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:59.640]         }, condition = base::local({
[08:27:59.640]             c <- base::c
[08:27:59.640]             inherits <- base::inherits
[08:27:59.640]             invokeRestart <- base::invokeRestart
[08:27:59.640]             length <- base::length
[08:27:59.640]             list <- base::list
[08:27:59.640]             seq.int <- base::seq.int
[08:27:59.640]             signalCondition <- base::signalCondition
[08:27:59.640]             sys.calls <- base::sys.calls
[08:27:59.640]             `[[` <- base::`[[`
[08:27:59.640]             `+` <- base::`+`
[08:27:59.640]             `<<-` <- base::`<<-`
[08:27:59.640]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:59.640]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:59.640]                   3L)]
[08:27:59.640]             }
[08:27:59.640]             function(cond) {
[08:27:59.640]                 is_error <- inherits(cond, "error")
[08:27:59.640]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:59.640]                   NULL)
[08:27:59.640]                 if (is_error) {
[08:27:59.640]                   sessionInformation <- function() {
[08:27:59.640]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:59.640]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:59.640]                       search = base::search(), system = base::Sys.info())
[08:27:59.640]                   }
[08:27:59.640]                   ...future.conditions[[length(...future.conditions) + 
[08:27:59.640]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:59.640]                     cond$call), session = sessionInformation(), 
[08:27:59.640]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:59.640]                   signalCondition(cond)
[08:27:59.640]                 }
[08:27:59.640]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:59.640]                 "immediateCondition"))) {
[08:27:59.640]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:59.640]                   ...future.conditions[[length(...future.conditions) + 
[08:27:59.640]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:59.640]                   if (TRUE && !signal) {
[08:27:59.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.640]                     {
[08:27:59.640]                       inherits <- base::inherits
[08:27:59.640]                       invokeRestart <- base::invokeRestart
[08:27:59.640]                       is.null <- base::is.null
[08:27:59.640]                       muffled <- FALSE
[08:27:59.640]                       if (inherits(cond, "message")) {
[08:27:59.640]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:59.640]                         if (muffled) 
[08:27:59.640]                           invokeRestart("muffleMessage")
[08:27:59.640]                       }
[08:27:59.640]                       else if (inherits(cond, "warning")) {
[08:27:59.640]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:59.640]                         if (muffled) 
[08:27:59.640]                           invokeRestart("muffleWarning")
[08:27:59.640]                       }
[08:27:59.640]                       else if (inherits(cond, "condition")) {
[08:27:59.640]                         if (!is.null(pattern)) {
[08:27:59.640]                           computeRestarts <- base::computeRestarts
[08:27:59.640]                           grepl <- base::grepl
[08:27:59.640]                           restarts <- computeRestarts(cond)
[08:27:59.640]                           for (restart in restarts) {
[08:27:59.640]                             name <- restart$name
[08:27:59.640]                             if (is.null(name)) 
[08:27:59.640]                               next
[08:27:59.640]                             if (!grepl(pattern, name)) 
[08:27:59.640]                               next
[08:27:59.640]                             invokeRestart(restart)
[08:27:59.640]                             muffled <- TRUE
[08:27:59.640]                             break
[08:27:59.640]                           }
[08:27:59.640]                         }
[08:27:59.640]                       }
[08:27:59.640]                       invisible(muffled)
[08:27:59.640]                     }
[08:27:59.640]                     muffleCondition(cond, pattern = "^muffle")
[08:27:59.640]                   }
[08:27:59.640]                 }
[08:27:59.640]                 else {
[08:27:59.640]                   if (TRUE) {
[08:27:59.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.640]                     {
[08:27:59.640]                       inherits <- base::inherits
[08:27:59.640]                       invokeRestart <- base::invokeRestart
[08:27:59.640]                       is.null <- base::is.null
[08:27:59.640]                       muffled <- FALSE
[08:27:59.640]                       if (inherits(cond, "message")) {
[08:27:59.640]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:59.640]                         if (muffled) 
[08:27:59.640]                           invokeRestart("muffleMessage")
[08:27:59.640]                       }
[08:27:59.640]                       else if (inherits(cond, "warning")) {
[08:27:59.640]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:59.640]                         if (muffled) 
[08:27:59.640]                           invokeRestart("muffleWarning")
[08:27:59.640]                       }
[08:27:59.640]                       else if (inherits(cond, "condition")) {
[08:27:59.640]                         if (!is.null(pattern)) {
[08:27:59.640]                           computeRestarts <- base::computeRestarts
[08:27:59.640]                           grepl <- base::grepl
[08:27:59.640]                           restarts <- computeRestarts(cond)
[08:27:59.640]                           for (restart in restarts) {
[08:27:59.640]                             name <- restart$name
[08:27:59.640]                             if (is.null(name)) 
[08:27:59.640]                               next
[08:27:59.640]                             if (!grepl(pattern, name)) 
[08:27:59.640]                               next
[08:27:59.640]                             invokeRestart(restart)
[08:27:59.640]                             muffled <- TRUE
[08:27:59.640]                             break
[08:27:59.640]                           }
[08:27:59.640]                         }
[08:27:59.640]                       }
[08:27:59.640]                       invisible(muffled)
[08:27:59.640]                     }
[08:27:59.640]                     muffleCondition(cond, pattern = "^muffle")
[08:27:59.640]                   }
[08:27:59.640]                 }
[08:27:59.640]             }
[08:27:59.640]         }))
[08:27:59.640]     }, error = function(ex) {
[08:27:59.640]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:59.640]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:59.640]                 ...future.rng), started = ...future.startTime, 
[08:27:59.640]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:59.640]             version = "1.8"), class = "FutureResult")
[08:27:59.640]     }, finally = {
[08:27:59.640]         if (!identical(...future.workdir, getwd())) 
[08:27:59.640]             setwd(...future.workdir)
[08:27:59.640]         {
[08:27:59.640]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:59.640]                 ...future.oldOptions$nwarnings <- NULL
[08:27:59.640]             }
[08:27:59.640]             base::options(...future.oldOptions)
[08:27:59.640]             if (.Platform$OS.type == "windows") {
[08:27:59.640]                 old_names <- names(...future.oldEnvVars)
[08:27:59.640]                 envs <- base::Sys.getenv()
[08:27:59.640]                 names <- names(envs)
[08:27:59.640]                 common <- intersect(names, old_names)
[08:27:59.640]                 added <- setdiff(names, old_names)
[08:27:59.640]                 removed <- setdiff(old_names, names)
[08:27:59.640]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:59.640]                   envs[common]]
[08:27:59.640]                 NAMES <- toupper(changed)
[08:27:59.640]                 args <- list()
[08:27:59.640]                 for (kk in seq_along(NAMES)) {
[08:27:59.640]                   name <- changed[[kk]]
[08:27:59.640]                   NAME <- NAMES[[kk]]
[08:27:59.640]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.640]                     next
[08:27:59.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:59.640]                 }
[08:27:59.640]                 NAMES <- toupper(added)
[08:27:59.640]                 for (kk in seq_along(NAMES)) {
[08:27:59.640]                   name <- added[[kk]]
[08:27:59.640]                   NAME <- NAMES[[kk]]
[08:27:59.640]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.640]                     next
[08:27:59.640]                   args[[name]] <- ""
[08:27:59.640]                 }
[08:27:59.640]                 NAMES <- toupper(removed)
[08:27:59.640]                 for (kk in seq_along(NAMES)) {
[08:27:59.640]                   name <- removed[[kk]]
[08:27:59.640]                   NAME <- NAMES[[kk]]
[08:27:59.640]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.640]                     next
[08:27:59.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:59.640]                 }
[08:27:59.640]                 if (length(args) > 0) 
[08:27:59.640]                   base::do.call(base::Sys.setenv, args = args)
[08:27:59.640]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:59.640]             }
[08:27:59.640]             else {
[08:27:59.640]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:59.640]             }
[08:27:59.640]             {
[08:27:59.640]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:59.640]                   0L) {
[08:27:59.640]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:59.640]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:59.640]                   base::options(opts)
[08:27:59.640]                 }
[08:27:59.640]                 {
[08:27:59.640]                   {
[08:27:59.640]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:59.640]                     NULL
[08:27:59.640]                   }
[08:27:59.640]                   options(future.plan = NULL)
[08:27:59.640]                   if (is.na(NA_character_)) 
[08:27:59.640]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:59.640]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:59.640]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:59.640]                     .init = FALSE)
[08:27:59.640]                 }
[08:27:59.640]             }
[08:27:59.640]         }
[08:27:59.640]     })
[08:27:59.640]     if (TRUE) {
[08:27:59.640]         base::sink(type = "output", split = FALSE)
[08:27:59.640]         if (TRUE) {
[08:27:59.640]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:59.640]         }
[08:27:59.640]         else {
[08:27:59.640]             ...future.result["stdout"] <- base::list(NULL)
[08:27:59.640]         }
[08:27:59.640]         base::close(...future.stdout)
[08:27:59.640]         ...future.stdout <- NULL
[08:27:59.640]     }
[08:27:59.640]     ...future.result$conditions <- ...future.conditions
[08:27:59.640]     ...future.result$finished <- base::Sys.time()
[08:27:59.640]     ...future.result
[08:27:59.640] }
[08:27:59.642] Exporting 3 global objects (1.53 KiB) to cluster node #1 ...
[08:27:59.642] Exporting ‘outer_function’ (250 bytes) to cluster node #1 ...
[08:27:59.643] Exporting ‘outer_function’ (250 bytes) to cluster node #1 ... DONE
[08:27:59.643] Exporting ‘map’ (633 bytes) to cluster node #1 ...
[08:27:59.643] Exporting ‘map’ (633 bytes) to cluster node #1 ... DONE
[08:27:59.644] Exporting ‘inner_function’ (371 bytes) to cluster node #1 ...
[08:27:59.644] Exporting ‘inner_function’ (371 bytes) to cluster node #1 ... DONE
[08:27:59.644] Exporting 3 global objects (1.53 KiB) to cluster node #1 ... DONE
[08:27:59.644] MultisessionFuture started
[08:27:59.645] - Launch lazy future ... done
[08:27:59.645] run() for ‘MultisessionFuture’ ... done
[08:27:59.645] result() for ClusterFuture ...
[08:27:59.645] receiveMessageFromWorker() for ClusterFuture ...
[08:27:59.645] - Validating connection of MultisessionFuture
[08:27:59.691] - received message: FutureResult
[08:27:59.691] - Received FutureResult
[08:27:59.691] - Erased future from FutureRegistry
[08:27:59.691] result() for ClusterFuture ...
[08:27:59.691] - result already collected: FutureResult
[08:27:59.692] result() for ClusterFuture ... done
[08:27:59.692] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:59.692] result() for ClusterFuture ... done
[08:27:59.692] result() for ClusterFuture ...
[08:27:59.692] - result already collected: FutureResult
[08:27:59.692] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[08:27:59.693] getGlobalsAndPackages() ...
[08:27:59.693] Searching for globals...
[08:27:59.697] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[08:27:59.697] Searching for globals ... DONE
[08:27:59.697] Resolving globals: FALSE
[08:27:59.698] The total size of the 3 globals is 1.22 KiB (1254 bytes)
[08:27:59.698] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (633 bytes of class ‘function’), ‘inner_function’ (371 bytes of class ‘function’) and ‘outer_function’ (250 bytes of class ‘function’)
[08:27:59.698] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[08:27:59.699] 
[08:27:59.699] getGlobalsAndPackages() ... DONE
[08:27:59.699] run() for ‘Future’ ...
[08:27:59.699] - state: ‘created’
[08:27:59.699] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:59.713] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:59.713] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:59.713]   - Field: ‘node’
[08:27:59.713]   - Field: ‘label’
[08:27:59.713]   - Field: ‘local’
[08:27:59.713]   - Field: ‘owner’
[08:27:59.713]   - Field: ‘envir’
[08:27:59.713]   - Field: ‘workers’
[08:27:59.713]   - Field: ‘packages’
[08:27:59.713]   - Field: ‘gc’
[08:27:59.714]   - Field: ‘conditions’
[08:27:59.714]   - Field: ‘persistent’
[08:27:59.714]   - Field: ‘expr’
[08:27:59.714]   - Field: ‘uuid’
[08:27:59.714]   - Field: ‘seed’
[08:27:59.714]   - Field: ‘version’
[08:27:59.714]   - Field: ‘result’
[08:27:59.714]   - Field: ‘asynchronous’
[08:27:59.714]   - Field: ‘calls’
[08:27:59.714]   - Field: ‘globals’
[08:27:59.714]   - Field: ‘stdout’
[08:27:59.714]   - Field: ‘earlySignal’
[08:27:59.715]   - Field: ‘lazy’
[08:27:59.715]   - Field: ‘state’
[08:27:59.715] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:59.715] - Launch lazy future ...
[08:27:59.715] Packages needed by the future expression (n = 0): <none>
[08:27:59.715] Packages needed by future strategies (n = 0): <none>
[08:27:59.716] {
[08:27:59.716]     {
[08:27:59.716]         {
[08:27:59.716]             ...future.startTime <- base::Sys.time()
[08:27:59.716]             {
[08:27:59.716]                 {
[08:27:59.716]                   {
[08:27:59.716]                     {
[08:27:59.716]                       base::local({
[08:27:59.716]                         has_future <- base::requireNamespace("future", 
[08:27:59.716]                           quietly = TRUE)
[08:27:59.716]                         if (has_future) {
[08:27:59.716]                           ns <- base::getNamespace("future")
[08:27:59.716]                           version <- ns[[".package"]][["version"]]
[08:27:59.716]                           if (is.null(version)) 
[08:27:59.716]                             version <- utils::packageVersion("future")
[08:27:59.716]                         }
[08:27:59.716]                         else {
[08:27:59.716]                           version <- NULL
[08:27:59.716]                         }
[08:27:59.716]                         if (!has_future || version < "1.8.0") {
[08:27:59.716]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:59.716]                             "", base::R.version$version.string), 
[08:27:59.716]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:59.716]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:59.716]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:59.716]                               "release", "version")], collapse = " "), 
[08:27:59.716]                             hostname = base::Sys.info()[["nodename"]])
[08:27:59.716]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:59.716]                             info)
[08:27:59.716]                           info <- base::paste(info, collapse = "; ")
[08:27:59.716]                           if (!has_future) {
[08:27:59.716]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:59.716]                               info)
[08:27:59.716]                           }
[08:27:59.716]                           else {
[08:27:59.716]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:59.716]                               info, version)
[08:27:59.716]                           }
[08:27:59.716]                           base::stop(msg)
[08:27:59.716]                         }
[08:27:59.716]                       })
[08:27:59.716]                     }
[08:27:59.716]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:59.716]                     base::options(mc.cores = 1L)
[08:27:59.716]                   }
[08:27:59.716]                   ...future.strategy.old <- future::plan("list")
[08:27:59.716]                   options(future.plan = NULL)
[08:27:59.716]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:59.716]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:59.716]                 }
[08:27:59.716]                 ...future.workdir <- getwd()
[08:27:59.716]             }
[08:27:59.716]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:59.716]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:59.716]         }
[08:27:59.716]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:59.716]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:59.716]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:59.716]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:59.716]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:59.716]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:59.716]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:59.716]             base::names(...future.oldOptions))
[08:27:59.716]     }
[08:27:59.716]     if (FALSE) {
[08:27:59.716]     }
[08:27:59.716]     else {
[08:27:59.716]         if (TRUE) {
[08:27:59.716]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:59.716]                 open = "w")
[08:27:59.716]         }
[08:27:59.716]         else {
[08:27:59.716]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:59.716]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:59.716]         }
[08:27:59.716]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:59.716]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:59.716]             base::sink(type = "output", split = FALSE)
[08:27:59.716]             base::close(...future.stdout)
[08:27:59.716]         }, add = TRUE)
[08:27:59.716]     }
[08:27:59.716]     ...future.frame <- base::sys.nframe()
[08:27:59.716]     ...future.conditions <- base::list()
[08:27:59.716]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:59.716]     if (FALSE) {
[08:27:59.716]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:59.716]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:59.716]     }
[08:27:59.716]     ...future.result <- base::tryCatch({
[08:27:59.716]         base::withCallingHandlers({
[08:27:59.716]             ...future.value <- base::withVisible(base::local({
[08:27:59.716]                 ...future.makeSendCondition <- base::local({
[08:27:59.716]                   sendCondition <- NULL
[08:27:59.716]                   function(frame = 1L) {
[08:27:59.716]                     if (is.function(sendCondition)) 
[08:27:59.716]                       return(sendCondition)
[08:27:59.716]                     ns <- getNamespace("parallel")
[08:27:59.716]                     if (exists("sendData", mode = "function", 
[08:27:59.716]                       envir = ns)) {
[08:27:59.716]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:59.716]                         envir = ns)
[08:27:59.716]                       envir <- sys.frame(frame)
[08:27:59.716]                       master <- NULL
[08:27:59.716]                       while (!identical(envir, .GlobalEnv) && 
[08:27:59.716]                         !identical(envir, emptyenv())) {
[08:27:59.716]                         if (exists("master", mode = "list", envir = envir, 
[08:27:59.716]                           inherits = FALSE)) {
[08:27:59.716]                           master <- get("master", mode = "list", 
[08:27:59.716]                             envir = envir, inherits = FALSE)
[08:27:59.716]                           if (inherits(master, c("SOCKnode", 
[08:27:59.716]                             "SOCK0node"))) {
[08:27:59.716]                             sendCondition <<- function(cond) {
[08:27:59.716]                               data <- list(type = "VALUE", value = cond, 
[08:27:59.716]                                 success = TRUE)
[08:27:59.716]                               parallel_sendData(master, data)
[08:27:59.716]                             }
[08:27:59.716]                             return(sendCondition)
[08:27:59.716]                           }
[08:27:59.716]                         }
[08:27:59.716]                         frame <- frame + 1L
[08:27:59.716]                         envir <- sys.frame(frame)
[08:27:59.716]                       }
[08:27:59.716]                     }
[08:27:59.716]                     sendCondition <<- function(cond) NULL
[08:27:59.716]                   }
[08:27:59.716]                 })
[08:27:59.716]                 withCallingHandlers({
[08:27:59.716]                   {
[08:27:59.716]                     outer_function(1L)
[08:27:59.716]                   }
[08:27:59.716]                 }, immediateCondition = function(cond) {
[08:27:59.716]                   sendCondition <- ...future.makeSendCondition()
[08:27:59.716]                   sendCondition(cond)
[08:27:59.716]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.716]                   {
[08:27:59.716]                     inherits <- base::inherits
[08:27:59.716]                     invokeRestart <- base::invokeRestart
[08:27:59.716]                     is.null <- base::is.null
[08:27:59.716]                     muffled <- FALSE
[08:27:59.716]                     if (inherits(cond, "message")) {
[08:27:59.716]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:59.716]                       if (muffled) 
[08:27:59.716]                         invokeRestart("muffleMessage")
[08:27:59.716]                     }
[08:27:59.716]                     else if (inherits(cond, "warning")) {
[08:27:59.716]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:59.716]                       if (muffled) 
[08:27:59.716]                         invokeRestart("muffleWarning")
[08:27:59.716]                     }
[08:27:59.716]                     else if (inherits(cond, "condition")) {
[08:27:59.716]                       if (!is.null(pattern)) {
[08:27:59.716]                         computeRestarts <- base::computeRestarts
[08:27:59.716]                         grepl <- base::grepl
[08:27:59.716]                         restarts <- computeRestarts(cond)
[08:27:59.716]                         for (restart in restarts) {
[08:27:59.716]                           name <- restart$name
[08:27:59.716]                           if (is.null(name)) 
[08:27:59.716]                             next
[08:27:59.716]                           if (!grepl(pattern, name)) 
[08:27:59.716]                             next
[08:27:59.716]                           invokeRestart(restart)
[08:27:59.716]                           muffled <- TRUE
[08:27:59.716]                           break
[08:27:59.716]                         }
[08:27:59.716]                       }
[08:27:59.716]                     }
[08:27:59.716]                     invisible(muffled)
[08:27:59.716]                   }
[08:27:59.716]                   muffleCondition(cond)
[08:27:59.716]                 })
[08:27:59.716]             }))
[08:27:59.716]             future::FutureResult(value = ...future.value$value, 
[08:27:59.716]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:59.716]                   ...future.rng), globalenv = if (FALSE) 
[08:27:59.716]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:59.716]                     ...future.globalenv.names))
[08:27:59.716]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:59.716]         }, condition = base::local({
[08:27:59.716]             c <- base::c
[08:27:59.716]             inherits <- base::inherits
[08:27:59.716]             invokeRestart <- base::invokeRestart
[08:27:59.716]             length <- base::length
[08:27:59.716]             list <- base::list
[08:27:59.716]             seq.int <- base::seq.int
[08:27:59.716]             signalCondition <- base::signalCondition
[08:27:59.716]             sys.calls <- base::sys.calls
[08:27:59.716]             `[[` <- base::`[[`
[08:27:59.716]             `+` <- base::`+`
[08:27:59.716]             `<<-` <- base::`<<-`
[08:27:59.716]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:59.716]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:59.716]                   3L)]
[08:27:59.716]             }
[08:27:59.716]             function(cond) {
[08:27:59.716]                 is_error <- inherits(cond, "error")
[08:27:59.716]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:59.716]                   NULL)
[08:27:59.716]                 if (is_error) {
[08:27:59.716]                   sessionInformation <- function() {
[08:27:59.716]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:59.716]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:59.716]                       search = base::search(), system = base::Sys.info())
[08:27:59.716]                   }
[08:27:59.716]                   ...future.conditions[[length(...future.conditions) + 
[08:27:59.716]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:59.716]                     cond$call), session = sessionInformation(), 
[08:27:59.716]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:59.716]                   signalCondition(cond)
[08:27:59.716]                 }
[08:27:59.716]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:59.716]                 "immediateCondition"))) {
[08:27:59.716]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:59.716]                   ...future.conditions[[length(...future.conditions) + 
[08:27:59.716]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:59.716]                   if (TRUE && !signal) {
[08:27:59.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.716]                     {
[08:27:59.716]                       inherits <- base::inherits
[08:27:59.716]                       invokeRestart <- base::invokeRestart
[08:27:59.716]                       is.null <- base::is.null
[08:27:59.716]                       muffled <- FALSE
[08:27:59.716]                       if (inherits(cond, "message")) {
[08:27:59.716]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:59.716]                         if (muffled) 
[08:27:59.716]                           invokeRestart("muffleMessage")
[08:27:59.716]                       }
[08:27:59.716]                       else if (inherits(cond, "warning")) {
[08:27:59.716]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:59.716]                         if (muffled) 
[08:27:59.716]                           invokeRestart("muffleWarning")
[08:27:59.716]                       }
[08:27:59.716]                       else if (inherits(cond, "condition")) {
[08:27:59.716]                         if (!is.null(pattern)) {
[08:27:59.716]                           computeRestarts <- base::computeRestarts
[08:27:59.716]                           grepl <- base::grepl
[08:27:59.716]                           restarts <- computeRestarts(cond)
[08:27:59.716]                           for (restart in restarts) {
[08:27:59.716]                             name <- restart$name
[08:27:59.716]                             if (is.null(name)) 
[08:27:59.716]                               next
[08:27:59.716]                             if (!grepl(pattern, name)) 
[08:27:59.716]                               next
[08:27:59.716]                             invokeRestart(restart)
[08:27:59.716]                             muffled <- TRUE
[08:27:59.716]                             break
[08:27:59.716]                           }
[08:27:59.716]                         }
[08:27:59.716]                       }
[08:27:59.716]                       invisible(muffled)
[08:27:59.716]                     }
[08:27:59.716]                     muffleCondition(cond, pattern = "^muffle")
[08:27:59.716]                   }
[08:27:59.716]                 }
[08:27:59.716]                 else {
[08:27:59.716]                   if (TRUE) {
[08:27:59.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:59.716]                     {
[08:27:59.716]                       inherits <- base::inherits
[08:27:59.716]                       invokeRestart <- base::invokeRestart
[08:27:59.716]                       is.null <- base::is.null
[08:27:59.716]                       muffled <- FALSE
[08:27:59.716]                       if (inherits(cond, "message")) {
[08:27:59.716]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:59.716]                         if (muffled) 
[08:27:59.716]                           invokeRestart("muffleMessage")
[08:27:59.716]                       }
[08:27:59.716]                       else if (inherits(cond, "warning")) {
[08:27:59.716]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:59.716]                         if (muffled) 
[08:27:59.716]                           invokeRestart("muffleWarning")
[08:27:59.716]                       }
[08:27:59.716]                       else if (inherits(cond, "condition")) {
[08:27:59.716]                         if (!is.null(pattern)) {
[08:27:59.716]                           computeRestarts <- base::computeRestarts
[08:27:59.716]                           grepl <- base::grepl
[08:27:59.716]                           restarts <- computeRestarts(cond)
[08:27:59.716]                           for (restart in restarts) {
[08:27:59.716]                             name <- restart$name
[08:27:59.716]                             if (is.null(name)) 
[08:27:59.716]                               next
[08:27:59.716]                             if (!grepl(pattern, name)) 
[08:27:59.716]                               next
[08:27:59.716]                             invokeRestart(restart)
[08:27:59.716]                             muffled <- TRUE
[08:27:59.716]                             break
[08:27:59.716]                           }
[08:27:59.716]                         }
[08:27:59.716]                       }
[08:27:59.716]                       invisible(muffled)
[08:27:59.716]                     }
[08:27:59.716]                     muffleCondition(cond, pattern = "^muffle")
[08:27:59.716]                   }
[08:27:59.716]                 }
[08:27:59.716]             }
[08:27:59.716]         }))
[08:27:59.716]     }, error = function(ex) {
[08:27:59.716]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:59.716]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:59.716]                 ...future.rng), started = ...future.startTime, 
[08:27:59.716]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:59.716]             version = "1.8"), class = "FutureResult")
[08:27:59.716]     }, finally = {
[08:27:59.716]         if (!identical(...future.workdir, getwd())) 
[08:27:59.716]             setwd(...future.workdir)
[08:27:59.716]         {
[08:27:59.716]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:59.716]                 ...future.oldOptions$nwarnings <- NULL
[08:27:59.716]             }
[08:27:59.716]             base::options(...future.oldOptions)
[08:27:59.716]             if (.Platform$OS.type == "windows") {
[08:27:59.716]                 old_names <- names(...future.oldEnvVars)
[08:27:59.716]                 envs <- base::Sys.getenv()
[08:27:59.716]                 names <- names(envs)
[08:27:59.716]                 common <- intersect(names, old_names)
[08:27:59.716]                 added <- setdiff(names, old_names)
[08:27:59.716]                 removed <- setdiff(old_names, names)
[08:27:59.716]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:59.716]                   envs[common]]
[08:27:59.716]                 NAMES <- toupper(changed)
[08:27:59.716]                 args <- list()
[08:27:59.716]                 for (kk in seq_along(NAMES)) {
[08:27:59.716]                   name <- changed[[kk]]
[08:27:59.716]                   NAME <- NAMES[[kk]]
[08:27:59.716]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.716]                     next
[08:27:59.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:59.716]                 }
[08:27:59.716]                 NAMES <- toupper(added)
[08:27:59.716]                 for (kk in seq_along(NAMES)) {
[08:27:59.716]                   name <- added[[kk]]
[08:27:59.716]                   NAME <- NAMES[[kk]]
[08:27:59.716]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.716]                     next
[08:27:59.716]                   args[[name]] <- ""
[08:27:59.716]                 }
[08:27:59.716]                 NAMES <- toupper(removed)
[08:27:59.716]                 for (kk in seq_along(NAMES)) {
[08:27:59.716]                   name <- removed[[kk]]
[08:27:59.716]                   NAME <- NAMES[[kk]]
[08:27:59.716]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:59.716]                     next
[08:27:59.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:59.716]                 }
[08:27:59.716]                 if (length(args) > 0) 
[08:27:59.716]                   base::do.call(base::Sys.setenv, args = args)
[08:27:59.716]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:59.716]             }
[08:27:59.716]             else {
[08:27:59.716]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:59.716]             }
[08:27:59.716]             {
[08:27:59.716]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:59.716]                   0L) {
[08:27:59.716]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:59.716]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:59.716]                   base::options(opts)
[08:27:59.716]                 }
[08:27:59.716]                 {
[08:27:59.716]                   {
[08:27:59.716]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:59.716]                     NULL
[08:27:59.716]                   }
[08:27:59.716]                   options(future.plan = NULL)
[08:27:59.716]                   if (is.na(NA_character_)) 
[08:27:59.716]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:59.716]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:59.716]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:59.716]                     .init = FALSE)
[08:27:59.716]                 }
[08:27:59.716]             }
[08:27:59.716]         }
[08:27:59.716]     })
[08:27:59.716]     if (TRUE) {
[08:27:59.716]         base::sink(type = "output", split = FALSE)
[08:27:59.716]         if (TRUE) {
[08:27:59.716]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:59.716]         }
[08:27:59.716]         else {
[08:27:59.716]             ...future.result["stdout"] <- base::list(NULL)
[08:27:59.716]         }
[08:27:59.716]         base::close(...future.stdout)
[08:27:59.716]         ...future.stdout <- NULL
[08:27:59.716]     }
[08:27:59.716]     ...future.result$conditions <- ...future.conditions
[08:27:59.716]     ...future.result$finished <- base::Sys.time()
[08:27:59.716]     ...future.result
[08:27:59.716] }
[08:27:59.718] Exporting 3 global objects (1.53 KiB) to cluster node #1 ...
[08:27:59.718] Exporting ‘outer_function’ (250 bytes) to cluster node #1 ...
[08:27:59.719] Exporting ‘outer_function’ (250 bytes) to cluster node #1 ... DONE
[08:27:59.719] Exporting ‘map’ (633 bytes) to cluster node #1 ...
[08:27:59.719] Exporting ‘map’ (633 bytes) to cluster node #1 ... DONE
[08:27:59.719] Exporting ‘inner_function’ (371 bytes) to cluster node #1 ...
[08:27:59.720] Exporting ‘inner_function’ (371 bytes) to cluster node #1 ... DONE
[08:27:59.720] Exporting 3 global objects (1.53 KiB) to cluster node #1 ... DONE
[08:27:59.720] MultisessionFuture started
[08:27:59.720] - Launch lazy future ... done
[08:27:59.720] run() for ‘MultisessionFuture’ ... done
[08:27:59.721] result() for ClusterFuture ...
[08:27:59.721] receiveMessageFromWorker() for ClusterFuture ...
[08:27:59.721] - Validating connection of MultisessionFuture
[08:27:59.762] - received message: FutureResult
[08:27:59.762] - Received FutureResult
[08:27:59.762] - Erased future from FutureRegistry
[08:27:59.762] result() for ClusterFuture ...
[08:27:59.762] - result already collected: FutureResult
[08:27:59.762] result() for ClusterFuture ... done
[08:27:59.763] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:59.763] result() for ClusterFuture ... done
[08:27:59.763] result() for ClusterFuture ...
[08:27:59.763] - result already collected: FutureResult
[08:27:59.763] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 2 cores ... DONE
> 
> message("*** Globals - formulas ... DONE")
*** Globals - formulas ... DONE
> 
> source("incl/end.R")
[08:27:59.764] plan(): Setting new future strategy stack:
[08:27:59.765] List of future strategies:
[08:27:59.765] 1. FutureStrategy:
[08:27:59.765]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:59.765]    - tweaked: FALSE
[08:27:59.765]    - call: future::plan(oplan)
[08:27:59.765] plan(): nbrOfWorkers() = 1
> 
