
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:21:26.102] plan(): Setting new future strategy stack:
[10:21:26.103] List of future strategies:
[10:21:26.103] 1. sequential:
[10:21:26.103]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.103]    - tweaked: FALSE
[10:21:26.103]    - call: future::plan("sequential")
[10:21:26.117] plan(): nbrOfWorkers() = 1
> 
> library("datasets") ## cars data set
> library("stats")    ## lm(), poly(), xtabs()
> 
> message("*** Globals - formulas ...")
*** Globals - formulas ...
> 
> ## (i) lm(<formula>):
> ## From example("lm", package = "stats")
> ctl <- c(4.17, 5.58, 5.18, 6.11, 4.50, 4.61, 5.17, 4.53, 5.33, 5.14)
> trt <- c(4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 4.89, 4.32, 4.69)
> group <- gl(2, 10, 20, labels = c("Ctl", "Trt"))
> weight <- c(ctl, trt)
> ctl <- trt <- NULL
> ## Truth:
> fit_i <- lm(weight ~ group - 1)
> print(fit_i)

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

> 
> ## (ii) xtabs(~ x):
> x <- c(1, 1, 2, 2, 2)
> ## Truth:
> tbl_ii <- xtabs(~ x)
> print(tbl_ii)
x
1 2 
2 3 
> 
> ## (iii) lm(<formula>, data = cars):
> exprs <- list(
+   # "remove-intercept-term" form of no-intercept
+   a = substitute({ lm(dist ~ . -1, data = cars) }),
+   # "make-intercept-zero" form of no-intercept
+   b = substitute({ lm(dist ~ . +0, data = cars) }),
+   # doesn't do what we want here
+   c = substitute({ lm(dist ~ speed + speed ^ 2, data = cars) }),
+   # gets us a quadratic term
+   d = substitute({ lm(dist ~ speed + I(speed ^ 2), data = cars) }),
+   # avoid potential multicollinearity
+   e = substitute({ lm(dist ~ poly(speed, 2), data = cars) })
+ )
> 
> ## (iv) Globals - map(x, ~ expr):
> ## A fake purrr::map() function with limited functionality
> map <- function(.x, .f, ...) {
+   if (inherits(.f, "formula")) {
+     expr <- .f[[-1]]
+     .f <- eval(bquote(function(...) {
+       .(expr)
+     }))
+   }
+   eval(lapply(.x, FUN = .f, ...))
+ }
> 
> inner_function <- function(x) { x + 1 }
> 
> outer_function <- function(x) {
+   map(1:2, ~ inner_function(.x))
+ }
> 
> y_iv <- outer_function(1L)
> str(y_iv)
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
> 
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     message("- lm(<formula>) ...")
+     
+     ## Explicit future
+     f <- future({ lm(weight ~ group - 1) })
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Explicit future (lazy)
+     f <- future({ lm(weight ~ group - 1) }, lazy = TRUE)
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment
+     fit %<-% { lm(weight ~ group - 1) }
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (non-lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% FALSE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% TRUE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     message("- Globals - one-side formulas, e.g. xtabs(~ x) ...")
+     ## Explicit future
+     f <- future({ xtabs(~ x) })
+     tbl <- value(f)
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     ## Future assignment
+     tbl %<-% { xtabs(~ x) }
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     message("- Globals - lm(<formula>, data = cars) ...")
+     for (kk in seq_along(exprs)) {
+       expr <- exprs[[kk]]
+       name <- names(exprs)[kk]
+       message(sprintf("- Globals - lm(<formula #%d (%s)>, data = cars) ...",
+                       kk, sQuote(name)))
+     
+       fit_iii <- eval(expr)
+       print(fit_iii)
+     
+       f <- future(expr, substitute = FALSE)
+       fit <- value(f)
+       print(fit)
+     
+       stopifnot(all.equal(fit, fit_iii))
+     } ## for (kk ...)
+ 
+     message("- Globals - map(x, ~ expr) ...")
+     f <- future({ outer_function(1L) })
+     y <- value(f)
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+ 
+     y %<-% { outer_function(1L) }
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+   } ## for (strategy ...)
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[10:21:26.176] plan(): Setting new future strategy stack:
[10:21:26.176] List of future strategies:
[10:21:26.176] 1. sequential:
[10:21:26.176]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.176]    - tweaked: FALSE
[10:21:26.176]    - call: plan(strategy)
[10:21:26.188] plan(): nbrOfWorkers() = 1
- lm(<formula>) ...
[10:21:26.189] getGlobalsAndPackages() ...
[10:21:26.189] Searching for globals...
[10:21:26.195] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:21:26.195] Searching for globals ... DONE
[10:21:26.195] Resolving globals: FALSE
[10:21:26.196] The total size of the 2 globals is 401 bytes (401 bytes)
[10:21:26.196] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[10:21:26.197] - globals: [2] ‘weight’, ‘group’
[10:21:26.197] - packages: [1] ‘stats’
[10:21:26.197] getGlobalsAndPackages() ... DONE
[10:21:26.197] run() for ‘Future’ ...
[10:21:26.198] - state: ‘created’
[10:21:26.198] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:26.198] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:26.198] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:26.198]   - Field: ‘label’
[10:21:26.198]   - Field: ‘local’
[10:21:26.198]   - Field: ‘owner’
[10:21:26.199]   - Field: ‘envir’
[10:21:26.199]   - Field: ‘packages’
[10:21:26.199]   - Field: ‘gc’
[10:21:26.199]   - Field: ‘conditions’
[10:21:26.199]   - Field: ‘expr’
[10:21:26.199]   - Field: ‘uuid’
[10:21:26.199]   - Field: ‘seed’
[10:21:26.199]   - Field: ‘version’
[10:21:26.199]   - Field: ‘result’
[10:21:26.199]   - Field: ‘asynchronous’
[10:21:26.199]   - Field: ‘calls’
[10:21:26.199]   - Field: ‘globals’
[10:21:26.199]   - Field: ‘stdout’
[10:21:26.200]   - Field: ‘earlySignal’
[10:21:26.200]   - Field: ‘lazy’
[10:21:26.200]   - Field: ‘state’
[10:21:26.200] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:26.200] - Launch lazy future ...
[10:21:26.201] Packages needed by the future expression (n = 1): ‘stats’
[10:21:26.201] Packages needed by future strategies (n = 0): <none>
[10:21:26.201] {
[10:21:26.201]     {
[10:21:26.201]         {
[10:21:26.201]             ...future.startTime <- base::Sys.time()
[10:21:26.201]             {
[10:21:26.201]                 {
[10:21:26.201]                   {
[10:21:26.201]                     {
[10:21:26.201]                       base::local({
[10:21:26.201]                         has_future <- base::requireNamespace("future", 
[10:21:26.201]                           quietly = TRUE)
[10:21:26.201]                         if (has_future) {
[10:21:26.201]                           ns <- base::getNamespace("future")
[10:21:26.201]                           version <- ns[[".package"]][["version"]]
[10:21:26.201]                           if (is.null(version)) 
[10:21:26.201]                             version <- utils::packageVersion("future")
[10:21:26.201]                         }
[10:21:26.201]                         else {
[10:21:26.201]                           version <- NULL
[10:21:26.201]                         }
[10:21:26.201]                         if (!has_future || version < "1.8.0") {
[10:21:26.201]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.201]                             "", base::R.version$version.string), 
[10:21:26.201]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:26.201]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:26.201]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.201]                               "release", "version")], collapse = " "), 
[10:21:26.201]                             hostname = base::Sys.info()[["nodename"]])
[10:21:26.201]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.201]                             info)
[10:21:26.201]                           info <- base::paste(info, collapse = "; ")
[10:21:26.201]                           if (!has_future) {
[10:21:26.201]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.201]                               info)
[10:21:26.201]                           }
[10:21:26.201]                           else {
[10:21:26.201]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.201]                               info, version)
[10:21:26.201]                           }
[10:21:26.201]                           base::stop(msg)
[10:21:26.201]                         }
[10:21:26.201]                       })
[10:21:26.201]                     }
[10:21:26.201]                     base::local({
[10:21:26.201]                       for (pkg in "stats") {
[10:21:26.201]                         base::loadNamespace(pkg)
[10:21:26.201]                         base::library(pkg, character.only = TRUE)
[10:21:26.201]                       }
[10:21:26.201]                     })
[10:21:26.201]                   }
[10:21:26.201]                   ...future.strategy.old <- future::plan("list")
[10:21:26.201]                   options(future.plan = NULL)
[10:21:26.201]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.201]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.201]                 }
[10:21:26.201]                 ...future.workdir <- getwd()
[10:21:26.201]             }
[10:21:26.201]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.201]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.201]         }
[10:21:26.201]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.201]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.201]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.201]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.201]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.201]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.201]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.201]             base::names(...future.oldOptions))
[10:21:26.201]     }
[10:21:26.201]     if (FALSE) {
[10:21:26.201]     }
[10:21:26.201]     else {
[10:21:26.201]         if (TRUE) {
[10:21:26.201]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.201]                 open = "w")
[10:21:26.201]         }
[10:21:26.201]         else {
[10:21:26.201]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.201]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.201]         }
[10:21:26.201]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.201]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.201]             base::sink(type = "output", split = FALSE)
[10:21:26.201]             base::close(...future.stdout)
[10:21:26.201]         }, add = TRUE)
[10:21:26.201]     }
[10:21:26.201]     ...future.frame <- base::sys.nframe()
[10:21:26.201]     ...future.conditions <- base::list()
[10:21:26.201]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.201]     if (FALSE) {
[10:21:26.201]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.201]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.201]     }
[10:21:26.201]     ...future.result <- base::tryCatch({
[10:21:26.201]         base::withCallingHandlers({
[10:21:26.201]             ...future.value <- base::withVisible(base::local({
[10:21:26.201]                 lm(weight ~ group - 1)
[10:21:26.201]             }))
[10:21:26.201]             future::FutureResult(value = ...future.value$value, 
[10:21:26.201]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.201]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.201]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.201]                     ...future.globalenv.names))
[10:21:26.201]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.201]         }, condition = base::local({
[10:21:26.201]             c <- base::c
[10:21:26.201]             inherits <- base::inherits
[10:21:26.201]             invokeRestart <- base::invokeRestart
[10:21:26.201]             length <- base::length
[10:21:26.201]             list <- base::list
[10:21:26.201]             seq.int <- base::seq.int
[10:21:26.201]             signalCondition <- base::signalCondition
[10:21:26.201]             sys.calls <- base::sys.calls
[10:21:26.201]             `[[` <- base::`[[`
[10:21:26.201]             `+` <- base::`+`
[10:21:26.201]             `<<-` <- base::`<<-`
[10:21:26.201]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.201]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.201]                   3L)]
[10:21:26.201]             }
[10:21:26.201]             function(cond) {
[10:21:26.201]                 is_error <- inherits(cond, "error")
[10:21:26.201]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.201]                   NULL)
[10:21:26.201]                 if (is_error) {
[10:21:26.201]                   sessionInformation <- function() {
[10:21:26.201]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.201]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.201]                       search = base::search(), system = base::Sys.info())
[10:21:26.201]                   }
[10:21:26.201]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.201]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.201]                     cond$call), session = sessionInformation(), 
[10:21:26.201]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.201]                   signalCondition(cond)
[10:21:26.201]                 }
[10:21:26.201]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.201]                 "immediateCondition"))) {
[10:21:26.201]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.201]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.201]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.201]                   if (TRUE && !signal) {
[10:21:26.201]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.201]                     {
[10:21:26.201]                       inherits <- base::inherits
[10:21:26.201]                       invokeRestart <- base::invokeRestart
[10:21:26.201]                       is.null <- base::is.null
[10:21:26.201]                       muffled <- FALSE
[10:21:26.201]                       if (inherits(cond, "message")) {
[10:21:26.201]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.201]                         if (muffled) 
[10:21:26.201]                           invokeRestart("muffleMessage")
[10:21:26.201]                       }
[10:21:26.201]                       else if (inherits(cond, "warning")) {
[10:21:26.201]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.201]                         if (muffled) 
[10:21:26.201]                           invokeRestart("muffleWarning")
[10:21:26.201]                       }
[10:21:26.201]                       else if (inherits(cond, "condition")) {
[10:21:26.201]                         if (!is.null(pattern)) {
[10:21:26.201]                           computeRestarts <- base::computeRestarts
[10:21:26.201]                           grepl <- base::grepl
[10:21:26.201]                           restarts <- computeRestarts(cond)
[10:21:26.201]                           for (restart in restarts) {
[10:21:26.201]                             name <- restart$name
[10:21:26.201]                             if (is.null(name)) 
[10:21:26.201]                               next
[10:21:26.201]                             if (!grepl(pattern, name)) 
[10:21:26.201]                               next
[10:21:26.201]                             invokeRestart(restart)
[10:21:26.201]                             muffled <- TRUE
[10:21:26.201]                             break
[10:21:26.201]                           }
[10:21:26.201]                         }
[10:21:26.201]                       }
[10:21:26.201]                       invisible(muffled)
[10:21:26.201]                     }
[10:21:26.201]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.201]                   }
[10:21:26.201]                 }
[10:21:26.201]                 else {
[10:21:26.201]                   if (TRUE) {
[10:21:26.201]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.201]                     {
[10:21:26.201]                       inherits <- base::inherits
[10:21:26.201]                       invokeRestart <- base::invokeRestart
[10:21:26.201]                       is.null <- base::is.null
[10:21:26.201]                       muffled <- FALSE
[10:21:26.201]                       if (inherits(cond, "message")) {
[10:21:26.201]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.201]                         if (muffled) 
[10:21:26.201]                           invokeRestart("muffleMessage")
[10:21:26.201]                       }
[10:21:26.201]                       else if (inherits(cond, "warning")) {
[10:21:26.201]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.201]                         if (muffled) 
[10:21:26.201]                           invokeRestart("muffleWarning")
[10:21:26.201]                       }
[10:21:26.201]                       else if (inherits(cond, "condition")) {
[10:21:26.201]                         if (!is.null(pattern)) {
[10:21:26.201]                           computeRestarts <- base::computeRestarts
[10:21:26.201]                           grepl <- base::grepl
[10:21:26.201]                           restarts <- computeRestarts(cond)
[10:21:26.201]                           for (restart in restarts) {
[10:21:26.201]                             name <- restart$name
[10:21:26.201]                             if (is.null(name)) 
[10:21:26.201]                               next
[10:21:26.201]                             if (!grepl(pattern, name)) 
[10:21:26.201]                               next
[10:21:26.201]                             invokeRestart(restart)
[10:21:26.201]                             muffled <- TRUE
[10:21:26.201]                             break
[10:21:26.201]                           }
[10:21:26.201]                         }
[10:21:26.201]                       }
[10:21:26.201]                       invisible(muffled)
[10:21:26.201]                     }
[10:21:26.201]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.201]                   }
[10:21:26.201]                 }
[10:21:26.201]             }
[10:21:26.201]         }))
[10:21:26.201]     }, error = function(ex) {
[10:21:26.201]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.201]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.201]                 ...future.rng), started = ...future.startTime, 
[10:21:26.201]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.201]             version = "1.8"), class = "FutureResult")
[10:21:26.201]     }, finally = {
[10:21:26.201]         if (!identical(...future.workdir, getwd())) 
[10:21:26.201]             setwd(...future.workdir)
[10:21:26.201]         {
[10:21:26.201]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.201]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.201]             }
[10:21:26.201]             base::options(...future.oldOptions)
[10:21:26.201]             if (.Platform$OS.type == "windows") {
[10:21:26.201]                 old_names <- names(...future.oldEnvVars)
[10:21:26.201]                 envs <- base::Sys.getenv()
[10:21:26.201]                 names <- names(envs)
[10:21:26.201]                 common <- intersect(names, old_names)
[10:21:26.201]                 added <- setdiff(names, old_names)
[10:21:26.201]                 removed <- setdiff(old_names, names)
[10:21:26.201]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.201]                   envs[common]]
[10:21:26.201]                 NAMES <- toupper(changed)
[10:21:26.201]                 args <- list()
[10:21:26.201]                 for (kk in seq_along(NAMES)) {
[10:21:26.201]                   name <- changed[[kk]]
[10:21:26.201]                   NAME <- NAMES[[kk]]
[10:21:26.201]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.201]                     next
[10:21:26.201]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.201]                 }
[10:21:26.201]                 NAMES <- toupper(added)
[10:21:26.201]                 for (kk in seq_along(NAMES)) {
[10:21:26.201]                   name <- added[[kk]]
[10:21:26.201]                   NAME <- NAMES[[kk]]
[10:21:26.201]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.201]                     next
[10:21:26.201]                   args[[name]] <- ""
[10:21:26.201]                 }
[10:21:26.201]                 NAMES <- toupper(removed)
[10:21:26.201]                 for (kk in seq_along(NAMES)) {
[10:21:26.201]                   name <- removed[[kk]]
[10:21:26.201]                   NAME <- NAMES[[kk]]
[10:21:26.201]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.201]                     next
[10:21:26.201]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.201]                 }
[10:21:26.201]                 if (length(args) > 0) 
[10:21:26.201]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.201]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.201]             }
[10:21:26.201]             else {
[10:21:26.201]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.201]             }
[10:21:26.201]             {
[10:21:26.201]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.201]                   0L) {
[10:21:26.201]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.201]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.201]                   base::options(opts)
[10:21:26.201]                 }
[10:21:26.201]                 {
[10:21:26.201]                   {
[10:21:26.201]                     NULL
[10:21:26.201]                     RNGkind("Mersenne-Twister")
[10:21:26.201]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:26.201]                       inherits = FALSE)
[10:21:26.201]                   }
[10:21:26.201]                   options(future.plan = NULL)
[10:21:26.201]                   if (is.na(NA_character_)) 
[10:21:26.201]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.201]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.201]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.201]                     .init = FALSE)
[10:21:26.201]                 }
[10:21:26.201]             }
[10:21:26.201]         }
[10:21:26.201]     })
[10:21:26.201]     if (TRUE) {
[10:21:26.201]         base::sink(type = "output", split = FALSE)
[10:21:26.201]         if (TRUE) {
[10:21:26.201]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.201]         }
[10:21:26.201]         else {
[10:21:26.201]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.201]         }
[10:21:26.201]         base::close(...future.stdout)
[10:21:26.201]         ...future.stdout <- NULL
[10:21:26.201]     }
[10:21:26.201]     ...future.result$conditions <- ...future.conditions
[10:21:26.201]     ...future.result$finished <- base::Sys.time()
[10:21:26.201]     ...future.result
[10:21:26.201] }
[10:21:26.203] assign_globals() ...
[10:21:26.203] List of 2
[10:21:26.203]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:21:26.203]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:21:26.203]  - attr(*, "where")=List of 2
[10:21:26.203]   ..$ weight:<environment: R_EmptyEnv> 
[10:21:26.203]   ..$ group :<environment: R_EmptyEnv> 
[10:21:26.203]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:26.203]  - attr(*, "resolved")= logi FALSE
[10:21:26.203]  - attr(*, "total_size")= num 401
[10:21:26.203]  - attr(*, "already-done")= logi TRUE
[10:21:26.206] - copied ‘weight’ to environment
[10:21:26.206] - copied ‘group’ to environment
[10:21:26.207] assign_globals() ... done
[10:21:26.207] plan(): Setting new future strategy stack:
[10:21:26.207] List of future strategies:
[10:21:26.207] 1. sequential:
[10:21:26.207]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.207]    - tweaked: FALSE
[10:21:26.207]    - call: NULL
[10:21:26.207] plan(): nbrOfWorkers() = 1
[10:21:26.209] plan(): Setting new future strategy stack:
[10:21:26.209] List of future strategies:
[10:21:26.209] 1. sequential:
[10:21:26.209]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.209]    - tweaked: FALSE
[10:21:26.209]    - call: plan(strategy)
[10:21:26.210] plan(): nbrOfWorkers() = 1
[10:21:26.210] SequentialFuture started (and completed)
[10:21:26.210] - Launch lazy future ... done
[10:21:26.210] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:21:26.214] getGlobalsAndPackages() ...
[10:21:26.214] Searching for globals...
[10:21:26.216] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:21:26.216] Searching for globals ... DONE
[10:21:26.216] Resolving globals: FALSE
[10:21:26.216] The total size of the 2 globals is 401 bytes (401 bytes)
[10:21:26.217] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[10:21:26.217] - globals: [2] ‘weight’, ‘group’
[10:21:26.217] - packages: [1] ‘stats’
[10:21:26.217] getGlobalsAndPackages() ... DONE
[10:21:26.217] run() for ‘Future’ ...
[10:21:26.218] - state: ‘created’
[10:21:26.218] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:26.218] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:26.218] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:26.218]   - Field: ‘label’
[10:21:26.218]   - Field: ‘local’
[10:21:26.218]   - Field: ‘owner’
[10:21:26.218]   - Field: ‘envir’
[10:21:26.218]   - Field: ‘packages’
[10:21:26.218]   - Field: ‘gc’
[10:21:26.219]   - Field: ‘conditions’
[10:21:26.219]   - Field: ‘expr’
[10:21:26.219]   - Field: ‘uuid’
[10:21:26.219]   - Field: ‘seed’
[10:21:26.219]   - Field: ‘version’
[10:21:26.219]   - Field: ‘result’
[10:21:26.219]   - Field: ‘asynchronous’
[10:21:26.219]   - Field: ‘calls’
[10:21:26.219]   - Field: ‘globals’
[10:21:26.219]   - Field: ‘stdout’
[10:21:26.219]   - Field: ‘earlySignal’
[10:21:26.220]   - Field: ‘lazy’
[10:21:26.220]   - Field: ‘state’
[10:21:26.220] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:26.220] - Launch lazy future ...
[10:21:26.220] Packages needed by the future expression (n = 1): ‘stats’
[10:21:26.220] Packages needed by future strategies (n = 0): <none>
[10:21:26.220] {
[10:21:26.220]     {
[10:21:26.220]         {
[10:21:26.220]             ...future.startTime <- base::Sys.time()
[10:21:26.220]             {
[10:21:26.220]                 {
[10:21:26.220]                   {
[10:21:26.220]                     {
[10:21:26.220]                       base::local({
[10:21:26.220]                         has_future <- base::requireNamespace("future", 
[10:21:26.220]                           quietly = TRUE)
[10:21:26.220]                         if (has_future) {
[10:21:26.220]                           ns <- base::getNamespace("future")
[10:21:26.220]                           version <- ns[[".package"]][["version"]]
[10:21:26.220]                           if (is.null(version)) 
[10:21:26.220]                             version <- utils::packageVersion("future")
[10:21:26.220]                         }
[10:21:26.220]                         else {
[10:21:26.220]                           version <- NULL
[10:21:26.220]                         }
[10:21:26.220]                         if (!has_future || version < "1.8.0") {
[10:21:26.220]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.220]                             "", base::R.version$version.string), 
[10:21:26.220]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:26.220]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:26.220]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.220]                               "release", "version")], collapse = " "), 
[10:21:26.220]                             hostname = base::Sys.info()[["nodename"]])
[10:21:26.220]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.220]                             info)
[10:21:26.220]                           info <- base::paste(info, collapse = "; ")
[10:21:26.220]                           if (!has_future) {
[10:21:26.220]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.220]                               info)
[10:21:26.220]                           }
[10:21:26.220]                           else {
[10:21:26.220]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.220]                               info, version)
[10:21:26.220]                           }
[10:21:26.220]                           base::stop(msg)
[10:21:26.220]                         }
[10:21:26.220]                       })
[10:21:26.220]                     }
[10:21:26.220]                     base::local({
[10:21:26.220]                       for (pkg in "stats") {
[10:21:26.220]                         base::loadNamespace(pkg)
[10:21:26.220]                         base::library(pkg, character.only = TRUE)
[10:21:26.220]                       }
[10:21:26.220]                     })
[10:21:26.220]                   }
[10:21:26.220]                   ...future.strategy.old <- future::plan("list")
[10:21:26.220]                   options(future.plan = NULL)
[10:21:26.220]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.220]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.220]                 }
[10:21:26.220]                 ...future.workdir <- getwd()
[10:21:26.220]             }
[10:21:26.220]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.220]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.220]         }
[10:21:26.220]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.220]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.220]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.220]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.220]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.220]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.220]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.220]             base::names(...future.oldOptions))
[10:21:26.220]     }
[10:21:26.220]     if (FALSE) {
[10:21:26.220]     }
[10:21:26.220]     else {
[10:21:26.220]         if (TRUE) {
[10:21:26.220]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.220]                 open = "w")
[10:21:26.220]         }
[10:21:26.220]         else {
[10:21:26.220]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.220]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.220]         }
[10:21:26.220]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.220]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.220]             base::sink(type = "output", split = FALSE)
[10:21:26.220]             base::close(...future.stdout)
[10:21:26.220]         }, add = TRUE)
[10:21:26.220]     }
[10:21:26.220]     ...future.frame <- base::sys.nframe()
[10:21:26.220]     ...future.conditions <- base::list()
[10:21:26.220]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.220]     if (FALSE) {
[10:21:26.220]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.220]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.220]     }
[10:21:26.220]     ...future.result <- base::tryCatch({
[10:21:26.220]         base::withCallingHandlers({
[10:21:26.220]             ...future.value <- base::withVisible(base::local({
[10:21:26.220]                 lm(weight ~ group - 1)
[10:21:26.220]             }))
[10:21:26.220]             future::FutureResult(value = ...future.value$value, 
[10:21:26.220]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.220]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.220]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.220]                     ...future.globalenv.names))
[10:21:26.220]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.220]         }, condition = base::local({
[10:21:26.220]             c <- base::c
[10:21:26.220]             inherits <- base::inherits
[10:21:26.220]             invokeRestart <- base::invokeRestart
[10:21:26.220]             length <- base::length
[10:21:26.220]             list <- base::list
[10:21:26.220]             seq.int <- base::seq.int
[10:21:26.220]             signalCondition <- base::signalCondition
[10:21:26.220]             sys.calls <- base::sys.calls
[10:21:26.220]             `[[` <- base::`[[`
[10:21:26.220]             `+` <- base::`+`
[10:21:26.220]             `<<-` <- base::`<<-`
[10:21:26.220]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.220]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.220]                   3L)]
[10:21:26.220]             }
[10:21:26.220]             function(cond) {
[10:21:26.220]                 is_error <- inherits(cond, "error")
[10:21:26.220]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.220]                   NULL)
[10:21:26.220]                 if (is_error) {
[10:21:26.220]                   sessionInformation <- function() {
[10:21:26.220]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.220]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.220]                       search = base::search(), system = base::Sys.info())
[10:21:26.220]                   }
[10:21:26.220]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.220]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.220]                     cond$call), session = sessionInformation(), 
[10:21:26.220]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.220]                   signalCondition(cond)
[10:21:26.220]                 }
[10:21:26.220]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.220]                 "immediateCondition"))) {
[10:21:26.220]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.220]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.220]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.220]                   if (TRUE && !signal) {
[10:21:26.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.220]                     {
[10:21:26.220]                       inherits <- base::inherits
[10:21:26.220]                       invokeRestart <- base::invokeRestart
[10:21:26.220]                       is.null <- base::is.null
[10:21:26.220]                       muffled <- FALSE
[10:21:26.220]                       if (inherits(cond, "message")) {
[10:21:26.220]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.220]                         if (muffled) 
[10:21:26.220]                           invokeRestart("muffleMessage")
[10:21:26.220]                       }
[10:21:26.220]                       else if (inherits(cond, "warning")) {
[10:21:26.220]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.220]                         if (muffled) 
[10:21:26.220]                           invokeRestart("muffleWarning")
[10:21:26.220]                       }
[10:21:26.220]                       else if (inherits(cond, "condition")) {
[10:21:26.220]                         if (!is.null(pattern)) {
[10:21:26.220]                           computeRestarts <- base::computeRestarts
[10:21:26.220]                           grepl <- base::grepl
[10:21:26.220]                           restarts <- computeRestarts(cond)
[10:21:26.220]                           for (restart in restarts) {
[10:21:26.220]                             name <- restart$name
[10:21:26.220]                             if (is.null(name)) 
[10:21:26.220]                               next
[10:21:26.220]                             if (!grepl(pattern, name)) 
[10:21:26.220]                               next
[10:21:26.220]                             invokeRestart(restart)
[10:21:26.220]                             muffled <- TRUE
[10:21:26.220]                             break
[10:21:26.220]                           }
[10:21:26.220]                         }
[10:21:26.220]                       }
[10:21:26.220]                       invisible(muffled)
[10:21:26.220]                     }
[10:21:26.220]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.220]                   }
[10:21:26.220]                 }
[10:21:26.220]                 else {
[10:21:26.220]                   if (TRUE) {
[10:21:26.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.220]                     {
[10:21:26.220]                       inherits <- base::inherits
[10:21:26.220]                       invokeRestart <- base::invokeRestart
[10:21:26.220]                       is.null <- base::is.null
[10:21:26.220]                       muffled <- FALSE
[10:21:26.220]                       if (inherits(cond, "message")) {
[10:21:26.220]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.220]                         if (muffled) 
[10:21:26.220]                           invokeRestart("muffleMessage")
[10:21:26.220]                       }
[10:21:26.220]                       else if (inherits(cond, "warning")) {
[10:21:26.220]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.220]                         if (muffled) 
[10:21:26.220]                           invokeRestart("muffleWarning")
[10:21:26.220]                       }
[10:21:26.220]                       else if (inherits(cond, "condition")) {
[10:21:26.220]                         if (!is.null(pattern)) {
[10:21:26.220]                           computeRestarts <- base::computeRestarts
[10:21:26.220]                           grepl <- base::grepl
[10:21:26.220]                           restarts <- computeRestarts(cond)
[10:21:26.220]                           for (restart in restarts) {
[10:21:26.220]                             name <- restart$name
[10:21:26.220]                             if (is.null(name)) 
[10:21:26.220]                               next
[10:21:26.220]                             if (!grepl(pattern, name)) 
[10:21:26.220]                               next
[10:21:26.220]                             invokeRestart(restart)
[10:21:26.220]                             muffled <- TRUE
[10:21:26.220]                             break
[10:21:26.220]                           }
[10:21:26.220]                         }
[10:21:26.220]                       }
[10:21:26.220]                       invisible(muffled)
[10:21:26.220]                     }
[10:21:26.220]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.220]                   }
[10:21:26.220]                 }
[10:21:26.220]             }
[10:21:26.220]         }))
[10:21:26.220]     }, error = function(ex) {
[10:21:26.220]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.220]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.220]                 ...future.rng), started = ...future.startTime, 
[10:21:26.220]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.220]             version = "1.8"), class = "FutureResult")
[10:21:26.220]     }, finally = {
[10:21:26.220]         if (!identical(...future.workdir, getwd())) 
[10:21:26.220]             setwd(...future.workdir)
[10:21:26.220]         {
[10:21:26.220]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.220]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.220]             }
[10:21:26.220]             base::options(...future.oldOptions)
[10:21:26.220]             if (.Platform$OS.type == "windows") {
[10:21:26.220]                 old_names <- names(...future.oldEnvVars)
[10:21:26.220]                 envs <- base::Sys.getenv()
[10:21:26.220]                 names <- names(envs)
[10:21:26.220]                 common <- intersect(names, old_names)
[10:21:26.220]                 added <- setdiff(names, old_names)
[10:21:26.220]                 removed <- setdiff(old_names, names)
[10:21:26.220]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.220]                   envs[common]]
[10:21:26.220]                 NAMES <- toupper(changed)
[10:21:26.220]                 args <- list()
[10:21:26.220]                 for (kk in seq_along(NAMES)) {
[10:21:26.220]                   name <- changed[[kk]]
[10:21:26.220]                   NAME <- NAMES[[kk]]
[10:21:26.220]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.220]                     next
[10:21:26.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.220]                 }
[10:21:26.220]                 NAMES <- toupper(added)
[10:21:26.220]                 for (kk in seq_along(NAMES)) {
[10:21:26.220]                   name <- added[[kk]]
[10:21:26.220]                   NAME <- NAMES[[kk]]
[10:21:26.220]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.220]                     next
[10:21:26.220]                   args[[name]] <- ""
[10:21:26.220]                 }
[10:21:26.220]                 NAMES <- toupper(removed)
[10:21:26.220]                 for (kk in seq_along(NAMES)) {
[10:21:26.220]                   name <- removed[[kk]]
[10:21:26.220]                   NAME <- NAMES[[kk]]
[10:21:26.220]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.220]                     next
[10:21:26.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.220]                 }
[10:21:26.220]                 if (length(args) > 0) 
[10:21:26.220]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.220]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.220]             }
[10:21:26.220]             else {
[10:21:26.220]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.220]             }
[10:21:26.220]             {
[10:21:26.220]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.220]                   0L) {
[10:21:26.220]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.220]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.220]                   base::options(opts)
[10:21:26.220]                 }
[10:21:26.220]                 {
[10:21:26.220]                   {
[10:21:26.220]                     NULL
[10:21:26.220]                     RNGkind("Mersenne-Twister")
[10:21:26.220]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:26.220]                       inherits = FALSE)
[10:21:26.220]                   }
[10:21:26.220]                   options(future.plan = NULL)
[10:21:26.220]                   if (is.na(NA_character_)) 
[10:21:26.220]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.220]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.220]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.220]                     .init = FALSE)
[10:21:26.220]                 }
[10:21:26.220]             }
[10:21:26.220]         }
[10:21:26.220]     })
[10:21:26.220]     if (TRUE) {
[10:21:26.220]         base::sink(type = "output", split = FALSE)
[10:21:26.220]         if (TRUE) {
[10:21:26.220]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.220]         }
[10:21:26.220]         else {
[10:21:26.220]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.220]         }
[10:21:26.220]         base::close(...future.stdout)
[10:21:26.220]         ...future.stdout <- NULL
[10:21:26.220]     }
[10:21:26.220]     ...future.result$conditions <- ...future.conditions
[10:21:26.220]     ...future.result$finished <- base::Sys.time()
[10:21:26.220]     ...future.result
[10:21:26.220] }
[10:21:26.222] assign_globals() ...
[10:21:26.222] List of 2
[10:21:26.222]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:21:26.222]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:21:26.222]  - attr(*, "where")=List of 2
[10:21:26.222]   ..$ weight:<environment: R_EmptyEnv> 
[10:21:26.222]   ..$ group :<environment: R_EmptyEnv> 
[10:21:26.222]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:26.222]  - attr(*, "resolved")= logi FALSE
[10:21:26.222]  - attr(*, "total_size")= num 401
[10:21:26.222]  - attr(*, "already-done")= logi TRUE
[10:21:26.225] - copied ‘weight’ to environment
[10:21:26.225] - copied ‘group’ to environment
[10:21:26.225] assign_globals() ... done
[10:21:26.226] plan(): Setting new future strategy stack:
[10:21:26.226] List of future strategies:
[10:21:26.226] 1. sequential:
[10:21:26.226]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.226]    - tweaked: FALSE
[10:21:26.226]    - call: NULL
[10:21:26.226] plan(): nbrOfWorkers() = 1
[10:21:26.227] plan(): Setting new future strategy stack:
[10:21:26.227] List of future strategies:
[10:21:26.227] 1. sequential:
[10:21:26.227]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.227]    - tweaked: FALSE
[10:21:26.227]    - call: plan(strategy)
[10:21:26.228] plan(): nbrOfWorkers() = 1
[10:21:26.228] SequentialFuture started (and completed)
[10:21:26.228] - Launch lazy future ... done
[10:21:26.228] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:21:26.230] getGlobalsAndPackages() ...
[10:21:26.231] Searching for globals...
[10:21:26.232] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:21:26.232] Searching for globals ... DONE
[10:21:26.232] Resolving globals: FALSE
[10:21:26.232] The total size of the 2 globals is 401 bytes (401 bytes)
[10:21:26.233] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[10:21:26.233] - globals: [2] ‘weight’, ‘group’
[10:21:26.233] - packages: [1] ‘stats’
[10:21:26.233] getGlobalsAndPackages() ... DONE
[10:21:26.233] run() for ‘Future’ ...
[10:21:26.233] - state: ‘created’
[10:21:26.234] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:26.234] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:26.234] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:26.234]   - Field: ‘label’
[10:21:26.234]   - Field: ‘local’
[10:21:26.234]   - Field: ‘owner’
[10:21:26.234]   - Field: ‘envir’
[10:21:26.234]   - Field: ‘packages’
[10:21:26.234]   - Field: ‘gc’
[10:21:26.234]   - Field: ‘conditions’
[10:21:26.235]   - Field: ‘expr’
[10:21:26.235]   - Field: ‘uuid’
[10:21:26.235]   - Field: ‘seed’
[10:21:26.235]   - Field: ‘version’
[10:21:26.235]   - Field: ‘result’
[10:21:26.235]   - Field: ‘asynchronous’
[10:21:26.235]   - Field: ‘calls’
[10:21:26.235]   - Field: ‘globals’
[10:21:26.235]   - Field: ‘stdout’
[10:21:26.235]   - Field: ‘earlySignal’
[10:21:26.235]   - Field: ‘lazy’
[10:21:26.235]   - Field: ‘state’
[10:21:26.236] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:26.236] - Launch lazy future ...
[10:21:26.236] Packages needed by the future expression (n = 1): ‘stats’
[10:21:26.236] Packages needed by future strategies (n = 0): <none>
[10:21:26.237] {
[10:21:26.237]     {
[10:21:26.237]         {
[10:21:26.237]             ...future.startTime <- base::Sys.time()
[10:21:26.237]             {
[10:21:26.237]                 {
[10:21:26.237]                   {
[10:21:26.237]                     {
[10:21:26.237]                       base::local({
[10:21:26.237]                         has_future <- base::requireNamespace("future", 
[10:21:26.237]                           quietly = TRUE)
[10:21:26.237]                         if (has_future) {
[10:21:26.237]                           ns <- base::getNamespace("future")
[10:21:26.237]                           version <- ns[[".package"]][["version"]]
[10:21:26.237]                           if (is.null(version)) 
[10:21:26.237]                             version <- utils::packageVersion("future")
[10:21:26.237]                         }
[10:21:26.237]                         else {
[10:21:26.237]                           version <- NULL
[10:21:26.237]                         }
[10:21:26.237]                         if (!has_future || version < "1.8.0") {
[10:21:26.237]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.237]                             "", base::R.version$version.string), 
[10:21:26.237]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:26.237]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:26.237]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.237]                               "release", "version")], collapse = " "), 
[10:21:26.237]                             hostname = base::Sys.info()[["nodename"]])
[10:21:26.237]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.237]                             info)
[10:21:26.237]                           info <- base::paste(info, collapse = "; ")
[10:21:26.237]                           if (!has_future) {
[10:21:26.237]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.237]                               info)
[10:21:26.237]                           }
[10:21:26.237]                           else {
[10:21:26.237]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.237]                               info, version)
[10:21:26.237]                           }
[10:21:26.237]                           base::stop(msg)
[10:21:26.237]                         }
[10:21:26.237]                       })
[10:21:26.237]                     }
[10:21:26.237]                     base::local({
[10:21:26.237]                       for (pkg in "stats") {
[10:21:26.237]                         base::loadNamespace(pkg)
[10:21:26.237]                         base::library(pkg, character.only = TRUE)
[10:21:26.237]                       }
[10:21:26.237]                     })
[10:21:26.237]                   }
[10:21:26.237]                   ...future.strategy.old <- future::plan("list")
[10:21:26.237]                   options(future.plan = NULL)
[10:21:26.237]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.237]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.237]                 }
[10:21:26.237]                 ...future.workdir <- getwd()
[10:21:26.237]             }
[10:21:26.237]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.237]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.237]         }
[10:21:26.237]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.237]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.237]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.237]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.237]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.237]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.237]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.237]             base::names(...future.oldOptions))
[10:21:26.237]     }
[10:21:26.237]     if (FALSE) {
[10:21:26.237]     }
[10:21:26.237]     else {
[10:21:26.237]         if (TRUE) {
[10:21:26.237]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.237]                 open = "w")
[10:21:26.237]         }
[10:21:26.237]         else {
[10:21:26.237]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.237]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.237]         }
[10:21:26.237]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.237]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.237]             base::sink(type = "output", split = FALSE)
[10:21:26.237]             base::close(...future.stdout)
[10:21:26.237]         }, add = TRUE)
[10:21:26.237]     }
[10:21:26.237]     ...future.frame <- base::sys.nframe()
[10:21:26.237]     ...future.conditions <- base::list()
[10:21:26.237]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.237]     if (FALSE) {
[10:21:26.237]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.237]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.237]     }
[10:21:26.237]     ...future.result <- base::tryCatch({
[10:21:26.237]         base::withCallingHandlers({
[10:21:26.237]             ...future.value <- base::withVisible(base::local({
[10:21:26.237]                 lm(weight ~ group - 1)
[10:21:26.237]             }))
[10:21:26.237]             future::FutureResult(value = ...future.value$value, 
[10:21:26.237]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.237]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.237]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.237]                     ...future.globalenv.names))
[10:21:26.237]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.237]         }, condition = base::local({
[10:21:26.237]             c <- base::c
[10:21:26.237]             inherits <- base::inherits
[10:21:26.237]             invokeRestart <- base::invokeRestart
[10:21:26.237]             length <- base::length
[10:21:26.237]             list <- base::list
[10:21:26.237]             seq.int <- base::seq.int
[10:21:26.237]             signalCondition <- base::signalCondition
[10:21:26.237]             sys.calls <- base::sys.calls
[10:21:26.237]             `[[` <- base::`[[`
[10:21:26.237]             `+` <- base::`+`
[10:21:26.237]             `<<-` <- base::`<<-`
[10:21:26.237]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.237]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.237]                   3L)]
[10:21:26.237]             }
[10:21:26.237]             function(cond) {
[10:21:26.237]                 is_error <- inherits(cond, "error")
[10:21:26.237]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.237]                   NULL)
[10:21:26.237]                 if (is_error) {
[10:21:26.237]                   sessionInformation <- function() {
[10:21:26.237]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.237]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.237]                       search = base::search(), system = base::Sys.info())
[10:21:26.237]                   }
[10:21:26.237]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.237]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.237]                     cond$call), session = sessionInformation(), 
[10:21:26.237]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.237]                   signalCondition(cond)
[10:21:26.237]                 }
[10:21:26.237]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.237]                 "immediateCondition"))) {
[10:21:26.237]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.237]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.237]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.237]                   if (TRUE && !signal) {
[10:21:26.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.237]                     {
[10:21:26.237]                       inherits <- base::inherits
[10:21:26.237]                       invokeRestart <- base::invokeRestart
[10:21:26.237]                       is.null <- base::is.null
[10:21:26.237]                       muffled <- FALSE
[10:21:26.237]                       if (inherits(cond, "message")) {
[10:21:26.237]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.237]                         if (muffled) 
[10:21:26.237]                           invokeRestart("muffleMessage")
[10:21:26.237]                       }
[10:21:26.237]                       else if (inherits(cond, "warning")) {
[10:21:26.237]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.237]                         if (muffled) 
[10:21:26.237]                           invokeRestart("muffleWarning")
[10:21:26.237]                       }
[10:21:26.237]                       else if (inherits(cond, "condition")) {
[10:21:26.237]                         if (!is.null(pattern)) {
[10:21:26.237]                           computeRestarts <- base::computeRestarts
[10:21:26.237]                           grepl <- base::grepl
[10:21:26.237]                           restarts <- computeRestarts(cond)
[10:21:26.237]                           for (restart in restarts) {
[10:21:26.237]                             name <- restart$name
[10:21:26.237]                             if (is.null(name)) 
[10:21:26.237]                               next
[10:21:26.237]                             if (!grepl(pattern, name)) 
[10:21:26.237]                               next
[10:21:26.237]                             invokeRestart(restart)
[10:21:26.237]                             muffled <- TRUE
[10:21:26.237]                             break
[10:21:26.237]                           }
[10:21:26.237]                         }
[10:21:26.237]                       }
[10:21:26.237]                       invisible(muffled)
[10:21:26.237]                     }
[10:21:26.237]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.237]                   }
[10:21:26.237]                 }
[10:21:26.237]                 else {
[10:21:26.237]                   if (TRUE) {
[10:21:26.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.237]                     {
[10:21:26.237]                       inherits <- base::inherits
[10:21:26.237]                       invokeRestart <- base::invokeRestart
[10:21:26.237]                       is.null <- base::is.null
[10:21:26.237]                       muffled <- FALSE
[10:21:26.237]                       if (inherits(cond, "message")) {
[10:21:26.237]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.237]                         if (muffled) 
[10:21:26.237]                           invokeRestart("muffleMessage")
[10:21:26.237]                       }
[10:21:26.237]                       else if (inherits(cond, "warning")) {
[10:21:26.237]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.237]                         if (muffled) 
[10:21:26.237]                           invokeRestart("muffleWarning")
[10:21:26.237]                       }
[10:21:26.237]                       else if (inherits(cond, "condition")) {
[10:21:26.237]                         if (!is.null(pattern)) {
[10:21:26.237]                           computeRestarts <- base::computeRestarts
[10:21:26.237]                           grepl <- base::grepl
[10:21:26.237]                           restarts <- computeRestarts(cond)
[10:21:26.237]                           for (restart in restarts) {
[10:21:26.237]                             name <- restart$name
[10:21:26.237]                             if (is.null(name)) 
[10:21:26.237]                               next
[10:21:26.237]                             if (!grepl(pattern, name)) 
[10:21:26.237]                               next
[10:21:26.237]                             invokeRestart(restart)
[10:21:26.237]                             muffled <- TRUE
[10:21:26.237]                             break
[10:21:26.237]                           }
[10:21:26.237]                         }
[10:21:26.237]                       }
[10:21:26.237]                       invisible(muffled)
[10:21:26.237]                     }
[10:21:26.237]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.237]                   }
[10:21:26.237]                 }
[10:21:26.237]             }
[10:21:26.237]         }))
[10:21:26.237]     }, error = function(ex) {
[10:21:26.237]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.237]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.237]                 ...future.rng), started = ...future.startTime, 
[10:21:26.237]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.237]             version = "1.8"), class = "FutureResult")
[10:21:26.237]     }, finally = {
[10:21:26.237]         if (!identical(...future.workdir, getwd())) 
[10:21:26.237]             setwd(...future.workdir)
[10:21:26.237]         {
[10:21:26.237]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.237]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.237]             }
[10:21:26.237]             base::options(...future.oldOptions)
[10:21:26.237]             if (.Platform$OS.type == "windows") {
[10:21:26.237]                 old_names <- names(...future.oldEnvVars)
[10:21:26.237]                 envs <- base::Sys.getenv()
[10:21:26.237]                 names <- names(envs)
[10:21:26.237]                 common <- intersect(names, old_names)
[10:21:26.237]                 added <- setdiff(names, old_names)
[10:21:26.237]                 removed <- setdiff(old_names, names)
[10:21:26.237]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.237]                   envs[common]]
[10:21:26.237]                 NAMES <- toupper(changed)
[10:21:26.237]                 args <- list()
[10:21:26.237]                 for (kk in seq_along(NAMES)) {
[10:21:26.237]                   name <- changed[[kk]]
[10:21:26.237]                   NAME <- NAMES[[kk]]
[10:21:26.237]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.237]                     next
[10:21:26.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.237]                 }
[10:21:26.237]                 NAMES <- toupper(added)
[10:21:26.237]                 for (kk in seq_along(NAMES)) {
[10:21:26.237]                   name <- added[[kk]]
[10:21:26.237]                   NAME <- NAMES[[kk]]
[10:21:26.237]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.237]                     next
[10:21:26.237]                   args[[name]] <- ""
[10:21:26.237]                 }
[10:21:26.237]                 NAMES <- toupper(removed)
[10:21:26.237]                 for (kk in seq_along(NAMES)) {
[10:21:26.237]                   name <- removed[[kk]]
[10:21:26.237]                   NAME <- NAMES[[kk]]
[10:21:26.237]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.237]                     next
[10:21:26.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.237]                 }
[10:21:26.237]                 if (length(args) > 0) 
[10:21:26.237]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.237]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.237]             }
[10:21:26.237]             else {
[10:21:26.237]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.237]             }
[10:21:26.237]             {
[10:21:26.237]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.237]                   0L) {
[10:21:26.237]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.237]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.237]                   base::options(opts)
[10:21:26.237]                 }
[10:21:26.237]                 {
[10:21:26.237]                   {
[10:21:26.237]                     NULL
[10:21:26.237]                     RNGkind("Mersenne-Twister")
[10:21:26.237]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:26.237]                       inherits = FALSE)
[10:21:26.237]                   }
[10:21:26.237]                   options(future.plan = NULL)
[10:21:26.237]                   if (is.na(NA_character_)) 
[10:21:26.237]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.237]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.237]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.237]                     .init = FALSE)
[10:21:26.237]                 }
[10:21:26.237]             }
[10:21:26.237]         }
[10:21:26.237]     })
[10:21:26.237]     if (TRUE) {
[10:21:26.237]         base::sink(type = "output", split = FALSE)
[10:21:26.237]         if (TRUE) {
[10:21:26.237]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.237]         }
[10:21:26.237]         else {
[10:21:26.237]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.237]         }
[10:21:26.237]         base::close(...future.stdout)
[10:21:26.237]         ...future.stdout <- NULL
[10:21:26.237]     }
[10:21:26.237]     ...future.result$conditions <- ...future.conditions
[10:21:26.237]     ...future.result$finished <- base::Sys.time()
[10:21:26.237]     ...future.result
[10:21:26.237] }
[10:21:26.239] assign_globals() ...
[10:21:26.239] List of 2
[10:21:26.239]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:21:26.239]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:21:26.239]  - attr(*, "where")=List of 2
[10:21:26.239]   ..$ weight:<environment: R_EmptyEnv> 
[10:21:26.239]   ..$ group :<environment: R_EmptyEnv> 
[10:21:26.239]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:26.239]  - attr(*, "resolved")= logi FALSE
[10:21:26.239]  - attr(*, "total_size")= num 401
[10:21:26.239]  - attr(*, "already-done")= logi TRUE
[10:21:26.242] - copied ‘weight’ to environment
[10:21:26.242] - copied ‘group’ to environment
[10:21:26.242] assign_globals() ... done
[10:21:26.242] plan(): Setting new future strategy stack:
[10:21:26.243] List of future strategies:
[10:21:26.243] 1. sequential:
[10:21:26.243]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.243]    - tweaked: FALSE
[10:21:26.243]    - call: NULL
[10:21:26.243] plan(): nbrOfWorkers() = 1
[10:21:26.244] plan(): Setting new future strategy stack:
[10:21:26.244] List of future strategies:
[10:21:26.244] 1. sequential:
[10:21:26.244]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.244]    - tweaked: FALSE
[10:21:26.244]    - call: plan(strategy)
[10:21:26.245] plan(): nbrOfWorkers() = 1
[10:21:26.245] SequentialFuture started (and completed)
[10:21:26.245] - Launch lazy future ... done
[10:21:26.245] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:21:26.247] getGlobalsAndPackages() ...
[10:21:26.247] Searching for globals...
[10:21:26.248] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:21:26.248] Searching for globals ... DONE
[10:21:26.248] Resolving globals: FALSE
[10:21:26.249] The total size of the 2 globals is 401 bytes (401 bytes)
[10:21:26.249] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[10:21:26.249] - globals: [2] ‘weight’, ‘group’
[10:21:26.249] - packages: [1] ‘stats’
[10:21:26.250] getGlobalsAndPackages() ... DONE
[10:21:26.250] run() for ‘Future’ ...
[10:21:26.250] - state: ‘created’
[10:21:26.250] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:26.250] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:26.250] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:26.250]   - Field: ‘label’
[10:21:26.250]   - Field: ‘local’
[10:21:26.251]   - Field: ‘owner’
[10:21:26.251]   - Field: ‘envir’
[10:21:26.251]   - Field: ‘packages’
[10:21:26.251]   - Field: ‘gc’
[10:21:26.251]   - Field: ‘conditions’
[10:21:26.251]   - Field: ‘expr’
[10:21:26.251]   - Field: ‘uuid’
[10:21:26.251]   - Field: ‘seed’
[10:21:26.251]   - Field: ‘version’
[10:21:26.251]   - Field: ‘result’
[10:21:26.251]   - Field: ‘asynchronous’
[10:21:26.251]   - Field: ‘calls’
[10:21:26.252]   - Field: ‘globals’
[10:21:26.252]   - Field: ‘stdout’
[10:21:26.252]   - Field: ‘earlySignal’
[10:21:26.252]   - Field: ‘lazy’
[10:21:26.252]   - Field: ‘state’
[10:21:26.252] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:26.252] - Launch lazy future ...
[10:21:26.252] Packages needed by the future expression (n = 1): ‘stats’
[10:21:26.252] Packages needed by future strategies (n = 0): <none>
[10:21:26.253] {
[10:21:26.253]     {
[10:21:26.253]         {
[10:21:26.253]             ...future.startTime <- base::Sys.time()
[10:21:26.253]             {
[10:21:26.253]                 {
[10:21:26.253]                   {
[10:21:26.253]                     {
[10:21:26.253]                       base::local({
[10:21:26.253]                         has_future <- base::requireNamespace("future", 
[10:21:26.253]                           quietly = TRUE)
[10:21:26.253]                         if (has_future) {
[10:21:26.253]                           ns <- base::getNamespace("future")
[10:21:26.253]                           version <- ns[[".package"]][["version"]]
[10:21:26.253]                           if (is.null(version)) 
[10:21:26.253]                             version <- utils::packageVersion("future")
[10:21:26.253]                         }
[10:21:26.253]                         else {
[10:21:26.253]                           version <- NULL
[10:21:26.253]                         }
[10:21:26.253]                         if (!has_future || version < "1.8.0") {
[10:21:26.253]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.253]                             "", base::R.version$version.string), 
[10:21:26.253]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:26.253]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:26.253]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.253]                               "release", "version")], collapse = " "), 
[10:21:26.253]                             hostname = base::Sys.info()[["nodename"]])
[10:21:26.253]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.253]                             info)
[10:21:26.253]                           info <- base::paste(info, collapse = "; ")
[10:21:26.253]                           if (!has_future) {
[10:21:26.253]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.253]                               info)
[10:21:26.253]                           }
[10:21:26.253]                           else {
[10:21:26.253]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.253]                               info, version)
[10:21:26.253]                           }
[10:21:26.253]                           base::stop(msg)
[10:21:26.253]                         }
[10:21:26.253]                       })
[10:21:26.253]                     }
[10:21:26.253]                     base::local({
[10:21:26.253]                       for (pkg in "stats") {
[10:21:26.253]                         base::loadNamespace(pkg)
[10:21:26.253]                         base::library(pkg, character.only = TRUE)
[10:21:26.253]                       }
[10:21:26.253]                     })
[10:21:26.253]                   }
[10:21:26.253]                   ...future.strategy.old <- future::plan("list")
[10:21:26.253]                   options(future.plan = NULL)
[10:21:26.253]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.253]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.253]                 }
[10:21:26.253]                 ...future.workdir <- getwd()
[10:21:26.253]             }
[10:21:26.253]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.253]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.253]         }
[10:21:26.253]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.253]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.253]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.253]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.253]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.253]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.253]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.253]             base::names(...future.oldOptions))
[10:21:26.253]     }
[10:21:26.253]     if (FALSE) {
[10:21:26.253]     }
[10:21:26.253]     else {
[10:21:26.253]         if (TRUE) {
[10:21:26.253]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.253]                 open = "w")
[10:21:26.253]         }
[10:21:26.253]         else {
[10:21:26.253]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.253]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.253]         }
[10:21:26.253]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.253]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.253]             base::sink(type = "output", split = FALSE)
[10:21:26.253]             base::close(...future.stdout)
[10:21:26.253]         }, add = TRUE)
[10:21:26.253]     }
[10:21:26.253]     ...future.frame <- base::sys.nframe()
[10:21:26.253]     ...future.conditions <- base::list()
[10:21:26.253]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.253]     if (FALSE) {
[10:21:26.253]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.253]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.253]     }
[10:21:26.253]     ...future.result <- base::tryCatch({
[10:21:26.253]         base::withCallingHandlers({
[10:21:26.253]             ...future.value <- base::withVisible(base::local({
[10:21:26.253]                 lm(weight ~ group - 1)
[10:21:26.253]             }))
[10:21:26.253]             future::FutureResult(value = ...future.value$value, 
[10:21:26.253]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.253]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.253]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.253]                     ...future.globalenv.names))
[10:21:26.253]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.253]         }, condition = base::local({
[10:21:26.253]             c <- base::c
[10:21:26.253]             inherits <- base::inherits
[10:21:26.253]             invokeRestart <- base::invokeRestart
[10:21:26.253]             length <- base::length
[10:21:26.253]             list <- base::list
[10:21:26.253]             seq.int <- base::seq.int
[10:21:26.253]             signalCondition <- base::signalCondition
[10:21:26.253]             sys.calls <- base::sys.calls
[10:21:26.253]             `[[` <- base::`[[`
[10:21:26.253]             `+` <- base::`+`
[10:21:26.253]             `<<-` <- base::`<<-`
[10:21:26.253]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.253]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.253]                   3L)]
[10:21:26.253]             }
[10:21:26.253]             function(cond) {
[10:21:26.253]                 is_error <- inherits(cond, "error")
[10:21:26.253]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.253]                   NULL)
[10:21:26.253]                 if (is_error) {
[10:21:26.253]                   sessionInformation <- function() {
[10:21:26.253]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.253]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.253]                       search = base::search(), system = base::Sys.info())
[10:21:26.253]                   }
[10:21:26.253]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.253]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.253]                     cond$call), session = sessionInformation(), 
[10:21:26.253]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.253]                   signalCondition(cond)
[10:21:26.253]                 }
[10:21:26.253]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.253]                 "immediateCondition"))) {
[10:21:26.253]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.253]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.253]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.253]                   if (TRUE && !signal) {
[10:21:26.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.253]                     {
[10:21:26.253]                       inherits <- base::inherits
[10:21:26.253]                       invokeRestart <- base::invokeRestart
[10:21:26.253]                       is.null <- base::is.null
[10:21:26.253]                       muffled <- FALSE
[10:21:26.253]                       if (inherits(cond, "message")) {
[10:21:26.253]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.253]                         if (muffled) 
[10:21:26.253]                           invokeRestart("muffleMessage")
[10:21:26.253]                       }
[10:21:26.253]                       else if (inherits(cond, "warning")) {
[10:21:26.253]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.253]                         if (muffled) 
[10:21:26.253]                           invokeRestart("muffleWarning")
[10:21:26.253]                       }
[10:21:26.253]                       else if (inherits(cond, "condition")) {
[10:21:26.253]                         if (!is.null(pattern)) {
[10:21:26.253]                           computeRestarts <- base::computeRestarts
[10:21:26.253]                           grepl <- base::grepl
[10:21:26.253]                           restarts <- computeRestarts(cond)
[10:21:26.253]                           for (restart in restarts) {
[10:21:26.253]                             name <- restart$name
[10:21:26.253]                             if (is.null(name)) 
[10:21:26.253]                               next
[10:21:26.253]                             if (!grepl(pattern, name)) 
[10:21:26.253]                               next
[10:21:26.253]                             invokeRestart(restart)
[10:21:26.253]                             muffled <- TRUE
[10:21:26.253]                             break
[10:21:26.253]                           }
[10:21:26.253]                         }
[10:21:26.253]                       }
[10:21:26.253]                       invisible(muffled)
[10:21:26.253]                     }
[10:21:26.253]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.253]                   }
[10:21:26.253]                 }
[10:21:26.253]                 else {
[10:21:26.253]                   if (TRUE) {
[10:21:26.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.253]                     {
[10:21:26.253]                       inherits <- base::inherits
[10:21:26.253]                       invokeRestart <- base::invokeRestart
[10:21:26.253]                       is.null <- base::is.null
[10:21:26.253]                       muffled <- FALSE
[10:21:26.253]                       if (inherits(cond, "message")) {
[10:21:26.253]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.253]                         if (muffled) 
[10:21:26.253]                           invokeRestart("muffleMessage")
[10:21:26.253]                       }
[10:21:26.253]                       else if (inherits(cond, "warning")) {
[10:21:26.253]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.253]                         if (muffled) 
[10:21:26.253]                           invokeRestart("muffleWarning")
[10:21:26.253]                       }
[10:21:26.253]                       else if (inherits(cond, "condition")) {
[10:21:26.253]                         if (!is.null(pattern)) {
[10:21:26.253]                           computeRestarts <- base::computeRestarts
[10:21:26.253]                           grepl <- base::grepl
[10:21:26.253]                           restarts <- computeRestarts(cond)
[10:21:26.253]                           for (restart in restarts) {
[10:21:26.253]                             name <- restart$name
[10:21:26.253]                             if (is.null(name)) 
[10:21:26.253]                               next
[10:21:26.253]                             if (!grepl(pattern, name)) 
[10:21:26.253]                               next
[10:21:26.253]                             invokeRestart(restart)
[10:21:26.253]                             muffled <- TRUE
[10:21:26.253]                             break
[10:21:26.253]                           }
[10:21:26.253]                         }
[10:21:26.253]                       }
[10:21:26.253]                       invisible(muffled)
[10:21:26.253]                     }
[10:21:26.253]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.253]                   }
[10:21:26.253]                 }
[10:21:26.253]             }
[10:21:26.253]         }))
[10:21:26.253]     }, error = function(ex) {
[10:21:26.253]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.253]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.253]                 ...future.rng), started = ...future.startTime, 
[10:21:26.253]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.253]             version = "1.8"), class = "FutureResult")
[10:21:26.253]     }, finally = {
[10:21:26.253]         if (!identical(...future.workdir, getwd())) 
[10:21:26.253]             setwd(...future.workdir)
[10:21:26.253]         {
[10:21:26.253]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.253]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.253]             }
[10:21:26.253]             base::options(...future.oldOptions)
[10:21:26.253]             if (.Platform$OS.type == "windows") {
[10:21:26.253]                 old_names <- names(...future.oldEnvVars)
[10:21:26.253]                 envs <- base::Sys.getenv()
[10:21:26.253]                 names <- names(envs)
[10:21:26.253]                 common <- intersect(names, old_names)
[10:21:26.253]                 added <- setdiff(names, old_names)
[10:21:26.253]                 removed <- setdiff(old_names, names)
[10:21:26.253]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.253]                   envs[common]]
[10:21:26.253]                 NAMES <- toupper(changed)
[10:21:26.253]                 args <- list()
[10:21:26.253]                 for (kk in seq_along(NAMES)) {
[10:21:26.253]                   name <- changed[[kk]]
[10:21:26.253]                   NAME <- NAMES[[kk]]
[10:21:26.253]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.253]                     next
[10:21:26.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.253]                 }
[10:21:26.253]                 NAMES <- toupper(added)
[10:21:26.253]                 for (kk in seq_along(NAMES)) {
[10:21:26.253]                   name <- added[[kk]]
[10:21:26.253]                   NAME <- NAMES[[kk]]
[10:21:26.253]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.253]                     next
[10:21:26.253]                   args[[name]] <- ""
[10:21:26.253]                 }
[10:21:26.253]                 NAMES <- toupper(removed)
[10:21:26.253]                 for (kk in seq_along(NAMES)) {
[10:21:26.253]                   name <- removed[[kk]]
[10:21:26.253]                   NAME <- NAMES[[kk]]
[10:21:26.253]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.253]                     next
[10:21:26.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.253]                 }
[10:21:26.253]                 if (length(args) > 0) 
[10:21:26.253]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.253]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.253]             }
[10:21:26.253]             else {
[10:21:26.253]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.253]             }
[10:21:26.253]             {
[10:21:26.253]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.253]                   0L) {
[10:21:26.253]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.253]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.253]                   base::options(opts)
[10:21:26.253]                 }
[10:21:26.253]                 {
[10:21:26.253]                   {
[10:21:26.253]                     NULL
[10:21:26.253]                     RNGkind("Mersenne-Twister")
[10:21:26.253]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:26.253]                       inherits = FALSE)
[10:21:26.253]                   }
[10:21:26.253]                   options(future.plan = NULL)
[10:21:26.253]                   if (is.na(NA_character_)) 
[10:21:26.253]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.253]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.253]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.253]                     .init = FALSE)
[10:21:26.253]                 }
[10:21:26.253]             }
[10:21:26.253]         }
[10:21:26.253]     })
[10:21:26.253]     if (TRUE) {
[10:21:26.253]         base::sink(type = "output", split = FALSE)
[10:21:26.253]         if (TRUE) {
[10:21:26.253]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.253]         }
[10:21:26.253]         else {
[10:21:26.253]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.253]         }
[10:21:26.253]         base::close(...future.stdout)
[10:21:26.253]         ...future.stdout <- NULL
[10:21:26.253]     }
[10:21:26.253]     ...future.result$conditions <- ...future.conditions
[10:21:26.253]     ...future.result$finished <- base::Sys.time()
[10:21:26.253]     ...future.result
[10:21:26.253] }
[10:21:26.254] assign_globals() ...
[10:21:26.254] List of 2
[10:21:26.254]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:21:26.254]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:21:26.254]  - attr(*, "where")=List of 2
[10:21:26.254]   ..$ weight:<environment: R_EmptyEnv> 
[10:21:26.254]   ..$ group :<environment: R_EmptyEnv> 
[10:21:26.254]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:26.254]  - attr(*, "resolved")= logi FALSE
[10:21:26.254]  - attr(*, "total_size")= num 401
[10:21:26.254]  - attr(*, "already-done")= logi TRUE
[10:21:26.257] - copied ‘weight’ to environment
[10:21:26.257] - copied ‘group’ to environment
[10:21:26.257] assign_globals() ... done
[10:21:26.258] plan(): Setting new future strategy stack:
[10:21:26.258] List of future strategies:
[10:21:26.258] 1. sequential:
[10:21:26.258]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.258]    - tweaked: FALSE
[10:21:26.258]    - call: NULL
[10:21:26.258] plan(): nbrOfWorkers() = 1
[10:21:26.260] plan(): Setting new future strategy stack:
[10:21:26.260] List of future strategies:
[10:21:26.260] 1. sequential:
[10:21:26.260]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.260]    - tweaked: FALSE
[10:21:26.260]    - call: plan(strategy)
[10:21:26.260] plan(): nbrOfWorkers() = 1
[10:21:26.260] SequentialFuture started (and completed)
[10:21:26.260] - Launch lazy future ... done
[10:21:26.260] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:21:26.263] getGlobalsAndPackages() ...
[10:21:26.263] Searching for globals...
[10:21:26.264] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:21:26.265] Searching for globals ... DONE
[10:21:26.265] Resolving globals: FALSE
[10:21:26.265] The total size of the 2 globals is 401 bytes (401 bytes)
[10:21:26.265] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[10:21:26.265] - globals: [2] ‘weight’, ‘group’
[10:21:26.266] - packages: [1] ‘stats’
[10:21:26.266] getGlobalsAndPackages() ... DONE
[10:21:26.266] run() for ‘Future’ ...
[10:21:26.266] - state: ‘created’
[10:21:26.266] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:26.266] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:26.266] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:26.267]   - Field: ‘label’
[10:21:26.267]   - Field: ‘local’
[10:21:26.267]   - Field: ‘owner’
[10:21:26.267]   - Field: ‘envir’
[10:21:26.267]   - Field: ‘packages’
[10:21:26.267]   - Field: ‘gc’
[10:21:26.267]   - Field: ‘conditions’
[10:21:26.267]   - Field: ‘expr’
[10:21:26.267]   - Field: ‘uuid’
[10:21:26.267]   - Field: ‘seed’
[10:21:26.267]   - Field: ‘version’
[10:21:26.267]   - Field: ‘result’
[10:21:26.268]   - Field: ‘asynchronous’
[10:21:26.268]   - Field: ‘calls’
[10:21:26.268]   - Field: ‘globals’
[10:21:26.268]   - Field: ‘stdout’
[10:21:26.268]   - Field: ‘earlySignal’
[10:21:26.268]   - Field: ‘lazy’
[10:21:26.268]   - Field: ‘state’
[10:21:26.268] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:26.268] - Launch lazy future ...
[10:21:26.268] Packages needed by the future expression (n = 1): ‘stats’
[10:21:26.268] Packages needed by future strategies (n = 0): <none>
[10:21:26.269] {
[10:21:26.269]     {
[10:21:26.269]         {
[10:21:26.269]             ...future.startTime <- base::Sys.time()
[10:21:26.269]             {
[10:21:26.269]                 {
[10:21:26.269]                   {
[10:21:26.269]                     {
[10:21:26.269]                       base::local({
[10:21:26.269]                         has_future <- base::requireNamespace("future", 
[10:21:26.269]                           quietly = TRUE)
[10:21:26.269]                         if (has_future) {
[10:21:26.269]                           ns <- base::getNamespace("future")
[10:21:26.269]                           version <- ns[[".package"]][["version"]]
[10:21:26.269]                           if (is.null(version)) 
[10:21:26.269]                             version <- utils::packageVersion("future")
[10:21:26.269]                         }
[10:21:26.269]                         else {
[10:21:26.269]                           version <- NULL
[10:21:26.269]                         }
[10:21:26.269]                         if (!has_future || version < "1.8.0") {
[10:21:26.269]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.269]                             "", base::R.version$version.string), 
[10:21:26.269]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:26.269]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:26.269]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.269]                               "release", "version")], collapse = " "), 
[10:21:26.269]                             hostname = base::Sys.info()[["nodename"]])
[10:21:26.269]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.269]                             info)
[10:21:26.269]                           info <- base::paste(info, collapse = "; ")
[10:21:26.269]                           if (!has_future) {
[10:21:26.269]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.269]                               info)
[10:21:26.269]                           }
[10:21:26.269]                           else {
[10:21:26.269]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.269]                               info, version)
[10:21:26.269]                           }
[10:21:26.269]                           base::stop(msg)
[10:21:26.269]                         }
[10:21:26.269]                       })
[10:21:26.269]                     }
[10:21:26.269]                     base::local({
[10:21:26.269]                       for (pkg in "stats") {
[10:21:26.269]                         base::loadNamespace(pkg)
[10:21:26.269]                         base::library(pkg, character.only = TRUE)
[10:21:26.269]                       }
[10:21:26.269]                     })
[10:21:26.269]                   }
[10:21:26.269]                   ...future.strategy.old <- future::plan("list")
[10:21:26.269]                   options(future.plan = NULL)
[10:21:26.269]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.269]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.269]                 }
[10:21:26.269]                 ...future.workdir <- getwd()
[10:21:26.269]             }
[10:21:26.269]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.269]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.269]         }
[10:21:26.269]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.269]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.269]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.269]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.269]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.269]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.269]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.269]             base::names(...future.oldOptions))
[10:21:26.269]     }
[10:21:26.269]     if (FALSE) {
[10:21:26.269]     }
[10:21:26.269]     else {
[10:21:26.269]         if (TRUE) {
[10:21:26.269]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.269]                 open = "w")
[10:21:26.269]         }
[10:21:26.269]         else {
[10:21:26.269]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.269]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.269]         }
[10:21:26.269]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.269]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.269]             base::sink(type = "output", split = FALSE)
[10:21:26.269]             base::close(...future.stdout)
[10:21:26.269]         }, add = TRUE)
[10:21:26.269]     }
[10:21:26.269]     ...future.frame <- base::sys.nframe()
[10:21:26.269]     ...future.conditions <- base::list()
[10:21:26.269]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.269]     if (FALSE) {
[10:21:26.269]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.269]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.269]     }
[10:21:26.269]     ...future.result <- base::tryCatch({
[10:21:26.269]         base::withCallingHandlers({
[10:21:26.269]             ...future.value <- base::withVisible(base::local({
[10:21:26.269]                 lm(weight ~ group - 1)
[10:21:26.269]             }))
[10:21:26.269]             future::FutureResult(value = ...future.value$value, 
[10:21:26.269]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.269]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.269]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.269]                     ...future.globalenv.names))
[10:21:26.269]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.269]         }, condition = base::local({
[10:21:26.269]             c <- base::c
[10:21:26.269]             inherits <- base::inherits
[10:21:26.269]             invokeRestart <- base::invokeRestart
[10:21:26.269]             length <- base::length
[10:21:26.269]             list <- base::list
[10:21:26.269]             seq.int <- base::seq.int
[10:21:26.269]             signalCondition <- base::signalCondition
[10:21:26.269]             sys.calls <- base::sys.calls
[10:21:26.269]             `[[` <- base::`[[`
[10:21:26.269]             `+` <- base::`+`
[10:21:26.269]             `<<-` <- base::`<<-`
[10:21:26.269]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.269]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.269]                   3L)]
[10:21:26.269]             }
[10:21:26.269]             function(cond) {
[10:21:26.269]                 is_error <- inherits(cond, "error")
[10:21:26.269]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.269]                   NULL)
[10:21:26.269]                 if (is_error) {
[10:21:26.269]                   sessionInformation <- function() {
[10:21:26.269]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.269]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.269]                       search = base::search(), system = base::Sys.info())
[10:21:26.269]                   }
[10:21:26.269]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.269]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.269]                     cond$call), session = sessionInformation(), 
[10:21:26.269]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.269]                   signalCondition(cond)
[10:21:26.269]                 }
[10:21:26.269]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.269]                 "immediateCondition"))) {
[10:21:26.269]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.269]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.269]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.269]                   if (TRUE && !signal) {
[10:21:26.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.269]                     {
[10:21:26.269]                       inherits <- base::inherits
[10:21:26.269]                       invokeRestart <- base::invokeRestart
[10:21:26.269]                       is.null <- base::is.null
[10:21:26.269]                       muffled <- FALSE
[10:21:26.269]                       if (inherits(cond, "message")) {
[10:21:26.269]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.269]                         if (muffled) 
[10:21:26.269]                           invokeRestart("muffleMessage")
[10:21:26.269]                       }
[10:21:26.269]                       else if (inherits(cond, "warning")) {
[10:21:26.269]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.269]                         if (muffled) 
[10:21:26.269]                           invokeRestart("muffleWarning")
[10:21:26.269]                       }
[10:21:26.269]                       else if (inherits(cond, "condition")) {
[10:21:26.269]                         if (!is.null(pattern)) {
[10:21:26.269]                           computeRestarts <- base::computeRestarts
[10:21:26.269]                           grepl <- base::grepl
[10:21:26.269]                           restarts <- computeRestarts(cond)
[10:21:26.269]                           for (restart in restarts) {
[10:21:26.269]                             name <- restart$name
[10:21:26.269]                             if (is.null(name)) 
[10:21:26.269]                               next
[10:21:26.269]                             if (!grepl(pattern, name)) 
[10:21:26.269]                               next
[10:21:26.269]                             invokeRestart(restart)
[10:21:26.269]                             muffled <- TRUE
[10:21:26.269]                             break
[10:21:26.269]                           }
[10:21:26.269]                         }
[10:21:26.269]                       }
[10:21:26.269]                       invisible(muffled)
[10:21:26.269]                     }
[10:21:26.269]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.269]                   }
[10:21:26.269]                 }
[10:21:26.269]                 else {
[10:21:26.269]                   if (TRUE) {
[10:21:26.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.269]                     {
[10:21:26.269]                       inherits <- base::inherits
[10:21:26.269]                       invokeRestart <- base::invokeRestart
[10:21:26.269]                       is.null <- base::is.null
[10:21:26.269]                       muffled <- FALSE
[10:21:26.269]                       if (inherits(cond, "message")) {
[10:21:26.269]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.269]                         if (muffled) 
[10:21:26.269]                           invokeRestart("muffleMessage")
[10:21:26.269]                       }
[10:21:26.269]                       else if (inherits(cond, "warning")) {
[10:21:26.269]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.269]                         if (muffled) 
[10:21:26.269]                           invokeRestart("muffleWarning")
[10:21:26.269]                       }
[10:21:26.269]                       else if (inherits(cond, "condition")) {
[10:21:26.269]                         if (!is.null(pattern)) {
[10:21:26.269]                           computeRestarts <- base::computeRestarts
[10:21:26.269]                           grepl <- base::grepl
[10:21:26.269]                           restarts <- computeRestarts(cond)
[10:21:26.269]                           for (restart in restarts) {
[10:21:26.269]                             name <- restart$name
[10:21:26.269]                             if (is.null(name)) 
[10:21:26.269]                               next
[10:21:26.269]                             if (!grepl(pattern, name)) 
[10:21:26.269]                               next
[10:21:26.269]                             invokeRestart(restart)
[10:21:26.269]                             muffled <- TRUE
[10:21:26.269]                             break
[10:21:26.269]                           }
[10:21:26.269]                         }
[10:21:26.269]                       }
[10:21:26.269]                       invisible(muffled)
[10:21:26.269]                     }
[10:21:26.269]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.269]                   }
[10:21:26.269]                 }
[10:21:26.269]             }
[10:21:26.269]         }))
[10:21:26.269]     }, error = function(ex) {
[10:21:26.269]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.269]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.269]                 ...future.rng), started = ...future.startTime, 
[10:21:26.269]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.269]             version = "1.8"), class = "FutureResult")
[10:21:26.269]     }, finally = {
[10:21:26.269]         if (!identical(...future.workdir, getwd())) 
[10:21:26.269]             setwd(...future.workdir)
[10:21:26.269]         {
[10:21:26.269]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.269]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.269]             }
[10:21:26.269]             base::options(...future.oldOptions)
[10:21:26.269]             if (.Platform$OS.type == "windows") {
[10:21:26.269]                 old_names <- names(...future.oldEnvVars)
[10:21:26.269]                 envs <- base::Sys.getenv()
[10:21:26.269]                 names <- names(envs)
[10:21:26.269]                 common <- intersect(names, old_names)
[10:21:26.269]                 added <- setdiff(names, old_names)
[10:21:26.269]                 removed <- setdiff(old_names, names)
[10:21:26.269]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.269]                   envs[common]]
[10:21:26.269]                 NAMES <- toupper(changed)
[10:21:26.269]                 args <- list()
[10:21:26.269]                 for (kk in seq_along(NAMES)) {
[10:21:26.269]                   name <- changed[[kk]]
[10:21:26.269]                   NAME <- NAMES[[kk]]
[10:21:26.269]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.269]                     next
[10:21:26.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.269]                 }
[10:21:26.269]                 NAMES <- toupper(added)
[10:21:26.269]                 for (kk in seq_along(NAMES)) {
[10:21:26.269]                   name <- added[[kk]]
[10:21:26.269]                   NAME <- NAMES[[kk]]
[10:21:26.269]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.269]                     next
[10:21:26.269]                   args[[name]] <- ""
[10:21:26.269]                 }
[10:21:26.269]                 NAMES <- toupper(removed)
[10:21:26.269]                 for (kk in seq_along(NAMES)) {
[10:21:26.269]                   name <- removed[[kk]]
[10:21:26.269]                   NAME <- NAMES[[kk]]
[10:21:26.269]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.269]                     next
[10:21:26.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.269]                 }
[10:21:26.269]                 if (length(args) > 0) 
[10:21:26.269]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.269]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.269]             }
[10:21:26.269]             else {
[10:21:26.269]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.269]             }
[10:21:26.269]             {
[10:21:26.269]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.269]                   0L) {
[10:21:26.269]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.269]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.269]                   base::options(opts)
[10:21:26.269]                 }
[10:21:26.269]                 {
[10:21:26.269]                   {
[10:21:26.269]                     NULL
[10:21:26.269]                     RNGkind("Mersenne-Twister")
[10:21:26.269]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:26.269]                       inherits = FALSE)
[10:21:26.269]                   }
[10:21:26.269]                   options(future.plan = NULL)
[10:21:26.269]                   if (is.na(NA_character_)) 
[10:21:26.269]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.269]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.269]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.269]                     .init = FALSE)
[10:21:26.269]                 }
[10:21:26.269]             }
[10:21:26.269]         }
[10:21:26.269]     })
[10:21:26.269]     if (TRUE) {
[10:21:26.269]         base::sink(type = "output", split = FALSE)
[10:21:26.269]         if (TRUE) {
[10:21:26.269]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.269]         }
[10:21:26.269]         else {
[10:21:26.269]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.269]         }
[10:21:26.269]         base::close(...future.stdout)
[10:21:26.269]         ...future.stdout <- NULL
[10:21:26.269]     }
[10:21:26.269]     ...future.result$conditions <- ...future.conditions
[10:21:26.269]     ...future.result$finished <- base::Sys.time()
[10:21:26.269]     ...future.result
[10:21:26.269] }
[10:21:26.270] assign_globals() ...
[10:21:26.271] List of 2
[10:21:26.271]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:21:26.271]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:21:26.271]  - attr(*, "where")=List of 2
[10:21:26.271]   ..$ weight:<environment: R_EmptyEnv> 
[10:21:26.271]   ..$ group :<environment: R_EmptyEnv> 
[10:21:26.271]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:26.271]  - attr(*, "resolved")= logi FALSE
[10:21:26.271]  - attr(*, "total_size")= num 401
[10:21:26.271]  - attr(*, "already-done")= logi TRUE
[10:21:26.273] - copied ‘weight’ to environment
[10:21:26.274] - copied ‘group’ to environment
[10:21:26.274] assign_globals() ... done
[10:21:26.274] plan(): Setting new future strategy stack:
[10:21:26.274] List of future strategies:
[10:21:26.274] 1. sequential:
[10:21:26.274]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.274]    - tweaked: FALSE
[10:21:26.274]    - call: NULL
[10:21:26.274] plan(): nbrOfWorkers() = 1
[10:21:26.276] plan(): Setting new future strategy stack:
[10:21:26.276] List of future strategies:
[10:21:26.276] 1. sequential:
[10:21:26.276]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.276]    - tweaked: FALSE
[10:21:26.276]    - call: plan(strategy)
[10:21:26.276] plan(): nbrOfWorkers() = 1
[10:21:26.276] SequentialFuture started (and completed)
[10:21:26.277] - Launch lazy future ... done
[10:21:26.277] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[10:21:26.278] getGlobalsAndPackages() ...
[10:21:26.278] Searching for globals...
[10:21:26.279] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[10:21:26.279] Searching for globals ... DONE
[10:21:26.279] Resolving globals: FALSE
[10:21:26.280] The total size of the 1 globals is 71 bytes (71 bytes)
[10:21:26.280] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 71 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (71 bytes of class ‘numeric’)
[10:21:26.280] - globals: [1] ‘x’
[10:21:26.280] - packages: [1] ‘stats’
[10:21:26.280] getGlobalsAndPackages() ... DONE
[10:21:26.281] run() for ‘Future’ ...
[10:21:26.281] - state: ‘created’
[10:21:26.281] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:26.281] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:26.281] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:26.281]   - Field: ‘label’
[10:21:26.281]   - Field: ‘local’
[10:21:26.281]   - Field: ‘owner’
[10:21:26.282]   - Field: ‘envir’
[10:21:26.282]   - Field: ‘packages’
[10:21:26.282]   - Field: ‘gc’
[10:21:26.282]   - Field: ‘conditions’
[10:21:26.282]   - Field: ‘expr’
[10:21:26.282]   - Field: ‘uuid’
[10:21:26.282]   - Field: ‘seed’
[10:21:26.282]   - Field: ‘version’
[10:21:26.282]   - Field: ‘result’
[10:21:26.282]   - Field: ‘asynchronous’
[10:21:26.282]   - Field: ‘calls’
[10:21:26.282]   - Field: ‘globals’
[10:21:26.282]   - Field: ‘stdout’
[10:21:26.283]   - Field: ‘earlySignal’
[10:21:26.283]   - Field: ‘lazy’
[10:21:26.283]   - Field: ‘state’
[10:21:26.283] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:26.283] - Launch lazy future ...
[10:21:26.283] Packages needed by the future expression (n = 1): ‘stats’
[10:21:26.284] Packages needed by future strategies (n = 0): <none>
[10:21:26.285] {
[10:21:26.285]     {
[10:21:26.285]         {
[10:21:26.285]             ...future.startTime <- base::Sys.time()
[10:21:26.285]             {
[10:21:26.285]                 {
[10:21:26.285]                   {
[10:21:26.285]                     {
[10:21:26.285]                       base::local({
[10:21:26.285]                         has_future <- base::requireNamespace("future", 
[10:21:26.285]                           quietly = TRUE)
[10:21:26.285]                         if (has_future) {
[10:21:26.285]                           ns <- base::getNamespace("future")
[10:21:26.285]                           version <- ns[[".package"]][["version"]]
[10:21:26.285]                           if (is.null(version)) 
[10:21:26.285]                             version <- utils::packageVersion("future")
[10:21:26.285]                         }
[10:21:26.285]                         else {
[10:21:26.285]                           version <- NULL
[10:21:26.285]                         }
[10:21:26.285]                         if (!has_future || version < "1.8.0") {
[10:21:26.285]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.285]                             "", base::R.version$version.string), 
[10:21:26.285]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:26.285]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:26.285]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.285]                               "release", "version")], collapse = " "), 
[10:21:26.285]                             hostname = base::Sys.info()[["nodename"]])
[10:21:26.285]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.285]                             info)
[10:21:26.285]                           info <- base::paste(info, collapse = "; ")
[10:21:26.285]                           if (!has_future) {
[10:21:26.285]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.285]                               info)
[10:21:26.285]                           }
[10:21:26.285]                           else {
[10:21:26.285]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.285]                               info, version)
[10:21:26.285]                           }
[10:21:26.285]                           base::stop(msg)
[10:21:26.285]                         }
[10:21:26.285]                       })
[10:21:26.285]                     }
[10:21:26.285]                     base::local({
[10:21:26.285]                       for (pkg in "stats") {
[10:21:26.285]                         base::loadNamespace(pkg)
[10:21:26.285]                         base::library(pkg, character.only = TRUE)
[10:21:26.285]                       }
[10:21:26.285]                     })
[10:21:26.285]                   }
[10:21:26.285]                   ...future.strategy.old <- future::plan("list")
[10:21:26.285]                   options(future.plan = NULL)
[10:21:26.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.285]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.285]                 }
[10:21:26.285]                 ...future.workdir <- getwd()
[10:21:26.285]             }
[10:21:26.285]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.285]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.285]         }
[10:21:26.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.285]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.285]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.285]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.285]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.285]             base::names(...future.oldOptions))
[10:21:26.285]     }
[10:21:26.285]     if (FALSE) {
[10:21:26.285]     }
[10:21:26.285]     else {
[10:21:26.285]         if (TRUE) {
[10:21:26.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.285]                 open = "w")
[10:21:26.285]         }
[10:21:26.285]         else {
[10:21:26.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.285]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.285]         }
[10:21:26.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.285]             base::sink(type = "output", split = FALSE)
[10:21:26.285]             base::close(...future.stdout)
[10:21:26.285]         }, add = TRUE)
[10:21:26.285]     }
[10:21:26.285]     ...future.frame <- base::sys.nframe()
[10:21:26.285]     ...future.conditions <- base::list()
[10:21:26.285]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.285]     if (FALSE) {
[10:21:26.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.285]     }
[10:21:26.285]     ...future.result <- base::tryCatch({
[10:21:26.285]         base::withCallingHandlers({
[10:21:26.285]             ...future.value <- base::withVisible(base::local({
[10:21:26.285]                 xtabs(~x)
[10:21:26.285]             }))
[10:21:26.285]             future::FutureResult(value = ...future.value$value, 
[10:21:26.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.285]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.285]                     ...future.globalenv.names))
[10:21:26.285]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.285]         }, condition = base::local({
[10:21:26.285]             c <- base::c
[10:21:26.285]             inherits <- base::inherits
[10:21:26.285]             invokeRestart <- base::invokeRestart
[10:21:26.285]             length <- base::length
[10:21:26.285]             list <- base::list
[10:21:26.285]             seq.int <- base::seq.int
[10:21:26.285]             signalCondition <- base::signalCondition
[10:21:26.285]             sys.calls <- base::sys.calls
[10:21:26.285]             `[[` <- base::`[[`
[10:21:26.285]             `+` <- base::`+`
[10:21:26.285]             `<<-` <- base::`<<-`
[10:21:26.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.285]                   3L)]
[10:21:26.285]             }
[10:21:26.285]             function(cond) {
[10:21:26.285]                 is_error <- inherits(cond, "error")
[10:21:26.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.285]                   NULL)
[10:21:26.285]                 if (is_error) {
[10:21:26.285]                   sessionInformation <- function() {
[10:21:26.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.285]                       search = base::search(), system = base::Sys.info())
[10:21:26.285]                   }
[10:21:26.285]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.285]                     cond$call), session = sessionInformation(), 
[10:21:26.285]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.285]                   signalCondition(cond)
[10:21:26.285]                 }
[10:21:26.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.285]                 "immediateCondition"))) {
[10:21:26.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.285]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.285]                   if (TRUE && !signal) {
[10:21:26.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.285]                     {
[10:21:26.285]                       inherits <- base::inherits
[10:21:26.285]                       invokeRestart <- base::invokeRestart
[10:21:26.285]                       is.null <- base::is.null
[10:21:26.285]                       muffled <- FALSE
[10:21:26.285]                       if (inherits(cond, "message")) {
[10:21:26.285]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.285]                         if (muffled) 
[10:21:26.285]                           invokeRestart("muffleMessage")
[10:21:26.285]                       }
[10:21:26.285]                       else if (inherits(cond, "warning")) {
[10:21:26.285]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.285]                         if (muffled) 
[10:21:26.285]                           invokeRestart("muffleWarning")
[10:21:26.285]                       }
[10:21:26.285]                       else if (inherits(cond, "condition")) {
[10:21:26.285]                         if (!is.null(pattern)) {
[10:21:26.285]                           computeRestarts <- base::computeRestarts
[10:21:26.285]                           grepl <- base::grepl
[10:21:26.285]                           restarts <- computeRestarts(cond)
[10:21:26.285]                           for (restart in restarts) {
[10:21:26.285]                             name <- restart$name
[10:21:26.285]                             if (is.null(name)) 
[10:21:26.285]                               next
[10:21:26.285]                             if (!grepl(pattern, name)) 
[10:21:26.285]                               next
[10:21:26.285]                             invokeRestart(restart)
[10:21:26.285]                             muffled <- TRUE
[10:21:26.285]                             break
[10:21:26.285]                           }
[10:21:26.285]                         }
[10:21:26.285]                       }
[10:21:26.285]                       invisible(muffled)
[10:21:26.285]                     }
[10:21:26.285]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.285]                   }
[10:21:26.285]                 }
[10:21:26.285]                 else {
[10:21:26.285]                   if (TRUE) {
[10:21:26.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.285]                     {
[10:21:26.285]                       inherits <- base::inherits
[10:21:26.285]                       invokeRestart <- base::invokeRestart
[10:21:26.285]                       is.null <- base::is.null
[10:21:26.285]                       muffled <- FALSE
[10:21:26.285]                       if (inherits(cond, "message")) {
[10:21:26.285]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.285]                         if (muffled) 
[10:21:26.285]                           invokeRestart("muffleMessage")
[10:21:26.285]                       }
[10:21:26.285]                       else if (inherits(cond, "warning")) {
[10:21:26.285]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.285]                         if (muffled) 
[10:21:26.285]                           invokeRestart("muffleWarning")
[10:21:26.285]                       }
[10:21:26.285]                       else if (inherits(cond, "condition")) {
[10:21:26.285]                         if (!is.null(pattern)) {
[10:21:26.285]                           computeRestarts <- base::computeRestarts
[10:21:26.285]                           grepl <- base::grepl
[10:21:26.285]                           restarts <- computeRestarts(cond)
[10:21:26.285]                           for (restart in restarts) {
[10:21:26.285]                             name <- restart$name
[10:21:26.285]                             if (is.null(name)) 
[10:21:26.285]                               next
[10:21:26.285]                             if (!grepl(pattern, name)) 
[10:21:26.285]                               next
[10:21:26.285]                             invokeRestart(restart)
[10:21:26.285]                             muffled <- TRUE
[10:21:26.285]                             break
[10:21:26.285]                           }
[10:21:26.285]                         }
[10:21:26.285]                       }
[10:21:26.285]                       invisible(muffled)
[10:21:26.285]                     }
[10:21:26.285]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.285]                   }
[10:21:26.285]                 }
[10:21:26.285]             }
[10:21:26.285]         }))
[10:21:26.285]     }, error = function(ex) {
[10:21:26.285]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.285]                 ...future.rng), started = ...future.startTime, 
[10:21:26.285]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.285]             version = "1.8"), class = "FutureResult")
[10:21:26.285]     }, finally = {
[10:21:26.285]         if (!identical(...future.workdir, getwd())) 
[10:21:26.285]             setwd(...future.workdir)
[10:21:26.285]         {
[10:21:26.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.285]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.285]             }
[10:21:26.285]             base::options(...future.oldOptions)
[10:21:26.285]             if (.Platform$OS.type == "windows") {
[10:21:26.285]                 old_names <- names(...future.oldEnvVars)
[10:21:26.285]                 envs <- base::Sys.getenv()
[10:21:26.285]                 names <- names(envs)
[10:21:26.285]                 common <- intersect(names, old_names)
[10:21:26.285]                 added <- setdiff(names, old_names)
[10:21:26.285]                 removed <- setdiff(old_names, names)
[10:21:26.285]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.285]                   envs[common]]
[10:21:26.285]                 NAMES <- toupper(changed)
[10:21:26.285]                 args <- list()
[10:21:26.285]                 for (kk in seq_along(NAMES)) {
[10:21:26.285]                   name <- changed[[kk]]
[10:21:26.285]                   NAME <- NAMES[[kk]]
[10:21:26.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.285]                     next
[10:21:26.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.285]                 }
[10:21:26.285]                 NAMES <- toupper(added)
[10:21:26.285]                 for (kk in seq_along(NAMES)) {
[10:21:26.285]                   name <- added[[kk]]
[10:21:26.285]                   NAME <- NAMES[[kk]]
[10:21:26.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.285]                     next
[10:21:26.285]                   args[[name]] <- ""
[10:21:26.285]                 }
[10:21:26.285]                 NAMES <- toupper(removed)
[10:21:26.285]                 for (kk in seq_along(NAMES)) {
[10:21:26.285]                   name <- removed[[kk]]
[10:21:26.285]                   NAME <- NAMES[[kk]]
[10:21:26.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.285]                     next
[10:21:26.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.285]                 }
[10:21:26.285]                 if (length(args) > 0) 
[10:21:26.285]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.285]             }
[10:21:26.285]             else {
[10:21:26.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.285]             }
[10:21:26.285]             {
[10:21:26.285]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.285]                   0L) {
[10:21:26.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.285]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.285]                   base::options(opts)
[10:21:26.285]                 }
[10:21:26.285]                 {
[10:21:26.285]                   {
[10:21:26.285]                     NULL
[10:21:26.285]                     RNGkind("Mersenne-Twister")
[10:21:26.285]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:26.285]                       inherits = FALSE)
[10:21:26.285]                   }
[10:21:26.285]                   options(future.plan = NULL)
[10:21:26.285]                   if (is.na(NA_character_)) 
[10:21:26.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.285]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.285]                     .init = FALSE)
[10:21:26.285]                 }
[10:21:26.285]             }
[10:21:26.285]         }
[10:21:26.285]     })
[10:21:26.285]     if (TRUE) {
[10:21:26.285]         base::sink(type = "output", split = FALSE)
[10:21:26.285]         if (TRUE) {
[10:21:26.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.285]         }
[10:21:26.285]         else {
[10:21:26.285]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.285]         }
[10:21:26.285]         base::close(...future.stdout)
[10:21:26.285]         ...future.stdout <- NULL
[10:21:26.285]     }
[10:21:26.285]     ...future.result$conditions <- ...future.conditions
[10:21:26.285]     ...future.result$finished <- base::Sys.time()
[10:21:26.285]     ...future.result
[10:21:26.285] }
[10:21:26.286] assign_globals() ...
[10:21:26.286] List of 1
[10:21:26.286]  $ x: num [1:5] 1 1 2 2 2
[10:21:26.286]  - attr(*, "where")=List of 1
[10:21:26.286]   ..$ x:<environment: R_EmptyEnv> 
[10:21:26.286]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:26.286]  - attr(*, "resolved")= logi FALSE
[10:21:26.286]  - attr(*, "total_size")= num 71
[10:21:26.286]  - attr(*, "already-done")= logi TRUE
[10:21:26.289] - copied ‘x’ to environment
[10:21:26.289] assign_globals() ... done
[10:21:26.289] plan(): Setting new future strategy stack:
[10:21:26.289] List of future strategies:
[10:21:26.289] 1. sequential:
[10:21:26.289]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.289]    - tweaked: FALSE
[10:21:26.289]    - call: NULL
[10:21:26.289] plan(): nbrOfWorkers() = 1
[10:21:26.290] plan(): Setting new future strategy stack:
[10:21:26.290] List of future strategies:
[10:21:26.290] 1. sequential:
[10:21:26.290]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.290]    - tweaked: FALSE
[10:21:26.290]    - call: plan(strategy)
[10:21:26.291] plan(): nbrOfWorkers() = 1
[10:21:26.291] SequentialFuture started (and completed)
[10:21:26.291] - Launch lazy future ... done
[10:21:26.291] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
[10:21:26.292] getGlobalsAndPackages() ...
[10:21:26.292] Searching for globals...
[10:21:26.293] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[10:21:26.293] Searching for globals ... DONE
[10:21:26.293] Resolving globals: FALSE
[10:21:26.294] The total size of the 1 globals is 71 bytes (71 bytes)
[10:21:26.294] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 71 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (71 bytes of class ‘numeric’)
[10:21:26.294] - globals: [1] ‘x’
[10:21:26.294] - packages: [1] ‘stats’
[10:21:26.294] getGlobalsAndPackages() ... DONE
[10:21:26.294] run() for ‘Future’ ...
[10:21:26.294] - state: ‘created’
[10:21:26.295] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:26.295] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:26.295] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:26.295]   - Field: ‘label’
[10:21:26.295]   - Field: ‘local’
[10:21:26.295]   - Field: ‘owner’
[10:21:26.295]   - Field: ‘envir’
[10:21:26.295]   - Field: ‘packages’
[10:21:26.295]   - Field: ‘gc’
[10:21:26.296]   - Field: ‘conditions’
[10:21:26.296]   - Field: ‘expr’
[10:21:26.296]   - Field: ‘uuid’
[10:21:26.296]   - Field: ‘seed’
[10:21:26.296]   - Field: ‘version’
[10:21:26.296]   - Field: ‘result’
[10:21:26.296]   - Field: ‘asynchronous’
[10:21:26.296]   - Field: ‘calls’
[10:21:26.296]   - Field: ‘globals’
[10:21:26.296]   - Field: ‘stdout’
[10:21:26.296]   - Field: ‘earlySignal’
[10:21:26.296]   - Field: ‘lazy’
[10:21:26.296]   - Field: ‘state’
[10:21:26.297] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:26.297] - Launch lazy future ...
[10:21:26.297] Packages needed by the future expression (n = 1): ‘stats’
[10:21:26.297] Packages needed by future strategies (n = 0): <none>
[10:21:26.297] {
[10:21:26.297]     {
[10:21:26.297]         {
[10:21:26.297]             ...future.startTime <- base::Sys.time()
[10:21:26.297]             {
[10:21:26.297]                 {
[10:21:26.297]                   {
[10:21:26.297]                     {
[10:21:26.297]                       base::local({
[10:21:26.297]                         has_future <- base::requireNamespace("future", 
[10:21:26.297]                           quietly = TRUE)
[10:21:26.297]                         if (has_future) {
[10:21:26.297]                           ns <- base::getNamespace("future")
[10:21:26.297]                           version <- ns[[".package"]][["version"]]
[10:21:26.297]                           if (is.null(version)) 
[10:21:26.297]                             version <- utils::packageVersion("future")
[10:21:26.297]                         }
[10:21:26.297]                         else {
[10:21:26.297]                           version <- NULL
[10:21:26.297]                         }
[10:21:26.297]                         if (!has_future || version < "1.8.0") {
[10:21:26.297]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.297]                             "", base::R.version$version.string), 
[10:21:26.297]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:26.297]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:26.297]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.297]                               "release", "version")], collapse = " "), 
[10:21:26.297]                             hostname = base::Sys.info()[["nodename"]])
[10:21:26.297]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.297]                             info)
[10:21:26.297]                           info <- base::paste(info, collapse = "; ")
[10:21:26.297]                           if (!has_future) {
[10:21:26.297]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.297]                               info)
[10:21:26.297]                           }
[10:21:26.297]                           else {
[10:21:26.297]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.297]                               info, version)
[10:21:26.297]                           }
[10:21:26.297]                           base::stop(msg)
[10:21:26.297]                         }
[10:21:26.297]                       })
[10:21:26.297]                     }
[10:21:26.297]                     base::local({
[10:21:26.297]                       for (pkg in "stats") {
[10:21:26.297]                         base::loadNamespace(pkg)
[10:21:26.297]                         base::library(pkg, character.only = TRUE)
[10:21:26.297]                       }
[10:21:26.297]                     })
[10:21:26.297]                   }
[10:21:26.297]                   ...future.strategy.old <- future::plan("list")
[10:21:26.297]                   options(future.plan = NULL)
[10:21:26.297]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.297]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.297]                 }
[10:21:26.297]                 ...future.workdir <- getwd()
[10:21:26.297]             }
[10:21:26.297]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.297]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.297]         }
[10:21:26.297]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.297]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.297]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.297]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.297]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.297]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.297]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.297]             base::names(...future.oldOptions))
[10:21:26.297]     }
[10:21:26.297]     if (FALSE) {
[10:21:26.297]     }
[10:21:26.297]     else {
[10:21:26.297]         if (TRUE) {
[10:21:26.297]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.297]                 open = "w")
[10:21:26.297]         }
[10:21:26.297]         else {
[10:21:26.297]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.297]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.297]         }
[10:21:26.297]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.297]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.297]             base::sink(type = "output", split = FALSE)
[10:21:26.297]             base::close(...future.stdout)
[10:21:26.297]         }, add = TRUE)
[10:21:26.297]     }
[10:21:26.297]     ...future.frame <- base::sys.nframe()
[10:21:26.297]     ...future.conditions <- base::list()
[10:21:26.297]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.297]     if (FALSE) {
[10:21:26.297]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.297]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.297]     }
[10:21:26.297]     ...future.result <- base::tryCatch({
[10:21:26.297]         base::withCallingHandlers({
[10:21:26.297]             ...future.value <- base::withVisible(base::local({
[10:21:26.297]                 xtabs(~x)
[10:21:26.297]             }))
[10:21:26.297]             future::FutureResult(value = ...future.value$value, 
[10:21:26.297]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.297]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.297]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.297]                     ...future.globalenv.names))
[10:21:26.297]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.297]         }, condition = base::local({
[10:21:26.297]             c <- base::c
[10:21:26.297]             inherits <- base::inherits
[10:21:26.297]             invokeRestart <- base::invokeRestart
[10:21:26.297]             length <- base::length
[10:21:26.297]             list <- base::list
[10:21:26.297]             seq.int <- base::seq.int
[10:21:26.297]             signalCondition <- base::signalCondition
[10:21:26.297]             sys.calls <- base::sys.calls
[10:21:26.297]             `[[` <- base::`[[`
[10:21:26.297]             `+` <- base::`+`
[10:21:26.297]             `<<-` <- base::`<<-`
[10:21:26.297]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.297]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.297]                   3L)]
[10:21:26.297]             }
[10:21:26.297]             function(cond) {
[10:21:26.297]                 is_error <- inherits(cond, "error")
[10:21:26.297]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.297]                   NULL)
[10:21:26.297]                 if (is_error) {
[10:21:26.297]                   sessionInformation <- function() {
[10:21:26.297]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.297]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.297]                       search = base::search(), system = base::Sys.info())
[10:21:26.297]                   }
[10:21:26.297]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.297]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.297]                     cond$call), session = sessionInformation(), 
[10:21:26.297]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.297]                   signalCondition(cond)
[10:21:26.297]                 }
[10:21:26.297]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.297]                 "immediateCondition"))) {
[10:21:26.297]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.297]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.297]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.297]                   if (TRUE && !signal) {
[10:21:26.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.297]                     {
[10:21:26.297]                       inherits <- base::inherits
[10:21:26.297]                       invokeRestart <- base::invokeRestart
[10:21:26.297]                       is.null <- base::is.null
[10:21:26.297]                       muffled <- FALSE
[10:21:26.297]                       if (inherits(cond, "message")) {
[10:21:26.297]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.297]                         if (muffled) 
[10:21:26.297]                           invokeRestart("muffleMessage")
[10:21:26.297]                       }
[10:21:26.297]                       else if (inherits(cond, "warning")) {
[10:21:26.297]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.297]                         if (muffled) 
[10:21:26.297]                           invokeRestart("muffleWarning")
[10:21:26.297]                       }
[10:21:26.297]                       else if (inherits(cond, "condition")) {
[10:21:26.297]                         if (!is.null(pattern)) {
[10:21:26.297]                           computeRestarts <- base::computeRestarts
[10:21:26.297]                           grepl <- base::grepl
[10:21:26.297]                           restarts <- computeRestarts(cond)
[10:21:26.297]                           for (restart in restarts) {
[10:21:26.297]                             name <- restart$name
[10:21:26.297]                             if (is.null(name)) 
[10:21:26.297]                               next
[10:21:26.297]                             if (!grepl(pattern, name)) 
[10:21:26.297]                               next
[10:21:26.297]                             invokeRestart(restart)
[10:21:26.297]                             muffled <- TRUE
[10:21:26.297]                             break
[10:21:26.297]                           }
[10:21:26.297]                         }
[10:21:26.297]                       }
[10:21:26.297]                       invisible(muffled)
[10:21:26.297]                     }
[10:21:26.297]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.297]                   }
[10:21:26.297]                 }
[10:21:26.297]                 else {
[10:21:26.297]                   if (TRUE) {
[10:21:26.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.297]                     {
[10:21:26.297]                       inherits <- base::inherits
[10:21:26.297]                       invokeRestart <- base::invokeRestart
[10:21:26.297]                       is.null <- base::is.null
[10:21:26.297]                       muffled <- FALSE
[10:21:26.297]                       if (inherits(cond, "message")) {
[10:21:26.297]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.297]                         if (muffled) 
[10:21:26.297]                           invokeRestart("muffleMessage")
[10:21:26.297]                       }
[10:21:26.297]                       else if (inherits(cond, "warning")) {
[10:21:26.297]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.297]                         if (muffled) 
[10:21:26.297]                           invokeRestart("muffleWarning")
[10:21:26.297]                       }
[10:21:26.297]                       else if (inherits(cond, "condition")) {
[10:21:26.297]                         if (!is.null(pattern)) {
[10:21:26.297]                           computeRestarts <- base::computeRestarts
[10:21:26.297]                           grepl <- base::grepl
[10:21:26.297]                           restarts <- computeRestarts(cond)
[10:21:26.297]                           for (restart in restarts) {
[10:21:26.297]                             name <- restart$name
[10:21:26.297]                             if (is.null(name)) 
[10:21:26.297]                               next
[10:21:26.297]                             if (!grepl(pattern, name)) 
[10:21:26.297]                               next
[10:21:26.297]                             invokeRestart(restart)
[10:21:26.297]                             muffled <- TRUE
[10:21:26.297]                             break
[10:21:26.297]                           }
[10:21:26.297]                         }
[10:21:26.297]                       }
[10:21:26.297]                       invisible(muffled)
[10:21:26.297]                     }
[10:21:26.297]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.297]                   }
[10:21:26.297]                 }
[10:21:26.297]             }
[10:21:26.297]         }))
[10:21:26.297]     }, error = function(ex) {
[10:21:26.297]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.297]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.297]                 ...future.rng), started = ...future.startTime, 
[10:21:26.297]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.297]             version = "1.8"), class = "FutureResult")
[10:21:26.297]     }, finally = {
[10:21:26.297]         if (!identical(...future.workdir, getwd())) 
[10:21:26.297]             setwd(...future.workdir)
[10:21:26.297]         {
[10:21:26.297]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.297]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.297]             }
[10:21:26.297]             base::options(...future.oldOptions)
[10:21:26.297]             if (.Platform$OS.type == "windows") {
[10:21:26.297]                 old_names <- names(...future.oldEnvVars)
[10:21:26.297]                 envs <- base::Sys.getenv()
[10:21:26.297]                 names <- names(envs)
[10:21:26.297]                 common <- intersect(names, old_names)
[10:21:26.297]                 added <- setdiff(names, old_names)
[10:21:26.297]                 removed <- setdiff(old_names, names)
[10:21:26.297]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.297]                   envs[common]]
[10:21:26.297]                 NAMES <- toupper(changed)
[10:21:26.297]                 args <- list()
[10:21:26.297]                 for (kk in seq_along(NAMES)) {
[10:21:26.297]                   name <- changed[[kk]]
[10:21:26.297]                   NAME <- NAMES[[kk]]
[10:21:26.297]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.297]                     next
[10:21:26.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.297]                 }
[10:21:26.297]                 NAMES <- toupper(added)
[10:21:26.297]                 for (kk in seq_along(NAMES)) {
[10:21:26.297]                   name <- added[[kk]]
[10:21:26.297]                   NAME <- NAMES[[kk]]
[10:21:26.297]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.297]                     next
[10:21:26.297]                   args[[name]] <- ""
[10:21:26.297]                 }
[10:21:26.297]                 NAMES <- toupper(removed)
[10:21:26.297]                 for (kk in seq_along(NAMES)) {
[10:21:26.297]                   name <- removed[[kk]]
[10:21:26.297]                   NAME <- NAMES[[kk]]
[10:21:26.297]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.297]                     next
[10:21:26.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.297]                 }
[10:21:26.297]                 if (length(args) > 0) 
[10:21:26.297]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.297]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.297]             }
[10:21:26.297]             else {
[10:21:26.297]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.297]             }
[10:21:26.297]             {
[10:21:26.297]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.297]                   0L) {
[10:21:26.297]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.297]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.297]                   base::options(opts)
[10:21:26.297]                 }
[10:21:26.297]                 {
[10:21:26.297]                   {
[10:21:26.297]                     NULL
[10:21:26.297]                     RNGkind("Mersenne-Twister")
[10:21:26.297]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:26.297]                       inherits = FALSE)
[10:21:26.297]                   }
[10:21:26.297]                   options(future.plan = NULL)
[10:21:26.297]                   if (is.na(NA_character_)) 
[10:21:26.297]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.297]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.297]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.297]                     .init = FALSE)
[10:21:26.297]                 }
[10:21:26.297]             }
[10:21:26.297]         }
[10:21:26.297]     })
[10:21:26.297]     if (TRUE) {
[10:21:26.297]         base::sink(type = "output", split = FALSE)
[10:21:26.297]         if (TRUE) {
[10:21:26.297]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.297]         }
[10:21:26.297]         else {
[10:21:26.297]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.297]         }
[10:21:26.297]         base::close(...future.stdout)
[10:21:26.297]         ...future.stdout <- NULL
[10:21:26.297]     }
[10:21:26.297]     ...future.result$conditions <- ...future.conditions
[10:21:26.297]     ...future.result$finished <- base::Sys.time()
[10:21:26.297]     ...future.result
[10:21:26.297] }
[10:21:26.299] assign_globals() ...
[10:21:26.299] List of 1
[10:21:26.299]  $ x: num [1:5] 1 1 2 2 2
[10:21:26.299]  - attr(*, "where")=List of 1
[10:21:26.299]   ..$ x:<environment: R_EmptyEnv> 
[10:21:26.299]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:26.299]  - attr(*, "resolved")= logi FALSE
[10:21:26.299]  - attr(*, "total_size")= num 71
[10:21:26.299]  - attr(*, "already-done")= logi TRUE
[10:21:26.301] - copied ‘x’ to environment
[10:21:26.301] assign_globals() ... done
[10:21:26.302] plan(): Setting new future strategy stack:
[10:21:26.302] List of future strategies:
[10:21:26.302] 1. sequential:
[10:21:26.302]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.302]    - tweaked: FALSE
[10:21:26.302]    - call: NULL
[10:21:26.302] plan(): nbrOfWorkers() = 1
[10:21:26.303] plan(): Setting new future strategy stack:
[10:21:26.303] List of future strategies:
[10:21:26.303] 1. sequential:
[10:21:26.303]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.303]    - tweaked: FALSE
[10:21:26.303]    - call: plan(strategy)
[10:21:26.304] plan(): nbrOfWorkers() = 1
[10:21:26.304] SequentialFuture started (and completed)
[10:21:26.304] - Launch lazy future ... done
[10:21:26.304] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[10:21:26.306] getGlobalsAndPackages() ...
[10:21:26.306] Searching for globals...
[10:21:26.307] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[10:21:26.307] Searching for globals ... DONE
[10:21:26.308] Resolving globals: FALSE
[10:21:26.308] 
[10:21:26.308] - packages: [2] ‘stats’, ‘datasets’
[10:21:26.309] getGlobalsAndPackages() ... DONE
[10:21:26.310] run() for ‘Future’ ...
[10:21:26.310] - state: ‘created’
[10:21:26.310] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:26.310] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:26.310] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:26.310]   - Field: ‘label’
[10:21:26.310]   - Field: ‘local’
[10:21:26.310]   - Field: ‘owner’
[10:21:26.310]   - Field: ‘envir’
[10:21:26.311]   - Field: ‘packages’
[10:21:26.311]   - Field: ‘gc’
[10:21:26.311]   - Field: ‘conditions’
[10:21:26.311]   - Field: ‘expr’
[10:21:26.311]   - Field: ‘uuid’
[10:21:26.311]   - Field: ‘seed’
[10:21:26.311]   - Field: ‘version’
[10:21:26.311]   - Field: ‘result’
[10:21:26.311]   - Field: ‘asynchronous’
[10:21:26.311]   - Field: ‘calls’
[10:21:26.311]   - Field: ‘globals’
[10:21:26.311]   - Field: ‘stdout’
[10:21:26.312]   - Field: ‘earlySignal’
[10:21:26.312]   - Field: ‘lazy’
[10:21:26.312]   - Field: ‘state’
[10:21:26.312] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:26.312] - Launch lazy future ...
[10:21:26.312] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:21:26.312] Packages needed by future strategies (n = 0): <none>
[10:21:26.313] {
[10:21:26.313]     {
[10:21:26.313]         {
[10:21:26.313]             ...future.startTime <- base::Sys.time()
[10:21:26.313]             {
[10:21:26.313]                 {
[10:21:26.313]                   {
[10:21:26.313]                     {
[10:21:26.313]                       base::local({
[10:21:26.313]                         has_future <- base::requireNamespace("future", 
[10:21:26.313]                           quietly = TRUE)
[10:21:26.313]                         if (has_future) {
[10:21:26.313]                           ns <- base::getNamespace("future")
[10:21:26.313]                           version <- ns[[".package"]][["version"]]
[10:21:26.313]                           if (is.null(version)) 
[10:21:26.313]                             version <- utils::packageVersion("future")
[10:21:26.313]                         }
[10:21:26.313]                         else {
[10:21:26.313]                           version <- NULL
[10:21:26.313]                         }
[10:21:26.313]                         if (!has_future || version < "1.8.0") {
[10:21:26.313]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.313]                             "", base::R.version$version.string), 
[10:21:26.313]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:26.313]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:26.313]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.313]                               "release", "version")], collapse = " "), 
[10:21:26.313]                             hostname = base::Sys.info()[["nodename"]])
[10:21:26.313]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.313]                             info)
[10:21:26.313]                           info <- base::paste(info, collapse = "; ")
[10:21:26.313]                           if (!has_future) {
[10:21:26.313]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.313]                               info)
[10:21:26.313]                           }
[10:21:26.313]                           else {
[10:21:26.313]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.313]                               info, version)
[10:21:26.313]                           }
[10:21:26.313]                           base::stop(msg)
[10:21:26.313]                         }
[10:21:26.313]                       })
[10:21:26.313]                     }
[10:21:26.313]                     base::local({
[10:21:26.313]                       for (pkg in c("stats", "datasets")) {
[10:21:26.313]                         base::loadNamespace(pkg)
[10:21:26.313]                         base::library(pkg, character.only = TRUE)
[10:21:26.313]                       }
[10:21:26.313]                     })
[10:21:26.313]                   }
[10:21:26.313]                   ...future.strategy.old <- future::plan("list")
[10:21:26.313]                   options(future.plan = NULL)
[10:21:26.313]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.313]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.313]                 }
[10:21:26.313]                 ...future.workdir <- getwd()
[10:21:26.313]             }
[10:21:26.313]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.313]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.313]         }
[10:21:26.313]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.313]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.313]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.313]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.313]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.313]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.313]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.313]             base::names(...future.oldOptions))
[10:21:26.313]     }
[10:21:26.313]     if (FALSE) {
[10:21:26.313]     }
[10:21:26.313]     else {
[10:21:26.313]         if (TRUE) {
[10:21:26.313]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.313]                 open = "w")
[10:21:26.313]         }
[10:21:26.313]         else {
[10:21:26.313]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.313]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.313]         }
[10:21:26.313]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.313]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.313]             base::sink(type = "output", split = FALSE)
[10:21:26.313]             base::close(...future.stdout)
[10:21:26.313]         }, add = TRUE)
[10:21:26.313]     }
[10:21:26.313]     ...future.frame <- base::sys.nframe()
[10:21:26.313]     ...future.conditions <- base::list()
[10:21:26.313]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.313]     if (FALSE) {
[10:21:26.313]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.313]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.313]     }
[10:21:26.313]     ...future.result <- base::tryCatch({
[10:21:26.313]         base::withCallingHandlers({
[10:21:26.313]             ...future.value <- base::withVisible(base::local({
[10:21:26.313]                 lm(dist ~ . - 1, data = cars)
[10:21:26.313]             }))
[10:21:26.313]             future::FutureResult(value = ...future.value$value, 
[10:21:26.313]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.313]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.313]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.313]                     ...future.globalenv.names))
[10:21:26.313]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.313]         }, condition = base::local({
[10:21:26.313]             c <- base::c
[10:21:26.313]             inherits <- base::inherits
[10:21:26.313]             invokeRestart <- base::invokeRestart
[10:21:26.313]             length <- base::length
[10:21:26.313]             list <- base::list
[10:21:26.313]             seq.int <- base::seq.int
[10:21:26.313]             signalCondition <- base::signalCondition
[10:21:26.313]             sys.calls <- base::sys.calls
[10:21:26.313]             `[[` <- base::`[[`
[10:21:26.313]             `+` <- base::`+`
[10:21:26.313]             `<<-` <- base::`<<-`
[10:21:26.313]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.313]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.313]                   3L)]
[10:21:26.313]             }
[10:21:26.313]             function(cond) {
[10:21:26.313]                 is_error <- inherits(cond, "error")
[10:21:26.313]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.313]                   NULL)
[10:21:26.313]                 if (is_error) {
[10:21:26.313]                   sessionInformation <- function() {
[10:21:26.313]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.313]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.313]                       search = base::search(), system = base::Sys.info())
[10:21:26.313]                   }
[10:21:26.313]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.313]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.313]                     cond$call), session = sessionInformation(), 
[10:21:26.313]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.313]                   signalCondition(cond)
[10:21:26.313]                 }
[10:21:26.313]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.313]                 "immediateCondition"))) {
[10:21:26.313]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.313]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.313]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.313]                   if (TRUE && !signal) {
[10:21:26.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.313]                     {
[10:21:26.313]                       inherits <- base::inherits
[10:21:26.313]                       invokeRestart <- base::invokeRestart
[10:21:26.313]                       is.null <- base::is.null
[10:21:26.313]                       muffled <- FALSE
[10:21:26.313]                       if (inherits(cond, "message")) {
[10:21:26.313]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.313]                         if (muffled) 
[10:21:26.313]                           invokeRestart("muffleMessage")
[10:21:26.313]                       }
[10:21:26.313]                       else if (inherits(cond, "warning")) {
[10:21:26.313]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.313]                         if (muffled) 
[10:21:26.313]                           invokeRestart("muffleWarning")
[10:21:26.313]                       }
[10:21:26.313]                       else if (inherits(cond, "condition")) {
[10:21:26.313]                         if (!is.null(pattern)) {
[10:21:26.313]                           computeRestarts <- base::computeRestarts
[10:21:26.313]                           grepl <- base::grepl
[10:21:26.313]                           restarts <- computeRestarts(cond)
[10:21:26.313]                           for (restart in restarts) {
[10:21:26.313]                             name <- restart$name
[10:21:26.313]                             if (is.null(name)) 
[10:21:26.313]                               next
[10:21:26.313]                             if (!grepl(pattern, name)) 
[10:21:26.313]                               next
[10:21:26.313]                             invokeRestart(restart)
[10:21:26.313]                             muffled <- TRUE
[10:21:26.313]                             break
[10:21:26.313]                           }
[10:21:26.313]                         }
[10:21:26.313]                       }
[10:21:26.313]                       invisible(muffled)
[10:21:26.313]                     }
[10:21:26.313]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.313]                   }
[10:21:26.313]                 }
[10:21:26.313]                 else {
[10:21:26.313]                   if (TRUE) {
[10:21:26.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.313]                     {
[10:21:26.313]                       inherits <- base::inherits
[10:21:26.313]                       invokeRestart <- base::invokeRestart
[10:21:26.313]                       is.null <- base::is.null
[10:21:26.313]                       muffled <- FALSE
[10:21:26.313]                       if (inherits(cond, "message")) {
[10:21:26.313]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.313]                         if (muffled) 
[10:21:26.313]                           invokeRestart("muffleMessage")
[10:21:26.313]                       }
[10:21:26.313]                       else if (inherits(cond, "warning")) {
[10:21:26.313]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.313]                         if (muffled) 
[10:21:26.313]                           invokeRestart("muffleWarning")
[10:21:26.313]                       }
[10:21:26.313]                       else if (inherits(cond, "condition")) {
[10:21:26.313]                         if (!is.null(pattern)) {
[10:21:26.313]                           computeRestarts <- base::computeRestarts
[10:21:26.313]                           grepl <- base::grepl
[10:21:26.313]                           restarts <- computeRestarts(cond)
[10:21:26.313]                           for (restart in restarts) {
[10:21:26.313]                             name <- restart$name
[10:21:26.313]                             if (is.null(name)) 
[10:21:26.313]                               next
[10:21:26.313]                             if (!grepl(pattern, name)) 
[10:21:26.313]                               next
[10:21:26.313]                             invokeRestart(restart)
[10:21:26.313]                             muffled <- TRUE
[10:21:26.313]                             break
[10:21:26.313]                           }
[10:21:26.313]                         }
[10:21:26.313]                       }
[10:21:26.313]                       invisible(muffled)
[10:21:26.313]                     }
[10:21:26.313]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.313]                   }
[10:21:26.313]                 }
[10:21:26.313]             }
[10:21:26.313]         }))
[10:21:26.313]     }, error = function(ex) {
[10:21:26.313]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.313]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.313]                 ...future.rng), started = ...future.startTime, 
[10:21:26.313]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.313]             version = "1.8"), class = "FutureResult")
[10:21:26.313]     }, finally = {
[10:21:26.313]         if (!identical(...future.workdir, getwd())) 
[10:21:26.313]             setwd(...future.workdir)
[10:21:26.313]         {
[10:21:26.313]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.313]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.313]             }
[10:21:26.313]             base::options(...future.oldOptions)
[10:21:26.313]             if (.Platform$OS.type == "windows") {
[10:21:26.313]                 old_names <- names(...future.oldEnvVars)
[10:21:26.313]                 envs <- base::Sys.getenv()
[10:21:26.313]                 names <- names(envs)
[10:21:26.313]                 common <- intersect(names, old_names)
[10:21:26.313]                 added <- setdiff(names, old_names)
[10:21:26.313]                 removed <- setdiff(old_names, names)
[10:21:26.313]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.313]                   envs[common]]
[10:21:26.313]                 NAMES <- toupper(changed)
[10:21:26.313]                 args <- list()
[10:21:26.313]                 for (kk in seq_along(NAMES)) {
[10:21:26.313]                   name <- changed[[kk]]
[10:21:26.313]                   NAME <- NAMES[[kk]]
[10:21:26.313]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.313]                     next
[10:21:26.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.313]                 }
[10:21:26.313]                 NAMES <- toupper(added)
[10:21:26.313]                 for (kk in seq_along(NAMES)) {
[10:21:26.313]                   name <- added[[kk]]
[10:21:26.313]                   NAME <- NAMES[[kk]]
[10:21:26.313]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.313]                     next
[10:21:26.313]                   args[[name]] <- ""
[10:21:26.313]                 }
[10:21:26.313]                 NAMES <- toupper(removed)
[10:21:26.313]                 for (kk in seq_along(NAMES)) {
[10:21:26.313]                   name <- removed[[kk]]
[10:21:26.313]                   NAME <- NAMES[[kk]]
[10:21:26.313]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.313]                     next
[10:21:26.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.313]                 }
[10:21:26.313]                 if (length(args) > 0) 
[10:21:26.313]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.313]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.313]             }
[10:21:26.313]             else {
[10:21:26.313]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.313]             }
[10:21:26.313]             {
[10:21:26.313]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.313]                   0L) {
[10:21:26.313]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.313]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.313]                   base::options(opts)
[10:21:26.313]                 }
[10:21:26.313]                 {
[10:21:26.313]                   {
[10:21:26.313]                     NULL
[10:21:26.313]                     RNGkind("Mersenne-Twister")
[10:21:26.313]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:26.313]                       inherits = FALSE)
[10:21:26.313]                   }
[10:21:26.313]                   options(future.plan = NULL)
[10:21:26.313]                   if (is.na(NA_character_)) 
[10:21:26.313]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.313]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.313]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.313]                     .init = FALSE)
[10:21:26.313]                 }
[10:21:26.313]             }
[10:21:26.313]         }
[10:21:26.313]     })
[10:21:26.313]     if (TRUE) {
[10:21:26.313]         base::sink(type = "output", split = FALSE)
[10:21:26.313]         if (TRUE) {
[10:21:26.313]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.313]         }
[10:21:26.313]         else {
[10:21:26.313]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.313]         }
[10:21:26.313]         base::close(...future.stdout)
[10:21:26.313]         ...future.stdout <- NULL
[10:21:26.313]     }
[10:21:26.313]     ...future.result$conditions <- ...future.conditions
[10:21:26.313]     ...future.result$finished <- base::Sys.time()
[10:21:26.313]     ...future.result
[10:21:26.313] }
[10:21:26.315] plan(): Setting new future strategy stack:
[10:21:26.315] List of future strategies:
[10:21:26.315] 1. sequential:
[10:21:26.315]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.315]    - tweaked: FALSE
[10:21:26.315]    - call: NULL
[10:21:26.315] plan(): nbrOfWorkers() = 1
[10:21:26.316] plan(): Setting new future strategy stack:
[10:21:26.316] List of future strategies:
[10:21:26.316] 1. sequential:
[10:21:26.316]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.316]    - tweaked: FALSE
[10:21:26.316]    - call: plan(strategy)
[10:21:26.317] plan(): nbrOfWorkers() = 1
[10:21:26.317] SequentialFuture started (and completed)
[10:21:26.317] - Launch lazy future ... done
[10:21:26.317] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[10:21:26.319] getGlobalsAndPackages() ...
[10:21:26.319] Searching for globals...
[10:21:26.321] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[10:21:26.321] Searching for globals ... DONE
[10:21:26.321] Resolving globals: FALSE
[10:21:26.321] 
[10:21:26.322] - packages: [2] ‘stats’, ‘datasets’
[10:21:26.322] getGlobalsAndPackages() ... DONE
[10:21:26.322] run() for ‘Future’ ...
[10:21:26.322] - state: ‘created’
[10:21:26.322] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:26.322] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:26.322] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:26.322]   - Field: ‘label’
[10:21:26.323]   - Field: ‘local’
[10:21:26.323]   - Field: ‘owner’
[10:21:26.323]   - Field: ‘envir’
[10:21:26.323]   - Field: ‘packages’
[10:21:26.323]   - Field: ‘gc’
[10:21:26.323]   - Field: ‘conditions’
[10:21:26.323]   - Field: ‘expr’
[10:21:26.323]   - Field: ‘uuid’
[10:21:26.323]   - Field: ‘seed’
[10:21:26.323]   - Field: ‘version’
[10:21:26.323]   - Field: ‘result’
[10:21:26.323]   - Field: ‘asynchronous’
[10:21:26.324]   - Field: ‘calls’
[10:21:26.324]   - Field: ‘globals’
[10:21:26.324]   - Field: ‘stdout’
[10:21:26.324]   - Field: ‘earlySignal’
[10:21:26.324]   - Field: ‘lazy’
[10:21:26.324]   - Field: ‘state’
[10:21:26.324] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:26.324] - Launch lazy future ...
[10:21:26.324] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:21:26.324] Packages needed by future strategies (n = 0): <none>
[10:21:26.325] {
[10:21:26.325]     {
[10:21:26.325]         {
[10:21:26.325]             ...future.startTime <- base::Sys.time()
[10:21:26.325]             {
[10:21:26.325]                 {
[10:21:26.325]                   {
[10:21:26.325]                     {
[10:21:26.325]                       base::local({
[10:21:26.325]                         has_future <- base::requireNamespace("future", 
[10:21:26.325]                           quietly = TRUE)
[10:21:26.325]                         if (has_future) {
[10:21:26.325]                           ns <- base::getNamespace("future")
[10:21:26.325]                           version <- ns[[".package"]][["version"]]
[10:21:26.325]                           if (is.null(version)) 
[10:21:26.325]                             version <- utils::packageVersion("future")
[10:21:26.325]                         }
[10:21:26.325]                         else {
[10:21:26.325]                           version <- NULL
[10:21:26.325]                         }
[10:21:26.325]                         if (!has_future || version < "1.8.0") {
[10:21:26.325]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.325]                             "", base::R.version$version.string), 
[10:21:26.325]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:26.325]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:26.325]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.325]                               "release", "version")], collapse = " "), 
[10:21:26.325]                             hostname = base::Sys.info()[["nodename"]])
[10:21:26.325]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.325]                             info)
[10:21:26.325]                           info <- base::paste(info, collapse = "; ")
[10:21:26.325]                           if (!has_future) {
[10:21:26.325]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.325]                               info)
[10:21:26.325]                           }
[10:21:26.325]                           else {
[10:21:26.325]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.325]                               info, version)
[10:21:26.325]                           }
[10:21:26.325]                           base::stop(msg)
[10:21:26.325]                         }
[10:21:26.325]                       })
[10:21:26.325]                     }
[10:21:26.325]                     base::local({
[10:21:26.325]                       for (pkg in c("stats", "datasets")) {
[10:21:26.325]                         base::loadNamespace(pkg)
[10:21:26.325]                         base::library(pkg, character.only = TRUE)
[10:21:26.325]                       }
[10:21:26.325]                     })
[10:21:26.325]                   }
[10:21:26.325]                   ...future.strategy.old <- future::plan("list")
[10:21:26.325]                   options(future.plan = NULL)
[10:21:26.325]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.325]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.325]                 }
[10:21:26.325]                 ...future.workdir <- getwd()
[10:21:26.325]             }
[10:21:26.325]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.325]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.325]         }
[10:21:26.325]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.325]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.325]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.325]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.325]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.325]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.325]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.325]             base::names(...future.oldOptions))
[10:21:26.325]     }
[10:21:26.325]     if (FALSE) {
[10:21:26.325]     }
[10:21:26.325]     else {
[10:21:26.325]         if (TRUE) {
[10:21:26.325]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.325]                 open = "w")
[10:21:26.325]         }
[10:21:26.325]         else {
[10:21:26.325]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.325]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.325]         }
[10:21:26.325]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.325]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.325]             base::sink(type = "output", split = FALSE)
[10:21:26.325]             base::close(...future.stdout)
[10:21:26.325]         }, add = TRUE)
[10:21:26.325]     }
[10:21:26.325]     ...future.frame <- base::sys.nframe()
[10:21:26.325]     ...future.conditions <- base::list()
[10:21:26.325]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.325]     if (FALSE) {
[10:21:26.325]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.325]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.325]     }
[10:21:26.325]     ...future.result <- base::tryCatch({
[10:21:26.325]         base::withCallingHandlers({
[10:21:26.325]             ...future.value <- base::withVisible(base::local({
[10:21:26.325]                 lm(dist ~ . + 0, data = cars)
[10:21:26.325]             }))
[10:21:26.325]             future::FutureResult(value = ...future.value$value, 
[10:21:26.325]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.325]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.325]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.325]                     ...future.globalenv.names))
[10:21:26.325]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.325]         }, condition = base::local({
[10:21:26.325]             c <- base::c
[10:21:26.325]             inherits <- base::inherits
[10:21:26.325]             invokeRestart <- base::invokeRestart
[10:21:26.325]             length <- base::length
[10:21:26.325]             list <- base::list
[10:21:26.325]             seq.int <- base::seq.int
[10:21:26.325]             signalCondition <- base::signalCondition
[10:21:26.325]             sys.calls <- base::sys.calls
[10:21:26.325]             `[[` <- base::`[[`
[10:21:26.325]             `+` <- base::`+`
[10:21:26.325]             `<<-` <- base::`<<-`
[10:21:26.325]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.325]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.325]                   3L)]
[10:21:26.325]             }
[10:21:26.325]             function(cond) {
[10:21:26.325]                 is_error <- inherits(cond, "error")
[10:21:26.325]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.325]                   NULL)
[10:21:26.325]                 if (is_error) {
[10:21:26.325]                   sessionInformation <- function() {
[10:21:26.325]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.325]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.325]                       search = base::search(), system = base::Sys.info())
[10:21:26.325]                   }
[10:21:26.325]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.325]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.325]                     cond$call), session = sessionInformation(), 
[10:21:26.325]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.325]                   signalCondition(cond)
[10:21:26.325]                 }
[10:21:26.325]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.325]                 "immediateCondition"))) {
[10:21:26.325]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.325]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.325]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.325]                   if (TRUE && !signal) {
[10:21:26.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.325]                     {
[10:21:26.325]                       inherits <- base::inherits
[10:21:26.325]                       invokeRestart <- base::invokeRestart
[10:21:26.325]                       is.null <- base::is.null
[10:21:26.325]                       muffled <- FALSE
[10:21:26.325]                       if (inherits(cond, "message")) {
[10:21:26.325]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.325]                         if (muffled) 
[10:21:26.325]                           invokeRestart("muffleMessage")
[10:21:26.325]                       }
[10:21:26.325]                       else if (inherits(cond, "warning")) {
[10:21:26.325]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.325]                         if (muffled) 
[10:21:26.325]                           invokeRestart("muffleWarning")
[10:21:26.325]                       }
[10:21:26.325]                       else if (inherits(cond, "condition")) {
[10:21:26.325]                         if (!is.null(pattern)) {
[10:21:26.325]                           computeRestarts <- base::computeRestarts
[10:21:26.325]                           grepl <- base::grepl
[10:21:26.325]                           restarts <- computeRestarts(cond)
[10:21:26.325]                           for (restart in restarts) {
[10:21:26.325]                             name <- restart$name
[10:21:26.325]                             if (is.null(name)) 
[10:21:26.325]                               next
[10:21:26.325]                             if (!grepl(pattern, name)) 
[10:21:26.325]                               next
[10:21:26.325]                             invokeRestart(restart)
[10:21:26.325]                             muffled <- TRUE
[10:21:26.325]                             break
[10:21:26.325]                           }
[10:21:26.325]                         }
[10:21:26.325]                       }
[10:21:26.325]                       invisible(muffled)
[10:21:26.325]                     }
[10:21:26.325]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.325]                   }
[10:21:26.325]                 }
[10:21:26.325]                 else {
[10:21:26.325]                   if (TRUE) {
[10:21:26.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.325]                     {
[10:21:26.325]                       inherits <- base::inherits
[10:21:26.325]                       invokeRestart <- base::invokeRestart
[10:21:26.325]                       is.null <- base::is.null
[10:21:26.325]                       muffled <- FALSE
[10:21:26.325]                       if (inherits(cond, "message")) {
[10:21:26.325]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.325]                         if (muffled) 
[10:21:26.325]                           invokeRestart("muffleMessage")
[10:21:26.325]                       }
[10:21:26.325]                       else if (inherits(cond, "warning")) {
[10:21:26.325]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.325]                         if (muffled) 
[10:21:26.325]                           invokeRestart("muffleWarning")
[10:21:26.325]                       }
[10:21:26.325]                       else if (inherits(cond, "condition")) {
[10:21:26.325]                         if (!is.null(pattern)) {
[10:21:26.325]                           computeRestarts <- base::computeRestarts
[10:21:26.325]                           grepl <- base::grepl
[10:21:26.325]                           restarts <- computeRestarts(cond)
[10:21:26.325]                           for (restart in restarts) {
[10:21:26.325]                             name <- restart$name
[10:21:26.325]                             if (is.null(name)) 
[10:21:26.325]                               next
[10:21:26.325]                             if (!grepl(pattern, name)) 
[10:21:26.325]                               next
[10:21:26.325]                             invokeRestart(restart)
[10:21:26.325]                             muffled <- TRUE
[10:21:26.325]                             break
[10:21:26.325]                           }
[10:21:26.325]                         }
[10:21:26.325]                       }
[10:21:26.325]                       invisible(muffled)
[10:21:26.325]                     }
[10:21:26.325]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.325]                   }
[10:21:26.325]                 }
[10:21:26.325]             }
[10:21:26.325]         }))
[10:21:26.325]     }, error = function(ex) {
[10:21:26.325]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.325]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.325]                 ...future.rng), started = ...future.startTime, 
[10:21:26.325]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.325]             version = "1.8"), class = "FutureResult")
[10:21:26.325]     }, finally = {
[10:21:26.325]         if (!identical(...future.workdir, getwd())) 
[10:21:26.325]             setwd(...future.workdir)
[10:21:26.325]         {
[10:21:26.325]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.325]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.325]             }
[10:21:26.325]             base::options(...future.oldOptions)
[10:21:26.325]             if (.Platform$OS.type == "windows") {
[10:21:26.325]                 old_names <- names(...future.oldEnvVars)
[10:21:26.325]                 envs <- base::Sys.getenv()
[10:21:26.325]                 names <- names(envs)
[10:21:26.325]                 common <- intersect(names, old_names)
[10:21:26.325]                 added <- setdiff(names, old_names)
[10:21:26.325]                 removed <- setdiff(old_names, names)
[10:21:26.325]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.325]                   envs[common]]
[10:21:26.325]                 NAMES <- toupper(changed)
[10:21:26.325]                 args <- list()
[10:21:26.325]                 for (kk in seq_along(NAMES)) {
[10:21:26.325]                   name <- changed[[kk]]
[10:21:26.325]                   NAME <- NAMES[[kk]]
[10:21:26.325]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.325]                     next
[10:21:26.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.325]                 }
[10:21:26.325]                 NAMES <- toupper(added)
[10:21:26.325]                 for (kk in seq_along(NAMES)) {
[10:21:26.325]                   name <- added[[kk]]
[10:21:26.325]                   NAME <- NAMES[[kk]]
[10:21:26.325]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.325]                     next
[10:21:26.325]                   args[[name]] <- ""
[10:21:26.325]                 }
[10:21:26.325]                 NAMES <- toupper(removed)
[10:21:26.325]                 for (kk in seq_along(NAMES)) {
[10:21:26.325]                   name <- removed[[kk]]
[10:21:26.325]                   NAME <- NAMES[[kk]]
[10:21:26.325]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.325]                     next
[10:21:26.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.325]                 }
[10:21:26.325]                 if (length(args) > 0) 
[10:21:26.325]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.325]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.325]             }
[10:21:26.325]             else {
[10:21:26.325]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.325]             }
[10:21:26.325]             {
[10:21:26.325]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.325]                   0L) {
[10:21:26.325]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.325]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.325]                   base::options(opts)
[10:21:26.325]                 }
[10:21:26.325]                 {
[10:21:26.325]                   {
[10:21:26.325]                     NULL
[10:21:26.325]                     RNGkind("Mersenne-Twister")
[10:21:26.325]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:26.325]                       inherits = FALSE)
[10:21:26.325]                   }
[10:21:26.325]                   options(future.plan = NULL)
[10:21:26.325]                   if (is.na(NA_character_)) 
[10:21:26.325]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.325]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.325]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.325]                     .init = FALSE)
[10:21:26.325]                 }
[10:21:26.325]             }
[10:21:26.325]         }
[10:21:26.325]     })
[10:21:26.325]     if (TRUE) {
[10:21:26.325]         base::sink(type = "output", split = FALSE)
[10:21:26.325]         if (TRUE) {
[10:21:26.325]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.325]         }
[10:21:26.325]         else {
[10:21:26.325]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.325]         }
[10:21:26.325]         base::close(...future.stdout)
[10:21:26.325]         ...future.stdout <- NULL
[10:21:26.325]     }
[10:21:26.325]     ...future.result$conditions <- ...future.conditions
[10:21:26.325]     ...future.result$finished <- base::Sys.time()
[10:21:26.325]     ...future.result
[10:21:26.325] }
[10:21:26.327] plan(): Setting new future strategy stack:
[10:21:26.327] List of future strategies:
[10:21:26.327] 1. sequential:
[10:21:26.327]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.327]    - tweaked: FALSE
[10:21:26.327]    - call: NULL
[10:21:26.327] plan(): nbrOfWorkers() = 1
[10:21:26.328] plan(): Setting new future strategy stack:
[10:21:26.329] List of future strategies:
[10:21:26.329] 1. sequential:
[10:21:26.329]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.329]    - tweaked: FALSE
[10:21:26.329]    - call: plan(strategy)
[10:21:26.329] plan(): nbrOfWorkers() = 1
[10:21:26.329] SequentialFuture started (and completed)
[10:21:26.329] - Launch lazy future ... done
[10:21:26.329] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[10:21:26.331] getGlobalsAndPackages() ...
[10:21:26.331] Searching for globals...
[10:21:26.334] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[10:21:26.334] Searching for globals ... DONE
[10:21:26.334] Resolving globals: FALSE
[10:21:26.335] 
[10:21:26.335] - packages: [2] ‘stats’, ‘datasets’
[10:21:26.335] getGlobalsAndPackages() ... DONE
[10:21:26.335] run() for ‘Future’ ...
[10:21:26.335] - state: ‘created’
[10:21:26.335] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:26.336] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:26.336] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:26.336]   - Field: ‘label’
[10:21:26.336]   - Field: ‘local’
[10:21:26.336]   - Field: ‘owner’
[10:21:26.336]   - Field: ‘envir’
[10:21:26.336]   - Field: ‘packages’
[10:21:26.336]   - Field: ‘gc’
[10:21:26.336]   - Field: ‘conditions’
[10:21:26.337]   - Field: ‘expr’
[10:21:26.337]   - Field: ‘uuid’
[10:21:26.337]   - Field: ‘seed’
[10:21:26.337]   - Field: ‘version’
[10:21:26.337]   - Field: ‘result’
[10:21:26.337]   - Field: ‘asynchronous’
[10:21:26.337]   - Field: ‘calls’
[10:21:26.337]   - Field: ‘globals’
[10:21:26.337]   - Field: ‘stdout’
[10:21:26.337]   - Field: ‘earlySignal’
[10:21:26.337]   - Field: ‘lazy’
[10:21:26.337]   - Field: ‘state’
[10:21:26.337] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:26.338] - Launch lazy future ...
[10:21:26.338] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:21:26.338] Packages needed by future strategies (n = 0): <none>
[10:21:26.338] {
[10:21:26.338]     {
[10:21:26.338]         {
[10:21:26.338]             ...future.startTime <- base::Sys.time()
[10:21:26.338]             {
[10:21:26.338]                 {
[10:21:26.338]                   {
[10:21:26.338]                     {
[10:21:26.338]                       base::local({
[10:21:26.338]                         has_future <- base::requireNamespace("future", 
[10:21:26.338]                           quietly = TRUE)
[10:21:26.338]                         if (has_future) {
[10:21:26.338]                           ns <- base::getNamespace("future")
[10:21:26.338]                           version <- ns[[".package"]][["version"]]
[10:21:26.338]                           if (is.null(version)) 
[10:21:26.338]                             version <- utils::packageVersion("future")
[10:21:26.338]                         }
[10:21:26.338]                         else {
[10:21:26.338]                           version <- NULL
[10:21:26.338]                         }
[10:21:26.338]                         if (!has_future || version < "1.8.0") {
[10:21:26.338]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.338]                             "", base::R.version$version.string), 
[10:21:26.338]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:26.338]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:26.338]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.338]                               "release", "version")], collapse = " "), 
[10:21:26.338]                             hostname = base::Sys.info()[["nodename"]])
[10:21:26.338]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.338]                             info)
[10:21:26.338]                           info <- base::paste(info, collapse = "; ")
[10:21:26.338]                           if (!has_future) {
[10:21:26.338]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.338]                               info)
[10:21:26.338]                           }
[10:21:26.338]                           else {
[10:21:26.338]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.338]                               info, version)
[10:21:26.338]                           }
[10:21:26.338]                           base::stop(msg)
[10:21:26.338]                         }
[10:21:26.338]                       })
[10:21:26.338]                     }
[10:21:26.338]                     base::local({
[10:21:26.338]                       for (pkg in c("stats", "datasets")) {
[10:21:26.338]                         base::loadNamespace(pkg)
[10:21:26.338]                         base::library(pkg, character.only = TRUE)
[10:21:26.338]                       }
[10:21:26.338]                     })
[10:21:26.338]                   }
[10:21:26.338]                   ...future.strategy.old <- future::plan("list")
[10:21:26.338]                   options(future.plan = NULL)
[10:21:26.338]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.338]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.338]                 }
[10:21:26.338]                 ...future.workdir <- getwd()
[10:21:26.338]             }
[10:21:26.338]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.338]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.338]         }
[10:21:26.338]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.338]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.338]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.338]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.338]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.338]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.338]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.338]             base::names(...future.oldOptions))
[10:21:26.338]     }
[10:21:26.338]     if (FALSE) {
[10:21:26.338]     }
[10:21:26.338]     else {
[10:21:26.338]         if (TRUE) {
[10:21:26.338]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.338]                 open = "w")
[10:21:26.338]         }
[10:21:26.338]         else {
[10:21:26.338]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.338]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.338]         }
[10:21:26.338]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.338]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.338]             base::sink(type = "output", split = FALSE)
[10:21:26.338]             base::close(...future.stdout)
[10:21:26.338]         }, add = TRUE)
[10:21:26.338]     }
[10:21:26.338]     ...future.frame <- base::sys.nframe()
[10:21:26.338]     ...future.conditions <- base::list()
[10:21:26.338]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.338]     if (FALSE) {
[10:21:26.338]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.338]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.338]     }
[10:21:26.338]     ...future.result <- base::tryCatch({
[10:21:26.338]         base::withCallingHandlers({
[10:21:26.338]             ...future.value <- base::withVisible(base::local({
[10:21:26.338]                 lm(dist ~ speed + speed^2, data = cars)
[10:21:26.338]             }))
[10:21:26.338]             future::FutureResult(value = ...future.value$value, 
[10:21:26.338]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.338]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.338]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.338]                     ...future.globalenv.names))
[10:21:26.338]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.338]         }, condition = base::local({
[10:21:26.338]             c <- base::c
[10:21:26.338]             inherits <- base::inherits
[10:21:26.338]             invokeRestart <- base::invokeRestart
[10:21:26.338]             length <- base::length
[10:21:26.338]             list <- base::list
[10:21:26.338]             seq.int <- base::seq.int
[10:21:26.338]             signalCondition <- base::signalCondition
[10:21:26.338]             sys.calls <- base::sys.calls
[10:21:26.338]             `[[` <- base::`[[`
[10:21:26.338]             `+` <- base::`+`
[10:21:26.338]             `<<-` <- base::`<<-`
[10:21:26.338]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.338]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.338]                   3L)]
[10:21:26.338]             }
[10:21:26.338]             function(cond) {
[10:21:26.338]                 is_error <- inherits(cond, "error")
[10:21:26.338]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.338]                   NULL)
[10:21:26.338]                 if (is_error) {
[10:21:26.338]                   sessionInformation <- function() {
[10:21:26.338]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.338]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.338]                       search = base::search(), system = base::Sys.info())
[10:21:26.338]                   }
[10:21:26.338]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.338]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.338]                     cond$call), session = sessionInformation(), 
[10:21:26.338]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.338]                   signalCondition(cond)
[10:21:26.338]                 }
[10:21:26.338]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.338]                 "immediateCondition"))) {
[10:21:26.338]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.338]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.338]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.338]                   if (TRUE && !signal) {
[10:21:26.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.338]                     {
[10:21:26.338]                       inherits <- base::inherits
[10:21:26.338]                       invokeRestart <- base::invokeRestart
[10:21:26.338]                       is.null <- base::is.null
[10:21:26.338]                       muffled <- FALSE
[10:21:26.338]                       if (inherits(cond, "message")) {
[10:21:26.338]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.338]                         if (muffled) 
[10:21:26.338]                           invokeRestart("muffleMessage")
[10:21:26.338]                       }
[10:21:26.338]                       else if (inherits(cond, "warning")) {
[10:21:26.338]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.338]                         if (muffled) 
[10:21:26.338]                           invokeRestart("muffleWarning")
[10:21:26.338]                       }
[10:21:26.338]                       else if (inherits(cond, "condition")) {
[10:21:26.338]                         if (!is.null(pattern)) {
[10:21:26.338]                           computeRestarts <- base::computeRestarts
[10:21:26.338]                           grepl <- base::grepl
[10:21:26.338]                           restarts <- computeRestarts(cond)
[10:21:26.338]                           for (restart in restarts) {
[10:21:26.338]                             name <- restart$name
[10:21:26.338]                             if (is.null(name)) 
[10:21:26.338]                               next
[10:21:26.338]                             if (!grepl(pattern, name)) 
[10:21:26.338]                               next
[10:21:26.338]                             invokeRestart(restart)
[10:21:26.338]                             muffled <- TRUE
[10:21:26.338]                             break
[10:21:26.338]                           }
[10:21:26.338]                         }
[10:21:26.338]                       }
[10:21:26.338]                       invisible(muffled)
[10:21:26.338]                     }
[10:21:26.338]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.338]                   }
[10:21:26.338]                 }
[10:21:26.338]                 else {
[10:21:26.338]                   if (TRUE) {
[10:21:26.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.338]                     {
[10:21:26.338]                       inherits <- base::inherits
[10:21:26.338]                       invokeRestart <- base::invokeRestart
[10:21:26.338]                       is.null <- base::is.null
[10:21:26.338]                       muffled <- FALSE
[10:21:26.338]                       if (inherits(cond, "message")) {
[10:21:26.338]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.338]                         if (muffled) 
[10:21:26.338]                           invokeRestart("muffleMessage")
[10:21:26.338]                       }
[10:21:26.338]                       else if (inherits(cond, "warning")) {
[10:21:26.338]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.338]                         if (muffled) 
[10:21:26.338]                           invokeRestart("muffleWarning")
[10:21:26.338]                       }
[10:21:26.338]                       else if (inherits(cond, "condition")) {
[10:21:26.338]                         if (!is.null(pattern)) {
[10:21:26.338]                           computeRestarts <- base::computeRestarts
[10:21:26.338]                           grepl <- base::grepl
[10:21:26.338]                           restarts <- computeRestarts(cond)
[10:21:26.338]                           for (restart in restarts) {
[10:21:26.338]                             name <- restart$name
[10:21:26.338]                             if (is.null(name)) 
[10:21:26.338]                               next
[10:21:26.338]                             if (!grepl(pattern, name)) 
[10:21:26.338]                               next
[10:21:26.338]                             invokeRestart(restart)
[10:21:26.338]                             muffled <- TRUE
[10:21:26.338]                             break
[10:21:26.338]                           }
[10:21:26.338]                         }
[10:21:26.338]                       }
[10:21:26.338]                       invisible(muffled)
[10:21:26.338]                     }
[10:21:26.338]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.338]                   }
[10:21:26.338]                 }
[10:21:26.338]             }
[10:21:26.338]         }))
[10:21:26.338]     }, error = function(ex) {
[10:21:26.338]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.338]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.338]                 ...future.rng), started = ...future.startTime, 
[10:21:26.338]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.338]             version = "1.8"), class = "FutureResult")
[10:21:26.338]     }, finally = {
[10:21:26.338]         if (!identical(...future.workdir, getwd())) 
[10:21:26.338]             setwd(...future.workdir)
[10:21:26.338]         {
[10:21:26.338]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.338]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.338]             }
[10:21:26.338]             base::options(...future.oldOptions)
[10:21:26.338]             if (.Platform$OS.type == "windows") {
[10:21:26.338]                 old_names <- names(...future.oldEnvVars)
[10:21:26.338]                 envs <- base::Sys.getenv()
[10:21:26.338]                 names <- names(envs)
[10:21:26.338]                 common <- intersect(names, old_names)
[10:21:26.338]                 added <- setdiff(names, old_names)
[10:21:26.338]                 removed <- setdiff(old_names, names)
[10:21:26.338]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.338]                   envs[common]]
[10:21:26.338]                 NAMES <- toupper(changed)
[10:21:26.338]                 args <- list()
[10:21:26.338]                 for (kk in seq_along(NAMES)) {
[10:21:26.338]                   name <- changed[[kk]]
[10:21:26.338]                   NAME <- NAMES[[kk]]
[10:21:26.338]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.338]                     next
[10:21:26.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.338]                 }
[10:21:26.338]                 NAMES <- toupper(added)
[10:21:26.338]                 for (kk in seq_along(NAMES)) {
[10:21:26.338]                   name <- added[[kk]]
[10:21:26.338]                   NAME <- NAMES[[kk]]
[10:21:26.338]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.338]                     next
[10:21:26.338]                   args[[name]] <- ""
[10:21:26.338]                 }
[10:21:26.338]                 NAMES <- toupper(removed)
[10:21:26.338]                 for (kk in seq_along(NAMES)) {
[10:21:26.338]                   name <- removed[[kk]]
[10:21:26.338]                   NAME <- NAMES[[kk]]
[10:21:26.338]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.338]                     next
[10:21:26.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.338]                 }
[10:21:26.338]                 if (length(args) > 0) 
[10:21:26.338]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.338]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.338]             }
[10:21:26.338]             else {
[10:21:26.338]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.338]             }
[10:21:26.338]             {
[10:21:26.338]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.338]                   0L) {
[10:21:26.338]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.338]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.338]                   base::options(opts)
[10:21:26.338]                 }
[10:21:26.338]                 {
[10:21:26.338]                   {
[10:21:26.338]                     NULL
[10:21:26.338]                     RNGkind("Mersenne-Twister")
[10:21:26.338]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:26.338]                       inherits = FALSE)
[10:21:26.338]                   }
[10:21:26.338]                   options(future.plan = NULL)
[10:21:26.338]                   if (is.na(NA_character_)) 
[10:21:26.338]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.338]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.338]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.338]                     .init = FALSE)
[10:21:26.338]                 }
[10:21:26.338]             }
[10:21:26.338]         }
[10:21:26.338]     })
[10:21:26.338]     if (TRUE) {
[10:21:26.338]         base::sink(type = "output", split = FALSE)
[10:21:26.338]         if (TRUE) {
[10:21:26.338]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.338]         }
[10:21:26.338]         else {
[10:21:26.338]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.338]         }
[10:21:26.338]         base::close(...future.stdout)
[10:21:26.338]         ...future.stdout <- NULL
[10:21:26.338]     }
[10:21:26.338]     ...future.result$conditions <- ...future.conditions
[10:21:26.338]     ...future.result$finished <- base::Sys.time()
[10:21:26.338]     ...future.result
[10:21:26.338] }
[10:21:26.340] plan(): Setting new future strategy stack:
[10:21:26.340] List of future strategies:
[10:21:26.340] 1. sequential:
[10:21:26.340]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.340]    - tweaked: FALSE
[10:21:26.340]    - call: NULL
[10:21:26.341] plan(): nbrOfWorkers() = 1
[10:21:26.342] plan(): Setting new future strategy stack:
[10:21:26.342] List of future strategies:
[10:21:26.342] 1. sequential:
[10:21:26.342]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.342]    - tweaked: FALSE
[10:21:26.342]    - call: plan(strategy)
[10:21:26.342] plan(): nbrOfWorkers() = 1
[10:21:26.343] SequentialFuture started (and completed)
[10:21:26.343] - Launch lazy future ... done
[10:21:26.343] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[10:21:26.345] getGlobalsAndPackages() ...
[10:21:26.345] Searching for globals...
[10:21:26.347] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[10:21:26.347] Searching for globals ... DONE
[10:21:26.347] Resolving globals: FALSE
[10:21:26.347] 
[10:21:26.348] - packages: [2] ‘stats’, ‘datasets’
[10:21:26.348] getGlobalsAndPackages() ... DONE
[10:21:26.348] run() for ‘Future’ ...
[10:21:26.348] - state: ‘created’
[10:21:26.348] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:26.348] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:26.348] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:26.349]   - Field: ‘label’
[10:21:26.349]   - Field: ‘local’
[10:21:26.349]   - Field: ‘owner’
[10:21:26.349]   - Field: ‘envir’
[10:21:26.349]   - Field: ‘packages’
[10:21:26.349]   - Field: ‘gc’
[10:21:26.349]   - Field: ‘conditions’
[10:21:26.349]   - Field: ‘expr’
[10:21:26.349]   - Field: ‘uuid’
[10:21:26.349]   - Field: ‘seed’
[10:21:26.349]   - Field: ‘version’
[10:21:26.349]   - Field: ‘result’
[10:21:26.349]   - Field: ‘asynchronous’
[10:21:26.350]   - Field: ‘calls’
[10:21:26.350]   - Field: ‘globals’
[10:21:26.350]   - Field: ‘stdout’
[10:21:26.350]   - Field: ‘earlySignal’
[10:21:26.350]   - Field: ‘lazy’
[10:21:26.350]   - Field: ‘state’
[10:21:26.350] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:26.350] - Launch lazy future ...
[10:21:26.350] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:21:26.350] Packages needed by future strategies (n = 0): <none>
[10:21:26.351] {
[10:21:26.351]     {
[10:21:26.351]         {
[10:21:26.351]             ...future.startTime <- base::Sys.time()
[10:21:26.351]             {
[10:21:26.351]                 {
[10:21:26.351]                   {
[10:21:26.351]                     {
[10:21:26.351]                       base::local({
[10:21:26.351]                         has_future <- base::requireNamespace("future", 
[10:21:26.351]                           quietly = TRUE)
[10:21:26.351]                         if (has_future) {
[10:21:26.351]                           ns <- base::getNamespace("future")
[10:21:26.351]                           version <- ns[[".package"]][["version"]]
[10:21:26.351]                           if (is.null(version)) 
[10:21:26.351]                             version <- utils::packageVersion("future")
[10:21:26.351]                         }
[10:21:26.351]                         else {
[10:21:26.351]                           version <- NULL
[10:21:26.351]                         }
[10:21:26.351]                         if (!has_future || version < "1.8.0") {
[10:21:26.351]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.351]                             "", base::R.version$version.string), 
[10:21:26.351]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:26.351]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:26.351]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.351]                               "release", "version")], collapse = " "), 
[10:21:26.351]                             hostname = base::Sys.info()[["nodename"]])
[10:21:26.351]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.351]                             info)
[10:21:26.351]                           info <- base::paste(info, collapse = "; ")
[10:21:26.351]                           if (!has_future) {
[10:21:26.351]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.351]                               info)
[10:21:26.351]                           }
[10:21:26.351]                           else {
[10:21:26.351]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.351]                               info, version)
[10:21:26.351]                           }
[10:21:26.351]                           base::stop(msg)
[10:21:26.351]                         }
[10:21:26.351]                       })
[10:21:26.351]                     }
[10:21:26.351]                     base::local({
[10:21:26.351]                       for (pkg in c("stats", "datasets")) {
[10:21:26.351]                         base::loadNamespace(pkg)
[10:21:26.351]                         base::library(pkg, character.only = TRUE)
[10:21:26.351]                       }
[10:21:26.351]                     })
[10:21:26.351]                   }
[10:21:26.351]                   ...future.strategy.old <- future::plan("list")
[10:21:26.351]                   options(future.plan = NULL)
[10:21:26.351]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.351]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.351]                 }
[10:21:26.351]                 ...future.workdir <- getwd()
[10:21:26.351]             }
[10:21:26.351]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.351]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.351]         }
[10:21:26.351]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.351]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.351]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.351]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.351]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.351]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.351]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.351]             base::names(...future.oldOptions))
[10:21:26.351]     }
[10:21:26.351]     if (FALSE) {
[10:21:26.351]     }
[10:21:26.351]     else {
[10:21:26.351]         if (TRUE) {
[10:21:26.351]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.351]                 open = "w")
[10:21:26.351]         }
[10:21:26.351]         else {
[10:21:26.351]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.351]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.351]         }
[10:21:26.351]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.351]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.351]             base::sink(type = "output", split = FALSE)
[10:21:26.351]             base::close(...future.stdout)
[10:21:26.351]         }, add = TRUE)
[10:21:26.351]     }
[10:21:26.351]     ...future.frame <- base::sys.nframe()
[10:21:26.351]     ...future.conditions <- base::list()
[10:21:26.351]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.351]     if (FALSE) {
[10:21:26.351]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.351]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.351]     }
[10:21:26.351]     ...future.result <- base::tryCatch({
[10:21:26.351]         base::withCallingHandlers({
[10:21:26.351]             ...future.value <- base::withVisible(base::local({
[10:21:26.351]                 lm(dist ~ speed + I(speed^2), data = cars)
[10:21:26.351]             }))
[10:21:26.351]             future::FutureResult(value = ...future.value$value, 
[10:21:26.351]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.351]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.351]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.351]                     ...future.globalenv.names))
[10:21:26.351]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.351]         }, condition = base::local({
[10:21:26.351]             c <- base::c
[10:21:26.351]             inherits <- base::inherits
[10:21:26.351]             invokeRestart <- base::invokeRestart
[10:21:26.351]             length <- base::length
[10:21:26.351]             list <- base::list
[10:21:26.351]             seq.int <- base::seq.int
[10:21:26.351]             signalCondition <- base::signalCondition
[10:21:26.351]             sys.calls <- base::sys.calls
[10:21:26.351]             `[[` <- base::`[[`
[10:21:26.351]             `+` <- base::`+`
[10:21:26.351]             `<<-` <- base::`<<-`
[10:21:26.351]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.351]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.351]                   3L)]
[10:21:26.351]             }
[10:21:26.351]             function(cond) {
[10:21:26.351]                 is_error <- inherits(cond, "error")
[10:21:26.351]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.351]                   NULL)
[10:21:26.351]                 if (is_error) {
[10:21:26.351]                   sessionInformation <- function() {
[10:21:26.351]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.351]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.351]                       search = base::search(), system = base::Sys.info())
[10:21:26.351]                   }
[10:21:26.351]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.351]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.351]                     cond$call), session = sessionInformation(), 
[10:21:26.351]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.351]                   signalCondition(cond)
[10:21:26.351]                 }
[10:21:26.351]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.351]                 "immediateCondition"))) {
[10:21:26.351]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.351]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.351]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.351]                   if (TRUE && !signal) {
[10:21:26.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.351]                     {
[10:21:26.351]                       inherits <- base::inherits
[10:21:26.351]                       invokeRestart <- base::invokeRestart
[10:21:26.351]                       is.null <- base::is.null
[10:21:26.351]                       muffled <- FALSE
[10:21:26.351]                       if (inherits(cond, "message")) {
[10:21:26.351]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.351]                         if (muffled) 
[10:21:26.351]                           invokeRestart("muffleMessage")
[10:21:26.351]                       }
[10:21:26.351]                       else if (inherits(cond, "warning")) {
[10:21:26.351]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.351]                         if (muffled) 
[10:21:26.351]                           invokeRestart("muffleWarning")
[10:21:26.351]                       }
[10:21:26.351]                       else if (inherits(cond, "condition")) {
[10:21:26.351]                         if (!is.null(pattern)) {
[10:21:26.351]                           computeRestarts <- base::computeRestarts
[10:21:26.351]                           grepl <- base::grepl
[10:21:26.351]                           restarts <- computeRestarts(cond)
[10:21:26.351]                           for (restart in restarts) {
[10:21:26.351]                             name <- restart$name
[10:21:26.351]                             if (is.null(name)) 
[10:21:26.351]                               next
[10:21:26.351]                             if (!grepl(pattern, name)) 
[10:21:26.351]                               next
[10:21:26.351]                             invokeRestart(restart)
[10:21:26.351]                             muffled <- TRUE
[10:21:26.351]                             break
[10:21:26.351]                           }
[10:21:26.351]                         }
[10:21:26.351]                       }
[10:21:26.351]                       invisible(muffled)
[10:21:26.351]                     }
[10:21:26.351]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.351]                   }
[10:21:26.351]                 }
[10:21:26.351]                 else {
[10:21:26.351]                   if (TRUE) {
[10:21:26.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.351]                     {
[10:21:26.351]                       inherits <- base::inherits
[10:21:26.351]                       invokeRestart <- base::invokeRestart
[10:21:26.351]                       is.null <- base::is.null
[10:21:26.351]                       muffled <- FALSE
[10:21:26.351]                       if (inherits(cond, "message")) {
[10:21:26.351]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.351]                         if (muffled) 
[10:21:26.351]                           invokeRestart("muffleMessage")
[10:21:26.351]                       }
[10:21:26.351]                       else if (inherits(cond, "warning")) {
[10:21:26.351]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.351]                         if (muffled) 
[10:21:26.351]                           invokeRestart("muffleWarning")
[10:21:26.351]                       }
[10:21:26.351]                       else if (inherits(cond, "condition")) {
[10:21:26.351]                         if (!is.null(pattern)) {
[10:21:26.351]                           computeRestarts <- base::computeRestarts
[10:21:26.351]                           grepl <- base::grepl
[10:21:26.351]                           restarts <- computeRestarts(cond)
[10:21:26.351]                           for (restart in restarts) {
[10:21:26.351]                             name <- restart$name
[10:21:26.351]                             if (is.null(name)) 
[10:21:26.351]                               next
[10:21:26.351]                             if (!grepl(pattern, name)) 
[10:21:26.351]                               next
[10:21:26.351]                             invokeRestart(restart)
[10:21:26.351]                             muffled <- TRUE
[10:21:26.351]                             break
[10:21:26.351]                           }
[10:21:26.351]                         }
[10:21:26.351]                       }
[10:21:26.351]                       invisible(muffled)
[10:21:26.351]                     }
[10:21:26.351]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.351]                   }
[10:21:26.351]                 }
[10:21:26.351]             }
[10:21:26.351]         }))
[10:21:26.351]     }, error = function(ex) {
[10:21:26.351]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.351]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.351]                 ...future.rng), started = ...future.startTime, 
[10:21:26.351]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.351]             version = "1.8"), class = "FutureResult")
[10:21:26.351]     }, finally = {
[10:21:26.351]         if (!identical(...future.workdir, getwd())) 
[10:21:26.351]             setwd(...future.workdir)
[10:21:26.351]         {
[10:21:26.351]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.351]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.351]             }
[10:21:26.351]             base::options(...future.oldOptions)
[10:21:26.351]             if (.Platform$OS.type == "windows") {
[10:21:26.351]                 old_names <- names(...future.oldEnvVars)
[10:21:26.351]                 envs <- base::Sys.getenv()
[10:21:26.351]                 names <- names(envs)
[10:21:26.351]                 common <- intersect(names, old_names)
[10:21:26.351]                 added <- setdiff(names, old_names)
[10:21:26.351]                 removed <- setdiff(old_names, names)
[10:21:26.351]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.351]                   envs[common]]
[10:21:26.351]                 NAMES <- toupper(changed)
[10:21:26.351]                 args <- list()
[10:21:26.351]                 for (kk in seq_along(NAMES)) {
[10:21:26.351]                   name <- changed[[kk]]
[10:21:26.351]                   NAME <- NAMES[[kk]]
[10:21:26.351]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.351]                     next
[10:21:26.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.351]                 }
[10:21:26.351]                 NAMES <- toupper(added)
[10:21:26.351]                 for (kk in seq_along(NAMES)) {
[10:21:26.351]                   name <- added[[kk]]
[10:21:26.351]                   NAME <- NAMES[[kk]]
[10:21:26.351]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.351]                     next
[10:21:26.351]                   args[[name]] <- ""
[10:21:26.351]                 }
[10:21:26.351]                 NAMES <- toupper(removed)
[10:21:26.351]                 for (kk in seq_along(NAMES)) {
[10:21:26.351]                   name <- removed[[kk]]
[10:21:26.351]                   NAME <- NAMES[[kk]]
[10:21:26.351]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.351]                     next
[10:21:26.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.351]                 }
[10:21:26.351]                 if (length(args) > 0) 
[10:21:26.351]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.351]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.351]             }
[10:21:26.351]             else {
[10:21:26.351]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.351]             }
[10:21:26.351]             {
[10:21:26.351]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.351]                   0L) {
[10:21:26.351]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.351]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.351]                   base::options(opts)
[10:21:26.351]                 }
[10:21:26.351]                 {
[10:21:26.351]                   {
[10:21:26.351]                     NULL
[10:21:26.351]                     RNGkind("Mersenne-Twister")
[10:21:26.351]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:26.351]                       inherits = FALSE)
[10:21:26.351]                   }
[10:21:26.351]                   options(future.plan = NULL)
[10:21:26.351]                   if (is.na(NA_character_)) 
[10:21:26.351]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.351]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.351]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.351]                     .init = FALSE)
[10:21:26.351]                 }
[10:21:26.351]             }
[10:21:26.351]         }
[10:21:26.351]     })
[10:21:26.351]     if (TRUE) {
[10:21:26.351]         base::sink(type = "output", split = FALSE)
[10:21:26.351]         if (TRUE) {
[10:21:26.351]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.351]         }
[10:21:26.351]         else {
[10:21:26.351]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.351]         }
[10:21:26.351]         base::close(...future.stdout)
[10:21:26.351]         ...future.stdout <- NULL
[10:21:26.351]     }
[10:21:26.351]     ...future.result$conditions <- ...future.conditions
[10:21:26.351]     ...future.result$finished <- base::Sys.time()
[10:21:26.351]     ...future.result
[10:21:26.351] }
[10:21:26.353] plan(): Setting new future strategy stack:
[10:21:26.353] List of future strategies:
[10:21:26.353] 1. sequential:
[10:21:26.353]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.353]    - tweaked: FALSE
[10:21:26.353]    - call: NULL
[10:21:26.353] plan(): nbrOfWorkers() = 1
[10:21:26.355] plan(): Setting new future strategy stack:
[10:21:26.355] List of future strategies:
[10:21:26.355] 1. sequential:
[10:21:26.355]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.355]    - tweaked: FALSE
[10:21:26.355]    - call: plan(strategy)
[10:21:26.356] plan(): nbrOfWorkers() = 1
[10:21:26.356] SequentialFuture started (and completed)
[10:21:26.356] - Launch lazy future ... done
[10:21:26.357] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[10:21:26.360] getGlobalsAndPackages() ...
[10:21:26.361] Searching for globals...
[10:21:26.362] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[10:21:26.362] Searching for globals ... DONE
[10:21:26.362] Resolving globals: FALSE
[10:21:26.363] 
[10:21:26.363] - packages: [2] ‘stats’, ‘datasets’
[10:21:26.363] getGlobalsAndPackages() ... DONE
[10:21:26.363] run() for ‘Future’ ...
[10:21:26.363] - state: ‘created’
[10:21:26.363] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:26.363] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:26.364] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:26.364]   - Field: ‘label’
[10:21:26.364]   - Field: ‘local’
[10:21:26.364]   - Field: ‘owner’
[10:21:26.364]   - Field: ‘envir’
[10:21:26.364]   - Field: ‘packages’
[10:21:26.364]   - Field: ‘gc’
[10:21:26.364]   - Field: ‘conditions’
[10:21:26.364]   - Field: ‘expr’
[10:21:26.364]   - Field: ‘uuid’
[10:21:26.364]   - Field: ‘seed’
[10:21:26.364]   - Field: ‘version’
[10:21:26.365]   - Field: ‘result’
[10:21:26.365]   - Field: ‘asynchronous’
[10:21:26.365]   - Field: ‘calls’
[10:21:26.365]   - Field: ‘globals’
[10:21:26.365]   - Field: ‘stdout’
[10:21:26.365]   - Field: ‘earlySignal’
[10:21:26.365]   - Field: ‘lazy’
[10:21:26.365]   - Field: ‘state’
[10:21:26.365] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:26.365] - Launch lazy future ...
[10:21:26.365] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:21:26.366] Packages needed by future strategies (n = 0): <none>
[10:21:26.366] {
[10:21:26.366]     {
[10:21:26.366]         {
[10:21:26.366]             ...future.startTime <- base::Sys.time()
[10:21:26.366]             {
[10:21:26.366]                 {
[10:21:26.366]                   {
[10:21:26.366]                     {
[10:21:26.366]                       base::local({
[10:21:26.366]                         has_future <- base::requireNamespace("future", 
[10:21:26.366]                           quietly = TRUE)
[10:21:26.366]                         if (has_future) {
[10:21:26.366]                           ns <- base::getNamespace("future")
[10:21:26.366]                           version <- ns[[".package"]][["version"]]
[10:21:26.366]                           if (is.null(version)) 
[10:21:26.366]                             version <- utils::packageVersion("future")
[10:21:26.366]                         }
[10:21:26.366]                         else {
[10:21:26.366]                           version <- NULL
[10:21:26.366]                         }
[10:21:26.366]                         if (!has_future || version < "1.8.0") {
[10:21:26.366]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.366]                             "", base::R.version$version.string), 
[10:21:26.366]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:26.366]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:26.366]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.366]                               "release", "version")], collapse = " "), 
[10:21:26.366]                             hostname = base::Sys.info()[["nodename"]])
[10:21:26.366]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.366]                             info)
[10:21:26.366]                           info <- base::paste(info, collapse = "; ")
[10:21:26.366]                           if (!has_future) {
[10:21:26.366]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.366]                               info)
[10:21:26.366]                           }
[10:21:26.366]                           else {
[10:21:26.366]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.366]                               info, version)
[10:21:26.366]                           }
[10:21:26.366]                           base::stop(msg)
[10:21:26.366]                         }
[10:21:26.366]                       })
[10:21:26.366]                     }
[10:21:26.366]                     base::local({
[10:21:26.366]                       for (pkg in c("stats", "datasets")) {
[10:21:26.366]                         base::loadNamespace(pkg)
[10:21:26.366]                         base::library(pkg, character.only = TRUE)
[10:21:26.366]                       }
[10:21:26.366]                     })
[10:21:26.366]                   }
[10:21:26.366]                   ...future.strategy.old <- future::plan("list")
[10:21:26.366]                   options(future.plan = NULL)
[10:21:26.366]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.366]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.366]                 }
[10:21:26.366]                 ...future.workdir <- getwd()
[10:21:26.366]             }
[10:21:26.366]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.366]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.366]         }
[10:21:26.366]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.366]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.366]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.366]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.366]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.366]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.366]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.366]             base::names(...future.oldOptions))
[10:21:26.366]     }
[10:21:26.366]     if (FALSE) {
[10:21:26.366]     }
[10:21:26.366]     else {
[10:21:26.366]         if (TRUE) {
[10:21:26.366]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.366]                 open = "w")
[10:21:26.366]         }
[10:21:26.366]         else {
[10:21:26.366]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.366]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.366]         }
[10:21:26.366]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.366]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.366]             base::sink(type = "output", split = FALSE)
[10:21:26.366]             base::close(...future.stdout)
[10:21:26.366]         }, add = TRUE)
[10:21:26.366]     }
[10:21:26.366]     ...future.frame <- base::sys.nframe()
[10:21:26.366]     ...future.conditions <- base::list()
[10:21:26.366]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.366]     if (FALSE) {
[10:21:26.366]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.366]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.366]     }
[10:21:26.366]     ...future.result <- base::tryCatch({
[10:21:26.366]         base::withCallingHandlers({
[10:21:26.366]             ...future.value <- base::withVisible(base::local({
[10:21:26.366]                 lm(dist ~ poly(speed, 2), data = cars)
[10:21:26.366]             }))
[10:21:26.366]             future::FutureResult(value = ...future.value$value, 
[10:21:26.366]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.366]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.366]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.366]                     ...future.globalenv.names))
[10:21:26.366]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.366]         }, condition = base::local({
[10:21:26.366]             c <- base::c
[10:21:26.366]             inherits <- base::inherits
[10:21:26.366]             invokeRestart <- base::invokeRestart
[10:21:26.366]             length <- base::length
[10:21:26.366]             list <- base::list
[10:21:26.366]             seq.int <- base::seq.int
[10:21:26.366]             signalCondition <- base::signalCondition
[10:21:26.366]             sys.calls <- base::sys.calls
[10:21:26.366]             `[[` <- base::`[[`
[10:21:26.366]             `+` <- base::`+`
[10:21:26.366]             `<<-` <- base::`<<-`
[10:21:26.366]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.366]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.366]                   3L)]
[10:21:26.366]             }
[10:21:26.366]             function(cond) {
[10:21:26.366]                 is_error <- inherits(cond, "error")
[10:21:26.366]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.366]                   NULL)
[10:21:26.366]                 if (is_error) {
[10:21:26.366]                   sessionInformation <- function() {
[10:21:26.366]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.366]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.366]                       search = base::search(), system = base::Sys.info())
[10:21:26.366]                   }
[10:21:26.366]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.366]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.366]                     cond$call), session = sessionInformation(), 
[10:21:26.366]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.366]                   signalCondition(cond)
[10:21:26.366]                 }
[10:21:26.366]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.366]                 "immediateCondition"))) {
[10:21:26.366]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.366]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.366]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.366]                   if (TRUE && !signal) {
[10:21:26.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.366]                     {
[10:21:26.366]                       inherits <- base::inherits
[10:21:26.366]                       invokeRestart <- base::invokeRestart
[10:21:26.366]                       is.null <- base::is.null
[10:21:26.366]                       muffled <- FALSE
[10:21:26.366]                       if (inherits(cond, "message")) {
[10:21:26.366]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.366]                         if (muffled) 
[10:21:26.366]                           invokeRestart("muffleMessage")
[10:21:26.366]                       }
[10:21:26.366]                       else if (inherits(cond, "warning")) {
[10:21:26.366]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.366]                         if (muffled) 
[10:21:26.366]                           invokeRestart("muffleWarning")
[10:21:26.366]                       }
[10:21:26.366]                       else if (inherits(cond, "condition")) {
[10:21:26.366]                         if (!is.null(pattern)) {
[10:21:26.366]                           computeRestarts <- base::computeRestarts
[10:21:26.366]                           grepl <- base::grepl
[10:21:26.366]                           restarts <- computeRestarts(cond)
[10:21:26.366]                           for (restart in restarts) {
[10:21:26.366]                             name <- restart$name
[10:21:26.366]                             if (is.null(name)) 
[10:21:26.366]                               next
[10:21:26.366]                             if (!grepl(pattern, name)) 
[10:21:26.366]                               next
[10:21:26.366]                             invokeRestart(restart)
[10:21:26.366]                             muffled <- TRUE
[10:21:26.366]                             break
[10:21:26.366]                           }
[10:21:26.366]                         }
[10:21:26.366]                       }
[10:21:26.366]                       invisible(muffled)
[10:21:26.366]                     }
[10:21:26.366]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.366]                   }
[10:21:26.366]                 }
[10:21:26.366]                 else {
[10:21:26.366]                   if (TRUE) {
[10:21:26.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.366]                     {
[10:21:26.366]                       inherits <- base::inherits
[10:21:26.366]                       invokeRestart <- base::invokeRestart
[10:21:26.366]                       is.null <- base::is.null
[10:21:26.366]                       muffled <- FALSE
[10:21:26.366]                       if (inherits(cond, "message")) {
[10:21:26.366]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.366]                         if (muffled) 
[10:21:26.366]                           invokeRestart("muffleMessage")
[10:21:26.366]                       }
[10:21:26.366]                       else if (inherits(cond, "warning")) {
[10:21:26.366]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.366]                         if (muffled) 
[10:21:26.366]                           invokeRestart("muffleWarning")
[10:21:26.366]                       }
[10:21:26.366]                       else if (inherits(cond, "condition")) {
[10:21:26.366]                         if (!is.null(pattern)) {
[10:21:26.366]                           computeRestarts <- base::computeRestarts
[10:21:26.366]                           grepl <- base::grepl
[10:21:26.366]                           restarts <- computeRestarts(cond)
[10:21:26.366]                           for (restart in restarts) {
[10:21:26.366]                             name <- restart$name
[10:21:26.366]                             if (is.null(name)) 
[10:21:26.366]                               next
[10:21:26.366]                             if (!grepl(pattern, name)) 
[10:21:26.366]                               next
[10:21:26.366]                             invokeRestart(restart)
[10:21:26.366]                             muffled <- TRUE
[10:21:26.366]                             break
[10:21:26.366]                           }
[10:21:26.366]                         }
[10:21:26.366]                       }
[10:21:26.366]                       invisible(muffled)
[10:21:26.366]                     }
[10:21:26.366]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.366]                   }
[10:21:26.366]                 }
[10:21:26.366]             }
[10:21:26.366]         }))
[10:21:26.366]     }, error = function(ex) {
[10:21:26.366]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.366]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.366]                 ...future.rng), started = ...future.startTime, 
[10:21:26.366]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.366]             version = "1.8"), class = "FutureResult")
[10:21:26.366]     }, finally = {
[10:21:26.366]         if (!identical(...future.workdir, getwd())) 
[10:21:26.366]             setwd(...future.workdir)
[10:21:26.366]         {
[10:21:26.366]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.366]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.366]             }
[10:21:26.366]             base::options(...future.oldOptions)
[10:21:26.366]             if (.Platform$OS.type == "windows") {
[10:21:26.366]                 old_names <- names(...future.oldEnvVars)
[10:21:26.366]                 envs <- base::Sys.getenv()
[10:21:26.366]                 names <- names(envs)
[10:21:26.366]                 common <- intersect(names, old_names)
[10:21:26.366]                 added <- setdiff(names, old_names)
[10:21:26.366]                 removed <- setdiff(old_names, names)
[10:21:26.366]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.366]                   envs[common]]
[10:21:26.366]                 NAMES <- toupper(changed)
[10:21:26.366]                 args <- list()
[10:21:26.366]                 for (kk in seq_along(NAMES)) {
[10:21:26.366]                   name <- changed[[kk]]
[10:21:26.366]                   NAME <- NAMES[[kk]]
[10:21:26.366]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.366]                     next
[10:21:26.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.366]                 }
[10:21:26.366]                 NAMES <- toupper(added)
[10:21:26.366]                 for (kk in seq_along(NAMES)) {
[10:21:26.366]                   name <- added[[kk]]
[10:21:26.366]                   NAME <- NAMES[[kk]]
[10:21:26.366]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.366]                     next
[10:21:26.366]                   args[[name]] <- ""
[10:21:26.366]                 }
[10:21:26.366]                 NAMES <- toupper(removed)
[10:21:26.366]                 for (kk in seq_along(NAMES)) {
[10:21:26.366]                   name <- removed[[kk]]
[10:21:26.366]                   NAME <- NAMES[[kk]]
[10:21:26.366]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.366]                     next
[10:21:26.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.366]                 }
[10:21:26.366]                 if (length(args) > 0) 
[10:21:26.366]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.366]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.366]             }
[10:21:26.366]             else {
[10:21:26.366]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.366]             }
[10:21:26.366]             {
[10:21:26.366]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.366]                   0L) {
[10:21:26.366]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.366]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.366]                   base::options(opts)
[10:21:26.366]                 }
[10:21:26.366]                 {
[10:21:26.366]                   {
[10:21:26.366]                     NULL
[10:21:26.366]                     RNGkind("Mersenne-Twister")
[10:21:26.366]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:26.366]                       inherits = FALSE)
[10:21:26.366]                   }
[10:21:26.366]                   options(future.plan = NULL)
[10:21:26.366]                   if (is.na(NA_character_)) 
[10:21:26.366]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.366]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.366]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.366]                     .init = FALSE)
[10:21:26.366]                 }
[10:21:26.366]             }
[10:21:26.366]         }
[10:21:26.366]     })
[10:21:26.366]     if (TRUE) {
[10:21:26.366]         base::sink(type = "output", split = FALSE)
[10:21:26.366]         if (TRUE) {
[10:21:26.366]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.366]         }
[10:21:26.366]         else {
[10:21:26.366]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.366]         }
[10:21:26.366]         base::close(...future.stdout)
[10:21:26.366]         ...future.stdout <- NULL
[10:21:26.366]     }
[10:21:26.366]     ...future.result$conditions <- ...future.conditions
[10:21:26.366]     ...future.result$finished <- base::Sys.time()
[10:21:26.366]     ...future.result
[10:21:26.366] }
[10:21:26.368] plan(): Setting new future strategy stack:
[10:21:26.368] List of future strategies:
[10:21:26.368] 1. sequential:
[10:21:26.368]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.368]    - tweaked: FALSE
[10:21:26.368]    - call: NULL
[10:21:26.368] plan(): nbrOfWorkers() = 1
[10:21:26.370] plan(): Setting new future strategy stack:
[10:21:26.370] List of future strategies:
[10:21:26.370] 1. sequential:
[10:21:26.370]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.370]    - tweaked: FALSE
[10:21:26.370]    - call: plan(strategy)
[10:21:26.370] plan(): nbrOfWorkers() = 1
[10:21:26.371] SequentialFuture started (and completed)
[10:21:26.371] - Launch lazy future ... done
[10:21:26.371] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[10:21:26.372] getGlobalsAndPackages() ...
[10:21:26.373] Searching for globals...
[10:21:26.377] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[10:21:26.377] Searching for globals ... DONE
[10:21:26.377] Resolving globals: FALSE
[10:21:26.379] The total size of the 3 globals is 1.22 KiB (1254 bytes)
[10:21:26.379] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (633 bytes of class ‘function’), ‘inner_function’ (371 bytes of class ‘function’) and ‘outer_function’ (250 bytes of class ‘function’)
[10:21:26.379] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[10:21:26.379] 
[10:21:26.379] getGlobalsAndPackages() ... DONE
[10:21:26.380] run() for ‘Future’ ...
[10:21:26.380] - state: ‘created’
[10:21:26.380] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:26.380] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:26.380] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:26.380]   - Field: ‘label’
[10:21:26.380]   - Field: ‘local’
[10:21:26.380]   - Field: ‘owner’
[10:21:26.381]   - Field: ‘envir’
[10:21:26.381]   - Field: ‘packages’
[10:21:26.381]   - Field: ‘gc’
[10:21:26.381]   - Field: ‘conditions’
[10:21:26.381]   - Field: ‘expr’
[10:21:26.381]   - Field: ‘uuid’
[10:21:26.381]   - Field: ‘seed’
[10:21:26.381]   - Field: ‘version’
[10:21:26.381]   - Field: ‘result’
[10:21:26.381]   - Field: ‘asynchronous’
[10:21:26.381]   - Field: ‘calls’
[10:21:26.381]   - Field: ‘globals’
[10:21:26.382]   - Field: ‘stdout’
[10:21:26.382]   - Field: ‘earlySignal’
[10:21:26.382]   - Field: ‘lazy’
[10:21:26.382]   - Field: ‘state’
[10:21:26.382] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:26.382] - Launch lazy future ...
[10:21:26.382] Packages needed by the future expression (n = 0): <none>
[10:21:26.382] Packages needed by future strategies (n = 0): <none>
[10:21:26.383] {
[10:21:26.383]     {
[10:21:26.383]         {
[10:21:26.383]             ...future.startTime <- base::Sys.time()
[10:21:26.383]             {
[10:21:26.383]                 {
[10:21:26.383]                   {
[10:21:26.383]                     base::local({
[10:21:26.383]                       has_future <- base::requireNamespace("future", 
[10:21:26.383]                         quietly = TRUE)
[10:21:26.383]                       if (has_future) {
[10:21:26.383]                         ns <- base::getNamespace("future")
[10:21:26.383]                         version <- ns[[".package"]][["version"]]
[10:21:26.383]                         if (is.null(version)) 
[10:21:26.383]                           version <- utils::packageVersion("future")
[10:21:26.383]                       }
[10:21:26.383]                       else {
[10:21:26.383]                         version <- NULL
[10:21:26.383]                       }
[10:21:26.383]                       if (!has_future || version < "1.8.0") {
[10:21:26.383]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.383]                           "", base::R.version$version.string), 
[10:21:26.383]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:26.383]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:26.383]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.383]                             "release", "version")], collapse = " "), 
[10:21:26.383]                           hostname = base::Sys.info()[["nodename"]])
[10:21:26.383]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.383]                           info)
[10:21:26.383]                         info <- base::paste(info, collapse = "; ")
[10:21:26.383]                         if (!has_future) {
[10:21:26.383]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.383]                             info)
[10:21:26.383]                         }
[10:21:26.383]                         else {
[10:21:26.383]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.383]                             info, version)
[10:21:26.383]                         }
[10:21:26.383]                         base::stop(msg)
[10:21:26.383]                       }
[10:21:26.383]                     })
[10:21:26.383]                   }
[10:21:26.383]                   ...future.strategy.old <- future::plan("list")
[10:21:26.383]                   options(future.plan = NULL)
[10:21:26.383]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.383]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.383]                 }
[10:21:26.383]                 ...future.workdir <- getwd()
[10:21:26.383]             }
[10:21:26.383]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.383]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.383]         }
[10:21:26.383]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.383]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.383]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.383]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.383]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.383]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.383]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.383]             base::names(...future.oldOptions))
[10:21:26.383]     }
[10:21:26.383]     if (FALSE) {
[10:21:26.383]     }
[10:21:26.383]     else {
[10:21:26.383]         if (TRUE) {
[10:21:26.383]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.383]                 open = "w")
[10:21:26.383]         }
[10:21:26.383]         else {
[10:21:26.383]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.383]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.383]         }
[10:21:26.383]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.383]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.383]             base::sink(type = "output", split = FALSE)
[10:21:26.383]             base::close(...future.stdout)
[10:21:26.383]         }, add = TRUE)
[10:21:26.383]     }
[10:21:26.383]     ...future.frame <- base::sys.nframe()
[10:21:26.383]     ...future.conditions <- base::list()
[10:21:26.383]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.383]     if (FALSE) {
[10:21:26.383]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.383]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.383]     }
[10:21:26.383]     ...future.result <- base::tryCatch({
[10:21:26.383]         base::withCallingHandlers({
[10:21:26.383]             ...future.value <- base::withVisible(base::local({
[10:21:26.383]                 outer_function(1L)
[10:21:26.383]             }))
[10:21:26.383]             future::FutureResult(value = ...future.value$value, 
[10:21:26.383]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.383]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.383]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.383]                     ...future.globalenv.names))
[10:21:26.383]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.383]         }, condition = base::local({
[10:21:26.383]             c <- base::c
[10:21:26.383]             inherits <- base::inherits
[10:21:26.383]             invokeRestart <- base::invokeRestart
[10:21:26.383]             length <- base::length
[10:21:26.383]             list <- base::list
[10:21:26.383]             seq.int <- base::seq.int
[10:21:26.383]             signalCondition <- base::signalCondition
[10:21:26.383]             sys.calls <- base::sys.calls
[10:21:26.383]             `[[` <- base::`[[`
[10:21:26.383]             `+` <- base::`+`
[10:21:26.383]             `<<-` <- base::`<<-`
[10:21:26.383]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.383]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.383]                   3L)]
[10:21:26.383]             }
[10:21:26.383]             function(cond) {
[10:21:26.383]                 is_error <- inherits(cond, "error")
[10:21:26.383]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.383]                   NULL)
[10:21:26.383]                 if (is_error) {
[10:21:26.383]                   sessionInformation <- function() {
[10:21:26.383]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.383]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.383]                       search = base::search(), system = base::Sys.info())
[10:21:26.383]                   }
[10:21:26.383]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.383]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.383]                     cond$call), session = sessionInformation(), 
[10:21:26.383]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.383]                   signalCondition(cond)
[10:21:26.383]                 }
[10:21:26.383]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.383]                 "immediateCondition"))) {
[10:21:26.383]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.383]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.383]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.383]                   if (TRUE && !signal) {
[10:21:26.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.383]                     {
[10:21:26.383]                       inherits <- base::inherits
[10:21:26.383]                       invokeRestart <- base::invokeRestart
[10:21:26.383]                       is.null <- base::is.null
[10:21:26.383]                       muffled <- FALSE
[10:21:26.383]                       if (inherits(cond, "message")) {
[10:21:26.383]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.383]                         if (muffled) 
[10:21:26.383]                           invokeRestart("muffleMessage")
[10:21:26.383]                       }
[10:21:26.383]                       else if (inherits(cond, "warning")) {
[10:21:26.383]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.383]                         if (muffled) 
[10:21:26.383]                           invokeRestart("muffleWarning")
[10:21:26.383]                       }
[10:21:26.383]                       else if (inherits(cond, "condition")) {
[10:21:26.383]                         if (!is.null(pattern)) {
[10:21:26.383]                           computeRestarts <- base::computeRestarts
[10:21:26.383]                           grepl <- base::grepl
[10:21:26.383]                           restarts <- computeRestarts(cond)
[10:21:26.383]                           for (restart in restarts) {
[10:21:26.383]                             name <- restart$name
[10:21:26.383]                             if (is.null(name)) 
[10:21:26.383]                               next
[10:21:26.383]                             if (!grepl(pattern, name)) 
[10:21:26.383]                               next
[10:21:26.383]                             invokeRestart(restart)
[10:21:26.383]                             muffled <- TRUE
[10:21:26.383]                             break
[10:21:26.383]                           }
[10:21:26.383]                         }
[10:21:26.383]                       }
[10:21:26.383]                       invisible(muffled)
[10:21:26.383]                     }
[10:21:26.383]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.383]                   }
[10:21:26.383]                 }
[10:21:26.383]                 else {
[10:21:26.383]                   if (TRUE) {
[10:21:26.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.383]                     {
[10:21:26.383]                       inherits <- base::inherits
[10:21:26.383]                       invokeRestart <- base::invokeRestart
[10:21:26.383]                       is.null <- base::is.null
[10:21:26.383]                       muffled <- FALSE
[10:21:26.383]                       if (inherits(cond, "message")) {
[10:21:26.383]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.383]                         if (muffled) 
[10:21:26.383]                           invokeRestart("muffleMessage")
[10:21:26.383]                       }
[10:21:26.383]                       else if (inherits(cond, "warning")) {
[10:21:26.383]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.383]                         if (muffled) 
[10:21:26.383]                           invokeRestart("muffleWarning")
[10:21:26.383]                       }
[10:21:26.383]                       else if (inherits(cond, "condition")) {
[10:21:26.383]                         if (!is.null(pattern)) {
[10:21:26.383]                           computeRestarts <- base::computeRestarts
[10:21:26.383]                           grepl <- base::grepl
[10:21:26.383]                           restarts <- computeRestarts(cond)
[10:21:26.383]                           for (restart in restarts) {
[10:21:26.383]                             name <- restart$name
[10:21:26.383]                             if (is.null(name)) 
[10:21:26.383]                               next
[10:21:26.383]                             if (!grepl(pattern, name)) 
[10:21:26.383]                               next
[10:21:26.383]                             invokeRestart(restart)
[10:21:26.383]                             muffled <- TRUE
[10:21:26.383]                             break
[10:21:26.383]                           }
[10:21:26.383]                         }
[10:21:26.383]                       }
[10:21:26.383]                       invisible(muffled)
[10:21:26.383]                     }
[10:21:26.383]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.383]                   }
[10:21:26.383]                 }
[10:21:26.383]             }
[10:21:26.383]         }))
[10:21:26.383]     }, error = function(ex) {
[10:21:26.383]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.383]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.383]                 ...future.rng), started = ...future.startTime, 
[10:21:26.383]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.383]             version = "1.8"), class = "FutureResult")
[10:21:26.383]     }, finally = {
[10:21:26.383]         if (!identical(...future.workdir, getwd())) 
[10:21:26.383]             setwd(...future.workdir)
[10:21:26.383]         {
[10:21:26.383]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.383]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.383]             }
[10:21:26.383]             base::options(...future.oldOptions)
[10:21:26.383]             if (.Platform$OS.type == "windows") {
[10:21:26.383]                 old_names <- names(...future.oldEnvVars)
[10:21:26.383]                 envs <- base::Sys.getenv()
[10:21:26.383]                 names <- names(envs)
[10:21:26.383]                 common <- intersect(names, old_names)
[10:21:26.383]                 added <- setdiff(names, old_names)
[10:21:26.383]                 removed <- setdiff(old_names, names)
[10:21:26.383]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.383]                   envs[common]]
[10:21:26.383]                 NAMES <- toupper(changed)
[10:21:26.383]                 args <- list()
[10:21:26.383]                 for (kk in seq_along(NAMES)) {
[10:21:26.383]                   name <- changed[[kk]]
[10:21:26.383]                   NAME <- NAMES[[kk]]
[10:21:26.383]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.383]                     next
[10:21:26.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.383]                 }
[10:21:26.383]                 NAMES <- toupper(added)
[10:21:26.383]                 for (kk in seq_along(NAMES)) {
[10:21:26.383]                   name <- added[[kk]]
[10:21:26.383]                   NAME <- NAMES[[kk]]
[10:21:26.383]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.383]                     next
[10:21:26.383]                   args[[name]] <- ""
[10:21:26.383]                 }
[10:21:26.383]                 NAMES <- toupper(removed)
[10:21:26.383]                 for (kk in seq_along(NAMES)) {
[10:21:26.383]                   name <- removed[[kk]]
[10:21:26.383]                   NAME <- NAMES[[kk]]
[10:21:26.383]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.383]                     next
[10:21:26.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.383]                 }
[10:21:26.383]                 if (length(args) > 0) 
[10:21:26.383]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.383]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.383]             }
[10:21:26.383]             else {
[10:21:26.383]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.383]             }
[10:21:26.383]             {
[10:21:26.383]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.383]                   0L) {
[10:21:26.383]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.383]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.383]                   base::options(opts)
[10:21:26.383]                 }
[10:21:26.383]                 {
[10:21:26.383]                   {
[10:21:26.383]                     NULL
[10:21:26.383]                     RNGkind("Mersenne-Twister")
[10:21:26.383]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:26.383]                       inherits = FALSE)
[10:21:26.383]                   }
[10:21:26.383]                   options(future.plan = NULL)
[10:21:26.383]                   if (is.na(NA_character_)) 
[10:21:26.383]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.383]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.383]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.383]                     .init = FALSE)
[10:21:26.383]                 }
[10:21:26.383]             }
[10:21:26.383]         }
[10:21:26.383]     })
[10:21:26.383]     if (TRUE) {
[10:21:26.383]         base::sink(type = "output", split = FALSE)
[10:21:26.383]         if (TRUE) {
[10:21:26.383]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.383]         }
[10:21:26.383]         else {
[10:21:26.383]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.383]         }
[10:21:26.383]         base::close(...future.stdout)
[10:21:26.383]         ...future.stdout <- NULL
[10:21:26.383]     }
[10:21:26.383]     ...future.result$conditions <- ...future.conditions
[10:21:26.383]     ...future.result$finished <- base::Sys.time()
[10:21:26.383]     ...future.result
[10:21:26.383] }
[10:21:26.384] assign_globals() ...
[10:21:26.384] List of 3
[10:21:26.384]  $ outer_function:function (x)  
[10:21:26.384]  $ map           :function (.x, .f, ...)  
[10:21:26.384]  $ inner_function:function (x)  
[10:21:26.384]  - attr(*, "where")=List of 3
[10:21:26.384]   ..$ outer_function:<environment: R_EmptyEnv> 
[10:21:26.384]   ..$ map           :<environment: R_EmptyEnv> 
[10:21:26.384]   ..$ inner_function:<environment: R_EmptyEnv> 
[10:21:26.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:26.384]  - attr(*, "resolved")= logi FALSE
[10:21:26.384]  - attr(*, "total_size")= num 1254
[10:21:26.384]  - attr(*, "already-done")= logi TRUE
[10:21:26.387] - reassign environment for ‘outer_function’
[10:21:26.387] - copied ‘outer_function’ to environment
[10:21:26.388] - reassign environment for ‘map’
[10:21:26.388] - copied ‘map’ to environment
[10:21:26.388] - reassign environment for ‘inner_function’
[10:21:26.388] - copied ‘inner_function’ to environment
[10:21:26.388] assign_globals() ... done
[10:21:26.388] plan(): Setting new future strategy stack:
[10:21:26.388] List of future strategies:
[10:21:26.388] 1. sequential:
[10:21:26.388]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.388]    - tweaked: FALSE
[10:21:26.388]    - call: NULL
[10:21:26.389] plan(): nbrOfWorkers() = 1
[10:21:26.393] plan(): Setting new future strategy stack:
[10:21:26.393] List of future strategies:
[10:21:26.393] 1. sequential:
[10:21:26.393]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.393]    - tweaked: FALSE
[10:21:26.393]    - call: plan(strategy)
[10:21:26.394] plan(): nbrOfWorkers() = 1
[10:21:26.394] SequentialFuture started (and completed)
[10:21:26.394] - Launch lazy future ... done
[10:21:26.394] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[10:21:26.395] getGlobalsAndPackages() ...
[10:21:26.395] Searching for globals...
[10:21:26.400] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[10:21:26.400] Searching for globals ... DONE
[10:21:26.400] Resolving globals: FALSE
[10:21:26.401] The total size of the 3 globals is 1.22 KiB (1254 bytes)
[10:21:26.401] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (633 bytes of class ‘function’), ‘inner_function’ (371 bytes of class ‘function’) and ‘outer_function’ (250 bytes of class ‘function’)
[10:21:26.402] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[10:21:26.402] 
[10:21:26.402] getGlobalsAndPackages() ... DONE
[10:21:26.402] run() for ‘Future’ ...
[10:21:26.402] - state: ‘created’
[10:21:26.402] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:26.402] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:26.402] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:26.403]   - Field: ‘label’
[10:21:26.403]   - Field: ‘local’
[10:21:26.403]   - Field: ‘owner’
[10:21:26.403]   - Field: ‘envir’
[10:21:26.403]   - Field: ‘packages’
[10:21:26.403]   - Field: ‘gc’
[10:21:26.403]   - Field: ‘conditions’
[10:21:26.403]   - Field: ‘expr’
[10:21:26.403]   - Field: ‘uuid’
[10:21:26.403]   - Field: ‘seed’
[10:21:26.403]   - Field: ‘version’
[10:21:26.403]   - Field: ‘result’
[10:21:26.404]   - Field: ‘asynchronous’
[10:21:26.404]   - Field: ‘calls’
[10:21:26.404]   - Field: ‘globals’
[10:21:26.404]   - Field: ‘stdout’
[10:21:26.404]   - Field: ‘earlySignal’
[10:21:26.404]   - Field: ‘lazy’
[10:21:26.404]   - Field: ‘state’
[10:21:26.404] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:26.404] - Launch lazy future ...
[10:21:26.404] Packages needed by the future expression (n = 0): <none>
[10:21:26.404] Packages needed by future strategies (n = 0): <none>
[10:21:26.405] {
[10:21:26.405]     {
[10:21:26.405]         {
[10:21:26.405]             ...future.startTime <- base::Sys.time()
[10:21:26.405]             {
[10:21:26.405]                 {
[10:21:26.405]                   {
[10:21:26.405]                     base::local({
[10:21:26.405]                       has_future <- base::requireNamespace("future", 
[10:21:26.405]                         quietly = TRUE)
[10:21:26.405]                       if (has_future) {
[10:21:26.405]                         ns <- base::getNamespace("future")
[10:21:26.405]                         version <- ns[[".package"]][["version"]]
[10:21:26.405]                         if (is.null(version)) 
[10:21:26.405]                           version <- utils::packageVersion("future")
[10:21:26.405]                       }
[10:21:26.405]                       else {
[10:21:26.405]                         version <- NULL
[10:21:26.405]                       }
[10:21:26.405]                       if (!has_future || version < "1.8.0") {
[10:21:26.405]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.405]                           "", base::R.version$version.string), 
[10:21:26.405]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:26.405]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:26.405]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.405]                             "release", "version")], collapse = " "), 
[10:21:26.405]                           hostname = base::Sys.info()[["nodename"]])
[10:21:26.405]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.405]                           info)
[10:21:26.405]                         info <- base::paste(info, collapse = "; ")
[10:21:26.405]                         if (!has_future) {
[10:21:26.405]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.405]                             info)
[10:21:26.405]                         }
[10:21:26.405]                         else {
[10:21:26.405]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.405]                             info, version)
[10:21:26.405]                         }
[10:21:26.405]                         base::stop(msg)
[10:21:26.405]                       }
[10:21:26.405]                     })
[10:21:26.405]                   }
[10:21:26.405]                   ...future.strategy.old <- future::plan("list")
[10:21:26.405]                   options(future.plan = NULL)
[10:21:26.405]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.405]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.405]                 }
[10:21:26.405]                 ...future.workdir <- getwd()
[10:21:26.405]             }
[10:21:26.405]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.405]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.405]         }
[10:21:26.405]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.405]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.405]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.405]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.405]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.405]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.405]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.405]             base::names(...future.oldOptions))
[10:21:26.405]     }
[10:21:26.405]     if (FALSE) {
[10:21:26.405]     }
[10:21:26.405]     else {
[10:21:26.405]         if (TRUE) {
[10:21:26.405]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.405]                 open = "w")
[10:21:26.405]         }
[10:21:26.405]         else {
[10:21:26.405]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.405]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.405]         }
[10:21:26.405]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.405]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.405]             base::sink(type = "output", split = FALSE)
[10:21:26.405]             base::close(...future.stdout)
[10:21:26.405]         }, add = TRUE)
[10:21:26.405]     }
[10:21:26.405]     ...future.frame <- base::sys.nframe()
[10:21:26.405]     ...future.conditions <- base::list()
[10:21:26.405]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.405]     if (FALSE) {
[10:21:26.405]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.405]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.405]     }
[10:21:26.405]     ...future.result <- base::tryCatch({
[10:21:26.405]         base::withCallingHandlers({
[10:21:26.405]             ...future.value <- base::withVisible(base::local({
[10:21:26.405]                 outer_function(1L)
[10:21:26.405]             }))
[10:21:26.405]             future::FutureResult(value = ...future.value$value, 
[10:21:26.405]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.405]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.405]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.405]                     ...future.globalenv.names))
[10:21:26.405]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.405]         }, condition = base::local({
[10:21:26.405]             c <- base::c
[10:21:26.405]             inherits <- base::inherits
[10:21:26.405]             invokeRestart <- base::invokeRestart
[10:21:26.405]             length <- base::length
[10:21:26.405]             list <- base::list
[10:21:26.405]             seq.int <- base::seq.int
[10:21:26.405]             signalCondition <- base::signalCondition
[10:21:26.405]             sys.calls <- base::sys.calls
[10:21:26.405]             `[[` <- base::`[[`
[10:21:26.405]             `+` <- base::`+`
[10:21:26.405]             `<<-` <- base::`<<-`
[10:21:26.405]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.405]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.405]                   3L)]
[10:21:26.405]             }
[10:21:26.405]             function(cond) {
[10:21:26.405]                 is_error <- inherits(cond, "error")
[10:21:26.405]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.405]                   NULL)
[10:21:26.405]                 if (is_error) {
[10:21:26.405]                   sessionInformation <- function() {
[10:21:26.405]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.405]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.405]                       search = base::search(), system = base::Sys.info())
[10:21:26.405]                   }
[10:21:26.405]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.405]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.405]                     cond$call), session = sessionInformation(), 
[10:21:26.405]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.405]                   signalCondition(cond)
[10:21:26.405]                 }
[10:21:26.405]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.405]                 "immediateCondition"))) {
[10:21:26.405]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.405]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.405]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.405]                   if (TRUE && !signal) {
[10:21:26.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.405]                     {
[10:21:26.405]                       inherits <- base::inherits
[10:21:26.405]                       invokeRestart <- base::invokeRestart
[10:21:26.405]                       is.null <- base::is.null
[10:21:26.405]                       muffled <- FALSE
[10:21:26.405]                       if (inherits(cond, "message")) {
[10:21:26.405]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.405]                         if (muffled) 
[10:21:26.405]                           invokeRestart("muffleMessage")
[10:21:26.405]                       }
[10:21:26.405]                       else if (inherits(cond, "warning")) {
[10:21:26.405]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.405]                         if (muffled) 
[10:21:26.405]                           invokeRestart("muffleWarning")
[10:21:26.405]                       }
[10:21:26.405]                       else if (inherits(cond, "condition")) {
[10:21:26.405]                         if (!is.null(pattern)) {
[10:21:26.405]                           computeRestarts <- base::computeRestarts
[10:21:26.405]                           grepl <- base::grepl
[10:21:26.405]                           restarts <- computeRestarts(cond)
[10:21:26.405]                           for (restart in restarts) {
[10:21:26.405]                             name <- restart$name
[10:21:26.405]                             if (is.null(name)) 
[10:21:26.405]                               next
[10:21:26.405]                             if (!grepl(pattern, name)) 
[10:21:26.405]                               next
[10:21:26.405]                             invokeRestart(restart)
[10:21:26.405]                             muffled <- TRUE
[10:21:26.405]                             break
[10:21:26.405]                           }
[10:21:26.405]                         }
[10:21:26.405]                       }
[10:21:26.405]                       invisible(muffled)
[10:21:26.405]                     }
[10:21:26.405]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.405]                   }
[10:21:26.405]                 }
[10:21:26.405]                 else {
[10:21:26.405]                   if (TRUE) {
[10:21:26.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.405]                     {
[10:21:26.405]                       inherits <- base::inherits
[10:21:26.405]                       invokeRestart <- base::invokeRestart
[10:21:26.405]                       is.null <- base::is.null
[10:21:26.405]                       muffled <- FALSE
[10:21:26.405]                       if (inherits(cond, "message")) {
[10:21:26.405]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.405]                         if (muffled) 
[10:21:26.405]                           invokeRestart("muffleMessage")
[10:21:26.405]                       }
[10:21:26.405]                       else if (inherits(cond, "warning")) {
[10:21:26.405]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.405]                         if (muffled) 
[10:21:26.405]                           invokeRestart("muffleWarning")
[10:21:26.405]                       }
[10:21:26.405]                       else if (inherits(cond, "condition")) {
[10:21:26.405]                         if (!is.null(pattern)) {
[10:21:26.405]                           computeRestarts <- base::computeRestarts
[10:21:26.405]                           grepl <- base::grepl
[10:21:26.405]                           restarts <- computeRestarts(cond)
[10:21:26.405]                           for (restart in restarts) {
[10:21:26.405]                             name <- restart$name
[10:21:26.405]                             if (is.null(name)) 
[10:21:26.405]                               next
[10:21:26.405]                             if (!grepl(pattern, name)) 
[10:21:26.405]                               next
[10:21:26.405]                             invokeRestart(restart)
[10:21:26.405]                             muffled <- TRUE
[10:21:26.405]                             break
[10:21:26.405]                           }
[10:21:26.405]                         }
[10:21:26.405]                       }
[10:21:26.405]                       invisible(muffled)
[10:21:26.405]                     }
[10:21:26.405]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.405]                   }
[10:21:26.405]                 }
[10:21:26.405]             }
[10:21:26.405]         }))
[10:21:26.405]     }, error = function(ex) {
[10:21:26.405]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.405]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.405]                 ...future.rng), started = ...future.startTime, 
[10:21:26.405]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.405]             version = "1.8"), class = "FutureResult")
[10:21:26.405]     }, finally = {
[10:21:26.405]         if (!identical(...future.workdir, getwd())) 
[10:21:26.405]             setwd(...future.workdir)
[10:21:26.405]         {
[10:21:26.405]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.405]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.405]             }
[10:21:26.405]             base::options(...future.oldOptions)
[10:21:26.405]             if (.Platform$OS.type == "windows") {
[10:21:26.405]                 old_names <- names(...future.oldEnvVars)
[10:21:26.405]                 envs <- base::Sys.getenv()
[10:21:26.405]                 names <- names(envs)
[10:21:26.405]                 common <- intersect(names, old_names)
[10:21:26.405]                 added <- setdiff(names, old_names)
[10:21:26.405]                 removed <- setdiff(old_names, names)
[10:21:26.405]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.405]                   envs[common]]
[10:21:26.405]                 NAMES <- toupper(changed)
[10:21:26.405]                 args <- list()
[10:21:26.405]                 for (kk in seq_along(NAMES)) {
[10:21:26.405]                   name <- changed[[kk]]
[10:21:26.405]                   NAME <- NAMES[[kk]]
[10:21:26.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.405]                     next
[10:21:26.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.405]                 }
[10:21:26.405]                 NAMES <- toupper(added)
[10:21:26.405]                 for (kk in seq_along(NAMES)) {
[10:21:26.405]                   name <- added[[kk]]
[10:21:26.405]                   NAME <- NAMES[[kk]]
[10:21:26.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.405]                     next
[10:21:26.405]                   args[[name]] <- ""
[10:21:26.405]                 }
[10:21:26.405]                 NAMES <- toupper(removed)
[10:21:26.405]                 for (kk in seq_along(NAMES)) {
[10:21:26.405]                   name <- removed[[kk]]
[10:21:26.405]                   NAME <- NAMES[[kk]]
[10:21:26.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.405]                     next
[10:21:26.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.405]                 }
[10:21:26.405]                 if (length(args) > 0) 
[10:21:26.405]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.405]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.405]             }
[10:21:26.405]             else {
[10:21:26.405]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.405]             }
[10:21:26.405]             {
[10:21:26.405]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.405]                   0L) {
[10:21:26.405]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.405]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.405]                   base::options(opts)
[10:21:26.405]                 }
[10:21:26.405]                 {
[10:21:26.405]                   {
[10:21:26.405]                     NULL
[10:21:26.405]                     RNGkind("Mersenne-Twister")
[10:21:26.405]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:26.405]                       inherits = FALSE)
[10:21:26.405]                   }
[10:21:26.405]                   options(future.plan = NULL)
[10:21:26.405]                   if (is.na(NA_character_)) 
[10:21:26.405]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.405]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.405]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.405]                     .init = FALSE)
[10:21:26.405]                 }
[10:21:26.405]             }
[10:21:26.405]         }
[10:21:26.405]     })
[10:21:26.405]     if (TRUE) {
[10:21:26.405]         base::sink(type = "output", split = FALSE)
[10:21:26.405]         if (TRUE) {
[10:21:26.405]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.405]         }
[10:21:26.405]         else {
[10:21:26.405]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.405]         }
[10:21:26.405]         base::close(...future.stdout)
[10:21:26.405]         ...future.stdout <- NULL
[10:21:26.405]     }
[10:21:26.405]     ...future.result$conditions <- ...future.conditions
[10:21:26.405]     ...future.result$finished <- base::Sys.time()
[10:21:26.405]     ...future.result
[10:21:26.405] }
[10:21:26.406] assign_globals() ...
[10:21:26.407] List of 3
[10:21:26.407]  $ outer_function:function (x)  
[10:21:26.407]  $ map           :function (.x, .f, ...)  
[10:21:26.407]  $ inner_function:function (x)  
[10:21:26.407]  - attr(*, "where")=List of 3
[10:21:26.407]   ..$ outer_function:<environment: R_EmptyEnv> 
[10:21:26.407]   ..$ map           :<environment: R_EmptyEnv> 
[10:21:26.407]   ..$ inner_function:<environment: R_EmptyEnv> 
[10:21:26.407]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:26.407]  - attr(*, "resolved")= logi FALSE
[10:21:26.407]  - attr(*, "total_size")= num 1254
[10:21:26.407]  - attr(*, "already-done")= logi TRUE
[10:21:26.409] - reassign environment for ‘outer_function’
[10:21:26.410] - copied ‘outer_function’ to environment
[10:21:26.410] - reassign environment for ‘map’
[10:21:26.410] - copied ‘map’ to environment
[10:21:26.410] - reassign environment for ‘inner_function’
[10:21:26.410] - copied ‘inner_function’ to environment
[10:21:26.410] assign_globals() ... done
[10:21:26.410] plan(): Setting new future strategy stack:
[10:21:26.410] List of future strategies:
[10:21:26.410] 1. sequential:
[10:21:26.410]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.410]    - tweaked: FALSE
[10:21:26.410]    - call: NULL
[10:21:26.411] plan(): nbrOfWorkers() = 1
[10:21:26.411] plan(): Setting new future strategy stack:
[10:21:26.412] List of future strategies:
[10:21:26.412] 1. sequential:
[10:21:26.412]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.412]    - tweaked: FALSE
[10:21:26.412]    - call: plan(strategy)
[10:21:26.412] plan(): nbrOfWorkers() = 1
[10:21:26.412] SequentialFuture started (and completed)
[10:21:26.412] - Launch lazy future ... done
[10:21:26.412] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[10:21:26.420] plan(): Setting new future strategy stack:
[10:21:26.421] List of future strategies:
[10:21:26.421] 1. multicore:
[10:21:26.421]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:26.421]    - tweaked: FALSE
[10:21:26.421]    - call: plan(strategy)
[10:21:26.422] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[10:21:26.422] getGlobalsAndPackages() ...
[10:21:26.422] Searching for globals...
[10:21:26.424] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:21:26.424] Searching for globals ... DONE
[10:21:26.424] Resolving globals: FALSE
[10:21:26.424] The total size of the 2 globals is 401 bytes (401 bytes)
[10:21:26.425] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[10:21:26.425] - globals: [2] ‘weight’, ‘group’
[10:21:26.425] - packages: [1] ‘stats’
[10:21:26.425] getGlobalsAndPackages() ... DONE
[10:21:26.425] run() for ‘Future’ ...
[10:21:26.425] - state: ‘created’
[10:21:26.425] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:26.427] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:26.427] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:26.427]   - Field: ‘label’
[10:21:26.427]   - Field: ‘local’
[10:21:26.427]   - Field: ‘owner’
[10:21:26.428]   - Field: ‘envir’
[10:21:26.428]   - Field: ‘workers’
[10:21:26.428]   - Field: ‘packages’
[10:21:26.428]   - Field: ‘gc’
[10:21:26.428]   - Field: ‘job’
[10:21:26.428]   - Field: ‘conditions’
[10:21:26.428]   - Field: ‘expr’
[10:21:26.428]   - Field: ‘uuid’
[10:21:26.428]   - Field: ‘seed’
[10:21:26.428]   - Field: ‘version’
[10:21:26.428]   - Field: ‘result’
[10:21:26.428]   - Field: ‘asynchronous’
[10:21:26.428]   - Field: ‘calls’
[10:21:26.429]   - Field: ‘globals’
[10:21:26.429]   - Field: ‘stdout’
[10:21:26.429]   - Field: ‘earlySignal’
[10:21:26.429]   - Field: ‘lazy’
[10:21:26.429]   - Field: ‘state’
[10:21:26.429] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:26.429] - Launch lazy future ...
[10:21:26.430] Packages needed by the future expression (n = 1): ‘stats’
[10:21:26.430] Packages needed by future strategies (n = 0): <none>
[10:21:26.430] {
[10:21:26.430]     {
[10:21:26.430]         {
[10:21:26.430]             ...future.startTime <- base::Sys.time()
[10:21:26.430]             {
[10:21:26.430]                 {
[10:21:26.430]                   {
[10:21:26.430]                     {
[10:21:26.430]                       {
[10:21:26.430]                         base::local({
[10:21:26.430]                           has_future <- base::requireNamespace("future", 
[10:21:26.430]                             quietly = TRUE)
[10:21:26.430]                           if (has_future) {
[10:21:26.430]                             ns <- base::getNamespace("future")
[10:21:26.430]                             version <- ns[[".package"]][["version"]]
[10:21:26.430]                             if (is.null(version)) 
[10:21:26.430]                               version <- utils::packageVersion("future")
[10:21:26.430]                           }
[10:21:26.430]                           else {
[10:21:26.430]                             version <- NULL
[10:21:26.430]                           }
[10:21:26.430]                           if (!has_future || version < "1.8.0") {
[10:21:26.430]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.430]                               "", base::R.version$version.string), 
[10:21:26.430]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:26.430]                                 base::R.version$platform, 8 * 
[10:21:26.430]                                   base::.Machine$sizeof.pointer), 
[10:21:26.430]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.430]                                 "release", "version")], collapse = " "), 
[10:21:26.430]                               hostname = base::Sys.info()[["nodename"]])
[10:21:26.430]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.430]                               info)
[10:21:26.430]                             info <- base::paste(info, collapse = "; ")
[10:21:26.430]                             if (!has_future) {
[10:21:26.430]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.430]                                 info)
[10:21:26.430]                             }
[10:21:26.430]                             else {
[10:21:26.430]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.430]                                 info, version)
[10:21:26.430]                             }
[10:21:26.430]                             base::stop(msg)
[10:21:26.430]                           }
[10:21:26.430]                         })
[10:21:26.430]                       }
[10:21:26.430]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:26.430]                       base::options(mc.cores = 1L)
[10:21:26.430]                     }
[10:21:26.430]                     base::local({
[10:21:26.430]                       for (pkg in "stats") {
[10:21:26.430]                         base::loadNamespace(pkg)
[10:21:26.430]                         base::library(pkg, character.only = TRUE)
[10:21:26.430]                       }
[10:21:26.430]                     })
[10:21:26.430]                   }
[10:21:26.430]                   ...future.strategy.old <- future::plan("list")
[10:21:26.430]                   options(future.plan = NULL)
[10:21:26.430]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.430]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.430]                 }
[10:21:26.430]                 ...future.workdir <- getwd()
[10:21:26.430]             }
[10:21:26.430]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.430]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.430]         }
[10:21:26.430]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.430]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.430]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.430]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.430]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.430]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.430]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.430]             base::names(...future.oldOptions))
[10:21:26.430]     }
[10:21:26.430]     if (FALSE) {
[10:21:26.430]     }
[10:21:26.430]     else {
[10:21:26.430]         if (TRUE) {
[10:21:26.430]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.430]                 open = "w")
[10:21:26.430]         }
[10:21:26.430]         else {
[10:21:26.430]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.430]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.430]         }
[10:21:26.430]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.430]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.430]             base::sink(type = "output", split = FALSE)
[10:21:26.430]             base::close(...future.stdout)
[10:21:26.430]         }, add = TRUE)
[10:21:26.430]     }
[10:21:26.430]     ...future.frame <- base::sys.nframe()
[10:21:26.430]     ...future.conditions <- base::list()
[10:21:26.430]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.430]     if (FALSE) {
[10:21:26.430]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.430]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.430]     }
[10:21:26.430]     ...future.result <- base::tryCatch({
[10:21:26.430]         base::withCallingHandlers({
[10:21:26.430]             ...future.value <- base::withVisible(base::local({
[10:21:26.430]                 withCallingHandlers({
[10:21:26.430]                   {
[10:21:26.430]                     lm(weight ~ group - 1)
[10:21:26.430]                   }
[10:21:26.430]                 }, immediateCondition = function(cond) {
[10:21:26.430]                   save_rds <- function (object, pathname, ...) 
[10:21:26.430]                   {
[10:21:26.430]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:26.430]                     if (file_test("-f", pathname_tmp)) {
[10:21:26.430]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.430]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:26.430]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.430]                         fi_tmp[["mtime"]])
[10:21:26.430]                     }
[10:21:26.430]                     tryCatch({
[10:21:26.430]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:26.430]                     }, error = function(ex) {
[10:21:26.430]                       msg <- conditionMessage(ex)
[10:21:26.430]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.430]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:26.430]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.430]                         fi_tmp[["mtime"]], msg)
[10:21:26.430]                       ex$message <- msg
[10:21:26.430]                       stop(ex)
[10:21:26.430]                     })
[10:21:26.430]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:26.430]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:26.430]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:26.430]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.430]                       fi <- file.info(pathname)
[10:21:26.430]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:26.430]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.430]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:26.430]                         fi[["size"]], fi[["mtime"]])
[10:21:26.430]                       stop(msg)
[10:21:26.430]                     }
[10:21:26.430]                     invisible(pathname)
[10:21:26.430]                   }
[10:21:26.430]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:26.430]                     rootPath = tempdir()) 
[10:21:26.430]                   {
[10:21:26.430]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:26.430]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:26.430]                       tmpdir = path, fileext = ".rds")
[10:21:26.430]                     save_rds(obj, file)
[10:21:26.430]                   }
[10:21:26.430]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0RHvXY/.future/immediateConditions")
[10:21:26.430]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.430]                   {
[10:21:26.430]                     inherits <- base::inherits
[10:21:26.430]                     invokeRestart <- base::invokeRestart
[10:21:26.430]                     is.null <- base::is.null
[10:21:26.430]                     muffled <- FALSE
[10:21:26.430]                     if (inherits(cond, "message")) {
[10:21:26.430]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:26.430]                       if (muffled) 
[10:21:26.430]                         invokeRestart("muffleMessage")
[10:21:26.430]                     }
[10:21:26.430]                     else if (inherits(cond, "warning")) {
[10:21:26.430]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:26.430]                       if (muffled) 
[10:21:26.430]                         invokeRestart("muffleWarning")
[10:21:26.430]                     }
[10:21:26.430]                     else if (inherits(cond, "condition")) {
[10:21:26.430]                       if (!is.null(pattern)) {
[10:21:26.430]                         computeRestarts <- base::computeRestarts
[10:21:26.430]                         grepl <- base::grepl
[10:21:26.430]                         restarts <- computeRestarts(cond)
[10:21:26.430]                         for (restart in restarts) {
[10:21:26.430]                           name <- restart$name
[10:21:26.430]                           if (is.null(name)) 
[10:21:26.430]                             next
[10:21:26.430]                           if (!grepl(pattern, name)) 
[10:21:26.430]                             next
[10:21:26.430]                           invokeRestart(restart)
[10:21:26.430]                           muffled <- TRUE
[10:21:26.430]                           break
[10:21:26.430]                         }
[10:21:26.430]                       }
[10:21:26.430]                     }
[10:21:26.430]                     invisible(muffled)
[10:21:26.430]                   }
[10:21:26.430]                   muffleCondition(cond)
[10:21:26.430]                 })
[10:21:26.430]             }))
[10:21:26.430]             future::FutureResult(value = ...future.value$value, 
[10:21:26.430]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.430]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.430]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.430]                     ...future.globalenv.names))
[10:21:26.430]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.430]         }, condition = base::local({
[10:21:26.430]             c <- base::c
[10:21:26.430]             inherits <- base::inherits
[10:21:26.430]             invokeRestart <- base::invokeRestart
[10:21:26.430]             length <- base::length
[10:21:26.430]             list <- base::list
[10:21:26.430]             seq.int <- base::seq.int
[10:21:26.430]             signalCondition <- base::signalCondition
[10:21:26.430]             sys.calls <- base::sys.calls
[10:21:26.430]             `[[` <- base::`[[`
[10:21:26.430]             `+` <- base::`+`
[10:21:26.430]             `<<-` <- base::`<<-`
[10:21:26.430]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.430]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.430]                   3L)]
[10:21:26.430]             }
[10:21:26.430]             function(cond) {
[10:21:26.430]                 is_error <- inherits(cond, "error")
[10:21:26.430]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.430]                   NULL)
[10:21:26.430]                 if (is_error) {
[10:21:26.430]                   sessionInformation <- function() {
[10:21:26.430]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.430]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.430]                       search = base::search(), system = base::Sys.info())
[10:21:26.430]                   }
[10:21:26.430]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.430]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.430]                     cond$call), session = sessionInformation(), 
[10:21:26.430]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.430]                   signalCondition(cond)
[10:21:26.430]                 }
[10:21:26.430]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.430]                 "immediateCondition"))) {
[10:21:26.430]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.430]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.430]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.430]                   if (TRUE && !signal) {
[10:21:26.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.430]                     {
[10:21:26.430]                       inherits <- base::inherits
[10:21:26.430]                       invokeRestart <- base::invokeRestart
[10:21:26.430]                       is.null <- base::is.null
[10:21:26.430]                       muffled <- FALSE
[10:21:26.430]                       if (inherits(cond, "message")) {
[10:21:26.430]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.430]                         if (muffled) 
[10:21:26.430]                           invokeRestart("muffleMessage")
[10:21:26.430]                       }
[10:21:26.430]                       else if (inherits(cond, "warning")) {
[10:21:26.430]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.430]                         if (muffled) 
[10:21:26.430]                           invokeRestart("muffleWarning")
[10:21:26.430]                       }
[10:21:26.430]                       else if (inherits(cond, "condition")) {
[10:21:26.430]                         if (!is.null(pattern)) {
[10:21:26.430]                           computeRestarts <- base::computeRestarts
[10:21:26.430]                           grepl <- base::grepl
[10:21:26.430]                           restarts <- computeRestarts(cond)
[10:21:26.430]                           for (restart in restarts) {
[10:21:26.430]                             name <- restart$name
[10:21:26.430]                             if (is.null(name)) 
[10:21:26.430]                               next
[10:21:26.430]                             if (!grepl(pattern, name)) 
[10:21:26.430]                               next
[10:21:26.430]                             invokeRestart(restart)
[10:21:26.430]                             muffled <- TRUE
[10:21:26.430]                             break
[10:21:26.430]                           }
[10:21:26.430]                         }
[10:21:26.430]                       }
[10:21:26.430]                       invisible(muffled)
[10:21:26.430]                     }
[10:21:26.430]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.430]                   }
[10:21:26.430]                 }
[10:21:26.430]                 else {
[10:21:26.430]                   if (TRUE) {
[10:21:26.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.430]                     {
[10:21:26.430]                       inherits <- base::inherits
[10:21:26.430]                       invokeRestart <- base::invokeRestart
[10:21:26.430]                       is.null <- base::is.null
[10:21:26.430]                       muffled <- FALSE
[10:21:26.430]                       if (inherits(cond, "message")) {
[10:21:26.430]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.430]                         if (muffled) 
[10:21:26.430]                           invokeRestart("muffleMessage")
[10:21:26.430]                       }
[10:21:26.430]                       else if (inherits(cond, "warning")) {
[10:21:26.430]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.430]                         if (muffled) 
[10:21:26.430]                           invokeRestart("muffleWarning")
[10:21:26.430]                       }
[10:21:26.430]                       else if (inherits(cond, "condition")) {
[10:21:26.430]                         if (!is.null(pattern)) {
[10:21:26.430]                           computeRestarts <- base::computeRestarts
[10:21:26.430]                           grepl <- base::grepl
[10:21:26.430]                           restarts <- computeRestarts(cond)
[10:21:26.430]                           for (restart in restarts) {
[10:21:26.430]                             name <- restart$name
[10:21:26.430]                             if (is.null(name)) 
[10:21:26.430]                               next
[10:21:26.430]                             if (!grepl(pattern, name)) 
[10:21:26.430]                               next
[10:21:26.430]                             invokeRestart(restart)
[10:21:26.430]                             muffled <- TRUE
[10:21:26.430]                             break
[10:21:26.430]                           }
[10:21:26.430]                         }
[10:21:26.430]                       }
[10:21:26.430]                       invisible(muffled)
[10:21:26.430]                     }
[10:21:26.430]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.430]                   }
[10:21:26.430]                 }
[10:21:26.430]             }
[10:21:26.430]         }))
[10:21:26.430]     }, error = function(ex) {
[10:21:26.430]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.430]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.430]                 ...future.rng), started = ...future.startTime, 
[10:21:26.430]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.430]             version = "1.8"), class = "FutureResult")
[10:21:26.430]     }, finally = {
[10:21:26.430]         if (!identical(...future.workdir, getwd())) 
[10:21:26.430]             setwd(...future.workdir)
[10:21:26.430]         {
[10:21:26.430]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.430]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.430]             }
[10:21:26.430]             base::options(...future.oldOptions)
[10:21:26.430]             if (.Platform$OS.type == "windows") {
[10:21:26.430]                 old_names <- names(...future.oldEnvVars)
[10:21:26.430]                 envs <- base::Sys.getenv()
[10:21:26.430]                 names <- names(envs)
[10:21:26.430]                 common <- intersect(names, old_names)
[10:21:26.430]                 added <- setdiff(names, old_names)
[10:21:26.430]                 removed <- setdiff(old_names, names)
[10:21:26.430]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.430]                   envs[common]]
[10:21:26.430]                 NAMES <- toupper(changed)
[10:21:26.430]                 args <- list()
[10:21:26.430]                 for (kk in seq_along(NAMES)) {
[10:21:26.430]                   name <- changed[[kk]]
[10:21:26.430]                   NAME <- NAMES[[kk]]
[10:21:26.430]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.430]                     next
[10:21:26.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.430]                 }
[10:21:26.430]                 NAMES <- toupper(added)
[10:21:26.430]                 for (kk in seq_along(NAMES)) {
[10:21:26.430]                   name <- added[[kk]]
[10:21:26.430]                   NAME <- NAMES[[kk]]
[10:21:26.430]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.430]                     next
[10:21:26.430]                   args[[name]] <- ""
[10:21:26.430]                 }
[10:21:26.430]                 NAMES <- toupper(removed)
[10:21:26.430]                 for (kk in seq_along(NAMES)) {
[10:21:26.430]                   name <- removed[[kk]]
[10:21:26.430]                   NAME <- NAMES[[kk]]
[10:21:26.430]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.430]                     next
[10:21:26.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.430]                 }
[10:21:26.430]                 if (length(args) > 0) 
[10:21:26.430]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.430]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.430]             }
[10:21:26.430]             else {
[10:21:26.430]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.430]             }
[10:21:26.430]             {
[10:21:26.430]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.430]                   0L) {
[10:21:26.430]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.430]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.430]                   base::options(opts)
[10:21:26.430]                 }
[10:21:26.430]                 {
[10:21:26.430]                   {
[10:21:26.430]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:26.430]                     NULL
[10:21:26.430]                   }
[10:21:26.430]                   options(future.plan = NULL)
[10:21:26.430]                   if (is.na(NA_character_)) 
[10:21:26.430]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.430]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.430]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.430]                     .init = FALSE)
[10:21:26.430]                 }
[10:21:26.430]             }
[10:21:26.430]         }
[10:21:26.430]     })
[10:21:26.430]     if (TRUE) {
[10:21:26.430]         base::sink(type = "output", split = FALSE)
[10:21:26.430]         if (TRUE) {
[10:21:26.430]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.430]         }
[10:21:26.430]         else {
[10:21:26.430]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.430]         }
[10:21:26.430]         base::close(...future.stdout)
[10:21:26.430]         ...future.stdout <- NULL
[10:21:26.430]     }
[10:21:26.430]     ...future.result$conditions <- ...future.conditions
[10:21:26.430]     ...future.result$finished <- base::Sys.time()
[10:21:26.430]     ...future.result
[10:21:26.430] }
[10:21:26.433] assign_globals() ...
[10:21:26.433] List of 2
[10:21:26.433]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:21:26.433]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:21:26.433]  - attr(*, "where")=List of 2
[10:21:26.433]   ..$ weight:<environment: R_EmptyEnv> 
[10:21:26.433]   ..$ group :<environment: R_EmptyEnv> 
[10:21:26.433]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:26.433]  - attr(*, "resolved")= logi FALSE
[10:21:26.433]  - attr(*, "total_size")= num 401
[10:21:26.433]  - attr(*, "already-done")= logi TRUE
[10:21:26.436] - copied ‘weight’ to environment
[10:21:26.436] - copied ‘group’ to environment
[10:21:26.436] assign_globals() ... done
[10:21:26.436] requestCore(): workers = 2
[10:21:26.439] MulticoreFuture started
[10:21:26.439] - Launch lazy future ... done
[10:21:26.440] run() for ‘MulticoreFuture’ ... done
[10:21:26.440] plan(): Setting new future strategy stack:
[10:21:26.441] result() for MulticoreFuture ...
[10:21:26.440] List of future strategies:
[10:21:26.440] 1. sequential:
[10:21:26.440]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.440]    - tweaked: FALSE
[10:21:26.440]    - call: NULL
[10:21:26.441] plan(): nbrOfWorkers() = 1
[10:21:26.445] plan(): Setting new future strategy stack:
[10:21:26.445] List of future strategies:
[10:21:26.445] 1. multicore:
[10:21:26.445]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:26.445]    - tweaked: FALSE
[10:21:26.445]    - call: plan(strategy)
[10:21:26.448] plan(): nbrOfWorkers() = 2
[10:21:26.454] result() for MulticoreFuture ...
[10:21:26.454] result() for MulticoreFuture ... done
[10:21:26.454] result() for MulticoreFuture ... done
[10:21:26.454] result() for MulticoreFuture ...
[10:21:26.454] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:21:26.456] getGlobalsAndPackages() ...
[10:21:26.457] Searching for globals...
[10:21:26.461] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:21:26.461] Searching for globals ... DONE
[10:21:26.462] Resolving globals: FALSE
[10:21:26.462] The total size of the 2 globals is 401 bytes (401 bytes)
[10:21:26.463] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[10:21:26.463] - globals: [2] ‘weight’, ‘group’
[10:21:26.463] - packages: [1] ‘stats’
[10:21:26.463] getGlobalsAndPackages() ... DONE
[10:21:26.464] run() for ‘Future’ ...
[10:21:26.464] - state: ‘created’
[10:21:26.464] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:26.466] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:26.466] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:26.466]   - Field: ‘label’
[10:21:26.466]   - Field: ‘local’
[10:21:26.466]   - Field: ‘owner’
[10:21:26.467]   - Field: ‘envir’
[10:21:26.467]   - Field: ‘workers’
[10:21:26.467]   - Field: ‘packages’
[10:21:26.467]   - Field: ‘gc’
[10:21:26.467]   - Field: ‘job’
[10:21:26.467]   - Field: ‘conditions’
[10:21:26.467]   - Field: ‘expr’
[10:21:26.467]   - Field: ‘uuid’
[10:21:26.468]   - Field: ‘seed’
[10:21:26.468]   - Field: ‘version’
[10:21:26.468]   - Field: ‘result’
[10:21:26.468]   - Field: ‘asynchronous’
[10:21:26.468]   - Field: ‘calls’
[10:21:26.468]   - Field: ‘globals’
[10:21:26.468]   - Field: ‘stdout’
[10:21:26.468]   - Field: ‘earlySignal’
[10:21:26.468]   - Field: ‘lazy’
[10:21:26.468]   - Field: ‘state’
[10:21:26.469] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:26.469] - Launch lazy future ...
[10:21:26.469] Packages needed by the future expression (n = 1): ‘stats’
[10:21:26.469] Packages needed by future strategies (n = 0): <none>
[10:21:26.470] {
[10:21:26.470]     {
[10:21:26.470]         {
[10:21:26.470]             ...future.startTime <- base::Sys.time()
[10:21:26.470]             {
[10:21:26.470]                 {
[10:21:26.470]                   {
[10:21:26.470]                     {
[10:21:26.470]                       {
[10:21:26.470]                         base::local({
[10:21:26.470]                           has_future <- base::requireNamespace("future", 
[10:21:26.470]                             quietly = TRUE)
[10:21:26.470]                           if (has_future) {
[10:21:26.470]                             ns <- base::getNamespace("future")
[10:21:26.470]                             version <- ns[[".package"]][["version"]]
[10:21:26.470]                             if (is.null(version)) 
[10:21:26.470]                               version <- utils::packageVersion("future")
[10:21:26.470]                           }
[10:21:26.470]                           else {
[10:21:26.470]                             version <- NULL
[10:21:26.470]                           }
[10:21:26.470]                           if (!has_future || version < "1.8.0") {
[10:21:26.470]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.470]                               "", base::R.version$version.string), 
[10:21:26.470]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:26.470]                                 base::R.version$platform, 8 * 
[10:21:26.470]                                   base::.Machine$sizeof.pointer), 
[10:21:26.470]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.470]                                 "release", "version")], collapse = " "), 
[10:21:26.470]                               hostname = base::Sys.info()[["nodename"]])
[10:21:26.470]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.470]                               info)
[10:21:26.470]                             info <- base::paste(info, collapse = "; ")
[10:21:26.470]                             if (!has_future) {
[10:21:26.470]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.470]                                 info)
[10:21:26.470]                             }
[10:21:26.470]                             else {
[10:21:26.470]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.470]                                 info, version)
[10:21:26.470]                             }
[10:21:26.470]                             base::stop(msg)
[10:21:26.470]                           }
[10:21:26.470]                         })
[10:21:26.470]                       }
[10:21:26.470]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:26.470]                       base::options(mc.cores = 1L)
[10:21:26.470]                     }
[10:21:26.470]                     base::local({
[10:21:26.470]                       for (pkg in "stats") {
[10:21:26.470]                         base::loadNamespace(pkg)
[10:21:26.470]                         base::library(pkg, character.only = TRUE)
[10:21:26.470]                       }
[10:21:26.470]                     })
[10:21:26.470]                   }
[10:21:26.470]                   ...future.strategy.old <- future::plan("list")
[10:21:26.470]                   options(future.plan = NULL)
[10:21:26.470]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.470]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.470]                 }
[10:21:26.470]                 ...future.workdir <- getwd()
[10:21:26.470]             }
[10:21:26.470]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.470]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.470]         }
[10:21:26.470]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.470]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.470]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.470]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.470]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.470]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.470]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.470]             base::names(...future.oldOptions))
[10:21:26.470]     }
[10:21:26.470]     if (FALSE) {
[10:21:26.470]     }
[10:21:26.470]     else {
[10:21:26.470]         if (TRUE) {
[10:21:26.470]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.470]                 open = "w")
[10:21:26.470]         }
[10:21:26.470]         else {
[10:21:26.470]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.470]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.470]         }
[10:21:26.470]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.470]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.470]             base::sink(type = "output", split = FALSE)
[10:21:26.470]             base::close(...future.stdout)
[10:21:26.470]         }, add = TRUE)
[10:21:26.470]     }
[10:21:26.470]     ...future.frame <- base::sys.nframe()
[10:21:26.470]     ...future.conditions <- base::list()
[10:21:26.470]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.470]     if (FALSE) {
[10:21:26.470]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.470]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.470]     }
[10:21:26.470]     ...future.result <- base::tryCatch({
[10:21:26.470]         base::withCallingHandlers({
[10:21:26.470]             ...future.value <- base::withVisible(base::local({
[10:21:26.470]                 withCallingHandlers({
[10:21:26.470]                   {
[10:21:26.470]                     lm(weight ~ group - 1)
[10:21:26.470]                   }
[10:21:26.470]                 }, immediateCondition = function(cond) {
[10:21:26.470]                   save_rds <- function (object, pathname, ...) 
[10:21:26.470]                   {
[10:21:26.470]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:26.470]                     if (file_test("-f", pathname_tmp)) {
[10:21:26.470]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.470]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:26.470]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.470]                         fi_tmp[["mtime"]])
[10:21:26.470]                     }
[10:21:26.470]                     tryCatch({
[10:21:26.470]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:26.470]                     }, error = function(ex) {
[10:21:26.470]                       msg <- conditionMessage(ex)
[10:21:26.470]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.470]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:26.470]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.470]                         fi_tmp[["mtime"]], msg)
[10:21:26.470]                       ex$message <- msg
[10:21:26.470]                       stop(ex)
[10:21:26.470]                     })
[10:21:26.470]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:26.470]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:26.470]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:26.470]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.470]                       fi <- file.info(pathname)
[10:21:26.470]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:26.470]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.470]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:26.470]                         fi[["size"]], fi[["mtime"]])
[10:21:26.470]                       stop(msg)
[10:21:26.470]                     }
[10:21:26.470]                     invisible(pathname)
[10:21:26.470]                   }
[10:21:26.470]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:26.470]                     rootPath = tempdir()) 
[10:21:26.470]                   {
[10:21:26.470]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:26.470]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:26.470]                       tmpdir = path, fileext = ".rds")
[10:21:26.470]                     save_rds(obj, file)
[10:21:26.470]                   }
[10:21:26.470]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0RHvXY/.future/immediateConditions")
[10:21:26.470]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.470]                   {
[10:21:26.470]                     inherits <- base::inherits
[10:21:26.470]                     invokeRestart <- base::invokeRestart
[10:21:26.470]                     is.null <- base::is.null
[10:21:26.470]                     muffled <- FALSE
[10:21:26.470]                     if (inherits(cond, "message")) {
[10:21:26.470]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:26.470]                       if (muffled) 
[10:21:26.470]                         invokeRestart("muffleMessage")
[10:21:26.470]                     }
[10:21:26.470]                     else if (inherits(cond, "warning")) {
[10:21:26.470]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:26.470]                       if (muffled) 
[10:21:26.470]                         invokeRestart("muffleWarning")
[10:21:26.470]                     }
[10:21:26.470]                     else if (inherits(cond, "condition")) {
[10:21:26.470]                       if (!is.null(pattern)) {
[10:21:26.470]                         computeRestarts <- base::computeRestarts
[10:21:26.470]                         grepl <- base::grepl
[10:21:26.470]                         restarts <- computeRestarts(cond)
[10:21:26.470]                         for (restart in restarts) {
[10:21:26.470]                           name <- restart$name
[10:21:26.470]                           if (is.null(name)) 
[10:21:26.470]                             next
[10:21:26.470]                           if (!grepl(pattern, name)) 
[10:21:26.470]                             next
[10:21:26.470]                           invokeRestart(restart)
[10:21:26.470]                           muffled <- TRUE
[10:21:26.470]                           break
[10:21:26.470]                         }
[10:21:26.470]                       }
[10:21:26.470]                     }
[10:21:26.470]                     invisible(muffled)
[10:21:26.470]                   }
[10:21:26.470]                   muffleCondition(cond)
[10:21:26.470]                 })
[10:21:26.470]             }))
[10:21:26.470]             future::FutureResult(value = ...future.value$value, 
[10:21:26.470]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.470]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.470]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.470]                     ...future.globalenv.names))
[10:21:26.470]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.470]         }, condition = base::local({
[10:21:26.470]             c <- base::c
[10:21:26.470]             inherits <- base::inherits
[10:21:26.470]             invokeRestart <- base::invokeRestart
[10:21:26.470]             length <- base::length
[10:21:26.470]             list <- base::list
[10:21:26.470]             seq.int <- base::seq.int
[10:21:26.470]             signalCondition <- base::signalCondition
[10:21:26.470]             sys.calls <- base::sys.calls
[10:21:26.470]             `[[` <- base::`[[`
[10:21:26.470]             `+` <- base::`+`
[10:21:26.470]             `<<-` <- base::`<<-`
[10:21:26.470]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.470]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.470]                   3L)]
[10:21:26.470]             }
[10:21:26.470]             function(cond) {
[10:21:26.470]                 is_error <- inherits(cond, "error")
[10:21:26.470]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.470]                   NULL)
[10:21:26.470]                 if (is_error) {
[10:21:26.470]                   sessionInformation <- function() {
[10:21:26.470]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.470]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.470]                       search = base::search(), system = base::Sys.info())
[10:21:26.470]                   }
[10:21:26.470]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.470]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.470]                     cond$call), session = sessionInformation(), 
[10:21:26.470]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.470]                   signalCondition(cond)
[10:21:26.470]                 }
[10:21:26.470]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.470]                 "immediateCondition"))) {
[10:21:26.470]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.470]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.470]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.470]                   if (TRUE && !signal) {
[10:21:26.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.470]                     {
[10:21:26.470]                       inherits <- base::inherits
[10:21:26.470]                       invokeRestart <- base::invokeRestart
[10:21:26.470]                       is.null <- base::is.null
[10:21:26.470]                       muffled <- FALSE
[10:21:26.470]                       if (inherits(cond, "message")) {
[10:21:26.470]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.470]                         if (muffled) 
[10:21:26.470]                           invokeRestart("muffleMessage")
[10:21:26.470]                       }
[10:21:26.470]                       else if (inherits(cond, "warning")) {
[10:21:26.470]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.470]                         if (muffled) 
[10:21:26.470]                           invokeRestart("muffleWarning")
[10:21:26.470]                       }
[10:21:26.470]                       else if (inherits(cond, "condition")) {
[10:21:26.470]                         if (!is.null(pattern)) {
[10:21:26.470]                           computeRestarts <- base::computeRestarts
[10:21:26.470]                           grepl <- base::grepl
[10:21:26.470]                           restarts <- computeRestarts(cond)
[10:21:26.470]                           for (restart in restarts) {
[10:21:26.470]                             name <- restart$name
[10:21:26.470]                             if (is.null(name)) 
[10:21:26.470]                               next
[10:21:26.470]                             if (!grepl(pattern, name)) 
[10:21:26.470]                               next
[10:21:26.470]                             invokeRestart(restart)
[10:21:26.470]                             muffled <- TRUE
[10:21:26.470]                             break
[10:21:26.470]                           }
[10:21:26.470]                         }
[10:21:26.470]                       }
[10:21:26.470]                       invisible(muffled)
[10:21:26.470]                     }
[10:21:26.470]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.470]                   }
[10:21:26.470]                 }
[10:21:26.470]                 else {
[10:21:26.470]                   if (TRUE) {
[10:21:26.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.470]                     {
[10:21:26.470]                       inherits <- base::inherits
[10:21:26.470]                       invokeRestart <- base::invokeRestart
[10:21:26.470]                       is.null <- base::is.null
[10:21:26.470]                       muffled <- FALSE
[10:21:26.470]                       if (inherits(cond, "message")) {
[10:21:26.470]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.470]                         if (muffled) 
[10:21:26.470]                           invokeRestart("muffleMessage")
[10:21:26.470]                       }
[10:21:26.470]                       else if (inherits(cond, "warning")) {
[10:21:26.470]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.470]                         if (muffled) 
[10:21:26.470]                           invokeRestart("muffleWarning")
[10:21:26.470]                       }
[10:21:26.470]                       else if (inherits(cond, "condition")) {
[10:21:26.470]                         if (!is.null(pattern)) {
[10:21:26.470]                           computeRestarts <- base::computeRestarts
[10:21:26.470]                           grepl <- base::grepl
[10:21:26.470]                           restarts <- computeRestarts(cond)
[10:21:26.470]                           for (restart in restarts) {
[10:21:26.470]                             name <- restart$name
[10:21:26.470]                             if (is.null(name)) 
[10:21:26.470]                               next
[10:21:26.470]                             if (!grepl(pattern, name)) 
[10:21:26.470]                               next
[10:21:26.470]                             invokeRestart(restart)
[10:21:26.470]                             muffled <- TRUE
[10:21:26.470]                             break
[10:21:26.470]                           }
[10:21:26.470]                         }
[10:21:26.470]                       }
[10:21:26.470]                       invisible(muffled)
[10:21:26.470]                     }
[10:21:26.470]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.470]                   }
[10:21:26.470]                 }
[10:21:26.470]             }
[10:21:26.470]         }))
[10:21:26.470]     }, error = function(ex) {
[10:21:26.470]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.470]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.470]                 ...future.rng), started = ...future.startTime, 
[10:21:26.470]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.470]             version = "1.8"), class = "FutureResult")
[10:21:26.470]     }, finally = {
[10:21:26.470]         if (!identical(...future.workdir, getwd())) 
[10:21:26.470]             setwd(...future.workdir)
[10:21:26.470]         {
[10:21:26.470]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.470]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.470]             }
[10:21:26.470]             base::options(...future.oldOptions)
[10:21:26.470]             if (.Platform$OS.type == "windows") {
[10:21:26.470]                 old_names <- names(...future.oldEnvVars)
[10:21:26.470]                 envs <- base::Sys.getenv()
[10:21:26.470]                 names <- names(envs)
[10:21:26.470]                 common <- intersect(names, old_names)
[10:21:26.470]                 added <- setdiff(names, old_names)
[10:21:26.470]                 removed <- setdiff(old_names, names)
[10:21:26.470]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.470]                   envs[common]]
[10:21:26.470]                 NAMES <- toupper(changed)
[10:21:26.470]                 args <- list()
[10:21:26.470]                 for (kk in seq_along(NAMES)) {
[10:21:26.470]                   name <- changed[[kk]]
[10:21:26.470]                   NAME <- NAMES[[kk]]
[10:21:26.470]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.470]                     next
[10:21:26.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.470]                 }
[10:21:26.470]                 NAMES <- toupper(added)
[10:21:26.470]                 for (kk in seq_along(NAMES)) {
[10:21:26.470]                   name <- added[[kk]]
[10:21:26.470]                   NAME <- NAMES[[kk]]
[10:21:26.470]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.470]                     next
[10:21:26.470]                   args[[name]] <- ""
[10:21:26.470]                 }
[10:21:26.470]                 NAMES <- toupper(removed)
[10:21:26.470]                 for (kk in seq_along(NAMES)) {
[10:21:26.470]                   name <- removed[[kk]]
[10:21:26.470]                   NAME <- NAMES[[kk]]
[10:21:26.470]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.470]                     next
[10:21:26.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.470]                 }
[10:21:26.470]                 if (length(args) > 0) 
[10:21:26.470]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.470]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.470]             }
[10:21:26.470]             else {
[10:21:26.470]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.470]             }
[10:21:26.470]             {
[10:21:26.470]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.470]                   0L) {
[10:21:26.470]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.470]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.470]                   base::options(opts)
[10:21:26.470]                 }
[10:21:26.470]                 {
[10:21:26.470]                   {
[10:21:26.470]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:26.470]                     NULL
[10:21:26.470]                   }
[10:21:26.470]                   options(future.plan = NULL)
[10:21:26.470]                   if (is.na(NA_character_)) 
[10:21:26.470]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.470]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.470]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.470]                     .init = FALSE)
[10:21:26.470]                 }
[10:21:26.470]             }
[10:21:26.470]         }
[10:21:26.470]     })
[10:21:26.470]     if (TRUE) {
[10:21:26.470]         base::sink(type = "output", split = FALSE)
[10:21:26.470]         if (TRUE) {
[10:21:26.470]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.470]         }
[10:21:26.470]         else {
[10:21:26.470]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.470]         }
[10:21:26.470]         base::close(...future.stdout)
[10:21:26.470]         ...future.stdout <- NULL
[10:21:26.470]     }
[10:21:26.470]     ...future.result$conditions <- ...future.conditions
[10:21:26.470]     ...future.result$finished <- base::Sys.time()
[10:21:26.470]     ...future.result
[10:21:26.470] }
[10:21:26.472] assign_globals() ...
[10:21:26.472] List of 2
[10:21:26.472]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:21:26.472]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:21:26.472]  - attr(*, "where")=List of 2
[10:21:26.472]   ..$ weight:<environment: R_EmptyEnv> 
[10:21:26.472]   ..$ group :<environment: R_EmptyEnv> 
[10:21:26.472]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:26.472]  - attr(*, "resolved")= logi FALSE
[10:21:26.472]  - attr(*, "total_size")= num 401
[10:21:26.472]  - attr(*, "already-done")= logi TRUE
[10:21:26.476] - copied ‘weight’ to environment
[10:21:26.476] - copied ‘group’ to environment
[10:21:26.476] assign_globals() ... done
[10:21:26.476] requestCore(): workers = 2
[10:21:26.478] MulticoreFuture started
[10:21:26.479] - Launch lazy future ... done
[10:21:26.479] run() for ‘MulticoreFuture’ ... done
[10:21:26.479] result() for MulticoreFuture ...
[10:21:26.479] plan(): Setting new future strategy stack:
[10:21:26.479] List of future strategies:
[10:21:26.479] 1. sequential:
[10:21:26.479]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.479]    - tweaked: FALSE
[10:21:26.479]    - call: NULL
[10:21:26.480] plan(): nbrOfWorkers() = 1
[10:21:26.484] plan(): Setting new future strategy stack:
[10:21:26.484] List of future strategies:
[10:21:26.484] 1. multicore:
[10:21:26.484]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:26.484]    - tweaked: FALSE
[10:21:26.484]    - call: plan(strategy)
[10:21:26.487] plan(): nbrOfWorkers() = 2
[10:21:26.489] result() for MulticoreFuture ...
[10:21:26.489] result() for MulticoreFuture ... done
[10:21:26.490] result() for MulticoreFuture ... done
[10:21:26.490] result() for MulticoreFuture ...
[10:21:26.490] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:21:26.492] getGlobalsAndPackages() ...
[10:21:26.493] Searching for globals...
[10:21:26.495] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:21:26.495] Searching for globals ... DONE
[10:21:26.495] Resolving globals: FALSE
[10:21:26.496] The total size of the 2 globals is 401 bytes (401 bytes)
[10:21:26.496] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[10:21:26.496] - globals: [2] ‘weight’, ‘group’
[10:21:26.496] - packages: [1] ‘stats’
[10:21:26.497] getGlobalsAndPackages() ... DONE
[10:21:26.497] run() for ‘Future’ ...
[10:21:26.497] - state: ‘created’
[10:21:26.497] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:26.499] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:26.499] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:26.499]   - Field: ‘label’
[10:21:26.500]   - Field: ‘local’
[10:21:26.500]   - Field: ‘owner’
[10:21:26.500]   - Field: ‘envir’
[10:21:26.502]   - Field: ‘workers’
[10:21:26.502]   - Field: ‘packages’
[10:21:26.502]   - Field: ‘gc’
[10:21:26.502]   - Field: ‘job’
[10:21:26.502]   - Field: ‘conditions’
[10:21:26.503]   - Field: ‘expr’
[10:21:26.503]   - Field: ‘uuid’
[10:21:26.503]   - Field: ‘seed’
[10:21:26.503]   - Field: ‘version’
[10:21:26.503]   - Field: ‘result’
[10:21:26.503]   - Field: ‘asynchronous’
[10:21:26.503]   - Field: ‘calls’
[10:21:26.503]   - Field: ‘globals’
[10:21:26.504]   - Field: ‘stdout’
[10:21:26.504]   - Field: ‘earlySignal’
[10:21:26.504]   - Field: ‘lazy’
[10:21:26.504]   - Field: ‘state’
[10:21:26.504] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:26.504] - Launch lazy future ...
[10:21:26.505] Packages needed by the future expression (n = 1): ‘stats’
[10:21:26.505] Packages needed by future strategies (n = 0): <none>
[10:21:26.505] {
[10:21:26.505]     {
[10:21:26.505]         {
[10:21:26.505]             ...future.startTime <- base::Sys.time()
[10:21:26.505]             {
[10:21:26.505]                 {
[10:21:26.505]                   {
[10:21:26.505]                     {
[10:21:26.505]                       {
[10:21:26.505]                         base::local({
[10:21:26.505]                           has_future <- base::requireNamespace("future", 
[10:21:26.505]                             quietly = TRUE)
[10:21:26.505]                           if (has_future) {
[10:21:26.505]                             ns <- base::getNamespace("future")
[10:21:26.505]                             version <- ns[[".package"]][["version"]]
[10:21:26.505]                             if (is.null(version)) 
[10:21:26.505]                               version <- utils::packageVersion("future")
[10:21:26.505]                           }
[10:21:26.505]                           else {
[10:21:26.505]                             version <- NULL
[10:21:26.505]                           }
[10:21:26.505]                           if (!has_future || version < "1.8.0") {
[10:21:26.505]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.505]                               "", base::R.version$version.string), 
[10:21:26.505]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:26.505]                                 base::R.version$platform, 8 * 
[10:21:26.505]                                   base::.Machine$sizeof.pointer), 
[10:21:26.505]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.505]                                 "release", "version")], collapse = " "), 
[10:21:26.505]                               hostname = base::Sys.info()[["nodename"]])
[10:21:26.505]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.505]                               info)
[10:21:26.505]                             info <- base::paste(info, collapse = "; ")
[10:21:26.505]                             if (!has_future) {
[10:21:26.505]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.505]                                 info)
[10:21:26.505]                             }
[10:21:26.505]                             else {
[10:21:26.505]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.505]                                 info, version)
[10:21:26.505]                             }
[10:21:26.505]                             base::stop(msg)
[10:21:26.505]                           }
[10:21:26.505]                         })
[10:21:26.505]                       }
[10:21:26.505]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:26.505]                       base::options(mc.cores = 1L)
[10:21:26.505]                     }
[10:21:26.505]                     base::local({
[10:21:26.505]                       for (pkg in "stats") {
[10:21:26.505]                         base::loadNamespace(pkg)
[10:21:26.505]                         base::library(pkg, character.only = TRUE)
[10:21:26.505]                       }
[10:21:26.505]                     })
[10:21:26.505]                   }
[10:21:26.505]                   ...future.strategy.old <- future::plan("list")
[10:21:26.505]                   options(future.plan = NULL)
[10:21:26.505]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.505]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.505]                 }
[10:21:26.505]                 ...future.workdir <- getwd()
[10:21:26.505]             }
[10:21:26.505]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.505]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.505]         }
[10:21:26.505]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.505]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.505]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.505]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.505]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.505]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.505]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.505]             base::names(...future.oldOptions))
[10:21:26.505]     }
[10:21:26.505]     if (FALSE) {
[10:21:26.505]     }
[10:21:26.505]     else {
[10:21:26.505]         if (TRUE) {
[10:21:26.505]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.505]                 open = "w")
[10:21:26.505]         }
[10:21:26.505]         else {
[10:21:26.505]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.505]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.505]         }
[10:21:26.505]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.505]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.505]             base::sink(type = "output", split = FALSE)
[10:21:26.505]             base::close(...future.stdout)
[10:21:26.505]         }, add = TRUE)
[10:21:26.505]     }
[10:21:26.505]     ...future.frame <- base::sys.nframe()
[10:21:26.505]     ...future.conditions <- base::list()
[10:21:26.505]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.505]     if (FALSE) {
[10:21:26.505]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.505]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.505]     }
[10:21:26.505]     ...future.result <- base::tryCatch({
[10:21:26.505]         base::withCallingHandlers({
[10:21:26.505]             ...future.value <- base::withVisible(base::local({
[10:21:26.505]                 withCallingHandlers({
[10:21:26.505]                   {
[10:21:26.505]                     lm(weight ~ group - 1)
[10:21:26.505]                   }
[10:21:26.505]                 }, immediateCondition = function(cond) {
[10:21:26.505]                   save_rds <- function (object, pathname, ...) 
[10:21:26.505]                   {
[10:21:26.505]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:26.505]                     if (file_test("-f", pathname_tmp)) {
[10:21:26.505]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.505]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:26.505]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.505]                         fi_tmp[["mtime"]])
[10:21:26.505]                     }
[10:21:26.505]                     tryCatch({
[10:21:26.505]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:26.505]                     }, error = function(ex) {
[10:21:26.505]                       msg <- conditionMessage(ex)
[10:21:26.505]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.505]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:26.505]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.505]                         fi_tmp[["mtime"]], msg)
[10:21:26.505]                       ex$message <- msg
[10:21:26.505]                       stop(ex)
[10:21:26.505]                     })
[10:21:26.505]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:26.505]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:26.505]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:26.505]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.505]                       fi <- file.info(pathname)
[10:21:26.505]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:26.505]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.505]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:26.505]                         fi[["size"]], fi[["mtime"]])
[10:21:26.505]                       stop(msg)
[10:21:26.505]                     }
[10:21:26.505]                     invisible(pathname)
[10:21:26.505]                   }
[10:21:26.505]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:26.505]                     rootPath = tempdir()) 
[10:21:26.505]                   {
[10:21:26.505]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:26.505]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:26.505]                       tmpdir = path, fileext = ".rds")
[10:21:26.505]                     save_rds(obj, file)
[10:21:26.505]                   }
[10:21:26.505]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0RHvXY/.future/immediateConditions")
[10:21:26.505]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.505]                   {
[10:21:26.505]                     inherits <- base::inherits
[10:21:26.505]                     invokeRestart <- base::invokeRestart
[10:21:26.505]                     is.null <- base::is.null
[10:21:26.505]                     muffled <- FALSE
[10:21:26.505]                     if (inherits(cond, "message")) {
[10:21:26.505]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:26.505]                       if (muffled) 
[10:21:26.505]                         invokeRestart("muffleMessage")
[10:21:26.505]                     }
[10:21:26.505]                     else if (inherits(cond, "warning")) {
[10:21:26.505]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:26.505]                       if (muffled) 
[10:21:26.505]                         invokeRestart("muffleWarning")
[10:21:26.505]                     }
[10:21:26.505]                     else if (inherits(cond, "condition")) {
[10:21:26.505]                       if (!is.null(pattern)) {
[10:21:26.505]                         computeRestarts <- base::computeRestarts
[10:21:26.505]                         grepl <- base::grepl
[10:21:26.505]                         restarts <- computeRestarts(cond)
[10:21:26.505]                         for (restart in restarts) {
[10:21:26.505]                           name <- restart$name
[10:21:26.505]                           if (is.null(name)) 
[10:21:26.505]                             next
[10:21:26.505]                           if (!grepl(pattern, name)) 
[10:21:26.505]                             next
[10:21:26.505]                           invokeRestart(restart)
[10:21:26.505]                           muffled <- TRUE
[10:21:26.505]                           break
[10:21:26.505]                         }
[10:21:26.505]                       }
[10:21:26.505]                     }
[10:21:26.505]                     invisible(muffled)
[10:21:26.505]                   }
[10:21:26.505]                   muffleCondition(cond)
[10:21:26.505]                 })
[10:21:26.505]             }))
[10:21:26.505]             future::FutureResult(value = ...future.value$value, 
[10:21:26.505]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.505]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.505]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.505]                     ...future.globalenv.names))
[10:21:26.505]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.505]         }, condition = base::local({
[10:21:26.505]             c <- base::c
[10:21:26.505]             inherits <- base::inherits
[10:21:26.505]             invokeRestart <- base::invokeRestart
[10:21:26.505]             length <- base::length
[10:21:26.505]             list <- base::list
[10:21:26.505]             seq.int <- base::seq.int
[10:21:26.505]             signalCondition <- base::signalCondition
[10:21:26.505]             sys.calls <- base::sys.calls
[10:21:26.505]             `[[` <- base::`[[`
[10:21:26.505]             `+` <- base::`+`
[10:21:26.505]             `<<-` <- base::`<<-`
[10:21:26.505]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.505]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.505]                   3L)]
[10:21:26.505]             }
[10:21:26.505]             function(cond) {
[10:21:26.505]                 is_error <- inherits(cond, "error")
[10:21:26.505]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.505]                   NULL)
[10:21:26.505]                 if (is_error) {
[10:21:26.505]                   sessionInformation <- function() {
[10:21:26.505]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.505]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.505]                       search = base::search(), system = base::Sys.info())
[10:21:26.505]                   }
[10:21:26.505]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.505]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.505]                     cond$call), session = sessionInformation(), 
[10:21:26.505]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.505]                   signalCondition(cond)
[10:21:26.505]                 }
[10:21:26.505]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.505]                 "immediateCondition"))) {
[10:21:26.505]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.505]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.505]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.505]                   if (TRUE && !signal) {
[10:21:26.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.505]                     {
[10:21:26.505]                       inherits <- base::inherits
[10:21:26.505]                       invokeRestart <- base::invokeRestart
[10:21:26.505]                       is.null <- base::is.null
[10:21:26.505]                       muffled <- FALSE
[10:21:26.505]                       if (inherits(cond, "message")) {
[10:21:26.505]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.505]                         if (muffled) 
[10:21:26.505]                           invokeRestart("muffleMessage")
[10:21:26.505]                       }
[10:21:26.505]                       else if (inherits(cond, "warning")) {
[10:21:26.505]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.505]                         if (muffled) 
[10:21:26.505]                           invokeRestart("muffleWarning")
[10:21:26.505]                       }
[10:21:26.505]                       else if (inherits(cond, "condition")) {
[10:21:26.505]                         if (!is.null(pattern)) {
[10:21:26.505]                           computeRestarts <- base::computeRestarts
[10:21:26.505]                           grepl <- base::grepl
[10:21:26.505]                           restarts <- computeRestarts(cond)
[10:21:26.505]                           for (restart in restarts) {
[10:21:26.505]                             name <- restart$name
[10:21:26.505]                             if (is.null(name)) 
[10:21:26.505]                               next
[10:21:26.505]                             if (!grepl(pattern, name)) 
[10:21:26.505]                               next
[10:21:26.505]                             invokeRestart(restart)
[10:21:26.505]                             muffled <- TRUE
[10:21:26.505]                             break
[10:21:26.505]                           }
[10:21:26.505]                         }
[10:21:26.505]                       }
[10:21:26.505]                       invisible(muffled)
[10:21:26.505]                     }
[10:21:26.505]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.505]                   }
[10:21:26.505]                 }
[10:21:26.505]                 else {
[10:21:26.505]                   if (TRUE) {
[10:21:26.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.505]                     {
[10:21:26.505]                       inherits <- base::inherits
[10:21:26.505]                       invokeRestart <- base::invokeRestart
[10:21:26.505]                       is.null <- base::is.null
[10:21:26.505]                       muffled <- FALSE
[10:21:26.505]                       if (inherits(cond, "message")) {
[10:21:26.505]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.505]                         if (muffled) 
[10:21:26.505]                           invokeRestart("muffleMessage")
[10:21:26.505]                       }
[10:21:26.505]                       else if (inherits(cond, "warning")) {
[10:21:26.505]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.505]                         if (muffled) 
[10:21:26.505]                           invokeRestart("muffleWarning")
[10:21:26.505]                       }
[10:21:26.505]                       else if (inherits(cond, "condition")) {
[10:21:26.505]                         if (!is.null(pattern)) {
[10:21:26.505]                           computeRestarts <- base::computeRestarts
[10:21:26.505]                           grepl <- base::grepl
[10:21:26.505]                           restarts <- computeRestarts(cond)
[10:21:26.505]                           for (restart in restarts) {
[10:21:26.505]                             name <- restart$name
[10:21:26.505]                             if (is.null(name)) 
[10:21:26.505]                               next
[10:21:26.505]                             if (!grepl(pattern, name)) 
[10:21:26.505]                               next
[10:21:26.505]                             invokeRestart(restart)
[10:21:26.505]                             muffled <- TRUE
[10:21:26.505]                             break
[10:21:26.505]                           }
[10:21:26.505]                         }
[10:21:26.505]                       }
[10:21:26.505]                       invisible(muffled)
[10:21:26.505]                     }
[10:21:26.505]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.505]                   }
[10:21:26.505]                 }
[10:21:26.505]             }
[10:21:26.505]         }))
[10:21:26.505]     }, error = function(ex) {
[10:21:26.505]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.505]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.505]                 ...future.rng), started = ...future.startTime, 
[10:21:26.505]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.505]             version = "1.8"), class = "FutureResult")
[10:21:26.505]     }, finally = {
[10:21:26.505]         if (!identical(...future.workdir, getwd())) 
[10:21:26.505]             setwd(...future.workdir)
[10:21:26.505]         {
[10:21:26.505]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.505]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.505]             }
[10:21:26.505]             base::options(...future.oldOptions)
[10:21:26.505]             if (.Platform$OS.type == "windows") {
[10:21:26.505]                 old_names <- names(...future.oldEnvVars)
[10:21:26.505]                 envs <- base::Sys.getenv()
[10:21:26.505]                 names <- names(envs)
[10:21:26.505]                 common <- intersect(names, old_names)
[10:21:26.505]                 added <- setdiff(names, old_names)
[10:21:26.505]                 removed <- setdiff(old_names, names)
[10:21:26.505]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.505]                   envs[common]]
[10:21:26.505]                 NAMES <- toupper(changed)
[10:21:26.505]                 args <- list()
[10:21:26.505]                 for (kk in seq_along(NAMES)) {
[10:21:26.505]                   name <- changed[[kk]]
[10:21:26.505]                   NAME <- NAMES[[kk]]
[10:21:26.505]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.505]                     next
[10:21:26.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.505]                 }
[10:21:26.505]                 NAMES <- toupper(added)
[10:21:26.505]                 for (kk in seq_along(NAMES)) {
[10:21:26.505]                   name <- added[[kk]]
[10:21:26.505]                   NAME <- NAMES[[kk]]
[10:21:26.505]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.505]                     next
[10:21:26.505]                   args[[name]] <- ""
[10:21:26.505]                 }
[10:21:26.505]                 NAMES <- toupper(removed)
[10:21:26.505]                 for (kk in seq_along(NAMES)) {
[10:21:26.505]                   name <- removed[[kk]]
[10:21:26.505]                   NAME <- NAMES[[kk]]
[10:21:26.505]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.505]                     next
[10:21:26.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.505]                 }
[10:21:26.505]                 if (length(args) > 0) 
[10:21:26.505]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.505]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.505]             }
[10:21:26.505]             else {
[10:21:26.505]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.505]             }
[10:21:26.505]             {
[10:21:26.505]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.505]                   0L) {
[10:21:26.505]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.505]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.505]                   base::options(opts)
[10:21:26.505]                 }
[10:21:26.505]                 {
[10:21:26.505]                   {
[10:21:26.505]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:26.505]                     NULL
[10:21:26.505]                   }
[10:21:26.505]                   options(future.plan = NULL)
[10:21:26.505]                   if (is.na(NA_character_)) 
[10:21:26.505]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.505]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.505]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.505]                     .init = FALSE)
[10:21:26.505]                 }
[10:21:26.505]             }
[10:21:26.505]         }
[10:21:26.505]     })
[10:21:26.505]     if (TRUE) {
[10:21:26.505]         base::sink(type = "output", split = FALSE)
[10:21:26.505]         if (TRUE) {
[10:21:26.505]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.505]         }
[10:21:26.505]         else {
[10:21:26.505]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.505]         }
[10:21:26.505]         base::close(...future.stdout)
[10:21:26.505]         ...future.stdout <- NULL
[10:21:26.505]     }
[10:21:26.505]     ...future.result$conditions <- ...future.conditions
[10:21:26.505]     ...future.result$finished <- base::Sys.time()
[10:21:26.505]     ...future.result
[10:21:26.505] }
[10:21:26.508] assign_globals() ...
[10:21:26.508] List of 2
[10:21:26.508]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:21:26.508]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:21:26.508]  - attr(*, "where")=List of 2
[10:21:26.508]   ..$ weight:<environment: R_EmptyEnv> 
[10:21:26.508]   ..$ group :<environment: R_EmptyEnv> 
[10:21:26.508]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:26.508]  - attr(*, "resolved")= logi FALSE
[10:21:26.508]  - attr(*, "total_size")= num 401
[10:21:26.508]  - attr(*, "already-done")= logi TRUE
[10:21:26.512] - copied ‘weight’ to environment
[10:21:26.512] - copied ‘group’ to environment
[10:21:26.512] assign_globals() ... done
[10:21:26.512] requestCore(): workers = 2
[10:21:26.514] MulticoreFuture started
[10:21:26.515] - Launch lazy future ... done
[10:21:26.515] run() for ‘MulticoreFuture’ ... done
[10:21:26.515] plan(): Setting new future strategy stack:
[10:21:26.515] result() for MulticoreFuture ...
[10:21:26.516] List of future strategies:
[10:21:26.516] 1. sequential:
[10:21:26.516]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.516]    - tweaked: FALSE
[10:21:26.516]    - call: NULL
[10:21:26.517] plan(): nbrOfWorkers() = 1
[10:21:26.520] plan(): Setting new future strategy stack:
[10:21:26.520] List of future strategies:
[10:21:26.520] 1. multicore:
[10:21:26.520]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:26.520]    - tweaked: FALSE
[10:21:26.520]    - call: plan(strategy)
[10:21:26.523] plan(): nbrOfWorkers() = 2
[10:21:26.525] result() for MulticoreFuture ...
[10:21:26.525] result() for MulticoreFuture ... done
[10:21:26.526] result() for MulticoreFuture ... done
[10:21:26.526] result() for MulticoreFuture ...
[10:21:26.526] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:21:26.528] getGlobalsAndPackages() ...
[10:21:26.529] Searching for globals...
[10:21:26.531] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:21:26.531] Searching for globals ... DONE
[10:21:26.531] Resolving globals: FALSE
[10:21:26.531] The total size of the 2 globals is 401 bytes (401 bytes)
[10:21:26.532] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[10:21:26.532] - globals: [2] ‘weight’, ‘group’
[10:21:26.532] - packages: [1] ‘stats’
[10:21:26.532] getGlobalsAndPackages() ... DONE
[10:21:26.533] run() for ‘Future’ ...
[10:21:26.533] - state: ‘created’
[10:21:26.533] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:26.535] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:26.535] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:26.535]   - Field: ‘label’
[10:21:26.536]   - Field: ‘local’
[10:21:26.536]   - Field: ‘owner’
[10:21:26.536]   - Field: ‘envir’
[10:21:26.536]   - Field: ‘workers’
[10:21:26.536]   - Field: ‘packages’
[10:21:26.536]   - Field: ‘gc’
[10:21:26.536]   - Field: ‘job’
[10:21:26.536]   - Field: ‘conditions’
[10:21:26.536]   - Field: ‘expr’
[10:21:26.536]   - Field: ‘uuid’
[10:21:26.537]   - Field: ‘seed’
[10:21:26.537]   - Field: ‘version’
[10:21:26.537]   - Field: ‘result’
[10:21:26.537]   - Field: ‘asynchronous’
[10:21:26.537]   - Field: ‘calls’
[10:21:26.537]   - Field: ‘globals’
[10:21:26.537]   - Field: ‘stdout’
[10:21:26.537]   - Field: ‘earlySignal’
[10:21:26.537]   - Field: ‘lazy’
[10:21:26.538]   - Field: ‘state’
[10:21:26.538] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:26.538] - Launch lazy future ...
[10:21:26.538] Packages needed by the future expression (n = 1): ‘stats’
[10:21:26.538] Packages needed by future strategies (n = 0): <none>
[10:21:26.539] {
[10:21:26.539]     {
[10:21:26.539]         {
[10:21:26.539]             ...future.startTime <- base::Sys.time()
[10:21:26.539]             {
[10:21:26.539]                 {
[10:21:26.539]                   {
[10:21:26.539]                     {
[10:21:26.539]                       {
[10:21:26.539]                         base::local({
[10:21:26.539]                           has_future <- base::requireNamespace("future", 
[10:21:26.539]                             quietly = TRUE)
[10:21:26.539]                           if (has_future) {
[10:21:26.539]                             ns <- base::getNamespace("future")
[10:21:26.539]                             version <- ns[[".package"]][["version"]]
[10:21:26.539]                             if (is.null(version)) 
[10:21:26.539]                               version <- utils::packageVersion("future")
[10:21:26.539]                           }
[10:21:26.539]                           else {
[10:21:26.539]                             version <- NULL
[10:21:26.539]                           }
[10:21:26.539]                           if (!has_future || version < "1.8.0") {
[10:21:26.539]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.539]                               "", base::R.version$version.string), 
[10:21:26.539]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:26.539]                                 base::R.version$platform, 8 * 
[10:21:26.539]                                   base::.Machine$sizeof.pointer), 
[10:21:26.539]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.539]                                 "release", "version")], collapse = " "), 
[10:21:26.539]                               hostname = base::Sys.info()[["nodename"]])
[10:21:26.539]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.539]                               info)
[10:21:26.539]                             info <- base::paste(info, collapse = "; ")
[10:21:26.539]                             if (!has_future) {
[10:21:26.539]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.539]                                 info)
[10:21:26.539]                             }
[10:21:26.539]                             else {
[10:21:26.539]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.539]                                 info, version)
[10:21:26.539]                             }
[10:21:26.539]                             base::stop(msg)
[10:21:26.539]                           }
[10:21:26.539]                         })
[10:21:26.539]                       }
[10:21:26.539]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:26.539]                       base::options(mc.cores = 1L)
[10:21:26.539]                     }
[10:21:26.539]                     base::local({
[10:21:26.539]                       for (pkg in "stats") {
[10:21:26.539]                         base::loadNamespace(pkg)
[10:21:26.539]                         base::library(pkg, character.only = TRUE)
[10:21:26.539]                       }
[10:21:26.539]                     })
[10:21:26.539]                   }
[10:21:26.539]                   ...future.strategy.old <- future::plan("list")
[10:21:26.539]                   options(future.plan = NULL)
[10:21:26.539]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.539]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.539]                 }
[10:21:26.539]                 ...future.workdir <- getwd()
[10:21:26.539]             }
[10:21:26.539]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.539]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.539]         }
[10:21:26.539]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.539]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.539]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.539]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.539]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.539]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.539]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.539]             base::names(...future.oldOptions))
[10:21:26.539]     }
[10:21:26.539]     if (FALSE) {
[10:21:26.539]     }
[10:21:26.539]     else {
[10:21:26.539]         if (TRUE) {
[10:21:26.539]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.539]                 open = "w")
[10:21:26.539]         }
[10:21:26.539]         else {
[10:21:26.539]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.539]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.539]         }
[10:21:26.539]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.539]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.539]             base::sink(type = "output", split = FALSE)
[10:21:26.539]             base::close(...future.stdout)
[10:21:26.539]         }, add = TRUE)
[10:21:26.539]     }
[10:21:26.539]     ...future.frame <- base::sys.nframe()
[10:21:26.539]     ...future.conditions <- base::list()
[10:21:26.539]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.539]     if (FALSE) {
[10:21:26.539]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.539]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.539]     }
[10:21:26.539]     ...future.result <- base::tryCatch({
[10:21:26.539]         base::withCallingHandlers({
[10:21:26.539]             ...future.value <- base::withVisible(base::local({
[10:21:26.539]                 withCallingHandlers({
[10:21:26.539]                   {
[10:21:26.539]                     lm(weight ~ group - 1)
[10:21:26.539]                   }
[10:21:26.539]                 }, immediateCondition = function(cond) {
[10:21:26.539]                   save_rds <- function (object, pathname, ...) 
[10:21:26.539]                   {
[10:21:26.539]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:26.539]                     if (file_test("-f", pathname_tmp)) {
[10:21:26.539]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.539]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:26.539]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.539]                         fi_tmp[["mtime"]])
[10:21:26.539]                     }
[10:21:26.539]                     tryCatch({
[10:21:26.539]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:26.539]                     }, error = function(ex) {
[10:21:26.539]                       msg <- conditionMessage(ex)
[10:21:26.539]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.539]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:26.539]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.539]                         fi_tmp[["mtime"]], msg)
[10:21:26.539]                       ex$message <- msg
[10:21:26.539]                       stop(ex)
[10:21:26.539]                     })
[10:21:26.539]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:26.539]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:26.539]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:26.539]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.539]                       fi <- file.info(pathname)
[10:21:26.539]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:26.539]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.539]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:26.539]                         fi[["size"]], fi[["mtime"]])
[10:21:26.539]                       stop(msg)
[10:21:26.539]                     }
[10:21:26.539]                     invisible(pathname)
[10:21:26.539]                   }
[10:21:26.539]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:26.539]                     rootPath = tempdir()) 
[10:21:26.539]                   {
[10:21:26.539]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:26.539]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:26.539]                       tmpdir = path, fileext = ".rds")
[10:21:26.539]                     save_rds(obj, file)
[10:21:26.539]                   }
[10:21:26.539]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0RHvXY/.future/immediateConditions")
[10:21:26.539]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.539]                   {
[10:21:26.539]                     inherits <- base::inherits
[10:21:26.539]                     invokeRestart <- base::invokeRestart
[10:21:26.539]                     is.null <- base::is.null
[10:21:26.539]                     muffled <- FALSE
[10:21:26.539]                     if (inherits(cond, "message")) {
[10:21:26.539]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:26.539]                       if (muffled) 
[10:21:26.539]                         invokeRestart("muffleMessage")
[10:21:26.539]                     }
[10:21:26.539]                     else if (inherits(cond, "warning")) {
[10:21:26.539]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:26.539]                       if (muffled) 
[10:21:26.539]                         invokeRestart("muffleWarning")
[10:21:26.539]                     }
[10:21:26.539]                     else if (inherits(cond, "condition")) {
[10:21:26.539]                       if (!is.null(pattern)) {
[10:21:26.539]                         computeRestarts <- base::computeRestarts
[10:21:26.539]                         grepl <- base::grepl
[10:21:26.539]                         restarts <- computeRestarts(cond)
[10:21:26.539]                         for (restart in restarts) {
[10:21:26.539]                           name <- restart$name
[10:21:26.539]                           if (is.null(name)) 
[10:21:26.539]                             next
[10:21:26.539]                           if (!grepl(pattern, name)) 
[10:21:26.539]                             next
[10:21:26.539]                           invokeRestart(restart)
[10:21:26.539]                           muffled <- TRUE
[10:21:26.539]                           break
[10:21:26.539]                         }
[10:21:26.539]                       }
[10:21:26.539]                     }
[10:21:26.539]                     invisible(muffled)
[10:21:26.539]                   }
[10:21:26.539]                   muffleCondition(cond)
[10:21:26.539]                 })
[10:21:26.539]             }))
[10:21:26.539]             future::FutureResult(value = ...future.value$value, 
[10:21:26.539]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.539]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.539]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.539]                     ...future.globalenv.names))
[10:21:26.539]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.539]         }, condition = base::local({
[10:21:26.539]             c <- base::c
[10:21:26.539]             inherits <- base::inherits
[10:21:26.539]             invokeRestart <- base::invokeRestart
[10:21:26.539]             length <- base::length
[10:21:26.539]             list <- base::list
[10:21:26.539]             seq.int <- base::seq.int
[10:21:26.539]             signalCondition <- base::signalCondition
[10:21:26.539]             sys.calls <- base::sys.calls
[10:21:26.539]             `[[` <- base::`[[`
[10:21:26.539]             `+` <- base::`+`
[10:21:26.539]             `<<-` <- base::`<<-`
[10:21:26.539]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.539]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.539]                   3L)]
[10:21:26.539]             }
[10:21:26.539]             function(cond) {
[10:21:26.539]                 is_error <- inherits(cond, "error")
[10:21:26.539]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.539]                   NULL)
[10:21:26.539]                 if (is_error) {
[10:21:26.539]                   sessionInformation <- function() {
[10:21:26.539]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.539]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.539]                       search = base::search(), system = base::Sys.info())
[10:21:26.539]                   }
[10:21:26.539]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.539]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.539]                     cond$call), session = sessionInformation(), 
[10:21:26.539]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.539]                   signalCondition(cond)
[10:21:26.539]                 }
[10:21:26.539]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.539]                 "immediateCondition"))) {
[10:21:26.539]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.539]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.539]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.539]                   if (TRUE && !signal) {
[10:21:26.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.539]                     {
[10:21:26.539]                       inherits <- base::inherits
[10:21:26.539]                       invokeRestart <- base::invokeRestart
[10:21:26.539]                       is.null <- base::is.null
[10:21:26.539]                       muffled <- FALSE
[10:21:26.539]                       if (inherits(cond, "message")) {
[10:21:26.539]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.539]                         if (muffled) 
[10:21:26.539]                           invokeRestart("muffleMessage")
[10:21:26.539]                       }
[10:21:26.539]                       else if (inherits(cond, "warning")) {
[10:21:26.539]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.539]                         if (muffled) 
[10:21:26.539]                           invokeRestart("muffleWarning")
[10:21:26.539]                       }
[10:21:26.539]                       else if (inherits(cond, "condition")) {
[10:21:26.539]                         if (!is.null(pattern)) {
[10:21:26.539]                           computeRestarts <- base::computeRestarts
[10:21:26.539]                           grepl <- base::grepl
[10:21:26.539]                           restarts <- computeRestarts(cond)
[10:21:26.539]                           for (restart in restarts) {
[10:21:26.539]                             name <- restart$name
[10:21:26.539]                             if (is.null(name)) 
[10:21:26.539]                               next
[10:21:26.539]                             if (!grepl(pattern, name)) 
[10:21:26.539]                               next
[10:21:26.539]                             invokeRestart(restart)
[10:21:26.539]                             muffled <- TRUE
[10:21:26.539]                             break
[10:21:26.539]                           }
[10:21:26.539]                         }
[10:21:26.539]                       }
[10:21:26.539]                       invisible(muffled)
[10:21:26.539]                     }
[10:21:26.539]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.539]                   }
[10:21:26.539]                 }
[10:21:26.539]                 else {
[10:21:26.539]                   if (TRUE) {
[10:21:26.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.539]                     {
[10:21:26.539]                       inherits <- base::inherits
[10:21:26.539]                       invokeRestart <- base::invokeRestart
[10:21:26.539]                       is.null <- base::is.null
[10:21:26.539]                       muffled <- FALSE
[10:21:26.539]                       if (inherits(cond, "message")) {
[10:21:26.539]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.539]                         if (muffled) 
[10:21:26.539]                           invokeRestart("muffleMessage")
[10:21:26.539]                       }
[10:21:26.539]                       else if (inherits(cond, "warning")) {
[10:21:26.539]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.539]                         if (muffled) 
[10:21:26.539]                           invokeRestart("muffleWarning")
[10:21:26.539]                       }
[10:21:26.539]                       else if (inherits(cond, "condition")) {
[10:21:26.539]                         if (!is.null(pattern)) {
[10:21:26.539]                           computeRestarts <- base::computeRestarts
[10:21:26.539]                           grepl <- base::grepl
[10:21:26.539]                           restarts <- computeRestarts(cond)
[10:21:26.539]                           for (restart in restarts) {
[10:21:26.539]                             name <- restart$name
[10:21:26.539]                             if (is.null(name)) 
[10:21:26.539]                               next
[10:21:26.539]                             if (!grepl(pattern, name)) 
[10:21:26.539]                               next
[10:21:26.539]                             invokeRestart(restart)
[10:21:26.539]                             muffled <- TRUE
[10:21:26.539]                             break
[10:21:26.539]                           }
[10:21:26.539]                         }
[10:21:26.539]                       }
[10:21:26.539]                       invisible(muffled)
[10:21:26.539]                     }
[10:21:26.539]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.539]                   }
[10:21:26.539]                 }
[10:21:26.539]             }
[10:21:26.539]         }))
[10:21:26.539]     }, error = function(ex) {
[10:21:26.539]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.539]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.539]                 ...future.rng), started = ...future.startTime, 
[10:21:26.539]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.539]             version = "1.8"), class = "FutureResult")
[10:21:26.539]     }, finally = {
[10:21:26.539]         if (!identical(...future.workdir, getwd())) 
[10:21:26.539]             setwd(...future.workdir)
[10:21:26.539]         {
[10:21:26.539]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.539]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.539]             }
[10:21:26.539]             base::options(...future.oldOptions)
[10:21:26.539]             if (.Platform$OS.type == "windows") {
[10:21:26.539]                 old_names <- names(...future.oldEnvVars)
[10:21:26.539]                 envs <- base::Sys.getenv()
[10:21:26.539]                 names <- names(envs)
[10:21:26.539]                 common <- intersect(names, old_names)
[10:21:26.539]                 added <- setdiff(names, old_names)
[10:21:26.539]                 removed <- setdiff(old_names, names)
[10:21:26.539]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.539]                   envs[common]]
[10:21:26.539]                 NAMES <- toupper(changed)
[10:21:26.539]                 args <- list()
[10:21:26.539]                 for (kk in seq_along(NAMES)) {
[10:21:26.539]                   name <- changed[[kk]]
[10:21:26.539]                   NAME <- NAMES[[kk]]
[10:21:26.539]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.539]                     next
[10:21:26.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.539]                 }
[10:21:26.539]                 NAMES <- toupper(added)
[10:21:26.539]                 for (kk in seq_along(NAMES)) {
[10:21:26.539]                   name <- added[[kk]]
[10:21:26.539]                   NAME <- NAMES[[kk]]
[10:21:26.539]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.539]                     next
[10:21:26.539]                   args[[name]] <- ""
[10:21:26.539]                 }
[10:21:26.539]                 NAMES <- toupper(removed)
[10:21:26.539]                 for (kk in seq_along(NAMES)) {
[10:21:26.539]                   name <- removed[[kk]]
[10:21:26.539]                   NAME <- NAMES[[kk]]
[10:21:26.539]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.539]                     next
[10:21:26.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.539]                 }
[10:21:26.539]                 if (length(args) > 0) 
[10:21:26.539]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.539]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.539]             }
[10:21:26.539]             else {
[10:21:26.539]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.539]             }
[10:21:26.539]             {
[10:21:26.539]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.539]                   0L) {
[10:21:26.539]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.539]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.539]                   base::options(opts)
[10:21:26.539]                 }
[10:21:26.539]                 {
[10:21:26.539]                   {
[10:21:26.539]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:26.539]                     NULL
[10:21:26.539]                   }
[10:21:26.539]                   options(future.plan = NULL)
[10:21:26.539]                   if (is.na(NA_character_)) 
[10:21:26.539]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.539]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.539]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.539]                     .init = FALSE)
[10:21:26.539]                 }
[10:21:26.539]             }
[10:21:26.539]         }
[10:21:26.539]     })
[10:21:26.539]     if (TRUE) {
[10:21:26.539]         base::sink(type = "output", split = FALSE)
[10:21:26.539]         if (TRUE) {
[10:21:26.539]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.539]         }
[10:21:26.539]         else {
[10:21:26.539]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.539]         }
[10:21:26.539]         base::close(...future.stdout)
[10:21:26.539]         ...future.stdout <- NULL
[10:21:26.539]     }
[10:21:26.539]     ...future.result$conditions <- ...future.conditions
[10:21:26.539]     ...future.result$finished <- base::Sys.time()
[10:21:26.539]     ...future.result
[10:21:26.539] }
[10:21:26.542] assign_globals() ...
[10:21:26.542] List of 2
[10:21:26.542]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:21:26.542]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:21:26.542]  - attr(*, "where")=List of 2
[10:21:26.542]   ..$ weight:<environment: R_EmptyEnv> 
[10:21:26.542]   ..$ group :<environment: R_EmptyEnv> 
[10:21:26.542]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:26.542]  - attr(*, "resolved")= logi FALSE
[10:21:26.542]  - attr(*, "total_size")= num 401
[10:21:26.542]  - attr(*, "already-done")= logi TRUE
[10:21:26.548] - copied ‘weight’ to environment
[10:21:26.548] - copied ‘group’ to environment
[10:21:26.548] assign_globals() ... done
[10:21:26.548] requestCore(): workers = 2
[10:21:26.550] MulticoreFuture started
[10:21:26.550] - Launch lazy future ... done
[10:21:26.550] run() for ‘MulticoreFuture’ ... done
[10:21:26.551] result() for MulticoreFuture ...
[10:21:26.551] plan(): Setting new future strategy stack:
[10:21:26.552] List of future strategies:
[10:21:26.552] 1. sequential:
[10:21:26.552]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.552]    - tweaked: FALSE
[10:21:26.552]    - call: NULL
[10:21:26.553] plan(): nbrOfWorkers() = 1
[10:21:26.556] plan(): Setting new future strategy stack:
[10:21:26.556] List of future strategies:
[10:21:26.556] 1. multicore:
[10:21:26.556]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:26.556]    - tweaked: FALSE
[10:21:26.556]    - call: plan(strategy)
[10:21:26.559] plan(): nbrOfWorkers() = 2
[10:21:26.562] result() for MulticoreFuture ...
[10:21:26.562] result() for MulticoreFuture ... done
[10:21:26.562] result() for MulticoreFuture ... done
[10:21:26.562] result() for MulticoreFuture ...
[10:21:26.562] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:21:26.565] getGlobalsAndPackages() ...
[10:21:26.565] Searching for globals...
[10:21:26.567] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:21:26.567] Searching for globals ... DONE
[10:21:26.567] Resolving globals: FALSE
[10:21:26.568] The total size of the 2 globals is 401 bytes (401 bytes)
[10:21:26.568] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[10:21:26.569] - globals: [2] ‘weight’, ‘group’
[10:21:26.569] - packages: [1] ‘stats’
[10:21:26.569] getGlobalsAndPackages() ... DONE
[10:21:26.569] run() for ‘Future’ ...
[10:21:26.569] - state: ‘created’
[10:21:26.570] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:26.572] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:26.572] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:26.572]   - Field: ‘label’
[10:21:26.572]   - Field: ‘local’
[10:21:26.572]   - Field: ‘owner’
[10:21:26.572]   - Field: ‘envir’
[10:21:26.572]   - Field: ‘workers’
[10:21:26.573]   - Field: ‘packages’
[10:21:26.573]   - Field: ‘gc’
[10:21:26.573]   - Field: ‘job’
[10:21:26.573]   - Field: ‘conditions’
[10:21:26.573]   - Field: ‘expr’
[10:21:26.573]   - Field: ‘uuid’
[10:21:26.573]   - Field: ‘seed’
[10:21:26.573]   - Field: ‘version’
[10:21:26.573]   - Field: ‘result’
[10:21:26.574]   - Field: ‘asynchronous’
[10:21:26.574]   - Field: ‘calls’
[10:21:26.574]   - Field: ‘globals’
[10:21:26.574]   - Field: ‘stdout’
[10:21:26.574]   - Field: ‘earlySignal’
[10:21:26.574]   - Field: ‘lazy’
[10:21:26.574]   - Field: ‘state’
[10:21:26.574] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:26.574] - Launch lazy future ...
[10:21:26.575] Packages needed by the future expression (n = 1): ‘stats’
[10:21:26.575] Packages needed by future strategies (n = 0): <none>
[10:21:26.576] {
[10:21:26.576]     {
[10:21:26.576]         {
[10:21:26.576]             ...future.startTime <- base::Sys.time()
[10:21:26.576]             {
[10:21:26.576]                 {
[10:21:26.576]                   {
[10:21:26.576]                     {
[10:21:26.576]                       {
[10:21:26.576]                         base::local({
[10:21:26.576]                           has_future <- base::requireNamespace("future", 
[10:21:26.576]                             quietly = TRUE)
[10:21:26.576]                           if (has_future) {
[10:21:26.576]                             ns <- base::getNamespace("future")
[10:21:26.576]                             version <- ns[[".package"]][["version"]]
[10:21:26.576]                             if (is.null(version)) 
[10:21:26.576]                               version <- utils::packageVersion("future")
[10:21:26.576]                           }
[10:21:26.576]                           else {
[10:21:26.576]                             version <- NULL
[10:21:26.576]                           }
[10:21:26.576]                           if (!has_future || version < "1.8.0") {
[10:21:26.576]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.576]                               "", base::R.version$version.string), 
[10:21:26.576]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:26.576]                                 base::R.version$platform, 8 * 
[10:21:26.576]                                   base::.Machine$sizeof.pointer), 
[10:21:26.576]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.576]                                 "release", "version")], collapse = " "), 
[10:21:26.576]                               hostname = base::Sys.info()[["nodename"]])
[10:21:26.576]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.576]                               info)
[10:21:26.576]                             info <- base::paste(info, collapse = "; ")
[10:21:26.576]                             if (!has_future) {
[10:21:26.576]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.576]                                 info)
[10:21:26.576]                             }
[10:21:26.576]                             else {
[10:21:26.576]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.576]                                 info, version)
[10:21:26.576]                             }
[10:21:26.576]                             base::stop(msg)
[10:21:26.576]                           }
[10:21:26.576]                         })
[10:21:26.576]                       }
[10:21:26.576]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:26.576]                       base::options(mc.cores = 1L)
[10:21:26.576]                     }
[10:21:26.576]                     base::local({
[10:21:26.576]                       for (pkg in "stats") {
[10:21:26.576]                         base::loadNamespace(pkg)
[10:21:26.576]                         base::library(pkg, character.only = TRUE)
[10:21:26.576]                       }
[10:21:26.576]                     })
[10:21:26.576]                   }
[10:21:26.576]                   ...future.strategy.old <- future::plan("list")
[10:21:26.576]                   options(future.plan = NULL)
[10:21:26.576]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.576]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.576]                 }
[10:21:26.576]                 ...future.workdir <- getwd()
[10:21:26.576]             }
[10:21:26.576]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.576]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.576]         }
[10:21:26.576]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.576]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.576]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.576]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.576]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.576]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.576]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.576]             base::names(...future.oldOptions))
[10:21:26.576]     }
[10:21:26.576]     if (FALSE) {
[10:21:26.576]     }
[10:21:26.576]     else {
[10:21:26.576]         if (TRUE) {
[10:21:26.576]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.576]                 open = "w")
[10:21:26.576]         }
[10:21:26.576]         else {
[10:21:26.576]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.576]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.576]         }
[10:21:26.576]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.576]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.576]             base::sink(type = "output", split = FALSE)
[10:21:26.576]             base::close(...future.stdout)
[10:21:26.576]         }, add = TRUE)
[10:21:26.576]     }
[10:21:26.576]     ...future.frame <- base::sys.nframe()
[10:21:26.576]     ...future.conditions <- base::list()
[10:21:26.576]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.576]     if (FALSE) {
[10:21:26.576]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.576]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.576]     }
[10:21:26.576]     ...future.result <- base::tryCatch({
[10:21:26.576]         base::withCallingHandlers({
[10:21:26.576]             ...future.value <- base::withVisible(base::local({
[10:21:26.576]                 withCallingHandlers({
[10:21:26.576]                   {
[10:21:26.576]                     lm(weight ~ group - 1)
[10:21:26.576]                   }
[10:21:26.576]                 }, immediateCondition = function(cond) {
[10:21:26.576]                   save_rds <- function (object, pathname, ...) 
[10:21:26.576]                   {
[10:21:26.576]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:26.576]                     if (file_test("-f", pathname_tmp)) {
[10:21:26.576]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.576]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:26.576]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.576]                         fi_tmp[["mtime"]])
[10:21:26.576]                     }
[10:21:26.576]                     tryCatch({
[10:21:26.576]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:26.576]                     }, error = function(ex) {
[10:21:26.576]                       msg <- conditionMessage(ex)
[10:21:26.576]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.576]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:26.576]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.576]                         fi_tmp[["mtime"]], msg)
[10:21:26.576]                       ex$message <- msg
[10:21:26.576]                       stop(ex)
[10:21:26.576]                     })
[10:21:26.576]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:26.576]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:26.576]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:26.576]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.576]                       fi <- file.info(pathname)
[10:21:26.576]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:26.576]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.576]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:26.576]                         fi[["size"]], fi[["mtime"]])
[10:21:26.576]                       stop(msg)
[10:21:26.576]                     }
[10:21:26.576]                     invisible(pathname)
[10:21:26.576]                   }
[10:21:26.576]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:26.576]                     rootPath = tempdir()) 
[10:21:26.576]                   {
[10:21:26.576]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:26.576]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:26.576]                       tmpdir = path, fileext = ".rds")
[10:21:26.576]                     save_rds(obj, file)
[10:21:26.576]                   }
[10:21:26.576]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0RHvXY/.future/immediateConditions")
[10:21:26.576]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.576]                   {
[10:21:26.576]                     inherits <- base::inherits
[10:21:26.576]                     invokeRestart <- base::invokeRestart
[10:21:26.576]                     is.null <- base::is.null
[10:21:26.576]                     muffled <- FALSE
[10:21:26.576]                     if (inherits(cond, "message")) {
[10:21:26.576]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:26.576]                       if (muffled) 
[10:21:26.576]                         invokeRestart("muffleMessage")
[10:21:26.576]                     }
[10:21:26.576]                     else if (inherits(cond, "warning")) {
[10:21:26.576]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:26.576]                       if (muffled) 
[10:21:26.576]                         invokeRestart("muffleWarning")
[10:21:26.576]                     }
[10:21:26.576]                     else if (inherits(cond, "condition")) {
[10:21:26.576]                       if (!is.null(pattern)) {
[10:21:26.576]                         computeRestarts <- base::computeRestarts
[10:21:26.576]                         grepl <- base::grepl
[10:21:26.576]                         restarts <- computeRestarts(cond)
[10:21:26.576]                         for (restart in restarts) {
[10:21:26.576]                           name <- restart$name
[10:21:26.576]                           if (is.null(name)) 
[10:21:26.576]                             next
[10:21:26.576]                           if (!grepl(pattern, name)) 
[10:21:26.576]                             next
[10:21:26.576]                           invokeRestart(restart)
[10:21:26.576]                           muffled <- TRUE
[10:21:26.576]                           break
[10:21:26.576]                         }
[10:21:26.576]                       }
[10:21:26.576]                     }
[10:21:26.576]                     invisible(muffled)
[10:21:26.576]                   }
[10:21:26.576]                   muffleCondition(cond)
[10:21:26.576]                 })
[10:21:26.576]             }))
[10:21:26.576]             future::FutureResult(value = ...future.value$value, 
[10:21:26.576]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.576]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.576]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.576]                     ...future.globalenv.names))
[10:21:26.576]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.576]         }, condition = base::local({
[10:21:26.576]             c <- base::c
[10:21:26.576]             inherits <- base::inherits
[10:21:26.576]             invokeRestart <- base::invokeRestart
[10:21:26.576]             length <- base::length
[10:21:26.576]             list <- base::list
[10:21:26.576]             seq.int <- base::seq.int
[10:21:26.576]             signalCondition <- base::signalCondition
[10:21:26.576]             sys.calls <- base::sys.calls
[10:21:26.576]             `[[` <- base::`[[`
[10:21:26.576]             `+` <- base::`+`
[10:21:26.576]             `<<-` <- base::`<<-`
[10:21:26.576]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.576]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.576]                   3L)]
[10:21:26.576]             }
[10:21:26.576]             function(cond) {
[10:21:26.576]                 is_error <- inherits(cond, "error")
[10:21:26.576]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.576]                   NULL)
[10:21:26.576]                 if (is_error) {
[10:21:26.576]                   sessionInformation <- function() {
[10:21:26.576]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.576]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.576]                       search = base::search(), system = base::Sys.info())
[10:21:26.576]                   }
[10:21:26.576]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.576]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.576]                     cond$call), session = sessionInformation(), 
[10:21:26.576]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.576]                   signalCondition(cond)
[10:21:26.576]                 }
[10:21:26.576]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.576]                 "immediateCondition"))) {
[10:21:26.576]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.576]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.576]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.576]                   if (TRUE && !signal) {
[10:21:26.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.576]                     {
[10:21:26.576]                       inherits <- base::inherits
[10:21:26.576]                       invokeRestart <- base::invokeRestart
[10:21:26.576]                       is.null <- base::is.null
[10:21:26.576]                       muffled <- FALSE
[10:21:26.576]                       if (inherits(cond, "message")) {
[10:21:26.576]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.576]                         if (muffled) 
[10:21:26.576]                           invokeRestart("muffleMessage")
[10:21:26.576]                       }
[10:21:26.576]                       else if (inherits(cond, "warning")) {
[10:21:26.576]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.576]                         if (muffled) 
[10:21:26.576]                           invokeRestart("muffleWarning")
[10:21:26.576]                       }
[10:21:26.576]                       else if (inherits(cond, "condition")) {
[10:21:26.576]                         if (!is.null(pattern)) {
[10:21:26.576]                           computeRestarts <- base::computeRestarts
[10:21:26.576]                           grepl <- base::grepl
[10:21:26.576]                           restarts <- computeRestarts(cond)
[10:21:26.576]                           for (restart in restarts) {
[10:21:26.576]                             name <- restart$name
[10:21:26.576]                             if (is.null(name)) 
[10:21:26.576]                               next
[10:21:26.576]                             if (!grepl(pattern, name)) 
[10:21:26.576]                               next
[10:21:26.576]                             invokeRestart(restart)
[10:21:26.576]                             muffled <- TRUE
[10:21:26.576]                             break
[10:21:26.576]                           }
[10:21:26.576]                         }
[10:21:26.576]                       }
[10:21:26.576]                       invisible(muffled)
[10:21:26.576]                     }
[10:21:26.576]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.576]                   }
[10:21:26.576]                 }
[10:21:26.576]                 else {
[10:21:26.576]                   if (TRUE) {
[10:21:26.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.576]                     {
[10:21:26.576]                       inherits <- base::inherits
[10:21:26.576]                       invokeRestart <- base::invokeRestart
[10:21:26.576]                       is.null <- base::is.null
[10:21:26.576]                       muffled <- FALSE
[10:21:26.576]                       if (inherits(cond, "message")) {
[10:21:26.576]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.576]                         if (muffled) 
[10:21:26.576]                           invokeRestart("muffleMessage")
[10:21:26.576]                       }
[10:21:26.576]                       else if (inherits(cond, "warning")) {
[10:21:26.576]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.576]                         if (muffled) 
[10:21:26.576]                           invokeRestart("muffleWarning")
[10:21:26.576]                       }
[10:21:26.576]                       else if (inherits(cond, "condition")) {
[10:21:26.576]                         if (!is.null(pattern)) {
[10:21:26.576]                           computeRestarts <- base::computeRestarts
[10:21:26.576]                           grepl <- base::grepl
[10:21:26.576]                           restarts <- computeRestarts(cond)
[10:21:26.576]                           for (restart in restarts) {
[10:21:26.576]                             name <- restart$name
[10:21:26.576]                             if (is.null(name)) 
[10:21:26.576]                               next
[10:21:26.576]                             if (!grepl(pattern, name)) 
[10:21:26.576]                               next
[10:21:26.576]                             invokeRestart(restart)
[10:21:26.576]                             muffled <- TRUE
[10:21:26.576]                             break
[10:21:26.576]                           }
[10:21:26.576]                         }
[10:21:26.576]                       }
[10:21:26.576]                       invisible(muffled)
[10:21:26.576]                     }
[10:21:26.576]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.576]                   }
[10:21:26.576]                 }
[10:21:26.576]             }
[10:21:26.576]         }))
[10:21:26.576]     }, error = function(ex) {
[10:21:26.576]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.576]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.576]                 ...future.rng), started = ...future.startTime, 
[10:21:26.576]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.576]             version = "1.8"), class = "FutureResult")
[10:21:26.576]     }, finally = {
[10:21:26.576]         if (!identical(...future.workdir, getwd())) 
[10:21:26.576]             setwd(...future.workdir)
[10:21:26.576]         {
[10:21:26.576]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.576]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.576]             }
[10:21:26.576]             base::options(...future.oldOptions)
[10:21:26.576]             if (.Platform$OS.type == "windows") {
[10:21:26.576]                 old_names <- names(...future.oldEnvVars)
[10:21:26.576]                 envs <- base::Sys.getenv()
[10:21:26.576]                 names <- names(envs)
[10:21:26.576]                 common <- intersect(names, old_names)
[10:21:26.576]                 added <- setdiff(names, old_names)
[10:21:26.576]                 removed <- setdiff(old_names, names)
[10:21:26.576]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.576]                   envs[common]]
[10:21:26.576]                 NAMES <- toupper(changed)
[10:21:26.576]                 args <- list()
[10:21:26.576]                 for (kk in seq_along(NAMES)) {
[10:21:26.576]                   name <- changed[[kk]]
[10:21:26.576]                   NAME <- NAMES[[kk]]
[10:21:26.576]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.576]                     next
[10:21:26.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.576]                 }
[10:21:26.576]                 NAMES <- toupper(added)
[10:21:26.576]                 for (kk in seq_along(NAMES)) {
[10:21:26.576]                   name <- added[[kk]]
[10:21:26.576]                   NAME <- NAMES[[kk]]
[10:21:26.576]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.576]                     next
[10:21:26.576]                   args[[name]] <- ""
[10:21:26.576]                 }
[10:21:26.576]                 NAMES <- toupper(removed)
[10:21:26.576]                 for (kk in seq_along(NAMES)) {
[10:21:26.576]                   name <- removed[[kk]]
[10:21:26.576]                   NAME <- NAMES[[kk]]
[10:21:26.576]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.576]                     next
[10:21:26.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.576]                 }
[10:21:26.576]                 if (length(args) > 0) 
[10:21:26.576]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.576]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.576]             }
[10:21:26.576]             else {
[10:21:26.576]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.576]             }
[10:21:26.576]             {
[10:21:26.576]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.576]                   0L) {
[10:21:26.576]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.576]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.576]                   base::options(opts)
[10:21:26.576]                 }
[10:21:26.576]                 {
[10:21:26.576]                   {
[10:21:26.576]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:26.576]                     NULL
[10:21:26.576]                   }
[10:21:26.576]                   options(future.plan = NULL)
[10:21:26.576]                   if (is.na(NA_character_)) 
[10:21:26.576]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.576]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.576]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.576]                     .init = FALSE)
[10:21:26.576]                 }
[10:21:26.576]             }
[10:21:26.576]         }
[10:21:26.576]     })
[10:21:26.576]     if (TRUE) {
[10:21:26.576]         base::sink(type = "output", split = FALSE)
[10:21:26.576]         if (TRUE) {
[10:21:26.576]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.576]         }
[10:21:26.576]         else {
[10:21:26.576]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.576]         }
[10:21:26.576]         base::close(...future.stdout)
[10:21:26.576]         ...future.stdout <- NULL
[10:21:26.576]     }
[10:21:26.576]     ...future.result$conditions <- ...future.conditions
[10:21:26.576]     ...future.result$finished <- base::Sys.time()
[10:21:26.576]     ...future.result
[10:21:26.576] }
[10:21:26.578] assign_globals() ...
[10:21:26.578] List of 2
[10:21:26.578]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[10:21:26.578]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[10:21:26.578]  - attr(*, "where")=List of 2
[10:21:26.578]   ..$ weight:<environment: R_EmptyEnv> 
[10:21:26.578]   ..$ group :<environment: R_EmptyEnv> 
[10:21:26.578]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:26.578]  - attr(*, "resolved")= logi FALSE
[10:21:26.578]  - attr(*, "total_size")= num 401
[10:21:26.578]  - attr(*, "already-done")= logi TRUE
[10:21:26.582] - copied ‘weight’ to environment
[10:21:26.582] - copied ‘group’ to environment
[10:21:26.582] assign_globals() ... done
[10:21:26.582] requestCore(): workers = 2
[10:21:26.584] MulticoreFuture started
[10:21:26.584] - Launch lazy future ... done
[10:21:26.585] run() for ‘MulticoreFuture’ ... done
[10:21:26.585] result() for MulticoreFuture ...
[10:21:26.585] plan(): Setting new future strategy stack:
[10:21:26.586] List of future strategies:
[10:21:26.586] 1. sequential:
[10:21:26.586]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.586]    - tweaked: FALSE
[10:21:26.586]    - call: NULL
[10:21:26.587] plan(): nbrOfWorkers() = 1
[10:21:26.594] plan(): Setting new future strategy stack:
[10:21:26.594] List of future strategies:
[10:21:26.594] 1. multicore:
[10:21:26.594]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:26.594]    - tweaked: FALSE
[10:21:26.594]    - call: plan(strategy)
[10:21:26.597] plan(): nbrOfWorkers() = 2
[10:21:26.599] result() for MulticoreFuture ...
[10:21:26.600] result() for MulticoreFuture ... done
[10:21:26.600] result() for MulticoreFuture ... done
[10:21:26.600] result() for MulticoreFuture ...
[10:21:26.602] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[10:21:26.605] getGlobalsAndPackages() ...
[10:21:26.605] Searching for globals...
[10:21:26.607] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[10:21:26.608] Searching for globals ... DONE
[10:21:26.608] Resolving globals: FALSE
[10:21:26.609] The total size of the 1 globals is 71 bytes (71 bytes)
[10:21:26.609] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 71 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (71 bytes of class ‘numeric’)
[10:21:26.609] - globals: [1] ‘x’
[10:21:26.610] - packages: [1] ‘stats’
[10:21:26.610] getGlobalsAndPackages() ... DONE
[10:21:26.610] run() for ‘Future’ ...
[10:21:26.611] - state: ‘created’
[10:21:26.611] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:26.614] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:26.614] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:26.614]   - Field: ‘label’
[10:21:26.614]   - Field: ‘local’
[10:21:26.614]   - Field: ‘owner’
[10:21:26.614]   - Field: ‘envir’
[10:21:26.614]   - Field: ‘workers’
[10:21:26.614]   - Field: ‘packages’
[10:21:26.615]   - Field: ‘gc’
[10:21:26.615]   - Field: ‘job’
[10:21:26.615]   - Field: ‘conditions’
[10:21:26.615]   - Field: ‘expr’
[10:21:26.615]   - Field: ‘uuid’
[10:21:26.615]   - Field: ‘seed’
[10:21:26.615]   - Field: ‘version’
[10:21:26.615]   - Field: ‘result’
[10:21:26.615]   - Field: ‘asynchronous’
[10:21:26.615]   - Field: ‘calls’
[10:21:26.616]   - Field: ‘globals’
[10:21:26.616]   - Field: ‘stdout’
[10:21:26.616]   - Field: ‘earlySignal’
[10:21:26.616]   - Field: ‘lazy’
[10:21:26.616]   - Field: ‘state’
[10:21:26.616] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:26.616] - Launch lazy future ...
[10:21:26.617] Packages needed by the future expression (n = 1): ‘stats’
[10:21:26.617] Packages needed by future strategies (n = 0): <none>
[10:21:26.617] {
[10:21:26.617]     {
[10:21:26.617]         {
[10:21:26.617]             ...future.startTime <- base::Sys.time()
[10:21:26.617]             {
[10:21:26.617]                 {
[10:21:26.617]                   {
[10:21:26.617]                     {
[10:21:26.617]                       {
[10:21:26.617]                         base::local({
[10:21:26.617]                           has_future <- base::requireNamespace("future", 
[10:21:26.617]                             quietly = TRUE)
[10:21:26.617]                           if (has_future) {
[10:21:26.617]                             ns <- base::getNamespace("future")
[10:21:26.617]                             version <- ns[[".package"]][["version"]]
[10:21:26.617]                             if (is.null(version)) 
[10:21:26.617]                               version <- utils::packageVersion("future")
[10:21:26.617]                           }
[10:21:26.617]                           else {
[10:21:26.617]                             version <- NULL
[10:21:26.617]                           }
[10:21:26.617]                           if (!has_future || version < "1.8.0") {
[10:21:26.617]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.617]                               "", base::R.version$version.string), 
[10:21:26.617]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:26.617]                                 base::R.version$platform, 8 * 
[10:21:26.617]                                   base::.Machine$sizeof.pointer), 
[10:21:26.617]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.617]                                 "release", "version")], collapse = " "), 
[10:21:26.617]                               hostname = base::Sys.info()[["nodename"]])
[10:21:26.617]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.617]                               info)
[10:21:26.617]                             info <- base::paste(info, collapse = "; ")
[10:21:26.617]                             if (!has_future) {
[10:21:26.617]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.617]                                 info)
[10:21:26.617]                             }
[10:21:26.617]                             else {
[10:21:26.617]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.617]                                 info, version)
[10:21:26.617]                             }
[10:21:26.617]                             base::stop(msg)
[10:21:26.617]                           }
[10:21:26.617]                         })
[10:21:26.617]                       }
[10:21:26.617]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:26.617]                       base::options(mc.cores = 1L)
[10:21:26.617]                     }
[10:21:26.617]                     base::local({
[10:21:26.617]                       for (pkg in "stats") {
[10:21:26.617]                         base::loadNamespace(pkg)
[10:21:26.617]                         base::library(pkg, character.only = TRUE)
[10:21:26.617]                       }
[10:21:26.617]                     })
[10:21:26.617]                   }
[10:21:26.617]                   ...future.strategy.old <- future::plan("list")
[10:21:26.617]                   options(future.plan = NULL)
[10:21:26.617]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.617]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.617]                 }
[10:21:26.617]                 ...future.workdir <- getwd()
[10:21:26.617]             }
[10:21:26.617]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.617]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.617]         }
[10:21:26.617]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.617]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.617]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.617]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.617]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.617]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.617]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.617]             base::names(...future.oldOptions))
[10:21:26.617]     }
[10:21:26.617]     if (FALSE) {
[10:21:26.617]     }
[10:21:26.617]     else {
[10:21:26.617]         if (TRUE) {
[10:21:26.617]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.617]                 open = "w")
[10:21:26.617]         }
[10:21:26.617]         else {
[10:21:26.617]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.617]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.617]         }
[10:21:26.617]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.617]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.617]             base::sink(type = "output", split = FALSE)
[10:21:26.617]             base::close(...future.stdout)
[10:21:26.617]         }, add = TRUE)
[10:21:26.617]     }
[10:21:26.617]     ...future.frame <- base::sys.nframe()
[10:21:26.617]     ...future.conditions <- base::list()
[10:21:26.617]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.617]     if (FALSE) {
[10:21:26.617]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.617]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.617]     }
[10:21:26.617]     ...future.result <- base::tryCatch({
[10:21:26.617]         base::withCallingHandlers({
[10:21:26.617]             ...future.value <- base::withVisible(base::local({
[10:21:26.617]                 withCallingHandlers({
[10:21:26.617]                   {
[10:21:26.617]                     xtabs(~x)
[10:21:26.617]                   }
[10:21:26.617]                 }, immediateCondition = function(cond) {
[10:21:26.617]                   save_rds <- function (object, pathname, ...) 
[10:21:26.617]                   {
[10:21:26.617]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:26.617]                     if (file_test("-f", pathname_tmp)) {
[10:21:26.617]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.617]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:26.617]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.617]                         fi_tmp[["mtime"]])
[10:21:26.617]                     }
[10:21:26.617]                     tryCatch({
[10:21:26.617]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:26.617]                     }, error = function(ex) {
[10:21:26.617]                       msg <- conditionMessage(ex)
[10:21:26.617]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.617]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:26.617]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.617]                         fi_tmp[["mtime"]], msg)
[10:21:26.617]                       ex$message <- msg
[10:21:26.617]                       stop(ex)
[10:21:26.617]                     })
[10:21:26.617]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:26.617]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:26.617]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:26.617]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.617]                       fi <- file.info(pathname)
[10:21:26.617]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:26.617]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.617]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:26.617]                         fi[["size"]], fi[["mtime"]])
[10:21:26.617]                       stop(msg)
[10:21:26.617]                     }
[10:21:26.617]                     invisible(pathname)
[10:21:26.617]                   }
[10:21:26.617]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:26.617]                     rootPath = tempdir()) 
[10:21:26.617]                   {
[10:21:26.617]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:26.617]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:26.617]                       tmpdir = path, fileext = ".rds")
[10:21:26.617]                     save_rds(obj, file)
[10:21:26.617]                   }
[10:21:26.617]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0RHvXY/.future/immediateConditions")
[10:21:26.617]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.617]                   {
[10:21:26.617]                     inherits <- base::inherits
[10:21:26.617]                     invokeRestart <- base::invokeRestart
[10:21:26.617]                     is.null <- base::is.null
[10:21:26.617]                     muffled <- FALSE
[10:21:26.617]                     if (inherits(cond, "message")) {
[10:21:26.617]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:26.617]                       if (muffled) 
[10:21:26.617]                         invokeRestart("muffleMessage")
[10:21:26.617]                     }
[10:21:26.617]                     else if (inherits(cond, "warning")) {
[10:21:26.617]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:26.617]                       if (muffled) 
[10:21:26.617]                         invokeRestart("muffleWarning")
[10:21:26.617]                     }
[10:21:26.617]                     else if (inherits(cond, "condition")) {
[10:21:26.617]                       if (!is.null(pattern)) {
[10:21:26.617]                         computeRestarts <- base::computeRestarts
[10:21:26.617]                         grepl <- base::grepl
[10:21:26.617]                         restarts <- computeRestarts(cond)
[10:21:26.617]                         for (restart in restarts) {
[10:21:26.617]                           name <- restart$name
[10:21:26.617]                           if (is.null(name)) 
[10:21:26.617]                             next
[10:21:26.617]                           if (!grepl(pattern, name)) 
[10:21:26.617]                             next
[10:21:26.617]                           invokeRestart(restart)
[10:21:26.617]                           muffled <- TRUE
[10:21:26.617]                           break
[10:21:26.617]                         }
[10:21:26.617]                       }
[10:21:26.617]                     }
[10:21:26.617]                     invisible(muffled)
[10:21:26.617]                   }
[10:21:26.617]                   muffleCondition(cond)
[10:21:26.617]                 })
[10:21:26.617]             }))
[10:21:26.617]             future::FutureResult(value = ...future.value$value, 
[10:21:26.617]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.617]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.617]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.617]                     ...future.globalenv.names))
[10:21:26.617]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.617]         }, condition = base::local({
[10:21:26.617]             c <- base::c
[10:21:26.617]             inherits <- base::inherits
[10:21:26.617]             invokeRestart <- base::invokeRestart
[10:21:26.617]             length <- base::length
[10:21:26.617]             list <- base::list
[10:21:26.617]             seq.int <- base::seq.int
[10:21:26.617]             signalCondition <- base::signalCondition
[10:21:26.617]             sys.calls <- base::sys.calls
[10:21:26.617]             `[[` <- base::`[[`
[10:21:26.617]             `+` <- base::`+`
[10:21:26.617]             `<<-` <- base::`<<-`
[10:21:26.617]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.617]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.617]                   3L)]
[10:21:26.617]             }
[10:21:26.617]             function(cond) {
[10:21:26.617]                 is_error <- inherits(cond, "error")
[10:21:26.617]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.617]                   NULL)
[10:21:26.617]                 if (is_error) {
[10:21:26.617]                   sessionInformation <- function() {
[10:21:26.617]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.617]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.617]                       search = base::search(), system = base::Sys.info())
[10:21:26.617]                   }
[10:21:26.617]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.617]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.617]                     cond$call), session = sessionInformation(), 
[10:21:26.617]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.617]                   signalCondition(cond)
[10:21:26.617]                 }
[10:21:26.617]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.617]                 "immediateCondition"))) {
[10:21:26.617]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.617]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.617]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.617]                   if (TRUE && !signal) {
[10:21:26.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.617]                     {
[10:21:26.617]                       inherits <- base::inherits
[10:21:26.617]                       invokeRestart <- base::invokeRestart
[10:21:26.617]                       is.null <- base::is.null
[10:21:26.617]                       muffled <- FALSE
[10:21:26.617]                       if (inherits(cond, "message")) {
[10:21:26.617]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.617]                         if (muffled) 
[10:21:26.617]                           invokeRestart("muffleMessage")
[10:21:26.617]                       }
[10:21:26.617]                       else if (inherits(cond, "warning")) {
[10:21:26.617]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.617]                         if (muffled) 
[10:21:26.617]                           invokeRestart("muffleWarning")
[10:21:26.617]                       }
[10:21:26.617]                       else if (inherits(cond, "condition")) {
[10:21:26.617]                         if (!is.null(pattern)) {
[10:21:26.617]                           computeRestarts <- base::computeRestarts
[10:21:26.617]                           grepl <- base::grepl
[10:21:26.617]                           restarts <- computeRestarts(cond)
[10:21:26.617]                           for (restart in restarts) {
[10:21:26.617]                             name <- restart$name
[10:21:26.617]                             if (is.null(name)) 
[10:21:26.617]                               next
[10:21:26.617]                             if (!grepl(pattern, name)) 
[10:21:26.617]                               next
[10:21:26.617]                             invokeRestart(restart)
[10:21:26.617]                             muffled <- TRUE
[10:21:26.617]                             break
[10:21:26.617]                           }
[10:21:26.617]                         }
[10:21:26.617]                       }
[10:21:26.617]                       invisible(muffled)
[10:21:26.617]                     }
[10:21:26.617]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.617]                   }
[10:21:26.617]                 }
[10:21:26.617]                 else {
[10:21:26.617]                   if (TRUE) {
[10:21:26.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.617]                     {
[10:21:26.617]                       inherits <- base::inherits
[10:21:26.617]                       invokeRestart <- base::invokeRestart
[10:21:26.617]                       is.null <- base::is.null
[10:21:26.617]                       muffled <- FALSE
[10:21:26.617]                       if (inherits(cond, "message")) {
[10:21:26.617]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.617]                         if (muffled) 
[10:21:26.617]                           invokeRestart("muffleMessage")
[10:21:26.617]                       }
[10:21:26.617]                       else if (inherits(cond, "warning")) {
[10:21:26.617]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.617]                         if (muffled) 
[10:21:26.617]                           invokeRestart("muffleWarning")
[10:21:26.617]                       }
[10:21:26.617]                       else if (inherits(cond, "condition")) {
[10:21:26.617]                         if (!is.null(pattern)) {
[10:21:26.617]                           computeRestarts <- base::computeRestarts
[10:21:26.617]                           grepl <- base::grepl
[10:21:26.617]                           restarts <- computeRestarts(cond)
[10:21:26.617]                           for (restart in restarts) {
[10:21:26.617]                             name <- restart$name
[10:21:26.617]                             if (is.null(name)) 
[10:21:26.617]                               next
[10:21:26.617]                             if (!grepl(pattern, name)) 
[10:21:26.617]                               next
[10:21:26.617]                             invokeRestart(restart)
[10:21:26.617]                             muffled <- TRUE
[10:21:26.617]                             break
[10:21:26.617]                           }
[10:21:26.617]                         }
[10:21:26.617]                       }
[10:21:26.617]                       invisible(muffled)
[10:21:26.617]                     }
[10:21:26.617]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.617]                   }
[10:21:26.617]                 }
[10:21:26.617]             }
[10:21:26.617]         }))
[10:21:26.617]     }, error = function(ex) {
[10:21:26.617]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.617]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.617]                 ...future.rng), started = ...future.startTime, 
[10:21:26.617]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.617]             version = "1.8"), class = "FutureResult")
[10:21:26.617]     }, finally = {
[10:21:26.617]         if (!identical(...future.workdir, getwd())) 
[10:21:26.617]             setwd(...future.workdir)
[10:21:26.617]         {
[10:21:26.617]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.617]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.617]             }
[10:21:26.617]             base::options(...future.oldOptions)
[10:21:26.617]             if (.Platform$OS.type == "windows") {
[10:21:26.617]                 old_names <- names(...future.oldEnvVars)
[10:21:26.617]                 envs <- base::Sys.getenv()
[10:21:26.617]                 names <- names(envs)
[10:21:26.617]                 common <- intersect(names, old_names)
[10:21:26.617]                 added <- setdiff(names, old_names)
[10:21:26.617]                 removed <- setdiff(old_names, names)
[10:21:26.617]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.617]                   envs[common]]
[10:21:26.617]                 NAMES <- toupper(changed)
[10:21:26.617]                 args <- list()
[10:21:26.617]                 for (kk in seq_along(NAMES)) {
[10:21:26.617]                   name <- changed[[kk]]
[10:21:26.617]                   NAME <- NAMES[[kk]]
[10:21:26.617]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.617]                     next
[10:21:26.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.617]                 }
[10:21:26.617]                 NAMES <- toupper(added)
[10:21:26.617]                 for (kk in seq_along(NAMES)) {
[10:21:26.617]                   name <- added[[kk]]
[10:21:26.617]                   NAME <- NAMES[[kk]]
[10:21:26.617]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.617]                     next
[10:21:26.617]                   args[[name]] <- ""
[10:21:26.617]                 }
[10:21:26.617]                 NAMES <- toupper(removed)
[10:21:26.617]                 for (kk in seq_along(NAMES)) {
[10:21:26.617]                   name <- removed[[kk]]
[10:21:26.617]                   NAME <- NAMES[[kk]]
[10:21:26.617]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.617]                     next
[10:21:26.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.617]                 }
[10:21:26.617]                 if (length(args) > 0) 
[10:21:26.617]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.617]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.617]             }
[10:21:26.617]             else {
[10:21:26.617]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.617]             }
[10:21:26.617]             {
[10:21:26.617]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.617]                   0L) {
[10:21:26.617]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.617]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.617]                   base::options(opts)
[10:21:26.617]                 }
[10:21:26.617]                 {
[10:21:26.617]                   {
[10:21:26.617]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:26.617]                     NULL
[10:21:26.617]                   }
[10:21:26.617]                   options(future.plan = NULL)
[10:21:26.617]                   if (is.na(NA_character_)) 
[10:21:26.617]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.617]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.617]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.617]                     .init = FALSE)
[10:21:26.617]                 }
[10:21:26.617]             }
[10:21:26.617]         }
[10:21:26.617]     })
[10:21:26.617]     if (TRUE) {
[10:21:26.617]         base::sink(type = "output", split = FALSE)
[10:21:26.617]         if (TRUE) {
[10:21:26.617]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.617]         }
[10:21:26.617]         else {
[10:21:26.617]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.617]         }
[10:21:26.617]         base::close(...future.stdout)
[10:21:26.617]         ...future.stdout <- NULL
[10:21:26.617]     }
[10:21:26.617]     ...future.result$conditions <- ...future.conditions
[10:21:26.617]     ...future.result$finished <- base::Sys.time()
[10:21:26.617]     ...future.result
[10:21:26.617] }
[10:21:26.620] assign_globals() ...
[10:21:26.620] List of 1
[10:21:26.620]  $ x: num [1:5] 1 1 2 2 2
[10:21:26.620]  - attr(*, "where")=List of 1
[10:21:26.620]   ..$ x:<environment: R_EmptyEnv> 
[10:21:26.620]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:26.620]  - attr(*, "resolved")= logi FALSE
[10:21:26.620]  - attr(*, "total_size")= num 71
[10:21:26.620]  - attr(*, "already-done")= logi TRUE
[10:21:26.623] - copied ‘x’ to environment
[10:21:26.623] assign_globals() ... done
[10:21:26.623] requestCore(): workers = 2
[10:21:26.626] MulticoreFuture started
[10:21:26.626] - Launch lazy future ... done
[10:21:26.627] run() for ‘MulticoreFuture’ ... done
[10:21:26.627] result() for MulticoreFuture ...
[10:21:26.628] plan(): Setting new future strategy stack:
[10:21:26.628] List of future strategies:
[10:21:26.628] 1. sequential:
[10:21:26.628]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.628]    - tweaked: FALSE
[10:21:26.628]    - call: NULL
[10:21:26.629] plan(): nbrOfWorkers() = 1
[10:21:26.633] plan(): Setting new future strategy stack:
[10:21:26.633] List of future strategies:
[10:21:26.633] 1. multicore:
[10:21:26.633]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:26.633]    - tweaked: FALSE
[10:21:26.633]    - call: plan(strategy)
[10:21:26.637] plan(): nbrOfWorkers() = 2
[10:21:26.638] result() for MulticoreFuture ...
[10:21:26.638] result() for MulticoreFuture ... done
[10:21:26.639] result() for MulticoreFuture ... done
[10:21:26.639] result() for MulticoreFuture ...
[10:21:26.639] result() for MulticoreFuture ... done
x
1 2 
2 3 
[10:21:26.641] getGlobalsAndPackages() ...
[10:21:26.641] Searching for globals...
[10:21:26.643] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[10:21:26.643] Searching for globals ... DONE
[10:21:26.643] Resolving globals: FALSE
[10:21:26.643] The total size of the 1 globals is 71 bytes (71 bytes)
[10:21:26.644] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 71 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (71 bytes of class ‘numeric’)
[10:21:26.644] - globals: [1] ‘x’
[10:21:26.644] - packages: [1] ‘stats’
[10:21:26.645] getGlobalsAndPackages() ... DONE
[10:21:26.645] run() for ‘Future’ ...
[10:21:26.645] - state: ‘created’
[10:21:26.645] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:26.651] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:26.652] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:26.652]   - Field: ‘label’
[10:21:26.652]   - Field: ‘local’
[10:21:26.652]   - Field: ‘owner’
[10:21:26.652]   - Field: ‘envir’
[10:21:26.653]   - Field: ‘workers’
[10:21:26.653]   - Field: ‘packages’
[10:21:26.653]   - Field: ‘gc’
[10:21:26.653]   - Field: ‘job’
[10:21:26.653]   - Field: ‘conditions’
[10:21:26.653]   - Field: ‘expr’
[10:21:26.654]   - Field: ‘uuid’
[10:21:26.654]   - Field: ‘seed’
[10:21:26.654]   - Field: ‘version’
[10:21:26.654]   - Field: ‘result’
[10:21:26.654]   - Field: ‘asynchronous’
[10:21:26.655]   - Field: ‘calls’
[10:21:26.655]   - Field: ‘globals’
[10:21:26.655]   - Field: ‘stdout’
[10:21:26.655]   - Field: ‘earlySignal’
[10:21:26.655]   - Field: ‘lazy’
[10:21:26.655]   - Field: ‘state’
[10:21:26.655] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:26.655] - Launch lazy future ...
[10:21:26.656] Packages needed by the future expression (n = 1): ‘stats’
[10:21:26.656] Packages needed by future strategies (n = 0): <none>
[10:21:26.657] {
[10:21:26.657]     {
[10:21:26.657]         {
[10:21:26.657]             ...future.startTime <- base::Sys.time()
[10:21:26.657]             {
[10:21:26.657]                 {
[10:21:26.657]                   {
[10:21:26.657]                     {
[10:21:26.657]                       {
[10:21:26.657]                         base::local({
[10:21:26.657]                           has_future <- base::requireNamespace("future", 
[10:21:26.657]                             quietly = TRUE)
[10:21:26.657]                           if (has_future) {
[10:21:26.657]                             ns <- base::getNamespace("future")
[10:21:26.657]                             version <- ns[[".package"]][["version"]]
[10:21:26.657]                             if (is.null(version)) 
[10:21:26.657]                               version <- utils::packageVersion("future")
[10:21:26.657]                           }
[10:21:26.657]                           else {
[10:21:26.657]                             version <- NULL
[10:21:26.657]                           }
[10:21:26.657]                           if (!has_future || version < "1.8.0") {
[10:21:26.657]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.657]                               "", base::R.version$version.string), 
[10:21:26.657]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:26.657]                                 base::R.version$platform, 8 * 
[10:21:26.657]                                   base::.Machine$sizeof.pointer), 
[10:21:26.657]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.657]                                 "release", "version")], collapse = " "), 
[10:21:26.657]                               hostname = base::Sys.info()[["nodename"]])
[10:21:26.657]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.657]                               info)
[10:21:26.657]                             info <- base::paste(info, collapse = "; ")
[10:21:26.657]                             if (!has_future) {
[10:21:26.657]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.657]                                 info)
[10:21:26.657]                             }
[10:21:26.657]                             else {
[10:21:26.657]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.657]                                 info, version)
[10:21:26.657]                             }
[10:21:26.657]                             base::stop(msg)
[10:21:26.657]                           }
[10:21:26.657]                         })
[10:21:26.657]                       }
[10:21:26.657]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:26.657]                       base::options(mc.cores = 1L)
[10:21:26.657]                     }
[10:21:26.657]                     base::local({
[10:21:26.657]                       for (pkg in "stats") {
[10:21:26.657]                         base::loadNamespace(pkg)
[10:21:26.657]                         base::library(pkg, character.only = TRUE)
[10:21:26.657]                       }
[10:21:26.657]                     })
[10:21:26.657]                   }
[10:21:26.657]                   ...future.strategy.old <- future::plan("list")
[10:21:26.657]                   options(future.plan = NULL)
[10:21:26.657]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.657]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.657]                 }
[10:21:26.657]                 ...future.workdir <- getwd()
[10:21:26.657]             }
[10:21:26.657]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.657]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.657]         }
[10:21:26.657]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.657]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.657]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.657]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.657]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.657]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.657]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.657]             base::names(...future.oldOptions))
[10:21:26.657]     }
[10:21:26.657]     if (FALSE) {
[10:21:26.657]     }
[10:21:26.657]     else {
[10:21:26.657]         if (TRUE) {
[10:21:26.657]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.657]                 open = "w")
[10:21:26.657]         }
[10:21:26.657]         else {
[10:21:26.657]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.657]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.657]         }
[10:21:26.657]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.657]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.657]             base::sink(type = "output", split = FALSE)
[10:21:26.657]             base::close(...future.stdout)
[10:21:26.657]         }, add = TRUE)
[10:21:26.657]     }
[10:21:26.657]     ...future.frame <- base::sys.nframe()
[10:21:26.657]     ...future.conditions <- base::list()
[10:21:26.657]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.657]     if (FALSE) {
[10:21:26.657]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.657]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.657]     }
[10:21:26.657]     ...future.result <- base::tryCatch({
[10:21:26.657]         base::withCallingHandlers({
[10:21:26.657]             ...future.value <- base::withVisible(base::local({
[10:21:26.657]                 withCallingHandlers({
[10:21:26.657]                   {
[10:21:26.657]                     xtabs(~x)
[10:21:26.657]                   }
[10:21:26.657]                 }, immediateCondition = function(cond) {
[10:21:26.657]                   save_rds <- function (object, pathname, ...) 
[10:21:26.657]                   {
[10:21:26.657]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:26.657]                     if (file_test("-f", pathname_tmp)) {
[10:21:26.657]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.657]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:26.657]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.657]                         fi_tmp[["mtime"]])
[10:21:26.657]                     }
[10:21:26.657]                     tryCatch({
[10:21:26.657]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:26.657]                     }, error = function(ex) {
[10:21:26.657]                       msg <- conditionMessage(ex)
[10:21:26.657]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.657]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:26.657]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.657]                         fi_tmp[["mtime"]], msg)
[10:21:26.657]                       ex$message <- msg
[10:21:26.657]                       stop(ex)
[10:21:26.657]                     })
[10:21:26.657]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:26.657]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:26.657]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:26.657]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.657]                       fi <- file.info(pathname)
[10:21:26.657]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:26.657]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.657]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:26.657]                         fi[["size"]], fi[["mtime"]])
[10:21:26.657]                       stop(msg)
[10:21:26.657]                     }
[10:21:26.657]                     invisible(pathname)
[10:21:26.657]                   }
[10:21:26.657]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:26.657]                     rootPath = tempdir()) 
[10:21:26.657]                   {
[10:21:26.657]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:26.657]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:26.657]                       tmpdir = path, fileext = ".rds")
[10:21:26.657]                     save_rds(obj, file)
[10:21:26.657]                   }
[10:21:26.657]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0RHvXY/.future/immediateConditions")
[10:21:26.657]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.657]                   {
[10:21:26.657]                     inherits <- base::inherits
[10:21:26.657]                     invokeRestart <- base::invokeRestart
[10:21:26.657]                     is.null <- base::is.null
[10:21:26.657]                     muffled <- FALSE
[10:21:26.657]                     if (inherits(cond, "message")) {
[10:21:26.657]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:26.657]                       if (muffled) 
[10:21:26.657]                         invokeRestart("muffleMessage")
[10:21:26.657]                     }
[10:21:26.657]                     else if (inherits(cond, "warning")) {
[10:21:26.657]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:26.657]                       if (muffled) 
[10:21:26.657]                         invokeRestart("muffleWarning")
[10:21:26.657]                     }
[10:21:26.657]                     else if (inherits(cond, "condition")) {
[10:21:26.657]                       if (!is.null(pattern)) {
[10:21:26.657]                         computeRestarts <- base::computeRestarts
[10:21:26.657]                         grepl <- base::grepl
[10:21:26.657]                         restarts <- computeRestarts(cond)
[10:21:26.657]                         for (restart in restarts) {
[10:21:26.657]                           name <- restart$name
[10:21:26.657]                           if (is.null(name)) 
[10:21:26.657]                             next
[10:21:26.657]                           if (!grepl(pattern, name)) 
[10:21:26.657]                             next
[10:21:26.657]                           invokeRestart(restart)
[10:21:26.657]                           muffled <- TRUE
[10:21:26.657]                           break
[10:21:26.657]                         }
[10:21:26.657]                       }
[10:21:26.657]                     }
[10:21:26.657]                     invisible(muffled)
[10:21:26.657]                   }
[10:21:26.657]                   muffleCondition(cond)
[10:21:26.657]                 })
[10:21:26.657]             }))
[10:21:26.657]             future::FutureResult(value = ...future.value$value, 
[10:21:26.657]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.657]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.657]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.657]                     ...future.globalenv.names))
[10:21:26.657]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.657]         }, condition = base::local({
[10:21:26.657]             c <- base::c
[10:21:26.657]             inherits <- base::inherits
[10:21:26.657]             invokeRestart <- base::invokeRestart
[10:21:26.657]             length <- base::length
[10:21:26.657]             list <- base::list
[10:21:26.657]             seq.int <- base::seq.int
[10:21:26.657]             signalCondition <- base::signalCondition
[10:21:26.657]             sys.calls <- base::sys.calls
[10:21:26.657]             `[[` <- base::`[[`
[10:21:26.657]             `+` <- base::`+`
[10:21:26.657]             `<<-` <- base::`<<-`
[10:21:26.657]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.657]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.657]                   3L)]
[10:21:26.657]             }
[10:21:26.657]             function(cond) {
[10:21:26.657]                 is_error <- inherits(cond, "error")
[10:21:26.657]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.657]                   NULL)
[10:21:26.657]                 if (is_error) {
[10:21:26.657]                   sessionInformation <- function() {
[10:21:26.657]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.657]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.657]                       search = base::search(), system = base::Sys.info())
[10:21:26.657]                   }
[10:21:26.657]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.657]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.657]                     cond$call), session = sessionInformation(), 
[10:21:26.657]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.657]                   signalCondition(cond)
[10:21:26.657]                 }
[10:21:26.657]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.657]                 "immediateCondition"))) {
[10:21:26.657]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.657]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.657]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.657]                   if (TRUE && !signal) {
[10:21:26.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.657]                     {
[10:21:26.657]                       inherits <- base::inherits
[10:21:26.657]                       invokeRestart <- base::invokeRestart
[10:21:26.657]                       is.null <- base::is.null
[10:21:26.657]                       muffled <- FALSE
[10:21:26.657]                       if (inherits(cond, "message")) {
[10:21:26.657]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.657]                         if (muffled) 
[10:21:26.657]                           invokeRestart("muffleMessage")
[10:21:26.657]                       }
[10:21:26.657]                       else if (inherits(cond, "warning")) {
[10:21:26.657]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.657]                         if (muffled) 
[10:21:26.657]                           invokeRestart("muffleWarning")
[10:21:26.657]                       }
[10:21:26.657]                       else if (inherits(cond, "condition")) {
[10:21:26.657]                         if (!is.null(pattern)) {
[10:21:26.657]                           computeRestarts <- base::computeRestarts
[10:21:26.657]                           grepl <- base::grepl
[10:21:26.657]                           restarts <- computeRestarts(cond)
[10:21:26.657]                           for (restart in restarts) {
[10:21:26.657]                             name <- restart$name
[10:21:26.657]                             if (is.null(name)) 
[10:21:26.657]                               next
[10:21:26.657]                             if (!grepl(pattern, name)) 
[10:21:26.657]                               next
[10:21:26.657]                             invokeRestart(restart)
[10:21:26.657]                             muffled <- TRUE
[10:21:26.657]                             break
[10:21:26.657]                           }
[10:21:26.657]                         }
[10:21:26.657]                       }
[10:21:26.657]                       invisible(muffled)
[10:21:26.657]                     }
[10:21:26.657]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.657]                   }
[10:21:26.657]                 }
[10:21:26.657]                 else {
[10:21:26.657]                   if (TRUE) {
[10:21:26.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.657]                     {
[10:21:26.657]                       inherits <- base::inherits
[10:21:26.657]                       invokeRestart <- base::invokeRestart
[10:21:26.657]                       is.null <- base::is.null
[10:21:26.657]                       muffled <- FALSE
[10:21:26.657]                       if (inherits(cond, "message")) {
[10:21:26.657]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.657]                         if (muffled) 
[10:21:26.657]                           invokeRestart("muffleMessage")
[10:21:26.657]                       }
[10:21:26.657]                       else if (inherits(cond, "warning")) {
[10:21:26.657]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.657]                         if (muffled) 
[10:21:26.657]                           invokeRestart("muffleWarning")
[10:21:26.657]                       }
[10:21:26.657]                       else if (inherits(cond, "condition")) {
[10:21:26.657]                         if (!is.null(pattern)) {
[10:21:26.657]                           computeRestarts <- base::computeRestarts
[10:21:26.657]                           grepl <- base::grepl
[10:21:26.657]                           restarts <- computeRestarts(cond)
[10:21:26.657]                           for (restart in restarts) {
[10:21:26.657]                             name <- restart$name
[10:21:26.657]                             if (is.null(name)) 
[10:21:26.657]                               next
[10:21:26.657]                             if (!grepl(pattern, name)) 
[10:21:26.657]                               next
[10:21:26.657]                             invokeRestart(restart)
[10:21:26.657]                             muffled <- TRUE
[10:21:26.657]                             break
[10:21:26.657]                           }
[10:21:26.657]                         }
[10:21:26.657]                       }
[10:21:26.657]                       invisible(muffled)
[10:21:26.657]                     }
[10:21:26.657]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.657]                   }
[10:21:26.657]                 }
[10:21:26.657]             }
[10:21:26.657]         }))
[10:21:26.657]     }, error = function(ex) {
[10:21:26.657]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.657]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.657]                 ...future.rng), started = ...future.startTime, 
[10:21:26.657]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.657]             version = "1.8"), class = "FutureResult")
[10:21:26.657]     }, finally = {
[10:21:26.657]         if (!identical(...future.workdir, getwd())) 
[10:21:26.657]             setwd(...future.workdir)
[10:21:26.657]         {
[10:21:26.657]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.657]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.657]             }
[10:21:26.657]             base::options(...future.oldOptions)
[10:21:26.657]             if (.Platform$OS.type == "windows") {
[10:21:26.657]                 old_names <- names(...future.oldEnvVars)
[10:21:26.657]                 envs <- base::Sys.getenv()
[10:21:26.657]                 names <- names(envs)
[10:21:26.657]                 common <- intersect(names, old_names)
[10:21:26.657]                 added <- setdiff(names, old_names)
[10:21:26.657]                 removed <- setdiff(old_names, names)
[10:21:26.657]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.657]                   envs[common]]
[10:21:26.657]                 NAMES <- toupper(changed)
[10:21:26.657]                 args <- list()
[10:21:26.657]                 for (kk in seq_along(NAMES)) {
[10:21:26.657]                   name <- changed[[kk]]
[10:21:26.657]                   NAME <- NAMES[[kk]]
[10:21:26.657]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.657]                     next
[10:21:26.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.657]                 }
[10:21:26.657]                 NAMES <- toupper(added)
[10:21:26.657]                 for (kk in seq_along(NAMES)) {
[10:21:26.657]                   name <- added[[kk]]
[10:21:26.657]                   NAME <- NAMES[[kk]]
[10:21:26.657]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.657]                     next
[10:21:26.657]                   args[[name]] <- ""
[10:21:26.657]                 }
[10:21:26.657]                 NAMES <- toupper(removed)
[10:21:26.657]                 for (kk in seq_along(NAMES)) {
[10:21:26.657]                   name <- removed[[kk]]
[10:21:26.657]                   NAME <- NAMES[[kk]]
[10:21:26.657]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.657]                     next
[10:21:26.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.657]                 }
[10:21:26.657]                 if (length(args) > 0) 
[10:21:26.657]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.657]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.657]             }
[10:21:26.657]             else {
[10:21:26.657]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.657]             }
[10:21:26.657]             {
[10:21:26.657]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.657]                   0L) {
[10:21:26.657]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.657]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.657]                   base::options(opts)
[10:21:26.657]                 }
[10:21:26.657]                 {
[10:21:26.657]                   {
[10:21:26.657]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:26.657]                     NULL
[10:21:26.657]                   }
[10:21:26.657]                   options(future.plan = NULL)
[10:21:26.657]                   if (is.na(NA_character_)) 
[10:21:26.657]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.657]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.657]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.657]                     .init = FALSE)
[10:21:26.657]                 }
[10:21:26.657]             }
[10:21:26.657]         }
[10:21:26.657]     })
[10:21:26.657]     if (TRUE) {
[10:21:26.657]         base::sink(type = "output", split = FALSE)
[10:21:26.657]         if (TRUE) {
[10:21:26.657]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.657]         }
[10:21:26.657]         else {
[10:21:26.657]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.657]         }
[10:21:26.657]         base::close(...future.stdout)
[10:21:26.657]         ...future.stdout <- NULL
[10:21:26.657]     }
[10:21:26.657]     ...future.result$conditions <- ...future.conditions
[10:21:26.657]     ...future.result$finished <- base::Sys.time()
[10:21:26.657]     ...future.result
[10:21:26.657] }
[10:21:26.659] assign_globals() ...
[10:21:26.659] List of 1
[10:21:26.659]  $ x: num [1:5] 1 1 2 2 2
[10:21:26.659]  - attr(*, "where")=List of 1
[10:21:26.659]   ..$ x:<environment: R_EmptyEnv> 
[10:21:26.659]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:26.659]  - attr(*, "resolved")= logi FALSE
[10:21:26.659]  - attr(*, "total_size")= num 71
[10:21:26.659]  - attr(*, "already-done")= logi TRUE
[10:21:26.662] - copied ‘x’ to environment
[10:21:26.662] assign_globals() ... done
[10:21:26.663] requestCore(): workers = 2
[10:21:26.664] MulticoreFuture started
[10:21:26.665] - Launch lazy future ... done
[10:21:26.665] run() for ‘MulticoreFuture’ ... done
[10:21:26.666] result() for MulticoreFuture ...
[10:21:26.666] plan(): Setting new future strategy stack:
[10:21:26.666] List of future strategies:
[10:21:26.666] 1. sequential:
[10:21:26.666]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.666]    - tweaked: FALSE
[10:21:26.666]    - call: NULL
[10:21:26.668] plan(): nbrOfWorkers() = 1
[10:21:26.671] plan(): Setting new future strategy stack:
[10:21:26.671] List of future strategies:
[10:21:26.671] 1. multicore:
[10:21:26.671]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:26.671]    - tweaked: FALSE
[10:21:26.671]    - call: plan(strategy)
[10:21:26.674] plan(): nbrOfWorkers() = 2
[10:21:26.675] result() for MulticoreFuture ...
[10:21:26.675] result() for MulticoreFuture ... done
[10:21:26.675] result() for MulticoreFuture ... done
[10:21:26.675] result() for MulticoreFuture ...
[10:21:26.675] result() for MulticoreFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[10:21:26.678] getGlobalsAndPackages() ...
[10:21:26.678] Searching for globals...
[10:21:26.680] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[10:21:26.681] Searching for globals ... DONE
[10:21:26.681] Resolving globals: FALSE
[10:21:26.681] 
[10:21:26.682] - packages: [2] ‘stats’, ‘datasets’
[10:21:26.682] getGlobalsAndPackages() ... DONE
[10:21:26.682] run() for ‘Future’ ...
[10:21:26.682] - state: ‘created’
[10:21:26.682] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:26.684] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:26.685] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:26.685]   - Field: ‘label’
[10:21:26.685]   - Field: ‘local’
[10:21:26.685]   - Field: ‘owner’
[10:21:26.685]   - Field: ‘envir’
[10:21:26.685]   - Field: ‘workers’
[10:21:26.686]   - Field: ‘packages’
[10:21:26.686]   - Field: ‘gc’
[10:21:26.686]   - Field: ‘job’
[10:21:26.686]   - Field: ‘conditions’
[10:21:26.686]   - Field: ‘expr’
[10:21:26.686]   - Field: ‘uuid’
[10:21:26.686]   - Field: ‘seed’
[10:21:26.686]   - Field: ‘version’
[10:21:26.687]   - Field: ‘result’
[10:21:26.687]   - Field: ‘asynchronous’
[10:21:26.687]   - Field: ‘calls’
[10:21:26.687]   - Field: ‘globals’
[10:21:26.687]   - Field: ‘stdout’
[10:21:26.687]   - Field: ‘earlySignal’
[10:21:26.687]   - Field: ‘lazy’
[10:21:26.687]   - Field: ‘state’
[10:21:26.687] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:26.687] - Launch lazy future ...
[10:21:26.688] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:21:26.688] Packages needed by future strategies (n = 0): <none>
[10:21:26.689] {
[10:21:26.689]     {
[10:21:26.689]         {
[10:21:26.689]             ...future.startTime <- base::Sys.time()
[10:21:26.689]             {
[10:21:26.689]                 {
[10:21:26.689]                   {
[10:21:26.689]                     {
[10:21:26.689]                       {
[10:21:26.689]                         base::local({
[10:21:26.689]                           has_future <- base::requireNamespace("future", 
[10:21:26.689]                             quietly = TRUE)
[10:21:26.689]                           if (has_future) {
[10:21:26.689]                             ns <- base::getNamespace("future")
[10:21:26.689]                             version <- ns[[".package"]][["version"]]
[10:21:26.689]                             if (is.null(version)) 
[10:21:26.689]                               version <- utils::packageVersion("future")
[10:21:26.689]                           }
[10:21:26.689]                           else {
[10:21:26.689]                             version <- NULL
[10:21:26.689]                           }
[10:21:26.689]                           if (!has_future || version < "1.8.0") {
[10:21:26.689]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.689]                               "", base::R.version$version.string), 
[10:21:26.689]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:26.689]                                 base::R.version$platform, 8 * 
[10:21:26.689]                                   base::.Machine$sizeof.pointer), 
[10:21:26.689]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.689]                                 "release", "version")], collapse = " "), 
[10:21:26.689]                               hostname = base::Sys.info()[["nodename"]])
[10:21:26.689]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.689]                               info)
[10:21:26.689]                             info <- base::paste(info, collapse = "; ")
[10:21:26.689]                             if (!has_future) {
[10:21:26.689]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.689]                                 info)
[10:21:26.689]                             }
[10:21:26.689]                             else {
[10:21:26.689]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.689]                                 info, version)
[10:21:26.689]                             }
[10:21:26.689]                             base::stop(msg)
[10:21:26.689]                           }
[10:21:26.689]                         })
[10:21:26.689]                       }
[10:21:26.689]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:26.689]                       base::options(mc.cores = 1L)
[10:21:26.689]                     }
[10:21:26.689]                     base::local({
[10:21:26.689]                       for (pkg in c("stats", "datasets")) {
[10:21:26.689]                         base::loadNamespace(pkg)
[10:21:26.689]                         base::library(pkg, character.only = TRUE)
[10:21:26.689]                       }
[10:21:26.689]                     })
[10:21:26.689]                   }
[10:21:26.689]                   ...future.strategy.old <- future::plan("list")
[10:21:26.689]                   options(future.plan = NULL)
[10:21:26.689]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.689]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.689]                 }
[10:21:26.689]                 ...future.workdir <- getwd()
[10:21:26.689]             }
[10:21:26.689]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.689]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.689]         }
[10:21:26.689]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.689]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.689]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.689]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.689]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.689]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.689]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.689]             base::names(...future.oldOptions))
[10:21:26.689]     }
[10:21:26.689]     if (FALSE) {
[10:21:26.689]     }
[10:21:26.689]     else {
[10:21:26.689]         if (TRUE) {
[10:21:26.689]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.689]                 open = "w")
[10:21:26.689]         }
[10:21:26.689]         else {
[10:21:26.689]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.689]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.689]         }
[10:21:26.689]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.689]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.689]             base::sink(type = "output", split = FALSE)
[10:21:26.689]             base::close(...future.stdout)
[10:21:26.689]         }, add = TRUE)
[10:21:26.689]     }
[10:21:26.689]     ...future.frame <- base::sys.nframe()
[10:21:26.689]     ...future.conditions <- base::list()
[10:21:26.689]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.689]     if (FALSE) {
[10:21:26.689]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.689]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.689]     }
[10:21:26.689]     ...future.result <- base::tryCatch({
[10:21:26.689]         base::withCallingHandlers({
[10:21:26.689]             ...future.value <- base::withVisible(base::local({
[10:21:26.689]                 withCallingHandlers({
[10:21:26.689]                   {
[10:21:26.689]                     lm(dist ~ . - 1, data = cars)
[10:21:26.689]                   }
[10:21:26.689]                 }, immediateCondition = function(cond) {
[10:21:26.689]                   save_rds <- function (object, pathname, ...) 
[10:21:26.689]                   {
[10:21:26.689]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:26.689]                     if (file_test("-f", pathname_tmp)) {
[10:21:26.689]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.689]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:26.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.689]                         fi_tmp[["mtime"]])
[10:21:26.689]                     }
[10:21:26.689]                     tryCatch({
[10:21:26.689]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:26.689]                     }, error = function(ex) {
[10:21:26.689]                       msg <- conditionMessage(ex)
[10:21:26.689]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.689]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:26.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.689]                         fi_tmp[["mtime"]], msg)
[10:21:26.689]                       ex$message <- msg
[10:21:26.689]                       stop(ex)
[10:21:26.689]                     })
[10:21:26.689]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:26.689]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:26.689]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:26.689]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.689]                       fi <- file.info(pathname)
[10:21:26.689]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:26.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.689]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:26.689]                         fi[["size"]], fi[["mtime"]])
[10:21:26.689]                       stop(msg)
[10:21:26.689]                     }
[10:21:26.689]                     invisible(pathname)
[10:21:26.689]                   }
[10:21:26.689]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:26.689]                     rootPath = tempdir()) 
[10:21:26.689]                   {
[10:21:26.689]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:26.689]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:26.689]                       tmpdir = path, fileext = ".rds")
[10:21:26.689]                     save_rds(obj, file)
[10:21:26.689]                   }
[10:21:26.689]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0RHvXY/.future/immediateConditions")
[10:21:26.689]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.689]                   {
[10:21:26.689]                     inherits <- base::inherits
[10:21:26.689]                     invokeRestart <- base::invokeRestart
[10:21:26.689]                     is.null <- base::is.null
[10:21:26.689]                     muffled <- FALSE
[10:21:26.689]                     if (inherits(cond, "message")) {
[10:21:26.689]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:26.689]                       if (muffled) 
[10:21:26.689]                         invokeRestart("muffleMessage")
[10:21:26.689]                     }
[10:21:26.689]                     else if (inherits(cond, "warning")) {
[10:21:26.689]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:26.689]                       if (muffled) 
[10:21:26.689]                         invokeRestart("muffleWarning")
[10:21:26.689]                     }
[10:21:26.689]                     else if (inherits(cond, "condition")) {
[10:21:26.689]                       if (!is.null(pattern)) {
[10:21:26.689]                         computeRestarts <- base::computeRestarts
[10:21:26.689]                         grepl <- base::grepl
[10:21:26.689]                         restarts <- computeRestarts(cond)
[10:21:26.689]                         for (restart in restarts) {
[10:21:26.689]                           name <- restart$name
[10:21:26.689]                           if (is.null(name)) 
[10:21:26.689]                             next
[10:21:26.689]                           if (!grepl(pattern, name)) 
[10:21:26.689]                             next
[10:21:26.689]                           invokeRestart(restart)
[10:21:26.689]                           muffled <- TRUE
[10:21:26.689]                           break
[10:21:26.689]                         }
[10:21:26.689]                       }
[10:21:26.689]                     }
[10:21:26.689]                     invisible(muffled)
[10:21:26.689]                   }
[10:21:26.689]                   muffleCondition(cond)
[10:21:26.689]                 })
[10:21:26.689]             }))
[10:21:26.689]             future::FutureResult(value = ...future.value$value, 
[10:21:26.689]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.689]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.689]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.689]                     ...future.globalenv.names))
[10:21:26.689]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.689]         }, condition = base::local({
[10:21:26.689]             c <- base::c
[10:21:26.689]             inherits <- base::inherits
[10:21:26.689]             invokeRestart <- base::invokeRestart
[10:21:26.689]             length <- base::length
[10:21:26.689]             list <- base::list
[10:21:26.689]             seq.int <- base::seq.int
[10:21:26.689]             signalCondition <- base::signalCondition
[10:21:26.689]             sys.calls <- base::sys.calls
[10:21:26.689]             `[[` <- base::`[[`
[10:21:26.689]             `+` <- base::`+`
[10:21:26.689]             `<<-` <- base::`<<-`
[10:21:26.689]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.689]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.689]                   3L)]
[10:21:26.689]             }
[10:21:26.689]             function(cond) {
[10:21:26.689]                 is_error <- inherits(cond, "error")
[10:21:26.689]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.689]                   NULL)
[10:21:26.689]                 if (is_error) {
[10:21:26.689]                   sessionInformation <- function() {
[10:21:26.689]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.689]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.689]                       search = base::search(), system = base::Sys.info())
[10:21:26.689]                   }
[10:21:26.689]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.689]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.689]                     cond$call), session = sessionInformation(), 
[10:21:26.689]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.689]                   signalCondition(cond)
[10:21:26.689]                 }
[10:21:26.689]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.689]                 "immediateCondition"))) {
[10:21:26.689]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.689]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.689]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.689]                   if (TRUE && !signal) {
[10:21:26.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.689]                     {
[10:21:26.689]                       inherits <- base::inherits
[10:21:26.689]                       invokeRestart <- base::invokeRestart
[10:21:26.689]                       is.null <- base::is.null
[10:21:26.689]                       muffled <- FALSE
[10:21:26.689]                       if (inherits(cond, "message")) {
[10:21:26.689]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.689]                         if (muffled) 
[10:21:26.689]                           invokeRestart("muffleMessage")
[10:21:26.689]                       }
[10:21:26.689]                       else if (inherits(cond, "warning")) {
[10:21:26.689]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.689]                         if (muffled) 
[10:21:26.689]                           invokeRestart("muffleWarning")
[10:21:26.689]                       }
[10:21:26.689]                       else if (inherits(cond, "condition")) {
[10:21:26.689]                         if (!is.null(pattern)) {
[10:21:26.689]                           computeRestarts <- base::computeRestarts
[10:21:26.689]                           grepl <- base::grepl
[10:21:26.689]                           restarts <- computeRestarts(cond)
[10:21:26.689]                           for (restart in restarts) {
[10:21:26.689]                             name <- restart$name
[10:21:26.689]                             if (is.null(name)) 
[10:21:26.689]                               next
[10:21:26.689]                             if (!grepl(pattern, name)) 
[10:21:26.689]                               next
[10:21:26.689]                             invokeRestart(restart)
[10:21:26.689]                             muffled <- TRUE
[10:21:26.689]                             break
[10:21:26.689]                           }
[10:21:26.689]                         }
[10:21:26.689]                       }
[10:21:26.689]                       invisible(muffled)
[10:21:26.689]                     }
[10:21:26.689]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.689]                   }
[10:21:26.689]                 }
[10:21:26.689]                 else {
[10:21:26.689]                   if (TRUE) {
[10:21:26.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.689]                     {
[10:21:26.689]                       inherits <- base::inherits
[10:21:26.689]                       invokeRestart <- base::invokeRestart
[10:21:26.689]                       is.null <- base::is.null
[10:21:26.689]                       muffled <- FALSE
[10:21:26.689]                       if (inherits(cond, "message")) {
[10:21:26.689]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.689]                         if (muffled) 
[10:21:26.689]                           invokeRestart("muffleMessage")
[10:21:26.689]                       }
[10:21:26.689]                       else if (inherits(cond, "warning")) {
[10:21:26.689]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.689]                         if (muffled) 
[10:21:26.689]                           invokeRestart("muffleWarning")
[10:21:26.689]                       }
[10:21:26.689]                       else if (inherits(cond, "condition")) {
[10:21:26.689]                         if (!is.null(pattern)) {
[10:21:26.689]                           computeRestarts <- base::computeRestarts
[10:21:26.689]                           grepl <- base::grepl
[10:21:26.689]                           restarts <- computeRestarts(cond)
[10:21:26.689]                           for (restart in restarts) {
[10:21:26.689]                             name <- restart$name
[10:21:26.689]                             if (is.null(name)) 
[10:21:26.689]                               next
[10:21:26.689]                             if (!grepl(pattern, name)) 
[10:21:26.689]                               next
[10:21:26.689]                             invokeRestart(restart)
[10:21:26.689]                             muffled <- TRUE
[10:21:26.689]                             break
[10:21:26.689]                           }
[10:21:26.689]                         }
[10:21:26.689]                       }
[10:21:26.689]                       invisible(muffled)
[10:21:26.689]                     }
[10:21:26.689]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.689]                   }
[10:21:26.689]                 }
[10:21:26.689]             }
[10:21:26.689]         }))
[10:21:26.689]     }, error = function(ex) {
[10:21:26.689]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.689]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.689]                 ...future.rng), started = ...future.startTime, 
[10:21:26.689]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.689]             version = "1.8"), class = "FutureResult")
[10:21:26.689]     }, finally = {
[10:21:26.689]         if (!identical(...future.workdir, getwd())) 
[10:21:26.689]             setwd(...future.workdir)
[10:21:26.689]         {
[10:21:26.689]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.689]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.689]             }
[10:21:26.689]             base::options(...future.oldOptions)
[10:21:26.689]             if (.Platform$OS.type == "windows") {
[10:21:26.689]                 old_names <- names(...future.oldEnvVars)
[10:21:26.689]                 envs <- base::Sys.getenv()
[10:21:26.689]                 names <- names(envs)
[10:21:26.689]                 common <- intersect(names, old_names)
[10:21:26.689]                 added <- setdiff(names, old_names)
[10:21:26.689]                 removed <- setdiff(old_names, names)
[10:21:26.689]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.689]                   envs[common]]
[10:21:26.689]                 NAMES <- toupper(changed)
[10:21:26.689]                 args <- list()
[10:21:26.689]                 for (kk in seq_along(NAMES)) {
[10:21:26.689]                   name <- changed[[kk]]
[10:21:26.689]                   NAME <- NAMES[[kk]]
[10:21:26.689]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.689]                     next
[10:21:26.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.689]                 }
[10:21:26.689]                 NAMES <- toupper(added)
[10:21:26.689]                 for (kk in seq_along(NAMES)) {
[10:21:26.689]                   name <- added[[kk]]
[10:21:26.689]                   NAME <- NAMES[[kk]]
[10:21:26.689]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.689]                     next
[10:21:26.689]                   args[[name]] <- ""
[10:21:26.689]                 }
[10:21:26.689]                 NAMES <- toupper(removed)
[10:21:26.689]                 for (kk in seq_along(NAMES)) {
[10:21:26.689]                   name <- removed[[kk]]
[10:21:26.689]                   NAME <- NAMES[[kk]]
[10:21:26.689]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.689]                     next
[10:21:26.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.689]                 }
[10:21:26.689]                 if (length(args) > 0) 
[10:21:26.689]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.689]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.689]             }
[10:21:26.689]             else {
[10:21:26.689]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.689]             }
[10:21:26.689]             {
[10:21:26.689]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.689]                   0L) {
[10:21:26.689]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.689]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.689]                   base::options(opts)
[10:21:26.689]                 }
[10:21:26.689]                 {
[10:21:26.689]                   {
[10:21:26.689]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:26.689]                     NULL
[10:21:26.689]                   }
[10:21:26.689]                   options(future.plan = NULL)
[10:21:26.689]                   if (is.na(NA_character_)) 
[10:21:26.689]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.689]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.689]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.689]                     .init = FALSE)
[10:21:26.689]                 }
[10:21:26.689]             }
[10:21:26.689]         }
[10:21:26.689]     })
[10:21:26.689]     if (TRUE) {
[10:21:26.689]         base::sink(type = "output", split = FALSE)
[10:21:26.689]         if (TRUE) {
[10:21:26.689]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.689]         }
[10:21:26.689]         else {
[10:21:26.689]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.689]         }
[10:21:26.689]         base::close(...future.stdout)
[10:21:26.689]         ...future.stdout <- NULL
[10:21:26.689]     }
[10:21:26.689]     ...future.result$conditions <- ...future.conditions
[10:21:26.689]     ...future.result$finished <- base::Sys.time()
[10:21:26.689]     ...future.result
[10:21:26.689] }
[10:21:26.691] requestCore(): workers = 2
[10:21:26.693] MulticoreFuture started
[10:21:26.693] - Launch lazy future ... done
[10:21:26.693] run() for ‘MulticoreFuture’ ... done
[10:21:26.694] result() for MulticoreFuture ...
[10:21:26.694] plan(): Setting new future strategy stack:
[10:21:26.695] List of future strategies:
[10:21:26.695] 1. sequential:
[10:21:26.695]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.695]    - tweaked: FALSE
[10:21:26.695]    - call: NULL
[10:21:26.696] plan(): nbrOfWorkers() = 1
[10:21:26.703] plan(): Setting new future strategy stack:
[10:21:26.703] List of future strategies:
[10:21:26.703] 1. multicore:
[10:21:26.703]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:26.703]    - tweaked: FALSE
[10:21:26.703]    - call: plan(strategy)
[10:21:26.707] plan(): nbrOfWorkers() = 2
[10:21:26.709] result() for MulticoreFuture ...
[10:21:26.709] result() for MulticoreFuture ... done
[10:21:26.709] result() for MulticoreFuture ... done
[10:21:26.709] result() for MulticoreFuture ...
[10:21:26.709] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[10:21:26.715] getGlobalsAndPackages() ...
[10:21:26.715] Searching for globals...
[10:21:26.718] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[10:21:26.718] Searching for globals ... DONE
[10:21:26.718] Resolving globals: FALSE
[10:21:26.719] 
[10:21:26.719] - packages: [2] ‘stats’, ‘datasets’
[10:21:26.719] getGlobalsAndPackages() ... DONE
[10:21:26.719] run() for ‘Future’ ...
[10:21:26.719] - state: ‘created’
[10:21:26.720] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:26.722] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:26.722] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:26.722]   - Field: ‘label’
[10:21:26.722]   - Field: ‘local’
[10:21:26.722]   - Field: ‘owner’
[10:21:26.722]   - Field: ‘envir’
[10:21:26.722]   - Field: ‘workers’
[10:21:26.722]   - Field: ‘packages’
[10:21:26.723]   - Field: ‘gc’
[10:21:26.723]   - Field: ‘job’
[10:21:26.723]   - Field: ‘conditions’
[10:21:26.723]   - Field: ‘expr’
[10:21:26.723]   - Field: ‘uuid’
[10:21:26.723]   - Field: ‘seed’
[10:21:26.723]   - Field: ‘version’
[10:21:26.723]   - Field: ‘result’
[10:21:26.723]   - Field: ‘asynchronous’
[10:21:26.723]   - Field: ‘calls’
[10:21:26.724]   - Field: ‘globals’
[10:21:26.724]   - Field: ‘stdout’
[10:21:26.724]   - Field: ‘earlySignal’
[10:21:26.724]   - Field: ‘lazy’
[10:21:26.724]   - Field: ‘state’
[10:21:26.724] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:26.724] - Launch lazy future ...
[10:21:26.725] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:21:26.725] Packages needed by future strategies (n = 0): <none>
[10:21:26.725] {
[10:21:26.725]     {
[10:21:26.725]         {
[10:21:26.725]             ...future.startTime <- base::Sys.time()
[10:21:26.725]             {
[10:21:26.725]                 {
[10:21:26.725]                   {
[10:21:26.725]                     {
[10:21:26.725]                       {
[10:21:26.725]                         base::local({
[10:21:26.725]                           has_future <- base::requireNamespace("future", 
[10:21:26.725]                             quietly = TRUE)
[10:21:26.725]                           if (has_future) {
[10:21:26.725]                             ns <- base::getNamespace("future")
[10:21:26.725]                             version <- ns[[".package"]][["version"]]
[10:21:26.725]                             if (is.null(version)) 
[10:21:26.725]                               version <- utils::packageVersion("future")
[10:21:26.725]                           }
[10:21:26.725]                           else {
[10:21:26.725]                             version <- NULL
[10:21:26.725]                           }
[10:21:26.725]                           if (!has_future || version < "1.8.0") {
[10:21:26.725]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.725]                               "", base::R.version$version.string), 
[10:21:26.725]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:26.725]                                 base::R.version$platform, 8 * 
[10:21:26.725]                                   base::.Machine$sizeof.pointer), 
[10:21:26.725]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.725]                                 "release", "version")], collapse = " "), 
[10:21:26.725]                               hostname = base::Sys.info()[["nodename"]])
[10:21:26.725]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.725]                               info)
[10:21:26.725]                             info <- base::paste(info, collapse = "; ")
[10:21:26.725]                             if (!has_future) {
[10:21:26.725]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.725]                                 info)
[10:21:26.725]                             }
[10:21:26.725]                             else {
[10:21:26.725]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.725]                                 info, version)
[10:21:26.725]                             }
[10:21:26.725]                             base::stop(msg)
[10:21:26.725]                           }
[10:21:26.725]                         })
[10:21:26.725]                       }
[10:21:26.725]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:26.725]                       base::options(mc.cores = 1L)
[10:21:26.725]                     }
[10:21:26.725]                     base::local({
[10:21:26.725]                       for (pkg in c("stats", "datasets")) {
[10:21:26.725]                         base::loadNamespace(pkg)
[10:21:26.725]                         base::library(pkg, character.only = TRUE)
[10:21:26.725]                       }
[10:21:26.725]                     })
[10:21:26.725]                   }
[10:21:26.725]                   ...future.strategy.old <- future::plan("list")
[10:21:26.725]                   options(future.plan = NULL)
[10:21:26.725]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.725]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.725]                 }
[10:21:26.725]                 ...future.workdir <- getwd()
[10:21:26.725]             }
[10:21:26.725]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.725]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.725]         }
[10:21:26.725]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.725]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.725]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.725]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.725]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.725]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.725]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.725]             base::names(...future.oldOptions))
[10:21:26.725]     }
[10:21:26.725]     if (FALSE) {
[10:21:26.725]     }
[10:21:26.725]     else {
[10:21:26.725]         if (TRUE) {
[10:21:26.725]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.725]                 open = "w")
[10:21:26.725]         }
[10:21:26.725]         else {
[10:21:26.725]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.725]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.725]         }
[10:21:26.725]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.725]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.725]             base::sink(type = "output", split = FALSE)
[10:21:26.725]             base::close(...future.stdout)
[10:21:26.725]         }, add = TRUE)
[10:21:26.725]     }
[10:21:26.725]     ...future.frame <- base::sys.nframe()
[10:21:26.725]     ...future.conditions <- base::list()
[10:21:26.725]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.725]     if (FALSE) {
[10:21:26.725]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.725]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.725]     }
[10:21:26.725]     ...future.result <- base::tryCatch({
[10:21:26.725]         base::withCallingHandlers({
[10:21:26.725]             ...future.value <- base::withVisible(base::local({
[10:21:26.725]                 withCallingHandlers({
[10:21:26.725]                   {
[10:21:26.725]                     lm(dist ~ . + 0, data = cars)
[10:21:26.725]                   }
[10:21:26.725]                 }, immediateCondition = function(cond) {
[10:21:26.725]                   save_rds <- function (object, pathname, ...) 
[10:21:26.725]                   {
[10:21:26.725]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:26.725]                     if (file_test("-f", pathname_tmp)) {
[10:21:26.725]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.725]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:26.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.725]                         fi_tmp[["mtime"]])
[10:21:26.725]                     }
[10:21:26.725]                     tryCatch({
[10:21:26.725]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:26.725]                     }, error = function(ex) {
[10:21:26.725]                       msg <- conditionMessage(ex)
[10:21:26.725]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.725]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:26.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.725]                         fi_tmp[["mtime"]], msg)
[10:21:26.725]                       ex$message <- msg
[10:21:26.725]                       stop(ex)
[10:21:26.725]                     })
[10:21:26.725]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:26.725]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:26.725]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:26.725]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.725]                       fi <- file.info(pathname)
[10:21:26.725]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:26.725]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.725]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:26.725]                         fi[["size"]], fi[["mtime"]])
[10:21:26.725]                       stop(msg)
[10:21:26.725]                     }
[10:21:26.725]                     invisible(pathname)
[10:21:26.725]                   }
[10:21:26.725]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:26.725]                     rootPath = tempdir()) 
[10:21:26.725]                   {
[10:21:26.725]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:26.725]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:26.725]                       tmpdir = path, fileext = ".rds")
[10:21:26.725]                     save_rds(obj, file)
[10:21:26.725]                   }
[10:21:26.725]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0RHvXY/.future/immediateConditions")
[10:21:26.725]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.725]                   {
[10:21:26.725]                     inherits <- base::inherits
[10:21:26.725]                     invokeRestart <- base::invokeRestart
[10:21:26.725]                     is.null <- base::is.null
[10:21:26.725]                     muffled <- FALSE
[10:21:26.725]                     if (inherits(cond, "message")) {
[10:21:26.725]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:26.725]                       if (muffled) 
[10:21:26.725]                         invokeRestart("muffleMessage")
[10:21:26.725]                     }
[10:21:26.725]                     else if (inherits(cond, "warning")) {
[10:21:26.725]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:26.725]                       if (muffled) 
[10:21:26.725]                         invokeRestart("muffleWarning")
[10:21:26.725]                     }
[10:21:26.725]                     else if (inherits(cond, "condition")) {
[10:21:26.725]                       if (!is.null(pattern)) {
[10:21:26.725]                         computeRestarts <- base::computeRestarts
[10:21:26.725]                         grepl <- base::grepl
[10:21:26.725]                         restarts <- computeRestarts(cond)
[10:21:26.725]                         for (restart in restarts) {
[10:21:26.725]                           name <- restart$name
[10:21:26.725]                           if (is.null(name)) 
[10:21:26.725]                             next
[10:21:26.725]                           if (!grepl(pattern, name)) 
[10:21:26.725]                             next
[10:21:26.725]                           invokeRestart(restart)
[10:21:26.725]                           muffled <- TRUE
[10:21:26.725]                           break
[10:21:26.725]                         }
[10:21:26.725]                       }
[10:21:26.725]                     }
[10:21:26.725]                     invisible(muffled)
[10:21:26.725]                   }
[10:21:26.725]                   muffleCondition(cond)
[10:21:26.725]                 })
[10:21:26.725]             }))
[10:21:26.725]             future::FutureResult(value = ...future.value$value, 
[10:21:26.725]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.725]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.725]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.725]                     ...future.globalenv.names))
[10:21:26.725]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.725]         }, condition = base::local({
[10:21:26.725]             c <- base::c
[10:21:26.725]             inherits <- base::inherits
[10:21:26.725]             invokeRestart <- base::invokeRestart
[10:21:26.725]             length <- base::length
[10:21:26.725]             list <- base::list
[10:21:26.725]             seq.int <- base::seq.int
[10:21:26.725]             signalCondition <- base::signalCondition
[10:21:26.725]             sys.calls <- base::sys.calls
[10:21:26.725]             `[[` <- base::`[[`
[10:21:26.725]             `+` <- base::`+`
[10:21:26.725]             `<<-` <- base::`<<-`
[10:21:26.725]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.725]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.725]                   3L)]
[10:21:26.725]             }
[10:21:26.725]             function(cond) {
[10:21:26.725]                 is_error <- inherits(cond, "error")
[10:21:26.725]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.725]                   NULL)
[10:21:26.725]                 if (is_error) {
[10:21:26.725]                   sessionInformation <- function() {
[10:21:26.725]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.725]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.725]                       search = base::search(), system = base::Sys.info())
[10:21:26.725]                   }
[10:21:26.725]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.725]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.725]                     cond$call), session = sessionInformation(), 
[10:21:26.725]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.725]                   signalCondition(cond)
[10:21:26.725]                 }
[10:21:26.725]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.725]                 "immediateCondition"))) {
[10:21:26.725]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.725]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.725]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.725]                   if (TRUE && !signal) {
[10:21:26.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.725]                     {
[10:21:26.725]                       inherits <- base::inherits
[10:21:26.725]                       invokeRestart <- base::invokeRestart
[10:21:26.725]                       is.null <- base::is.null
[10:21:26.725]                       muffled <- FALSE
[10:21:26.725]                       if (inherits(cond, "message")) {
[10:21:26.725]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.725]                         if (muffled) 
[10:21:26.725]                           invokeRestart("muffleMessage")
[10:21:26.725]                       }
[10:21:26.725]                       else if (inherits(cond, "warning")) {
[10:21:26.725]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.725]                         if (muffled) 
[10:21:26.725]                           invokeRestart("muffleWarning")
[10:21:26.725]                       }
[10:21:26.725]                       else if (inherits(cond, "condition")) {
[10:21:26.725]                         if (!is.null(pattern)) {
[10:21:26.725]                           computeRestarts <- base::computeRestarts
[10:21:26.725]                           grepl <- base::grepl
[10:21:26.725]                           restarts <- computeRestarts(cond)
[10:21:26.725]                           for (restart in restarts) {
[10:21:26.725]                             name <- restart$name
[10:21:26.725]                             if (is.null(name)) 
[10:21:26.725]                               next
[10:21:26.725]                             if (!grepl(pattern, name)) 
[10:21:26.725]                               next
[10:21:26.725]                             invokeRestart(restart)
[10:21:26.725]                             muffled <- TRUE
[10:21:26.725]                             break
[10:21:26.725]                           }
[10:21:26.725]                         }
[10:21:26.725]                       }
[10:21:26.725]                       invisible(muffled)
[10:21:26.725]                     }
[10:21:26.725]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.725]                   }
[10:21:26.725]                 }
[10:21:26.725]                 else {
[10:21:26.725]                   if (TRUE) {
[10:21:26.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.725]                     {
[10:21:26.725]                       inherits <- base::inherits
[10:21:26.725]                       invokeRestart <- base::invokeRestart
[10:21:26.725]                       is.null <- base::is.null
[10:21:26.725]                       muffled <- FALSE
[10:21:26.725]                       if (inherits(cond, "message")) {
[10:21:26.725]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.725]                         if (muffled) 
[10:21:26.725]                           invokeRestart("muffleMessage")
[10:21:26.725]                       }
[10:21:26.725]                       else if (inherits(cond, "warning")) {
[10:21:26.725]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.725]                         if (muffled) 
[10:21:26.725]                           invokeRestart("muffleWarning")
[10:21:26.725]                       }
[10:21:26.725]                       else if (inherits(cond, "condition")) {
[10:21:26.725]                         if (!is.null(pattern)) {
[10:21:26.725]                           computeRestarts <- base::computeRestarts
[10:21:26.725]                           grepl <- base::grepl
[10:21:26.725]                           restarts <- computeRestarts(cond)
[10:21:26.725]                           for (restart in restarts) {
[10:21:26.725]                             name <- restart$name
[10:21:26.725]                             if (is.null(name)) 
[10:21:26.725]                               next
[10:21:26.725]                             if (!grepl(pattern, name)) 
[10:21:26.725]                               next
[10:21:26.725]                             invokeRestart(restart)
[10:21:26.725]                             muffled <- TRUE
[10:21:26.725]                             break
[10:21:26.725]                           }
[10:21:26.725]                         }
[10:21:26.725]                       }
[10:21:26.725]                       invisible(muffled)
[10:21:26.725]                     }
[10:21:26.725]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.725]                   }
[10:21:26.725]                 }
[10:21:26.725]             }
[10:21:26.725]         }))
[10:21:26.725]     }, error = function(ex) {
[10:21:26.725]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.725]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.725]                 ...future.rng), started = ...future.startTime, 
[10:21:26.725]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.725]             version = "1.8"), class = "FutureResult")
[10:21:26.725]     }, finally = {
[10:21:26.725]         if (!identical(...future.workdir, getwd())) 
[10:21:26.725]             setwd(...future.workdir)
[10:21:26.725]         {
[10:21:26.725]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.725]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.725]             }
[10:21:26.725]             base::options(...future.oldOptions)
[10:21:26.725]             if (.Platform$OS.type == "windows") {
[10:21:26.725]                 old_names <- names(...future.oldEnvVars)
[10:21:26.725]                 envs <- base::Sys.getenv()
[10:21:26.725]                 names <- names(envs)
[10:21:26.725]                 common <- intersect(names, old_names)
[10:21:26.725]                 added <- setdiff(names, old_names)
[10:21:26.725]                 removed <- setdiff(old_names, names)
[10:21:26.725]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.725]                   envs[common]]
[10:21:26.725]                 NAMES <- toupper(changed)
[10:21:26.725]                 args <- list()
[10:21:26.725]                 for (kk in seq_along(NAMES)) {
[10:21:26.725]                   name <- changed[[kk]]
[10:21:26.725]                   NAME <- NAMES[[kk]]
[10:21:26.725]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.725]                     next
[10:21:26.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.725]                 }
[10:21:26.725]                 NAMES <- toupper(added)
[10:21:26.725]                 for (kk in seq_along(NAMES)) {
[10:21:26.725]                   name <- added[[kk]]
[10:21:26.725]                   NAME <- NAMES[[kk]]
[10:21:26.725]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.725]                     next
[10:21:26.725]                   args[[name]] <- ""
[10:21:26.725]                 }
[10:21:26.725]                 NAMES <- toupper(removed)
[10:21:26.725]                 for (kk in seq_along(NAMES)) {
[10:21:26.725]                   name <- removed[[kk]]
[10:21:26.725]                   NAME <- NAMES[[kk]]
[10:21:26.725]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.725]                     next
[10:21:26.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.725]                 }
[10:21:26.725]                 if (length(args) > 0) 
[10:21:26.725]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.725]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.725]             }
[10:21:26.725]             else {
[10:21:26.725]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.725]             }
[10:21:26.725]             {
[10:21:26.725]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.725]                   0L) {
[10:21:26.725]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.725]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.725]                   base::options(opts)
[10:21:26.725]                 }
[10:21:26.725]                 {
[10:21:26.725]                   {
[10:21:26.725]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:26.725]                     NULL
[10:21:26.725]                   }
[10:21:26.725]                   options(future.plan = NULL)
[10:21:26.725]                   if (is.na(NA_character_)) 
[10:21:26.725]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.725]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.725]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.725]                     .init = FALSE)
[10:21:26.725]                 }
[10:21:26.725]             }
[10:21:26.725]         }
[10:21:26.725]     })
[10:21:26.725]     if (TRUE) {
[10:21:26.725]         base::sink(type = "output", split = FALSE)
[10:21:26.725]         if (TRUE) {
[10:21:26.725]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.725]         }
[10:21:26.725]         else {
[10:21:26.725]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.725]         }
[10:21:26.725]         base::close(...future.stdout)
[10:21:26.725]         ...future.stdout <- NULL
[10:21:26.725]     }
[10:21:26.725]     ...future.result$conditions <- ...future.conditions
[10:21:26.725]     ...future.result$finished <- base::Sys.time()
[10:21:26.725]     ...future.result
[10:21:26.725] }
[10:21:26.728] requestCore(): workers = 2
[10:21:26.730] MulticoreFuture started
[10:21:26.730] - Launch lazy future ... done
[10:21:26.730] run() for ‘MulticoreFuture’ ... done
[10:21:26.730] result() for MulticoreFuture ...
[10:21:26.731] plan(): Setting new future strategy stack:
[10:21:26.731] List of future strategies:
[10:21:26.731] 1. sequential:
[10:21:26.731]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.731]    - tweaked: FALSE
[10:21:26.731]    - call: NULL
[10:21:26.732] plan(): nbrOfWorkers() = 1
[10:21:26.735] plan(): Setting new future strategy stack:
[10:21:26.736] List of future strategies:
[10:21:26.736] 1. multicore:
[10:21:26.736]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:26.736]    - tweaked: FALSE
[10:21:26.736]    - call: plan(strategy)
[10:21:26.739] plan(): nbrOfWorkers() = 2
[10:21:26.741] result() for MulticoreFuture ...
[10:21:26.741] result() for MulticoreFuture ... done
[10:21:26.741] result() for MulticoreFuture ... done
[10:21:26.741] result() for MulticoreFuture ...
[10:21:26.741] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[10:21:26.744] getGlobalsAndPackages() ...
[10:21:26.745] Searching for globals...
[10:21:26.747] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[10:21:26.747] Searching for globals ... DONE
[10:21:26.747] Resolving globals: FALSE
[10:21:26.748] 
[10:21:26.748] - packages: [2] ‘stats’, ‘datasets’
[10:21:26.748] getGlobalsAndPackages() ... DONE
[10:21:26.749] run() for ‘Future’ ...
[10:21:26.783] - state: ‘created’
[10:21:26.783] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:26.785] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:26.785] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:26.785]   - Field: ‘label’
[10:21:26.786]   - Field: ‘local’
[10:21:26.786]   - Field: ‘owner’
[10:21:26.786]   - Field: ‘envir’
[10:21:26.786]   - Field: ‘workers’
[10:21:26.786]   - Field: ‘packages’
[10:21:26.786]   - Field: ‘gc’
[10:21:26.786]   - Field: ‘job’
[10:21:26.786]   - Field: ‘conditions’
[10:21:26.786]   - Field: ‘expr’
[10:21:26.786]   - Field: ‘uuid’
[10:21:26.787]   - Field: ‘seed’
[10:21:26.787]   - Field: ‘version’
[10:21:26.787]   - Field: ‘result’
[10:21:26.787]   - Field: ‘asynchronous’
[10:21:26.787]   - Field: ‘calls’
[10:21:26.787]   - Field: ‘globals’
[10:21:26.787]   - Field: ‘stdout’
[10:21:26.787]   - Field: ‘earlySignal’
[10:21:26.787]   - Field: ‘lazy’
[10:21:26.787]   - Field: ‘state’
[10:21:26.787] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:26.788] - Launch lazy future ...
[10:21:26.788] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:21:26.788] Packages needed by future strategies (n = 0): <none>
[10:21:26.788] {
[10:21:26.788]     {
[10:21:26.788]         {
[10:21:26.788]             ...future.startTime <- base::Sys.time()
[10:21:26.788]             {
[10:21:26.788]                 {
[10:21:26.788]                   {
[10:21:26.788]                     {
[10:21:26.788]                       {
[10:21:26.788]                         base::local({
[10:21:26.788]                           has_future <- base::requireNamespace("future", 
[10:21:26.788]                             quietly = TRUE)
[10:21:26.788]                           if (has_future) {
[10:21:26.788]                             ns <- base::getNamespace("future")
[10:21:26.788]                             version <- ns[[".package"]][["version"]]
[10:21:26.788]                             if (is.null(version)) 
[10:21:26.788]                               version <- utils::packageVersion("future")
[10:21:26.788]                           }
[10:21:26.788]                           else {
[10:21:26.788]                             version <- NULL
[10:21:26.788]                           }
[10:21:26.788]                           if (!has_future || version < "1.8.0") {
[10:21:26.788]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.788]                               "", base::R.version$version.string), 
[10:21:26.788]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:26.788]                                 base::R.version$platform, 8 * 
[10:21:26.788]                                   base::.Machine$sizeof.pointer), 
[10:21:26.788]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.788]                                 "release", "version")], collapse = " "), 
[10:21:26.788]                               hostname = base::Sys.info()[["nodename"]])
[10:21:26.788]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.788]                               info)
[10:21:26.788]                             info <- base::paste(info, collapse = "; ")
[10:21:26.788]                             if (!has_future) {
[10:21:26.788]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.788]                                 info)
[10:21:26.788]                             }
[10:21:26.788]                             else {
[10:21:26.788]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.788]                                 info, version)
[10:21:26.788]                             }
[10:21:26.788]                             base::stop(msg)
[10:21:26.788]                           }
[10:21:26.788]                         })
[10:21:26.788]                       }
[10:21:26.788]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:26.788]                       base::options(mc.cores = 1L)
[10:21:26.788]                     }
[10:21:26.788]                     base::local({
[10:21:26.788]                       for (pkg in c("stats", "datasets")) {
[10:21:26.788]                         base::loadNamespace(pkg)
[10:21:26.788]                         base::library(pkg, character.only = TRUE)
[10:21:26.788]                       }
[10:21:26.788]                     })
[10:21:26.788]                   }
[10:21:26.788]                   ...future.strategy.old <- future::plan("list")
[10:21:26.788]                   options(future.plan = NULL)
[10:21:26.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.788]                 }
[10:21:26.788]                 ...future.workdir <- getwd()
[10:21:26.788]             }
[10:21:26.788]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.788]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.788]         }
[10:21:26.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.788]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.788]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.788]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.788]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.788]             base::names(...future.oldOptions))
[10:21:26.788]     }
[10:21:26.788]     if (FALSE) {
[10:21:26.788]     }
[10:21:26.788]     else {
[10:21:26.788]         if (TRUE) {
[10:21:26.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.788]                 open = "w")
[10:21:26.788]         }
[10:21:26.788]         else {
[10:21:26.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.788]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.788]         }
[10:21:26.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.788]             base::sink(type = "output", split = FALSE)
[10:21:26.788]             base::close(...future.stdout)
[10:21:26.788]         }, add = TRUE)
[10:21:26.788]     }
[10:21:26.788]     ...future.frame <- base::sys.nframe()
[10:21:26.788]     ...future.conditions <- base::list()
[10:21:26.788]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.788]     if (FALSE) {
[10:21:26.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.788]     }
[10:21:26.788]     ...future.result <- base::tryCatch({
[10:21:26.788]         base::withCallingHandlers({
[10:21:26.788]             ...future.value <- base::withVisible(base::local({
[10:21:26.788]                 withCallingHandlers({
[10:21:26.788]                   {
[10:21:26.788]                     lm(dist ~ speed + speed^2, data = cars)
[10:21:26.788]                   }
[10:21:26.788]                 }, immediateCondition = function(cond) {
[10:21:26.788]                   save_rds <- function (object, pathname, ...) 
[10:21:26.788]                   {
[10:21:26.788]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:26.788]                     if (file_test("-f", pathname_tmp)) {
[10:21:26.788]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.788]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:26.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.788]                         fi_tmp[["mtime"]])
[10:21:26.788]                     }
[10:21:26.788]                     tryCatch({
[10:21:26.788]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:26.788]                     }, error = function(ex) {
[10:21:26.788]                       msg <- conditionMessage(ex)
[10:21:26.788]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.788]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:26.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.788]                         fi_tmp[["mtime"]], msg)
[10:21:26.788]                       ex$message <- msg
[10:21:26.788]                       stop(ex)
[10:21:26.788]                     })
[10:21:26.788]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:26.788]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:26.788]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:26.788]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.788]                       fi <- file.info(pathname)
[10:21:26.788]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:26.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.788]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:26.788]                         fi[["size"]], fi[["mtime"]])
[10:21:26.788]                       stop(msg)
[10:21:26.788]                     }
[10:21:26.788]                     invisible(pathname)
[10:21:26.788]                   }
[10:21:26.788]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:26.788]                     rootPath = tempdir()) 
[10:21:26.788]                   {
[10:21:26.788]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:26.788]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:26.788]                       tmpdir = path, fileext = ".rds")
[10:21:26.788]                     save_rds(obj, file)
[10:21:26.788]                   }
[10:21:26.788]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0RHvXY/.future/immediateConditions")
[10:21:26.788]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.788]                   {
[10:21:26.788]                     inherits <- base::inherits
[10:21:26.788]                     invokeRestart <- base::invokeRestart
[10:21:26.788]                     is.null <- base::is.null
[10:21:26.788]                     muffled <- FALSE
[10:21:26.788]                     if (inherits(cond, "message")) {
[10:21:26.788]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:26.788]                       if (muffled) 
[10:21:26.788]                         invokeRestart("muffleMessage")
[10:21:26.788]                     }
[10:21:26.788]                     else if (inherits(cond, "warning")) {
[10:21:26.788]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:26.788]                       if (muffled) 
[10:21:26.788]                         invokeRestart("muffleWarning")
[10:21:26.788]                     }
[10:21:26.788]                     else if (inherits(cond, "condition")) {
[10:21:26.788]                       if (!is.null(pattern)) {
[10:21:26.788]                         computeRestarts <- base::computeRestarts
[10:21:26.788]                         grepl <- base::grepl
[10:21:26.788]                         restarts <- computeRestarts(cond)
[10:21:26.788]                         for (restart in restarts) {
[10:21:26.788]                           name <- restart$name
[10:21:26.788]                           if (is.null(name)) 
[10:21:26.788]                             next
[10:21:26.788]                           if (!grepl(pattern, name)) 
[10:21:26.788]                             next
[10:21:26.788]                           invokeRestart(restart)
[10:21:26.788]                           muffled <- TRUE
[10:21:26.788]                           break
[10:21:26.788]                         }
[10:21:26.788]                       }
[10:21:26.788]                     }
[10:21:26.788]                     invisible(muffled)
[10:21:26.788]                   }
[10:21:26.788]                   muffleCondition(cond)
[10:21:26.788]                 })
[10:21:26.788]             }))
[10:21:26.788]             future::FutureResult(value = ...future.value$value, 
[10:21:26.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.788]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.788]                     ...future.globalenv.names))
[10:21:26.788]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.788]         }, condition = base::local({
[10:21:26.788]             c <- base::c
[10:21:26.788]             inherits <- base::inherits
[10:21:26.788]             invokeRestart <- base::invokeRestart
[10:21:26.788]             length <- base::length
[10:21:26.788]             list <- base::list
[10:21:26.788]             seq.int <- base::seq.int
[10:21:26.788]             signalCondition <- base::signalCondition
[10:21:26.788]             sys.calls <- base::sys.calls
[10:21:26.788]             `[[` <- base::`[[`
[10:21:26.788]             `+` <- base::`+`
[10:21:26.788]             `<<-` <- base::`<<-`
[10:21:26.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.788]                   3L)]
[10:21:26.788]             }
[10:21:26.788]             function(cond) {
[10:21:26.788]                 is_error <- inherits(cond, "error")
[10:21:26.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.788]                   NULL)
[10:21:26.788]                 if (is_error) {
[10:21:26.788]                   sessionInformation <- function() {
[10:21:26.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.788]                       search = base::search(), system = base::Sys.info())
[10:21:26.788]                   }
[10:21:26.788]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.788]                     cond$call), session = sessionInformation(), 
[10:21:26.788]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.788]                   signalCondition(cond)
[10:21:26.788]                 }
[10:21:26.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.788]                 "immediateCondition"))) {
[10:21:26.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.788]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.788]                   if (TRUE && !signal) {
[10:21:26.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.788]                     {
[10:21:26.788]                       inherits <- base::inherits
[10:21:26.788]                       invokeRestart <- base::invokeRestart
[10:21:26.788]                       is.null <- base::is.null
[10:21:26.788]                       muffled <- FALSE
[10:21:26.788]                       if (inherits(cond, "message")) {
[10:21:26.788]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.788]                         if (muffled) 
[10:21:26.788]                           invokeRestart("muffleMessage")
[10:21:26.788]                       }
[10:21:26.788]                       else if (inherits(cond, "warning")) {
[10:21:26.788]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.788]                         if (muffled) 
[10:21:26.788]                           invokeRestart("muffleWarning")
[10:21:26.788]                       }
[10:21:26.788]                       else if (inherits(cond, "condition")) {
[10:21:26.788]                         if (!is.null(pattern)) {
[10:21:26.788]                           computeRestarts <- base::computeRestarts
[10:21:26.788]                           grepl <- base::grepl
[10:21:26.788]                           restarts <- computeRestarts(cond)
[10:21:26.788]                           for (restart in restarts) {
[10:21:26.788]                             name <- restart$name
[10:21:26.788]                             if (is.null(name)) 
[10:21:26.788]                               next
[10:21:26.788]                             if (!grepl(pattern, name)) 
[10:21:26.788]                               next
[10:21:26.788]                             invokeRestart(restart)
[10:21:26.788]                             muffled <- TRUE
[10:21:26.788]                             break
[10:21:26.788]                           }
[10:21:26.788]                         }
[10:21:26.788]                       }
[10:21:26.788]                       invisible(muffled)
[10:21:26.788]                     }
[10:21:26.788]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.788]                   }
[10:21:26.788]                 }
[10:21:26.788]                 else {
[10:21:26.788]                   if (TRUE) {
[10:21:26.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.788]                     {
[10:21:26.788]                       inherits <- base::inherits
[10:21:26.788]                       invokeRestart <- base::invokeRestart
[10:21:26.788]                       is.null <- base::is.null
[10:21:26.788]                       muffled <- FALSE
[10:21:26.788]                       if (inherits(cond, "message")) {
[10:21:26.788]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.788]                         if (muffled) 
[10:21:26.788]                           invokeRestart("muffleMessage")
[10:21:26.788]                       }
[10:21:26.788]                       else if (inherits(cond, "warning")) {
[10:21:26.788]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.788]                         if (muffled) 
[10:21:26.788]                           invokeRestart("muffleWarning")
[10:21:26.788]                       }
[10:21:26.788]                       else if (inherits(cond, "condition")) {
[10:21:26.788]                         if (!is.null(pattern)) {
[10:21:26.788]                           computeRestarts <- base::computeRestarts
[10:21:26.788]                           grepl <- base::grepl
[10:21:26.788]                           restarts <- computeRestarts(cond)
[10:21:26.788]                           for (restart in restarts) {
[10:21:26.788]                             name <- restart$name
[10:21:26.788]                             if (is.null(name)) 
[10:21:26.788]                               next
[10:21:26.788]                             if (!grepl(pattern, name)) 
[10:21:26.788]                               next
[10:21:26.788]                             invokeRestart(restart)
[10:21:26.788]                             muffled <- TRUE
[10:21:26.788]                             break
[10:21:26.788]                           }
[10:21:26.788]                         }
[10:21:26.788]                       }
[10:21:26.788]                       invisible(muffled)
[10:21:26.788]                     }
[10:21:26.788]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.788]                   }
[10:21:26.788]                 }
[10:21:26.788]             }
[10:21:26.788]         }))
[10:21:26.788]     }, error = function(ex) {
[10:21:26.788]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.788]                 ...future.rng), started = ...future.startTime, 
[10:21:26.788]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.788]             version = "1.8"), class = "FutureResult")
[10:21:26.788]     }, finally = {
[10:21:26.788]         if (!identical(...future.workdir, getwd())) 
[10:21:26.788]             setwd(...future.workdir)
[10:21:26.788]         {
[10:21:26.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.788]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.788]             }
[10:21:26.788]             base::options(...future.oldOptions)
[10:21:26.788]             if (.Platform$OS.type == "windows") {
[10:21:26.788]                 old_names <- names(...future.oldEnvVars)
[10:21:26.788]                 envs <- base::Sys.getenv()
[10:21:26.788]                 names <- names(envs)
[10:21:26.788]                 common <- intersect(names, old_names)
[10:21:26.788]                 added <- setdiff(names, old_names)
[10:21:26.788]                 removed <- setdiff(old_names, names)
[10:21:26.788]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.788]                   envs[common]]
[10:21:26.788]                 NAMES <- toupper(changed)
[10:21:26.788]                 args <- list()
[10:21:26.788]                 for (kk in seq_along(NAMES)) {
[10:21:26.788]                   name <- changed[[kk]]
[10:21:26.788]                   NAME <- NAMES[[kk]]
[10:21:26.788]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.788]                     next
[10:21:26.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.788]                 }
[10:21:26.788]                 NAMES <- toupper(added)
[10:21:26.788]                 for (kk in seq_along(NAMES)) {
[10:21:26.788]                   name <- added[[kk]]
[10:21:26.788]                   NAME <- NAMES[[kk]]
[10:21:26.788]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.788]                     next
[10:21:26.788]                   args[[name]] <- ""
[10:21:26.788]                 }
[10:21:26.788]                 NAMES <- toupper(removed)
[10:21:26.788]                 for (kk in seq_along(NAMES)) {
[10:21:26.788]                   name <- removed[[kk]]
[10:21:26.788]                   NAME <- NAMES[[kk]]
[10:21:26.788]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.788]                     next
[10:21:26.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.788]                 }
[10:21:26.788]                 if (length(args) > 0) 
[10:21:26.788]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.788]             }
[10:21:26.788]             else {
[10:21:26.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.788]             }
[10:21:26.788]             {
[10:21:26.788]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.788]                   0L) {
[10:21:26.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.788]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.788]                   base::options(opts)
[10:21:26.788]                 }
[10:21:26.788]                 {
[10:21:26.788]                   {
[10:21:26.788]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:26.788]                     NULL
[10:21:26.788]                   }
[10:21:26.788]                   options(future.plan = NULL)
[10:21:26.788]                   if (is.na(NA_character_)) 
[10:21:26.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.788]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.788]                     .init = FALSE)
[10:21:26.788]                 }
[10:21:26.788]             }
[10:21:26.788]         }
[10:21:26.788]     })
[10:21:26.788]     if (TRUE) {
[10:21:26.788]         base::sink(type = "output", split = FALSE)
[10:21:26.788]         if (TRUE) {
[10:21:26.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.788]         }
[10:21:26.788]         else {
[10:21:26.788]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.788]         }
[10:21:26.788]         base::close(...future.stdout)
[10:21:26.788]         ...future.stdout <- NULL
[10:21:26.788]     }
[10:21:26.788]     ...future.result$conditions <- ...future.conditions
[10:21:26.788]     ...future.result$finished <- base::Sys.time()
[10:21:26.788]     ...future.result
[10:21:26.788] }
[10:21:26.791] requestCore(): workers = 2
[10:21:26.793] MulticoreFuture started
[10:21:26.793] - Launch lazy future ... done
[10:21:26.794] run() for ‘MulticoreFuture’ ... done
[10:21:26.794] result() for MulticoreFuture ...
[10:21:26.794] plan(): Setting new future strategy stack:
[10:21:26.795] List of future strategies:
[10:21:26.795] 1. sequential:
[10:21:26.795]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.795]    - tweaked: FALSE
[10:21:26.795]    - call: NULL
[10:21:26.796] plan(): nbrOfWorkers() = 1
[10:21:26.800] plan(): Setting new future strategy stack:
[10:21:26.800] List of future strategies:
[10:21:26.800] 1. multicore:
[10:21:26.800]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:26.800]    - tweaked: FALSE
[10:21:26.800]    - call: plan(strategy)
[10:21:26.803] plan(): nbrOfWorkers() = 2
[10:21:26.805] result() for MulticoreFuture ...
[10:21:26.806] result() for MulticoreFuture ... done
[10:21:26.806] result() for MulticoreFuture ... done
[10:21:26.806] result() for MulticoreFuture ...
[10:21:26.806] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[10:21:26.810] getGlobalsAndPackages() ...
[10:21:26.810] Searching for globals...
[10:21:26.813] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[10:21:26.813] Searching for globals ... DONE
[10:21:26.813] Resolving globals: FALSE
[10:21:26.814] 
[10:21:26.814] - packages: [2] ‘stats’, ‘datasets’
[10:21:26.814] getGlobalsAndPackages() ... DONE
[10:21:26.814] run() for ‘Future’ ...
[10:21:26.815] - state: ‘created’
[10:21:26.815] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:26.817] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:26.817] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:26.817]   - Field: ‘label’
[10:21:26.817]   - Field: ‘local’
[10:21:26.817]   - Field: ‘owner’
[10:21:26.817]   - Field: ‘envir’
[10:21:26.818]   - Field: ‘workers’
[10:21:26.818]   - Field: ‘packages’
[10:21:26.818]   - Field: ‘gc’
[10:21:26.818]   - Field: ‘job’
[10:21:26.818]   - Field: ‘conditions’
[10:21:26.818]   - Field: ‘expr’
[10:21:26.818]   - Field: ‘uuid’
[10:21:26.818]   - Field: ‘seed’
[10:21:26.818]   - Field: ‘version’
[10:21:26.819]   - Field: ‘result’
[10:21:26.819]   - Field: ‘asynchronous’
[10:21:26.819]   - Field: ‘calls’
[10:21:26.819]   - Field: ‘globals’
[10:21:26.819]   - Field: ‘stdout’
[10:21:26.819]   - Field: ‘earlySignal’
[10:21:26.819]   - Field: ‘lazy’
[10:21:26.819]   - Field: ‘state’
[10:21:26.819] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:26.820] - Launch lazy future ...
[10:21:26.820] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:21:26.820] Packages needed by future strategies (n = 0): <none>
[10:21:26.821] {
[10:21:26.821]     {
[10:21:26.821]         {
[10:21:26.821]             ...future.startTime <- base::Sys.time()
[10:21:26.821]             {
[10:21:26.821]                 {
[10:21:26.821]                   {
[10:21:26.821]                     {
[10:21:26.821]                       {
[10:21:26.821]                         base::local({
[10:21:26.821]                           has_future <- base::requireNamespace("future", 
[10:21:26.821]                             quietly = TRUE)
[10:21:26.821]                           if (has_future) {
[10:21:26.821]                             ns <- base::getNamespace("future")
[10:21:26.821]                             version <- ns[[".package"]][["version"]]
[10:21:26.821]                             if (is.null(version)) 
[10:21:26.821]                               version <- utils::packageVersion("future")
[10:21:26.821]                           }
[10:21:26.821]                           else {
[10:21:26.821]                             version <- NULL
[10:21:26.821]                           }
[10:21:26.821]                           if (!has_future || version < "1.8.0") {
[10:21:26.821]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.821]                               "", base::R.version$version.string), 
[10:21:26.821]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:26.821]                                 base::R.version$platform, 8 * 
[10:21:26.821]                                   base::.Machine$sizeof.pointer), 
[10:21:26.821]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.821]                                 "release", "version")], collapse = " "), 
[10:21:26.821]                               hostname = base::Sys.info()[["nodename"]])
[10:21:26.821]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.821]                               info)
[10:21:26.821]                             info <- base::paste(info, collapse = "; ")
[10:21:26.821]                             if (!has_future) {
[10:21:26.821]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.821]                                 info)
[10:21:26.821]                             }
[10:21:26.821]                             else {
[10:21:26.821]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.821]                                 info, version)
[10:21:26.821]                             }
[10:21:26.821]                             base::stop(msg)
[10:21:26.821]                           }
[10:21:26.821]                         })
[10:21:26.821]                       }
[10:21:26.821]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:26.821]                       base::options(mc.cores = 1L)
[10:21:26.821]                     }
[10:21:26.821]                     base::local({
[10:21:26.821]                       for (pkg in c("stats", "datasets")) {
[10:21:26.821]                         base::loadNamespace(pkg)
[10:21:26.821]                         base::library(pkg, character.only = TRUE)
[10:21:26.821]                       }
[10:21:26.821]                     })
[10:21:26.821]                   }
[10:21:26.821]                   ...future.strategy.old <- future::plan("list")
[10:21:26.821]                   options(future.plan = NULL)
[10:21:26.821]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.821]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.821]                 }
[10:21:26.821]                 ...future.workdir <- getwd()
[10:21:26.821]             }
[10:21:26.821]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.821]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.821]         }
[10:21:26.821]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.821]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.821]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.821]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.821]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.821]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.821]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.821]             base::names(...future.oldOptions))
[10:21:26.821]     }
[10:21:26.821]     if (FALSE) {
[10:21:26.821]     }
[10:21:26.821]     else {
[10:21:26.821]         if (TRUE) {
[10:21:26.821]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.821]                 open = "w")
[10:21:26.821]         }
[10:21:26.821]         else {
[10:21:26.821]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.821]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.821]         }
[10:21:26.821]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.821]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.821]             base::sink(type = "output", split = FALSE)
[10:21:26.821]             base::close(...future.stdout)
[10:21:26.821]         }, add = TRUE)
[10:21:26.821]     }
[10:21:26.821]     ...future.frame <- base::sys.nframe()
[10:21:26.821]     ...future.conditions <- base::list()
[10:21:26.821]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.821]     if (FALSE) {
[10:21:26.821]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.821]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.821]     }
[10:21:26.821]     ...future.result <- base::tryCatch({
[10:21:26.821]         base::withCallingHandlers({
[10:21:26.821]             ...future.value <- base::withVisible(base::local({
[10:21:26.821]                 withCallingHandlers({
[10:21:26.821]                   {
[10:21:26.821]                     lm(dist ~ speed + I(speed^2), data = cars)
[10:21:26.821]                   }
[10:21:26.821]                 }, immediateCondition = function(cond) {
[10:21:26.821]                   save_rds <- function (object, pathname, ...) 
[10:21:26.821]                   {
[10:21:26.821]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:26.821]                     if (file_test("-f", pathname_tmp)) {
[10:21:26.821]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.821]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:26.821]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.821]                         fi_tmp[["mtime"]])
[10:21:26.821]                     }
[10:21:26.821]                     tryCatch({
[10:21:26.821]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:26.821]                     }, error = function(ex) {
[10:21:26.821]                       msg <- conditionMessage(ex)
[10:21:26.821]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.821]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:26.821]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.821]                         fi_tmp[["mtime"]], msg)
[10:21:26.821]                       ex$message <- msg
[10:21:26.821]                       stop(ex)
[10:21:26.821]                     })
[10:21:26.821]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:26.821]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:26.821]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:26.821]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.821]                       fi <- file.info(pathname)
[10:21:26.821]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:26.821]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.821]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:26.821]                         fi[["size"]], fi[["mtime"]])
[10:21:26.821]                       stop(msg)
[10:21:26.821]                     }
[10:21:26.821]                     invisible(pathname)
[10:21:26.821]                   }
[10:21:26.821]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:26.821]                     rootPath = tempdir()) 
[10:21:26.821]                   {
[10:21:26.821]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:26.821]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:26.821]                       tmpdir = path, fileext = ".rds")
[10:21:26.821]                     save_rds(obj, file)
[10:21:26.821]                   }
[10:21:26.821]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0RHvXY/.future/immediateConditions")
[10:21:26.821]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.821]                   {
[10:21:26.821]                     inherits <- base::inherits
[10:21:26.821]                     invokeRestart <- base::invokeRestart
[10:21:26.821]                     is.null <- base::is.null
[10:21:26.821]                     muffled <- FALSE
[10:21:26.821]                     if (inherits(cond, "message")) {
[10:21:26.821]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:26.821]                       if (muffled) 
[10:21:26.821]                         invokeRestart("muffleMessage")
[10:21:26.821]                     }
[10:21:26.821]                     else if (inherits(cond, "warning")) {
[10:21:26.821]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:26.821]                       if (muffled) 
[10:21:26.821]                         invokeRestart("muffleWarning")
[10:21:26.821]                     }
[10:21:26.821]                     else if (inherits(cond, "condition")) {
[10:21:26.821]                       if (!is.null(pattern)) {
[10:21:26.821]                         computeRestarts <- base::computeRestarts
[10:21:26.821]                         grepl <- base::grepl
[10:21:26.821]                         restarts <- computeRestarts(cond)
[10:21:26.821]                         for (restart in restarts) {
[10:21:26.821]                           name <- restart$name
[10:21:26.821]                           if (is.null(name)) 
[10:21:26.821]                             next
[10:21:26.821]                           if (!grepl(pattern, name)) 
[10:21:26.821]                             next
[10:21:26.821]                           invokeRestart(restart)
[10:21:26.821]                           muffled <- TRUE
[10:21:26.821]                           break
[10:21:26.821]                         }
[10:21:26.821]                       }
[10:21:26.821]                     }
[10:21:26.821]                     invisible(muffled)
[10:21:26.821]                   }
[10:21:26.821]                   muffleCondition(cond)
[10:21:26.821]                 })
[10:21:26.821]             }))
[10:21:26.821]             future::FutureResult(value = ...future.value$value, 
[10:21:26.821]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.821]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.821]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.821]                     ...future.globalenv.names))
[10:21:26.821]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.821]         }, condition = base::local({
[10:21:26.821]             c <- base::c
[10:21:26.821]             inherits <- base::inherits
[10:21:26.821]             invokeRestart <- base::invokeRestart
[10:21:26.821]             length <- base::length
[10:21:26.821]             list <- base::list
[10:21:26.821]             seq.int <- base::seq.int
[10:21:26.821]             signalCondition <- base::signalCondition
[10:21:26.821]             sys.calls <- base::sys.calls
[10:21:26.821]             `[[` <- base::`[[`
[10:21:26.821]             `+` <- base::`+`
[10:21:26.821]             `<<-` <- base::`<<-`
[10:21:26.821]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.821]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.821]                   3L)]
[10:21:26.821]             }
[10:21:26.821]             function(cond) {
[10:21:26.821]                 is_error <- inherits(cond, "error")
[10:21:26.821]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.821]                   NULL)
[10:21:26.821]                 if (is_error) {
[10:21:26.821]                   sessionInformation <- function() {
[10:21:26.821]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.821]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.821]                       search = base::search(), system = base::Sys.info())
[10:21:26.821]                   }
[10:21:26.821]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.821]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.821]                     cond$call), session = sessionInformation(), 
[10:21:26.821]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.821]                   signalCondition(cond)
[10:21:26.821]                 }
[10:21:26.821]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.821]                 "immediateCondition"))) {
[10:21:26.821]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.821]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.821]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.821]                   if (TRUE && !signal) {
[10:21:26.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.821]                     {
[10:21:26.821]                       inherits <- base::inherits
[10:21:26.821]                       invokeRestart <- base::invokeRestart
[10:21:26.821]                       is.null <- base::is.null
[10:21:26.821]                       muffled <- FALSE
[10:21:26.821]                       if (inherits(cond, "message")) {
[10:21:26.821]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.821]                         if (muffled) 
[10:21:26.821]                           invokeRestart("muffleMessage")
[10:21:26.821]                       }
[10:21:26.821]                       else if (inherits(cond, "warning")) {
[10:21:26.821]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.821]                         if (muffled) 
[10:21:26.821]                           invokeRestart("muffleWarning")
[10:21:26.821]                       }
[10:21:26.821]                       else if (inherits(cond, "condition")) {
[10:21:26.821]                         if (!is.null(pattern)) {
[10:21:26.821]                           computeRestarts <- base::computeRestarts
[10:21:26.821]                           grepl <- base::grepl
[10:21:26.821]                           restarts <- computeRestarts(cond)
[10:21:26.821]                           for (restart in restarts) {
[10:21:26.821]                             name <- restart$name
[10:21:26.821]                             if (is.null(name)) 
[10:21:26.821]                               next
[10:21:26.821]                             if (!grepl(pattern, name)) 
[10:21:26.821]                               next
[10:21:26.821]                             invokeRestart(restart)
[10:21:26.821]                             muffled <- TRUE
[10:21:26.821]                             break
[10:21:26.821]                           }
[10:21:26.821]                         }
[10:21:26.821]                       }
[10:21:26.821]                       invisible(muffled)
[10:21:26.821]                     }
[10:21:26.821]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.821]                   }
[10:21:26.821]                 }
[10:21:26.821]                 else {
[10:21:26.821]                   if (TRUE) {
[10:21:26.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.821]                     {
[10:21:26.821]                       inherits <- base::inherits
[10:21:26.821]                       invokeRestart <- base::invokeRestart
[10:21:26.821]                       is.null <- base::is.null
[10:21:26.821]                       muffled <- FALSE
[10:21:26.821]                       if (inherits(cond, "message")) {
[10:21:26.821]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.821]                         if (muffled) 
[10:21:26.821]                           invokeRestart("muffleMessage")
[10:21:26.821]                       }
[10:21:26.821]                       else if (inherits(cond, "warning")) {
[10:21:26.821]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.821]                         if (muffled) 
[10:21:26.821]                           invokeRestart("muffleWarning")
[10:21:26.821]                       }
[10:21:26.821]                       else if (inherits(cond, "condition")) {
[10:21:26.821]                         if (!is.null(pattern)) {
[10:21:26.821]                           computeRestarts <- base::computeRestarts
[10:21:26.821]                           grepl <- base::grepl
[10:21:26.821]                           restarts <- computeRestarts(cond)
[10:21:26.821]                           for (restart in restarts) {
[10:21:26.821]                             name <- restart$name
[10:21:26.821]                             if (is.null(name)) 
[10:21:26.821]                               next
[10:21:26.821]                             if (!grepl(pattern, name)) 
[10:21:26.821]                               next
[10:21:26.821]                             invokeRestart(restart)
[10:21:26.821]                             muffled <- TRUE
[10:21:26.821]                             break
[10:21:26.821]                           }
[10:21:26.821]                         }
[10:21:26.821]                       }
[10:21:26.821]                       invisible(muffled)
[10:21:26.821]                     }
[10:21:26.821]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.821]                   }
[10:21:26.821]                 }
[10:21:26.821]             }
[10:21:26.821]         }))
[10:21:26.821]     }, error = function(ex) {
[10:21:26.821]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.821]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.821]                 ...future.rng), started = ...future.startTime, 
[10:21:26.821]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.821]             version = "1.8"), class = "FutureResult")
[10:21:26.821]     }, finally = {
[10:21:26.821]         if (!identical(...future.workdir, getwd())) 
[10:21:26.821]             setwd(...future.workdir)
[10:21:26.821]         {
[10:21:26.821]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.821]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.821]             }
[10:21:26.821]             base::options(...future.oldOptions)
[10:21:26.821]             if (.Platform$OS.type == "windows") {
[10:21:26.821]                 old_names <- names(...future.oldEnvVars)
[10:21:26.821]                 envs <- base::Sys.getenv()
[10:21:26.821]                 names <- names(envs)
[10:21:26.821]                 common <- intersect(names, old_names)
[10:21:26.821]                 added <- setdiff(names, old_names)
[10:21:26.821]                 removed <- setdiff(old_names, names)
[10:21:26.821]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.821]                   envs[common]]
[10:21:26.821]                 NAMES <- toupper(changed)
[10:21:26.821]                 args <- list()
[10:21:26.821]                 for (kk in seq_along(NAMES)) {
[10:21:26.821]                   name <- changed[[kk]]
[10:21:26.821]                   NAME <- NAMES[[kk]]
[10:21:26.821]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.821]                     next
[10:21:26.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.821]                 }
[10:21:26.821]                 NAMES <- toupper(added)
[10:21:26.821]                 for (kk in seq_along(NAMES)) {
[10:21:26.821]                   name <- added[[kk]]
[10:21:26.821]                   NAME <- NAMES[[kk]]
[10:21:26.821]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.821]                     next
[10:21:26.821]                   args[[name]] <- ""
[10:21:26.821]                 }
[10:21:26.821]                 NAMES <- toupper(removed)
[10:21:26.821]                 for (kk in seq_along(NAMES)) {
[10:21:26.821]                   name <- removed[[kk]]
[10:21:26.821]                   NAME <- NAMES[[kk]]
[10:21:26.821]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.821]                     next
[10:21:26.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.821]                 }
[10:21:26.821]                 if (length(args) > 0) 
[10:21:26.821]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.821]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.821]             }
[10:21:26.821]             else {
[10:21:26.821]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.821]             }
[10:21:26.821]             {
[10:21:26.821]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.821]                   0L) {
[10:21:26.821]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.821]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.821]                   base::options(opts)
[10:21:26.821]                 }
[10:21:26.821]                 {
[10:21:26.821]                   {
[10:21:26.821]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:26.821]                     NULL
[10:21:26.821]                   }
[10:21:26.821]                   options(future.plan = NULL)
[10:21:26.821]                   if (is.na(NA_character_)) 
[10:21:26.821]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.821]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.821]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.821]                     .init = FALSE)
[10:21:26.821]                 }
[10:21:26.821]             }
[10:21:26.821]         }
[10:21:26.821]     })
[10:21:26.821]     if (TRUE) {
[10:21:26.821]         base::sink(type = "output", split = FALSE)
[10:21:26.821]         if (TRUE) {
[10:21:26.821]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.821]         }
[10:21:26.821]         else {
[10:21:26.821]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.821]         }
[10:21:26.821]         base::close(...future.stdout)
[10:21:26.821]         ...future.stdout <- NULL
[10:21:26.821]     }
[10:21:26.821]     ...future.result$conditions <- ...future.conditions
[10:21:26.821]     ...future.result$finished <- base::Sys.time()
[10:21:26.821]     ...future.result
[10:21:26.821] }
[10:21:26.823] requestCore(): workers = 2
[10:21:26.825] MulticoreFuture started
[10:21:26.825] - Launch lazy future ... done
[10:21:26.826] run() for ‘MulticoreFuture’ ... done
[10:21:26.826] result() for MulticoreFuture ...
[10:21:26.826] plan(): Setting new future strategy stack:
[10:21:26.827] List of future strategies:
[10:21:26.827] 1. sequential:
[10:21:26.827]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.827]    - tweaked: FALSE
[10:21:26.827]    - call: NULL
[10:21:26.828] plan(): nbrOfWorkers() = 1
[10:21:26.831] plan(): Setting new future strategy stack:
[10:21:26.831] List of future strategies:
[10:21:26.831] 1. multicore:
[10:21:26.831]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:26.831]    - tweaked: FALSE
[10:21:26.831]    - call: plan(strategy)
[10:21:26.835] plan(): nbrOfWorkers() = 2
[10:21:26.837] result() for MulticoreFuture ...
[10:21:26.837] result() for MulticoreFuture ... done
[10:21:26.837] result() for MulticoreFuture ... done
[10:21:26.837] result() for MulticoreFuture ...
[10:21:26.837] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[10:21:26.841] getGlobalsAndPackages() ...
[10:21:26.841] Searching for globals...
[10:21:26.847] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[10:21:26.847] Searching for globals ... DONE
[10:21:26.847] Resolving globals: FALSE
[10:21:26.848] 
[10:21:26.848] - packages: [2] ‘stats’, ‘datasets’
[10:21:26.848] getGlobalsAndPackages() ... DONE
[10:21:26.849] run() for ‘Future’ ...
[10:21:26.849] - state: ‘created’
[10:21:26.849] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:26.851] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:26.851] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:26.851]   - Field: ‘label’
[10:21:26.851]   - Field: ‘local’
[10:21:26.851]   - Field: ‘owner’
[10:21:26.851]   - Field: ‘envir’
[10:21:26.851]   - Field: ‘workers’
[10:21:26.852]   - Field: ‘packages’
[10:21:26.852]   - Field: ‘gc’
[10:21:26.852]   - Field: ‘job’
[10:21:26.852]   - Field: ‘conditions’
[10:21:26.852]   - Field: ‘expr’
[10:21:26.852]   - Field: ‘uuid’
[10:21:26.852]   - Field: ‘seed’
[10:21:26.852]   - Field: ‘version’
[10:21:26.852]   - Field: ‘result’
[10:21:26.853]   - Field: ‘asynchronous’
[10:21:26.853]   - Field: ‘calls’
[10:21:26.853]   - Field: ‘globals’
[10:21:26.853]   - Field: ‘stdout’
[10:21:26.853]   - Field: ‘earlySignal’
[10:21:26.853]   - Field: ‘lazy’
[10:21:26.853]   - Field: ‘state’
[10:21:26.853] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:26.853] - Launch lazy future ...
[10:21:26.854] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:21:26.854] Packages needed by future strategies (n = 0): <none>
[10:21:26.854] {
[10:21:26.854]     {
[10:21:26.854]         {
[10:21:26.854]             ...future.startTime <- base::Sys.time()
[10:21:26.854]             {
[10:21:26.854]                 {
[10:21:26.854]                   {
[10:21:26.854]                     {
[10:21:26.854]                       {
[10:21:26.854]                         base::local({
[10:21:26.854]                           has_future <- base::requireNamespace("future", 
[10:21:26.854]                             quietly = TRUE)
[10:21:26.854]                           if (has_future) {
[10:21:26.854]                             ns <- base::getNamespace("future")
[10:21:26.854]                             version <- ns[[".package"]][["version"]]
[10:21:26.854]                             if (is.null(version)) 
[10:21:26.854]                               version <- utils::packageVersion("future")
[10:21:26.854]                           }
[10:21:26.854]                           else {
[10:21:26.854]                             version <- NULL
[10:21:26.854]                           }
[10:21:26.854]                           if (!has_future || version < "1.8.0") {
[10:21:26.854]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.854]                               "", base::R.version$version.string), 
[10:21:26.854]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:26.854]                                 base::R.version$platform, 8 * 
[10:21:26.854]                                   base::.Machine$sizeof.pointer), 
[10:21:26.854]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.854]                                 "release", "version")], collapse = " "), 
[10:21:26.854]                               hostname = base::Sys.info()[["nodename"]])
[10:21:26.854]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.854]                               info)
[10:21:26.854]                             info <- base::paste(info, collapse = "; ")
[10:21:26.854]                             if (!has_future) {
[10:21:26.854]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.854]                                 info)
[10:21:26.854]                             }
[10:21:26.854]                             else {
[10:21:26.854]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.854]                                 info, version)
[10:21:26.854]                             }
[10:21:26.854]                             base::stop(msg)
[10:21:26.854]                           }
[10:21:26.854]                         })
[10:21:26.854]                       }
[10:21:26.854]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:26.854]                       base::options(mc.cores = 1L)
[10:21:26.854]                     }
[10:21:26.854]                     base::local({
[10:21:26.854]                       for (pkg in c("stats", "datasets")) {
[10:21:26.854]                         base::loadNamespace(pkg)
[10:21:26.854]                         base::library(pkg, character.only = TRUE)
[10:21:26.854]                       }
[10:21:26.854]                     })
[10:21:26.854]                   }
[10:21:26.854]                   ...future.strategy.old <- future::plan("list")
[10:21:26.854]                   options(future.plan = NULL)
[10:21:26.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.854]                 }
[10:21:26.854]                 ...future.workdir <- getwd()
[10:21:26.854]             }
[10:21:26.854]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.854]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.854]         }
[10:21:26.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.854]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.854]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.854]             base::names(...future.oldOptions))
[10:21:26.854]     }
[10:21:26.854]     if (FALSE) {
[10:21:26.854]     }
[10:21:26.854]     else {
[10:21:26.854]         if (TRUE) {
[10:21:26.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.854]                 open = "w")
[10:21:26.854]         }
[10:21:26.854]         else {
[10:21:26.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.854]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.854]         }
[10:21:26.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.854]             base::sink(type = "output", split = FALSE)
[10:21:26.854]             base::close(...future.stdout)
[10:21:26.854]         }, add = TRUE)
[10:21:26.854]     }
[10:21:26.854]     ...future.frame <- base::sys.nframe()
[10:21:26.854]     ...future.conditions <- base::list()
[10:21:26.854]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.854]     if (FALSE) {
[10:21:26.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.854]     }
[10:21:26.854]     ...future.result <- base::tryCatch({
[10:21:26.854]         base::withCallingHandlers({
[10:21:26.854]             ...future.value <- base::withVisible(base::local({
[10:21:26.854]                 withCallingHandlers({
[10:21:26.854]                   {
[10:21:26.854]                     lm(dist ~ poly(speed, 2), data = cars)
[10:21:26.854]                   }
[10:21:26.854]                 }, immediateCondition = function(cond) {
[10:21:26.854]                   save_rds <- function (object, pathname, ...) 
[10:21:26.854]                   {
[10:21:26.854]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:26.854]                     if (file_test("-f", pathname_tmp)) {
[10:21:26.854]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.854]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:26.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.854]                         fi_tmp[["mtime"]])
[10:21:26.854]                     }
[10:21:26.854]                     tryCatch({
[10:21:26.854]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:26.854]                     }, error = function(ex) {
[10:21:26.854]                       msg <- conditionMessage(ex)
[10:21:26.854]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.854]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:26.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.854]                         fi_tmp[["mtime"]], msg)
[10:21:26.854]                       ex$message <- msg
[10:21:26.854]                       stop(ex)
[10:21:26.854]                     })
[10:21:26.854]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:26.854]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:26.854]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:26.854]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.854]                       fi <- file.info(pathname)
[10:21:26.854]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:26.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.854]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:26.854]                         fi[["size"]], fi[["mtime"]])
[10:21:26.854]                       stop(msg)
[10:21:26.854]                     }
[10:21:26.854]                     invisible(pathname)
[10:21:26.854]                   }
[10:21:26.854]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:26.854]                     rootPath = tempdir()) 
[10:21:26.854]                   {
[10:21:26.854]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:26.854]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:26.854]                       tmpdir = path, fileext = ".rds")
[10:21:26.854]                     save_rds(obj, file)
[10:21:26.854]                   }
[10:21:26.854]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0RHvXY/.future/immediateConditions")
[10:21:26.854]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.854]                   {
[10:21:26.854]                     inherits <- base::inherits
[10:21:26.854]                     invokeRestart <- base::invokeRestart
[10:21:26.854]                     is.null <- base::is.null
[10:21:26.854]                     muffled <- FALSE
[10:21:26.854]                     if (inherits(cond, "message")) {
[10:21:26.854]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:26.854]                       if (muffled) 
[10:21:26.854]                         invokeRestart("muffleMessage")
[10:21:26.854]                     }
[10:21:26.854]                     else if (inherits(cond, "warning")) {
[10:21:26.854]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:26.854]                       if (muffled) 
[10:21:26.854]                         invokeRestart("muffleWarning")
[10:21:26.854]                     }
[10:21:26.854]                     else if (inherits(cond, "condition")) {
[10:21:26.854]                       if (!is.null(pattern)) {
[10:21:26.854]                         computeRestarts <- base::computeRestarts
[10:21:26.854]                         grepl <- base::grepl
[10:21:26.854]                         restarts <- computeRestarts(cond)
[10:21:26.854]                         for (restart in restarts) {
[10:21:26.854]                           name <- restart$name
[10:21:26.854]                           if (is.null(name)) 
[10:21:26.854]                             next
[10:21:26.854]                           if (!grepl(pattern, name)) 
[10:21:26.854]                             next
[10:21:26.854]                           invokeRestart(restart)
[10:21:26.854]                           muffled <- TRUE
[10:21:26.854]                           break
[10:21:26.854]                         }
[10:21:26.854]                       }
[10:21:26.854]                     }
[10:21:26.854]                     invisible(muffled)
[10:21:26.854]                   }
[10:21:26.854]                   muffleCondition(cond)
[10:21:26.854]                 })
[10:21:26.854]             }))
[10:21:26.854]             future::FutureResult(value = ...future.value$value, 
[10:21:26.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.854]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.854]                     ...future.globalenv.names))
[10:21:26.854]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.854]         }, condition = base::local({
[10:21:26.854]             c <- base::c
[10:21:26.854]             inherits <- base::inherits
[10:21:26.854]             invokeRestart <- base::invokeRestart
[10:21:26.854]             length <- base::length
[10:21:26.854]             list <- base::list
[10:21:26.854]             seq.int <- base::seq.int
[10:21:26.854]             signalCondition <- base::signalCondition
[10:21:26.854]             sys.calls <- base::sys.calls
[10:21:26.854]             `[[` <- base::`[[`
[10:21:26.854]             `+` <- base::`+`
[10:21:26.854]             `<<-` <- base::`<<-`
[10:21:26.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.854]                   3L)]
[10:21:26.854]             }
[10:21:26.854]             function(cond) {
[10:21:26.854]                 is_error <- inherits(cond, "error")
[10:21:26.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.854]                   NULL)
[10:21:26.854]                 if (is_error) {
[10:21:26.854]                   sessionInformation <- function() {
[10:21:26.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.854]                       search = base::search(), system = base::Sys.info())
[10:21:26.854]                   }
[10:21:26.854]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.854]                     cond$call), session = sessionInformation(), 
[10:21:26.854]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.854]                   signalCondition(cond)
[10:21:26.854]                 }
[10:21:26.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.854]                 "immediateCondition"))) {
[10:21:26.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.854]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.854]                   if (TRUE && !signal) {
[10:21:26.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.854]                     {
[10:21:26.854]                       inherits <- base::inherits
[10:21:26.854]                       invokeRestart <- base::invokeRestart
[10:21:26.854]                       is.null <- base::is.null
[10:21:26.854]                       muffled <- FALSE
[10:21:26.854]                       if (inherits(cond, "message")) {
[10:21:26.854]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.854]                         if (muffled) 
[10:21:26.854]                           invokeRestart("muffleMessage")
[10:21:26.854]                       }
[10:21:26.854]                       else if (inherits(cond, "warning")) {
[10:21:26.854]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.854]                         if (muffled) 
[10:21:26.854]                           invokeRestart("muffleWarning")
[10:21:26.854]                       }
[10:21:26.854]                       else if (inherits(cond, "condition")) {
[10:21:26.854]                         if (!is.null(pattern)) {
[10:21:26.854]                           computeRestarts <- base::computeRestarts
[10:21:26.854]                           grepl <- base::grepl
[10:21:26.854]                           restarts <- computeRestarts(cond)
[10:21:26.854]                           for (restart in restarts) {
[10:21:26.854]                             name <- restart$name
[10:21:26.854]                             if (is.null(name)) 
[10:21:26.854]                               next
[10:21:26.854]                             if (!grepl(pattern, name)) 
[10:21:26.854]                               next
[10:21:26.854]                             invokeRestart(restart)
[10:21:26.854]                             muffled <- TRUE
[10:21:26.854]                             break
[10:21:26.854]                           }
[10:21:26.854]                         }
[10:21:26.854]                       }
[10:21:26.854]                       invisible(muffled)
[10:21:26.854]                     }
[10:21:26.854]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.854]                   }
[10:21:26.854]                 }
[10:21:26.854]                 else {
[10:21:26.854]                   if (TRUE) {
[10:21:26.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.854]                     {
[10:21:26.854]                       inherits <- base::inherits
[10:21:26.854]                       invokeRestart <- base::invokeRestart
[10:21:26.854]                       is.null <- base::is.null
[10:21:26.854]                       muffled <- FALSE
[10:21:26.854]                       if (inherits(cond, "message")) {
[10:21:26.854]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.854]                         if (muffled) 
[10:21:26.854]                           invokeRestart("muffleMessage")
[10:21:26.854]                       }
[10:21:26.854]                       else if (inherits(cond, "warning")) {
[10:21:26.854]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.854]                         if (muffled) 
[10:21:26.854]                           invokeRestart("muffleWarning")
[10:21:26.854]                       }
[10:21:26.854]                       else if (inherits(cond, "condition")) {
[10:21:26.854]                         if (!is.null(pattern)) {
[10:21:26.854]                           computeRestarts <- base::computeRestarts
[10:21:26.854]                           grepl <- base::grepl
[10:21:26.854]                           restarts <- computeRestarts(cond)
[10:21:26.854]                           for (restart in restarts) {
[10:21:26.854]                             name <- restart$name
[10:21:26.854]                             if (is.null(name)) 
[10:21:26.854]                               next
[10:21:26.854]                             if (!grepl(pattern, name)) 
[10:21:26.854]                               next
[10:21:26.854]                             invokeRestart(restart)
[10:21:26.854]                             muffled <- TRUE
[10:21:26.854]                             break
[10:21:26.854]                           }
[10:21:26.854]                         }
[10:21:26.854]                       }
[10:21:26.854]                       invisible(muffled)
[10:21:26.854]                     }
[10:21:26.854]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.854]                   }
[10:21:26.854]                 }
[10:21:26.854]             }
[10:21:26.854]         }))
[10:21:26.854]     }, error = function(ex) {
[10:21:26.854]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.854]                 ...future.rng), started = ...future.startTime, 
[10:21:26.854]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.854]             version = "1.8"), class = "FutureResult")
[10:21:26.854]     }, finally = {
[10:21:26.854]         if (!identical(...future.workdir, getwd())) 
[10:21:26.854]             setwd(...future.workdir)
[10:21:26.854]         {
[10:21:26.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.854]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.854]             }
[10:21:26.854]             base::options(...future.oldOptions)
[10:21:26.854]             if (.Platform$OS.type == "windows") {
[10:21:26.854]                 old_names <- names(...future.oldEnvVars)
[10:21:26.854]                 envs <- base::Sys.getenv()
[10:21:26.854]                 names <- names(envs)
[10:21:26.854]                 common <- intersect(names, old_names)
[10:21:26.854]                 added <- setdiff(names, old_names)
[10:21:26.854]                 removed <- setdiff(old_names, names)
[10:21:26.854]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.854]                   envs[common]]
[10:21:26.854]                 NAMES <- toupper(changed)
[10:21:26.854]                 args <- list()
[10:21:26.854]                 for (kk in seq_along(NAMES)) {
[10:21:26.854]                   name <- changed[[kk]]
[10:21:26.854]                   NAME <- NAMES[[kk]]
[10:21:26.854]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.854]                     next
[10:21:26.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.854]                 }
[10:21:26.854]                 NAMES <- toupper(added)
[10:21:26.854]                 for (kk in seq_along(NAMES)) {
[10:21:26.854]                   name <- added[[kk]]
[10:21:26.854]                   NAME <- NAMES[[kk]]
[10:21:26.854]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.854]                     next
[10:21:26.854]                   args[[name]] <- ""
[10:21:26.854]                 }
[10:21:26.854]                 NAMES <- toupper(removed)
[10:21:26.854]                 for (kk in seq_along(NAMES)) {
[10:21:26.854]                   name <- removed[[kk]]
[10:21:26.854]                   NAME <- NAMES[[kk]]
[10:21:26.854]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.854]                     next
[10:21:26.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.854]                 }
[10:21:26.854]                 if (length(args) > 0) 
[10:21:26.854]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.854]             }
[10:21:26.854]             else {
[10:21:26.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.854]             }
[10:21:26.854]             {
[10:21:26.854]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.854]                   0L) {
[10:21:26.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.854]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.854]                   base::options(opts)
[10:21:26.854]                 }
[10:21:26.854]                 {
[10:21:26.854]                   {
[10:21:26.854]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:26.854]                     NULL
[10:21:26.854]                   }
[10:21:26.854]                   options(future.plan = NULL)
[10:21:26.854]                   if (is.na(NA_character_)) 
[10:21:26.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.854]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.854]                     .init = FALSE)
[10:21:26.854]                 }
[10:21:26.854]             }
[10:21:26.854]         }
[10:21:26.854]     })
[10:21:26.854]     if (TRUE) {
[10:21:26.854]         base::sink(type = "output", split = FALSE)
[10:21:26.854]         if (TRUE) {
[10:21:26.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.854]         }
[10:21:26.854]         else {
[10:21:26.854]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.854]         }
[10:21:26.854]         base::close(...future.stdout)
[10:21:26.854]         ...future.stdout <- NULL
[10:21:26.854]     }
[10:21:26.854]     ...future.result$conditions <- ...future.conditions
[10:21:26.854]     ...future.result$finished <- base::Sys.time()
[10:21:26.854]     ...future.result
[10:21:26.854] }
[10:21:26.857] requestCore(): workers = 2
[10:21:26.858] MulticoreFuture started
[10:21:26.859] - Launch lazy future ... done
[10:21:26.859] run() for ‘MulticoreFuture’ ... done
[10:21:26.859] result() for MulticoreFuture ...
[10:21:26.860] plan(): Setting new future strategy stack:
[10:21:26.860] List of future strategies:
[10:21:26.860] 1. sequential:
[10:21:26.860]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.860]    - tweaked: FALSE
[10:21:26.860]    - call: NULL
[10:21:26.861] plan(): nbrOfWorkers() = 1
[10:21:26.866] plan(): Setting new future strategy stack:
[10:21:26.866] List of future strategies:
[10:21:26.866] 1. multicore:
[10:21:26.866]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:26.866]    - tweaked: FALSE
[10:21:26.866]    - call: plan(strategy)
[10:21:26.869] plan(): nbrOfWorkers() = 2
[10:21:26.871] result() for MulticoreFuture ...
[10:21:26.872] result() for MulticoreFuture ... done
[10:21:26.872] result() for MulticoreFuture ... done
[10:21:26.872] result() for MulticoreFuture ...
[10:21:26.872] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[10:21:26.875] getGlobalsAndPackages() ...
[10:21:26.875] Searching for globals...
[10:21:26.880] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[10:21:26.881] Searching for globals ... DONE
[10:21:26.881] Resolving globals: FALSE
[10:21:26.882] The total size of the 3 globals is 1.22 KiB (1254 bytes)
[10:21:26.882] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (633 bytes of class ‘function’), ‘inner_function’ (371 bytes of class ‘function’) and ‘outer_function’ (250 bytes of class ‘function’)
[10:21:26.882] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[10:21:26.882] 
[10:21:26.883] getGlobalsAndPackages() ... DONE
[10:21:26.883] run() for ‘Future’ ...
[10:21:26.883] - state: ‘created’
[10:21:26.883] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:26.885] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:26.885] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:26.886]   - Field: ‘label’
[10:21:26.886]   - Field: ‘local’
[10:21:26.886]   - Field: ‘owner’
[10:21:26.886]   - Field: ‘envir’
[10:21:26.886]   - Field: ‘workers’
[10:21:26.886]   - Field: ‘packages’
[10:21:26.886]   - Field: ‘gc’
[10:21:26.886]   - Field: ‘job’
[10:21:26.886]   - Field: ‘conditions’
[10:21:26.887]   - Field: ‘expr’
[10:21:26.887]   - Field: ‘uuid’
[10:21:26.887]   - Field: ‘seed’
[10:21:26.887]   - Field: ‘version’
[10:21:26.887]   - Field: ‘result’
[10:21:26.889]   - Field: ‘asynchronous’
[10:21:26.889]   - Field: ‘calls’
[10:21:26.889]   - Field: ‘globals’
[10:21:26.889]   - Field: ‘stdout’
[10:21:26.890]   - Field: ‘earlySignal’
[10:21:26.890]   - Field: ‘lazy’
[10:21:26.890]   - Field: ‘state’
[10:21:26.890] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:26.890] - Launch lazy future ...
[10:21:26.891] Packages needed by the future expression (n = 0): <none>
[10:21:26.891] Packages needed by future strategies (n = 0): <none>
[10:21:26.891] {
[10:21:26.891]     {
[10:21:26.891]         {
[10:21:26.891]             ...future.startTime <- base::Sys.time()
[10:21:26.891]             {
[10:21:26.891]                 {
[10:21:26.891]                   {
[10:21:26.891]                     {
[10:21:26.891]                       base::local({
[10:21:26.891]                         has_future <- base::requireNamespace("future", 
[10:21:26.891]                           quietly = TRUE)
[10:21:26.891]                         if (has_future) {
[10:21:26.891]                           ns <- base::getNamespace("future")
[10:21:26.891]                           version <- ns[[".package"]][["version"]]
[10:21:26.891]                           if (is.null(version)) 
[10:21:26.891]                             version <- utils::packageVersion("future")
[10:21:26.891]                         }
[10:21:26.891]                         else {
[10:21:26.891]                           version <- NULL
[10:21:26.891]                         }
[10:21:26.891]                         if (!has_future || version < "1.8.0") {
[10:21:26.891]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.891]                             "", base::R.version$version.string), 
[10:21:26.891]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:26.891]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:26.891]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.891]                               "release", "version")], collapse = " "), 
[10:21:26.891]                             hostname = base::Sys.info()[["nodename"]])
[10:21:26.891]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.891]                             info)
[10:21:26.891]                           info <- base::paste(info, collapse = "; ")
[10:21:26.891]                           if (!has_future) {
[10:21:26.891]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.891]                               info)
[10:21:26.891]                           }
[10:21:26.891]                           else {
[10:21:26.891]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.891]                               info, version)
[10:21:26.891]                           }
[10:21:26.891]                           base::stop(msg)
[10:21:26.891]                         }
[10:21:26.891]                       })
[10:21:26.891]                     }
[10:21:26.891]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:26.891]                     base::options(mc.cores = 1L)
[10:21:26.891]                   }
[10:21:26.891]                   ...future.strategy.old <- future::plan("list")
[10:21:26.891]                   options(future.plan = NULL)
[10:21:26.891]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.891]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.891]                 }
[10:21:26.891]                 ...future.workdir <- getwd()
[10:21:26.891]             }
[10:21:26.891]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.891]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.891]         }
[10:21:26.891]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.891]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.891]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.891]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.891]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.891]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.891]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.891]             base::names(...future.oldOptions))
[10:21:26.891]     }
[10:21:26.891]     if (FALSE) {
[10:21:26.891]     }
[10:21:26.891]     else {
[10:21:26.891]         if (TRUE) {
[10:21:26.891]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.891]                 open = "w")
[10:21:26.891]         }
[10:21:26.891]         else {
[10:21:26.891]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.891]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.891]         }
[10:21:26.891]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.891]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.891]             base::sink(type = "output", split = FALSE)
[10:21:26.891]             base::close(...future.stdout)
[10:21:26.891]         }, add = TRUE)
[10:21:26.891]     }
[10:21:26.891]     ...future.frame <- base::sys.nframe()
[10:21:26.891]     ...future.conditions <- base::list()
[10:21:26.891]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.891]     if (FALSE) {
[10:21:26.891]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.891]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.891]     }
[10:21:26.891]     ...future.result <- base::tryCatch({
[10:21:26.891]         base::withCallingHandlers({
[10:21:26.891]             ...future.value <- base::withVisible(base::local({
[10:21:26.891]                 withCallingHandlers({
[10:21:26.891]                   {
[10:21:26.891]                     outer_function(1L)
[10:21:26.891]                   }
[10:21:26.891]                 }, immediateCondition = function(cond) {
[10:21:26.891]                   save_rds <- function (object, pathname, ...) 
[10:21:26.891]                   {
[10:21:26.891]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:26.891]                     if (file_test("-f", pathname_tmp)) {
[10:21:26.891]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.891]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:26.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.891]                         fi_tmp[["mtime"]])
[10:21:26.891]                     }
[10:21:26.891]                     tryCatch({
[10:21:26.891]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:26.891]                     }, error = function(ex) {
[10:21:26.891]                       msg <- conditionMessage(ex)
[10:21:26.891]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.891]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:26.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.891]                         fi_tmp[["mtime"]], msg)
[10:21:26.891]                       ex$message <- msg
[10:21:26.891]                       stop(ex)
[10:21:26.891]                     })
[10:21:26.891]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:26.891]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:26.891]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:26.891]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.891]                       fi <- file.info(pathname)
[10:21:26.891]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:26.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.891]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:26.891]                         fi[["size"]], fi[["mtime"]])
[10:21:26.891]                       stop(msg)
[10:21:26.891]                     }
[10:21:26.891]                     invisible(pathname)
[10:21:26.891]                   }
[10:21:26.891]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:26.891]                     rootPath = tempdir()) 
[10:21:26.891]                   {
[10:21:26.891]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:26.891]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:26.891]                       tmpdir = path, fileext = ".rds")
[10:21:26.891]                     save_rds(obj, file)
[10:21:26.891]                   }
[10:21:26.891]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0RHvXY/.future/immediateConditions")
[10:21:26.891]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.891]                   {
[10:21:26.891]                     inherits <- base::inherits
[10:21:26.891]                     invokeRestart <- base::invokeRestart
[10:21:26.891]                     is.null <- base::is.null
[10:21:26.891]                     muffled <- FALSE
[10:21:26.891]                     if (inherits(cond, "message")) {
[10:21:26.891]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:26.891]                       if (muffled) 
[10:21:26.891]                         invokeRestart("muffleMessage")
[10:21:26.891]                     }
[10:21:26.891]                     else if (inherits(cond, "warning")) {
[10:21:26.891]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:26.891]                       if (muffled) 
[10:21:26.891]                         invokeRestart("muffleWarning")
[10:21:26.891]                     }
[10:21:26.891]                     else if (inherits(cond, "condition")) {
[10:21:26.891]                       if (!is.null(pattern)) {
[10:21:26.891]                         computeRestarts <- base::computeRestarts
[10:21:26.891]                         grepl <- base::grepl
[10:21:26.891]                         restarts <- computeRestarts(cond)
[10:21:26.891]                         for (restart in restarts) {
[10:21:26.891]                           name <- restart$name
[10:21:26.891]                           if (is.null(name)) 
[10:21:26.891]                             next
[10:21:26.891]                           if (!grepl(pattern, name)) 
[10:21:26.891]                             next
[10:21:26.891]                           invokeRestart(restart)
[10:21:26.891]                           muffled <- TRUE
[10:21:26.891]                           break
[10:21:26.891]                         }
[10:21:26.891]                       }
[10:21:26.891]                     }
[10:21:26.891]                     invisible(muffled)
[10:21:26.891]                   }
[10:21:26.891]                   muffleCondition(cond)
[10:21:26.891]                 })
[10:21:26.891]             }))
[10:21:26.891]             future::FutureResult(value = ...future.value$value, 
[10:21:26.891]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.891]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.891]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.891]                     ...future.globalenv.names))
[10:21:26.891]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.891]         }, condition = base::local({
[10:21:26.891]             c <- base::c
[10:21:26.891]             inherits <- base::inherits
[10:21:26.891]             invokeRestart <- base::invokeRestart
[10:21:26.891]             length <- base::length
[10:21:26.891]             list <- base::list
[10:21:26.891]             seq.int <- base::seq.int
[10:21:26.891]             signalCondition <- base::signalCondition
[10:21:26.891]             sys.calls <- base::sys.calls
[10:21:26.891]             `[[` <- base::`[[`
[10:21:26.891]             `+` <- base::`+`
[10:21:26.891]             `<<-` <- base::`<<-`
[10:21:26.891]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.891]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.891]                   3L)]
[10:21:26.891]             }
[10:21:26.891]             function(cond) {
[10:21:26.891]                 is_error <- inherits(cond, "error")
[10:21:26.891]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.891]                   NULL)
[10:21:26.891]                 if (is_error) {
[10:21:26.891]                   sessionInformation <- function() {
[10:21:26.891]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.891]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.891]                       search = base::search(), system = base::Sys.info())
[10:21:26.891]                   }
[10:21:26.891]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.891]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.891]                     cond$call), session = sessionInformation(), 
[10:21:26.891]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.891]                   signalCondition(cond)
[10:21:26.891]                 }
[10:21:26.891]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.891]                 "immediateCondition"))) {
[10:21:26.891]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.891]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.891]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.891]                   if (TRUE && !signal) {
[10:21:26.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.891]                     {
[10:21:26.891]                       inherits <- base::inherits
[10:21:26.891]                       invokeRestart <- base::invokeRestart
[10:21:26.891]                       is.null <- base::is.null
[10:21:26.891]                       muffled <- FALSE
[10:21:26.891]                       if (inherits(cond, "message")) {
[10:21:26.891]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.891]                         if (muffled) 
[10:21:26.891]                           invokeRestart("muffleMessage")
[10:21:26.891]                       }
[10:21:26.891]                       else if (inherits(cond, "warning")) {
[10:21:26.891]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.891]                         if (muffled) 
[10:21:26.891]                           invokeRestart("muffleWarning")
[10:21:26.891]                       }
[10:21:26.891]                       else if (inherits(cond, "condition")) {
[10:21:26.891]                         if (!is.null(pattern)) {
[10:21:26.891]                           computeRestarts <- base::computeRestarts
[10:21:26.891]                           grepl <- base::grepl
[10:21:26.891]                           restarts <- computeRestarts(cond)
[10:21:26.891]                           for (restart in restarts) {
[10:21:26.891]                             name <- restart$name
[10:21:26.891]                             if (is.null(name)) 
[10:21:26.891]                               next
[10:21:26.891]                             if (!grepl(pattern, name)) 
[10:21:26.891]                               next
[10:21:26.891]                             invokeRestart(restart)
[10:21:26.891]                             muffled <- TRUE
[10:21:26.891]                             break
[10:21:26.891]                           }
[10:21:26.891]                         }
[10:21:26.891]                       }
[10:21:26.891]                       invisible(muffled)
[10:21:26.891]                     }
[10:21:26.891]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.891]                   }
[10:21:26.891]                 }
[10:21:26.891]                 else {
[10:21:26.891]                   if (TRUE) {
[10:21:26.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.891]                     {
[10:21:26.891]                       inherits <- base::inherits
[10:21:26.891]                       invokeRestart <- base::invokeRestart
[10:21:26.891]                       is.null <- base::is.null
[10:21:26.891]                       muffled <- FALSE
[10:21:26.891]                       if (inherits(cond, "message")) {
[10:21:26.891]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.891]                         if (muffled) 
[10:21:26.891]                           invokeRestart("muffleMessage")
[10:21:26.891]                       }
[10:21:26.891]                       else if (inherits(cond, "warning")) {
[10:21:26.891]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.891]                         if (muffled) 
[10:21:26.891]                           invokeRestart("muffleWarning")
[10:21:26.891]                       }
[10:21:26.891]                       else if (inherits(cond, "condition")) {
[10:21:26.891]                         if (!is.null(pattern)) {
[10:21:26.891]                           computeRestarts <- base::computeRestarts
[10:21:26.891]                           grepl <- base::grepl
[10:21:26.891]                           restarts <- computeRestarts(cond)
[10:21:26.891]                           for (restart in restarts) {
[10:21:26.891]                             name <- restart$name
[10:21:26.891]                             if (is.null(name)) 
[10:21:26.891]                               next
[10:21:26.891]                             if (!grepl(pattern, name)) 
[10:21:26.891]                               next
[10:21:26.891]                             invokeRestart(restart)
[10:21:26.891]                             muffled <- TRUE
[10:21:26.891]                             break
[10:21:26.891]                           }
[10:21:26.891]                         }
[10:21:26.891]                       }
[10:21:26.891]                       invisible(muffled)
[10:21:26.891]                     }
[10:21:26.891]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.891]                   }
[10:21:26.891]                 }
[10:21:26.891]             }
[10:21:26.891]         }))
[10:21:26.891]     }, error = function(ex) {
[10:21:26.891]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.891]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.891]                 ...future.rng), started = ...future.startTime, 
[10:21:26.891]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.891]             version = "1.8"), class = "FutureResult")
[10:21:26.891]     }, finally = {
[10:21:26.891]         if (!identical(...future.workdir, getwd())) 
[10:21:26.891]             setwd(...future.workdir)
[10:21:26.891]         {
[10:21:26.891]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.891]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.891]             }
[10:21:26.891]             base::options(...future.oldOptions)
[10:21:26.891]             if (.Platform$OS.type == "windows") {
[10:21:26.891]                 old_names <- names(...future.oldEnvVars)
[10:21:26.891]                 envs <- base::Sys.getenv()
[10:21:26.891]                 names <- names(envs)
[10:21:26.891]                 common <- intersect(names, old_names)
[10:21:26.891]                 added <- setdiff(names, old_names)
[10:21:26.891]                 removed <- setdiff(old_names, names)
[10:21:26.891]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.891]                   envs[common]]
[10:21:26.891]                 NAMES <- toupper(changed)
[10:21:26.891]                 args <- list()
[10:21:26.891]                 for (kk in seq_along(NAMES)) {
[10:21:26.891]                   name <- changed[[kk]]
[10:21:26.891]                   NAME <- NAMES[[kk]]
[10:21:26.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.891]                     next
[10:21:26.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.891]                 }
[10:21:26.891]                 NAMES <- toupper(added)
[10:21:26.891]                 for (kk in seq_along(NAMES)) {
[10:21:26.891]                   name <- added[[kk]]
[10:21:26.891]                   NAME <- NAMES[[kk]]
[10:21:26.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.891]                     next
[10:21:26.891]                   args[[name]] <- ""
[10:21:26.891]                 }
[10:21:26.891]                 NAMES <- toupper(removed)
[10:21:26.891]                 for (kk in seq_along(NAMES)) {
[10:21:26.891]                   name <- removed[[kk]]
[10:21:26.891]                   NAME <- NAMES[[kk]]
[10:21:26.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.891]                     next
[10:21:26.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.891]                 }
[10:21:26.891]                 if (length(args) > 0) 
[10:21:26.891]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.891]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.891]             }
[10:21:26.891]             else {
[10:21:26.891]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.891]             }
[10:21:26.891]             {
[10:21:26.891]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.891]                   0L) {
[10:21:26.891]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.891]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.891]                   base::options(opts)
[10:21:26.891]                 }
[10:21:26.891]                 {
[10:21:26.891]                   {
[10:21:26.891]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:26.891]                     NULL
[10:21:26.891]                   }
[10:21:26.891]                   options(future.plan = NULL)
[10:21:26.891]                   if (is.na(NA_character_)) 
[10:21:26.891]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.891]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.891]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.891]                     .init = FALSE)
[10:21:26.891]                 }
[10:21:26.891]             }
[10:21:26.891]         }
[10:21:26.891]     })
[10:21:26.891]     if (TRUE) {
[10:21:26.891]         base::sink(type = "output", split = FALSE)
[10:21:26.891]         if (TRUE) {
[10:21:26.891]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.891]         }
[10:21:26.891]         else {
[10:21:26.891]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.891]         }
[10:21:26.891]         base::close(...future.stdout)
[10:21:26.891]         ...future.stdout <- NULL
[10:21:26.891]     }
[10:21:26.891]     ...future.result$conditions <- ...future.conditions
[10:21:26.891]     ...future.result$finished <- base::Sys.time()
[10:21:26.891]     ...future.result
[10:21:26.891] }
[10:21:26.894] assign_globals() ...
[10:21:26.894] List of 3
[10:21:26.894]  $ outer_function:function (x)  
[10:21:26.894]  $ map           :function (.x, .f, ...)  
[10:21:26.894]  $ inner_function:function (x)  
[10:21:26.894]  - attr(*, "where")=List of 3
[10:21:26.894]   ..$ outer_function:<environment: R_EmptyEnv> 
[10:21:26.894]   ..$ map           :<environment: R_EmptyEnv> 
[10:21:26.894]   ..$ inner_function:<environment: R_EmptyEnv> 
[10:21:26.894]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:26.894]  - attr(*, "resolved")= logi FALSE
[10:21:26.894]  - attr(*, "total_size")= num 1254
[10:21:26.894]  - attr(*, "already-done")= logi TRUE
[10:21:26.898] - reassign environment for ‘outer_function’
[10:21:26.898] - copied ‘outer_function’ to environment
[10:21:26.898] - reassign environment for ‘map’
[10:21:26.898] - copied ‘map’ to environment
[10:21:26.898] - reassign environment for ‘inner_function’
[10:21:26.898] - copied ‘inner_function’ to environment
[10:21:26.898] assign_globals() ... done
[10:21:26.899] requestCore(): workers = 2
[10:21:26.900] MulticoreFuture started
[10:21:26.901] - Launch lazy future ... done
[10:21:26.901] run() for ‘MulticoreFuture’ ... done
[10:21:26.901] plan(): Setting new future strategy stack:
[10:21:26.901] result() for MulticoreFuture ...
[10:21:26.902] List of future strategies:
[10:21:26.902] 1. sequential:
[10:21:26.902]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.902]    - tweaked: FALSE
[10:21:26.902]    - call: NULL
[10:21:26.903] plan(): nbrOfWorkers() = 1
[10:21:26.905] plan(): Setting new future strategy stack:
[10:21:26.905] List of future strategies:
[10:21:26.905] 1. multicore:
[10:21:26.905]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:26.905]    - tweaked: FALSE
[10:21:26.905]    - call: plan(strategy)
[10:21:26.909] plan(): nbrOfWorkers() = 2
[10:21:26.910] result() for MulticoreFuture ...
[10:21:26.910] result() for MulticoreFuture ... done
[10:21:26.910] result() for MulticoreFuture ... done
[10:21:26.910] result() for MulticoreFuture ...
[10:21:26.910] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[10:21:26.912] getGlobalsAndPackages() ...
[10:21:26.912] Searching for globals...
[10:21:26.918] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[10:21:26.918] Searching for globals ... DONE
[10:21:26.918] Resolving globals: FALSE
[10:21:26.919] The total size of the 3 globals is 1.22 KiB (1254 bytes)
[10:21:26.920] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (633 bytes of class ‘function’), ‘inner_function’ (371 bytes of class ‘function’) and ‘outer_function’ (250 bytes of class ‘function’)
[10:21:26.920] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[10:21:26.920] 
[10:21:26.920] getGlobalsAndPackages() ... DONE
[10:21:26.920] run() for ‘Future’ ...
[10:21:26.921] - state: ‘created’
[10:21:26.921] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:26.923] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:26.923] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:26.923]   - Field: ‘label’
[10:21:26.923]   - Field: ‘local’
[10:21:26.923]   - Field: ‘owner’
[10:21:26.923]   - Field: ‘envir’
[10:21:26.923]   - Field: ‘workers’
[10:21:26.924]   - Field: ‘packages’
[10:21:26.924]   - Field: ‘gc’
[10:21:26.924]   - Field: ‘job’
[10:21:26.924]   - Field: ‘conditions’
[10:21:26.924]   - Field: ‘expr’
[10:21:26.924]   - Field: ‘uuid’
[10:21:26.924]   - Field: ‘seed’
[10:21:26.924]   - Field: ‘version’
[10:21:26.924]   - Field: ‘result’
[10:21:26.925]   - Field: ‘asynchronous’
[10:21:26.925]   - Field: ‘calls’
[10:21:26.925]   - Field: ‘globals’
[10:21:26.925]   - Field: ‘stdout’
[10:21:26.925]   - Field: ‘earlySignal’
[10:21:26.925]   - Field: ‘lazy’
[10:21:26.925]   - Field: ‘state’
[10:21:26.925] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:26.925] - Launch lazy future ...
[10:21:26.926] Packages needed by the future expression (n = 0): <none>
[10:21:26.926] Packages needed by future strategies (n = 0): <none>
[10:21:26.926] {
[10:21:26.926]     {
[10:21:26.926]         {
[10:21:26.926]             ...future.startTime <- base::Sys.time()
[10:21:26.926]             {
[10:21:26.926]                 {
[10:21:26.926]                   {
[10:21:26.926]                     {
[10:21:26.926]                       base::local({
[10:21:26.926]                         has_future <- base::requireNamespace("future", 
[10:21:26.926]                           quietly = TRUE)
[10:21:26.926]                         if (has_future) {
[10:21:26.926]                           ns <- base::getNamespace("future")
[10:21:26.926]                           version <- ns[[".package"]][["version"]]
[10:21:26.926]                           if (is.null(version)) 
[10:21:26.926]                             version <- utils::packageVersion("future")
[10:21:26.926]                         }
[10:21:26.926]                         else {
[10:21:26.926]                           version <- NULL
[10:21:26.926]                         }
[10:21:26.926]                         if (!has_future || version < "1.8.0") {
[10:21:26.926]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:26.926]                             "", base::R.version$version.string), 
[10:21:26.926]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:26.926]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:26.926]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:26.926]                               "release", "version")], collapse = " "), 
[10:21:26.926]                             hostname = base::Sys.info()[["nodename"]])
[10:21:26.926]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:26.926]                             info)
[10:21:26.926]                           info <- base::paste(info, collapse = "; ")
[10:21:26.926]                           if (!has_future) {
[10:21:26.926]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:26.926]                               info)
[10:21:26.926]                           }
[10:21:26.926]                           else {
[10:21:26.926]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:26.926]                               info, version)
[10:21:26.926]                           }
[10:21:26.926]                           base::stop(msg)
[10:21:26.926]                         }
[10:21:26.926]                       })
[10:21:26.926]                     }
[10:21:26.926]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:26.926]                     base::options(mc.cores = 1L)
[10:21:26.926]                   }
[10:21:26.926]                   ...future.strategy.old <- future::plan("list")
[10:21:26.926]                   options(future.plan = NULL)
[10:21:26.926]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.926]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:26.926]                 }
[10:21:26.926]                 ...future.workdir <- getwd()
[10:21:26.926]             }
[10:21:26.926]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:26.926]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:26.926]         }
[10:21:26.926]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:26.926]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:26.926]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:26.926]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:26.926]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:26.926]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:26.926]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:26.926]             base::names(...future.oldOptions))
[10:21:26.926]     }
[10:21:26.926]     if (FALSE) {
[10:21:26.926]     }
[10:21:26.926]     else {
[10:21:26.926]         if (TRUE) {
[10:21:26.926]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:26.926]                 open = "w")
[10:21:26.926]         }
[10:21:26.926]         else {
[10:21:26.926]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:26.926]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:26.926]         }
[10:21:26.926]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:26.926]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:26.926]             base::sink(type = "output", split = FALSE)
[10:21:26.926]             base::close(...future.stdout)
[10:21:26.926]         }, add = TRUE)
[10:21:26.926]     }
[10:21:26.926]     ...future.frame <- base::sys.nframe()
[10:21:26.926]     ...future.conditions <- base::list()
[10:21:26.926]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:26.926]     if (FALSE) {
[10:21:26.926]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:26.926]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:26.926]     }
[10:21:26.926]     ...future.result <- base::tryCatch({
[10:21:26.926]         base::withCallingHandlers({
[10:21:26.926]             ...future.value <- base::withVisible(base::local({
[10:21:26.926]                 withCallingHandlers({
[10:21:26.926]                   {
[10:21:26.926]                     outer_function(1L)
[10:21:26.926]                   }
[10:21:26.926]                 }, immediateCondition = function(cond) {
[10:21:26.926]                   save_rds <- function (object, pathname, ...) 
[10:21:26.926]                   {
[10:21:26.926]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:26.926]                     if (file_test("-f", pathname_tmp)) {
[10:21:26.926]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.926]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:26.926]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.926]                         fi_tmp[["mtime"]])
[10:21:26.926]                     }
[10:21:26.926]                     tryCatch({
[10:21:26.926]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:26.926]                     }, error = function(ex) {
[10:21:26.926]                       msg <- conditionMessage(ex)
[10:21:26.926]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.926]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:26.926]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.926]                         fi_tmp[["mtime"]], msg)
[10:21:26.926]                       ex$message <- msg
[10:21:26.926]                       stop(ex)
[10:21:26.926]                     })
[10:21:26.926]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:26.926]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:26.926]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:26.926]                       fi_tmp <- file.info(pathname_tmp)
[10:21:26.926]                       fi <- file.info(pathname)
[10:21:26.926]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:26.926]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:26.926]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:26.926]                         fi[["size"]], fi[["mtime"]])
[10:21:26.926]                       stop(msg)
[10:21:26.926]                     }
[10:21:26.926]                     invisible(pathname)
[10:21:26.926]                   }
[10:21:26.926]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:26.926]                     rootPath = tempdir()) 
[10:21:26.926]                   {
[10:21:26.926]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:26.926]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:26.926]                       tmpdir = path, fileext = ".rds")
[10:21:26.926]                     save_rds(obj, file)
[10:21:26.926]                   }
[10:21:26.926]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0RHvXY/.future/immediateConditions")
[10:21:26.926]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.926]                   {
[10:21:26.926]                     inherits <- base::inherits
[10:21:26.926]                     invokeRestart <- base::invokeRestart
[10:21:26.926]                     is.null <- base::is.null
[10:21:26.926]                     muffled <- FALSE
[10:21:26.926]                     if (inherits(cond, "message")) {
[10:21:26.926]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:26.926]                       if (muffled) 
[10:21:26.926]                         invokeRestart("muffleMessage")
[10:21:26.926]                     }
[10:21:26.926]                     else if (inherits(cond, "warning")) {
[10:21:26.926]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:26.926]                       if (muffled) 
[10:21:26.926]                         invokeRestart("muffleWarning")
[10:21:26.926]                     }
[10:21:26.926]                     else if (inherits(cond, "condition")) {
[10:21:26.926]                       if (!is.null(pattern)) {
[10:21:26.926]                         computeRestarts <- base::computeRestarts
[10:21:26.926]                         grepl <- base::grepl
[10:21:26.926]                         restarts <- computeRestarts(cond)
[10:21:26.926]                         for (restart in restarts) {
[10:21:26.926]                           name <- restart$name
[10:21:26.926]                           if (is.null(name)) 
[10:21:26.926]                             next
[10:21:26.926]                           if (!grepl(pattern, name)) 
[10:21:26.926]                             next
[10:21:26.926]                           invokeRestart(restart)
[10:21:26.926]                           muffled <- TRUE
[10:21:26.926]                           break
[10:21:26.926]                         }
[10:21:26.926]                       }
[10:21:26.926]                     }
[10:21:26.926]                     invisible(muffled)
[10:21:26.926]                   }
[10:21:26.926]                   muffleCondition(cond)
[10:21:26.926]                 })
[10:21:26.926]             }))
[10:21:26.926]             future::FutureResult(value = ...future.value$value, 
[10:21:26.926]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.926]                   ...future.rng), globalenv = if (FALSE) 
[10:21:26.926]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:26.926]                     ...future.globalenv.names))
[10:21:26.926]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:26.926]         }, condition = base::local({
[10:21:26.926]             c <- base::c
[10:21:26.926]             inherits <- base::inherits
[10:21:26.926]             invokeRestart <- base::invokeRestart
[10:21:26.926]             length <- base::length
[10:21:26.926]             list <- base::list
[10:21:26.926]             seq.int <- base::seq.int
[10:21:26.926]             signalCondition <- base::signalCondition
[10:21:26.926]             sys.calls <- base::sys.calls
[10:21:26.926]             `[[` <- base::`[[`
[10:21:26.926]             `+` <- base::`+`
[10:21:26.926]             `<<-` <- base::`<<-`
[10:21:26.926]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:26.926]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:26.926]                   3L)]
[10:21:26.926]             }
[10:21:26.926]             function(cond) {
[10:21:26.926]                 is_error <- inherits(cond, "error")
[10:21:26.926]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:26.926]                   NULL)
[10:21:26.926]                 if (is_error) {
[10:21:26.926]                   sessionInformation <- function() {
[10:21:26.926]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:26.926]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:26.926]                       search = base::search(), system = base::Sys.info())
[10:21:26.926]                   }
[10:21:26.926]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.926]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:26.926]                     cond$call), session = sessionInformation(), 
[10:21:26.926]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:26.926]                   signalCondition(cond)
[10:21:26.926]                 }
[10:21:26.926]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:26.926]                 "immediateCondition"))) {
[10:21:26.926]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:26.926]                   ...future.conditions[[length(...future.conditions) + 
[10:21:26.926]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:26.926]                   if (TRUE && !signal) {
[10:21:26.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.926]                     {
[10:21:26.926]                       inherits <- base::inherits
[10:21:26.926]                       invokeRestart <- base::invokeRestart
[10:21:26.926]                       is.null <- base::is.null
[10:21:26.926]                       muffled <- FALSE
[10:21:26.926]                       if (inherits(cond, "message")) {
[10:21:26.926]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.926]                         if (muffled) 
[10:21:26.926]                           invokeRestart("muffleMessage")
[10:21:26.926]                       }
[10:21:26.926]                       else if (inherits(cond, "warning")) {
[10:21:26.926]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.926]                         if (muffled) 
[10:21:26.926]                           invokeRestart("muffleWarning")
[10:21:26.926]                       }
[10:21:26.926]                       else if (inherits(cond, "condition")) {
[10:21:26.926]                         if (!is.null(pattern)) {
[10:21:26.926]                           computeRestarts <- base::computeRestarts
[10:21:26.926]                           grepl <- base::grepl
[10:21:26.926]                           restarts <- computeRestarts(cond)
[10:21:26.926]                           for (restart in restarts) {
[10:21:26.926]                             name <- restart$name
[10:21:26.926]                             if (is.null(name)) 
[10:21:26.926]                               next
[10:21:26.926]                             if (!grepl(pattern, name)) 
[10:21:26.926]                               next
[10:21:26.926]                             invokeRestart(restart)
[10:21:26.926]                             muffled <- TRUE
[10:21:26.926]                             break
[10:21:26.926]                           }
[10:21:26.926]                         }
[10:21:26.926]                       }
[10:21:26.926]                       invisible(muffled)
[10:21:26.926]                     }
[10:21:26.926]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.926]                   }
[10:21:26.926]                 }
[10:21:26.926]                 else {
[10:21:26.926]                   if (TRUE) {
[10:21:26.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:26.926]                     {
[10:21:26.926]                       inherits <- base::inherits
[10:21:26.926]                       invokeRestart <- base::invokeRestart
[10:21:26.926]                       is.null <- base::is.null
[10:21:26.926]                       muffled <- FALSE
[10:21:26.926]                       if (inherits(cond, "message")) {
[10:21:26.926]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:26.926]                         if (muffled) 
[10:21:26.926]                           invokeRestart("muffleMessage")
[10:21:26.926]                       }
[10:21:26.926]                       else if (inherits(cond, "warning")) {
[10:21:26.926]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:26.926]                         if (muffled) 
[10:21:26.926]                           invokeRestart("muffleWarning")
[10:21:26.926]                       }
[10:21:26.926]                       else if (inherits(cond, "condition")) {
[10:21:26.926]                         if (!is.null(pattern)) {
[10:21:26.926]                           computeRestarts <- base::computeRestarts
[10:21:26.926]                           grepl <- base::grepl
[10:21:26.926]                           restarts <- computeRestarts(cond)
[10:21:26.926]                           for (restart in restarts) {
[10:21:26.926]                             name <- restart$name
[10:21:26.926]                             if (is.null(name)) 
[10:21:26.926]                               next
[10:21:26.926]                             if (!grepl(pattern, name)) 
[10:21:26.926]                               next
[10:21:26.926]                             invokeRestart(restart)
[10:21:26.926]                             muffled <- TRUE
[10:21:26.926]                             break
[10:21:26.926]                           }
[10:21:26.926]                         }
[10:21:26.926]                       }
[10:21:26.926]                       invisible(muffled)
[10:21:26.926]                     }
[10:21:26.926]                     muffleCondition(cond, pattern = "^muffle")
[10:21:26.926]                   }
[10:21:26.926]                 }
[10:21:26.926]             }
[10:21:26.926]         }))
[10:21:26.926]     }, error = function(ex) {
[10:21:26.926]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:26.926]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:26.926]                 ...future.rng), started = ...future.startTime, 
[10:21:26.926]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:26.926]             version = "1.8"), class = "FutureResult")
[10:21:26.926]     }, finally = {
[10:21:26.926]         if (!identical(...future.workdir, getwd())) 
[10:21:26.926]             setwd(...future.workdir)
[10:21:26.926]         {
[10:21:26.926]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:26.926]                 ...future.oldOptions$nwarnings <- NULL
[10:21:26.926]             }
[10:21:26.926]             base::options(...future.oldOptions)
[10:21:26.926]             if (.Platform$OS.type == "windows") {
[10:21:26.926]                 old_names <- names(...future.oldEnvVars)
[10:21:26.926]                 envs <- base::Sys.getenv()
[10:21:26.926]                 names <- names(envs)
[10:21:26.926]                 common <- intersect(names, old_names)
[10:21:26.926]                 added <- setdiff(names, old_names)
[10:21:26.926]                 removed <- setdiff(old_names, names)
[10:21:26.926]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:26.926]                   envs[common]]
[10:21:26.926]                 NAMES <- toupper(changed)
[10:21:26.926]                 args <- list()
[10:21:26.926]                 for (kk in seq_along(NAMES)) {
[10:21:26.926]                   name <- changed[[kk]]
[10:21:26.926]                   NAME <- NAMES[[kk]]
[10:21:26.926]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.926]                     next
[10:21:26.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.926]                 }
[10:21:26.926]                 NAMES <- toupper(added)
[10:21:26.926]                 for (kk in seq_along(NAMES)) {
[10:21:26.926]                   name <- added[[kk]]
[10:21:26.926]                   NAME <- NAMES[[kk]]
[10:21:26.926]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.926]                     next
[10:21:26.926]                   args[[name]] <- ""
[10:21:26.926]                 }
[10:21:26.926]                 NAMES <- toupper(removed)
[10:21:26.926]                 for (kk in seq_along(NAMES)) {
[10:21:26.926]                   name <- removed[[kk]]
[10:21:26.926]                   NAME <- NAMES[[kk]]
[10:21:26.926]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:26.926]                     next
[10:21:26.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:26.926]                 }
[10:21:26.926]                 if (length(args) > 0) 
[10:21:26.926]                   base::do.call(base::Sys.setenv, args = args)
[10:21:26.926]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:26.926]             }
[10:21:26.926]             else {
[10:21:26.926]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:26.926]             }
[10:21:26.926]             {
[10:21:26.926]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:26.926]                   0L) {
[10:21:26.926]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:26.926]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:26.926]                   base::options(opts)
[10:21:26.926]                 }
[10:21:26.926]                 {
[10:21:26.926]                   {
[10:21:26.926]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:26.926]                     NULL
[10:21:26.926]                   }
[10:21:26.926]                   options(future.plan = NULL)
[10:21:26.926]                   if (is.na(NA_character_)) 
[10:21:26.926]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:26.926]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:26.926]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:26.926]                     .init = FALSE)
[10:21:26.926]                 }
[10:21:26.926]             }
[10:21:26.926]         }
[10:21:26.926]     })
[10:21:26.926]     if (TRUE) {
[10:21:26.926]         base::sink(type = "output", split = FALSE)
[10:21:26.926]         if (TRUE) {
[10:21:26.926]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:26.926]         }
[10:21:26.926]         else {
[10:21:26.926]             ...future.result["stdout"] <- base::list(NULL)
[10:21:26.926]         }
[10:21:26.926]         base::close(...future.stdout)
[10:21:26.926]         ...future.stdout <- NULL
[10:21:26.926]     }
[10:21:26.926]     ...future.result$conditions <- ...future.conditions
[10:21:26.926]     ...future.result$finished <- base::Sys.time()
[10:21:26.926]     ...future.result
[10:21:26.926] }
[10:21:26.929] assign_globals() ...
[10:21:26.929] List of 3
[10:21:26.929]  $ outer_function:function (x)  
[10:21:26.929]  $ map           :function (.x, .f, ...)  
[10:21:26.929]  $ inner_function:function (x)  
[10:21:26.929]  - attr(*, "where")=List of 3
[10:21:26.929]   ..$ outer_function:<environment: R_EmptyEnv> 
[10:21:26.929]   ..$ map           :<environment: R_EmptyEnv> 
[10:21:26.929]   ..$ inner_function:<environment: R_EmptyEnv> 
[10:21:26.929]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:26.929]  - attr(*, "resolved")= logi FALSE
[10:21:26.929]  - attr(*, "total_size")= num 1254
[10:21:26.929]  - attr(*, "already-done")= logi TRUE
[10:21:26.935] - reassign environment for ‘outer_function’
[10:21:26.935] - copied ‘outer_function’ to environment
[10:21:26.936] - reassign environment for ‘map’
[10:21:26.936] - copied ‘map’ to environment
[10:21:26.936] - reassign environment for ‘inner_function’
[10:21:26.936] - copied ‘inner_function’ to environment
[10:21:26.936] assign_globals() ... done
[10:21:26.936] requestCore(): workers = 2
[10:21:26.938] MulticoreFuture started
[10:21:26.938] - Launch lazy future ... done
[10:21:26.939] run() for ‘MulticoreFuture’ ... done
[10:21:26.939] plan(): Setting new future strategy stack:
[10:21:26.939] result() for MulticoreFuture ...
[10:21:26.939] List of future strategies:
[10:21:26.939] 1. sequential:
[10:21:26.939]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:26.939]    - tweaked: FALSE
[10:21:26.939]    - call: NULL
[10:21:26.940] plan(): nbrOfWorkers() = 1
[10:21:26.943] plan(): Setting new future strategy stack:
[10:21:26.943] List of future strategies:
[10:21:26.943] 1. multicore:
[10:21:26.943]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:26.943]    - tweaked: FALSE
[10:21:26.943]    - call: plan(strategy)
[10:21:26.946] plan(): nbrOfWorkers() = 2
[10:21:26.947] result() for MulticoreFuture ...
[10:21:26.948] result() for MulticoreFuture ... done
[10:21:26.948] result() for MulticoreFuture ... done
[10:21:26.948] result() for MulticoreFuture ...
[10:21:26.948] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
- plan('multisession') ...
[10:21:26.950] plan(): Setting new future strategy stack:
[10:21:26.950] List of future strategies:
[10:21:26.950] 1. multisession:
[10:21:26.950]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:26.950]    - tweaked: FALSE
[10:21:26.950]    - call: plan(strategy)
[10:21:26.951] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:21:26.951] multisession:
[10:21:26.951] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:26.951] - tweaked: FALSE
[10:21:26.951] - call: plan(strategy)
[10:21:26.956] getGlobalsAndPackages() ...
[10:21:26.956] Not searching for globals
[10:21:26.956] - globals: [0] <none>
[10:21:26.956] getGlobalsAndPackages() ... DONE
[10:21:27.452] Packages needed by the future expression (n = 0): <none>
[10:21:27.452] Packages needed by future strategies (n = 0): <none>
[10:21:27.453] {
[10:21:27.453]     {
[10:21:27.453]         {
[10:21:27.453]             ...future.startTime <- base::Sys.time()
[10:21:27.453]             {
[10:21:27.453]                 {
[10:21:27.453]                   {
[10:21:27.453]                     {
[10:21:27.453]                       base::local({
[10:21:27.453]                         has_future <- base::requireNamespace("future", 
[10:21:27.453]                           quietly = TRUE)
[10:21:27.453]                         if (has_future) {
[10:21:27.453]                           ns <- base::getNamespace("future")
[10:21:27.453]                           version <- ns[[".package"]][["version"]]
[10:21:27.453]                           if (is.null(version)) 
[10:21:27.453]                             version <- utils::packageVersion("future")
[10:21:27.453]                         }
[10:21:27.453]                         else {
[10:21:27.453]                           version <- NULL
[10:21:27.453]                         }
[10:21:27.453]                         if (!has_future || version < "1.8.0") {
[10:21:27.453]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:27.453]                             "", base::R.version$version.string), 
[10:21:27.453]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:27.453]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:27.453]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:27.453]                               "release", "version")], collapse = " "), 
[10:21:27.453]                             hostname = base::Sys.info()[["nodename"]])
[10:21:27.453]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:27.453]                             info)
[10:21:27.453]                           info <- base::paste(info, collapse = "; ")
[10:21:27.453]                           if (!has_future) {
[10:21:27.453]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:27.453]                               info)
[10:21:27.453]                           }
[10:21:27.453]                           else {
[10:21:27.453]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:27.453]                               info, version)
[10:21:27.453]                           }
[10:21:27.453]                           base::stop(msg)
[10:21:27.453]                         }
[10:21:27.453]                       })
[10:21:27.453]                     }
[10:21:27.453]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:27.453]                     base::options(mc.cores = 1L)
[10:21:27.453]                   }
[10:21:27.453]                   ...future.strategy.old <- future::plan("list")
[10:21:27.453]                   options(future.plan = NULL)
[10:21:27.453]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:27.453]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:27.453]                 }
[10:21:27.453]                 ...future.workdir <- getwd()
[10:21:27.453]             }
[10:21:27.453]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:27.453]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:27.453]         }
[10:21:27.453]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:27.453]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:27.453]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:27.453]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:27.453]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:27.453]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:27.453]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:27.453]             base::names(...future.oldOptions))
[10:21:27.453]     }
[10:21:27.453]     if (FALSE) {
[10:21:27.453]     }
[10:21:27.453]     else {
[10:21:27.453]         if (TRUE) {
[10:21:27.453]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:27.453]                 open = "w")
[10:21:27.453]         }
[10:21:27.453]         else {
[10:21:27.453]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:27.453]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:27.453]         }
[10:21:27.453]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:27.453]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:27.453]             base::sink(type = "output", split = FALSE)
[10:21:27.453]             base::close(...future.stdout)
[10:21:27.453]         }, add = TRUE)
[10:21:27.453]     }
[10:21:27.453]     ...future.frame <- base::sys.nframe()
[10:21:27.453]     ...future.conditions <- base::list()
[10:21:27.453]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:27.453]     if (FALSE) {
[10:21:27.453]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:27.453]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:27.453]     }
[10:21:27.453]     ...future.result <- base::tryCatch({
[10:21:27.453]         base::withCallingHandlers({
[10:21:27.453]             ...future.value <- base::withVisible(base::local({
[10:21:27.453]                 ...future.makeSendCondition <- base::local({
[10:21:27.453]                   sendCondition <- NULL
[10:21:27.453]                   function(frame = 1L) {
[10:21:27.453]                     if (is.function(sendCondition)) 
[10:21:27.453]                       return(sendCondition)
[10:21:27.453]                     ns <- getNamespace("parallel")
[10:21:27.453]                     if (exists("sendData", mode = "function", 
[10:21:27.453]                       envir = ns)) {
[10:21:27.453]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:27.453]                         envir = ns)
[10:21:27.453]                       envir <- sys.frame(frame)
[10:21:27.453]                       master <- NULL
[10:21:27.453]                       while (!identical(envir, .GlobalEnv) && 
[10:21:27.453]                         !identical(envir, emptyenv())) {
[10:21:27.453]                         if (exists("master", mode = "list", envir = envir, 
[10:21:27.453]                           inherits = FALSE)) {
[10:21:27.453]                           master <- get("master", mode = "list", 
[10:21:27.453]                             envir = envir, inherits = FALSE)
[10:21:27.453]                           if (inherits(master, c("SOCKnode", 
[10:21:27.453]                             "SOCK0node"))) {
[10:21:27.453]                             sendCondition <<- function(cond) {
[10:21:27.453]                               data <- list(type = "VALUE", value = cond, 
[10:21:27.453]                                 success = TRUE)
[10:21:27.453]                               parallel_sendData(master, data)
[10:21:27.453]                             }
[10:21:27.453]                             return(sendCondition)
[10:21:27.453]                           }
[10:21:27.453]                         }
[10:21:27.453]                         frame <- frame + 1L
[10:21:27.453]                         envir <- sys.frame(frame)
[10:21:27.453]                       }
[10:21:27.453]                     }
[10:21:27.453]                     sendCondition <<- function(cond) NULL
[10:21:27.453]                   }
[10:21:27.453]                 })
[10:21:27.453]                 withCallingHandlers({
[10:21:27.453]                   NA
[10:21:27.453]                 }, immediateCondition = function(cond) {
[10:21:27.453]                   sendCondition <- ...future.makeSendCondition()
[10:21:27.453]                   sendCondition(cond)
[10:21:27.453]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:27.453]                   {
[10:21:27.453]                     inherits <- base::inherits
[10:21:27.453]                     invokeRestart <- base::invokeRestart
[10:21:27.453]                     is.null <- base::is.null
[10:21:27.453]                     muffled <- FALSE
[10:21:27.453]                     if (inherits(cond, "message")) {
[10:21:27.453]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:27.453]                       if (muffled) 
[10:21:27.453]                         invokeRestart("muffleMessage")
[10:21:27.453]                     }
[10:21:27.453]                     else if (inherits(cond, "warning")) {
[10:21:27.453]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:27.453]                       if (muffled) 
[10:21:27.453]                         invokeRestart("muffleWarning")
[10:21:27.453]                     }
[10:21:27.453]                     else if (inherits(cond, "condition")) {
[10:21:27.453]                       if (!is.null(pattern)) {
[10:21:27.453]                         computeRestarts <- base::computeRestarts
[10:21:27.453]                         grepl <- base::grepl
[10:21:27.453]                         restarts <- computeRestarts(cond)
[10:21:27.453]                         for (restart in restarts) {
[10:21:27.453]                           name <- restart$name
[10:21:27.453]                           if (is.null(name)) 
[10:21:27.453]                             next
[10:21:27.453]                           if (!grepl(pattern, name)) 
[10:21:27.453]                             next
[10:21:27.453]                           invokeRestart(restart)
[10:21:27.453]                           muffled <- TRUE
[10:21:27.453]                           break
[10:21:27.453]                         }
[10:21:27.453]                       }
[10:21:27.453]                     }
[10:21:27.453]                     invisible(muffled)
[10:21:27.453]                   }
[10:21:27.453]                   muffleCondition(cond)
[10:21:27.453]                 })
[10:21:27.453]             }))
[10:21:27.453]             future::FutureResult(value = ...future.value$value, 
[10:21:27.453]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:27.453]                   ...future.rng), globalenv = if (FALSE) 
[10:21:27.453]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:27.453]                     ...future.globalenv.names))
[10:21:27.453]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:27.453]         }, condition = base::local({
[10:21:27.453]             c <- base::c
[10:21:27.453]             inherits <- base::inherits
[10:21:27.453]             invokeRestart <- base::invokeRestart
[10:21:27.453]             length <- base::length
[10:21:27.453]             list <- base::list
[10:21:27.453]             seq.int <- base::seq.int
[10:21:27.453]             signalCondition <- base::signalCondition
[10:21:27.453]             sys.calls <- base::sys.calls
[10:21:27.453]             `[[` <- base::`[[`
[10:21:27.453]             `+` <- base::`+`
[10:21:27.453]             `<<-` <- base::`<<-`
[10:21:27.453]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:27.453]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:27.453]                   3L)]
[10:21:27.453]             }
[10:21:27.453]             function(cond) {
[10:21:27.453]                 is_error <- inherits(cond, "error")
[10:21:27.453]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:27.453]                   NULL)
[10:21:27.453]                 if (is_error) {
[10:21:27.453]                   sessionInformation <- function() {
[10:21:27.453]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:27.453]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:27.453]                       search = base::search(), system = base::Sys.info())
[10:21:27.453]                   }
[10:21:27.453]                   ...future.conditions[[length(...future.conditions) + 
[10:21:27.453]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:27.453]                     cond$call), session = sessionInformation(), 
[10:21:27.453]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:27.453]                   signalCondition(cond)
[10:21:27.453]                 }
[10:21:27.453]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:27.453]                 "immediateCondition"))) {
[10:21:27.453]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:27.453]                   ...future.conditions[[length(...future.conditions) + 
[10:21:27.453]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:27.453]                   if (TRUE && !signal) {
[10:21:27.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:27.453]                     {
[10:21:27.453]                       inherits <- base::inherits
[10:21:27.453]                       invokeRestart <- base::invokeRestart
[10:21:27.453]                       is.null <- base::is.null
[10:21:27.453]                       muffled <- FALSE
[10:21:27.453]                       if (inherits(cond, "message")) {
[10:21:27.453]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:27.453]                         if (muffled) 
[10:21:27.453]                           invokeRestart("muffleMessage")
[10:21:27.453]                       }
[10:21:27.453]                       else if (inherits(cond, "warning")) {
[10:21:27.453]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:27.453]                         if (muffled) 
[10:21:27.453]                           invokeRestart("muffleWarning")
[10:21:27.453]                       }
[10:21:27.453]                       else if (inherits(cond, "condition")) {
[10:21:27.453]                         if (!is.null(pattern)) {
[10:21:27.453]                           computeRestarts <- base::computeRestarts
[10:21:27.453]                           grepl <- base::grepl
[10:21:27.453]                           restarts <- computeRestarts(cond)
[10:21:27.453]                           for (restart in restarts) {
[10:21:27.453]                             name <- restart$name
[10:21:27.453]                             if (is.null(name)) 
[10:21:27.453]                               next
[10:21:27.453]                             if (!grepl(pattern, name)) 
[10:21:27.453]                               next
[10:21:27.453]                             invokeRestart(restart)
[10:21:27.453]                             muffled <- TRUE
[10:21:27.453]                             break
[10:21:27.453]                           }
[10:21:27.453]                         }
[10:21:27.453]                       }
[10:21:27.453]                       invisible(muffled)
[10:21:27.453]                     }
[10:21:27.453]                     muffleCondition(cond, pattern = "^muffle")
[10:21:27.453]                   }
[10:21:27.453]                 }
[10:21:27.453]                 else {
[10:21:27.453]                   if (TRUE) {
[10:21:27.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:27.453]                     {
[10:21:27.453]                       inherits <- base::inherits
[10:21:27.453]                       invokeRestart <- base::invokeRestart
[10:21:27.453]                       is.null <- base::is.null
[10:21:27.453]                       muffled <- FALSE
[10:21:27.453]                       if (inherits(cond, "message")) {
[10:21:27.453]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:27.453]                         if (muffled) 
[10:21:27.453]                           invokeRestart("muffleMessage")
[10:21:27.453]                       }
[10:21:27.453]                       else if (inherits(cond, "warning")) {
[10:21:27.453]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:27.453]                         if (muffled) 
[10:21:27.453]                           invokeRestart("muffleWarning")
[10:21:27.453]                       }
[10:21:27.453]                       else if (inherits(cond, "condition")) {
[10:21:27.453]                         if (!is.null(pattern)) {
[10:21:27.453]                           computeRestarts <- base::computeRestarts
[10:21:27.453]                           grepl <- base::grepl
[10:21:27.453]                           restarts <- computeRestarts(cond)
[10:21:27.453]                           for (restart in restarts) {
[10:21:27.453]                             name <- restart$name
[10:21:27.453]                             if (is.null(name)) 
[10:21:27.453]                               next
[10:21:27.453]                             if (!grepl(pattern, name)) 
[10:21:27.453]                               next
[10:21:27.453]                             invokeRestart(restart)
[10:21:27.453]                             muffled <- TRUE
[10:21:27.453]                             break
[10:21:27.453]                           }
[10:21:27.453]                         }
[10:21:27.453]                       }
[10:21:27.453]                       invisible(muffled)
[10:21:27.453]                     }
[10:21:27.453]                     muffleCondition(cond, pattern = "^muffle")
[10:21:27.453]                   }
[10:21:27.453]                 }
[10:21:27.453]             }
[10:21:27.453]         }))
[10:21:27.453]     }, error = function(ex) {
[10:21:27.453]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:27.453]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:27.453]                 ...future.rng), started = ...future.startTime, 
[10:21:27.453]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:27.453]             version = "1.8"), class = "FutureResult")
[10:21:27.453]     }, finally = {
[10:21:27.453]         if (!identical(...future.workdir, getwd())) 
[10:21:27.453]             setwd(...future.workdir)
[10:21:27.453]         {
[10:21:27.453]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:27.453]                 ...future.oldOptions$nwarnings <- NULL
[10:21:27.453]             }
[10:21:27.453]             base::options(...future.oldOptions)
[10:21:27.453]             if (.Platform$OS.type == "windows") {
[10:21:27.453]                 old_names <- names(...future.oldEnvVars)
[10:21:27.453]                 envs <- base::Sys.getenv()
[10:21:27.453]                 names <- names(envs)
[10:21:27.453]                 common <- intersect(names, old_names)
[10:21:27.453]                 added <- setdiff(names, old_names)
[10:21:27.453]                 removed <- setdiff(old_names, names)
[10:21:27.453]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:27.453]                   envs[common]]
[10:21:27.453]                 NAMES <- toupper(changed)
[10:21:27.453]                 args <- list()
[10:21:27.453]                 for (kk in seq_along(NAMES)) {
[10:21:27.453]                   name <- changed[[kk]]
[10:21:27.453]                   NAME <- NAMES[[kk]]
[10:21:27.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:27.453]                     next
[10:21:27.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:27.453]                 }
[10:21:27.453]                 NAMES <- toupper(added)
[10:21:27.453]                 for (kk in seq_along(NAMES)) {
[10:21:27.453]                   name <- added[[kk]]
[10:21:27.453]                   NAME <- NAMES[[kk]]
[10:21:27.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:27.453]                     next
[10:21:27.453]                   args[[name]] <- ""
[10:21:27.453]                 }
[10:21:27.453]                 NAMES <- toupper(removed)
[10:21:27.453]                 for (kk in seq_along(NAMES)) {
[10:21:27.453]                   name <- removed[[kk]]
[10:21:27.453]                   NAME <- NAMES[[kk]]
[10:21:27.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:27.453]                     next
[10:21:27.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:27.453]                 }
[10:21:27.453]                 if (length(args) > 0) 
[10:21:27.453]                   base::do.call(base::Sys.setenv, args = args)
[10:21:27.453]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:27.453]             }
[10:21:27.453]             else {
[10:21:27.453]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:27.453]             }
[10:21:27.453]             {
[10:21:27.453]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:27.453]                   0L) {
[10:21:27.453]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:27.453]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:27.453]                   base::options(opts)
[10:21:27.453]                 }
[10:21:27.453]                 {
[10:21:27.453]                   {
[10:21:27.453]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:27.453]                     NULL
[10:21:27.453]                   }
[10:21:27.453]                   options(future.plan = NULL)
[10:21:27.453]                   if (is.na(NA_character_)) 
[10:21:27.453]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:27.453]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:27.453]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:27.453]                     .init = FALSE)
[10:21:27.453]                 }
[10:21:27.453]             }
[10:21:27.453]         }
[10:21:27.453]     })
[10:21:27.453]     if (TRUE) {
[10:21:27.453]         base::sink(type = "output", split = FALSE)
[10:21:27.453]         if (TRUE) {
[10:21:27.453]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:27.453]         }
[10:21:27.453]         else {
[10:21:27.453]             ...future.result["stdout"] <- base::list(NULL)
[10:21:27.453]         }
[10:21:27.453]         base::close(...future.stdout)
[10:21:27.453]         ...future.stdout <- NULL
[10:21:27.453]     }
[10:21:27.453]     ...future.result$conditions <- ...future.conditions
[10:21:27.453]     ...future.result$finished <- base::Sys.time()
[10:21:27.453]     ...future.result
[10:21:27.453] }
[10:21:27.506] MultisessionFuture started
[10:21:27.507] result() for ClusterFuture ...
[10:21:27.507] receiveMessageFromWorker() for ClusterFuture ...
[10:21:27.507] - Validating connection of MultisessionFuture
[10:21:27.538] - received message: FutureResult
[10:21:27.539] - Received FutureResult
[10:21:27.539] - Erased future from FutureRegistry
[10:21:27.539] result() for ClusterFuture ...
[10:21:27.539] - result already collected: FutureResult
[10:21:27.539] result() for ClusterFuture ... done
[10:21:27.539] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:27.539] result() for ClusterFuture ... done
[10:21:27.539] result() for ClusterFuture ...
[10:21:27.539] - result already collected: FutureResult
[10:21:27.540] result() for ClusterFuture ... done
[10:21:27.540] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:21:27.541] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[10:21:27.542] getGlobalsAndPackages() ...
[10:21:27.542] Searching for globals...
[10:21:27.543] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:21:27.543] Searching for globals ... DONE
[10:21:27.543] Resolving globals: FALSE
[10:21:27.544] The total size of the 2 globals is 401 bytes (401 bytes)
[10:21:27.544] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[10:21:27.544] - globals: [2] ‘weight’, ‘group’
[10:21:27.545] - packages: [1] ‘stats’
[10:21:27.545] getGlobalsAndPackages() ... DONE
[10:21:27.545] run() for ‘Future’ ...
[10:21:27.545] - state: ‘created’
[10:21:27.545] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:27.559] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:27.560] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:27.560]   - Field: ‘node’
[10:21:27.560]   - Field: ‘label’
[10:21:27.560]   - Field: ‘local’
[10:21:27.560]   - Field: ‘owner’
[10:21:27.560]   - Field: ‘envir’
[10:21:27.560]   - Field: ‘workers’
[10:21:27.560]   - Field: ‘packages’
[10:21:27.560]   - Field: ‘gc’
[10:21:27.561]   - Field: ‘conditions’
[10:21:27.561]   - Field: ‘persistent’
[10:21:27.561]   - Field: ‘expr’
[10:21:27.561]   - Field: ‘uuid’
[10:21:27.561]   - Field: ‘seed’
[10:21:27.561]   - Field: ‘version’
[10:21:27.561]   - Field: ‘result’
[10:21:27.561]   - Field: ‘asynchronous’
[10:21:27.561]   - Field: ‘calls’
[10:21:27.561]   - Field: ‘globals’
[10:21:27.561]   - Field: ‘stdout’
[10:21:27.562]   - Field: ‘earlySignal’
[10:21:27.562]   - Field: ‘lazy’
[10:21:27.562]   - Field: ‘state’
[10:21:27.562] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:27.562] - Launch lazy future ...
[10:21:27.562] Packages needed by the future expression (n = 1): ‘stats’
[10:21:27.562] Packages needed by future strategies (n = 0): <none>
[10:21:27.563] {
[10:21:27.563]     {
[10:21:27.563]         {
[10:21:27.563]             ...future.startTime <- base::Sys.time()
[10:21:27.563]             {
[10:21:27.563]                 {
[10:21:27.563]                   {
[10:21:27.563]                     {
[10:21:27.563]                       {
[10:21:27.563]                         base::local({
[10:21:27.563]                           has_future <- base::requireNamespace("future", 
[10:21:27.563]                             quietly = TRUE)
[10:21:27.563]                           if (has_future) {
[10:21:27.563]                             ns <- base::getNamespace("future")
[10:21:27.563]                             version <- ns[[".package"]][["version"]]
[10:21:27.563]                             if (is.null(version)) 
[10:21:27.563]                               version <- utils::packageVersion("future")
[10:21:27.563]                           }
[10:21:27.563]                           else {
[10:21:27.563]                             version <- NULL
[10:21:27.563]                           }
[10:21:27.563]                           if (!has_future || version < "1.8.0") {
[10:21:27.563]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:27.563]                               "", base::R.version$version.string), 
[10:21:27.563]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:27.563]                                 base::R.version$platform, 8 * 
[10:21:27.563]                                   base::.Machine$sizeof.pointer), 
[10:21:27.563]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:27.563]                                 "release", "version")], collapse = " "), 
[10:21:27.563]                               hostname = base::Sys.info()[["nodename"]])
[10:21:27.563]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:27.563]                               info)
[10:21:27.563]                             info <- base::paste(info, collapse = "; ")
[10:21:27.563]                             if (!has_future) {
[10:21:27.563]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:27.563]                                 info)
[10:21:27.563]                             }
[10:21:27.563]                             else {
[10:21:27.563]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:27.563]                                 info, version)
[10:21:27.563]                             }
[10:21:27.563]                             base::stop(msg)
[10:21:27.563]                           }
[10:21:27.563]                         })
[10:21:27.563]                       }
[10:21:27.563]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:27.563]                       base::options(mc.cores = 1L)
[10:21:27.563]                     }
[10:21:27.563]                     base::local({
[10:21:27.563]                       for (pkg in "stats") {
[10:21:27.563]                         base::loadNamespace(pkg)
[10:21:27.563]                         base::library(pkg, character.only = TRUE)
[10:21:27.563]                       }
[10:21:27.563]                     })
[10:21:27.563]                   }
[10:21:27.563]                   ...future.strategy.old <- future::plan("list")
[10:21:27.563]                   options(future.plan = NULL)
[10:21:27.563]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:27.563]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:27.563]                 }
[10:21:27.563]                 ...future.workdir <- getwd()
[10:21:27.563]             }
[10:21:27.563]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:27.563]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:27.563]         }
[10:21:27.563]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:27.563]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:27.563]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:27.563]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:27.563]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:27.563]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:27.563]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:27.563]             base::names(...future.oldOptions))
[10:21:27.563]     }
[10:21:27.563]     if (FALSE) {
[10:21:27.563]     }
[10:21:27.563]     else {
[10:21:27.563]         if (TRUE) {
[10:21:27.563]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:27.563]                 open = "w")
[10:21:27.563]         }
[10:21:27.563]         else {
[10:21:27.563]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:27.563]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:27.563]         }
[10:21:27.563]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:27.563]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:27.563]             base::sink(type = "output", split = FALSE)
[10:21:27.563]             base::close(...future.stdout)
[10:21:27.563]         }, add = TRUE)
[10:21:27.563]     }
[10:21:27.563]     ...future.frame <- base::sys.nframe()
[10:21:27.563]     ...future.conditions <- base::list()
[10:21:27.563]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:27.563]     if (FALSE) {
[10:21:27.563]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:27.563]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:27.563]     }
[10:21:27.563]     ...future.result <- base::tryCatch({
[10:21:27.563]         base::withCallingHandlers({
[10:21:27.563]             ...future.value <- base::withVisible(base::local({
[10:21:27.563]                 ...future.makeSendCondition <- base::local({
[10:21:27.563]                   sendCondition <- NULL
[10:21:27.563]                   function(frame = 1L) {
[10:21:27.563]                     if (is.function(sendCondition)) 
[10:21:27.563]                       return(sendCondition)
[10:21:27.563]                     ns <- getNamespace("parallel")
[10:21:27.563]                     if (exists("sendData", mode = "function", 
[10:21:27.563]                       envir = ns)) {
[10:21:27.563]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:27.563]                         envir = ns)
[10:21:27.563]                       envir <- sys.frame(frame)
[10:21:27.563]                       master <- NULL
[10:21:27.563]                       while (!identical(envir, .GlobalEnv) && 
[10:21:27.563]                         !identical(envir, emptyenv())) {
[10:21:27.563]                         if (exists("master", mode = "list", envir = envir, 
[10:21:27.563]                           inherits = FALSE)) {
[10:21:27.563]                           master <- get("master", mode = "list", 
[10:21:27.563]                             envir = envir, inherits = FALSE)
[10:21:27.563]                           if (inherits(master, c("SOCKnode", 
[10:21:27.563]                             "SOCK0node"))) {
[10:21:27.563]                             sendCondition <<- function(cond) {
[10:21:27.563]                               data <- list(type = "VALUE", value = cond, 
[10:21:27.563]                                 success = TRUE)
[10:21:27.563]                               parallel_sendData(master, data)
[10:21:27.563]                             }
[10:21:27.563]                             return(sendCondition)
[10:21:27.563]                           }
[10:21:27.563]                         }
[10:21:27.563]                         frame <- frame + 1L
[10:21:27.563]                         envir <- sys.frame(frame)
[10:21:27.563]                       }
[10:21:27.563]                     }
[10:21:27.563]                     sendCondition <<- function(cond) NULL
[10:21:27.563]                   }
[10:21:27.563]                 })
[10:21:27.563]                 withCallingHandlers({
[10:21:27.563]                   {
[10:21:27.563]                     lm(weight ~ group - 1)
[10:21:27.563]                   }
[10:21:27.563]                 }, immediateCondition = function(cond) {
[10:21:27.563]                   sendCondition <- ...future.makeSendCondition()
[10:21:27.563]                   sendCondition(cond)
[10:21:27.563]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:27.563]                   {
[10:21:27.563]                     inherits <- base::inherits
[10:21:27.563]                     invokeRestart <- base::invokeRestart
[10:21:27.563]                     is.null <- base::is.null
[10:21:27.563]                     muffled <- FALSE
[10:21:27.563]                     if (inherits(cond, "message")) {
[10:21:27.563]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:27.563]                       if (muffled) 
[10:21:27.563]                         invokeRestart("muffleMessage")
[10:21:27.563]                     }
[10:21:27.563]                     else if (inherits(cond, "warning")) {
[10:21:27.563]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:27.563]                       if (muffled) 
[10:21:27.563]                         invokeRestart("muffleWarning")
[10:21:27.563]                     }
[10:21:27.563]                     else if (inherits(cond, "condition")) {
[10:21:27.563]                       if (!is.null(pattern)) {
[10:21:27.563]                         computeRestarts <- base::computeRestarts
[10:21:27.563]                         grepl <- base::grepl
[10:21:27.563]                         restarts <- computeRestarts(cond)
[10:21:27.563]                         for (restart in restarts) {
[10:21:27.563]                           name <- restart$name
[10:21:27.563]                           if (is.null(name)) 
[10:21:27.563]                             next
[10:21:27.563]                           if (!grepl(pattern, name)) 
[10:21:27.563]                             next
[10:21:27.563]                           invokeRestart(restart)
[10:21:27.563]                           muffled <- TRUE
[10:21:27.563]                           break
[10:21:27.563]                         }
[10:21:27.563]                       }
[10:21:27.563]                     }
[10:21:27.563]                     invisible(muffled)
[10:21:27.563]                   }
[10:21:27.563]                   muffleCondition(cond)
[10:21:27.563]                 })
[10:21:27.563]             }))
[10:21:27.563]             future::FutureResult(value = ...future.value$value, 
[10:21:27.563]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:27.563]                   ...future.rng), globalenv = if (FALSE) 
[10:21:27.563]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:27.563]                     ...future.globalenv.names))
[10:21:27.563]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:27.563]         }, condition = base::local({
[10:21:27.563]             c <- base::c
[10:21:27.563]             inherits <- base::inherits
[10:21:27.563]             invokeRestart <- base::invokeRestart
[10:21:27.563]             length <- base::length
[10:21:27.563]             list <- base::list
[10:21:27.563]             seq.int <- base::seq.int
[10:21:27.563]             signalCondition <- base::signalCondition
[10:21:27.563]             sys.calls <- base::sys.calls
[10:21:27.563]             `[[` <- base::`[[`
[10:21:27.563]             `+` <- base::`+`
[10:21:27.563]             `<<-` <- base::`<<-`
[10:21:27.563]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:27.563]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:27.563]                   3L)]
[10:21:27.563]             }
[10:21:27.563]             function(cond) {
[10:21:27.563]                 is_error <- inherits(cond, "error")
[10:21:27.563]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:27.563]                   NULL)
[10:21:27.563]                 if (is_error) {
[10:21:27.563]                   sessionInformation <- function() {
[10:21:27.563]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:27.563]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:27.563]                       search = base::search(), system = base::Sys.info())
[10:21:27.563]                   }
[10:21:27.563]                   ...future.conditions[[length(...future.conditions) + 
[10:21:27.563]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:27.563]                     cond$call), session = sessionInformation(), 
[10:21:27.563]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:27.563]                   signalCondition(cond)
[10:21:27.563]                 }
[10:21:27.563]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:27.563]                 "immediateCondition"))) {
[10:21:27.563]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:27.563]                   ...future.conditions[[length(...future.conditions) + 
[10:21:27.563]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:27.563]                   if (TRUE && !signal) {
[10:21:27.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:27.563]                     {
[10:21:27.563]                       inherits <- base::inherits
[10:21:27.563]                       invokeRestart <- base::invokeRestart
[10:21:27.563]                       is.null <- base::is.null
[10:21:27.563]                       muffled <- FALSE
[10:21:27.563]                       if (inherits(cond, "message")) {
[10:21:27.563]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:27.563]                         if (muffled) 
[10:21:27.563]                           invokeRestart("muffleMessage")
[10:21:27.563]                       }
[10:21:27.563]                       else if (inherits(cond, "warning")) {
[10:21:27.563]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:27.563]                         if (muffled) 
[10:21:27.563]                           invokeRestart("muffleWarning")
[10:21:27.563]                       }
[10:21:27.563]                       else if (inherits(cond, "condition")) {
[10:21:27.563]                         if (!is.null(pattern)) {
[10:21:27.563]                           computeRestarts <- base::computeRestarts
[10:21:27.563]                           grepl <- base::grepl
[10:21:27.563]                           restarts <- computeRestarts(cond)
[10:21:27.563]                           for (restart in restarts) {
[10:21:27.563]                             name <- restart$name
[10:21:27.563]                             if (is.null(name)) 
[10:21:27.563]                               next
[10:21:27.563]                             if (!grepl(pattern, name)) 
[10:21:27.563]                               next
[10:21:27.563]                             invokeRestart(restart)
[10:21:27.563]                             muffled <- TRUE
[10:21:27.563]                             break
[10:21:27.563]                           }
[10:21:27.563]                         }
[10:21:27.563]                       }
[10:21:27.563]                       invisible(muffled)
[10:21:27.563]                     }
[10:21:27.563]                     muffleCondition(cond, pattern = "^muffle")
[10:21:27.563]                   }
[10:21:27.563]                 }
[10:21:27.563]                 else {
[10:21:27.563]                   if (TRUE) {
[10:21:27.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:27.563]                     {
[10:21:27.563]                       inherits <- base::inherits
[10:21:27.563]                       invokeRestart <- base::invokeRestart
[10:21:27.563]                       is.null <- base::is.null
[10:21:27.563]                       muffled <- FALSE
[10:21:27.563]                       if (inherits(cond, "message")) {
[10:21:27.563]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:27.563]                         if (muffled) 
[10:21:27.563]                           invokeRestart("muffleMessage")
[10:21:27.563]                       }
[10:21:27.563]                       else if (inherits(cond, "warning")) {
[10:21:27.563]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:27.563]                         if (muffled) 
[10:21:27.563]                           invokeRestart("muffleWarning")
[10:21:27.563]                       }
[10:21:27.563]                       else if (inherits(cond, "condition")) {
[10:21:27.563]                         if (!is.null(pattern)) {
[10:21:27.563]                           computeRestarts <- base::computeRestarts
[10:21:27.563]                           grepl <- base::grepl
[10:21:27.563]                           restarts <- computeRestarts(cond)
[10:21:27.563]                           for (restart in restarts) {
[10:21:27.563]                             name <- restart$name
[10:21:27.563]                             if (is.null(name)) 
[10:21:27.563]                               next
[10:21:27.563]                             if (!grepl(pattern, name)) 
[10:21:27.563]                               next
[10:21:27.563]                             invokeRestart(restart)
[10:21:27.563]                             muffled <- TRUE
[10:21:27.563]                             break
[10:21:27.563]                           }
[10:21:27.563]                         }
[10:21:27.563]                       }
[10:21:27.563]                       invisible(muffled)
[10:21:27.563]                     }
[10:21:27.563]                     muffleCondition(cond, pattern = "^muffle")
[10:21:27.563]                   }
[10:21:27.563]                 }
[10:21:27.563]             }
[10:21:27.563]         }))
[10:21:27.563]     }, error = function(ex) {
[10:21:27.563]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:27.563]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:27.563]                 ...future.rng), started = ...future.startTime, 
[10:21:27.563]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:27.563]             version = "1.8"), class = "FutureResult")
[10:21:27.563]     }, finally = {
[10:21:27.563]         if (!identical(...future.workdir, getwd())) 
[10:21:27.563]             setwd(...future.workdir)
[10:21:27.563]         {
[10:21:27.563]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:27.563]                 ...future.oldOptions$nwarnings <- NULL
[10:21:27.563]             }
[10:21:27.563]             base::options(...future.oldOptions)
[10:21:27.563]             if (.Platform$OS.type == "windows") {
[10:21:27.563]                 old_names <- names(...future.oldEnvVars)
[10:21:27.563]                 envs <- base::Sys.getenv()
[10:21:27.563]                 names <- names(envs)
[10:21:27.563]                 common <- intersect(names, old_names)
[10:21:27.563]                 added <- setdiff(names, old_names)
[10:21:27.563]                 removed <- setdiff(old_names, names)
[10:21:27.563]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:27.563]                   envs[common]]
[10:21:27.563]                 NAMES <- toupper(changed)
[10:21:27.563]                 args <- list()
[10:21:27.563]                 for (kk in seq_along(NAMES)) {
[10:21:27.563]                   name <- changed[[kk]]
[10:21:27.563]                   NAME <- NAMES[[kk]]
[10:21:27.563]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:27.563]                     next
[10:21:27.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:27.563]                 }
[10:21:27.563]                 NAMES <- toupper(added)
[10:21:27.563]                 for (kk in seq_along(NAMES)) {
[10:21:27.563]                   name <- added[[kk]]
[10:21:27.563]                   NAME <- NAMES[[kk]]
[10:21:27.563]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:27.563]                     next
[10:21:27.563]                   args[[name]] <- ""
[10:21:27.563]                 }
[10:21:27.563]                 NAMES <- toupper(removed)
[10:21:27.563]                 for (kk in seq_along(NAMES)) {
[10:21:27.563]                   name <- removed[[kk]]
[10:21:27.563]                   NAME <- NAMES[[kk]]
[10:21:27.563]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:27.563]                     next
[10:21:27.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:27.563]                 }
[10:21:27.563]                 if (length(args) > 0) 
[10:21:27.563]                   base::do.call(base::Sys.setenv, args = args)
[10:21:27.563]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:27.563]             }
[10:21:27.563]             else {
[10:21:27.563]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:27.563]             }
[10:21:27.563]             {
[10:21:27.563]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:27.563]                   0L) {
[10:21:27.563]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:27.563]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:27.563]                   base::options(opts)
[10:21:27.563]                 }
[10:21:27.563]                 {
[10:21:27.563]                   {
[10:21:27.563]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:27.563]                     NULL
[10:21:27.563]                   }
[10:21:27.563]                   options(future.plan = NULL)
[10:21:27.563]                   if (is.na(NA_character_)) 
[10:21:27.563]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:27.563]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:27.563]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:27.563]                     .init = FALSE)
[10:21:27.563]                 }
[10:21:27.563]             }
[10:21:27.563]         }
[10:21:27.563]     })
[10:21:27.563]     if (TRUE) {
[10:21:27.563]         base::sink(type = "output", split = FALSE)
[10:21:27.563]         if (TRUE) {
[10:21:27.563]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:27.563]         }
[10:21:27.563]         else {
[10:21:27.563]             ...future.result["stdout"] <- base::list(NULL)
[10:21:27.563]         }
[10:21:27.563]         base::close(...future.stdout)
[10:21:27.563]         ...future.stdout <- NULL
[10:21:27.563]     }
[10:21:27.563]     ...future.result$conditions <- ...future.conditions
[10:21:27.563]     ...future.result$finished <- base::Sys.time()
[10:21:27.563]     ...future.result
[10:21:27.563] }
[10:21:27.566] Exporting 2 global objects (712 bytes) to cluster node #1 ...
[10:21:27.566] Exporting ‘weight’ (191 bytes) to cluster node #1 ...
[10:21:27.566] Exporting ‘weight’ (191 bytes) to cluster node #1 ... DONE
[10:21:27.566] Exporting ‘group’ (210 bytes) to cluster node #1 ...
[10:21:27.567] Exporting ‘group’ (210 bytes) to cluster node #1 ... DONE
[10:21:27.567] Exporting 2 global objects (712 bytes) to cluster node #1 ... DONE
[10:21:27.567] MultisessionFuture started
[10:21:27.567] - Launch lazy future ... done
[10:21:27.568] run() for ‘MultisessionFuture’ ... done
[10:21:27.568] result() for ClusterFuture ...
[10:21:27.568] receiveMessageFromWorker() for ClusterFuture ...
[10:21:27.568] - Validating connection of MultisessionFuture
[10:21:27.615] - received message: FutureResult
[10:21:27.616] - Received FutureResult
[10:21:27.616] - Erased future from FutureRegistry
[10:21:27.616] result() for ClusterFuture ...
[10:21:27.616] - result already collected: FutureResult
[10:21:27.616] result() for ClusterFuture ... done
[10:21:27.616] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:27.616] result() for ClusterFuture ... done
[10:21:27.616] result() for ClusterFuture ...
[10:21:27.616] - result already collected: FutureResult
[10:21:27.616] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:21:27.618] getGlobalsAndPackages() ...
[10:21:27.618] Searching for globals...
[10:21:27.620] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:21:27.620] Searching for globals ... DONE
[10:21:27.620] Resolving globals: FALSE
[10:21:27.621] The total size of the 2 globals is 401 bytes (401 bytes)
[10:21:27.621] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[10:21:27.622] - globals: [2] ‘weight’, ‘group’
[10:21:27.622] - packages: [1] ‘stats’
[10:21:27.622] getGlobalsAndPackages() ... DONE
[10:21:27.622] run() for ‘Future’ ...
[10:21:27.622] - state: ‘created’
[10:21:27.622] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:27.637] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:27.637] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:27.637]   - Field: ‘node’
[10:21:27.638]   - Field: ‘label’
[10:21:27.638]   - Field: ‘local’
[10:21:27.638]   - Field: ‘owner’
[10:21:27.638]   - Field: ‘envir’
[10:21:27.638]   - Field: ‘workers’
[10:21:27.638]   - Field: ‘packages’
[10:21:27.638]   - Field: ‘gc’
[10:21:27.638]   - Field: ‘conditions’
[10:21:27.638]   - Field: ‘persistent’
[10:21:27.638]   - Field: ‘expr’
[10:21:27.639]   - Field: ‘uuid’
[10:21:27.639]   - Field: ‘seed’
[10:21:27.639]   - Field: ‘version’
[10:21:27.639]   - Field: ‘result’
[10:21:27.639]   - Field: ‘asynchronous’
[10:21:27.639]   - Field: ‘calls’
[10:21:27.639]   - Field: ‘globals’
[10:21:27.639]   - Field: ‘stdout’
[10:21:27.639]   - Field: ‘earlySignal’
[10:21:27.640]   - Field: ‘lazy’
[10:21:27.640]   - Field: ‘state’
[10:21:27.640] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:27.640] - Launch lazy future ...
[10:21:27.640] Packages needed by the future expression (n = 1): ‘stats’
[10:21:27.640] Packages needed by future strategies (n = 0): <none>
[10:21:27.641] {
[10:21:27.641]     {
[10:21:27.641]         {
[10:21:27.641]             ...future.startTime <- base::Sys.time()
[10:21:27.641]             {
[10:21:27.641]                 {
[10:21:27.641]                   {
[10:21:27.641]                     {
[10:21:27.641]                       {
[10:21:27.641]                         base::local({
[10:21:27.641]                           has_future <- base::requireNamespace("future", 
[10:21:27.641]                             quietly = TRUE)
[10:21:27.641]                           if (has_future) {
[10:21:27.641]                             ns <- base::getNamespace("future")
[10:21:27.641]                             version <- ns[[".package"]][["version"]]
[10:21:27.641]                             if (is.null(version)) 
[10:21:27.641]                               version <- utils::packageVersion("future")
[10:21:27.641]                           }
[10:21:27.641]                           else {
[10:21:27.641]                             version <- NULL
[10:21:27.641]                           }
[10:21:27.641]                           if (!has_future || version < "1.8.0") {
[10:21:27.641]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:27.641]                               "", base::R.version$version.string), 
[10:21:27.641]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:27.641]                                 base::R.version$platform, 8 * 
[10:21:27.641]                                   base::.Machine$sizeof.pointer), 
[10:21:27.641]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:27.641]                                 "release", "version")], collapse = " "), 
[10:21:27.641]                               hostname = base::Sys.info()[["nodename"]])
[10:21:27.641]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:27.641]                               info)
[10:21:27.641]                             info <- base::paste(info, collapse = "; ")
[10:21:27.641]                             if (!has_future) {
[10:21:27.641]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:27.641]                                 info)
[10:21:27.641]                             }
[10:21:27.641]                             else {
[10:21:27.641]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:27.641]                                 info, version)
[10:21:27.641]                             }
[10:21:27.641]                             base::stop(msg)
[10:21:27.641]                           }
[10:21:27.641]                         })
[10:21:27.641]                       }
[10:21:27.641]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:27.641]                       base::options(mc.cores = 1L)
[10:21:27.641]                     }
[10:21:27.641]                     base::local({
[10:21:27.641]                       for (pkg in "stats") {
[10:21:27.641]                         base::loadNamespace(pkg)
[10:21:27.641]                         base::library(pkg, character.only = TRUE)
[10:21:27.641]                       }
[10:21:27.641]                     })
[10:21:27.641]                   }
[10:21:27.641]                   ...future.strategy.old <- future::plan("list")
[10:21:27.641]                   options(future.plan = NULL)
[10:21:27.641]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:27.641]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:27.641]                 }
[10:21:27.641]                 ...future.workdir <- getwd()
[10:21:27.641]             }
[10:21:27.641]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:27.641]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:27.641]         }
[10:21:27.641]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:27.641]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:27.641]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:27.641]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:27.641]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:27.641]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:27.641]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:27.641]             base::names(...future.oldOptions))
[10:21:27.641]     }
[10:21:27.641]     if (FALSE) {
[10:21:27.641]     }
[10:21:27.641]     else {
[10:21:27.641]         if (TRUE) {
[10:21:27.641]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:27.641]                 open = "w")
[10:21:27.641]         }
[10:21:27.641]         else {
[10:21:27.641]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:27.641]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:27.641]         }
[10:21:27.641]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:27.641]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:27.641]             base::sink(type = "output", split = FALSE)
[10:21:27.641]             base::close(...future.stdout)
[10:21:27.641]         }, add = TRUE)
[10:21:27.641]     }
[10:21:27.641]     ...future.frame <- base::sys.nframe()
[10:21:27.641]     ...future.conditions <- base::list()
[10:21:27.641]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:27.641]     if (FALSE) {
[10:21:27.641]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:27.641]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:27.641]     }
[10:21:27.641]     ...future.result <- base::tryCatch({
[10:21:27.641]         base::withCallingHandlers({
[10:21:27.641]             ...future.value <- base::withVisible(base::local({
[10:21:27.641]                 ...future.makeSendCondition <- base::local({
[10:21:27.641]                   sendCondition <- NULL
[10:21:27.641]                   function(frame = 1L) {
[10:21:27.641]                     if (is.function(sendCondition)) 
[10:21:27.641]                       return(sendCondition)
[10:21:27.641]                     ns <- getNamespace("parallel")
[10:21:27.641]                     if (exists("sendData", mode = "function", 
[10:21:27.641]                       envir = ns)) {
[10:21:27.641]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:27.641]                         envir = ns)
[10:21:27.641]                       envir <- sys.frame(frame)
[10:21:27.641]                       master <- NULL
[10:21:27.641]                       while (!identical(envir, .GlobalEnv) && 
[10:21:27.641]                         !identical(envir, emptyenv())) {
[10:21:27.641]                         if (exists("master", mode = "list", envir = envir, 
[10:21:27.641]                           inherits = FALSE)) {
[10:21:27.641]                           master <- get("master", mode = "list", 
[10:21:27.641]                             envir = envir, inherits = FALSE)
[10:21:27.641]                           if (inherits(master, c("SOCKnode", 
[10:21:27.641]                             "SOCK0node"))) {
[10:21:27.641]                             sendCondition <<- function(cond) {
[10:21:27.641]                               data <- list(type = "VALUE", value = cond, 
[10:21:27.641]                                 success = TRUE)
[10:21:27.641]                               parallel_sendData(master, data)
[10:21:27.641]                             }
[10:21:27.641]                             return(sendCondition)
[10:21:27.641]                           }
[10:21:27.641]                         }
[10:21:27.641]                         frame <- frame + 1L
[10:21:27.641]                         envir <- sys.frame(frame)
[10:21:27.641]                       }
[10:21:27.641]                     }
[10:21:27.641]                     sendCondition <<- function(cond) NULL
[10:21:27.641]                   }
[10:21:27.641]                 })
[10:21:27.641]                 withCallingHandlers({
[10:21:27.641]                   {
[10:21:27.641]                     lm(weight ~ group - 1)
[10:21:27.641]                   }
[10:21:27.641]                 }, immediateCondition = function(cond) {
[10:21:27.641]                   sendCondition <- ...future.makeSendCondition()
[10:21:27.641]                   sendCondition(cond)
[10:21:27.641]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:27.641]                   {
[10:21:27.641]                     inherits <- base::inherits
[10:21:27.641]                     invokeRestart <- base::invokeRestart
[10:21:27.641]                     is.null <- base::is.null
[10:21:27.641]                     muffled <- FALSE
[10:21:27.641]                     if (inherits(cond, "message")) {
[10:21:27.641]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:27.641]                       if (muffled) 
[10:21:27.641]                         invokeRestart("muffleMessage")
[10:21:27.641]                     }
[10:21:27.641]                     else if (inherits(cond, "warning")) {
[10:21:27.641]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:27.641]                       if (muffled) 
[10:21:27.641]                         invokeRestart("muffleWarning")
[10:21:27.641]                     }
[10:21:27.641]                     else if (inherits(cond, "condition")) {
[10:21:27.641]                       if (!is.null(pattern)) {
[10:21:27.641]                         computeRestarts <- base::computeRestarts
[10:21:27.641]                         grepl <- base::grepl
[10:21:27.641]                         restarts <- computeRestarts(cond)
[10:21:27.641]                         for (restart in restarts) {
[10:21:27.641]                           name <- restart$name
[10:21:27.641]                           if (is.null(name)) 
[10:21:27.641]                             next
[10:21:27.641]                           if (!grepl(pattern, name)) 
[10:21:27.641]                             next
[10:21:27.641]                           invokeRestart(restart)
[10:21:27.641]                           muffled <- TRUE
[10:21:27.641]                           break
[10:21:27.641]                         }
[10:21:27.641]                       }
[10:21:27.641]                     }
[10:21:27.641]                     invisible(muffled)
[10:21:27.641]                   }
[10:21:27.641]                   muffleCondition(cond)
[10:21:27.641]                 })
[10:21:27.641]             }))
[10:21:27.641]             future::FutureResult(value = ...future.value$value, 
[10:21:27.641]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:27.641]                   ...future.rng), globalenv = if (FALSE) 
[10:21:27.641]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:27.641]                     ...future.globalenv.names))
[10:21:27.641]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:27.641]         }, condition = base::local({
[10:21:27.641]             c <- base::c
[10:21:27.641]             inherits <- base::inherits
[10:21:27.641]             invokeRestart <- base::invokeRestart
[10:21:27.641]             length <- base::length
[10:21:27.641]             list <- base::list
[10:21:27.641]             seq.int <- base::seq.int
[10:21:27.641]             signalCondition <- base::signalCondition
[10:21:27.641]             sys.calls <- base::sys.calls
[10:21:27.641]             `[[` <- base::`[[`
[10:21:27.641]             `+` <- base::`+`
[10:21:27.641]             `<<-` <- base::`<<-`
[10:21:27.641]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:27.641]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:27.641]                   3L)]
[10:21:27.641]             }
[10:21:27.641]             function(cond) {
[10:21:27.641]                 is_error <- inherits(cond, "error")
[10:21:27.641]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:27.641]                   NULL)
[10:21:27.641]                 if (is_error) {
[10:21:27.641]                   sessionInformation <- function() {
[10:21:27.641]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:27.641]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:27.641]                       search = base::search(), system = base::Sys.info())
[10:21:27.641]                   }
[10:21:27.641]                   ...future.conditions[[length(...future.conditions) + 
[10:21:27.641]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:27.641]                     cond$call), session = sessionInformation(), 
[10:21:27.641]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:27.641]                   signalCondition(cond)
[10:21:27.641]                 }
[10:21:27.641]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:27.641]                 "immediateCondition"))) {
[10:21:27.641]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:27.641]                   ...future.conditions[[length(...future.conditions) + 
[10:21:27.641]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:27.641]                   if (TRUE && !signal) {
[10:21:27.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:27.641]                     {
[10:21:27.641]                       inherits <- base::inherits
[10:21:27.641]                       invokeRestart <- base::invokeRestart
[10:21:27.641]                       is.null <- base::is.null
[10:21:27.641]                       muffled <- FALSE
[10:21:27.641]                       if (inherits(cond, "message")) {
[10:21:27.641]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:27.641]                         if (muffled) 
[10:21:27.641]                           invokeRestart("muffleMessage")
[10:21:27.641]                       }
[10:21:27.641]                       else if (inherits(cond, "warning")) {
[10:21:27.641]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:27.641]                         if (muffled) 
[10:21:27.641]                           invokeRestart("muffleWarning")
[10:21:27.641]                       }
[10:21:27.641]                       else if (inherits(cond, "condition")) {
[10:21:27.641]                         if (!is.null(pattern)) {
[10:21:27.641]                           computeRestarts <- base::computeRestarts
[10:21:27.641]                           grepl <- base::grepl
[10:21:27.641]                           restarts <- computeRestarts(cond)
[10:21:27.641]                           for (restart in restarts) {
[10:21:27.641]                             name <- restart$name
[10:21:27.641]                             if (is.null(name)) 
[10:21:27.641]                               next
[10:21:27.641]                             if (!grepl(pattern, name)) 
[10:21:27.641]                               next
[10:21:27.641]                             invokeRestart(restart)
[10:21:27.641]                             muffled <- TRUE
[10:21:27.641]                             break
[10:21:27.641]                           }
[10:21:27.641]                         }
[10:21:27.641]                       }
[10:21:27.641]                       invisible(muffled)
[10:21:27.641]                     }
[10:21:27.641]                     muffleCondition(cond, pattern = "^muffle")
[10:21:27.641]                   }
[10:21:27.641]                 }
[10:21:27.641]                 else {
[10:21:27.641]                   if (TRUE) {
[10:21:27.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:27.641]                     {
[10:21:27.641]                       inherits <- base::inherits
[10:21:27.641]                       invokeRestart <- base::invokeRestart
[10:21:27.641]                       is.null <- base::is.null
[10:21:27.641]                       muffled <- FALSE
[10:21:27.641]                       if (inherits(cond, "message")) {
[10:21:27.641]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:27.641]                         if (muffled) 
[10:21:27.641]                           invokeRestart("muffleMessage")
[10:21:27.641]                       }
[10:21:27.641]                       else if (inherits(cond, "warning")) {
[10:21:27.641]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:27.641]                         if (muffled) 
[10:21:27.641]                           invokeRestart("muffleWarning")
[10:21:27.641]                       }
[10:21:27.641]                       else if (inherits(cond, "condition")) {
[10:21:27.641]                         if (!is.null(pattern)) {
[10:21:27.641]                           computeRestarts <- base::computeRestarts
[10:21:27.641]                           grepl <- base::grepl
[10:21:27.641]                           restarts <- computeRestarts(cond)
[10:21:27.641]                           for (restart in restarts) {
[10:21:27.641]                             name <- restart$name
[10:21:27.641]                             if (is.null(name)) 
[10:21:27.641]                               next
[10:21:27.641]                             if (!grepl(pattern, name)) 
[10:21:27.641]                               next
[10:21:27.641]                             invokeRestart(restart)
[10:21:27.641]                             muffled <- TRUE
[10:21:27.641]                             break
[10:21:27.641]                           }
[10:21:27.641]                         }
[10:21:27.641]                       }
[10:21:27.641]                       invisible(muffled)
[10:21:27.641]                     }
[10:21:27.641]                     muffleCondition(cond, pattern = "^muffle")
[10:21:27.641]                   }
[10:21:27.641]                 }
[10:21:27.641]             }
[10:21:27.641]         }))
[10:21:27.641]     }, error = function(ex) {
[10:21:27.641]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:27.641]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:27.641]                 ...future.rng), started = ...future.startTime, 
[10:21:27.641]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:27.641]             version = "1.8"), class = "FutureResult")
[10:21:27.641]     }, finally = {
[10:21:27.641]         if (!identical(...future.workdir, getwd())) 
[10:21:27.641]             setwd(...future.workdir)
[10:21:27.641]         {
[10:21:27.641]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:27.641]                 ...future.oldOptions$nwarnings <- NULL
[10:21:27.641]             }
[10:21:27.641]             base::options(...future.oldOptions)
[10:21:27.641]             if (.Platform$OS.type == "windows") {
[10:21:27.641]                 old_names <- names(...future.oldEnvVars)
[10:21:27.641]                 envs <- base::Sys.getenv()
[10:21:27.641]                 names <- names(envs)
[10:21:27.641]                 common <- intersect(names, old_names)
[10:21:27.641]                 added <- setdiff(names, old_names)
[10:21:27.641]                 removed <- setdiff(old_names, names)
[10:21:27.641]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:27.641]                   envs[common]]
[10:21:27.641]                 NAMES <- toupper(changed)
[10:21:27.641]                 args <- list()
[10:21:27.641]                 for (kk in seq_along(NAMES)) {
[10:21:27.641]                   name <- changed[[kk]]
[10:21:27.641]                   NAME <- NAMES[[kk]]
[10:21:27.641]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:27.641]                     next
[10:21:27.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:27.641]                 }
[10:21:27.641]                 NAMES <- toupper(added)
[10:21:27.641]                 for (kk in seq_along(NAMES)) {
[10:21:27.641]                   name <- added[[kk]]
[10:21:27.641]                   NAME <- NAMES[[kk]]
[10:21:27.641]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:27.641]                     next
[10:21:27.641]                   args[[name]] <- ""
[10:21:27.641]                 }
[10:21:27.641]                 NAMES <- toupper(removed)
[10:21:27.641]                 for (kk in seq_along(NAMES)) {
[10:21:27.641]                   name <- removed[[kk]]
[10:21:27.641]                   NAME <- NAMES[[kk]]
[10:21:27.641]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:27.641]                     next
[10:21:27.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:27.641]                 }
[10:21:27.641]                 if (length(args) > 0) 
[10:21:27.641]                   base::do.call(base::Sys.setenv, args = args)
[10:21:27.641]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:27.641]             }
[10:21:27.641]             else {
[10:21:27.641]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:27.641]             }
[10:21:27.641]             {
[10:21:27.641]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:27.641]                   0L) {
[10:21:27.641]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:27.641]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:27.641]                   base::options(opts)
[10:21:27.641]                 }
[10:21:27.641]                 {
[10:21:27.641]                   {
[10:21:27.641]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:27.641]                     NULL
[10:21:27.641]                   }
[10:21:27.641]                   options(future.plan = NULL)
[10:21:27.641]                   if (is.na(NA_character_)) 
[10:21:27.641]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:27.641]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:27.641]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:27.641]                     .init = FALSE)
[10:21:27.641]                 }
[10:21:27.641]             }
[10:21:27.641]         }
[10:21:27.641]     })
[10:21:27.641]     if (TRUE) {
[10:21:27.641]         base::sink(type = "output", split = FALSE)
[10:21:27.641]         if (TRUE) {
[10:21:27.641]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:27.641]         }
[10:21:27.641]         else {
[10:21:27.641]             ...future.result["stdout"] <- base::list(NULL)
[10:21:27.641]         }
[10:21:27.641]         base::close(...future.stdout)
[10:21:27.641]         ...future.stdout <- NULL
[10:21:27.641]     }
[10:21:27.641]     ...future.result$conditions <- ...future.conditions
[10:21:27.641]     ...future.result$finished <- base::Sys.time()
[10:21:27.641]     ...future.result
[10:21:27.641] }
[10:21:27.644] Exporting 2 global objects (712 bytes) to cluster node #1 ...
[10:21:27.644] Exporting ‘weight’ (191 bytes) to cluster node #1 ...
[10:21:27.644] Exporting ‘weight’ (191 bytes) to cluster node #1 ... DONE
[10:21:27.645] Exporting ‘group’ (210 bytes) to cluster node #1 ...
[10:21:27.645] Exporting ‘group’ (210 bytes) to cluster node #1 ... DONE
[10:21:27.645] Exporting 2 global objects (712 bytes) to cluster node #1 ... DONE
[10:21:27.646] MultisessionFuture started
[10:21:27.646] - Launch lazy future ... done
[10:21:27.646] run() for ‘MultisessionFuture’ ... done
[10:21:27.646] result() for ClusterFuture ...
[10:21:27.646] receiveMessageFromWorker() for ClusterFuture ...
[10:21:27.646] - Validating connection of MultisessionFuture
[10:21:27.689] - received message: FutureResult
[10:21:27.689] - Received FutureResult
[10:21:27.689] - Erased future from FutureRegistry
[10:21:27.689] result() for ClusterFuture ...
[10:21:27.689] - result already collected: FutureResult
[10:21:27.690] result() for ClusterFuture ... done
[10:21:27.690] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:27.690] result() for ClusterFuture ... done
[10:21:27.690] result() for ClusterFuture ...
[10:21:27.690] - result already collected: FutureResult
[10:21:27.690] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:21:27.692] getGlobalsAndPackages() ...
[10:21:27.693] Searching for globals...
[10:21:27.694] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:21:27.694] Searching for globals ... DONE
[10:21:27.695] Resolving globals: FALSE
[10:21:27.695] The total size of the 2 globals is 401 bytes (401 bytes)
[10:21:27.696] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[10:21:27.696] - globals: [2] ‘weight’, ‘group’
[10:21:27.696] - packages: [1] ‘stats’
[10:21:27.696] getGlobalsAndPackages() ... DONE
[10:21:27.696] run() for ‘Future’ ...
[10:21:27.696] - state: ‘created’
[10:21:27.697] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:27.711] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:27.711] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:27.711]   - Field: ‘node’
[10:21:27.711]   - Field: ‘label’
[10:21:27.712]   - Field: ‘local’
[10:21:27.712]   - Field: ‘owner’
[10:21:27.712]   - Field: ‘envir’
[10:21:27.712]   - Field: ‘workers’
[10:21:27.712]   - Field: ‘packages’
[10:21:27.712]   - Field: ‘gc’
[10:21:27.712]   - Field: ‘conditions’
[10:21:27.712]   - Field: ‘persistent’
[10:21:27.712]   - Field: ‘expr’
[10:21:27.712]   - Field: ‘uuid’
[10:21:27.713]   - Field: ‘seed’
[10:21:27.713]   - Field: ‘version’
[10:21:27.713]   - Field: ‘result’
[10:21:27.713]   - Field: ‘asynchronous’
[10:21:27.713]   - Field: ‘calls’
[10:21:27.713]   - Field: ‘globals’
[10:21:27.713]   - Field: ‘stdout’
[10:21:27.713]   - Field: ‘earlySignal’
[10:21:27.713]   - Field: ‘lazy’
[10:21:27.713]   - Field: ‘state’
[10:21:27.714] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:27.714] - Launch lazy future ...
[10:21:27.714] Packages needed by the future expression (n = 1): ‘stats’
[10:21:27.714] Packages needed by future strategies (n = 0): <none>
[10:21:27.715] {
[10:21:27.715]     {
[10:21:27.715]         {
[10:21:27.715]             ...future.startTime <- base::Sys.time()
[10:21:27.715]             {
[10:21:27.715]                 {
[10:21:27.715]                   {
[10:21:27.715]                     {
[10:21:27.715]                       {
[10:21:27.715]                         base::local({
[10:21:27.715]                           has_future <- base::requireNamespace("future", 
[10:21:27.715]                             quietly = TRUE)
[10:21:27.715]                           if (has_future) {
[10:21:27.715]                             ns <- base::getNamespace("future")
[10:21:27.715]                             version <- ns[[".package"]][["version"]]
[10:21:27.715]                             if (is.null(version)) 
[10:21:27.715]                               version <- utils::packageVersion("future")
[10:21:27.715]                           }
[10:21:27.715]                           else {
[10:21:27.715]                             version <- NULL
[10:21:27.715]                           }
[10:21:27.715]                           if (!has_future || version < "1.8.0") {
[10:21:27.715]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:27.715]                               "", base::R.version$version.string), 
[10:21:27.715]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:27.715]                                 base::R.version$platform, 8 * 
[10:21:27.715]                                   base::.Machine$sizeof.pointer), 
[10:21:27.715]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:27.715]                                 "release", "version")], collapse = " "), 
[10:21:27.715]                               hostname = base::Sys.info()[["nodename"]])
[10:21:27.715]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:27.715]                               info)
[10:21:27.715]                             info <- base::paste(info, collapse = "; ")
[10:21:27.715]                             if (!has_future) {
[10:21:27.715]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:27.715]                                 info)
[10:21:27.715]                             }
[10:21:27.715]                             else {
[10:21:27.715]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:27.715]                                 info, version)
[10:21:27.715]                             }
[10:21:27.715]                             base::stop(msg)
[10:21:27.715]                           }
[10:21:27.715]                         })
[10:21:27.715]                       }
[10:21:27.715]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:27.715]                       base::options(mc.cores = 1L)
[10:21:27.715]                     }
[10:21:27.715]                     base::local({
[10:21:27.715]                       for (pkg in "stats") {
[10:21:27.715]                         base::loadNamespace(pkg)
[10:21:27.715]                         base::library(pkg, character.only = TRUE)
[10:21:27.715]                       }
[10:21:27.715]                     })
[10:21:27.715]                   }
[10:21:27.715]                   ...future.strategy.old <- future::plan("list")
[10:21:27.715]                   options(future.plan = NULL)
[10:21:27.715]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:27.715]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:27.715]                 }
[10:21:27.715]                 ...future.workdir <- getwd()
[10:21:27.715]             }
[10:21:27.715]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:27.715]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:27.715]         }
[10:21:27.715]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:27.715]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:27.715]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:27.715]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:27.715]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:27.715]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:27.715]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:27.715]             base::names(...future.oldOptions))
[10:21:27.715]     }
[10:21:27.715]     if (FALSE) {
[10:21:27.715]     }
[10:21:27.715]     else {
[10:21:27.715]         if (TRUE) {
[10:21:27.715]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:27.715]                 open = "w")
[10:21:27.715]         }
[10:21:27.715]         else {
[10:21:27.715]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:27.715]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:27.715]         }
[10:21:27.715]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:27.715]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:27.715]             base::sink(type = "output", split = FALSE)
[10:21:27.715]             base::close(...future.stdout)
[10:21:27.715]         }, add = TRUE)
[10:21:27.715]     }
[10:21:27.715]     ...future.frame <- base::sys.nframe()
[10:21:27.715]     ...future.conditions <- base::list()
[10:21:27.715]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:27.715]     if (FALSE) {
[10:21:27.715]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:27.715]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:27.715]     }
[10:21:27.715]     ...future.result <- base::tryCatch({
[10:21:27.715]         base::withCallingHandlers({
[10:21:27.715]             ...future.value <- base::withVisible(base::local({
[10:21:27.715]                 ...future.makeSendCondition <- base::local({
[10:21:27.715]                   sendCondition <- NULL
[10:21:27.715]                   function(frame = 1L) {
[10:21:27.715]                     if (is.function(sendCondition)) 
[10:21:27.715]                       return(sendCondition)
[10:21:27.715]                     ns <- getNamespace("parallel")
[10:21:27.715]                     if (exists("sendData", mode = "function", 
[10:21:27.715]                       envir = ns)) {
[10:21:27.715]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:27.715]                         envir = ns)
[10:21:27.715]                       envir <- sys.frame(frame)
[10:21:27.715]                       master <- NULL
[10:21:27.715]                       while (!identical(envir, .GlobalEnv) && 
[10:21:27.715]                         !identical(envir, emptyenv())) {
[10:21:27.715]                         if (exists("master", mode = "list", envir = envir, 
[10:21:27.715]                           inherits = FALSE)) {
[10:21:27.715]                           master <- get("master", mode = "list", 
[10:21:27.715]                             envir = envir, inherits = FALSE)
[10:21:27.715]                           if (inherits(master, c("SOCKnode", 
[10:21:27.715]                             "SOCK0node"))) {
[10:21:27.715]                             sendCondition <<- function(cond) {
[10:21:27.715]                               data <- list(type = "VALUE", value = cond, 
[10:21:27.715]                                 success = TRUE)
[10:21:27.715]                               parallel_sendData(master, data)
[10:21:27.715]                             }
[10:21:27.715]                             return(sendCondition)
[10:21:27.715]                           }
[10:21:27.715]                         }
[10:21:27.715]                         frame <- frame + 1L
[10:21:27.715]                         envir <- sys.frame(frame)
[10:21:27.715]                       }
[10:21:27.715]                     }
[10:21:27.715]                     sendCondition <<- function(cond) NULL
[10:21:27.715]                   }
[10:21:27.715]                 })
[10:21:27.715]                 withCallingHandlers({
[10:21:27.715]                   {
[10:21:27.715]                     lm(weight ~ group - 1)
[10:21:27.715]                   }
[10:21:27.715]                 }, immediateCondition = function(cond) {
[10:21:27.715]                   sendCondition <- ...future.makeSendCondition()
[10:21:27.715]                   sendCondition(cond)
[10:21:27.715]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:27.715]                   {
[10:21:27.715]                     inherits <- base::inherits
[10:21:27.715]                     invokeRestart <- base::invokeRestart
[10:21:27.715]                     is.null <- base::is.null
[10:21:27.715]                     muffled <- FALSE
[10:21:27.715]                     if (inherits(cond, "message")) {
[10:21:27.715]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:27.715]                       if (muffled) 
[10:21:27.715]                         invokeRestart("muffleMessage")
[10:21:27.715]                     }
[10:21:27.715]                     else if (inherits(cond, "warning")) {
[10:21:27.715]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:27.715]                       if (muffled) 
[10:21:27.715]                         invokeRestart("muffleWarning")
[10:21:27.715]                     }
[10:21:27.715]                     else if (inherits(cond, "condition")) {
[10:21:27.715]                       if (!is.null(pattern)) {
[10:21:27.715]                         computeRestarts <- base::computeRestarts
[10:21:27.715]                         grepl <- base::grepl
[10:21:27.715]                         restarts <- computeRestarts(cond)
[10:21:27.715]                         for (restart in restarts) {
[10:21:27.715]                           name <- restart$name
[10:21:27.715]                           if (is.null(name)) 
[10:21:27.715]                             next
[10:21:27.715]                           if (!grepl(pattern, name)) 
[10:21:27.715]                             next
[10:21:27.715]                           invokeRestart(restart)
[10:21:27.715]                           muffled <- TRUE
[10:21:27.715]                           break
[10:21:27.715]                         }
[10:21:27.715]                       }
[10:21:27.715]                     }
[10:21:27.715]                     invisible(muffled)
[10:21:27.715]                   }
[10:21:27.715]                   muffleCondition(cond)
[10:21:27.715]                 })
[10:21:27.715]             }))
[10:21:27.715]             future::FutureResult(value = ...future.value$value, 
[10:21:27.715]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:27.715]                   ...future.rng), globalenv = if (FALSE) 
[10:21:27.715]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:27.715]                     ...future.globalenv.names))
[10:21:27.715]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:27.715]         }, condition = base::local({
[10:21:27.715]             c <- base::c
[10:21:27.715]             inherits <- base::inherits
[10:21:27.715]             invokeRestart <- base::invokeRestart
[10:21:27.715]             length <- base::length
[10:21:27.715]             list <- base::list
[10:21:27.715]             seq.int <- base::seq.int
[10:21:27.715]             signalCondition <- base::signalCondition
[10:21:27.715]             sys.calls <- base::sys.calls
[10:21:27.715]             `[[` <- base::`[[`
[10:21:27.715]             `+` <- base::`+`
[10:21:27.715]             `<<-` <- base::`<<-`
[10:21:27.715]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:27.715]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:27.715]                   3L)]
[10:21:27.715]             }
[10:21:27.715]             function(cond) {
[10:21:27.715]                 is_error <- inherits(cond, "error")
[10:21:27.715]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:27.715]                   NULL)
[10:21:27.715]                 if (is_error) {
[10:21:27.715]                   sessionInformation <- function() {
[10:21:27.715]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:27.715]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:27.715]                       search = base::search(), system = base::Sys.info())
[10:21:27.715]                   }
[10:21:27.715]                   ...future.conditions[[length(...future.conditions) + 
[10:21:27.715]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:27.715]                     cond$call), session = sessionInformation(), 
[10:21:27.715]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:27.715]                   signalCondition(cond)
[10:21:27.715]                 }
[10:21:27.715]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:27.715]                 "immediateCondition"))) {
[10:21:27.715]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:27.715]                   ...future.conditions[[length(...future.conditions) + 
[10:21:27.715]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:27.715]                   if (TRUE && !signal) {
[10:21:27.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:27.715]                     {
[10:21:27.715]                       inherits <- base::inherits
[10:21:27.715]                       invokeRestart <- base::invokeRestart
[10:21:27.715]                       is.null <- base::is.null
[10:21:27.715]                       muffled <- FALSE
[10:21:27.715]                       if (inherits(cond, "message")) {
[10:21:27.715]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:27.715]                         if (muffled) 
[10:21:27.715]                           invokeRestart("muffleMessage")
[10:21:27.715]                       }
[10:21:27.715]                       else if (inherits(cond, "warning")) {
[10:21:27.715]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:27.715]                         if (muffled) 
[10:21:27.715]                           invokeRestart("muffleWarning")
[10:21:27.715]                       }
[10:21:27.715]                       else if (inherits(cond, "condition")) {
[10:21:27.715]                         if (!is.null(pattern)) {
[10:21:27.715]                           computeRestarts <- base::computeRestarts
[10:21:27.715]                           grepl <- base::grepl
[10:21:27.715]                           restarts <- computeRestarts(cond)
[10:21:27.715]                           for (restart in restarts) {
[10:21:27.715]                             name <- restart$name
[10:21:27.715]                             if (is.null(name)) 
[10:21:27.715]                               next
[10:21:27.715]                             if (!grepl(pattern, name)) 
[10:21:27.715]                               next
[10:21:27.715]                             invokeRestart(restart)
[10:21:27.715]                             muffled <- TRUE
[10:21:27.715]                             break
[10:21:27.715]                           }
[10:21:27.715]                         }
[10:21:27.715]                       }
[10:21:27.715]                       invisible(muffled)
[10:21:27.715]                     }
[10:21:27.715]                     muffleCondition(cond, pattern = "^muffle")
[10:21:27.715]                   }
[10:21:27.715]                 }
[10:21:27.715]                 else {
[10:21:27.715]                   if (TRUE) {
[10:21:27.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:27.715]                     {
[10:21:27.715]                       inherits <- base::inherits
[10:21:27.715]                       invokeRestart <- base::invokeRestart
[10:21:27.715]                       is.null <- base::is.null
[10:21:27.715]                       muffled <- FALSE
[10:21:27.715]                       if (inherits(cond, "message")) {
[10:21:27.715]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:27.715]                         if (muffled) 
[10:21:27.715]                           invokeRestart("muffleMessage")
[10:21:27.715]                       }
[10:21:27.715]                       else if (inherits(cond, "warning")) {
[10:21:27.715]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:27.715]                         if (muffled) 
[10:21:27.715]                           invokeRestart("muffleWarning")
[10:21:27.715]                       }
[10:21:27.715]                       else if (inherits(cond, "condition")) {
[10:21:27.715]                         if (!is.null(pattern)) {
[10:21:27.715]                           computeRestarts <- base::computeRestarts
[10:21:27.715]                           grepl <- base::grepl
[10:21:27.715]                           restarts <- computeRestarts(cond)
[10:21:27.715]                           for (restart in restarts) {
[10:21:27.715]                             name <- restart$name
[10:21:27.715]                             if (is.null(name)) 
[10:21:27.715]                               next
[10:21:27.715]                             if (!grepl(pattern, name)) 
[10:21:27.715]                               next
[10:21:27.715]                             invokeRestart(restart)
[10:21:27.715]                             muffled <- TRUE
[10:21:27.715]                             break
[10:21:27.715]                           }
[10:21:27.715]                         }
[10:21:27.715]                       }
[10:21:27.715]                       invisible(muffled)
[10:21:27.715]                     }
[10:21:27.715]                     muffleCondition(cond, pattern = "^muffle")
[10:21:27.715]                   }
[10:21:27.715]                 }
[10:21:27.715]             }
[10:21:27.715]         }))
[10:21:27.715]     }, error = function(ex) {
[10:21:27.715]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:27.715]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:27.715]                 ...future.rng), started = ...future.startTime, 
[10:21:27.715]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:27.715]             version = "1.8"), class = "FutureResult")
[10:21:27.715]     }, finally = {
[10:21:27.715]         if (!identical(...future.workdir, getwd())) 
[10:21:27.715]             setwd(...future.workdir)
[10:21:27.715]         {
[10:21:27.715]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:27.715]                 ...future.oldOptions$nwarnings <- NULL
[10:21:27.715]             }
[10:21:27.715]             base::options(...future.oldOptions)
[10:21:27.715]             if (.Platform$OS.type == "windows") {
[10:21:27.715]                 old_names <- names(...future.oldEnvVars)
[10:21:27.715]                 envs <- base::Sys.getenv()
[10:21:27.715]                 names <- names(envs)
[10:21:27.715]                 common <- intersect(names, old_names)
[10:21:27.715]                 added <- setdiff(names, old_names)
[10:21:27.715]                 removed <- setdiff(old_names, names)
[10:21:27.715]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:27.715]                   envs[common]]
[10:21:27.715]                 NAMES <- toupper(changed)
[10:21:27.715]                 args <- list()
[10:21:27.715]                 for (kk in seq_along(NAMES)) {
[10:21:27.715]                   name <- changed[[kk]]
[10:21:27.715]                   NAME <- NAMES[[kk]]
[10:21:27.715]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:27.715]                     next
[10:21:27.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:27.715]                 }
[10:21:27.715]                 NAMES <- toupper(added)
[10:21:27.715]                 for (kk in seq_along(NAMES)) {
[10:21:27.715]                   name <- added[[kk]]
[10:21:27.715]                   NAME <- NAMES[[kk]]
[10:21:27.715]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:27.715]                     next
[10:21:27.715]                   args[[name]] <- ""
[10:21:27.715]                 }
[10:21:27.715]                 NAMES <- toupper(removed)
[10:21:27.715]                 for (kk in seq_along(NAMES)) {
[10:21:27.715]                   name <- removed[[kk]]
[10:21:27.715]                   NAME <- NAMES[[kk]]
[10:21:27.715]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:27.715]                     next
[10:21:27.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:27.715]                 }
[10:21:27.715]                 if (length(args) > 0) 
[10:21:27.715]                   base::do.call(base::Sys.setenv, args = args)
[10:21:27.715]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:27.715]             }
[10:21:27.715]             else {
[10:21:27.715]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:27.715]             }
[10:21:27.715]             {
[10:21:27.715]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:27.715]                   0L) {
[10:21:27.715]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:27.715]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:27.715]                   base::options(opts)
[10:21:27.715]                 }
[10:21:27.715]                 {
[10:21:27.715]                   {
[10:21:27.715]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:27.715]                     NULL
[10:21:27.715]                   }
[10:21:27.715]                   options(future.plan = NULL)
[10:21:27.715]                   if (is.na(NA_character_)) 
[10:21:27.715]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:27.715]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:27.715]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:27.715]                     .init = FALSE)
[10:21:27.715]                 }
[10:21:27.715]             }
[10:21:27.715]         }
[10:21:27.715]     })
[10:21:27.715]     if (TRUE) {
[10:21:27.715]         base::sink(type = "output", split = FALSE)
[10:21:27.715]         if (TRUE) {
[10:21:27.715]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:27.715]         }
[10:21:27.715]         else {
[10:21:27.715]             ...future.result["stdout"] <- base::list(NULL)
[10:21:27.715]         }
[10:21:27.715]         base::close(...future.stdout)
[10:21:27.715]         ...future.stdout <- NULL
[10:21:27.715]     }
[10:21:27.715]     ...future.result$conditions <- ...future.conditions
[10:21:27.715]     ...future.result$finished <- base::Sys.time()
[10:21:27.715]     ...future.result
[10:21:27.715] }
[10:21:27.718] Exporting 2 global objects (712 bytes) to cluster node #1 ...
[10:21:27.718] Exporting ‘weight’ (191 bytes) to cluster node #1 ...
[10:21:27.718] Exporting ‘weight’ (191 bytes) to cluster node #1 ... DONE
[10:21:27.718] Exporting ‘group’ (210 bytes) to cluster node #1 ...
[10:21:27.719] Exporting ‘group’ (210 bytes) to cluster node #1 ... DONE
[10:21:27.719] Exporting 2 global objects (712 bytes) to cluster node #1 ... DONE
[10:21:27.719] MultisessionFuture started
[10:21:27.720] - Launch lazy future ... done
[10:21:27.720] run() for ‘MultisessionFuture’ ... done
[10:21:27.720] result() for ClusterFuture ...
[10:21:27.720] receiveMessageFromWorker() for ClusterFuture ...
[10:21:27.720] - Validating connection of MultisessionFuture
[10:21:27.763] - received message: FutureResult
[10:21:27.763] - Received FutureResult
[10:21:27.763] - Erased future from FutureRegistry
[10:21:27.763] result() for ClusterFuture ...
[10:21:27.763] - result already collected: FutureResult
[10:21:27.764] result() for ClusterFuture ... done
[10:21:27.764] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:27.764] result() for ClusterFuture ... done
[10:21:27.764] result() for ClusterFuture ...
[10:21:27.764] - result already collected: FutureResult
[10:21:27.764] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:21:27.766] getGlobalsAndPackages() ...
[10:21:27.766] Searching for globals...
[10:21:27.768] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:21:27.768] Searching for globals ... DONE
[10:21:27.769] Resolving globals: FALSE
[10:21:27.769] The total size of the 2 globals is 401 bytes (401 bytes)
[10:21:27.770] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[10:21:27.770] - globals: [2] ‘weight’, ‘group’
[10:21:27.770] - packages: [1] ‘stats’
[10:21:27.770] getGlobalsAndPackages() ... DONE
[10:21:27.770] run() for ‘Future’ ...
[10:21:27.770] - state: ‘created’
[10:21:27.771] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:27.785] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:27.785] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:27.786]   - Field: ‘node’
[10:21:27.786]   - Field: ‘label’
[10:21:27.786]   - Field: ‘local’
[10:21:27.786]   - Field: ‘owner’
[10:21:27.786]   - Field: ‘envir’
[10:21:27.786]   - Field: ‘workers’
[10:21:27.786]   - Field: ‘packages’
[10:21:27.786]   - Field: ‘gc’
[10:21:27.786]   - Field: ‘conditions’
[10:21:27.786]   - Field: ‘persistent’
[10:21:27.786]   - Field: ‘expr’
[10:21:27.787]   - Field: ‘uuid’
[10:21:27.787]   - Field: ‘seed’
[10:21:27.787]   - Field: ‘version’
[10:21:27.787]   - Field: ‘result’
[10:21:27.787]   - Field: ‘asynchronous’
[10:21:27.787]   - Field: ‘calls’
[10:21:27.787]   - Field: ‘globals’
[10:21:27.787]   - Field: ‘stdout’
[10:21:27.788]   - Field: ‘earlySignal’
[10:21:27.788]   - Field: ‘lazy’
[10:21:27.788]   - Field: ‘state’
[10:21:27.788] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:27.788] - Launch lazy future ...
[10:21:27.788] Packages needed by the future expression (n = 1): ‘stats’
[10:21:27.788] Packages needed by future strategies (n = 0): <none>
[10:21:27.789] {
[10:21:27.789]     {
[10:21:27.789]         {
[10:21:27.789]             ...future.startTime <- base::Sys.time()
[10:21:27.789]             {
[10:21:27.789]                 {
[10:21:27.789]                   {
[10:21:27.789]                     {
[10:21:27.789]                       {
[10:21:27.789]                         base::local({
[10:21:27.789]                           has_future <- base::requireNamespace("future", 
[10:21:27.789]                             quietly = TRUE)
[10:21:27.789]                           if (has_future) {
[10:21:27.789]                             ns <- base::getNamespace("future")
[10:21:27.789]                             version <- ns[[".package"]][["version"]]
[10:21:27.789]                             if (is.null(version)) 
[10:21:27.789]                               version <- utils::packageVersion("future")
[10:21:27.789]                           }
[10:21:27.789]                           else {
[10:21:27.789]                             version <- NULL
[10:21:27.789]                           }
[10:21:27.789]                           if (!has_future || version < "1.8.0") {
[10:21:27.789]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:27.789]                               "", base::R.version$version.string), 
[10:21:27.789]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:27.789]                                 base::R.version$platform, 8 * 
[10:21:27.789]                                   base::.Machine$sizeof.pointer), 
[10:21:27.789]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:27.789]                                 "release", "version")], collapse = " "), 
[10:21:27.789]                               hostname = base::Sys.info()[["nodename"]])
[10:21:27.789]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:27.789]                               info)
[10:21:27.789]                             info <- base::paste(info, collapse = "; ")
[10:21:27.789]                             if (!has_future) {
[10:21:27.789]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:27.789]                                 info)
[10:21:27.789]                             }
[10:21:27.789]                             else {
[10:21:27.789]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:27.789]                                 info, version)
[10:21:27.789]                             }
[10:21:27.789]                             base::stop(msg)
[10:21:27.789]                           }
[10:21:27.789]                         })
[10:21:27.789]                       }
[10:21:27.789]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:27.789]                       base::options(mc.cores = 1L)
[10:21:27.789]                     }
[10:21:27.789]                     base::local({
[10:21:27.789]                       for (pkg in "stats") {
[10:21:27.789]                         base::loadNamespace(pkg)
[10:21:27.789]                         base::library(pkg, character.only = TRUE)
[10:21:27.789]                       }
[10:21:27.789]                     })
[10:21:27.789]                   }
[10:21:27.789]                   ...future.strategy.old <- future::plan("list")
[10:21:27.789]                   options(future.plan = NULL)
[10:21:27.789]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:27.789]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:27.789]                 }
[10:21:27.789]                 ...future.workdir <- getwd()
[10:21:27.789]             }
[10:21:27.789]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:27.789]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:27.789]         }
[10:21:27.789]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:27.789]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:27.789]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:27.789]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:27.789]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:27.789]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:27.789]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:27.789]             base::names(...future.oldOptions))
[10:21:27.789]     }
[10:21:27.789]     if (FALSE) {
[10:21:27.789]     }
[10:21:27.789]     else {
[10:21:27.789]         if (TRUE) {
[10:21:27.789]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:27.789]                 open = "w")
[10:21:27.789]         }
[10:21:27.789]         else {
[10:21:27.789]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:27.789]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:27.789]         }
[10:21:27.789]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:27.789]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:27.789]             base::sink(type = "output", split = FALSE)
[10:21:27.789]             base::close(...future.stdout)
[10:21:27.789]         }, add = TRUE)
[10:21:27.789]     }
[10:21:27.789]     ...future.frame <- base::sys.nframe()
[10:21:27.789]     ...future.conditions <- base::list()
[10:21:27.789]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:27.789]     if (FALSE) {
[10:21:27.789]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:27.789]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:27.789]     }
[10:21:27.789]     ...future.result <- base::tryCatch({
[10:21:27.789]         base::withCallingHandlers({
[10:21:27.789]             ...future.value <- base::withVisible(base::local({
[10:21:27.789]                 ...future.makeSendCondition <- base::local({
[10:21:27.789]                   sendCondition <- NULL
[10:21:27.789]                   function(frame = 1L) {
[10:21:27.789]                     if (is.function(sendCondition)) 
[10:21:27.789]                       return(sendCondition)
[10:21:27.789]                     ns <- getNamespace("parallel")
[10:21:27.789]                     if (exists("sendData", mode = "function", 
[10:21:27.789]                       envir = ns)) {
[10:21:27.789]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:27.789]                         envir = ns)
[10:21:27.789]                       envir <- sys.frame(frame)
[10:21:27.789]                       master <- NULL
[10:21:27.789]                       while (!identical(envir, .GlobalEnv) && 
[10:21:27.789]                         !identical(envir, emptyenv())) {
[10:21:27.789]                         if (exists("master", mode = "list", envir = envir, 
[10:21:27.789]                           inherits = FALSE)) {
[10:21:27.789]                           master <- get("master", mode = "list", 
[10:21:27.789]                             envir = envir, inherits = FALSE)
[10:21:27.789]                           if (inherits(master, c("SOCKnode", 
[10:21:27.789]                             "SOCK0node"))) {
[10:21:27.789]                             sendCondition <<- function(cond) {
[10:21:27.789]                               data <- list(type = "VALUE", value = cond, 
[10:21:27.789]                                 success = TRUE)
[10:21:27.789]                               parallel_sendData(master, data)
[10:21:27.789]                             }
[10:21:27.789]                             return(sendCondition)
[10:21:27.789]                           }
[10:21:27.789]                         }
[10:21:27.789]                         frame <- frame + 1L
[10:21:27.789]                         envir <- sys.frame(frame)
[10:21:27.789]                       }
[10:21:27.789]                     }
[10:21:27.789]                     sendCondition <<- function(cond) NULL
[10:21:27.789]                   }
[10:21:27.789]                 })
[10:21:27.789]                 withCallingHandlers({
[10:21:27.789]                   {
[10:21:27.789]                     lm(weight ~ group - 1)
[10:21:27.789]                   }
[10:21:27.789]                 }, immediateCondition = function(cond) {
[10:21:27.789]                   sendCondition <- ...future.makeSendCondition()
[10:21:27.789]                   sendCondition(cond)
[10:21:27.789]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:27.789]                   {
[10:21:27.789]                     inherits <- base::inherits
[10:21:27.789]                     invokeRestart <- base::invokeRestart
[10:21:27.789]                     is.null <- base::is.null
[10:21:27.789]                     muffled <- FALSE
[10:21:27.789]                     if (inherits(cond, "message")) {
[10:21:27.789]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:27.789]                       if (muffled) 
[10:21:27.789]                         invokeRestart("muffleMessage")
[10:21:27.789]                     }
[10:21:27.789]                     else if (inherits(cond, "warning")) {
[10:21:27.789]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:27.789]                       if (muffled) 
[10:21:27.789]                         invokeRestart("muffleWarning")
[10:21:27.789]                     }
[10:21:27.789]                     else if (inherits(cond, "condition")) {
[10:21:27.789]                       if (!is.null(pattern)) {
[10:21:27.789]                         computeRestarts <- base::computeRestarts
[10:21:27.789]                         grepl <- base::grepl
[10:21:27.789]                         restarts <- computeRestarts(cond)
[10:21:27.789]                         for (restart in restarts) {
[10:21:27.789]                           name <- restart$name
[10:21:27.789]                           if (is.null(name)) 
[10:21:27.789]                             next
[10:21:27.789]                           if (!grepl(pattern, name)) 
[10:21:27.789]                             next
[10:21:27.789]                           invokeRestart(restart)
[10:21:27.789]                           muffled <- TRUE
[10:21:27.789]                           break
[10:21:27.789]                         }
[10:21:27.789]                       }
[10:21:27.789]                     }
[10:21:27.789]                     invisible(muffled)
[10:21:27.789]                   }
[10:21:27.789]                   muffleCondition(cond)
[10:21:27.789]                 })
[10:21:27.789]             }))
[10:21:27.789]             future::FutureResult(value = ...future.value$value, 
[10:21:27.789]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:27.789]                   ...future.rng), globalenv = if (FALSE) 
[10:21:27.789]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:27.789]                     ...future.globalenv.names))
[10:21:27.789]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:27.789]         }, condition = base::local({
[10:21:27.789]             c <- base::c
[10:21:27.789]             inherits <- base::inherits
[10:21:27.789]             invokeRestart <- base::invokeRestart
[10:21:27.789]             length <- base::length
[10:21:27.789]             list <- base::list
[10:21:27.789]             seq.int <- base::seq.int
[10:21:27.789]             signalCondition <- base::signalCondition
[10:21:27.789]             sys.calls <- base::sys.calls
[10:21:27.789]             `[[` <- base::`[[`
[10:21:27.789]             `+` <- base::`+`
[10:21:27.789]             `<<-` <- base::`<<-`
[10:21:27.789]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:27.789]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:27.789]                   3L)]
[10:21:27.789]             }
[10:21:27.789]             function(cond) {
[10:21:27.789]                 is_error <- inherits(cond, "error")
[10:21:27.789]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:27.789]                   NULL)
[10:21:27.789]                 if (is_error) {
[10:21:27.789]                   sessionInformation <- function() {
[10:21:27.789]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:27.789]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:27.789]                       search = base::search(), system = base::Sys.info())
[10:21:27.789]                   }
[10:21:27.789]                   ...future.conditions[[length(...future.conditions) + 
[10:21:27.789]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:27.789]                     cond$call), session = sessionInformation(), 
[10:21:27.789]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:27.789]                   signalCondition(cond)
[10:21:27.789]                 }
[10:21:27.789]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:27.789]                 "immediateCondition"))) {
[10:21:27.789]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:27.789]                   ...future.conditions[[length(...future.conditions) + 
[10:21:27.789]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:27.789]                   if (TRUE && !signal) {
[10:21:27.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:27.789]                     {
[10:21:27.789]                       inherits <- base::inherits
[10:21:27.789]                       invokeRestart <- base::invokeRestart
[10:21:27.789]                       is.null <- base::is.null
[10:21:27.789]                       muffled <- FALSE
[10:21:27.789]                       if (inherits(cond, "message")) {
[10:21:27.789]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:27.789]                         if (muffled) 
[10:21:27.789]                           invokeRestart("muffleMessage")
[10:21:27.789]                       }
[10:21:27.789]                       else if (inherits(cond, "warning")) {
[10:21:27.789]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:27.789]                         if (muffled) 
[10:21:27.789]                           invokeRestart("muffleWarning")
[10:21:27.789]                       }
[10:21:27.789]                       else if (inherits(cond, "condition")) {
[10:21:27.789]                         if (!is.null(pattern)) {
[10:21:27.789]                           computeRestarts <- base::computeRestarts
[10:21:27.789]                           grepl <- base::grepl
[10:21:27.789]                           restarts <- computeRestarts(cond)
[10:21:27.789]                           for (restart in restarts) {
[10:21:27.789]                             name <- restart$name
[10:21:27.789]                             if (is.null(name)) 
[10:21:27.789]                               next
[10:21:27.789]                             if (!grepl(pattern, name)) 
[10:21:27.789]                               next
[10:21:27.789]                             invokeRestart(restart)
[10:21:27.789]                             muffled <- TRUE
[10:21:27.789]                             break
[10:21:27.789]                           }
[10:21:27.789]                         }
[10:21:27.789]                       }
[10:21:27.789]                       invisible(muffled)
[10:21:27.789]                     }
[10:21:27.789]                     muffleCondition(cond, pattern = "^muffle")
[10:21:27.789]                   }
[10:21:27.789]                 }
[10:21:27.789]                 else {
[10:21:27.789]                   if (TRUE) {
[10:21:27.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:27.789]                     {
[10:21:27.789]                       inherits <- base::inherits
[10:21:27.789]                       invokeRestart <- base::invokeRestart
[10:21:27.789]                       is.null <- base::is.null
[10:21:27.789]                       muffled <- FALSE
[10:21:27.789]                       if (inherits(cond, "message")) {
[10:21:27.789]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:27.789]                         if (muffled) 
[10:21:27.789]                           invokeRestart("muffleMessage")
[10:21:27.789]                       }
[10:21:27.789]                       else if (inherits(cond, "warning")) {
[10:21:27.789]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:27.789]                         if (muffled) 
[10:21:27.789]                           invokeRestart("muffleWarning")
[10:21:27.789]                       }
[10:21:27.789]                       else if (inherits(cond, "condition")) {
[10:21:27.789]                         if (!is.null(pattern)) {
[10:21:27.789]                           computeRestarts <- base::computeRestarts
[10:21:27.789]                           grepl <- base::grepl
[10:21:27.789]                           restarts <- computeRestarts(cond)
[10:21:27.789]                           for (restart in restarts) {
[10:21:27.789]                             name <- restart$name
[10:21:27.789]                             if (is.null(name)) 
[10:21:27.789]                               next
[10:21:27.789]                             if (!grepl(pattern, name)) 
[10:21:27.789]                               next
[10:21:27.789]                             invokeRestart(restart)
[10:21:27.789]                             muffled <- TRUE
[10:21:27.789]                             break
[10:21:27.789]                           }
[10:21:27.789]                         }
[10:21:27.789]                       }
[10:21:27.789]                       invisible(muffled)
[10:21:27.789]                     }
[10:21:27.789]                     muffleCondition(cond, pattern = "^muffle")
[10:21:27.789]                   }
[10:21:27.789]                 }
[10:21:27.789]             }
[10:21:27.789]         }))
[10:21:27.789]     }, error = function(ex) {
[10:21:27.789]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:27.789]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:27.789]                 ...future.rng), started = ...future.startTime, 
[10:21:27.789]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:27.789]             version = "1.8"), class = "FutureResult")
[10:21:27.789]     }, finally = {
[10:21:27.789]         if (!identical(...future.workdir, getwd())) 
[10:21:27.789]             setwd(...future.workdir)
[10:21:27.789]         {
[10:21:27.789]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:27.789]                 ...future.oldOptions$nwarnings <- NULL
[10:21:27.789]             }
[10:21:27.789]             base::options(...future.oldOptions)
[10:21:27.789]             if (.Platform$OS.type == "windows") {
[10:21:27.789]                 old_names <- names(...future.oldEnvVars)
[10:21:27.789]                 envs <- base::Sys.getenv()
[10:21:27.789]                 names <- names(envs)
[10:21:27.789]                 common <- intersect(names, old_names)
[10:21:27.789]                 added <- setdiff(names, old_names)
[10:21:27.789]                 removed <- setdiff(old_names, names)
[10:21:27.789]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:27.789]                   envs[common]]
[10:21:27.789]                 NAMES <- toupper(changed)
[10:21:27.789]                 args <- list()
[10:21:27.789]                 for (kk in seq_along(NAMES)) {
[10:21:27.789]                   name <- changed[[kk]]
[10:21:27.789]                   NAME <- NAMES[[kk]]
[10:21:27.789]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:27.789]                     next
[10:21:27.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:27.789]                 }
[10:21:27.789]                 NAMES <- toupper(added)
[10:21:27.789]                 for (kk in seq_along(NAMES)) {
[10:21:27.789]                   name <- added[[kk]]
[10:21:27.789]                   NAME <- NAMES[[kk]]
[10:21:27.789]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:27.789]                     next
[10:21:27.789]                   args[[name]] <- ""
[10:21:27.789]                 }
[10:21:27.789]                 NAMES <- toupper(removed)
[10:21:27.789]                 for (kk in seq_along(NAMES)) {
[10:21:27.789]                   name <- removed[[kk]]
[10:21:27.789]                   NAME <- NAMES[[kk]]
[10:21:27.789]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:27.789]                     next
[10:21:27.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:27.789]                 }
[10:21:27.789]                 if (length(args) > 0) 
[10:21:27.789]                   base::do.call(base::Sys.setenv, args = args)
[10:21:27.789]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:27.789]             }
[10:21:27.789]             else {
[10:21:27.789]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:27.789]             }
[10:21:27.789]             {
[10:21:27.789]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:27.789]                   0L) {
[10:21:27.789]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:27.789]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:27.789]                   base::options(opts)
[10:21:27.789]                 }
[10:21:27.789]                 {
[10:21:27.789]                   {
[10:21:27.789]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:27.789]                     NULL
[10:21:27.789]                   }
[10:21:27.789]                   options(future.plan = NULL)
[10:21:27.789]                   if (is.na(NA_character_)) 
[10:21:27.789]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:27.789]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:27.789]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:27.789]                     .init = FALSE)
[10:21:27.789]                 }
[10:21:27.789]             }
[10:21:27.789]         }
[10:21:27.789]     })
[10:21:27.789]     if (TRUE) {
[10:21:27.789]         base::sink(type = "output", split = FALSE)
[10:21:27.789]         if (TRUE) {
[10:21:27.789]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:27.789]         }
[10:21:27.789]         else {
[10:21:27.789]             ...future.result["stdout"] <- base::list(NULL)
[10:21:27.789]         }
[10:21:27.789]         base::close(...future.stdout)
[10:21:27.789]         ...future.stdout <- NULL
[10:21:27.789]     }
[10:21:27.789]     ...future.result$conditions <- ...future.conditions
[10:21:27.789]     ...future.result$finished <- base::Sys.time()
[10:21:27.789]     ...future.result
[10:21:27.789] }
[10:21:27.792] Exporting 2 global objects (712 bytes) to cluster node #1 ...
[10:21:27.792] Exporting ‘weight’ (191 bytes) to cluster node #1 ...
[10:21:27.793] Exporting ‘weight’ (191 bytes) to cluster node #1 ... DONE
[10:21:27.793] Exporting ‘group’ (210 bytes) to cluster node #1 ...
[10:21:27.793] Exporting ‘group’ (210 bytes) to cluster node #1 ... DONE
[10:21:27.793] Exporting 2 global objects (712 bytes) to cluster node #1 ... DONE
[10:21:27.794] MultisessionFuture started
[10:21:27.794] - Launch lazy future ... done
[10:21:27.794] run() for ‘MultisessionFuture’ ... done
[10:21:27.794] result() for ClusterFuture ...
[10:21:27.794] receiveMessageFromWorker() for ClusterFuture ...
[10:21:27.795] - Validating connection of MultisessionFuture
[10:21:27.837] - received message: FutureResult
[10:21:27.838] - Received FutureResult
[10:21:27.838] - Erased future from FutureRegistry
[10:21:27.838] result() for ClusterFuture ...
[10:21:27.838] - result already collected: FutureResult
[10:21:27.838] result() for ClusterFuture ... done
[10:21:27.838] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:27.838] result() for ClusterFuture ... done
[10:21:27.839] result() for ClusterFuture ...
[10:21:27.839] - result already collected: FutureResult
[10:21:27.839] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[10:21:27.841] getGlobalsAndPackages() ...
[10:21:27.841] Searching for globals...
[10:21:27.843] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[10:21:27.843] Searching for globals ... DONE
[10:21:27.844] Resolving globals: FALSE
[10:21:27.844] The total size of the 2 globals is 401 bytes (401 bytes)
[10:21:27.845] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[10:21:27.845] - globals: [2] ‘weight’, ‘group’
[10:21:27.845] - packages: [1] ‘stats’
[10:21:27.845] getGlobalsAndPackages() ... DONE
[10:21:27.845] run() for ‘Future’ ...
[10:21:27.846] - state: ‘created’
[10:21:27.846] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:27.863] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:27.863] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:27.863]   - Field: ‘node’
[10:21:27.863]   - Field: ‘label’
[10:21:27.863]   - Field: ‘local’
[10:21:27.863]   - Field: ‘owner’
[10:21:27.863]   - Field: ‘envir’
[10:21:27.863]   - Field: ‘workers’
[10:21:27.863]   - Field: ‘packages’
[10:21:27.863]   - Field: ‘gc’
[10:21:27.864]   - Field: ‘conditions’
[10:21:27.864]   - Field: ‘persistent’
[10:21:27.864]   - Field: ‘expr’
[10:21:27.864]   - Field: ‘uuid’
[10:21:27.864]   - Field: ‘seed’
[10:21:27.864]   - Field: ‘version’
[10:21:27.864]   - Field: ‘result’
[10:21:27.864]   - Field: ‘asynchronous’
[10:21:27.864]   - Field: ‘calls’
[10:21:27.864]   - Field: ‘globals’
[10:21:27.864]   - Field: ‘stdout’
[10:21:27.864]   - Field: ‘earlySignal’
[10:21:27.865]   - Field: ‘lazy’
[10:21:27.865]   - Field: ‘state’
[10:21:27.865] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:27.865] - Launch lazy future ...
[10:21:27.865] Packages needed by the future expression (n = 1): ‘stats’
[10:21:27.865] Packages needed by future strategies (n = 0): <none>
[10:21:27.866] {
[10:21:27.866]     {
[10:21:27.866]         {
[10:21:27.866]             ...future.startTime <- base::Sys.time()
[10:21:27.866]             {
[10:21:27.866]                 {
[10:21:27.866]                   {
[10:21:27.866]                     {
[10:21:27.866]                       {
[10:21:27.866]                         base::local({
[10:21:27.866]                           has_future <- base::requireNamespace("future", 
[10:21:27.866]                             quietly = TRUE)
[10:21:27.866]                           if (has_future) {
[10:21:27.866]                             ns <- base::getNamespace("future")
[10:21:27.866]                             version <- ns[[".package"]][["version"]]
[10:21:27.866]                             if (is.null(version)) 
[10:21:27.866]                               version <- utils::packageVersion("future")
[10:21:27.866]                           }
[10:21:27.866]                           else {
[10:21:27.866]                             version <- NULL
[10:21:27.866]                           }
[10:21:27.866]                           if (!has_future || version < "1.8.0") {
[10:21:27.866]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:27.866]                               "", base::R.version$version.string), 
[10:21:27.866]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:27.866]                                 base::R.version$platform, 8 * 
[10:21:27.866]                                   base::.Machine$sizeof.pointer), 
[10:21:27.866]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:27.866]                                 "release", "version")], collapse = " "), 
[10:21:27.866]                               hostname = base::Sys.info()[["nodename"]])
[10:21:27.866]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:27.866]                               info)
[10:21:27.866]                             info <- base::paste(info, collapse = "; ")
[10:21:27.866]                             if (!has_future) {
[10:21:27.866]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:27.866]                                 info)
[10:21:27.866]                             }
[10:21:27.866]                             else {
[10:21:27.866]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:27.866]                                 info, version)
[10:21:27.866]                             }
[10:21:27.866]                             base::stop(msg)
[10:21:27.866]                           }
[10:21:27.866]                         })
[10:21:27.866]                       }
[10:21:27.866]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:27.866]                       base::options(mc.cores = 1L)
[10:21:27.866]                     }
[10:21:27.866]                     base::local({
[10:21:27.866]                       for (pkg in "stats") {
[10:21:27.866]                         base::loadNamespace(pkg)
[10:21:27.866]                         base::library(pkg, character.only = TRUE)
[10:21:27.866]                       }
[10:21:27.866]                     })
[10:21:27.866]                   }
[10:21:27.866]                   ...future.strategy.old <- future::plan("list")
[10:21:27.866]                   options(future.plan = NULL)
[10:21:27.866]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:27.866]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:27.866]                 }
[10:21:27.866]                 ...future.workdir <- getwd()
[10:21:27.866]             }
[10:21:27.866]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:27.866]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:27.866]         }
[10:21:27.866]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:27.866]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:27.866]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:27.866]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:27.866]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:27.866]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:27.866]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:27.866]             base::names(...future.oldOptions))
[10:21:27.866]     }
[10:21:27.866]     if (FALSE) {
[10:21:27.866]     }
[10:21:27.866]     else {
[10:21:27.866]         if (TRUE) {
[10:21:27.866]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:27.866]                 open = "w")
[10:21:27.866]         }
[10:21:27.866]         else {
[10:21:27.866]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:27.866]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:27.866]         }
[10:21:27.866]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:27.866]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:27.866]             base::sink(type = "output", split = FALSE)
[10:21:27.866]             base::close(...future.stdout)
[10:21:27.866]         }, add = TRUE)
[10:21:27.866]     }
[10:21:27.866]     ...future.frame <- base::sys.nframe()
[10:21:27.866]     ...future.conditions <- base::list()
[10:21:27.866]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:27.866]     if (FALSE) {
[10:21:27.866]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:27.866]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:27.866]     }
[10:21:27.866]     ...future.result <- base::tryCatch({
[10:21:27.866]         base::withCallingHandlers({
[10:21:27.866]             ...future.value <- base::withVisible(base::local({
[10:21:27.866]                 ...future.makeSendCondition <- base::local({
[10:21:27.866]                   sendCondition <- NULL
[10:21:27.866]                   function(frame = 1L) {
[10:21:27.866]                     if (is.function(sendCondition)) 
[10:21:27.866]                       return(sendCondition)
[10:21:27.866]                     ns <- getNamespace("parallel")
[10:21:27.866]                     if (exists("sendData", mode = "function", 
[10:21:27.866]                       envir = ns)) {
[10:21:27.866]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:27.866]                         envir = ns)
[10:21:27.866]                       envir <- sys.frame(frame)
[10:21:27.866]                       master <- NULL
[10:21:27.866]                       while (!identical(envir, .GlobalEnv) && 
[10:21:27.866]                         !identical(envir, emptyenv())) {
[10:21:27.866]                         if (exists("master", mode = "list", envir = envir, 
[10:21:27.866]                           inherits = FALSE)) {
[10:21:27.866]                           master <- get("master", mode = "list", 
[10:21:27.866]                             envir = envir, inherits = FALSE)
[10:21:27.866]                           if (inherits(master, c("SOCKnode", 
[10:21:27.866]                             "SOCK0node"))) {
[10:21:27.866]                             sendCondition <<- function(cond) {
[10:21:27.866]                               data <- list(type = "VALUE", value = cond, 
[10:21:27.866]                                 success = TRUE)
[10:21:27.866]                               parallel_sendData(master, data)
[10:21:27.866]                             }
[10:21:27.866]                             return(sendCondition)
[10:21:27.866]                           }
[10:21:27.866]                         }
[10:21:27.866]                         frame <- frame + 1L
[10:21:27.866]                         envir <- sys.frame(frame)
[10:21:27.866]                       }
[10:21:27.866]                     }
[10:21:27.866]                     sendCondition <<- function(cond) NULL
[10:21:27.866]                   }
[10:21:27.866]                 })
[10:21:27.866]                 withCallingHandlers({
[10:21:27.866]                   {
[10:21:27.866]                     lm(weight ~ group - 1)
[10:21:27.866]                   }
[10:21:27.866]                 }, immediateCondition = function(cond) {
[10:21:27.866]                   sendCondition <- ...future.makeSendCondition()
[10:21:27.866]                   sendCondition(cond)
[10:21:27.866]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:27.866]                   {
[10:21:27.866]                     inherits <- base::inherits
[10:21:27.866]                     invokeRestart <- base::invokeRestart
[10:21:27.866]                     is.null <- base::is.null
[10:21:27.866]                     muffled <- FALSE
[10:21:27.866]                     if (inherits(cond, "message")) {
[10:21:27.866]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:27.866]                       if (muffled) 
[10:21:27.866]                         invokeRestart("muffleMessage")
[10:21:27.866]                     }
[10:21:27.866]                     else if (inherits(cond, "warning")) {
[10:21:27.866]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:27.866]                       if (muffled) 
[10:21:27.866]                         invokeRestart("muffleWarning")
[10:21:27.866]                     }
[10:21:27.866]                     else if (inherits(cond, "condition")) {
[10:21:27.866]                       if (!is.null(pattern)) {
[10:21:27.866]                         computeRestarts <- base::computeRestarts
[10:21:27.866]                         grepl <- base::grepl
[10:21:27.866]                         restarts <- computeRestarts(cond)
[10:21:27.866]                         for (restart in restarts) {
[10:21:27.866]                           name <- restart$name
[10:21:27.866]                           if (is.null(name)) 
[10:21:27.866]                             next
[10:21:27.866]                           if (!grepl(pattern, name)) 
[10:21:27.866]                             next
[10:21:27.866]                           invokeRestart(restart)
[10:21:27.866]                           muffled <- TRUE
[10:21:27.866]                           break
[10:21:27.866]                         }
[10:21:27.866]                       }
[10:21:27.866]                     }
[10:21:27.866]                     invisible(muffled)
[10:21:27.866]                   }
[10:21:27.866]                   muffleCondition(cond)
[10:21:27.866]                 })
[10:21:27.866]             }))
[10:21:27.866]             future::FutureResult(value = ...future.value$value, 
[10:21:27.866]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:27.866]                   ...future.rng), globalenv = if (FALSE) 
[10:21:27.866]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:27.866]                     ...future.globalenv.names))
[10:21:27.866]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:27.866]         }, condition = base::local({
[10:21:27.866]             c <- base::c
[10:21:27.866]             inherits <- base::inherits
[10:21:27.866]             invokeRestart <- base::invokeRestart
[10:21:27.866]             length <- base::length
[10:21:27.866]             list <- base::list
[10:21:27.866]             seq.int <- base::seq.int
[10:21:27.866]             signalCondition <- base::signalCondition
[10:21:27.866]             sys.calls <- base::sys.calls
[10:21:27.866]             `[[` <- base::`[[`
[10:21:27.866]             `+` <- base::`+`
[10:21:27.866]             `<<-` <- base::`<<-`
[10:21:27.866]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:27.866]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:27.866]                   3L)]
[10:21:27.866]             }
[10:21:27.866]             function(cond) {
[10:21:27.866]                 is_error <- inherits(cond, "error")
[10:21:27.866]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:27.866]                   NULL)
[10:21:27.866]                 if (is_error) {
[10:21:27.866]                   sessionInformation <- function() {
[10:21:27.866]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:27.866]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:27.866]                       search = base::search(), system = base::Sys.info())
[10:21:27.866]                   }
[10:21:27.866]                   ...future.conditions[[length(...future.conditions) + 
[10:21:27.866]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:27.866]                     cond$call), session = sessionInformation(), 
[10:21:27.866]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:27.866]                   signalCondition(cond)
[10:21:27.866]                 }
[10:21:27.866]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:27.866]                 "immediateCondition"))) {
[10:21:27.866]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:27.866]                   ...future.conditions[[length(...future.conditions) + 
[10:21:27.866]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:27.866]                   if (TRUE && !signal) {
[10:21:27.866]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:27.866]                     {
[10:21:27.866]                       inherits <- base::inherits
[10:21:27.866]                       invokeRestart <- base::invokeRestart
[10:21:27.866]                       is.null <- base::is.null
[10:21:27.866]                       muffled <- FALSE
[10:21:27.866]                       if (inherits(cond, "message")) {
[10:21:27.866]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:27.866]                         if (muffled) 
[10:21:27.866]                           invokeRestart("muffleMessage")
[10:21:27.866]                       }
[10:21:27.866]                       else if (inherits(cond, "warning")) {
[10:21:27.866]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:27.866]                         if (muffled) 
[10:21:27.866]                           invokeRestart("muffleWarning")
[10:21:27.866]                       }
[10:21:27.866]                       else if (inherits(cond, "condition")) {
[10:21:27.866]                         if (!is.null(pattern)) {
[10:21:27.866]                           computeRestarts <- base::computeRestarts
[10:21:27.866]                           grepl <- base::grepl
[10:21:27.866]                           restarts <- computeRestarts(cond)
[10:21:27.866]                           for (restart in restarts) {
[10:21:27.866]                             name <- restart$name
[10:21:27.866]                             if (is.null(name)) 
[10:21:27.866]                               next
[10:21:27.866]                             if (!grepl(pattern, name)) 
[10:21:27.866]                               next
[10:21:27.866]                             invokeRestart(restart)
[10:21:27.866]                             muffled <- TRUE
[10:21:27.866]                             break
[10:21:27.866]                           }
[10:21:27.866]                         }
[10:21:27.866]                       }
[10:21:27.866]                       invisible(muffled)
[10:21:27.866]                     }
[10:21:27.866]                     muffleCondition(cond, pattern = "^muffle")
[10:21:27.866]                   }
[10:21:27.866]                 }
[10:21:27.866]                 else {
[10:21:27.866]                   if (TRUE) {
[10:21:27.866]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:27.866]                     {
[10:21:27.866]                       inherits <- base::inherits
[10:21:27.866]                       invokeRestart <- base::invokeRestart
[10:21:27.866]                       is.null <- base::is.null
[10:21:27.866]                       muffled <- FALSE
[10:21:27.866]                       if (inherits(cond, "message")) {
[10:21:27.866]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:27.866]                         if (muffled) 
[10:21:27.866]                           invokeRestart("muffleMessage")
[10:21:27.866]                       }
[10:21:27.866]                       else if (inherits(cond, "warning")) {
[10:21:27.866]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:27.866]                         if (muffled) 
[10:21:27.866]                           invokeRestart("muffleWarning")
[10:21:27.866]                       }
[10:21:27.866]                       else if (inherits(cond, "condition")) {
[10:21:27.866]                         if (!is.null(pattern)) {
[10:21:27.866]                           computeRestarts <- base::computeRestarts
[10:21:27.866]                           grepl <- base::grepl
[10:21:27.866]                           restarts <- computeRestarts(cond)
[10:21:27.866]                           for (restart in restarts) {
[10:21:27.866]                             name <- restart$name
[10:21:27.866]                             if (is.null(name)) 
[10:21:27.866]                               next
[10:21:27.866]                             if (!grepl(pattern, name)) 
[10:21:27.866]                               next
[10:21:27.866]                             invokeRestart(restart)
[10:21:27.866]                             muffled <- TRUE
[10:21:27.866]                             break
[10:21:27.866]                           }
[10:21:27.866]                         }
[10:21:27.866]                       }
[10:21:27.866]                       invisible(muffled)
[10:21:27.866]                     }
[10:21:27.866]                     muffleCondition(cond, pattern = "^muffle")
[10:21:27.866]                   }
[10:21:27.866]                 }
[10:21:27.866]             }
[10:21:27.866]         }))
[10:21:27.866]     }, error = function(ex) {
[10:21:27.866]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:27.866]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:27.866]                 ...future.rng), started = ...future.startTime, 
[10:21:27.866]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:27.866]             version = "1.8"), class = "FutureResult")
[10:21:27.866]     }, finally = {
[10:21:27.866]         if (!identical(...future.workdir, getwd())) 
[10:21:27.866]             setwd(...future.workdir)
[10:21:27.866]         {
[10:21:27.866]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:27.866]                 ...future.oldOptions$nwarnings <- NULL
[10:21:27.866]             }
[10:21:27.866]             base::options(...future.oldOptions)
[10:21:27.866]             if (.Platform$OS.type == "windows") {
[10:21:27.866]                 old_names <- names(...future.oldEnvVars)
[10:21:27.866]                 envs <- base::Sys.getenv()
[10:21:27.866]                 names <- names(envs)
[10:21:27.866]                 common <- intersect(names, old_names)
[10:21:27.866]                 added <- setdiff(names, old_names)
[10:21:27.866]                 removed <- setdiff(old_names, names)
[10:21:27.866]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:27.866]                   envs[common]]
[10:21:27.866]                 NAMES <- toupper(changed)
[10:21:27.866]                 args <- list()
[10:21:27.866]                 for (kk in seq_along(NAMES)) {
[10:21:27.866]                   name <- changed[[kk]]
[10:21:27.866]                   NAME <- NAMES[[kk]]
[10:21:27.866]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:27.866]                     next
[10:21:27.866]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:27.866]                 }
[10:21:27.866]                 NAMES <- toupper(added)
[10:21:27.866]                 for (kk in seq_along(NAMES)) {
[10:21:27.866]                   name <- added[[kk]]
[10:21:27.866]                   NAME <- NAMES[[kk]]
[10:21:27.866]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:27.866]                     next
[10:21:27.866]                   args[[name]] <- ""
[10:21:27.866]                 }
[10:21:27.866]                 NAMES <- toupper(removed)
[10:21:27.866]                 for (kk in seq_along(NAMES)) {
[10:21:27.866]                   name <- removed[[kk]]
[10:21:27.866]                   NAME <- NAMES[[kk]]
[10:21:27.866]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:27.866]                     next
[10:21:27.866]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:27.866]                 }
[10:21:27.866]                 if (length(args) > 0) 
[10:21:27.866]                   base::do.call(base::Sys.setenv, args = args)
[10:21:27.866]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:27.866]             }
[10:21:27.866]             else {
[10:21:27.866]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:27.866]             }
[10:21:27.866]             {
[10:21:27.866]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:27.866]                   0L) {
[10:21:27.866]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:27.866]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:27.866]                   base::options(opts)
[10:21:27.866]                 }
[10:21:27.866]                 {
[10:21:27.866]                   {
[10:21:27.866]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:27.866]                     NULL
[10:21:27.866]                   }
[10:21:27.866]                   options(future.plan = NULL)
[10:21:27.866]                   if (is.na(NA_character_)) 
[10:21:27.866]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:27.866]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:27.866]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:27.866]                     .init = FALSE)
[10:21:27.866]                 }
[10:21:27.866]             }
[10:21:27.866]         }
[10:21:27.866]     })
[10:21:27.866]     if (TRUE) {
[10:21:27.866]         base::sink(type = "output", split = FALSE)
[10:21:27.866]         if (TRUE) {
[10:21:27.866]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:27.866]         }
[10:21:27.866]         else {
[10:21:27.866]             ...future.result["stdout"] <- base::list(NULL)
[10:21:27.866]         }
[10:21:27.866]         base::close(...future.stdout)
[10:21:27.866]         ...future.stdout <- NULL
[10:21:27.866]     }
[10:21:27.866]     ...future.result$conditions <- ...future.conditions
[10:21:27.866]     ...future.result$finished <- base::Sys.time()
[10:21:27.866]     ...future.result
[10:21:27.866] }
[10:21:27.868] Exporting 2 global objects (712 bytes) to cluster node #1 ...
[10:21:27.868] Exporting ‘weight’ (191 bytes) to cluster node #1 ...
[10:21:27.869] Exporting ‘weight’ (191 bytes) to cluster node #1 ... DONE
[10:21:27.869] Exporting ‘group’ (210 bytes) to cluster node #1 ...
[10:21:27.869] Exporting ‘group’ (210 bytes) to cluster node #1 ... DONE
[10:21:27.869] Exporting 2 global objects (712 bytes) to cluster node #1 ... DONE
[10:21:27.870] MultisessionFuture started
[10:21:27.870] - Launch lazy future ... done
[10:21:27.870] run() for ‘MultisessionFuture’ ... done
[10:21:27.870] result() for ClusterFuture ...
[10:21:27.870] receiveMessageFromWorker() for ClusterFuture ...
[10:21:27.870] - Validating connection of MultisessionFuture
[10:21:27.913] - received message: FutureResult
[10:21:27.913] - Received FutureResult
[10:21:27.914] - Erased future from FutureRegistry
[10:21:27.914] result() for ClusterFuture ...
[10:21:27.914] - result already collected: FutureResult
[10:21:27.914] result() for ClusterFuture ... done
[10:21:27.914] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:27.914] result() for ClusterFuture ... done
[10:21:27.914] result() for ClusterFuture ...
[10:21:27.914] - result already collected: FutureResult
[10:21:27.914] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[10:21:27.916] getGlobalsAndPackages() ...
[10:21:27.916] Searching for globals...
[10:21:27.917] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[10:21:27.917] Searching for globals ... DONE
[10:21:27.917] Resolving globals: FALSE
[10:21:27.918] The total size of the 1 globals is 71 bytes (71 bytes)
[10:21:27.918] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 71 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (71 bytes of class ‘numeric’)
[10:21:27.918] - globals: [1] ‘x’
[10:21:27.918] - packages: [1] ‘stats’
[10:21:27.919] getGlobalsAndPackages() ... DONE
[10:21:27.919] run() for ‘Future’ ...
[10:21:27.919] - state: ‘created’
[10:21:27.919] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:27.932] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:27.933] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:27.933]   - Field: ‘node’
[10:21:27.933]   - Field: ‘label’
[10:21:27.933]   - Field: ‘local’
[10:21:27.933]   - Field: ‘owner’
[10:21:27.933]   - Field: ‘envir’
[10:21:27.933]   - Field: ‘workers’
[10:21:27.933]   - Field: ‘packages’
[10:21:27.933]   - Field: ‘gc’
[10:21:27.933]   - Field: ‘conditions’
[10:21:27.934]   - Field: ‘persistent’
[10:21:27.934]   - Field: ‘expr’
[10:21:27.934]   - Field: ‘uuid’
[10:21:27.934]   - Field: ‘seed’
[10:21:27.934]   - Field: ‘version’
[10:21:27.934]   - Field: ‘result’
[10:21:27.934]   - Field: ‘asynchronous’
[10:21:27.934]   - Field: ‘calls’
[10:21:27.934]   - Field: ‘globals’
[10:21:27.934]   - Field: ‘stdout’
[10:21:27.934]   - Field: ‘earlySignal’
[10:21:27.934]   - Field: ‘lazy’
[10:21:27.935]   - Field: ‘state’
[10:21:27.935] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:27.935] - Launch lazy future ...
[10:21:27.935] Packages needed by the future expression (n = 1): ‘stats’
[10:21:27.935] Packages needed by future strategies (n = 0): <none>
[10:21:27.936] {
[10:21:27.936]     {
[10:21:27.936]         {
[10:21:27.936]             ...future.startTime <- base::Sys.time()
[10:21:27.936]             {
[10:21:27.936]                 {
[10:21:27.936]                   {
[10:21:27.936]                     {
[10:21:27.936]                       {
[10:21:27.936]                         base::local({
[10:21:27.936]                           has_future <- base::requireNamespace("future", 
[10:21:27.936]                             quietly = TRUE)
[10:21:27.936]                           if (has_future) {
[10:21:27.936]                             ns <- base::getNamespace("future")
[10:21:27.936]                             version <- ns[[".package"]][["version"]]
[10:21:27.936]                             if (is.null(version)) 
[10:21:27.936]                               version <- utils::packageVersion("future")
[10:21:27.936]                           }
[10:21:27.936]                           else {
[10:21:27.936]                             version <- NULL
[10:21:27.936]                           }
[10:21:27.936]                           if (!has_future || version < "1.8.0") {
[10:21:27.936]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:27.936]                               "", base::R.version$version.string), 
[10:21:27.936]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:27.936]                                 base::R.version$platform, 8 * 
[10:21:27.936]                                   base::.Machine$sizeof.pointer), 
[10:21:27.936]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:27.936]                                 "release", "version")], collapse = " "), 
[10:21:27.936]                               hostname = base::Sys.info()[["nodename"]])
[10:21:27.936]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:27.936]                               info)
[10:21:27.936]                             info <- base::paste(info, collapse = "; ")
[10:21:27.936]                             if (!has_future) {
[10:21:27.936]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:27.936]                                 info)
[10:21:27.936]                             }
[10:21:27.936]                             else {
[10:21:27.936]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:27.936]                                 info, version)
[10:21:27.936]                             }
[10:21:27.936]                             base::stop(msg)
[10:21:27.936]                           }
[10:21:27.936]                         })
[10:21:27.936]                       }
[10:21:27.936]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:27.936]                       base::options(mc.cores = 1L)
[10:21:27.936]                     }
[10:21:27.936]                     base::local({
[10:21:27.936]                       for (pkg in "stats") {
[10:21:27.936]                         base::loadNamespace(pkg)
[10:21:27.936]                         base::library(pkg, character.only = TRUE)
[10:21:27.936]                       }
[10:21:27.936]                     })
[10:21:27.936]                   }
[10:21:27.936]                   ...future.strategy.old <- future::plan("list")
[10:21:27.936]                   options(future.plan = NULL)
[10:21:27.936]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:27.936]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:27.936]                 }
[10:21:27.936]                 ...future.workdir <- getwd()
[10:21:27.936]             }
[10:21:27.936]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:27.936]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:27.936]         }
[10:21:27.936]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:27.936]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:27.936]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:27.936]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:27.936]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:27.936]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:27.936]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:27.936]             base::names(...future.oldOptions))
[10:21:27.936]     }
[10:21:27.936]     if (FALSE) {
[10:21:27.936]     }
[10:21:27.936]     else {
[10:21:27.936]         if (TRUE) {
[10:21:27.936]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:27.936]                 open = "w")
[10:21:27.936]         }
[10:21:27.936]         else {
[10:21:27.936]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:27.936]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:27.936]         }
[10:21:27.936]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:27.936]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:27.936]             base::sink(type = "output", split = FALSE)
[10:21:27.936]             base::close(...future.stdout)
[10:21:27.936]         }, add = TRUE)
[10:21:27.936]     }
[10:21:27.936]     ...future.frame <- base::sys.nframe()
[10:21:27.936]     ...future.conditions <- base::list()
[10:21:27.936]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:27.936]     if (FALSE) {
[10:21:27.936]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:27.936]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:27.936]     }
[10:21:27.936]     ...future.result <- base::tryCatch({
[10:21:27.936]         base::withCallingHandlers({
[10:21:27.936]             ...future.value <- base::withVisible(base::local({
[10:21:27.936]                 ...future.makeSendCondition <- base::local({
[10:21:27.936]                   sendCondition <- NULL
[10:21:27.936]                   function(frame = 1L) {
[10:21:27.936]                     if (is.function(sendCondition)) 
[10:21:27.936]                       return(sendCondition)
[10:21:27.936]                     ns <- getNamespace("parallel")
[10:21:27.936]                     if (exists("sendData", mode = "function", 
[10:21:27.936]                       envir = ns)) {
[10:21:27.936]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:27.936]                         envir = ns)
[10:21:27.936]                       envir <- sys.frame(frame)
[10:21:27.936]                       master <- NULL
[10:21:27.936]                       while (!identical(envir, .GlobalEnv) && 
[10:21:27.936]                         !identical(envir, emptyenv())) {
[10:21:27.936]                         if (exists("master", mode = "list", envir = envir, 
[10:21:27.936]                           inherits = FALSE)) {
[10:21:27.936]                           master <- get("master", mode = "list", 
[10:21:27.936]                             envir = envir, inherits = FALSE)
[10:21:27.936]                           if (inherits(master, c("SOCKnode", 
[10:21:27.936]                             "SOCK0node"))) {
[10:21:27.936]                             sendCondition <<- function(cond) {
[10:21:27.936]                               data <- list(type = "VALUE", value = cond, 
[10:21:27.936]                                 success = TRUE)
[10:21:27.936]                               parallel_sendData(master, data)
[10:21:27.936]                             }
[10:21:27.936]                             return(sendCondition)
[10:21:27.936]                           }
[10:21:27.936]                         }
[10:21:27.936]                         frame <- frame + 1L
[10:21:27.936]                         envir <- sys.frame(frame)
[10:21:27.936]                       }
[10:21:27.936]                     }
[10:21:27.936]                     sendCondition <<- function(cond) NULL
[10:21:27.936]                   }
[10:21:27.936]                 })
[10:21:27.936]                 withCallingHandlers({
[10:21:27.936]                   {
[10:21:27.936]                     xtabs(~x)
[10:21:27.936]                   }
[10:21:27.936]                 }, immediateCondition = function(cond) {
[10:21:27.936]                   sendCondition <- ...future.makeSendCondition()
[10:21:27.936]                   sendCondition(cond)
[10:21:27.936]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:27.936]                   {
[10:21:27.936]                     inherits <- base::inherits
[10:21:27.936]                     invokeRestart <- base::invokeRestart
[10:21:27.936]                     is.null <- base::is.null
[10:21:27.936]                     muffled <- FALSE
[10:21:27.936]                     if (inherits(cond, "message")) {
[10:21:27.936]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:27.936]                       if (muffled) 
[10:21:27.936]                         invokeRestart("muffleMessage")
[10:21:27.936]                     }
[10:21:27.936]                     else if (inherits(cond, "warning")) {
[10:21:27.936]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:27.936]                       if (muffled) 
[10:21:27.936]                         invokeRestart("muffleWarning")
[10:21:27.936]                     }
[10:21:27.936]                     else if (inherits(cond, "condition")) {
[10:21:27.936]                       if (!is.null(pattern)) {
[10:21:27.936]                         computeRestarts <- base::computeRestarts
[10:21:27.936]                         grepl <- base::grepl
[10:21:27.936]                         restarts <- computeRestarts(cond)
[10:21:27.936]                         for (restart in restarts) {
[10:21:27.936]                           name <- restart$name
[10:21:27.936]                           if (is.null(name)) 
[10:21:27.936]                             next
[10:21:27.936]                           if (!grepl(pattern, name)) 
[10:21:27.936]                             next
[10:21:27.936]                           invokeRestart(restart)
[10:21:27.936]                           muffled <- TRUE
[10:21:27.936]                           break
[10:21:27.936]                         }
[10:21:27.936]                       }
[10:21:27.936]                     }
[10:21:27.936]                     invisible(muffled)
[10:21:27.936]                   }
[10:21:27.936]                   muffleCondition(cond)
[10:21:27.936]                 })
[10:21:27.936]             }))
[10:21:27.936]             future::FutureResult(value = ...future.value$value, 
[10:21:27.936]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:27.936]                   ...future.rng), globalenv = if (FALSE) 
[10:21:27.936]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:27.936]                     ...future.globalenv.names))
[10:21:27.936]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:27.936]         }, condition = base::local({
[10:21:27.936]             c <- base::c
[10:21:27.936]             inherits <- base::inherits
[10:21:27.936]             invokeRestart <- base::invokeRestart
[10:21:27.936]             length <- base::length
[10:21:27.936]             list <- base::list
[10:21:27.936]             seq.int <- base::seq.int
[10:21:27.936]             signalCondition <- base::signalCondition
[10:21:27.936]             sys.calls <- base::sys.calls
[10:21:27.936]             `[[` <- base::`[[`
[10:21:27.936]             `+` <- base::`+`
[10:21:27.936]             `<<-` <- base::`<<-`
[10:21:27.936]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:27.936]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:27.936]                   3L)]
[10:21:27.936]             }
[10:21:27.936]             function(cond) {
[10:21:27.936]                 is_error <- inherits(cond, "error")
[10:21:27.936]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:27.936]                   NULL)
[10:21:27.936]                 if (is_error) {
[10:21:27.936]                   sessionInformation <- function() {
[10:21:27.936]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:27.936]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:27.936]                       search = base::search(), system = base::Sys.info())
[10:21:27.936]                   }
[10:21:27.936]                   ...future.conditions[[length(...future.conditions) + 
[10:21:27.936]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:27.936]                     cond$call), session = sessionInformation(), 
[10:21:27.936]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:27.936]                   signalCondition(cond)
[10:21:27.936]                 }
[10:21:27.936]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:27.936]                 "immediateCondition"))) {
[10:21:27.936]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:27.936]                   ...future.conditions[[length(...future.conditions) + 
[10:21:27.936]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:27.936]                   if (TRUE && !signal) {
[10:21:27.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:27.936]                     {
[10:21:27.936]                       inherits <- base::inherits
[10:21:27.936]                       invokeRestart <- base::invokeRestart
[10:21:27.936]                       is.null <- base::is.null
[10:21:27.936]                       muffled <- FALSE
[10:21:27.936]                       if (inherits(cond, "message")) {
[10:21:27.936]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:27.936]                         if (muffled) 
[10:21:27.936]                           invokeRestart("muffleMessage")
[10:21:27.936]                       }
[10:21:27.936]                       else if (inherits(cond, "warning")) {
[10:21:27.936]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:27.936]                         if (muffled) 
[10:21:27.936]                           invokeRestart("muffleWarning")
[10:21:27.936]                       }
[10:21:27.936]                       else if (inherits(cond, "condition")) {
[10:21:27.936]                         if (!is.null(pattern)) {
[10:21:27.936]                           computeRestarts <- base::computeRestarts
[10:21:27.936]                           grepl <- base::grepl
[10:21:27.936]                           restarts <- computeRestarts(cond)
[10:21:27.936]                           for (restart in restarts) {
[10:21:27.936]                             name <- restart$name
[10:21:27.936]                             if (is.null(name)) 
[10:21:27.936]                               next
[10:21:27.936]                             if (!grepl(pattern, name)) 
[10:21:27.936]                               next
[10:21:27.936]                             invokeRestart(restart)
[10:21:27.936]                             muffled <- TRUE
[10:21:27.936]                             break
[10:21:27.936]                           }
[10:21:27.936]                         }
[10:21:27.936]                       }
[10:21:27.936]                       invisible(muffled)
[10:21:27.936]                     }
[10:21:27.936]                     muffleCondition(cond, pattern = "^muffle")
[10:21:27.936]                   }
[10:21:27.936]                 }
[10:21:27.936]                 else {
[10:21:27.936]                   if (TRUE) {
[10:21:27.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:27.936]                     {
[10:21:27.936]                       inherits <- base::inherits
[10:21:27.936]                       invokeRestart <- base::invokeRestart
[10:21:27.936]                       is.null <- base::is.null
[10:21:27.936]                       muffled <- FALSE
[10:21:27.936]                       if (inherits(cond, "message")) {
[10:21:27.936]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:27.936]                         if (muffled) 
[10:21:27.936]                           invokeRestart("muffleMessage")
[10:21:27.936]                       }
[10:21:27.936]                       else if (inherits(cond, "warning")) {
[10:21:27.936]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:27.936]                         if (muffled) 
[10:21:27.936]                           invokeRestart("muffleWarning")
[10:21:27.936]                       }
[10:21:27.936]                       else if (inherits(cond, "condition")) {
[10:21:27.936]                         if (!is.null(pattern)) {
[10:21:27.936]                           computeRestarts <- base::computeRestarts
[10:21:27.936]                           grepl <- base::grepl
[10:21:27.936]                           restarts <- computeRestarts(cond)
[10:21:27.936]                           for (restart in restarts) {
[10:21:27.936]                             name <- restart$name
[10:21:27.936]                             if (is.null(name)) 
[10:21:27.936]                               next
[10:21:27.936]                             if (!grepl(pattern, name)) 
[10:21:27.936]                               next
[10:21:27.936]                             invokeRestart(restart)
[10:21:27.936]                             muffled <- TRUE
[10:21:27.936]                             break
[10:21:27.936]                           }
[10:21:27.936]                         }
[10:21:27.936]                       }
[10:21:27.936]                       invisible(muffled)
[10:21:27.936]                     }
[10:21:27.936]                     muffleCondition(cond, pattern = "^muffle")
[10:21:27.936]                   }
[10:21:27.936]                 }
[10:21:27.936]             }
[10:21:27.936]         }))
[10:21:27.936]     }, error = function(ex) {
[10:21:27.936]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:27.936]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:27.936]                 ...future.rng), started = ...future.startTime, 
[10:21:27.936]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:27.936]             version = "1.8"), class = "FutureResult")
[10:21:27.936]     }, finally = {
[10:21:27.936]         if (!identical(...future.workdir, getwd())) 
[10:21:27.936]             setwd(...future.workdir)
[10:21:27.936]         {
[10:21:27.936]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:27.936]                 ...future.oldOptions$nwarnings <- NULL
[10:21:27.936]             }
[10:21:27.936]             base::options(...future.oldOptions)
[10:21:27.936]             if (.Platform$OS.type == "windows") {
[10:21:27.936]                 old_names <- names(...future.oldEnvVars)
[10:21:27.936]                 envs <- base::Sys.getenv()
[10:21:27.936]                 names <- names(envs)
[10:21:27.936]                 common <- intersect(names, old_names)
[10:21:27.936]                 added <- setdiff(names, old_names)
[10:21:27.936]                 removed <- setdiff(old_names, names)
[10:21:27.936]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:27.936]                   envs[common]]
[10:21:27.936]                 NAMES <- toupper(changed)
[10:21:27.936]                 args <- list()
[10:21:27.936]                 for (kk in seq_along(NAMES)) {
[10:21:27.936]                   name <- changed[[kk]]
[10:21:27.936]                   NAME <- NAMES[[kk]]
[10:21:27.936]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:27.936]                     next
[10:21:27.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:27.936]                 }
[10:21:27.936]                 NAMES <- toupper(added)
[10:21:27.936]                 for (kk in seq_along(NAMES)) {
[10:21:27.936]                   name <- added[[kk]]
[10:21:27.936]                   NAME <- NAMES[[kk]]
[10:21:27.936]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:27.936]                     next
[10:21:27.936]                   args[[name]] <- ""
[10:21:27.936]                 }
[10:21:27.936]                 NAMES <- toupper(removed)
[10:21:27.936]                 for (kk in seq_along(NAMES)) {
[10:21:27.936]                   name <- removed[[kk]]
[10:21:27.936]                   NAME <- NAMES[[kk]]
[10:21:27.936]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:27.936]                     next
[10:21:27.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:27.936]                 }
[10:21:27.936]                 if (length(args) > 0) 
[10:21:27.936]                   base::do.call(base::Sys.setenv, args = args)
[10:21:27.936]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:27.936]             }
[10:21:27.936]             else {
[10:21:27.936]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:27.936]             }
[10:21:27.936]             {
[10:21:27.936]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:27.936]                   0L) {
[10:21:27.936]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:27.936]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:27.936]                   base::options(opts)
[10:21:27.936]                 }
[10:21:27.936]                 {
[10:21:27.936]                   {
[10:21:27.936]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:27.936]                     NULL
[10:21:27.936]                   }
[10:21:27.936]                   options(future.plan = NULL)
[10:21:27.936]                   if (is.na(NA_character_)) 
[10:21:27.936]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:27.936]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:27.936]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:27.936]                     .init = FALSE)
[10:21:27.936]                 }
[10:21:27.936]             }
[10:21:27.936]         }
[10:21:27.936]     })
[10:21:27.936]     if (TRUE) {
[10:21:27.936]         base::sink(type = "output", split = FALSE)
[10:21:27.936]         if (TRUE) {
[10:21:27.936]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:27.936]         }
[10:21:27.936]         else {
[10:21:27.936]             ...future.result["stdout"] <- base::list(NULL)
[10:21:27.936]         }
[10:21:27.936]         base::close(...future.stdout)
[10:21:27.936]         ...future.stdout <- NULL
[10:21:27.936]     }
[10:21:27.936]     ...future.result$conditions <- ...future.conditions
[10:21:27.936]     ...future.result$finished <- base::Sys.time()
[10:21:27.936]     ...future.result
[10:21:27.936] }
[10:21:27.938] Exporting 1 global objects (378 bytes) to cluster node #1 ...
[10:21:27.938] Exporting ‘x’ (71 bytes) to cluster node #1 ...
[10:21:27.939] Exporting ‘x’ (71 bytes) to cluster node #1 ... DONE
[10:21:27.939] Exporting 1 global objects (378 bytes) to cluster node #1 ... DONE
[10:21:27.939] MultisessionFuture started
[10:21:27.939] - Launch lazy future ... done
[10:21:27.939] run() for ‘MultisessionFuture’ ... done
[10:21:27.940] result() for ClusterFuture ...
[10:21:27.940] receiveMessageFromWorker() for ClusterFuture ...
[10:21:27.940] - Validating connection of MultisessionFuture
[10:21:27.982] - received message: FutureResult
[10:21:27.982] - Received FutureResult
[10:21:27.982] - Erased future from FutureRegistry
[10:21:27.982] result() for ClusterFuture ...
[10:21:27.982] - result already collected: FutureResult
[10:21:27.983] result() for ClusterFuture ... done
[10:21:27.983] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:27.983] result() for ClusterFuture ... done
[10:21:27.983] result() for ClusterFuture ...
[10:21:27.983] - result already collected: FutureResult
[10:21:27.983] result() for ClusterFuture ... done
x
1 2 
2 3 
[10:21:27.984] getGlobalsAndPackages() ...
[10:21:27.984] Searching for globals...
[10:21:27.985] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[10:21:27.985] Searching for globals ... DONE
[10:21:27.985] Resolving globals: FALSE
[10:21:27.986] The total size of the 1 globals is 71 bytes (71 bytes)
[10:21:27.986] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 71 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (71 bytes of class ‘numeric’)
[10:21:27.986] - globals: [1] ‘x’
[10:21:27.986] - packages: [1] ‘stats’
[10:21:27.986] getGlobalsAndPackages() ... DONE
[10:21:27.986] run() for ‘Future’ ...
[10:21:27.987] - state: ‘created’
[10:21:27.987] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:28.001] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:28.001] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:28.001]   - Field: ‘node’
[10:21:28.001]   - Field: ‘label’
[10:21:28.001]   - Field: ‘local’
[10:21:28.002]   - Field: ‘owner’
[10:21:28.002]   - Field: ‘envir’
[10:21:28.002]   - Field: ‘workers’
[10:21:28.002]   - Field: ‘packages’
[10:21:28.002]   - Field: ‘gc’
[10:21:28.002]   - Field: ‘conditions’
[10:21:28.002]   - Field: ‘persistent’
[10:21:28.002]   - Field: ‘expr’
[10:21:28.002]   - Field: ‘uuid’
[10:21:28.002]   - Field: ‘seed’
[10:21:28.002]   - Field: ‘version’
[10:21:28.002]   - Field: ‘result’
[10:21:28.003]   - Field: ‘asynchronous’
[10:21:28.003]   - Field: ‘calls’
[10:21:28.003]   - Field: ‘globals’
[10:21:28.003]   - Field: ‘stdout’
[10:21:28.003]   - Field: ‘earlySignal’
[10:21:28.003]   - Field: ‘lazy’
[10:21:28.003]   - Field: ‘state’
[10:21:28.003] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:28.003] - Launch lazy future ...
[10:21:28.004] Packages needed by the future expression (n = 1): ‘stats’
[10:21:28.004] Packages needed by future strategies (n = 0): <none>
[10:21:28.004] {
[10:21:28.004]     {
[10:21:28.004]         {
[10:21:28.004]             ...future.startTime <- base::Sys.time()
[10:21:28.004]             {
[10:21:28.004]                 {
[10:21:28.004]                   {
[10:21:28.004]                     {
[10:21:28.004]                       {
[10:21:28.004]                         base::local({
[10:21:28.004]                           has_future <- base::requireNamespace("future", 
[10:21:28.004]                             quietly = TRUE)
[10:21:28.004]                           if (has_future) {
[10:21:28.004]                             ns <- base::getNamespace("future")
[10:21:28.004]                             version <- ns[[".package"]][["version"]]
[10:21:28.004]                             if (is.null(version)) 
[10:21:28.004]                               version <- utils::packageVersion("future")
[10:21:28.004]                           }
[10:21:28.004]                           else {
[10:21:28.004]                             version <- NULL
[10:21:28.004]                           }
[10:21:28.004]                           if (!has_future || version < "1.8.0") {
[10:21:28.004]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:28.004]                               "", base::R.version$version.string), 
[10:21:28.004]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:28.004]                                 base::R.version$platform, 8 * 
[10:21:28.004]                                   base::.Machine$sizeof.pointer), 
[10:21:28.004]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:28.004]                                 "release", "version")], collapse = " "), 
[10:21:28.004]                               hostname = base::Sys.info()[["nodename"]])
[10:21:28.004]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:28.004]                               info)
[10:21:28.004]                             info <- base::paste(info, collapse = "; ")
[10:21:28.004]                             if (!has_future) {
[10:21:28.004]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:28.004]                                 info)
[10:21:28.004]                             }
[10:21:28.004]                             else {
[10:21:28.004]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:28.004]                                 info, version)
[10:21:28.004]                             }
[10:21:28.004]                             base::stop(msg)
[10:21:28.004]                           }
[10:21:28.004]                         })
[10:21:28.004]                       }
[10:21:28.004]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:28.004]                       base::options(mc.cores = 1L)
[10:21:28.004]                     }
[10:21:28.004]                     base::local({
[10:21:28.004]                       for (pkg in "stats") {
[10:21:28.004]                         base::loadNamespace(pkg)
[10:21:28.004]                         base::library(pkg, character.only = TRUE)
[10:21:28.004]                       }
[10:21:28.004]                     })
[10:21:28.004]                   }
[10:21:28.004]                   ...future.strategy.old <- future::plan("list")
[10:21:28.004]                   options(future.plan = NULL)
[10:21:28.004]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:28.004]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:28.004]                 }
[10:21:28.004]                 ...future.workdir <- getwd()
[10:21:28.004]             }
[10:21:28.004]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:28.004]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:28.004]         }
[10:21:28.004]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:28.004]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:28.004]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:28.004]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:28.004]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:28.004]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:28.004]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:28.004]             base::names(...future.oldOptions))
[10:21:28.004]     }
[10:21:28.004]     if (FALSE) {
[10:21:28.004]     }
[10:21:28.004]     else {
[10:21:28.004]         if (TRUE) {
[10:21:28.004]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:28.004]                 open = "w")
[10:21:28.004]         }
[10:21:28.004]         else {
[10:21:28.004]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:28.004]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:28.004]         }
[10:21:28.004]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:28.004]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:28.004]             base::sink(type = "output", split = FALSE)
[10:21:28.004]             base::close(...future.stdout)
[10:21:28.004]         }, add = TRUE)
[10:21:28.004]     }
[10:21:28.004]     ...future.frame <- base::sys.nframe()
[10:21:28.004]     ...future.conditions <- base::list()
[10:21:28.004]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:28.004]     if (FALSE) {
[10:21:28.004]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:28.004]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:28.004]     }
[10:21:28.004]     ...future.result <- base::tryCatch({
[10:21:28.004]         base::withCallingHandlers({
[10:21:28.004]             ...future.value <- base::withVisible(base::local({
[10:21:28.004]                 ...future.makeSendCondition <- base::local({
[10:21:28.004]                   sendCondition <- NULL
[10:21:28.004]                   function(frame = 1L) {
[10:21:28.004]                     if (is.function(sendCondition)) 
[10:21:28.004]                       return(sendCondition)
[10:21:28.004]                     ns <- getNamespace("parallel")
[10:21:28.004]                     if (exists("sendData", mode = "function", 
[10:21:28.004]                       envir = ns)) {
[10:21:28.004]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:28.004]                         envir = ns)
[10:21:28.004]                       envir <- sys.frame(frame)
[10:21:28.004]                       master <- NULL
[10:21:28.004]                       while (!identical(envir, .GlobalEnv) && 
[10:21:28.004]                         !identical(envir, emptyenv())) {
[10:21:28.004]                         if (exists("master", mode = "list", envir = envir, 
[10:21:28.004]                           inherits = FALSE)) {
[10:21:28.004]                           master <- get("master", mode = "list", 
[10:21:28.004]                             envir = envir, inherits = FALSE)
[10:21:28.004]                           if (inherits(master, c("SOCKnode", 
[10:21:28.004]                             "SOCK0node"))) {
[10:21:28.004]                             sendCondition <<- function(cond) {
[10:21:28.004]                               data <- list(type = "VALUE", value = cond, 
[10:21:28.004]                                 success = TRUE)
[10:21:28.004]                               parallel_sendData(master, data)
[10:21:28.004]                             }
[10:21:28.004]                             return(sendCondition)
[10:21:28.004]                           }
[10:21:28.004]                         }
[10:21:28.004]                         frame <- frame + 1L
[10:21:28.004]                         envir <- sys.frame(frame)
[10:21:28.004]                       }
[10:21:28.004]                     }
[10:21:28.004]                     sendCondition <<- function(cond) NULL
[10:21:28.004]                   }
[10:21:28.004]                 })
[10:21:28.004]                 withCallingHandlers({
[10:21:28.004]                   {
[10:21:28.004]                     xtabs(~x)
[10:21:28.004]                   }
[10:21:28.004]                 }, immediateCondition = function(cond) {
[10:21:28.004]                   sendCondition <- ...future.makeSendCondition()
[10:21:28.004]                   sendCondition(cond)
[10:21:28.004]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.004]                   {
[10:21:28.004]                     inherits <- base::inherits
[10:21:28.004]                     invokeRestart <- base::invokeRestart
[10:21:28.004]                     is.null <- base::is.null
[10:21:28.004]                     muffled <- FALSE
[10:21:28.004]                     if (inherits(cond, "message")) {
[10:21:28.004]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:28.004]                       if (muffled) 
[10:21:28.004]                         invokeRestart("muffleMessage")
[10:21:28.004]                     }
[10:21:28.004]                     else if (inherits(cond, "warning")) {
[10:21:28.004]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:28.004]                       if (muffled) 
[10:21:28.004]                         invokeRestart("muffleWarning")
[10:21:28.004]                     }
[10:21:28.004]                     else if (inherits(cond, "condition")) {
[10:21:28.004]                       if (!is.null(pattern)) {
[10:21:28.004]                         computeRestarts <- base::computeRestarts
[10:21:28.004]                         grepl <- base::grepl
[10:21:28.004]                         restarts <- computeRestarts(cond)
[10:21:28.004]                         for (restart in restarts) {
[10:21:28.004]                           name <- restart$name
[10:21:28.004]                           if (is.null(name)) 
[10:21:28.004]                             next
[10:21:28.004]                           if (!grepl(pattern, name)) 
[10:21:28.004]                             next
[10:21:28.004]                           invokeRestart(restart)
[10:21:28.004]                           muffled <- TRUE
[10:21:28.004]                           break
[10:21:28.004]                         }
[10:21:28.004]                       }
[10:21:28.004]                     }
[10:21:28.004]                     invisible(muffled)
[10:21:28.004]                   }
[10:21:28.004]                   muffleCondition(cond)
[10:21:28.004]                 })
[10:21:28.004]             }))
[10:21:28.004]             future::FutureResult(value = ...future.value$value, 
[10:21:28.004]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:28.004]                   ...future.rng), globalenv = if (FALSE) 
[10:21:28.004]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:28.004]                     ...future.globalenv.names))
[10:21:28.004]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:28.004]         }, condition = base::local({
[10:21:28.004]             c <- base::c
[10:21:28.004]             inherits <- base::inherits
[10:21:28.004]             invokeRestart <- base::invokeRestart
[10:21:28.004]             length <- base::length
[10:21:28.004]             list <- base::list
[10:21:28.004]             seq.int <- base::seq.int
[10:21:28.004]             signalCondition <- base::signalCondition
[10:21:28.004]             sys.calls <- base::sys.calls
[10:21:28.004]             `[[` <- base::`[[`
[10:21:28.004]             `+` <- base::`+`
[10:21:28.004]             `<<-` <- base::`<<-`
[10:21:28.004]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:28.004]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:28.004]                   3L)]
[10:21:28.004]             }
[10:21:28.004]             function(cond) {
[10:21:28.004]                 is_error <- inherits(cond, "error")
[10:21:28.004]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:28.004]                   NULL)
[10:21:28.004]                 if (is_error) {
[10:21:28.004]                   sessionInformation <- function() {
[10:21:28.004]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:28.004]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:28.004]                       search = base::search(), system = base::Sys.info())
[10:21:28.004]                   }
[10:21:28.004]                   ...future.conditions[[length(...future.conditions) + 
[10:21:28.004]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:28.004]                     cond$call), session = sessionInformation(), 
[10:21:28.004]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:28.004]                   signalCondition(cond)
[10:21:28.004]                 }
[10:21:28.004]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:28.004]                 "immediateCondition"))) {
[10:21:28.004]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:28.004]                   ...future.conditions[[length(...future.conditions) + 
[10:21:28.004]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:28.004]                   if (TRUE && !signal) {
[10:21:28.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.004]                     {
[10:21:28.004]                       inherits <- base::inherits
[10:21:28.004]                       invokeRestart <- base::invokeRestart
[10:21:28.004]                       is.null <- base::is.null
[10:21:28.004]                       muffled <- FALSE
[10:21:28.004]                       if (inherits(cond, "message")) {
[10:21:28.004]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:28.004]                         if (muffled) 
[10:21:28.004]                           invokeRestart("muffleMessage")
[10:21:28.004]                       }
[10:21:28.004]                       else if (inherits(cond, "warning")) {
[10:21:28.004]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:28.004]                         if (muffled) 
[10:21:28.004]                           invokeRestart("muffleWarning")
[10:21:28.004]                       }
[10:21:28.004]                       else if (inherits(cond, "condition")) {
[10:21:28.004]                         if (!is.null(pattern)) {
[10:21:28.004]                           computeRestarts <- base::computeRestarts
[10:21:28.004]                           grepl <- base::grepl
[10:21:28.004]                           restarts <- computeRestarts(cond)
[10:21:28.004]                           for (restart in restarts) {
[10:21:28.004]                             name <- restart$name
[10:21:28.004]                             if (is.null(name)) 
[10:21:28.004]                               next
[10:21:28.004]                             if (!grepl(pattern, name)) 
[10:21:28.004]                               next
[10:21:28.004]                             invokeRestart(restart)
[10:21:28.004]                             muffled <- TRUE
[10:21:28.004]                             break
[10:21:28.004]                           }
[10:21:28.004]                         }
[10:21:28.004]                       }
[10:21:28.004]                       invisible(muffled)
[10:21:28.004]                     }
[10:21:28.004]                     muffleCondition(cond, pattern = "^muffle")
[10:21:28.004]                   }
[10:21:28.004]                 }
[10:21:28.004]                 else {
[10:21:28.004]                   if (TRUE) {
[10:21:28.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.004]                     {
[10:21:28.004]                       inherits <- base::inherits
[10:21:28.004]                       invokeRestart <- base::invokeRestart
[10:21:28.004]                       is.null <- base::is.null
[10:21:28.004]                       muffled <- FALSE
[10:21:28.004]                       if (inherits(cond, "message")) {
[10:21:28.004]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:28.004]                         if (muffled) 
[10:21:28.004]                           invokeRestart("muffleMessage")
[10:21:28.004]                       }
[10:21:28.004]                       else if (inherits(cond, "warning")) {
[10:21:28.004]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:28.004]                         if (muffled) 
[10:21:28.004]                           invokeRestart("muffleWarning")
[10:21:28.004]                       }
[10:21:28.004]                       else if (inherits(cond, "condition")) {
[10:21:28.004]                         if (!is.null(pattern)) {
[10:21:28.004]                           computeRestarts <- base::computeRestarts
[10:21:28.004]                           grepl <- base::grepl
[10:21:28.004]                           restarts <- computeRestarts(cond)
[10:21:28.004]                           for (restart in restarts) {
[10:21:28.004]                             name <- restart$name
[10:21:28.004]                             if (is.null(name)) 
[10:21:28.004]                               next
[10:21:28.004]                             if (!grepl(pattern, name)) 
[10:21:28.004]                               next
[10:21:28.004]                             invokeRestart(restart)
[10:21:28.004]                             muffled <- TRUE
[10:21:28.004]                             break
[10:21:28.004]                           }
[10:21:28.004]                         }
[10:21:28.004]                       }
[10:21:28.004]                       invisible(muffled)
[10:21:28.004]                     }
[10:21:28.004]                     muffleCondition(cond, pattern = "^muffle")
[10:21:28.004]                   }
[10:21:28.004]                 }
[10:21:28.004]             }
[10:21:28.004]         }))
[10:21:28.004]     }, error = function(ex) {
[10:21:28.004]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:28.004]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:28.004]                 ...future.rng), started = ...future.startTime, 
[10:21:28.004]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:28.004]             version = "1.8"), class = "FutureResult")
[10:21:28.004]     }, finally = {
[10:21:28.004]         if (!identical(...future.workdir, getwd())) 
[10:21:28.004]             setwd(...future.workdir)
[10:21:28.004]         {
[10:21:28.004]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:28.004]                 ...future.oldOptions$nwarnings <- NULL
[10:21:28.004]             }
[10:21:28.004]             base::options(...future.oldOptions)
[10:21:28.004]             if (.Platform$OS.type == "windows") {
[10:21:28.004]                 old_names <- names(...future.oldEnvVars)
[10:21:28.004]                 envs <- base::Sys.getenv()
[10:21:28.004]                 names <- names(envs)
[10:21:28.004]                 common <- intersect(names, old_names)
[10:21:28.004]                 added <- setdiff(names, old_names)
[10:21:28.004]                 removed <- setdiff(old_names, names)
[10:21:28.004]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:28.004]                   envs[common]]
[10:21:28.004]                 NAMES <- toupper(changed)
[10:21:28.004]                 args <- list()
[10:21:28.004]                 for (kk in seq_along(NAMES)) {
[10:21:28.004]                   name <- changed[[kk]]
[10:21:28.004]                   NAME <- NAMES[[kk]]
[10:21:28.004]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.004]                     next
[10:21:28.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:28.004]                 }
[10:21:28.004]                 NAMES <- toupper(added)
[10:21:28.004]                 for (kk in seq_along(NAMES)) {
[10:21:28.004]                   name <- added[[kk]]
[10:21:28.004]                   NAME <- NAMES[[kk]]
[10:21:28.004]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.004]                     next
[10:21:28.004]                   args[[name]] <- ""
[10:21:28.004]                 }
[10:21:28.004]                 NAMES <- toupper(removed)
[10:21:28.004]                 for (kk in seq_along(NAMES)) {
[10:21:28.004]                   name <- removed[[kk]]
[10:21:28.004]                   NAME <- NAMES[[kk]]
[10:21:28.004]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.004]                     next
[10:21:28.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:28.004]                 }
[10:21:28.004]                 if (length(args) > 0) 
[10:21:28.004]                   base::do.call(base::Sys.setenv, args = args)
[10:21:28.004]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:28.004]             }
[10:21:28.004]             else {
[10:21:28.004]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:28.004]             }
[10:21:28.004]             {
[10:21:28.004]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:28.004]                   0L) {
[10:21:28.004]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:28.004]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:28.004]                   base::options(opts)
[10:21:28.004]                 }
[10:21:28.004]                 {
[10:21:28.004]                   {
[10:21:28.004]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:28.004]                     NULL
[10:21:28.004]                   }
[10:21:28.004]                   options(future.plan = NULL)
[10:21:28.004]                   if (is.na(NA_character_)) 
[10:21:28.004]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:28.004]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:28.004]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:28.004]                     .init = FALSE)
[10:21:28.004]                 }
[10:21:28.004]             }
[10:21:28.004]         }
[10:21:28.004]     })
[10:21:28.004]     if (TRUE) {
[10:21:28.004]         base::sink(type = "output", split = FALSE)
[10:21:28.004]         if (TRUE) {
[10:21:28.004]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:28.004]         }
[10:21:28.004]         else {
[10:21:28.004]             ...future.result["stdout"] <- base::list(NULL)
[10:21:28.004]         }
[10:21:28.004]         base::close(...future.stdout)
[10:21:28.004]         ...future.stdout <- NULL
[10:21:28.004]     }
[10:21:28.004]     ...future.result$conditions <- ...future.conditions
[10:21:28.004]     ...future.result$finished <- base::Sys.time()
[10:21:28.004]     ...future.result
[10:21:28.004] }
[10:21:28.007] Exporting 1 global objects (378 bytes) to cluster node #1 ...
[10:21:28.007] Exporting ‘x’ (71 bytes) to cluster node #1 ...
[10:21:28.007] Exporting ‘x’ (71 bytes) to cluster node #1 ... DONE
[10:21:28.007] Exporting 1 global objects (378 bytes) to cluster node #1 ... DONE
[10:21:28.008] MultisessionFuture started
[10:21:28.008] - Launch lazy future ... done
[10:21:28.008] run() for ‘MultisessionFuture’ ... done
[10:21:28.008] result() for ClusterFuture ...
[10:21:28.008] receiveMessageFromWorker() for ClusterFuture ...
[10:21:28.008] - Validating connection of MultisessionFuture
[10:21:28.050] - received message: FutureResult
[10:21:28.051] - Received FutureResult
[10:21:28.051] - Erased future from FutureRegistry
[10:21:28.051] result() for ClusterFuture ...
[10:21:28.051] - result already collected: FutureResult
[10:21:28.051] result() for ClusterFuture ... done
[10:21:28.051] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:28.051] result() for ClusterFuture ... done
[10:21:28.051] result() for ClusterFuture ...
[10:21:28.052] - result already collected: FutureResult
[10:21:28.052] result() for ClusterFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[10:21:28.053] getGlobalsAndPackages() ...
[10:21:28.053] Searching for globals...
[10:21:28.055] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[10:21:28.055] Searching for globals ... DONE
[10:21:28.055] Resolving globals: FALSE
[10:21:28.055] 
[10:21:28.056] - packages: [2] ‘stats’, ‘datasets’
[10:21:28.056] getGlobalsAndPackages() ... DONE
[10:21:28.056] run() for ‘Future’ ...
[10:21:28.056] - state: ‘created’
[10:21:28.056] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:28.070] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:28.070] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:28.070]   - Field: ‘node’
[10:21:28.070]   - Field: ‘label’
[10:21:28.070]   - Field: ‘local’
[10:21:28.071]   - Field: ‘owner’
[10:21:28.071]   - Field: ‘envir’
[10:21:28.071]   - Field: ‘workers’
[10:21:28.071]   - Field: ‘packages’
[10:21:28.071]   - Field: ‘gc’
[10:21:28.071]   - Field: ‘conditions’
[10:21:28.071]   - Field: ‘persistent’
[10:21:28.071]   - Field: ‘expr’
[10:21:28.071]   - Field: ‘uuid’
[10:21:28.071]   - Field: ‘seed’
[10:21:28.071]   - Field: ‘version’
[10:21:28.072]   - Field: ‘result’
[10:21:28.072]   - Field: ‘asynchronous’
[10:21:28.072]   - Field: ‘calls’
[10:21:28.072]   - Field: ‘globals’
[10:21:28.072]   - Field: ‘stdout’
[10:21:28.072]   - Field: ‘earlySignal’
[10:21:28.072]   - Field: ‘lazy’
[10:21:28.072]   - Field: ‘state’
[10:21:28.072] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:28.072] - Launch lazy future ...
[10:21:28.073] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:21:28.073] Packages needed by future strategies (n = 0): <none>
[10:21:28.073] {
[10:21:28.073]     {
[10:21:28.073]         {
[10:21:28.073]             ...future.startTime <- base::Sys.time()
[10:21:28.073]             {
[10:21:28.073]                 {
[10:21:28.073]                   {
[10:21:28.073]                     {
[10:21:28.073]                       {
[10:21:28.073]                         base::local({
[10:21:28.073]                           has_future <- base::requireNamespace("future", 
[10:21:28.073]                             quietly = TRUE)
[10:21:28.073]                           if (has_future) {
[10:21:28.073]                             ns <- base::getNamespace("future")
[10:21:28.073]                             version <- ns[[".package"]][["version"]]
[10:21:28.073]                             if (is.null(version)) 
[10:21:28.073]                               version <- utils::packageVersion("future")
[10:21:28.073]                           }
[10:21:28.073]                           else {
[10:21:28.073]                             version <- NULL
[10:21:28.073]                           }
[10:21:28.073]                           if (!has_future || version < "1.8.0") {
[10:21:28.073]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:28.073]                               "", base::R.version$version.string), 
[10:21:28.073]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:28.073]                                 base::R.version$platform, 8 * 
[10:21:28.073]                                   base::.Machine$sizeof.pointer), 
[10:21:28.073]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:28.073]                                 "release", "version")], collapse = " "), 
[10:21:28.073]                               hostname = base::Sys.info()[["nodename"]])
[10:21:28.073]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:28.073]                               info)
[10:21:28.073]                             info <- base::paste(info, collapse = "; ")
[10:21:28.073]                             if (!has_future) {
[10:21:28.073]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:28.073]                                 info)
[10:21:28.073]                             }
[10:21:28.073]                             else {
[10:21:28.073]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:28.073]                                 info, version)
[10:21:28.073]                             }
[10:21:28.073]                             base::stop(msg)
[10:21:28.073]                           }
[10:21:28.073]                         })
[10:21:28.073]                       }
[10:21:28.073]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:28.073]                       base::options(mc.cores = 1L)
[10:21:28.073]                     }
[10:21:28.073]                     base::local({
[10:21:28.073]                       for (pkg in c("stats", "datasets")) {
[10:21:28.073]                         base::loadNamespace(pkg)
[10:21:28.073]                         base::library(pkg, character.only = TRUE)
[10:21:28.073]                       }
[10:21:28.073]                     })
[10:21:28.073]                   }
[10:21:28.073]                   ...future.strategy.old <- future::plan("list")
[10:21:28.073]                   options(future.plan = NULL)
[10:21:28.073]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:28.073]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:28.073]                 }
[10:21:28.073]                 ...future.workdir <- getwd()
[10:21:28.073]             }
[10:21:28.073]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:28.073]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:28.073]         }
[10:21:28.073]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:28.073]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:28.073]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:28.073]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:28.073]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:28.073]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:28.073]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:28.073]             base::names(...future.oldOptions))
[10:21:28.073]     }
[10:21:28.073]     if (FALSE) {
[10:21:28.073]     }
[10:21:28.073]     else {
[10:21:28.073]         if (TRUE) {
[10:21:28.073]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:28.073]                 open = "w")
[10:21:28.073]         }
[10:21:28.073]         else {
[10:21:28.073]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:28.073]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:28.073]         }
[10:21:28.073]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:28.073]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:28.073]             base::sink(type = "output", split = FALSE)
[10:21:28.073]             base::close(...future.stdout)
[10:21:28.073]         }, add = TRUE)
[10:21:28.073]     }
[10:21:28.073]     ...future.frame <- base::sys.nframe()
[10:21:28.073]     ...future.conditions <- base::list()
[10:21:28.073]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:28.073]     if (FALSE) {
[10:21:28.073]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:28.073]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:28.073]     }
[10:21:28.073]     ...future.result <- base::tryCatch({
[10:21:28.073]         base::withCallingHandlers({
[10:21:28.073]             ...future.value <- base::withVisible(base::local({
[10:21:28.073]                 ...future.makeSendCondition <- base::local({
[10:21:28.073]                   sendCondition <- NULL
[10:21:28.073]                   function(frame = 1L) {
[10:21:28.073]                     if (is.function(sendCondition)) 
[10:21:28.073]                       return(sendCondition)
[10:21:28.073]                     ns <- getNamespace("parallel")
[10:21:28.073]                     if (exists("sendData", mode = "function", 
[10:21:28.073]                       envir = ns)) {
[10:21:28.073]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:28.073]                         envir = ns)
[10:21:28.073]                       envir <- sys.frame(frame)
[10:21:28.073]                       master <- NULL
[10:21:28.073]                       while (!identical(envir, .GlobalEnv) && 
[10:21:28.073]                         !identical(envir, emptyenv())) {
[10:21:28.073]                         if (exists("master", mode = "list", envir = envir, 
[10:21:28.073]                           inherits = FALSE)) {
[10:21:28.073]                           master <- get("master", mode = "list", 
[10:21:28.073]                             envir = envir, inherits = FALSE)
[10:21:28.073]                           if (inherits(master, c("SOCKnode", 
[10:21:28.073]                             "SOCK0node"))) {
[10:21:28.073]                             sendCondition <<- function(cond) {
[10:21:28.073]                               data <- list(type = "VALUE", value = cond, 
[10:21:28.073]                                 success = TRUE)
[10:21:28.073]                               parallel_sendData(master, data)
[10:21:28.073]                             }
[10:21:28.073]                             return(sendCondition)
[10:21:28.073]                           }
[10:21:28.073]                         }
[10:21:28.073]                         frame <- frame + 1L
[10:21:28.073]                         envir <- sys.frame(frame)
[10:21:28.073]                       }
[10:21:28.073]                     }
[10:21:28.073]                     sendCondition <<- function(cond) NULL
[10:21:28.073]                   }
[10:21:28.073]                 })
[10:21:28.073]                 withCallingHandlers({
[10:21:28.073]                   {
[10:21:28.073]                     lm(dist ~ . - 1, data = cars)
[10:21:28.073]                   }
[10:21:28.073]                 }, immediateCondition = function(cond) {
[10:21:28.073]                   sendCondition <- ...future.makeSendCondition()
[10:21:28.073]                   sendCondition(cond)
[10:21:28.073]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.073]                   {
[10:21:28.073]                     inherits <- base::inherits
[10:21:28.073]                     invokeRestart <- base::invokeRestart
[10:21:28.073]                     is.null <- base::is.null
[10:21:28.073]                     muffled <- FALSE
[10:21:28.073]                     if (inherits(cond, "message")) {
[10:21:28.073]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:28.073]                       if (muffled) 
[10:21:28.073]                         invokeRestart("muffleMessage")
[10:21:28.073]                     }
[10:21:28.073]                     else if (inherits(cond, "warning")) {
[10:21:28.073]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:28.073]                       if (muffled) 
[10:21:28.073]                         invokeRestart("muffleWarning")
[10:21:28.073]                     }
[10:21:28.073]                     else if (inherits(cond, "condition")) {
[10:21:28.073]                       if (!is.null(pattern)) {
[10:21:28.073]                         computeRestarts <- base::computeRestarts
[10:21:28.073]                         grepl <- base::grepl
[10:21:28.073]                         restarts <- computeRestarts(cond)
[10:21:28.073]                         for (restart in restarts) {
[10:21:28.073]                           name <- restart$name
[10:21:28.073]                           if (is.null(name)) 
[10:21:28.073]                             next
[10:21:28.073]                           if (!grepl(pattern, name)) 
[10:21:28.073]                             next
[10:21:28.073]                           invokeRestart(restart)
[10:21:28.073]                           muffled <- TRUE
[10:21:28.073]                           break
[10:21:28.073]                         }
[10:21:28.073]                       }
[10:21:28.073]                     }
[10:21:28.073]                     invisible(muffled)
[10:21:28.073]                   }
[10:21:28.073]                   muffleCondition(cond)
[10:21:28.073]                 })
[10:21:28.073]             }))
[10:21:28.073]             future::FutureResult(value = ...future.value$value, 
[10:21:28.073]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:28.073]                   ...future.rng), globalenv = if (FALSE) 
[10:21:28.073]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:28.073]                     ...future.globalenv.names))
[10:21:28.073]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:28.073]         }, condition = base::local({
[10:21:28.073]             c <- base::c
[10:21:28.073]             inherits <- base::inherits
[10:21:28.073]             invokeRestart <- base::invokeRestart
[10:21:28.073]             length <- base::length
[10:21:28.073]             list <- base::list
[10:21:28.073]             seq.int <- base::seq.int
[10:21:28.073]             signalCondition <- base::signalCondition
[10:21:28.073]             sys.calls <- base::sys.calls
[10:21:28.073]             `[[` <- base::`[[`
[10:21:28.073]             `+` <- base::`+`
[10:21:28.073]             `<<-` <- base::`<<-`
[10:21:28.073]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:28.073]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:28.073]                   3L)]
[10:21:28.073]             }
[10:21:28.073]             function(cond) {
[10:21:28.073]                 is_error <- inherits(cond, "error")
[10:21:28.073]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:28.073]                   NULL)
[10:21:28.073]                 if (is_error) {
[10:21:28.073]                   sessionInformation <- function() {
[10:21:28.073]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:28.073]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:28.073]                       search = base::search(), system = base::Sys.info())
[10:21:28.073]                   }
[10:21:28.073]                   ...future.conditions[[length(...future.conditions) + 
[10:21:28.073]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:28.073]                     cond$call), session = sessionInformation(), 
[10:21:28.073]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:28.073]                   signalCondition(cond)
[10:21:28.073]                 }
[10:21:28.073]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:28.073]                 "immediateCondition"))) {
[10:21:28.073]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:28.073]                   ...future.conditions[[length(...future.conditions) + 
[10:21:28.073]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:28.073]                   if (TRUE && !signal) {
[10:21:28.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.073]                     {
[10:21:28.073]                       inherits <- base::inherits
[10:21:28.073]                       invokeRestart <- base::invokeRestart
[10:21:28.073]                       is.null <- base::is.null
[10:21:28.073]                       muffled <- FALSE
[10:21:28.073]                       if (inherits(cond, "message")) {
[10:21:28.073]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:28.073]                         if (muffled) 
[10:21:28.073]                           invokeRestart("muffleMessage")
[10:21:28.073]                       }
[10:21:28.073]                       else if (inherits(cond, "warning")) {
[10:21:28.073]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:28.073]                         if (muffled) 
[10:21:28.073]                           invokeRestart("muffleWarning")
[10:21:28.073]                       }
[10:21:28.073]                       else if (inherits(cond, "condition")) {
[10:21:28.073]                         if (!is.null(pattern)) {
[10:21:28.073]                           computeRestarts <- base::computeRestarts
[10:21:28.073]                           grepl <- base::grepl
[10:21:28.073]                           restarts <- computeRestarts(cond)
[10:21:28.073]                           for (restart in restarts) {
[10:21:28.073]                             name <- restart$name
[10:21:28.073]                             if (is.null(name)) 
[10:21:28.073]                               next
[10:21:28.073]                             if (!grepl(pattern, name)) 
[10:21:28.073]                               next
[10:21:28.073]                             invokeRestart(restart)
[10:21:28.073]                             muffled <- TRUE
[10:21:28.073]                             break
[10:21:28.073]                           }
[10:21:28.073]                         }
[10:21:28.073]                       }
[10:21:28.073]                       invisible(muffled)
[10:21:28.073]                     }
[10:21:28.073]                     muffleCondition(cond, pattern = "^muffle")
[10:21:28.073]                   }
[10:21:28.073]                 }
[10:21:28.073]                 else {
[10:21:28.073]                   if (TRUE) {
[10:21:28.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.073]                     {
[10:21:28.073]                       inherits <- base::inherits
[10:21:28.073]                       invokeRestart <- base::invokeRestart
[10:21:28.073]                       is.null <- base::is.null
[10:21:28.073]                       muffled <- FALSE
[10:21:28.073]                       if (inherits(cond, "message")) {
[10:21:28.073]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:28.073]                         if (muffled) 
[10:21:28.073]                           invokeRestart("muffleMessage")
[10:21:28.073]                       }
[10:21:28.073]                       else if (inherits(cond, "warning")) {
[10:21:28.073]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:28.073]                         if (muffled) 
[10:21:28.073]                           invokeRestart("muffleWarning")
[10:21:28.073]                       }
[10:21:28.073]                       else if (inherits(cond, "condition")) {
[10:21:28.073]                         if (!is.null(pattern)) {
[10:21:28.073]                           computeRestarts <- base::computeRestarts
[10:21:28.073]                           grepl <- base::grepl
[10:21:28.073]                           restarts <- computeRestarts(cond)
[10:21:28.073]                           for (restart in restarts) {
[10:21:28.073]                             name <- restart$name
[10:21:28.073]                             if (is.null(name)) 
[10:21:28.073]                               next
[10:21:28.073]                             if (!grepl(pattern, name)) 
[10:21:28.073]                               next
[10:21:28.073]                             invokeRestart(restart)
[10:21:28.073]                             muffled <- TRUE
[10:21:28.073]                             break
[10:21:28.073]                           }
[10:21:28.073]                         }
[10:21:28.073]                       }
[10:21:28.073]                       invisible(muffled)
[10:21:28.073]                     }
[10:21:28.073]                     muffleCondition(cond, pattern = "^muffle")
[10:21:28.073]                   }
[10:21:28.073]                 }
[10:21:28.073]             }
[10:21:28.073]         }))
[10:21:28.073]     }, error = function(ex) {
[10:21:28.073]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:28.073]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:28.073]                 ...future.rng), started = ...future.startTime, 
[10:21:28.073]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:28.073]             version = "1.8"), class = "FutureResult")
[10:21:28.073]     }, finally = {
[10:21:28.073]         if (!identical(...future.workdir, getwd())) 
[10:21:28.073]             setwd(...future.workdir)
[10:21:28.073]         {
[10:21:28.073]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:28.073]                 ...future.oldOptions$nwarnings <- NULL
[10:21:28.073]             }
[10:21:28.073]             base::options(...future.oldOptions)
[10:21:28.073]             if (.Platform$OS.type == "windows") {
[10:21:28.073]                 old_names <- names(...future.oldEnvVars)
[10:21:28.073]                 envs <- base::Sys.getenv()
[10:21:28.073]                 names <- names(envs)
[10:21:28.073]                 common <- intersect(names, old_names)
[10:21:28.073]                 added <- setdiff(names, old_names)
[10:21:28.073]                 removed <- setdiff(old_names, names)
[10:21:28.073]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:28.073]                   envs[common]]
[10:21:28.073]                 NAMES <- toupper(changed)
[10:21:28.073]                 args <- list()
[10:21:28.073]                 for (kk in seq_along(NAMES)) {
[10:21:28.073]                   name <- changed[[kk]]
[10:21:28.073]                   NAME <- NAMES[[kk]]
[10:21:28.073]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.073]                     next
[10:21:28.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:28.073]                 }
[10:21:28.073]                 NAMES <- toupper(added)
[10:21:28.073]                 for (kk in seq_along(NAMES)) {
[10:21:28.073]                   name <- added[[kk]]
[10:21:28.073]                   NAME <- NAMES[[kk]]
[10:21:28.073]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.073]                     next
[10:21:28.073]                   args[[name]] <- ""
[10:21:28.073]                 }
[10:21:28.073]                 NAMES <- toupper(removed)
[10:21:28.073]                 for (kk in seq_along(NAMES)) {
[10:21:28.073]                   name <- removed[[kk]]
[10:21:28.073]                   NAME <- NAMES[[kk]]
[10:21:28.073]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.073]                     next
[10:21:28.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:28.073]                 }
[10:21:28.073]                 if (length(args) > 0) 
[10:21:28.073]                   base::do.call(base::Sys.setenv, args = args)
[10:21:28.073]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:28.073]             }
[10:21:28.073]             else {
[10:21:28.073]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:28.073]             }
[10:21:28.073]             {
[10:21:28.073]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:28.073]                   0L) {
[10:21:28.073]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:28.073]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:28.073]                   base::options(opts)
[10:21:28.073]                 }
[10:21:28.073]                 {
[10:21:28.073]                   {
[10:21:28.073]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:28.073]                     NULL
[10:21:28.073]                   }
[10:21:28.073]                   options(future.plan = NULL)
[10:21:28.073]                   if (is.na(NA_character_)) 
[10:21:28.073]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:28.073]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:28.073]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:28.073]                     .init = FALSE)
[10:21:28.073]                 }
[10:21:28.073]             }
[10:21:28.073]         }
[10:21:28.073]     })
[10:21:28.073]     if (TRUE) {
[10:21:28.073]         base::sink(type = "output", split = FALSE)
[10:21:28.073]         if (TRUE) {
[10:21:28.073]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:28.073]         }
[10:21:28.073]         else {
[10:21:28.073]             ...future.result["stdout"] <- base::list(NULL)
[10:21:28.073]         }
[10:21:28.073]         base::close(...future.stdout)
[10:21:28.073]         ...future.stdout <- NULL
[10:21:28.073]     }
[10:21:28.073]     ...future.result$conditions <- ...future.conditions
[10:21:28.073]     ...future.result$finished <- base::Sys.time()
[10:21:28.073]     ...future.result
[10:21:28.073] }
[10:21:28.076] MultisessionFuture started
[10:21:28.077] - Launch lazy future ... done
[10:21:28.077] run() for ‘MultisessionFuture’ ... done
[10:21:28.077] result() for ClusterFuture ...
[10:21:28.077] receiveMessageFromWorker() for ClusterFuture ...
[10:21:28.077] - Validating connection of MultisessionFuture
[10:21:28.120] - received message: FutureResult
[10:21:28.120] - Received FutureResult
[10:21:28.121] - Erased future from FutureRegistry
[10:21:28.121] result() for ClusterFuture ...
[10:21:28.121] - result already collected: FutureResult
[10:21:28.121] result() for ClusterFuture ... done
[10:21:28.121] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:28.121] result() for ClusterFuture ... done
[10:21:28.121] result() for ClusterFuture ...
[10:21:28.121] - result already collected: FutureResult
[10:21:28.121] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[10:21:28.124] getGlobalsAndPackages() ...
[10:21:28.124] Searching for globals...
[10:21:28.126] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[10:21:28.126] Searching for globals ... DONE
[10:21:28.126] Resolving globals: FALSE
[10:21:28.126] 
[10:21:28.126] - packages: [2] ‘stats’, ‘datasets’
[10:21:28.127] getGlobalsAndPackages() ... DONE
[10:21:28.127] run() for ‘Future’ ...
[10:21:28.127] - state: ‘created’
[10:21:28.127] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:28.141] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:28.141] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:28.141]   - Field: ‘node’
[10:21:28.141]   - Field: ‘label’
[10:21:28.141]   - Field: ‘local’
[10:21:28.142]   - Field: ‘owner’
[10:21:28.142]   - Field: ‘envir’
[10:21:28.142]   - Field: ‘workers’
[10:21:28.142]   - Field: ‘packages’
[10:21:28.142]   - Field: ‘gc’
[10:21:28.142]   - Field: ‘conditions’
[10:21:28.142]   - Field: ‘persistent’
[10:21:28.142]   - Field: ‘expr’
[10:21:28.142]   - Field: ‘uuid’
[10:21:28.142]   - Field: ‘seed’
[10:21:28.142]   - Field: ‘version’
[10:21:28.143]   - Field: ‘result’
[10:21:28.143]   - Field: ‘asynchronous’
[10:21:28.143]   - Field: ‘calls’
[10:21:28.143]   - Field: ‘globals’
[10:21:28.143]   - Field: ‘stdout’
[10:21:28.143]   - Field: ‘earlySignal’
[10:21:28.143]   - Field: ‘lazy’
[10:21:28.143]   - Field: ‘state’
[10:21:28.143] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:28.143] - Launch lazy future ...
[10:21:28.144] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:21:28.144] Packages needed by future strategies (n = 0): <none>
[10:21:28.144] {
[10:21:28.144]     {
[10:21:28.144]         {
[10:21:28.144]             ...future.startTime <- base::Sys.time()
[10:21:28.144]             {
[10:21:28.144]                 {
[10:21:28.144]                   {
[10:21:28.144]                     {
[10:21:28.144]                       {
[10:21:28.144]                         base::local({
[10:21:28.144]                           has_future <- base::requireNamespace("future", 
[10:21:28.144]                             quietly = TRUE)
[10:21:28.144]                           if (has_future) {
[10:21:28.144]                             ns <- base::getNamespace("future")
[10:21:28.144]                             version <- ns[[".package"]][["version"]]
[10:21:28.144]                             if (is.null(version)) 
[10:21:28.144]                               version <- utils::packageVersion("future")
[10:21:28.144]                           }
[10:21:28.144]                           else {
[10:21:28.144]                             version <- NULL
[10:21:28.144]                           }
[10:21:28.144]                           if (!has_future || version < "1.8.0") {
[10:21:28.144]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:28.144]                               "", base::R.version$version.string), 
[10:21:28.144]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:28.144]                                 base::R.version$platform, 8 * 
[10:21:28.144]                                   base::.Machine$sizeof.pointer), 
[10:21:28.144]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:28.144]                                 "release", "version")], collapse = " "), 
[10:21:28.144]                               hostname = base::Sys.info()[["nodename"]])
[10:21:28.144]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:28.144]                               info)
[10:21:28.144]                             info <- base::paste(info, collapse = "; ")
[10:21:28.144]                             if (!has_future) {
[10:21:28.144]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:28.144]                                 info)
[10:21:28.144]                             }
[10:21:28.144]                             else {
[10:21:28.144]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:28.144]                                 info, version)
[10:21:28.144]                             }
[10:21:28.144]                             base::stop(msg)
[10:21:28.144]                           }
[10:21:28.144]                         })
[10:21:28.144]                       }
[10:21:28.144]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:28.144]                       base::options(mc.cores = 1L)
[10:21:28.144]                     }
[10:21:28.144]                     base::local({
[10:21:28.144]                       for (pkg in c("stats", "datasets")) {
[10:21:28.144]                         base::loadNamespace(pkg)
[10:21:28.144]                         base::library(pkg, character.only = TRUE)
[10:21:28.144]                       }
[10:21:28.144]                     })
[10:21:28.144]                   }
[10:21:28.144]                   ...future.strategy.old <- future::plan("list")
[10:21:28.144]                   options(future.plan = NULL)
[10:21:28.144]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:28.144]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:28.144]                 }
[10:21:28.144]                 ...future.workdir <- getwd()
[10:21:28.144]             }
[10:21:28.144]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:28.144]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:28.144]         }
[10:21:28.144]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:28.144]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:28.144]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:28.144]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:28.144]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:28.144]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:28.144]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:28.144]             base::names(...future.oldOptions))
[10:21:28.144]     }
[10:21:28.144]     if (FALSE) {
[10:21:28.144]     }
[10:21:28.144]     else {
[10:21:28.144]         if (TRUE) {
[10:21:28.144]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:28.144]                 open = "w")
[10:21:28.144]         }
[10:21:28.144]         else {
[10:21:28.144]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:28.144]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:28.144]         }
[10:21:28.144]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:28.144]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:28.144]             base::sink(type = "output", split = FALSE)
[10:21:28.144]             base::close(...future.stdout)
[10:21:28.144]         }, add = TRUE)
[10:21:28.144]     }
[10:21:28.144]     ...future.frame <- base::sys.nframe()
[10:21:28.144]     ...future.conditions <- base::list()
[10:21:28.144]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:28.144]     if (FALSE) {
[10:21:28.144]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:28.144]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:28.144]     }
[10:21:28.144]     ...future.result <- base::tryCatch({
[10:21:28.144]         base::withCallingHandlers({
[10:21:28.144]             ...future.value <- base::withVisible(base::local({
[10:21:28.144]                 ...future.makeSendCondition <- base::local({
[10:21:28.144]                   sendCondition <- NULL
[10:21:28.144]                   function(frame = 1L) {
[10:21:28.144]                     if (is.function(sendCondition)) 
[10:21:28.144]                       return(sendCondition)
[10:21:28.144]                     ns <- getNamespace("parallel")
[10:21:28.144]                     if (exists("sendData", mode = "function", 
[10:21:28.144]                       envir = ns)) {
[10:21:28.144]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:28.144]                         envir = ns)
[10:21:28.144]                       envir <- sys.frame(frame)
[10:21:28.144]                       master <- NULL
[10:21:28.144]                       while (!identical(envir, .GlobalEnv) && 
[10:21:28.144]                         !identical(envir, emptyenv())) {
[10:21:28.144]                         if (exists("master", mode = "list", envir = envir, 
[10:21:28.144]                           inherits = FALSE)) {
[10:21:28.144]                           master <- get("master", mode = "list", 
[10:21:28.144]                             envir = envir, inherits = FALSE)
[10:21:28.144]                           if (inherits(master, c("SOCKnode", 
[10:21:28.144]                             "SOCK0node"))) {
[10:21:28.144]                             sendCondition <<- function(cond) {
[10:21:28.144]                               data <- list(type = "VALUE", value = cond, 
[10:21:28.144]                                 success = TRUE)
[10:21:28.144]                               parallel_sendData(master, data)
[10:21:28.144]                             }
[10:21:28.144]                             return(sendCondition)
[10:21:28.144]                           }
[10:21:28.144]                         }
[10:21:28.144]                         frame <- frame + 1L
[10:21:28.144]                         envir <- sys.frame(frame)
[10:21:28.144]                       }
[10:21:28.144]                     }
[10:21:28.144]                     sendCondition <<- function(cond) NULL
[10:21:28.144]                   }
[10:21:28.144]                 })
[10:21:28.144]                 withCallingHandlers({
[10:21:28.144]                   {
[10:21:28.144]                     lm(dist ~ . + 0, data = cars)
[10:21:28.144]                   }
[10:21:28.144]                 }, immediateCondition = function(cond) {
[10:21:28.144]                   sendCondition <- ...future.makeSendCondition()
[10:21:28.144]                   sendCondition(cond)
[10:21:28.144]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.144]                   {
[10:21:28.144]                     inherits <- base::inherits
[10:21:28.144]                     invokeRestart <- base::invokeRestart
[10:21:28.144]                     is.null <- base::is.null
[10:21:28.144]                     muffled <- FALSE
[10:21:28.144]                     if (inherits(cond, "message")) {
[10:21:28.144]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:28.144]                       if (muffled) 
[10:21:28.144]                         invokeRestart("muffleMessage")
[10:21:28.144]                     }
[10:21:28.144]                     else if (inherits(cond, "warning")) {
[10:21:28.144]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:28.144]                       if (muffled) 
[10:21:28.144]                         invokeRestart("muffleWarning")
[10:21:28.144]                     }
[10:21:28.144]                     else if (inherits(cond, "condition")) {
[10:21:28.144]                       if (!is.null(pattern)) {
[10:21:28.144]                         computeRestarts <- base::computeRestarts
[10:21:28.144]                         grepl <- base::grepl
[10:21:28.144]                         restarts <- computeRestarts(cond)
[10:21:28.144]                         for (restart in restarts) {
[10:21:28.144]                           name <- restart$name
[10:21:28.144]                           if (is.null(name)) 
[10:21:28.144]                             next
[10:21:28.144]                           if (!grepl(pattern, name)) 
[10:21:28.144]                             next
[10:21:28.144]                           invokeRestart(restart)
[10:21:28.144]                           muffled <- TRUE
[10:21:28.144]                           break
[10:21:28.144]                         }
[10:21:28.144]                       }
[10:21:28.144]                     }
[10:21:28.144]                     invisible(muffled)
[10:21:28.144]                   }
[10:21:28.144]                   muffleCondition(cond)
[10:21:28.144]                 })
[10:21:28.144]             }))
[10:21:28.144]             future::FutureResult(value = ...future.value$value, 
[10:21:28.144]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:28.144]                   ...future.rng), globalenv = if (FALSE) 
[10:21:28.144]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:28.144]                     ...future.globalenv.names))
[10:21:28.144]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:28.144]         }, condition = base::local({
[10:21:28.144]             c <- base::c
[10:21:28.144]             inherits <- base::inherits
[10:21:28.144]             invokeRestart <- base::invokeRestart
[10:21:28.144]             length <- base::length
[10:21:28.144]             list <- base::list
[10:21:28.144]             seq.int <- base::seq.int
[10:21:28.144]             signalCondition <- base::signalCondition
[10:21:28.144]             sys.calls <- base::sys.calls
[10:21:28.144]             `[[` <- base::`[[`
[10:21:28.144]             `+` <- base::`+`
[10:21:28.144]             `<<-` <- base::`<<-`
[10:21:28.144]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:28.144]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:28.144]                   3L)]
[10:21:28.144]             }
[10:21:28.144]             function(cond) {
[10:21:28.144]                 is_error <- inherits(cond, "error")
[10:21:28.144]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:28.144]                   NULL)
[10:21:28.144]                 if (is_error) {
[10:21:28.144]                   sessionInformation <- function() {
[10:21:28.144]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:28.144]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:28.144]                       search = base::search(), system = base::Sys.info())
[10:21:28.144]                   }
[10:21:28.144]                   ...future.conditions[[length(...future.conditions) + 
[10:21:28.144]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:28.144]                     cond$call), session = sessionInformation(), 
[10:21:28.144]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:28.144]                   signalCondition(cond)
[10:21:28.144]                 }
[10:21:28.144]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:28.144]                 "immediateCondition"))) {
[10:21:28.144]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:28.144]                   ...future.conditions[[length(...future.conditions) + 
[10:21:28.144]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:28.144]                   if (TRUE && !signal) {
[10:21:28.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.144]                     {
[10:21:28.144]                       inherits <- base::inherits
[10:21:28.144]                       invokeRestart <- base::invokeRestart
[10:21:28.144]                       is.null <- base::is.null
[10:21:28.144]                       muffled <- FALSE
[10:21:28.144]                       if (inherits(cond, "message")) {
[10:21:28.144]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:28.144]                         if (muffled) 
[10:21:28.144]                           invokeRestart("muffleMessage")
[10:21:28.144]                       }
[10:21:28.144]                       else if (inherits(cond, "warning")) {
[10:21:28.144]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:28.144]                         if (muffled) 
[10:21:28.144]                           invokeRestart("muffleWarning")
[10:21:28.144]                       }
[10:21:28.144]                       else if (inherits(cond, "condition")) {
[10:21:28.144]                         if (!is.null(pattern)) {
[10:21:28.144]                           computeRestarts <- base::computeRestarts
[10:21:28.144]                           grepl <- base::grepl
[10:21:28.144]                           restarts <- computeRestarts(cond)
[10:21:28.144]                           for (restart in restarts) {
[10:21:28.144]                             name <- restart$name
[10:21:28.144]                             if (is.null(name)) 
[10:21:28.144]                               next
[10:21:28.144]                             if (!grepl(pattern, name)) 
[10:21:28.144]                               next
[10:21:28.144]                             invokeRestart(restart)
[10:21:28.144]                             muffled <- TRUE
[10:21:28.144]                             break
[10:21:28.144]                           }
[10:21:28.144]                         }
[10:21:28.144]                       }
[10:21:28.144]                       invisible(muffled)
[10:21:28.144]                     }
[10:21:28.144]                     muffleCondition(cond, pattern = "^muffle")
[10:21:28.144]                   }
[10:21:28.144]                 }
[10:21:28.144]                 else {
[10:21:28.144]                   if (TRUE) {
[10:21:28.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.144]                     {
[10:21:28.144]                       inherits <- base::inherits
[10:21:28.144]                       invokeRestart <- base::invokeRestart
[10:21:28.144]                       is.null <- base::is.null
[10:21:28.144]                       muffled <- FALSE
[10:21:28.144]                       if (inherits(cond, "message")) {
[10:21:28.144]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:28.144]                         if (muffled) 
[10:21:28.144]                           invokeRestart("muffleMessage")
[10:21:28.144]                       }
[10:21:28.144]                       else if (inherits(cond, "warning")) {
[10:21:28.144]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:28.144]                         if (muffled) 
[10:21:28.144]                           invokeRestart("muffleWarning")
[10:21:28.144]                       }
[10:21:28.144]                       else if (inherits(cond, "condition")) {
[10:21:28.144]                         if (!is.null(pattern)) {
[10:21:28.144]                           computeRestarts <- base::computeRestarts
[10:21:28.144]                           grepl <- base::grepl
[10:21:28.144]                           restarts <- computeRestarts(cond)
[10:21:28.144]                           for (restart in restarts) {
[10:21:28.144]                             name <- restart$name
[10:21:28.144]                             if (is.null(name)) 
[10:21:28.144]                               next
[10:21:28.144]                             if (!grepl(pattern, name)) 
[10:21:28.144]                               next
[10:21:28.144]                             invokeRestart(restart)
[10:21:28.144]                             muffled <- TRUE
[10:21:28.144]                             break
[10:21:28.144]                           }
[10:21:28.144]                         }
[10:21:28.144]                       }
[10:21:28.144]                       invisible(muffled)
[10:21:28.144]                     }
[10:21:28.144]                     muffleCondition(cond, pattern = "^muffle")
[10:21:28.144]                   }
[10:21:28.144]                 }
[10:21:28.144]             }
[10:21:28.144]         }))
[10:21:28.144]     }, error = function(ex) {
[10:21:28.144]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:28.144]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:28.144]                 ...future.rng), started = ...future.startTime, 
[10:21:28.144]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:28.144]             version = "1.8"), class = "FutureResult")
[10:21:28.144]     }, finally = {
[10:21:28.144]         if (!identical(...future.workdir, getwd())) 
[10:21:28.144]             setwd(...future.workdir)
[10:21:28.144]         {
[10:21:28.144]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:28.144]                 ...future.oldOptions$nwarnings <- NULL
[10:21:28.144]             }
[10:21:28.144]             base::options(...future.oldOptions)
[10:21:28.144]             if (.Platform$OS.type == "windows") {
[10:21:28.144]                 old_names <- names(...future.oldEnvVars)
[10:21:28.144]                 envs <- base::Sys.getenv()
[10:21:28.144]                 names <- names(envs)
[10:21:28.144]                 common <- intersect(names, old_names)
[10:21:28.144]                 added <- setdiff(names, old_names)
[10:21:28.144]                 removed <- setdiff(old_names, names)
[10:21:28.144]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:28.144]                   envs[common]]
[10:21:28.144]                 NAMES <- toupper(changed)
[10:21:28.144]                 args <- list()
[10:21:28.144]                 for (kk in seq_along(NAMES)) {
[10:21:28.144]                   name <- changed[[kk]]
[10:21:28.144]                   NAME <- NAMES[[kk]]
[10:21:28.144]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.144]                     next
[10:21:28.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:28.144]                 }
[10:21:28.144]                 NAMES <- toupper(added)
[10:21:28.144]                 for (kk in seq_along(NAMES)) {
[10:21:28.144]                   name <- added[[kk]]
[10:21:28.144]                   NAME <- NAMES[[kk]]
[10:21:28.144]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.144]                     next
[10:21:28.144]                   args[[name]] <- ""
[10:21:28.144]                 }
[10:21:28.144]                 NAMES <- toupper(removed)
[10:21:28.144]                 for (kk in seq_along(NAMES)) {
[10:21:28.144]                   name <- removed[[kk]]
[10:21:28.144]                   NAME <- NAMES[[kk]]
[10:21:28.144]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.144]                     next
[10:21:28.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:28.144]                 }
[10:21:28.144]                 if (length(args) > 0) 
[10:21:28.144]                   base::do.call(base::Sys.setenv, args = args)
[10:21:28.144]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:28.144]             }
[10:21:28.144]             else {
[10:21:28.144]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:28.144]             }
[10:21:28.144]             {
[10:21:28.144]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:28.144]                   0L) {
[10:21:28.144]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:28.144]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:28.144]                   base::options(opts)
[10:21:28.144]                 }
[10:21:28.144]                 {
[10:21:28.144]                   {
[10:21:28.144]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:28.144]                     NULL
[10:21:28.144]                   }
[10:21:28.144]                   options(future.plan = NULL)
[10:21:28.144]                   if (is.na(NA_character_)) 
[10:21:28.144]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:28.144]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:28.144]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:28.144]                     .init = FALSE)
[10:21:28.144]                 }
[10:21:28.144]             }
[10:21:28.144]         }
[10:21:28.144]     })
[10:21:28.144]     if (TRUE) {
[10:21:28.144]         base::sink(type = "output", split = FALSE)
[10:21:28.144]         if (TRUE) {
[10:21:28.144]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:28.144]         }
[10:21:28.144]         else {
[10:21:28.144]             ...future.result["stdout"] <- base::list(NULL)
[10:21:28.144]         }
[10:21:28.144]         base::close(...future.stdout)
[10:21:28.144]         ...future.stdout <- NULL
[10:21:28.144]     }
[10:21:28.144]     ...future.result$conditions <- ...future.conditions
[10:21:28.144]     ...future.result$finished <- base::Sys.time()
[10:21:28.144]     ...future.result
[10:21:28.144] }
[10:21:28.147] MultisessionFuture started
[10:21:28.147] - Launch lazy future ... done
[10:21:28.147] run() for ‘MultisessionFuture’ ... done
[10:21:28.148] result() for ClusterFuture ...
[10:21:28.148] receiveMessageFromWorker() for ClusterFuture ...
[10:21:28.148] - Validating connection of MultisessionFuture
[10:21:28.190] - received message: FutureResult
[10:21:28.190] - Received FutureResult
[10:21:28.190] - Erased future from FutureRegistry
[10:21:28.190] result() for ClusterFuture ...
[10:21:28.190] - result already collected: FutureResult
[10:21:28.191] result() for ClusterFuture ... done
[10:21:28.191] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:28.191] result() for ClusterFuture ... done
[10:21:28.191] result() for ClusterFuture ...
[10:21:28.191] - result already collected: FutureResult
[10:21:28.191] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[10:21:28.193] getGlobalsAndPackages() ...
[10:21:28.193] Searching for globals...
[10:21:28.195] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[10:21:28.195] Searching for globals ... DONE
[10:21:28.195] Resolving globals: FALSE
[10:21:28.196] 
[10:21:28.196] - packages: [2] ‘stats’, ‘datasets’
[10:21:28.196] getGlobalsAndPackages() ... DONE
[10:21:28.196] run() for ‘Future’ ...
[10:21:28.196] - state: ‘created’
[10:21:28.197] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:28.210] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:28.211] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:28.211]   - Field: ‘node’
[10:21:28.211]   - Field: ‘label’
[10:21:28.211]   - Field: ‘local’
[10:21:28.211]   - Field: ‘owner’
[10:21:28.211]   - Field: ‘envir’
[10:21:28.211]   - Field: ‘workers’
[10:21:28.211]   - Field: ‘packages’
[10:21:28.211]   - Field: ‘gc’
[10:21:28.211]   - Field: ‘conditions’
[10:21:28.211]   - Field: ‘persistent’
[10:21:28.212]   - Field: ‘expr’
[10:21:28.212]   - Field: ‘uuid’
[10:21:28.212]   - Field: ‘seed’
[10:21:28.212]   - Field: ‘version’
[10:21:28.212]   - Field: ‘result’
[10:21:28.212]   - Field: ‘asynchronous’
[10:21:28.212]   - Field: ‘calls’
[10:21:28.212]   - Field: ‘globals’
[10:21:28.212]   - Field: ‘stdout’
[10:21:28.212]   - Field: ‘earlySignal’
[10:21:28.212]   - Field: ‘lazy’
[10:21:28.213]   - Field: ‘state’
[10:21:28.213] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:28.213] - Launch lazy future ...
[10:21:28.213] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:21:28.213] Packages needed by future strategies (n = 0): <none>
[10:21:28.214] {
[10:21:28.214]     {
[10:21:28.214]         {
[10:21:28.214]             ...future.startTime <- base::Sys.time()
[10:21:28.214]             {
[10:21:28.214]                 {
[10:21:28.214]                   {
[10:21:28.214]                     {
[10:21:28.214]                       {
[10:21:28.214]                         base::local({
[10:21:28.214]                           has_future <- base::requireNamespace("future", 
[10:21:28.214]                             quietly = TRUE)
[10:21:28.214]                           if (has_future) {
[10:21:28.214]                             ns <- base::getNamespace("future")
[10:21:28.214]                             version <- ns[[".package"]][["version"]]
[10:21:28.214]                             if (is.null(version)) 
[10:21:28.214]                               version <- utils::packageVersion("future")
[10:21:28.214]                           }
[10:21:28.214]                           else {
[10:21:28.214]                             version <- NULL
[10:21:28.214]                           }
[10:21:28.214]                           if (!has_future || version < "1.8.0") {
[10:21:28.214]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:28.214]                               "", base::R.version$version.string), 
[10:21:28.214]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:28.214]                                 base::R.version$platform, 8 * 
[10:21:28.214]                                   base::.Machine$sizeof.pointer), 
[10:21:28.214]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:28.214]                                 "release", "version")], collapse = " "), 
[10:21:28.214]                               hostname = base::Sys.info()[["nodename"]])
[10:21:28.214]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:28.214]                               info)
[10:21:28.214]                             info <- base::paste(info, collapse = "; ")
[10:21:28.214]                             if (!has_future) {
[10:21:28.214]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:28.214]                                 info)
[10:21:28.214]                             }
[10:21:28.214]                             else {
[10:21:28.214]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:28.214]                                 info, version)
[10:21:28.214]                             }
[10:21:28.214]                             base::stop(msg)
[10:21:28.214]                           }
[10:21:28.214]                         })
[10:21:28.214]                       }
[10:21:28.214]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:28.214]                       base::options(mc.cores = 1L)
[10:21:28.214]                     }
[10:21:28.214]                     base::local({
[10:21:28.214]                       for (pkg in c("stats", "datasets")) {
[10:21:28.214]                         base::loadNamespace(pkg)
[10:21:28.214]                         base::library(pkg, character.only = TRUE)
[10:21:28.214]                       }
[10:21:28.214]                     })
[10:21:28.214]                   }
[10:21:28.214]                   ...future.strategy.old <- future::plan("list")
[10:21:28.214]                   options(future.plan = NULL)
[10:21:28.214]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:28.214]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:28.214]                 }
[10:21:28.214]                 ...future.workdir <- getwd()
[10:21:28.214]             }
[10:21:28.214]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:28.214]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:28.214]         }
[10:21:28.214]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:28.214]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:28.214]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:28.214]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:28.214]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:28.214]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:28.214]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:28.214]             base::names(...future.oldOptions))
[10:21:28.214]     }
[10:21:28.214]     if (FALSE) {
[10:21:28.214]     }
[10:21:28.214]     else {
[10:21:28.214]         if (TRUE) {
[10:21:28.214]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:28.214]                 open = "w")
[10:21:28.214]         }
[10:21:28.214]         else {
[10:21:28.214]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:28.214]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:28.214]         }
[10:21:28.214]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:28.214]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:28.214]             base::sink(type = "output", split = FALSE)
[10:21:28.214]             base::close(...future.stdout)
[10:21:28.214]         }, add = TRUE)
[10:21:28.214]     }
[10:21:28.214]     ...future.frame <- base::sys.nframe()
[10:21:28.214]     ...future.conditions <- base::list()
[10:21:28.214]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:28.214]     if (FALSE) {
[10:21:28.214]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:28.214]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:28.214]     }
[10:21:28.214]     ...future.result <- base::tryCatch({
[10:21:28.214]         base::withCallingHandlers({
[10:21:28.214]             ...future.value <- base::withVisible(base::local({
[10:21:28.214]                 ...future.makeSendCondition <- base::local({
[10:21:28.214]                   sendCondition <- NULL
[10:21:28.214]                   function(frame = 1L) {
[10:21:28.214]                     if (is.function(sendCondition)) 
[10:21:28.214]                       return(sendCondition)
[10:21:28.214]                     ns <- getNamespace("parallel")
[10:21:28.214]                     if (exists("sendData", mode = "function", 
[10:21:28.214]                       envir = ns)) {
[10:21:28.214]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:28.214]                         envir = ns)
[10:21:28.214]                       envir <- sys.frame(frame)
[10:21:28.214]                       master <- NULL
[10:21:28.214]                       while (!identical(envir, .GlobalEnv) && 
[10:21:28.214]                         !identical(envir, emptyenv())) {
[10:21:28.214]                         if (exists("master", mode = "list", envir = envir, 
[10:21:28.214]                           inherits = FALSE)) {
[10:21:28.214]                           master <- get("master", mode = "list", 
[10:21:28.214]                             envir = envir, inherits = FALSE)
[10:21:28.214]                           if (inherits(master, c("SOCKnode", 
[10:21:28.214]                             "SOCK0node"))) {
[10:21:28.214]                             sendCondition <<- function(cond) {
[10:21:28.214]                               data <- list(type = "VALUE", value = cond, 
[10:21:28.214]                                 success = TRUE)
[10:21:28.214]                               parallel_sendData(master, data)
[10:21:28.214]                             }
[10:21:28.214]                             return(sendCondition)
[10:21:28.214]                           }
[10:21:28.214]                         }
[10:21:28.214]                         frame <- frame + 1L
[10:21:28.214]                         envir <- sys.frame(frame)
[10:21:28.214]                       }
[10:21:28.214]                     }
[10:21:28.214]                     sendCondition <<- function(cond) NULL
[10:21:28.214]                   }
[10:21:28.214]                 })
[10:21:28.214]                 withCallingHandlers({
[10:21:28.214]                   {
[10:21:28.214]                     lm(dist ~ speed + speed^2, data = cars)
[10:21:28.214]                   }
[10:21:28.214]                 }, immediateCondition = function(cond) {
[10:21:28.214]                   sendCondition <- ...future.makeSendCondition()
[10:21:28.214]                   sendCondition(cond)
[10:21:28.214]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.214]                   {
[10:21:28.214]                     inherits <- base::inherits
[10:21:28.214]                     invokeRestart <- base::invokeRestart
[10:21:28.214]                     is.null <- base::is.null
[10:21:28.214]                     muffled <- FALSE
[10:21:28.214]                     if (inherits(cond, "message")) {
[10:21:28.214]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:28.214]                       if (muffled) 
[10:21:28.214]                         invokeRestart("muffleMessage")
[10:21:28.214]                     }
[10:21:28.214]                     else if (inherits(cond, "warning")) {
[10:21:28.214]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:28.214]                       if (muffled) 
[10:21:28.214]                         invokeRestart("muffleWarning")
[10:21:28.214]                     }
[10:21:28.214]                     else if (inherits(cond, "condition")) {
[10:21:28.214]                       if (!is.null(pattern)) {
[10:21:28.214]                         computeRestarts <- base::computeRestarts
[10:21:28.214]                         grepl <- base::grepl
[10:21:28.214]                         restarts <- computeRestarts(cond)
[10:21:28.214]                         for (restart in restarts) {
[10:21:28.214]                           name <- restart$name
[10:21:28.214]                           if (is.null(name)) 
[10:21:28.214]                             next
[10:21:28.214]                           if (!grepl(pattern, name)) 
[10:21:28.214]                             next
[10:21:28.214]                           invokeRestart(restart)
[10:21:28.214]                           muffled <- TRUE
[10:21:28.214]                           break
[10:21:28.214]                         }
[10:21:28.214]                       }
[10:21:28.214]                     }
[10:21:28.214]                     invisible(muffled)
[10:21:28.214]                   }
[10:21:28.214]                   muffleCondition(cond)
[10:21:28.214]                 })
[10:21:28.214]             }))
[10:21:28.214]             future::FutureResult(value = ...future.value$value, 
[10:21:28.214]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:28.214]                   ...future.rng), globalenv = if (FALSE) 
[10:21:28.214]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:28.214]                     ...future.globalenv.names))
[10:21:28.214]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:28.214]         }, condition = base::local({
[10:21:28.214]             c <- base::c
[10:21:28.214]             inherits <- base::inherits
[10:21:28.214]             invokeRestart <- base::invokeRestart
[10:21:28.214]             length <- base::length
[10:21:28.214]             list <- base::list
[10:21:28.214]             seq.int <- base::seq.int
[10:21:28.214]             signalCondition <- base::signalCondition
[10:21:28.214]             sys.calls <- base::sys.calls
[10:21:28.214]             `[[` <- base::`[[`
[10:21:28.214]             `+` <- base::`+`
[10:21:28.214]             `<<-` <- base::`<<-`
[10:21:28.214]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:28.214]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:28.214]                   3L)]
[10:21:28.214]             }
[10:21:28.214]             function(cond) {
[10:21:28.214]                 is_error <- inherits(cond, "error")
[10:21:28.214]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:28.214]                   NULL)
[10:21:28.214]                 if (is_error) {
[10:21:28.214]                   sessionInformation <- function() {
[10:21:28.214]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:28.214]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:28.214]                       search = base::search(), system = base::Sys.info())
[10:21:28.214]                   }
[10:21:28.214]                   ...future.conditions[[length(...future.conditions) + 
[10:21:28.214]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:28.214]                     cond$call), session = sessionInformation(), 
[10:21:28.214]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:28.214]                   signalCondition(cond)
[10:21:28.214]                 }
[10:21:28.214]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:28.214]                 "immediateCondition"))) {
[10:21:28.214]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:28.214]                   ...future.conditions[[length(...future.conditions) + 
[10:21:28.214]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:28.214]                   if (TRUE && !signal) {
[10:21:28.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.214]                     {
[10:21:28.214]                       inherits <- base::inherits
[10:21:28.214]                       invokeRestart <- base::invokeRestart
[10:21:28.214]                       is.null <- base::is.null
[10:21:28.214]                       muffled <- FALSE
[10:21:28.214]                       if (inherits(cond, "message")) {
[10:21:28.214]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:28.214]                         if (muffled) 
[10:21:28.214]                           invokeRestart("muffleMessage")
[10:21:28.214]                       }
[10:21:28.214]                       else if (inherits(cond, "warning")) {
[10:21:28.214]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:28.214]                         if (muffled) 
[10:21:28.214]                           invokeRestart("muffleWarning")
[10:21:28.214]                       }
[10:21:28.214]                       else if (inherits(cond, "condition")) {
[10:21:28.214]                         if (!is.null(pattern)) {
[10:21:28.214]                           computeRestarts <- base::computeRestarts
[10:21:28.214]                           grepl <- base::grepl
[10:21:28.214]                           restarts <- computeRestarts(cond)
[10:21:28.214]                           for (restart in restarts) {
[10:21:28.214]                             name <- restart$name
[10:21:28.214]                             if (is.null(name)) 
[10:21:28.214]                               next
[10:21:28.214]                             if (!grepl(pattern, name)) 
[10:21:28.214]                               next
[10:21:28.214]                             invokeRestart(restart)
[10:21:28.214]                             muffled <- TRUE
[10:21:28.214]                             break
[10:21:28.214]                           }
[10:21:28.214]                         }
[10:21:28.214]                       }
[10:21:28.214]                       invisible(muffled)
[10:21:28.214]                     }
[10:21:28.214]                     muffleCondition(cond, pattern = "^muffle")
[10:21:28.214]                   }
[10:21:28.214]                 }
[10:21:28.214]                 else {
[10:21:28.214]                   if (TRUE) {
[10:21:28.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.214]                     {
[10:21:28.214]                       inherits <- base::inherits
[10:21:28.214]                       invokeRestart <- base::invokeRestart
[10:21:28.214]                       is.null <- base::is.null
[10:21:28.214]                       muffled <- FALSE
[10:21:28.214]                       if (inherits(cond, "message")) {
[10:21:28.214]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:28.214]                         if (muffled) 
[10:21:28.214]                           invokeRestart("muffleMessage")
[10:21:28.214]                       }
[10:21:28.214]                       else if (inherits(cond, "warning")) {
[10:21:28.214]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:28.214]                         if (muffled) 
[10:21:28.214]                           invokeRestart("muffleWarning")
[10:21:28.214]                       }
[10:21:28.214]                       else if (inherits(cond, "condition")) {
[10:21:28.214]                         if (!is.null(pattern)) {
[10:21:28.214]                           computeRestarts <- base::computeRestarts
[10:21:28.214]                           grepl <- base::grepl
[10:21:28.214]                           restarts <- computeRestarts(cond)
[10:21:28.214]                           for (restart in restarts) {
[10:21:28.214]                             name <- restart$name
[10:21:28.214]                             if (is.null(name)) 
[10:21:28.214]                               next
[10:21:28.214]                             if (!grepl(pattern, name)) 
[10:21:28.214]                               next
[10:21:28.214]                             invokeRestart(restart)
[10:21:28.214]                             muffled <- TRUE
[10:21:28.214]                             break
[10:21:28.214]                           }
[10:21:28.214]                         }
[10:21:28.214]                       }
[10:21:28.214]                       invisible(muffled)
[10:21:28.214]                     }
[10:21:28.214]                     muffleCondition(cond, pattern = "^muffle")
[10:21:28.214]                   }
[10:21:28.214]                 }
[10:21:28.214]             }
[10:21:28.214]         }))
[10:21:28.214]     }, error = function(ex) {
[10:21:28.214]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:28.214]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:28.214]                 ...future.rng), started = ...future.startTime, 
[10:21:28.214]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:28.214]             version = "1.8"), class = "FutureResult")
[10:21:28.214]     }, finally = {
[10:21:28.214]         if (!identical(...future.workdir, getwd())) 
[10:21:28.214]             setwd(...future.workdir)
[10:21:28.214]         {
[10:21:28.214]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:28.214]                 ...future.oldOptions$nwarnings <- NULL
[10:21:28.214]             }
[10:21:28.214]             base::options(...future.oldOptions)
[10:21:28.214]             if (.Platform$OS.type == "windows") {
[10:21:28.214]                 old_names <- names(...future.oldEnvVars)
[10:21:28.214]                 envs <- base::Sys.getenv()
[10:21:28.214]                 names <- names(envs)
[10:21:28.214]                 common <- intersect(names, old_names)
[10:21:28.214]                 added <- setdiff(names, old_names)
[10:21:28.214]                 removed <- setdiff(old_names, names)
[10:21:28.214]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:28.214]                   envs[common]]
[10:21:28.214]                 NAMES <- toupper(changed)
[10:21:28.214]                 args <- list()
[10:21:28.214]                 for (kk in seq_along(NAMES)) {
[10:21:28.214]                   name <- changed[[kk]]
[10:21:28.214]                   NAME <- NAMES[[kk]]
[10:21:28.214]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.214]                     next
[10:21:28.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:28.214]                 }
[10:21:28.214]                 NAMES <- toupper(added)
[10:21:28.214]                 for (kk in seq_along(NAMES)) {
[10:21:28.214]                   name <- added[[kk]]
[10:21:28.214]                   NAME <- NAMES[[kk]]
[10:21:28.214]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.214]                     next
[10:21:28.214]                   args[[name]] <- ""
[10:21:28.214]                 }
[10:21:28.214]                 NAMES <- toupper(removed)
[10:21:28.214]                 for (kk in seq_along(NAMES)) {
[10:21:28.214]                   name <- removed[[kk]]
[10:21:28.214]                   NAME <- NAMES[[kk]]
[10:21:28.214]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.214]                     next
[10:21:28.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:28.214]                 }
[10:21:28.214]                 if (length(args) > 0) 
[10:21:28.214]                   base::do.call(base::Sys.setenv, args = args)
[10:21:28.214]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:28.214]             }
[10:21:28.214]             else {
[10:21:28.214]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:28.214]             }
[10:21:28.214]             {
[10:21:28.214]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:28.214]                   0L) {
[10:21:28.214]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:28.214]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:28.214]                   base::options(opts)
[10:21:28.214]                 }
[10:21:28.214]                 {
[10:21:28.214]                   {
[10:21:28.214]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:28.214]                     NULL
[10:21:28.214]                   }
[10:21:28.214]                   options(future.plan = NULL)
[10:21:28.214]                   if (is.na(NA_character_)) 
[10:21:28.214]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:28.214]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:28.214]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:28.214]                     .init = FALSE)
[10:21:28.214]                 }
[10:21:28.214]             }
[10:21:28.214]         }
[10:21:28.214]     })
[10:21:28.214]     if (TRUE) {
[10:21:28.214]         base::sink(type = "output", split = FALSE)
[10:21:28.214]         if (TRUE) {
[10:21:28.214]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:28.214]         }
[10:21:28.214]         else {
[10:21:28.214]             ...future.result["stdout"] <- base::list(NULL)
[10:21:28.214]         }
[10:21:28.214]         base::close(...future.stdout)
[10:21:28.214]         ...future.stdout <- NULL
[10:21:28.214]     }
[10:21:28.214]     ...future.result$conditions <- ...future.conditions
[10:21:28.214]     ...future.result$finished <- base::Sys.time()
[10:21:28.214]     ...future.result
[10:21:28.214] }
[10:21:28.217] MultisessionFuture started
[10:21:28.217] - Launch lazy future ... done
[10:21:28.217] run() for ‘MultisessionFuture’ ... done
[10:21:28.217] result() for ClusterFuture ...
[10:21:28.217] receiveMessageFromWorker() for ClusterFuture ...
[10:21:28.217] - Validating connection of MultisessionFuture
[10:21:28.260] - received message: FutureResult
[10:21:28.260] - Received FutureResult
[10:21:28.260] - Erased future from FutureRegistry
[10:21:28.260] result() for ClusterFuture ...
[10:21:28.261] - result already collected: FutureResult
[10:21:28.261] result() for ClusterFuture ... done
[10:21:28.263] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:28.263] result() for ClusterFuture ... done
[10:21:28.263] result() for ClusterFuture ...
[10:21:28.263] - result already collected: FutureResult
[10:21:28.263] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[10:21:28.266] getGlobalsAndPackages() ...
[10:21:28.266] Searching for globals...
[10:21:28.268] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[10:21:28.268] Searching for globals ... DONE
[10:21:28.268] Resolving globals: FALSE
[10:21:28.269] 
[10:21:28.269] - packages: [2] ‘stats’, ‘datasets’
[10:21:28.269] getGlobalsAndPackages() ... DONE
[10:21:28.269] run() for ‘Future’ ...
[10:21:28.269] - state: ‘created’
[10:21:28.269] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:28.283] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:28.283] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:28.283]   - Field: ‘node’
[10:21:28.284]   - Field: ‘label’
[10:21:28.284]   - Field: ‘local’
[10:21:28.284]   - Field: ‘owner’
[10:21:28.284]   - Field: ‘envir’
[10:21:28.284]   - Field: ‘workers’
[10:21:28.284]   - Field: ‘packages’
[10:21:28.284]   - Field: ‘gc’
[10:21:28.284]   - Field: ‘conditions’
[10:21:28.284]   - Field: ‘persistent’
[10:21:28.284]   - Field: ‘expr’
[10:21:28.284]   - Field: ‘uuid’
[10:21:28.284]   - Field: ‘seed’
[10:21:28.285]   - Field: ‘version’
[10:21:28.285]   - Field: ‘result’
[10:21:28.285]   - Field: ‘asynchronous’
[10:21:28.285]   - Field: ‘calls’
[10:21:28.285]   - Field: ‘globals’
[10:21:28.285]   - Field: ‘stdout’
[10:21:28.285]   - Field: ‘earlySignal’
[10:21:28.285]   - Field: ‘lazy’
[10:21:28.285]   - Field: ‘state’
[10:21:28.285] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:28.285] - Launch lazy future ...
[10:21:28.286] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:21:28.286] Packages needed by future strategies (n = 0): <none>
[10:21:28.286] {
[10:21:28.286]     {
[10:21:28.286]         {
[10:21:28.286]             ...future.startTime <- base::Sys.time()
[10:21:28.286]             {
[10:21:28.286]                 {
[10:21:28.286]                   {
[10:21:28.286]                     {
[10:21:28.286]                       {
[10:21:28.286]                         base::local({
[10:21:28.286]                           has_future <- base::requireNamespace("future", 
[10:21:28.286]                             quietly = TRUE)
[10:21:28.286]                           if (has_future) {
[10:21:28.286]                             ns <- base::getNamespace("future")
[10:21:28.286]                             version <- ns[[".package"]][["version"]]
[10:21:28.286]                             if (is.null(version)) 
[10:21:28.286]                               version <- utils::packageVersion("future")
[10:21:28.286]                           }
[10:21:28.286]                           else {
[10:21:28.286]                             version <- NULL
[10:21:28.286]                           }
[10:21:28.286]                           if (!has_future || version < "1.8.0") {
[10:21:28.286]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:28.286]                               "", base::R.version$version.string), 
[10:21:28.286]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:28.286]                                 base::R.version$platform, 8 * 
[10:21:28.286]                                   base::.Machine$sizeof.pointer), 
[10:21:28.286]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:28.286]                                 "release", "version")], collapse = " "), 
[10:21:28.286]                               hostname = base::Sys.info()[["nodename"]])
[10:21:28.286]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:28.286]                               info)
[10:21:28.286]                             info <- base::paste(info, collapse = "; ")
[10:21:28.286]                             if (!has_future) {
[10:21:28.286]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:28.286]                                 info)
[10:21:28.286]                             }
[10:21:28.286]                             else {
[10:21:28.286]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:28.286]                                 info, version)
[10:21:28.286]                             }
[10:21:28.286]                             base::stop(msg)
[10:21:28.286]                           }
[10:21:28.286]                         })
[10:21:28.286]                       }
[10:21:28.286]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:28.286]                       base::options(mc.cores = 1L)
[10:21:28.286]                     }
[10:21:28.286]                     base::local({
[10:21:28.286]                       for (pkg in c("stats", "datasets")) {
[10:21:28.286]                         base::loadNamespace(pkg)
[10:21:28.286]                         base::library(pkg, character.only = TRUE)
[10:21:28.286]                       }
[10:21:28.286]                     })
[10:21:28.286]                   }
[10:21:28.286]                   ...future.strategy.old <- future::plan("list")
[10:21:28.286]                   options(future.plan = NULL)
[10:21:28.286]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:28.286]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:28.286]                 }
[10:21:28.286]                 ...future.workdir <- getwd()
[10:21:28.286]             }
[10:21:28.286]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:28.286]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:28.286]         }
[10:21:28.286]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:28.286]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:28.286]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:28.286]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:28.286]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:28.286]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:28.286]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:28.286]             base::names(...future.oldOptions))
[10:21:28.286]     }
[10:21:28.286]     if (FALSE) {
[10:21:28.286]     }
[10:21:28.286]     else {
[10:21:28.286]         if (TRUE) {
[10:21:28.286]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:28.286]                 open = "w")
[10:21:28.286]         }
[10:21:28.286]         else {
[10:21:28.286]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:28.286]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:28.286]         }
[10:21:28.286]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:28.286]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:28.286]             base::sink(type = "output", split = FALSE)
[10:21:28.286]             base::close(...future.stdout)
[10:21:28.286]         }, add = TRUE)
[10:21:28.286]     }
[10:21:28.286]     ...future.frame <- base::sys.nframe()
[10:21:28.286]     ...future.conditions <- base::list()
[10:21:28.286]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:28.286]     if (FALSE) {
[10:21:28.286]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:28.286]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:28.286]     }
[10:21:28.286]     ...future.result <- base::tryCatch({
[10:21:28.286]         base::withCallingHandlers({
[10:21:28.286]             ...future.value <- base::withVisible(base::local({
[10:21:28.286]                 ...future.makeSendCondition <- base::local({
[10:21:28.286]                   sendCondition <- NULL
[10:21:28.286]                   function(frame = 1L) {
[10:21:28.286]                     if (is.function(sendCondition)) 
[10:21:28.286]                       return(sendCondition)
[10:21:28.286]                     ns <- getNamespace("parallel")
[10:21:28.286]                     if (exists("sendData", mode = "function", 
[10:21:28.286]                       envir = ns)) {
[10:21:28.286]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:28.286]                         envir = ns)
[10:21:28.286]                       envir <- sys.frame(frame)
[10:21:28.286]                       master <- NULL
[10:21:28.286]                       while (!identical(envir, .GlobalEnv) && 
[10:21:28.286]                         !identical(envir, emptyenv())) {
[10:21:28.286]                         if (exists("master", mode = "list", envir = envir, 
[10:21:28.286]                           inherits = FALSE)) {
[10:21:28.286]                           master <- get("master", mode = "list", 
[10:21:28.286]                             envir = envir, inherits = FALSE)
[10:21:28.286]                           if (inherits(master, c("SOCKnode", 
[10:21:28.286]                             "SOCK0node"))) {
[10:21:28.286]                             sendCondition <<- function(cond) {
[10:21:28.286]                               data <- list(type = "VALUE", value = cond, 
[10:21:28.286]                                 success = TRUE)
[10:21:28.286]                               parallel_sendData(master, data)
[10:21:28.286]                             }
[10:21:28.286]                             return(sendCondition)
[10:21:28.286]                           }
[10:21:28.286]                         }
[10:21:28.286]                         frame <- frame + 1L
[10:21:28.286]                         envir <- sys.frame(frame)
[10:21:28.286]                       }
[10:21:28.286]                     }
[10:21:28.286]                     sendCondition <<- function(cond) NULL
[10:21:28.286]                   }
[10:21:28.286]                 })
[10:21:28.286]                 withCallingHandlers({
[10:21:28.286]                   {
[10:21:28.286]                     lm(dist ~ speed + I(speed^2), data = cars)
[10:21:28.286]                   }
[10:21:28.286]                 }, immediateCondition = function(cond) {
[10:21:28.286]                   sendCondition <- ...future.makeSendCondition()
[10:21:28.286]                   sendCondition(cond)
[10:21:28.286]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.286]                   {
[10:21:28.286]                     inherits <- base::inherits
[10:21:28.286]                     invokeRestart <- base::invokeRestart
[10:21:28.286]                     is.null <- base::is.null
[10:21:28.286]                     muffled <- FALSE
[10:21:28.286]                     if (inherits(cond, "message")) {
[10:21:28.286]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:28.286]                       if (muffled) 
[10:21:28.286]                         invokeRestart("muffleMessage")
[10:21:28.286]                     }
[10:21:28.286]                     else if (inherits(cond, "warning")) {
[10:21:28.286]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:28.286]                       if (muffled) 
[10:21:28.286]                         invokeRestart("muffleWarning")
[10:21:28.286]                     }
[10:21:28.286]                     else if (inherits(cond, "condition")) {
[10:21:28.286]                       if (!is.null(pattern)) {
[10:21:28.286]                         computeRestarts <- base::computeRestarts
[10:21:28.286]                         grepl <- base::grepl
[10:21:28.286]                         restarts <- computeRestarts(cond)
[10:21:28.286]                         for (restart in restarts) {
[10:21:28.286]                           name <- restart$name
[10:21:28.286]                           if (is.null(name)) 
[10:21:28.286]                             next
[10:21:28.286]                           if (!grepl(pattern, name)) 
[10:21:28.286]                             next
[10:21:28.286]                           invokeRestart(restart)
[10:21:28.286]                           muffled <- TRUE
[10:21:28.286]                           break
[10:21:28.286]                         }
[10:21:28.286]                       }
[10:21:28.286]                     }
[10:21:28.286]                     invisible(muffled)
[10:21:28.286]                   }
[10:21:28.286]                   muffleCondition(cond)
[10:21:28.286]                 })
[10:21:28.286]             }))
[10:21:28.286]             future::FutureResult(value = ...future.value$value, 
[10:21:28.286]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:28.286]                   ...future.rng), globalenv = if (FALSE) 
[10:21:28.286]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:28.286]                     ...future.globalenv.names))
[10:21:28.286]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:28.286]         }, condition = base::local({
[10:21:28.286]             c <- base::c
[10:21:28.286]             inherits <- base::inherits
[10:21:28.286]             invokeRestart <- base::invokeRestart
[10:21:28.286]             length <- base::length
[10:21:28.286]             list <- base::list
[10:21:28.286]             seq.int <- base::seq.int
[10:21:28.286]             signalCondition <- base::signalCondition
[10:21:28.286]             sys.calls <- base::sys.calls
[10:21:28.286]             `[[` <- base::`[[`
[10:21:28.286]             `+` <- base::`+`
[10:21:28.286]             `<<-` <- base::`<<-`
[10:21:28.286]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:28.286]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:28.286]                   3L)]
[10:21:28.286]             }
[10:21:28.286]             function(cond) {
[10:21:28.286]                 is_error <- inherits(cond, "error")
[10:21:28.286]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:28.286]                   NULL)
[10:21:28.286]                 if (is_error) {
[10:21:28.286]                   sessionInformation <- function() {
[10:21:28.286]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:28.286]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:28.286]                       search = base::search(), system = base::Sys.info())
[10:21:28.286]                   }
[10:21:28.286]                   ...future.conditions[[length(...future.conditions) + 
[10:21:28.286]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:28.286]                     cond$call), session = sessionInformation(), 
[10:21:28.286]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:28.286]                   signalCondition(cond)
[10:21:28.286]                 }
[10:21:28.286]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:28.286]                 "immediateCondition"))) {
[10:21:28.286]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:28.286]                   ...future.conditions[[length(...future.conditions) + 
[10:21:28.286]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:28.286]                   if (TRUE && !signal) {
[10:21:28.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.286]                     {
[10:21:28.286]                       inherits <- base::inherits
[10:21:28.286]                       invokeRestart <- base::invokeRestart
[10:21:28.286]                       is.null <- base::is.null
[10:21:28.286]                       muffled <- FALSE
[10:21:28.286]                       if (inherits(cond, "message")) {
[10:21:28.286]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:28.286]                         if (muffled) 
[10:21:28.286]                           invokeRestart("muffleMessage")
[10:21:28.286]                       }
[10:21:28.286]                       else if (inherits(cond, "warning")) {
[10:21:28.286]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:28.286]                         if (muffled) 
[10:21:28.286]                           invokeRestart("muffleWarning")
[10:21:28.286]                       }
[10:21:28.286]                       else if (inherits(cond, "condition")) {
[10:21:28.286]                         if (!is.null(pattern)) {
[10:21:28.286]                           computeRestarts <- base::computeRestarts
[10:21:28.286]                           grepl <- base::grepl
[10:21:28.286]                           restarts <- computeRestarts(cond)
[10:21:28.286]                           for (restart in restarts) {
[10:21:28.286]                             name <- restart$name
[10:21:28.286]                             if (is.null(name)) 
[10:21:28.286]                               next
[10:21:28.286]                             if (!grepl(pattern, name)) 
[10:21:28.286]                               next
[10:21:28.286]                             invokeRestart(restart)
[10:21:28.286]                             muffled <- TRUE
[10:21:28.286]                             break
[10:21:28.286]                           }
[10:21:28.286]                         }
[10:21:28.286]                       }
[10:21:28.286]                       invisible(muffled)
[10:21:28.286]                     }
[10:21:28.286]                     muffleCondition(cond, pattern = "^muffle")
[10:21:28.286]                   }
[10:21:28.286]                 }
[10:21:28.286]                 else {
[10:21:28.286]                   if (TRUE) {
[10:21:28.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.286]                     {
[10:21:28.286]                       inherits <- base::inherits
[10:21:28.286]                       invokeRestart <- base::invokeRestart
[10:21:28.286]                       is.null <- base::is.null
[10:21:28.286]                       muffled <- FALSE
[10:21:28.286]                       if (inherits(cond, "message")) {
[10:21:28.286]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:28.286]                         if (muffled) 
[10:21:28.286]                           invokeRestart("muffleMessage")
[10:21:28.286]                       }
[10:21:28.286]                       else if (inherits(cond, "warning")) {
[10:21:28.286]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:28.286]                         if (muffled) 
[10:21:28.286]                           invokeRestart("muffleWarning")
[10:21:28.286]                       }
[10:21:28.286]                       else if (inherits(cond, "condition")) {
[10:21:28.286]                         if (!is.null(pattern)) {
[10:21:28.286]                           computeRestarts <- base::computeRestarts
[10:21:28.286]                           grepl <- base::grepl
[10:21:28.286]                           restarts <- computeRestarts(cond)
[10:21:28.286]                           for (restart in restarts) {
[10:21:28.286]                             name <- restart$name
[10:21:28.286]                             if (is.null(name)) 
[10:21:28.286]                               next
[10:21:28.286]                             if (!grepl(pattern, name)) 
[10:21:28.286]                               next
[10:21:28.286]                             invokeRestart(restart)
[10:21:28.286]                             muffled <- TRUE
[10:21:28.286]                             break
[10:21:28.286]                           }
[10:21:28.286]                         }
[10:21:28.286]                       }
[10:21:28.286]                       invisible(muffled)
[10:21:28.286]                     }
[10:21:28.286]                     muffleCondition(cond, pattern = "^muffle")
[10:21:28.286]                   }
[10:21:28.286]                 }
[10:21:28.286]             }
[10:21:28.286]         }))
[10:21:28.286]     }, error = function(ex) {
[10:21:28.286]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:28.286]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:28.286]                 ...future.rng), started = ...future.startTime, 
[10:21:28.286]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:28.286]             version = "1.8"), class = "FutureResult")
[10:21:28.286]     }, finally = {
[10:21:28.286]         if (!identical(...future.workdir, getwd())) 
[10:21:28.286]             setwd(...future.workdir)
[10:21:28.286]         {
[10:21:28.286]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:28.286]                 ...future.oldOptions$nwarnings <- NULL
[10:21:28.286]             }
[10:21:28.286]             base::options(...future.oldOptions)
[10:21:28.286]             if (.Platform$OS.type == "windows") {
[10:21:28.286]                 old_names <- names(...future.oldEnvVars)
[10:21:28.286]                 envs <- base::Sys.getenv()
[10:21:28.286]                 names <- names(envs)
[10:21:28.286]                 common <- intersect(names, old_names)
[10:21:28.286]                 added <- setdiff(names, old_names)
[10:21:28.286]                 removed <- setdiff(old_names, names)
[10:21:28.286]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:28.286]                   envs[common]]
[10:21:28.286]                 NAMES <- toupper(changed)
[10:21:28.286]                 args <- list()
[10:21:28.286]                 for (kk in seq_along(NAMES)) {
[10:21:28.286]                   name <- changed[[kk]]
[10:21:28.286]                   NAME <- NAMES[[kk]]
[10:21:28.286]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.286]                     next
[10:21:28.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:28.286]                 }
[10:21:28.286]                 NAMES <- toupper(added)
[10:21:28.286]                 for (kk in seq_along(NAMES)) {
[10:21:28.286]                   name <- added[[kk]]
[10:21:28.286]                   NAME <- NAMES[[kk]]
[10:21:28.286]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.286]                     next
[10:21:28.286]                   args[[name]] <- ""
[10:21:28.286]                 }
[10:21:28.286]                 NAMES <- toupper(removed)
[10:21:28.286]                 for (kk in seq_along(NAMES)) {
[10:21:28.286]                   name <- removed[[kk]]
[10:21:28.286]                   NAME <- NAMES[[kk]]
[10:21:28.286]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.286]                     next
[10:21:28.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:28.286]                 }
[10:21:28.286]                 if (length(args) > 0) 
[10:21:28.286]                   base::do.call(base::Sys.setenv, args = args)
[10:21:28.286]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:28.286]             }
[10:21:28.286]             else {
[10:21:28.286]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:28.286]             }
[10:21:28.286]             {
[10:21:28.286]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:28.286]                   0L) {
[10:21:28.286]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:28.286]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:28.286]                   base::options(opts)
[10:21:28.286]                 }
[10:21:28.286]                 {
[10:21:28.286]                   {
[10:21:28.286]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:28.286]                     NULL
[10:21:28.286]                   }
[10:21:28.286]                   options(future.plan = NULL)
[10:21:28.286]                   if (is.na(NA_character_)) 
[10:21:28.286]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:28.286]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:28.286]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:28.286]                     .init = FALSE)
[10:21:28.286]                 }
[10:21:28.286]             }
[10:21:28.286]         }
[10:21:28.286]     })
[10:21:28.286]     if (TRUE) {
[10:21:28.286]         base::sink(type = "output", split = FALSE)
[10:21:28.286]         if (TRUE) {
[10:21:28.286]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:28.286]         }
[10:21:28.286]         else {
[10:21:28.286]             ...future.result["stdout"] <- base::list(NULL)
[10:21:28.286]         }
[10:21:28.286]         base::close(...future.stdout)
[10:21:28.286]         ...future.stdout <- NULL
[10:21:28.286]     }
[10:21:28.286]     ...future.result$conditions <- ...future.conditions
[10:21:28.286]     ...future.result$finished <- base::Sys.time()
[10:21:28.286]     ...future.result
[10:21:28.286] }
[10:21:28.289] MultisessionFuture started
[10:21:28.289] - Launch lazy future ... done
[10:21:28.289] run() for ‘MultisessionFuture’ ... done
[10:21:28.289] result() for ClusterFuture ...
[10:21:28.290] receiveMessageFromWorker() for ClusterFuture ...
[10:21:28.290] - Validating connection of MultisessionFuture
[10:21:28.332] - received message: FutureResult
[10:21:28.332] - Received FutureResult
[10:21:28.333] - Erased future from FutureRegistry
[10:21:28.333] result() for ClusterFuture ...
[10:21:28.333] - result already collected: FutureResult
[10:21:28.333] result() for ClusterFuture ... done
[10:21:28.333] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:28.333] result() for ClusterFuture ... done
[10:21:28.333] result() for ClusterFuture ...
[10:21:28.333] - result already collected: FutureResult
[10:21:28.333] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[10:21:28.336] getGlobalsAndPackages() ...
[10:21:28.336] Searching for globals...
[10:21:28.338] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[10:21:28.338] Searching for globals ... DONE
[10:21:28.338] Resolving globals: FALSE
[10:21:28.339] 
[10:21:28.339] - packages: [2] ‘stats’, ‘datasets’
[10:21:28.339] getGlobalsAndPackages() ... DONE
[10:21:28.339] run() for ‘Future’ ...
[10:21:28.339] - state: ‘created’
[10:21:28.339] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:28.354] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:28.354] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:28.354]   - Field: ‘node’
[10:21:28.354]   - Field: ‘label’
[10:21:28.355]   - Field: ‘local’
[10:21:28.355]   - Field: ‘owner’
[10:21:28.355]   - Field: ‘envir’
[10:21:28.355]   - Field: ‘workers’
[10:21:28.355]   - Field: ‘packages’
[10:21:28.355]   - Field: ‘gc’
[10:21:28.355]   - Field: ‘conditions’
[10:21:28.355]   - Field: ‘persistent’
[10:21:28.355]   - Field: ‘expr’
[10:21:28.355]   - Field: ‘uuid’
[10:21:28.355]   - Field: ‘seed’
[10:21:28.356]   - Field: ‘version’
[10:21:28.356]   - Field: ‘result’
[10:21:28.356]   - Field: ‘asynchronous’
[10:21:28.356]   - Field: ‘calls’
[10:21:28.356]   - Field: ‘globals’
[10:21:28.356]   - Field: ‘stdout’
[10:21:28.356]   - Field: ‘earlySignal’
[10:21:28.356]   - Field: ‘lazy’
[10:21:28.356]   - Field: ‘state’
[10:21:28.356] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:28.356] - Launch lazy future ...
[10:21:28.357] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[10:21:28.357] Packages needed by future strategies (n = 0): <none>
[10:21:28.357] {
[10:21:28.357]     {
[10:21:28.357]         {
[10:21:28.357]             ...future.startTime <- base::Sys.time()
[10:21:28.357]             {
[10:21:28.357]                 {
[10:21:28.357]                   {
[10:21:28.357]                     {
[10:21:28.357]                       {
[10:21:28.357]                         base::local({
[10:21:28.357]                           has_future <- base::requireNamespace("future", 
[10:21:28.357]                             quietly = TRUE)
[10:21:28.357]                           if (has_future) {
[10:21:28.357]                             ns <- base::getNamespace("future")
[10:21:28.357]                             version <- ns[[".package"]][["version"]]
[10:21:28.357]                             if (is.null(version)) 
[10:21:28.357]                               version <- utils::packageVersion("future")
[10:21:28.357]                           }
[10:21:28.357]                           else {
[10:21:28.357]                             version <- NULL
[10:21:28.357]                           }
[10:21:28.357]                           if (!has_future || version < "1.8.0") {
[10:21:28.357]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:28.357]                               "", base::R.version$version.string), 
[10:21:28.357]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:28.357]                                 base::R.version$platform, 8 * 
[10:21:28.357]                                   base::.Machine$sizeof.pointer), 
[10:21:28.357]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:28.357]                                 "release", "version")], collapse = " "), 
[10:21:28.357]                               hostname = base::Sys.info()[["nodename"]])
[10:21:28.357]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:28.357]                               info)
[10:21:28.357]                             info <- base::paste(info, collapse = "; ")
[10:21:28.357]                             if (!has_future) {
[10:21:28.357]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:28.357]                                 info)
[10:21:28.357]                             }
[10:21:28.357]                             else {
[10:21:28.357]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:28.357]                                 info, version)
[10:21:28.357]                             }
[10:21:28.357]                             base::stop(msg)
[10:21:28.357]                           }
[10:21:28.357]                         })
[10:21:28.357]                       }
[10:21:28.357]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:28.357]                       base::options(mc.cores = 1L)
[10:21:28.357]                     }
[10:21:28.357]                     base::local({
[10:21:28.357]                       for (pkg in c("stats", "datasets")) {
[10:21:28.357]                         base::loadNamespace(pkg)
[10:21:28.357]                         base::library(pkg, character.only = TRUE)
[10:21:28.357]                       }
[10:21:28.357]                     })
[10:21:28.357]                   }
[10:21:28.357]                   ...future.strategy.old <- future::plan("list")
[10:21:28.357]                   options(future.plan = NULL)
[10:21:28.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:28.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:28.357]                 }
[10:21:28.357]                 ...future.workdir <- getwd()
[10:21:28.357]             }
[10:21:28.357]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:28.357]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:28.357]         }
[10:21:28.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:28.357]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:28.357]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:28.357]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:28.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:28.357]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:28.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:28.357]             base::names(...future.oldOptions))
[10:21:28.357]     }
[10:21:28.357]     if (FALSE) {
[10:21:28.357]     }
[10:21:28.357]     else {
[10:21:28.357]         if (TRUE) {
[10:21:28.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:28.357]                 open = "w")
[10:21:28.357]         }
[10:21:28.357]         else {
[10:21:28.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:28.357]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:28.357]         }
[10:21:28.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:28.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:28.357]             base::sink(type = "output", split = FALSE)
[10:21:28.357]             base::close(...future.stdout)
[10:21:28.357]         }, add = TRUE)
[10:21:28.357]     }
[10:21:28.357]     ...future.frame <- base::sys.nframe()
[10:21:28.357]     ...future.conditions <- base::list()
[10:21:28.357]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:28.357]     if (FALSE) {
[10:21:28.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:28.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:28.357]     }
[10:21:28.357]     ...future.result <- base::tryCatch({
[10:21:28.357]         base::withCallingHandlers({
[10:21:28.357]             ...future.value <- base::withVisible(base::local({
[10:21:28.357]                 ...future.makeSendCondition <- base::local({
[10:21:28.357]                   sendCondition <- NULL
[10:21:28.357]                   function(frame = 1L) {
[10:21:28.357]                     if (is.function(sendCondition)) 
[10:21:28.357]                       return(sendCondition)
[10:21:28.357]                     ns <- getNamespace("parallel")
[10:21:28.357]                     if (exists("sendData", mode = "function", 
[10:21:28.357]                       envir = ns)) {
[10:21:28.357]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:28.357]                         envir = ns)
[10:21:28.357]                       envir <- sys.frame(frame)
[10:21:28.357]                       master <- NULL
[10:21:28.357]                       while (!identical(envir, .GlobalEnv) && 
[10:21:28.357]                         !identical(envir, emptyenv())) {
[10:21:28.357]                         if (exists("master", mode = "list", envir = envir, 
[10:21:28.357]                           inherits = FALSE)) {
[10:21:28.357]                           master <- get("master", mode = "list", 
[10:21:28.357]                             envir = envir, inherits = FALSE)
[10:21:28.357]                           if (inherits(master, c("SOCKnode", 
[10:21:28.357]                             "SOCK0node"))) {
[10:21:28.357]                             sendCondition <<- function(cond) {
[10:21:28.357]                               data <- list(type = "VALUE", value = cond, 
[10:21:28.357]                                 success = TRUE)
[10:21:28.357]                               parallel_sendData(master, data)
[10:21:28.357]                             }
[10:21:28.357]                             return(sendCondition)
[10:21:28.357]                           }
[10:21:28.357]                         }
[10:21:28.357]                         frame <- frame + 1L
[10:21:28.357]                         envir <- sys.frame(frame)
[10:21:28.357]                       }
[10:21:28.357]                     }
[10:21:28.357]                     sendCondition <<- function(cond) NULL
[10:21:28.357]                   }
[10:21:28.357]                 })
[10:21:28.357]                 withCallingHandlers({
[10:21:28.357]                   {
[10:21:28.357]                     lm(dist ~ poly(speed, 2), data = cars)
[10:21:28.357]                   }
[10:21:28.357]                 }, immediateCondition = function(cond) {
[10:21:28.357]                   sendCondition <- ...future.makeSendCondition()
[10:21:28.357]                   sendCondition(cond)
[10:21:28.357]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.357]                   {
[10:21:28.357]                     inherits <- base::inherits
[10:21:28.357]                     invokeRestart <- base::invokeRestart
[10:21:28.357]                     is.null <- base::is.null
[10:21:28.357]                     muffled <- FALSE
[10:21:28.357]                     if (inherits(cond, "message")) {
[10:21:28.357]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:28.357]                       if (muffled) 
[10:21:28.357]                         invokeRestart("muffleMessage")
[10:21:28.357]                     }
[10:21:28.357]                     else if (inherits(cond, "warning")) {
[10:21:28.357]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:28.357]                       if (muffled) 
[10:21:28.357]                         invokeRestart("muffleWarning")
[10:21:28.357]                     }
[10:21:28.357]                     else if (inherits(cond, "condition")) {
[10:21:28.357]                       if (!is.null(pattern)) {
[10:21:28.357]                         computeRestarts <- base::computeRestarts
[10:21:28.357]                         grepl <- base::grepl
[10:21:28.357]                         restarts <- computeRestarts(cond)
[10:21:28.357]                         for (restart in restarts) {
[10:21:28.357]                           name <- restart$name
[10:21:28.357]                           if (is.null(name)) 
[10:21:28.357]                             next
[10:21:28.357]                           if (!grepl(pattern, name)) 
[10:21:28.357]                             next
[10:21:28.357]                           invokeRestart(restart)
[10:21:28.357]                           muffled <- TRUE
[10:21:28.357]                           break
[10:21:28.357]                         }
[10:21:28.357]                       }
[10:21:28.357]                     }
[10:21:28.357]                     invisible(muffled)
[10:21:28.357]                   }
[10:21:28.357]                   muffleCondition(cond)
[10:21:28.357]                 })
[10:21:28.357]             }))
[10:21:28.357]             future::FutureResult(value = ...future.value$value, 
[10:21:28.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:28.357]                   ...future.rng), globalenv = if (FALSE) 
[10:21:28.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:28.357]                     ...future.globalenv.names))
[10:21:28.357]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:28.357]         }, condition = base::local({
[10:21:28.357]             c <- base::c
[10:21:28.357]             inherits <- base::inherits
[10:21:28.357]             invokeRestart <- base::invokeRestart
[10:21:28.357]             length <- base::length
[10:21:28.357]             list <- base::list
[10:21:28.357]             seq.int <- base::seq.int
[10:21:28.357]             signalCondition <- base::signalCondition
[10:21:28.357]             sys.calls <- base::sys.calls
[10:21:28.357]             `[[` <- base::`[[`
[10:21:28.357]             `+` <- base::`+`
[10:21:28.357]             `<<-` <- base::`<<-`
[10:21:28.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:28.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:28.357]                   3L)]
[10:21:28.357]             }
[10:21:28.357]             function(cond) {
[10:21:28.357]                 is_error <- inherits(cond, "error")
[10:21:28.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:28.357]                   NULL)
[10:21:28.357]                 if (is_error) {
[10:21:28.357]                   sessionInformation <- function() {
[10:21:28.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:28.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:28.357]                       search = base::search(), system = base::Sys.info())
[10:21:28.357]                   }
[10:21:28.357]                   ...future.conditions[[length(...future.conditions) + 
[10:21:28.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:28.357]                     cond$call), session = sessionInformation(), 
[10:21:28.357]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:28.357]                   signalCondition(cond)
[10:21:28.357]                 }
[10:21:28.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:28.357]                 "immediateCondition"))) {
[10:21:28.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:28.357]                   ...future.conditions[[length(...future.conditions) + 
[10:21:28.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:28.357]                   if (TRUE && !signal) {
[10:21:28.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.357]                     {
[10:21:28.357]                       inherits <- base::inherits
[10:21:28.357]                       invokeRestart <- base::invokeRestart
[10:21:28.357]                       is.null <- base::is.null
[10:21:28.357]                       muffled <- FALSE
[10:21:28.357]                       if (inherits(cond, "message")) {
[10:21:28.357]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:28.357]                         if (muffled) 
[10:21:28.357]                           invokeRestart("muffleMessage")
[10:21:28.357]                       }
[10:21:28.357]                       else if (inherits(cond, "warning")) {
[10:21:28.357]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:28.357]                         if (muffled) 
[10:21:28.357]                           invokeRestart("muffleWarning")
[10:21:28.357]                       }
[10:21:28.357]                       else if (inherits(cond, "condition")) {
[10:21:28.357]                         if (!is.null(pattern)) {
[10:21:28.357]                           computeRestarts <- base::computeRestarts
[10:21:28.357]                           grepl <- base::grepl
[10:21:28.357]                           restarts <- computeRestarts(cond)
[10:21:28.357]                           for (restart in restarts) {
[10:21:28.357]                             name <- restart$name
[10:21:28.357]                             if (is.null(name)) 
[10:21:28.357]                               next
[10:21:28.357]                             if (!grepl(pattern, name)) 
[10:21:28.357]                               next
[10:21:28.357]                             invokeRestart(restart)
[10:21:28.357]                             muffled <- TRUE
[10:21:28.357]                             break
[10:21:28.357]                           }
[10:21:28.357]                         }
[10:21:28.357]                       }
[10:21:28.357]                       invisible(muffled)
[10:21:28.357]                     }
[10:21:28.357]                     muffleCondition(cond, pattern = "^muffle")
[10:21:28.357]                   }
[10:21:28.357]                 }
[10:21:28.357]                 else {
[10:21:28.357]                   if (TRUE) {
[10:21:28.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.357]                     {
[10:21:28.357]                       inherits <- base::inherits
[10:21:28.357]                       invokeRestart <- base::invokeRestart
[10:21:28.357]                       is.null <- base::is.null
[10:21:28.357]                       muffled <- FALSE
[10:21:28.357]                       if (inherits(cond, "message")) {
[10:21:28.357]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:28.357]                         if (muffled) 
[10:21:28.357]                           invokeRestart("muffleMessage")
[10:21:28.357]                       }
[10:21:28.357]                       else if (inherits(cond, "warning")) {
[10:21:28.357]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:28.357]                         if (muffled) 
[10:21:28.357]                           invokeRestart("muffleWarning")
[10:21:28.357]                       }
[10:21:28.357]                       else if (inherits(cond, "condition")) {
[10:21:28.357]                         if (!is.null(pattern)) {
[10:21:28.357]                           computeRestarts <- base::computeRestarts
[10:21:28.357]                           grepl <- base::grepl
[10:21:28.357]                           restarts <- computeRestarts(cond)
[10:21:28.357]                           for (restart in restarts) {
[10:21:28.357]                             name <- restart$name
[10:21:28.357]                             if (is.null(name)) 
[10:21:28.357]                               next
[10:21:28.357]                             if (!grepl(pattern, name)) 
[10:21:28.357]                               next
[10:21:28.357]                             invokeRestart(restart)
[10:21:28.357]                             muffled <- TRUE
[10:21:28.357]                             break
[10:21:28.357]                           }
[10:21:28.357]                         }
[10:21:28.357]                       }
[10:21:28.357]                       invisible(muffled)
[10:21:28.357]                     }
[10:21:28.357]                     muffleCondition(cond, pattern = "^muffle")
[10:21:28.357]                   }
[10:21:28.357]                 }
[10:21:28.357]             }
[10:21:28.357]         }))
[10:21:28.357]     }, error = function(ex) {
[10:21:28.357]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:28.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:28.357]                 ...future.rng), started = ...future.startTime, 
[10:21:28.357]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:28.357]             version = "1.8"), class = "FutureResult")
[10:21:28.357]     }, finally = {
[10:21:28.357]         if (!identical(...future.workdir, getwd())) 
[10:21:28.357]             setwd(...future.workdir)
[10:21:28.357]         {
[10:21:28.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:28.357]                 ...future.oldOptions$nwarnings <- NULL
[10:21:28.357]             }
[10:21:28.357]             base::options(...future.oldOptions)
[10:21:28.357]             if (.Platform$OS.type == "windows") {
[10:21:28.357]                 old_names <- names(...future.oldEnvVars)
[10:21:28.357]                 envs <- base::Sys.getenv()
[10:21:28.357]                 names <- names(envs)
[10:21:28.357]                 common <- intersect(names, old_names)
[10:21:28.357]                 added <- setdiff(names, old_names)
[10:21:28.357]                 removed <- setdiff(old_names, names)
[10:21:28.357]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:28.357]                   envs[common]]
[10:21:28.357]                 NAMES <- toupper(changed)
[10:21:28.357]                 args <- list()
[10:21:28.357]                 for (kk in seq_along(NAMES)) {
[10:21:28.357]                   name <- changed[[kk]]
[10:21:28.357]                   NAME <- NAMES[[kk]]
[10:21:28.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.357]                     next
[10:21:28.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:28.357]                 }
[10:21:28.357]                 NAMES <- toupper(added)
[10:21:28.357]                 for (kk in seq_along(NAMES)) {
[10:21:28.357]                   name <- added[[kk]]
[10:21:28.357]                   NAME <- NAMES[[kk]]
[10:21:28.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.357]                     next
[10:21:28.357]                   args[[name]] <- ""
[10:21:28.357]                 }
[10:21:28.357]                 NAMES <- toupper(removed)
[10:21:28.357]                 for (kk in seq_along(NAMES)) {
[10:21:28.357]                   name <- removed[[kk]]
[10:21:28.357]                   NAME <- NAMES[[kk]]
[10:21:28.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.357]                     next
[10:21:28.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:28.357]                 }
[10:21:28.357]                 if (length(args) > 0) 
[10:21:28.357]                   base::do.call(base::Sys.setenv, args = args)
[10:21:28.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:28.357]             }
[10:21:28.357]             else {
[10:21:28.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:28.357]             }
[10:21:28.357]             {
[10:21:28.357]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:28.357]                   0L) {
[10:21:28.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:28.357]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:28.357]                   base::options(opts)
[10:21:28.357]                 }
[10:21:28.357]                 {
[10:21:28.357]                   {
[10:21:28.357]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:28.357]                     NULL
[10:21:28.357]                   }
[10:21:28.357]                   options(future.plan = NULL)
[10:21:28.357]                   if (is.na(NA_character_)) 
[10:21:28.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:28.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:28.357]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:28.357]                     .init = FALSE)
[10:21:28.357]                 }
[10:21:28.357]             }
[10:21:28.357]         }
[10:21:28.357]     })
[10:21:28.357]     if (TRUE) {
[10:21:28.357]         base::sink(type = "output", split = FALSE)
[10:21:28.357]         if (TRUE) {
[10:21:28.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:28.357]         }
[10:21:28.357]         else {
[10:21:28.357]             ...future.result["stdout"] <- base::list(NULL)
[10:21:28.357]         }
[10:21:28.357]         base::close(...future.stdout)
[10:21:28.357]         ...future.stdout <- NULL
[10:21:28.357]     }
[10:21:28.357]     ...future.result$conditions <- ...future.conditions
[10:21:28.357]     ...future.result$finished <- base::Sys.time()
[10:21:28.357]     ...future.result
[10:21:28.357] }
[10:21:28.361] MultisessionFuture started
[10:21:28.361] - Launch lazy future ... done
[10:21:28.361] run() for ‘MultisessionFuture’ ... done
[10:21:28.361] result() for ClusterFuture ...
[10:21:28.362] receiveMessageFromWorker() for ClusterFuture ...
[10:21:28.362] - Validating connection of MultisessionFuture
[10:21:28.405] - received message: FutureResult
[10:21:28.405] - Received FutureResult
[10:21:28.405] - Erased future from FutureRegistry
[10:21:28.405] result() for ClusterFuture ...
[10:21:28.406] - result already collected: FutureResult
[10:21:28.406] result() for ClusterFuture ... done
[10:21:28.406] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:28.406] result() for ClusterFuture ... done
[10:21:28.406] result() for ClusterFuture ...
[10:21:28.406] - result already collected: FutureResult
[10:21:28.406] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[10:21:28.408] getGlobalsAndPackages() ...
[10:21:28.408] Searching for globals...
[10:21:28.412] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[10:21:28.412] Searching for globals ... DONE
[10:21:28.412] Resolving globals: FALSE
[10:21:28.413] The total size of the 3 globals is 1.22 KiB (1254 bytes)
[10:21:28.413] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (633 bytes of class ‘function’), ‘inner_function’ (371 bytes of class ‘function’) and ‘outer_function’ (250 bytes of class ‘function’)
[10:21:28.414] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[10:21:28.414] 
[10:21:28.414] getGlobalsAndPackages() ... DONE
[10:21:28.414] run() for ‘Future’ ...
[10:21:28.414] - state: ‘created’
[10:21:28.414] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:28.428] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:28.428] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:28.428]   - Field: ‘node’
[10:21:28.428]   - Field: ‘label’
[10:21:28.429]   - Field: ‘local’
[10:21:28.429]   - Field: ‘owner’
[10:21:28.429]   - Field: ‘envir’
[10:21:28.429]   - Field: ‘workers’
[10:21:28.429]   - Field: ‘packages’
[10:21:28.429]   - Field: ‘gc’
[10:21:28.429]   - Field: ‘conditions’
[10:21:28.429]   - Field: ‘persistent’
[10:21:28.429]   - Field: ‘expr’
[10:21:28.429]   - Field: ‘uuid’
[10:21:28.429]   - Field: ‘seed’
[10:21:28.429]   - Field: ‘version’
[10:21:28.430]   - Field: ‘result’
[10:21:28.430]   - Field: ‘asynchronous’
[10:21:28.430]   - Field: ‘calls’
[10:21:28.430]   - Field: ‘globals’
[10:21:28.430]   - Field: ‘stdout’
[10:21:28.430]   - Field: ‘earlySignal’
[10:21:28.430]   - Field: ‘lazy’
[10:21:28.430]   - Field: ‘state’
[10:21:28.430] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:28.430] - Launch lazy future ...
[10:21:28.431] Packages needed by the future expression (n = 0): <none>
[10:21:28.431] Packages needed by future strategies (n = 0): <none>
[10:21:28.431] {
[10:21:28.431]     {
[10:21:28.431]         {
[10:21:28.431]             ...future.startTime <- base::Sys.time()
[10:21:28.431]             {
[10:21:28.431]                 {
[10:21:28.431]                   {
[10:21:28.431]                     {
[10:21:28.431]                       base::local({
[10:21:28.431]                         has_future <- base::requireNamespace("future", 
[10:21:28.431]                           quietly = TRUE)
[10:21:28.431]                         if (has_future) {
[10:21:28.431]                           ns <- base::getNamespace("future")
[10:21:28.431]                           version <- ns[[".package"]][["version"]]
[10:21:28.431]                           if (is.null(version)) 
[10:21:28.431]                             version <- utils::packageVersion("future")
[10:21:28.431]                         }
[10:21:28.431]                         else {
[10:21:28.431]                           version <- NULL
[10:21:28.431]                         }
[10:21:28.431]                         if (!has_future || version < "1.8.0") {
[10:21:28.431]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:28.431]                             "", base::R.version$version.string), 
[10:21:28.431]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:28.431]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:28.431]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:28.431]                               "release", "version")], collapse = " "), 
[10:21:28.431]                             hostname = base::Sys.info()[["nodename"]])
[10:21:28.431]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:28.431]                             info)
[10:21:28.431]                           info <- base::paste(info, collapse = "; ")
[10:21:28.431]                           if (!has_future) {
[10:21:28.431]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:28.431]                               info)
[10:21:28.431]                           }
[10:21:28.431]                           else {
[10:21:28.431]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:28.431]                               info, version)
[10:21:28.431]                           }
[10:21:28.431]                           base::stop(msg)
[10:21:28.431]                         }
[10:21:28.431]                       })
[10:21:28.431]                     }
[10:21:28.431]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:28.431]                     base::options(mc.cores = 1L)
[10:21:28.431]                   }
[10:21:28.431]                   ...future.strategy.old <- future::plan("list")
[10:21:28.431]                   options(future.plan = NULL)
[10:21:28.431]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:28.431]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:28.431]                 }
[10:21:28.431]                 ...future.workdir <- getwd()
[10:21:28.431]             }
[10:21:28.431]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:28.431]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:28.431]         }
[10:21:28.431]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:28.431]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:28.431]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:28.431]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:28.431]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:28.431]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:28.431]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:28.431]             base::names(...future.oldOptions))
[10:21:28.431]     }
[10:21:28.431]     if (FALSE) {
[10:21:28.431]     }
[10:21:28.431]     else {
[10:21:28.431]         if (TRUE) {
[10:21:28.431]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:28.431]                 open = "w")
[10:21:28.431]         }
[10:21:28.431]         else {
[10:21:28.431]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:28.431]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:28.431]         }
[10:21:28.431]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:28.431]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:28.431]             base::sink(type = "output", split = FALSE)
[10:21:28.431]             base::close(...future.stdout)
[10:21:28.431]         }, add = TRUE)
[10:21:28.431]     }
[10:21:28.431]     ...future.frame <- base::sys.nframe()
[10:21:28.431]     ...future.conditions <- base::list()
[10:21:28.431]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:28.431]     if (FALSE) {
[10:21:28.431]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:28.431]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:28.431]     }
[10:21:28.431]     ...future.result <- base::tryCatch({
[10:21:28.431]         base::withCallingHandlers({
[10:21:28.431]             ...future.value <- base::withVisible(base::local({
[10:21:28.431]                 ...future.makeSendCondition <- base::local({
[10:21:28.431]                   sendCondition <- NULL
[10:21:28.431]                   function(frame = 1L) {
[10:21:28.431]                     if (is.function(sendCondition)) 
[10:21:28.431]                       return(sendCondition)
[10:21:28.431]                     ns <- getNamespace("parallel")
[10:21:28.431]                     if (exists("sendData", mode = "function", 
[10:21:28.431]                       envir = ns)) {
[10:21:28.431]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:28.431]                         envir = ns)
[10:21:28.431]                       envir <- sys.frame(frame)
[10:21:28.431]                       master <- NULL
[10:21:28.431]                       while (!identical(envir, .GlobalEnv) && 
[10:21:28.431]                         !identical(envir, emptyenv())) {
[10:21:28.431]                         if (exists("master", mode = "list", envir = envir, 
[10:21:28.431]                           inherits = FALSE)) {
[10:21:28.431]                           master <- get("master", mode = "list", 
[10:21:28.431]                             envir = envir, inherits = FALSE)
[10:21:28.431]                           if (inherits(master, c("SOCKnode", 
[10:21:28.431]                             "SOCK0node"))) {
[10:21:28.431]                             sendCondition <<- function(cond) {
[10:21:28.431]                               data <- list(type = "VALUE", value = cond, 
[10:21:28.431]                                 success = TRUE)
[10:21:28.431]                               parallel_sendData(master, data)
[10:21:28.431]                             }
[10:21:28.431]                             return(sendCondition)
[10:21:28.431]                           }
[10:21:28.431]                         }
[10:21:28.431]                         frame <- frame + 1L
[10:21:28.431]                         envir <- sys.frame(frame)
[10:21:28.431]                       }
[10:21:28.431]                     }
[10:21:28.431]                     sendCondition <<- function(cond) NULL
[10:21:28.431]                   }
[10:21:28.431]                 })
[10:21:28.431]                 withCallingHandlers({
[10:21:28.431]                   {
[10:21:28.431]                     outer_function(1L)
[10:21:28.431]                   }
[10:21:28.431]                 }, immediateCondition = function(cond) {
[10:21:28.431]                   sendCondition <- ...future.makeSendCondition()
[10:21:28.431]                   sendCondition(cond)
[10:21:28.431]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.431]                   {
[10:21:28.431]                     inherits <- base::inherits
[10:21:28.431]                     invokeRestart <- base::invokeRestart
[10:21:28.431]                     is.null <- base::is.null
[10:21:28.431]                     muffled <- FALSE
[10:21:28.431]                     if (inherits(cond, "message")) {
[10:21:28.431]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:28.431]                       if (muffled) 
[10:21:28.431]                         invokeRestart("muffleMessage")
[10:21:28.431]                     }
[10:21:28.431]                     else if (inherits(cond, "warning")) {
[10:21:28.431]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:28.431]                       if (muffled) 
[10:21:28.431]                         invokeRestart("muffleWarning")
[10:21:28.431]                     }
[10:21:28.431]                     else if (inherits(cond, "condition")) {
[10:21:28.431]                       if (!is.null(pattern)) {
[10:21:28.431]                         computeRestarts <- base::computeRestarts
[10:21:28.431]                         grepl <- base::grepl
[10:21:28.431]                         restarts <- computeRestarts(cond)
[10:21:28.431]                         for (restart in restarts) {
[10:21:28.431]                           name <- restart$name
[10:21:28.431]                           if (is.null(name)) 
[10:21:28.431]                             next
[10:21:28.431]                           if (!grepl(pattern, name)) 
[10:21:28.431]                             next
[10:21:28.431]                           invokeRestart(restart)
[10:21:28.431]                           muffled <- TRUE
[10:21:28.431]                           break
[10:21:28.431]                         }
[10:21:28.431]                       }
[10:21:28.431]                     }
[10:21:28.431]                     invisible(muffled)
[10:21:28.431]                   }
[10:21:28.431]                   muffleCondition(cond)
[10:21:28.431]                 })
[10:21:28.431]             }))
[10:21:28.431]             future::FutureResult(value = ...future.value$value, 
[10:21:28.431]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:28.431]                   ...future.rng), globalenv = if (FALSE) 
[10:21:28.431]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:28.431]                     ...future.globalenv.names))
[10:21:28.431]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:28.431]         }, condition = base::local({
[10:21:28.431]             c <- base::c
[10:21:28.431]             inherits <- base::inherits
[10:21:28.431]             invokeRestart <- base::invokeRestart
[10:21:28.431]             length <- base::length
[10:21:28.431]             list <- base::list
[10:21:28.431]             seq.int <- base::seq.int
[10:21:28.431]             signalCondition <- base::signalCondition
[10:21:28.431]             sys.calls <- base::sys.calls
[10:21:28.431]             `[[` <- base::`[[`
[10:21:28.431]             `+` <- base::`+`
[10:21:28.431]             `<<-` <- base::`<<-`
[10:21:28.431]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:28.431]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:28.431]                   3L)]
[10:21:28.431]             }
[10:21:28.431]             function(cond) {
[10:21:28.431]                 is_error <- inherits(cond, "error")
[10:21:28.431]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:28.431]                   NULL)
[10:21:28.431]                 if (is_error) {
[10:21:28.431]                   sessionInformation <- function() {
[10:21:28.431]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:28.431]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:28.431]                       search = base::search(), system = base::Sys.info())
[10:21:28.431]                   }
[10:21:28.431]                   ...future.conditions[[length(...future.conditions) + 
[10:21:28.431]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:28.431]                     cond$call), session = sessionInformation(), 
[10:21:28.431]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:28.431]                   signalCondition(cond)
[10:21:28.431]                 }
[10:21:28.431]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:28.431]                 "immediateCondition"))) {
[10:21:28.431]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:28.431]                   ...future.conditions[[length(...future.conditions) + 
[10:21:28.431]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:28.431]                   if (TRUE && !signal) {
[10:21:28.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.431]                     {
[10:21:28.431]                       inherits <- base::inherits
[10:21:28.431]                       invokeRestart <- base::invokeRestart
[10:21:28.431]                       is.null <- base::is.null
[10:21:28.431]                       muffled <- FALSE
[10:21:28.431]                       if (inherits(cond, "message")) {
[10:21:28.431]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:28.431]                         if (muffled) 
[10:21:28.431]                           invokeRestart("muffleMessage")
[10:21:28.431]                       }
[10:21:28.431]                       else if (inherits(cond, "warning")) {
[10:21:28.431]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:28.431]                         if (muffled) 
[10:21:28.431]                           invokeRestart("muffleWarning")
[10:21:28.431]                       }
[10:21:28.431]                       else if (inherits(cond, "condition")) {
[10:21:28.431]                         if (!is.null(pattern)) {
[10:21:28.431]                           computeRestarts <- base::computeRestarts
[10:21:28.431]                           grepl <- base::grepl
[10:21:28.431]                           restarts <- computeRestarts(cond)
[10:21:28.431]                           for (restart in restarts) {
[10:21:28.431]                             name <- restart$name
[10:21:28.431]                             if (is.null(name)) 
[10:21:28.431]                               next
[10:21:28.431]                             if (!grepl(pattern, name)) 
[10:21:28.431]                               next
[10:21:28.431]                             invokeRestart(restart)
[10:21:28.431]                             muffled <- TRUE
[10:21:28.431]                             break
[10:21:28.431]                           }
[10:21:28.431]                         }
[10:21:28.431]                       }
[10:21:28.431]                       invisible(muffled)
[10:21:28.431]                     }
[10:21:28.431]                     muffleCondition(cond, pattern = "^muffle")
[10:21:28.431]                   }
[10:21:28.431]                 }
[10:21:28.431]                 else {
[10:21:28.431]                   if (TRUE) {
[10:21:28.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.431]                     {
[10:21:28.431]                       inherits <- base::inherits
[10:21:28.431]                       invokeRestart <- base::invokeRestart
[10:21:28.431]                       is.null <- base::is.null
[10:21:28.431]                       muffled <- FALSE
[10:21:28.431]                       if (inherits(cond, "message")) {
[10:21:28.431]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:28.431]                         if (muffled) 
[10:21:28.431]                           invokeRestart("muffleMessage")
[10:21:28.431]                       }
[10:21:28.431]                       else if (inherits(cond, "warning")) {
[10:21:28.431]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:28.431]                         if (muffled) 
[10:21:28.431]                           invokeRestart("muffleWarning")
[10:21:28.431]                       }
[10:21:28.431]                       else if (inherits(cond, "condition")) {
[10:21:28.431]                         if (!is.null(pattern)) {
[10:21:28.431]                           computeRestarts <- base::computeRestarts
[10:21:28.431]                           grepl <- base::grepl
[10:21:28.431]                           restarts <- computeRestarts(cond)
[10:21:28.431]                           for (restart in restarts) {
[10:21:28.431]                             name <- restart$name
[10:21:28.431]                             if (is.null(name)) 
[10:21:28.431]                               next
[10:21:28.431]                             if (!grepl(pattern, name)) 
[10:21:28.431]                               next
[10:21:28.431]                             invokeRestart(restart)
[10:21:28.431]                             muffled <- TRUE
[10:21:28.431]                             break
[10:21:28.431]                           }
[10:21:28.431]                         }
[10:21:28.431]                       }
[10:21:28.431]                       invisible(muffled)
[10:21:28.431]                     }
[10:21:28.431]                     muffleCondition(cond, pattern = "^muffle")
[10:21:28.431]                   }
[10:21:28.431]                 }
[10:21:28.431]             }
[10:21:28.431]         }))
[10:21:28.431]     }, error = function(ex) {
[10:21:28.431]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:28.431]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:28.431]                 ...future.rng), started = ...future.startTime, 
[10:21:28.431]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:28.431]             version = "1.8"), class = "FutureResult")
[10:21:28.431]     }, finally = {
[10:21:28.431]         if (!identical(...future.workdir, getwd())) 
[10:21:28.431]             setwd(...future.workdir)
[10:21:28.431]         {
[10:21:28.431]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:28.431]                 ...future.oldOptions$nwarnings <- NULL
[10:21:28.431]             }
[10:21:28.431]             base::options(...future.oldOptions)
[10:21:28.431]             if (.Platform$OS.type == "windows") {
[10:21:28.431]                 old_names <- names(...future.oldEnvVars)
[10:21:28.431]                 envs <- base::Sys.getenv()
[10:21:28.431]                 names <- names(envs)
[10:21:28.431]                 common <- intersect(names, old_names)
[10:21:28.431]                 added <- setdiff(names, old_names)
[10:21:28.431]                 removed <- setdiff(old_names, names)
[10:21:28.431]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:28.431]                   envs[common]]
[10:21:28.431]                 NAMES <- toupper(changed)
[10:21:28.431]                 args <- list()
[10:21:28.431]                 for (kk in seq_along(NAMES)) {
[10:21:28.431]                   name <- changed[[kk]]
[10:21:28.431]                   NAME <- NAMES[[kk]]
[10:21:28.431]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.431]                     next
[10:21:28.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:28.431]                 }
[10:21:28.431]                 NAMES <- toupper(added)
[10:21:28.431]                 for (kk in seq_along(NAMES)) {
[10:21:28.431]                   name <- added[[kk]]
[10:21:28.431]                   NAME <- NAMES[[kk]]
[10:21:28.431]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.431]                     next
[10:21:28.431]                   args[[name]] <- ""
[10:21:28.431]                 }
[10:21:28.431]                 NAMES <- toupper(removed)
[10:21:28.431]                 for (kk in seq_along(NAMES)) {
[10:21:28.431]                   name <- removed[[kk]]
[10:21:28.431]                   NAME <- NAMES[[kk]]
[10:21:28.431]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.431]                     next
[10:21:28.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:28.431]                 }
[10:21:28.431]                 if (length(args) > 0) 
[10:21:28.431]                   base::do.call(base::Sys.setenv, args = args)
[10:21:28.431]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:28.431]             }
[10:21:28.431]             else {
[10:21:28.431]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:28.431]             }
[10:21:28.431]             {
[10:21:28.431]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:28.431]                   0L) {
[10:21:28.431]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:28.431]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:28.431]                   base::options(opts)
[10:21:28.431]                 }
[10:21:28.431]                 {
[10:21:28.431]                   {
[10:21:28.431]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:28.431]                     NULL
[10:21:28.431]                   }
[10:21:28.431]                   options(future.plan = NULL)
[10:21:28.431]                   if (is.na(NA_character_)) 
[10:21:28.431]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:28.431]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:28.431]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:28.431]                     .init = FALSE)
[10:21:28.431]                 }
[10:21:28.431]             }
[10:21:28.431]         }
[10:21:28.431]     })
[10:21:28.431]     if (TRUE) {
[10:21:28.431]         base::sink(type = "output", split = FALSE)
[10:21:28.431]         if (TRUE) {
[10:21:28.431]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:28.431]         }
[10:21:28.431]         else {
[10:21:28.431]             ...future.result["stdout"] <- base::list(NULL)
[10:21:28.431]         }
[10:21:28.431]         base::close(...future.stdout)
[10:21:28.431]         ...future.stdout <- NULL
[10:21:28.431]     }
[10:21:28.431]     ...future.result$conditions <- ...future.conditions
[10:21:28.431]     ...future.result$finished <- base::Sys.time()
[10:21:28.431]     ...future.result
[10:21:28.431] }
[10:21:28.434] Exporting 3 global objects (1.53 KiB) to cluster node #1 ...
[10:21:28.434] Exporting ‘outer_function’ (250 bytes) to cluster node #1 ...
[10:21:28.434] Exporting ‘outer_function’ (250 bytes) to cluster node #1 ... DONE
[10:21:28.434] Exporting ‘map’ (633 bytes) to cluster node #1 ...
[10:21:28.435] Exporting ‘map’ (633 bytes) to cluster node #1 ... DONE
[10:21:28.435] Exporting ‘inner_function’ (371 bytes) to cluster node #1 ...
[10:21:28.435] Exporting ‘inner_function’ (371 bytes) to cluster node #1 ... DONE
[10:21:28.435] Exporting 3 global objects (1.53 KiB) to cluster node #1 ... DONE
[10:21:28.436] MultisessionFuture started
[10:21:28.436] - Launch lazy future ... done
[10:21:28.436] run() for ‘MultisessionFuture’ ... done
[10:21:28.436] result() for ClusterFuture ...
[10:21:28.436] receiveMessageFromWorker() for ClusterFuture ...
[10:21:28.436] - Validating connection of MultisessionFuture
[10:21:28.482] - received message: FutureResult
[10:21:28.483] - Received FutureResult
[10:21:28.483] - Erased future from FutureRegistry
[10:21:28.483] result() for ClusterFuture ...
[10:21:28.483] - result already collected: FutureResult
[10:21:28.483] result() for ClusterFuture ... done
[10:21:28.483] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:28.483] result() for ClusterFuture ... done
[10:21:28.483] result() for ClusterFuture ...
[10:21:28.483] - result already collected: FutureResult
[10:21:28.484] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[10:21:28.485] getGlobalsAndPackages() ...
[10:21:28.485] Searching for globals...
[10:21:28.489] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[10:21:28.489] Searching for globals ... DONE
[10:21:28.489] Resolving globals: FALSE
[10:21:28.490] The total size of the 3 globals is 1.22 KiB (1254 bytes)
[10:21:28.490] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (633 bytes of class ‘function’), ‘inner_function’ (371 bytes of class ‘function’) and ‘outer_function’ (250 bytes of class ‘function’)
[10:21:28.490] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[10:21:28.490] 
[10:21:28.490] getGlobalsAndPackages() ... DONE
[10:21:28.491] run() for ‘Future’ ...
[10:21:28.491] - state: ‘created’
[10:21:28.491] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:28.504] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:28.505] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:28.505]   - Field: ‘node’
[10:21:28.505]   - Field: ‘label’
[10:21:28.505]   - Field: ‘local’
[10:21:28.505]   - Field: ‘owner’
[10:21:28.505]   - Field: ‘envir’
[10:21:28.505]   - Field: ‘workers’
[10:21:28.505]   - Field: ‘packages’
[10:21:28.505]   - Field: ‘gc’
[10:21:28.505]   - Field: ‘conditions’
[10:21:28.506]   - Field: ‘persistent’
[10:21:28.506]   - Field: ‘expr’
[10:21:28.506]   - Field: ‘uuid’
[10:21:28.506]   - Field: ‘seed’
[10:21:28.506]   - Field: ‘version’
[10:21:28.506]   - Field: ‘result’
[10:21:28.506]   - Field: ‘asynchronous’
[10:21:28.506]   - Field: ‘calls’
[10:21:28.506]   - Field: ‘globals’
[10:21:28.506]   - Field: ‘stdout’
[10:21:28.506]   - Field: ‘earlySignal’
[10:21:28.506]   - Field: ‘lazy’
[10:21:28.507]   - Field: ‘state’
[10:21:28.507] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:28.507] - Launch lazy future ...
[10:21:28.507] Packages needed by the future expression (n = 0): <none>
[10:21:28.507] Packages needed by future strategies (n = 0): <none>
[10:21:28.508] {
[10:21:28.508]     {
[10:21:28.508]         {
[10:21:28.508]             ...future.startTime <- base::Sys.time()
[10:21:28.508]             {
[10:21:28.508]                 {
[10:21:28.508]                   {
[10:21:28.508]                     {
[10:21:28.508]                       base::local({
[10:21:28.508]                         has_future <- base::requireNamespace("future", 
[10:21:28.508]                           quietly = TRUE)
[10:21:28.508]                         if (has_future) {
[10:21:28.508]                           ns <- base::getNamespace("future")
[10:21:28.508]                           version <- ns[[".package"]][["version"]]
[10:21:28.508]                           if (is.null(version)) 
[10:21:28.508]                             version <- utils::packageVersion("future")
[10:21:28.508]                         }
[10:21:28.508]                         else {
[10:21:28.508]                           version <- NULL
[10:21:28.508]                         }
[10:21:28.508]                         if (!has_future || version < "1.8.0") {
[10:21:28.508]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:28.508]                             "", base::R.version$version.string), 
[10:21:28.508]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:28.508]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:28.508]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:28.508]                               "release", "version")], collapse = " "), 
[10:21:28.508]                             hostname = base::Sys.info()[["nodename"]])
[10:21:28.508]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:28.508]                             info)
[10:21:28.508]                           info <- base::paste(info, collapse = "; ")
[10:21:28.508]                           if (!has_future) {
[10:21:28.508]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:28.508]                               info)
[10:21:28.508]                           }
[10:21:28.508]                           else {
[10:21:28.508]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:28.508]                               info, version)
[10:21:28.508]                           }
[10:21:28.508]                           base::stop(msg)
[10:21:28.508]                         }
[10:21:28.508]                       })
[10:21:28.508]                     }
[10:21:28.508]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:28.508]                     base::options(mc.cores = 1L)
[10:21:28.508]                   }
[10:21:28.508]                   ...future.strategy.old <- future::plan("list")
[10:21:28.508]                   options(future.plan = NULL)
[10:21:28.508]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:28.508]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:28.508]                 }
[10:21:28.508]                 ...future.workdir <- getwd()
[10:21:28.508]             }
[10:21:28.508]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:28.508]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:28.508]         }
[10:21:28.508]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:28.508]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:28.508]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:28.508]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:28.508]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:28.508]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:28.508]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:28.508]             base::names(...future.oldOptions))
[10:21:28.508]     }
[10:21:28.508]     if (FALSE) {
[10:21:28.508]     }
[10:21:28.508]     else {
[10:21:28.508]         if (TRUE) {
[10:21:28.508]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:28.508]                 open = "w")
[10:21:28.508]         }
[10:21:28.508]         else {
[10:21:28.508]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:28.508]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:28.508]         }
[10:21:28.508]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:28.508]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:28.508]             base::sink(type = "output", split = FALSE)
[10:21:28.508]             base::close(...future.stdout)
[10:21:28.508]         }, add = TRUE)
[10:21:28.508]     }
[10:21:28.508]     ...future.frame <- base::sys.nframe()
[10:21:28.508]     ...future.conditions <- base::list()
[10:21:28.508]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:28.508]     if (FALSE) {
[10:21:28.508]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:28.508]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:28.508]     }
[10:21:28.508]     ...future.result <- base::tryCatch({
[10:21:28.508]         base::withCallingHandlers({
[10:21:28.508]             ...future.value <- base::withVisible(base::local({
[10:21:28.508]                 ...future.makeSendCondition <- base::local({
[10:21:28.508]                   sendCondition <- NULL
[10:21:28.508]                   function(frame = 1L) {
[10:21:28.508]                     if (is.function(sendCondition)) 
[10:21:28.508]                       return(sendCondition)
[10:21:28.508]                     ns <- getNamespace("parallel")
[10:21:28.508]                     if (exists("sendData", mode = "function", 
[10:21:28.508]                       envir = ns)) {
[10:21:28.508]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:28.508]                         envir = ns)
[10:21:28.508]                       envir <- sys.frame(frame)
[10:21:28.508]                       master <- NULL
[10:21:28.508]                       while (!identical(envir, .GlobalEnv) && 
[10:21:28.508]                         !identical(envir, emptyenv())) {
[10:21:28.508]                         if (exists("master", mode = "list", envir = envir, 
[10:21:28.508]                           inherits = FALSE)) {
[10:21:28.508]                           master <- get("master", mode = "list", 
[10:21:28.508]                             envir = envir, inherits = FALSE)
[10:21:28.508]                           if (inherits(master, c("SOCKnode", 
[10:21:28.508]                             "SOCK0node"))) {
[10:21:28.508]                             sendCondition <<- function(cond) {
[10:21:28.508]                               data <- list(type = "VALUE", value = cond, 
[10:21:28.508]                                 success = TRUE)
[10:21:28.508]                               parallel_sendData(master, data)
[10:21:28.508]                             }
[10:21:28.508]                             return(sendCondition)
[10:21:28.508]                           }
[10:21:28.508]                         }
[10:21:28.508]                         frame <- frame + 1L
[10:21:28.508]                         envir <- sys.frame(frame)
[10:21:28.508]                       }
[10:21:28.508]                     }
[10:21:28.508]                     sendCondition <<- function(cond) NULL
[10:21:28.508]                   }
[10:21:28.508]                 })
[10:21:28.508]                 withCallingHandlers({
[10:21:28.508]                   {
[10:21:28.508]                     outer_function(1L)
[10:21:28.508]                   }
[10:21:28.508]                 }, immediateCondition = function(cond) {
[10:21:28.508]                   sendCondition <- ...future.makeSendCondition()
[10:21:28.508]                   sendCondition(cond)
[10:21:28.508]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.508]                   {
[10:21:28.508]                     inherits <- base::inherits
[10:21:28.508]                     invokeRestart <- base::invokeRestart
[10:21:28.508]                     is.null <- base::is.null
[10:21:28.508]                     muffled <- FALSE
[10:21:28.508]                     if (inherits(cond, "message")) {
[10:21:28.508]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:28.508]                       if (muffled) 
[10:21:28.508]                         invokeRestart("muffleMessage")
[10:21:28.508]                     }
[10:21:28.508]                     else if (inherits(cond, "warning")) {
[10:21:28.508]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:28.508]                       if (muffled) 
[10:21:28.508]                         invokeRestart("muffleWarning")
[10:21:28.508]                     }
[10:21:28.508]                     else if (inherits(cond, "condition")) {
[10:21:28.508]                       if (!is.null(pattern)) {
[10:21:28.508]                         computeRestarts <- base::computeRestarts
[10:21:28.508]                         grepl <- base::grepl
[10:21:28.508]                         restarts <- computeRestarts(cond)
[10:21:28.508]                         for (restart in restarts) {
[10:21:28.508]                           name <- restart$name
[10:21:28.508]                           if (is.null(name)) 
[10:21:28.508]                             next
[10:21:28.508]                           if (!grepl(pattern, name)) 
[10:21:28.508]                             next
[10:21:28.508]                           invokeRestart(restart)
[10:21:28.508]                           muffled <- TRUE
[10:21:28.508]                           break
[10:21:28.508]                         }
[10:21:28.508]                       }
[10:21:28.508]                     }
[10:21:28.508]                     invisible(muffled)
[10:21:28.508]                   }
[10:21:28.508]                   muffleCondition(cond)
[10:21:28.508]                 })
[10:21:28.508]             }))
[10:21:28.508]             future::FutureResult(value = ...future.value$value, 
[10:21:28.508]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:28.508]                   ...future.rng), globalenv = if (FALSE) 
[10:21:28.508]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:28.508]                     ...future.globalenv.names))
[10:21:28.508]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:28.508]         }, condition = base::local({
[10:21:28.508]             c <- base::c
[10:21:28.508]             inherits <- base::inherits
[10:21:28.508]             invokeRestart <- base::invokeRestart
[10:21:28.508]             length <- base::length
[10:21:28.508]             list <- base::list
[10:21:28.508]             seq.int <- base::seq.int
[10:21:28.508]             signalCondition <- base::signalCondition
[10:21:28.508]             sys.calls <- base::sys.calls
[10:21:28.508]             `[[` <- base::`[[`
[10:21:28.508]             `+` <- base::`+`
[10:21:28.508]             `<<-` <- base::`<<-`
[10:21:28.508]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:28.508]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:28.508]                   3L)]
[10:21:28.508]             }
[10:21:28.508]             function(cond) {
[10:21:28.508]                 is_error <- inherits(cond, "error")
[10:21:28.508]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:28.508]                   NULL)
[10:21:28.508]                 if (is_error) {
[10:21:28.508]                   sessionInformation <- function() {
[10:21:28.508]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:28.508]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:28.508]                       search = base::search(), system = base::Sys.info())
[10:21:28.508]                   }
[10:21:28.508]                   ...future.conditions[[length(...future.conditions) + 
[10:21:28.508]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:28.508]                     cond$call), session = sessionInformation(), 
[10:21:28.508]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:28.508]                   signalCondition(cond)
[10:21:28.508]                 }
[10:21:28.508]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:28.508]                 "immediateCondition"))) {
[10:21:28.508]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:28.508]                   ...future.conditions[[length(...future.conditions) + 
[10:21:28.508]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:28.508]                   if (TRUE && !signal) {
[10:21:28.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.508]                     {
[10:21:28.508]                       inherits <- base::inherits
[10:21:28.508]                       invokeRestart <- base::invokeRestart
[10:21:28.508]                       is.null <- base::is.null
[10:21:28.508]                       muffled <- FALSE
[10:21:28.508]                       if (inherits(cond, "message")) {
[10:21:28.508]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:28.508]                         if (muffled) 
[10:21:28.508]                           invokeRestart("muffleMessage")
[10:21:28.508]                       }
[10:21:28.508]                       else if (inherits(cond, "warning")) {
[10:21:28.508]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:28.508]                         if (muffled) 
[10:21:28.508]                           invokeRestart("muffleWarning")
[10:21:28.508]                       }
[10:21:28.508]                       else if (inherits(cond, "condition")) {
[10:21:28.508]                         if (!is.null(pattern)) {
[10:21:28.508]                           computeRestarts <- base::computeRestarts
[10:21:28.508]                           grepl <- base::grepl
[10:21:28.508]                           restarts <- computeRestarts(cond)
[10:21:28.508]                           for (restart in restarts) {
[10:21:28.508]                             name <- restart$name
[10:21:28.508]                             if (is.null(name)) 
[10:21:28.508]                               next
[10:21:28.508]                             if (!grepl(pattern, name)) 
[10:21:28.508]                               next
[10:21:28.508]                             invokeRestart(restart)
[10:21:28.508]                             muffled <- TRUE
[10:21:28.508]                             break
[10:21:28.508]                           }
[10:21:28.508]                         }
[10:21:28.508]                       }
[10:21:28.508]                       invisible(muffled)
[10:21:28.508]                     }
[10:21:28.508]                     muffleCondition(cond, pattern = "^muffle")
[10:21:28.508]                   }
[10:21:28.508]                 }
[10:21:28.508]                 else {
[10:21:28.508]                   if (TRUE) {
[10:21:28.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:28.508]                     {
[10:21:28.508]                       inherits <- base::inherits
[10:21:28.508]                       invokeRestart <- base::invokeRestart
[10:21:28.508]                       is.null <- base::is.null
[10:21:28.508]                       muffled <- FALSE
[10:21:28.508]                       if (inherits(cond, "message")) {
[10:21:28.508]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:28.508]                         if (muffled) 
[10:21:28.508]                           invokeRestart("muffleMessage")
[10:21:28.508]                       }
[10:21:28.508]                       else if (inherits(cond, "warning")) {
[10:21:28.508]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:28.508]                         if (muffled) 
[10:21:28.508]                           invokeRestart("muffleWarning")
[10:21:28.508]                       }
[10:21:28.508]                       else if (inherits(cond, "condition")) {
[10:21:28.508]                         if (!is.null(pattern)) {
[10:21:28.508]                           computeRestarts <- base::computeRestarts
[10:21:28.508]                           grepl <- base::grepl
[10:21:28.508]                           restarts <- computeRestarts(cond)
[10:21:28.508]                           for (restart in restarts) {
[10:21:28.508]                             name <- restart$name
[10:21:28.508]                             if (is.null(name)) 
[10:21:28.508]                               next
[10:21:28.508]                             if (!grepl(pattern, name)) 
[10:21:28.508]                               next
[10:21:28.508]                             invokeRestart(restart)
[10:21:28.508]                             muffled <- TRUE
[10:21:28.508]                             break
[10:21:28.508]                           }
[10:21:28.508]                         }
[10:21:28.508]                       }
[10:21:28.508]                       invisible(muffled)
[10:21:28.508]                     }
[10:21:28.508]                     muffleCondition(cond, pattern = "^muffle")
[10:21:28.508]                   }
[10:21:28.508]                 }
[10:21:28.508]             }
[10:21:28.508]         }))
[10:21:28.508]     }, error = function(ex) {
[10:21:28.508]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:28.508]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:28.508]                 ...future.rng), started = ...future.startTime, 
[10:21:28.508]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:28.508]             version = "1.8"), class = "FutureResult")
[10:21:28.508]     }, finally = {
[10:21:28.508]         if (!identical(...future.workdir, getwd())) 
[10:21:28.508]             setwd(...future.workdir)
[10:21:28.508]         {
[10:21:28.508]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:28.508]                 ...future.oldOptions$nwarnings <- NULL
[10:21:28.508]             }
[10:21:28.508]             base::options(...future.oldOptions)
[10:21:28.508]             if (.Platform$OS.type == "windows") {
[10:21:28.508]                 old_names <- names(...future.oldEnvVars)
[10:21:28.508]                 envs <- base::Sys.getenv()
[10:21:28.508]                 names <- names(envs)
[10:21:28.508]                 common <- intersect(names, old_names)
[10:21:28.508]                 added <- setdiff(names, old_names)
[10:21:28.508]                 removed <- setdiff(old_names, names)
[10:21:28.508]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:28.508]                   envs[common]]
[10:21:28.508]                 NAMES <- toupper(changed)
[10:21:28.508]                 args <- list()
[10:21:28.508]                 for (kk in seq_along(NAMES)) {
[10:21:28.508]                   name <- changed[[kk]]
[10:21:28.508]                   NAME <- NAMES[[kk]]
[10:21:28.508]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.508]                     next
[10:21:28.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:28.508]                 }
[10:21:28.508]                 NAMES <- toupper(added)
[10:21:28.508]                 for (kk in seq_along(NAMES)) {
[10:21:28.508]                   name <- added[[kk]]
[10:21:28.508]                   NAME <- NAMES[[kk]]
[10:21:28.508]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.508]                     next
[10:21:28.508]                   args[[name]] <- ""
[10:21:28.508]                 }
[10:21:28.508]                 NAMES <- toupper(removed)
[10:21:28.508]                 for (kk in seq_along(NAMES)) {
[10:21:28.508]                   name <- removed[[kk]]
[10:21:28.508]                   NAME <- NAMES[[kk]]
[10:21:28.508]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:28.508]                     next
[10:21:28.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:28.508]                 }
[10:21:28.508]                 if (length(args) > 0) 
[10:21:28.508]                   base::do.call(base::Sys.setenv, args = args)
[10:21:28.508]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:28.508]             }
[10:21:28.508]             else {
[10:21:28.508]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:28.508]             }
[10:21:28.508]             {
[10:21:28.508]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:28.508]                   0L) {
[10:21:28.508]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:28.508]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:28.508]                   base::options(opts)
[10:21:28.508]                 }
[10:21:28.508]                 {
[10:21:28.508]                   {
[10:21:28.508]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:28.508]                     NULL
[10:21:28.508]                   }
[10:21:28.508]                   options(future.plan = NULL)
[10:21:28.508]                   if (is.na(NA_character_)) 
[10:21:28.508]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:28.508]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:28.508]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:28.508]                     .init = FALSE)
[10:21:28.508]                 }
[10:21:28.508]             }
[10:21:28.508]         }
[10:21:28.508]     })
[10:21:28.508]     if (TRUE) {
[10:21:28.508]         base::sink(type = "output", split = FALSE)
[10:21:28.508]         if (TRUE) {
[10:21:28.508]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:28.508]         }
[10:21:28.508]         else {
[10:21:28.508]             ...future.result["stdout"] <- base::list(NULL)
[10:21:28.508]         }
[10:21:28.508]         base::close(...future.stdout)
[10:21:28.508]         ...future.stdout <- NULL
[10:21:28.508]     }
[10:21:28.508]     ...future.result$conditions <- ...future.conditions
[10:21:28.508]     ...future.result$finished <- base::Sys.time()
[10:21:28.508]     ...future.result
[10:21:28.508] }
[10:21:28.510] Exporting 3 global objects (1.53 KiB) to cluster node #1 ...
[10:21:28.510] Exporting ‘outer_function’ (250 bytes) to cluster node #1 ...
[10:21:28.511] Exporting ‘outer_function’ (250 bytes) to cluster node #1 ... DONE
[10:21:28.511] Exporting ‘map’ (633 bytes) to cluster node #1 ...
[10:21:28.511] Exporting ‘map’ (633 bytes) to cluster node #1 ... DONE
[10:21:28.511] Exporting ‘inner_function’ (371 bytes) to cluster node #1 ...
[10:21:28.512] Exporting ‘inner_function’ (371 bytes) to cluster node #1 ... DONE
[10:21:28.512] Exporting 3 global objects (1.53 KiB) to cluster node #1 ... DONE
[10:21:28.512] MultisessionFuture started
[10:21:28.512] - Launch lazy future ... done
[10:21:28.512] run() for ‘MultisessionFuture’ ... done
[10:21:28.513] result() for ClusterFuture ...
[10:21:28.513] receiveMessageFromWorker() for ClusterFuture ...
[10:21:28.513] - Validating connection of MultisessionFuture
[10:21:28.554] - received message: FutureResult
[10:21:28.554] - Received FutureResult
[10:21:28.554] - Erased future from FutureRegistry
[10:21:28.555] result() for ClusterFuture ...
[10:21:28.555] - result already collected: FutureResult
[10:21:28.555] result() for ClusterFuture ... done
[10:21:28.555] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:28.555] result() for ClusterFuture ... done
[10:21:28.555] result() for ClusterFuture ...
[10:21:28.555] - result already collected: FutureResult
[10:21:28.555] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 2 cores ... DONE
> 
> message("*** Globals - formulas ... DONE")
*** Globals - formulas ... DONE
> 
> source("incl/end.R")
[10:21:28.557] plan(): Setting new future strategy stack:
[10:21:28.557] List of future strategies:
[10:21:28.557] 1. FutureStrategy:
[10:21:28.557]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:28.557]    - tweaked: FALSE
[10:21:28.557]    - call: future::plan(oplan)
[10:21:28.558] plan(): nbrOfWorkers() = 1
> 
