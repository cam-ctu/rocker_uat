
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[11:01:35.396] plan(): Setting new future strategy stack:
[11:01:35.396] List of future strategies:
[11:01:35.396] 1. sequential:
[11:01:35.396]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.396]    - tweaked: FALSE
[11:01:35.396]    - call: future::plan("sequential")
[11:01:35.409] plan(): nbrOfWorkers() = 1
> 
> library("datasets") ## cars data set
> library("stats")    ## lm(), poly(), xtabs()
> 
> message("*** Globals - formulas ...")
*** Globals - formulas ...
> 
> ## (i) lm(<formula>):
> ## From example("lm", package = "stats")
> ctl <- c(4.17, 5.58, 5.18, 6.11, 4.50, 4.61, 5.17, 4.53, 5.33, 5.14)
> trt <- c(4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 4.89, 4.32, 4.69)
> group <- gl(2, 10, 20, labels = c("Ctl", "Trt"))
> weight <- c(ctl, trt)
> ctl <- trt <- NULL
> ## Truth:
> fit_i <- lm(weight ~ group - 1)
> print(fit_i)

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

> 
> ## (ii) xtabs(~ x):
> x <- c(1, 1, 2, 2, 2)
> ## Truth:
> tbl_ii <- xtabs(~ x)
> print(tbl_ii)
x
1 2 
2 3 
> 
> ## (iii) lm(<formula>, data = cars):
> exprs <- list(
+   # "remove-intercept-term" form of no-intercept
+   a = substitute({ lm(dist ~ . -1, data = cars) }),
+   # "make-intercept-zero" form of no-intercept
+   b = substitute({ lm(dist ~ . +0, data = cars) }),
+   # doesn't do what we want here
+   c = substitute({ lm(dist ~ speed + speed ^ 2, data = cars) }),
+   # gets us a quadratic term
+   d = substitute({ lm(dist ~ speed + I(speed ^ 2), data = cars) }),
+   # avoid potential multicollinearity
+   e = substitute({ lm(dist ~ poly(speed, 2), data = cars) })
+ )
> 
> ## (iv) Globals - map(x, ~ expr):
> ## A fake purrr::map() function with limited functionality
> map <- function(.x, .f, ...) {
+   if (inherits(.f, "formula")) {
+     expr <- .f[[-1]]
+     .f <- eval(bquote(function(...) {
+       .(expr)
+     }))
+   }
+   eval(lapply(.x, FUN = .f, ...))
+ }
> 
> inner_function <- function(x) { x + 1 }
> 
> outer_function <- function(x) {
+   map(1:2, ~ inner_function(.x))
+ }
> 
> y_iv <- outer_function(1L)
> str(y_iv)
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
> 
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     message("- lm(<formula>) ...")
+     
+     ## Explicit future
+     f <- future({ lm(weight ~ group - 1) })
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Explicit future (lazy)
+     f <- future({ lm(weight ~ group - 1) }, lazy = TRUE)
+     fit <- value(f)
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment
+     fit %<-% { lm(weight ~ group - 1) }
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (non-lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% FALSE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     ## Future assignment (lazy)
+     fit %<-% { lm(weight ~ group - 1) } %lazy% TRUE
+     print(fit)
+     stopifnot(all.equal(fit, fit_i))
+ 
+     message("- Globals - one-side formulas, e.g. xtabs(~ x) ...")
+     ## Explicit future
+     f <- future({ xtabs(~ x) })
+     tbl <- value(f)
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     ## Future assignment
+     tbl %<-% { xtabs(~ x) }
+     print(tbl)
+     stopifnot(all.equal(tbl, tbl_ii))
+ 
+     message("- Globals - lm(<formula>, data = cars) ...")
+     for (kk in seq_along(exprs)) {
+       expr <- exprs[[kk]]
+       name <- names(exprs)[kk]
+       message(sprintf("- Globals - lm(<formula #%d (%s)>, data = cars) ...",
+                       kk, sQuote(name)))
+     
+       fit_iii <- eval(expr)
+       print(fit_iii)
+     
+       f <- future(expr, substitute = FALSE)
+       fit <- value(f)
+       print(fit)
+     
+       stopifnot(all.equal(fit, fit_iii))
+     } ## for (kk ...)
+ 
+     message("- Globals - map(x, ~ expr) ...")
+     f <- future({ outer_function(1L) })
+     y <- value(f)
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+ 
+     y %<-% { outer_function(1L) }
+     str(y)
+     stopifnot(all.equal(y, y_iv))
+   } ## for (strategy ...)
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[11:01:35.467] plan(): Setting new future strategy stack:
[11:01:35.467] List of future strategies:
[11:01:35.467] 1. sequential:
[11:01:35.467]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.467]    - tweaked: FALSE
[11:01:35.467]    - call: plan(strategy)
[11:01:35.478] plan(): nbrOfWorkers() = 1
- lm(<formula>) ...
[11:01:35.479] getGlobalsAndPackages() ...
[11:01:35.479] Searching for globals...
[11:01:35.485] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[11:01:35.485] Searching for globals ... DONE
[11:01:35.485] Resolving globals: FALSE
[11:01:35.486] The total size of the 2 globals is 401 bytes (401 bytes)
[11:01:35.486] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[11:01:35.487] - globals: [2] ‘weight’, ‘group’
[11:01:35.487] - packages: [1] ‘stats’
[11:01:35.487] getGlobalsAndPackages() ... DONE
[11:01:35.487] run() for ‘Future’ ...
[11:01:35.487] - state: ‘created’
[11:01:35.488] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:35.488] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:35.488] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:35.488]   - Field: ‘label’
[11:01:35.488]   - Field: ‘local’
[11:01:35.488]   - Field: ‘owner’
[11:01:35.488]   - Field: ‘envir’
[11:01:35.488]   - Field: ‘packages’
[11:01:35.488]   - Field: ‘gc’
[11:01:35.489]   - Field: ‘conditions’
[11:01:35.489]   - Field: ‘expr’
[11:01:35.489]   - Field: ‘uuid’
[11:01:35.489]   - Field: ‘seed’
[11:01:35.489]   - Field: ‘version’
[11:01:35.489]   - Field: ‘result’
[11:01:35.489]   - Field: ‘asynchronous’
[11:01:35.489]   - Field: ‘calls’
[11:01:35.489]   - Field: ‘globals’
[11:01:35.489]   - Field: ‘stdout’
[11:01:35.489]   - Field: ‘earlySignal’
[11:01:35.489]   - Field: ‘lazy’
[11:01:35.490]   - Field: ‘state’
[11:01:35.490] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:35.490] - Launch lazy future ...
[11:01:35.490] Packages needed by the future expression (n = 1): ‘stats’
[11:01:35.490] Packages needed by future strategies (n = 0): <none>
[11:01:35.491] {
[11:01:35.491]     {
[11:01:35.491]         {
[11:01:35.491]             ...future.startTime <- base::Sys.time()
[11:01:35.491]             {
[11:01:35.491]                 {
[11:01:35.491]                   {
[11:01:35.491]                     {
[11:01:35.491]                       base::local({
[11:01:35.491]                         has_future <- base::requireNamespace("future", 
[11:01:35.491]                           quietly = TRUE)
[11:01:35.491]                         if (has_future) {
[11:01:35.491]                           ns <- base::getNamespace("future")
[11:01:35.491]                           version <- ns[[".package"]][["version"]]
[11:01:35.491]                           if (is.null(version)) 
[11:01:35.491]                             version <- utils::packageVersion("future")
[11:01:35.491]                         }
[11:01:35.491]                         else {
[11:01:35.491]                           version <- NULL
[11:01:35.491]                         }
[11:01:35.491]                         if (!has_future || version < "1.8.0") {
[11:01:35.491]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.491]                             "", base::R.version$version.string), 
[11:01:35.491]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:35.491]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:35.491]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.491]                               "release", "version")], collapse = " "), 
[11:01:35.491]                             hostname = base::Sys.info()[["nodename"]])
[11:01:35.491]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.491]                             info)
[11:01:35.491]                           info <- base::paste(info, collapse = "; ")
[11:01:35.491]                           if (!has_future) {
[11:01:35.491]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.491]                               info)
[11:01:35.491]                           }
[11:01:35.491]                           else {
[11:01:35.491]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.491]                               info, version)
[11:01:35.491]                           }
[11:01:35.491]                           base::stop(msg)
[11:01:35.491]                         }
[11:01:35.491]                       })
[11:01:35.491]                     }
[11:01:35.491]                     base::local({
[11:01:35.491]                       for (pkg in "stats") {
[11:01:35.491]                         base::loadNamespace(pkg)
[11:01:35.491]                         base::library(pkg, character.only = TRUE)
[11:01:35.491]                       }
[11:01:35.491]                     })
[11:01:35.491]                   }
[11:01:35.491]                   ...future.strategy.old <- future::plan("list")
[11:01:35.491]                   options(future.plan = NULL)
[11:01:35.491]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.491]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.491]                 }
[11:01:35.491]                 ...future.workdir <- getwd()
[11:01:35.491]             }
[11:01:35.491]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.491]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.491]         }
[11:01:35.491]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.491]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.491]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.491]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.491]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.491]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.491]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.491]             base::names(...future.oldOptions))
[11:01:35.491]     }
[11:01:35.491]     if (FALSE) {
[11:01:35.491]     }
[11:01:35.491]     else {
[11:01:35.491]         if (TRUE) {
[11:01:35.491]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.491]                 open = "w")
[11:01:35.491]         }
[11:01:35.491]         else {
[11:01:35.491]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.491]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.491]         }
[11:01:35.491]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.491]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.491]             base::sink(type = "output", split = FALSE)
[11:01:35.491]             base::close(...future.stdout)
[11:01:35.491]         }, add = TRUE)
[11:01:35.491]     }
[11:01:35.491]     ...future.frame <- base::sys.nframe()
[11:01:35.491]     ...future.conditions <- base::list()
[11:01:35.491]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.491]     if (FALSE) {
[11:01:35.491]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.491]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.491]     }
[11:01:35.491]     ...future.result <- base::tryCatch({
[11:01:35.491]         base::withCallingHandlers({
[11:01:35.491]             ...future.value <- base::withVisible(base::local({
[11:01:35.491]                 lm(weight ~ group - 1)
[11:01:35.491]             }))
[11:01:35.491]             future::FutureResult(value = ...future.value$value, 
[11:01:35.491]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.491]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.491]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.491]                     ...future.globalenv.names))
[11:01:35.491]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.491]         }, condition = base::local({
[11:01:35.491]             c <- base::c
[11:01:35.491]             inherits <- base::inherits
[11:01:35.491]             invokeRestart <- base::invokeRestart
[11:01:35.491]             length <- base::length
[11:01:35.491]             list <- base::list
[11:01:35.491]             seq.int <- base::seq.int
[11:01:35.491]             signalCondition <- base::signalCondition
[11:01:35.491]             sys.calls <- base::sys.calls
[11:01:35.491]             `[[` <- base::`[[`
[11:01:35.491]             `+` <- base::`+`
[11:01:35.491]             `<<-` <- base::`<<-`
[11:01:35.491]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.491]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.491]                   3L)]
[11:01:35.491]             }
[11:01:35.491]             function(cond) {
[11:01:35.491]                 is_error <- inherits(cond, "error")
[11:01:35.491]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.491]                   NULL)
[11:01:35.491]                 if (is_error) {
[11:01:35.491]                   sessionInformation <- function() {
[11:01:35.491]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.491]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.491]                       search = base::search(), system = base::Sys.info())
[11:01:35.491]                   }
[11:01:35.491]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.491]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.491]                     cond$call), session = sessionInformation(), 
[11:01:35.491]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.491]                   signalCondition(cond)
[11:01:35.491]                 }
[11:01:35.491]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.491]                 "immediateCondition"))) {
[11:01:35.491]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.491]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.491]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.491]                   if (TRUE && !signal) {
[11:01:35.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.491]                     {
[11:01:35.491]                       inherits <- base::inherits
[11:01:35.491]                       invokeRestart <- base::invokeRestart
[11:01:35.491]                       is.null <- base::is.null
[11:01:35.491]                       muffled <- FALSE
[11:01:35.491]                       if (inherits(cond, "message")) {
[11:01:35.491]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.491]                         if (muffled) 
[11:01:35.491]                           invokeRestart("muffleMessage")
[11:01:35.491]                       }
[11:01:35.491]                       else if (inherits(cond, "warning")) {
[11:01:35.491]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.491]                         if (muffled) 
[11:01:35.491]                           invokeRestart("muffleWarning")
[11:01:35.491]                       }
[11:01:35.491]                       else if (inherits(cond, "condition")) {
[11:01:35.491]                         if (!is.null(pattern)) {
[11:01:35.491]                           computeRestarts <- base::computeRestarts
[11:01:35.491]                           grepl <- base::grepl
[11:01:35.491]                           restarts <- computeRestarts(cond)
[11:01:35.491]                           for (restart in restarts) {
[11:01:35.491]                             name <- restart$name
[11:01:35.491]                             if (is.null(name)) 
[11:01:35.491]                               next
[11:01:35.491]                             if (!grepl(pattern, name)) 
[11:01:35.491]                               next
[11:01:35.491]                             invokeRestart(restart)
[11:01:35.491]                             muffled <- TRUE
[11:01:35.491]                             break
[11:01:35.491]                           }
[11:01:35.491]                         }
[11:01:35.491]                       }
[11:01:35.491]                       invisible(muffled)
[11:01:35.491]                     }
[11:01:35.491]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.491]                   }
[11:01:35.491]                 }
[11:01:35.491]                 else {
[11:01:35.491]                   if (TRUE) {
[11:01:35.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.491]                     {
[11:01:35.491]                       inherits <- base::inherits
[11:01:35.491]                       invokeRestart <- base::invokeRestart
[11:01:35.491]                       is.null <- base::is.null
[11:01:35.491]                       muffled <- FALSE
[11:01:35.491]                       if (inherits(cond, "message")) {
[11:01:35.491]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.491]                         if (muffled) 
[11:01:35.491]                           invokeRestart("muffleMessage")
[11:01:35.491]                       }
[11:01:35.491]                       else if (inherits(cond, "warning")) {
[11:01:35.491]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.491]                         if (muffled) 
[11:01:35.491]                           invokeRestart("muffleWarning")
[11:01:35.491]                       }
[11:01:35.491]                       else if (inherits(cond, "condition")) {
[11:01:35.491]                         if (!is.null(pattern)) {
[11:01:35.491]                           computeRestarts <- base::computeRestarts
[11:01:35.491]                           grepl <- base::grepl
[11:01:35.491]                           restarts <- computeRestarts(cond)
[11:01:35.491]                           for (restart in restarts) {
[11:01:35.491]                             name <- restart$name
[11:01:35.491]                             if (is.null(name)) 
[11:01:35.491]                               next
[11:01:35.491]                             if (!grepl(pattern, name)) 
[11:01:35.491]                               next
[11:01:35.491]                             invokeRestart(restart)
[11:01:35.491]                             muffled <- TRUE
[11:01:35.491]                             break
[11:01:35.491]                           }
[11:01:35.491]                         }
[11:01:35.491]                       }
[11:01:35.491]                       invisible(muffled)
[11:01:35.491]                     }
[11:01:35.491]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.491]                   }
[11:01:35.491]                 }
[11:01:35.491]             }
[11:01:35.491]         }))
[11:01:35.491]     }, error = function(ex) {
[11:01:35.491]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.491]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.491]                 ...future.rng), started = ...future.startTime, 
[11:01:35.491]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.491]             version = "1.8"), class = "FutureResult")
[11:01:35.491]     }, finally = {
[11:01:35.491]         if (!identical(...future.workdir, getwd())) 
[11:01:35.491]             setwd(...future.workdir)
[11:01:35.491]         {
[11:01:35.491]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.491]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.491]             }
[11:01:35.491]             base::options(...future.oldOptions)
[11:01:35.491]             if (.Platform$OS.type == "windows") {
[11:01:35.491]                 old_names <- names(...future.oldEnvVars)
[11:01:35.491]                 envs <- base::Sys.getenv()
[11:01:35.491]                 names <- names(envs)
[11:01:35.491]                 common <- intersect(names, old_names)
[11:01:35.491]                 added <- setdiff(names, old_names)
[11:01:35.491]                 removed <- setdiff(old_names, names)
[11:01:35.491]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.491]                   envs[common]]
[11:01:35.491]                 NAMES <- toupper(changed)
[11:01:35.491]                 args <- list()
[11:01:35.491]                 for (kk in seq_along(NAMES)) {
[11:01:35.491]                   name <- changed[[kk]]
[11:01:35.491]                   NAME <- NAMES[[kk]]
[11:01:35.491]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.491]                     next
[11:01:35.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.491]                 }
[11:01:35.491]                 NAMES <- toupper(added)
[11:01:35.491]                 for (kk in seq_along(NAMES)) {
[11:01:35.491]                   name <- added[[kk]]
[11:01:35.491]                   NAME <- NAMES[[kk]]
[11:01:35.491]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.491]                     next
[11:01:35.491]                   args[[name]] <- ""
[11:01:35.491]                 }
[11:01:35.491]                 NAMES <- toupper(removed)
[11:01:35.491]                 for (kk in seq_along(NAMES)) {
[11:01:35.491]                   name <- removed[[kk]]
[11:01:35.491]                   NAME <- NAMES[[kk]]
[11:01:35.491]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.491]                     next
[11:01:35.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.491]                 }
[11:01:35.491]                 if (length(args) > 0) 
[11:01:35.491]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.491]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.491]             }
[11:01:35.491]             else {
[11:01:35.491]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.491]             }
[11:01:35.491]             {
[11:01:35.491]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.491]                   0L) {
[11:01:35.491]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.491]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.491]                   base::options(opts)
[11:01:35.491]                 }
[11:01:35.491]                 {
[11:01:35.491]                   {
[11:01:35.491]                     NULL
[11:01:35.491]                     RNGkind("Mersenne-Twister")
[11:01:35.491]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:35.491]                       inherits = FALSE)
[11:01:35.491]                   }
[11:01:35.491]                   options(future.plan = NULL)
[11:01:35.491]                   if (is.na(NA_character_)) 
[11:01:35.491]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.491]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.491]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.491]                     .init = FALSE)
[11:01:35.491]                 }
[11:01:35.491]             }
[11:01:35.491]         }
[11:01:35.491]     })
[11:01:35.491]     if (TRUE) {
[11:01:35.491]         base::sink(type = "output", split = FALSE)
[11:01:35.491]         if (TRUE) {
[11:01:35.491]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.491]         }
[11:01:35.491]         else {
[11:01:35.491]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.491]         }
[11:01:35.491]         base::close(...future.stdout)
[11:01:35.491]         ...future.stdout <- NULL
[11:01:35.491]     }
[11:01:35.491]     ...future.result$conditions <- ...future.conditions
[11:01:35.491]     ...future.result$finished <- base::Sys.time()
[11:01:35.491]     ...future.result
[11:01:35.491] }
[11:01:35.493] assign_globals() ...
[11:01:35.493] List of 2
[11:01:35.493]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[11:01:35.493]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[11:01:35.493]  - attr(*, "where")=List of 2
[11:01:35.493]   ..$ weight:<environment: R_EmptyEnv> 
[11:01:35.493]   ..$ group :<environment: R_EmptyEnv> 
[11:01:35.493]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:35.493]  - attr(*, "resolved")= logi FALSE
[11:01:35.493]  - attr(*, "total_size")= num 401
[11:01:35.493]  - attr(*, "already-done")= logi TRUE
[11:01:35.496] - copied ‘weight’ to environment
[11:01:35.496] - copied ‘group’ to environment
[11:01:35.496] assign_globals() ... done
[11:01:35.497] plan(): Setting new future strategy stack:
[11:01:35.497] List of future strategies:
[11:01:35.497] 1. sequential:
[11:01:35.497]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.497]    - tweaked: FALSE
[11:01:35.497]    - call: NULL
[11:01:35.497] plan(): nbrOfWorkers() = 1
[11:01:35.499] plan(): Setting new future strategy stack:
[11:01:35.499] List of future strategies:
[11:01:35.499] 1. sequential:
[11:01:35.499]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.499]    - tweaked: FALSE
[11:01:35.499]    - call: plan(strategy)
[11:01:35.499] plan(): nbrOfWorkers() = 1
[11:01:35.499] SequentialFuture started (and completed)
[11:01:35.500] - Launch lazy future ... done
[11:01:35.500] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[11:01:35.504] getGlobalsAndPackages() ...
[11:01:35.504] Searching for globals...
[11:01:35.505] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[11:01:35.505] Searching for globals ... DONE
[11:01:35.505] Resolving globals: FALSE
[11:01:35.506] The total size of the 2 globals is 401 bytes (401 bytes)
[11:01:35.506] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[11:01:35.506] - globals: [2] ‘weight’, ‘group’
[11:01:35.506] - packages: [1] ‘stats’
[11:01:35.507] getGlobalsAndPackages() ... DONE
[11:01:35.507] run() for ‘Future’ ...
[11:01:35.507] - state: ‘created’
[11:01:35.507] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:35.507] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:35.507] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:35.507]   - Field: ‘label’
[11:01:35.507]   - Field: ‘local’
[11:01:35.508]   - Field: ‘owner’
[11:01:35.508]   - Field: ‘envir’
[11:01:35.508]   - Field: ‘packages’
[11:01:35.508]   - Field: ‘gc’
[11:01:35.508]   - Field: ‘conditions’
[11:01:35.508]   - Field: ‘expr’
[11:01:35.508]   - Field: ‘uuid’
[11:01:35.508]   - Field: ‘seed’
[11:01:35.508]   - Field: ‘version’
[11:01:35.508]   - Field: ‘result’
[11:01:35.508]   - Field: ‘asynchronous’
[11:01:35.508]   - Field: ‘calls’
[11:01:35.509]   - Field: ‘globals’
[11:01:35.509]   - Field: ‘stdout’
[11:01:35.509]   - Field: ‘earlySignal’
[11:01:35.509]   - Field: ‘lazy’
[11:01:35.509]   - Field: ‘state’
[11:01:35.509] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:35.509] - Launch lazy future ...
[11:01:35.509] Packages needed by the future expression (n = 1): ‘stats’
[11:01:35.509] Packages needed by future strategies (n = 0): <none>
[11:01:35.510] {
[11:01:35.510]     {
[11:01:35.510]         {
[11:01:35.510]             ...future.startTime <- base::Sys.time()
[11:01:35.510]             {
[11:01:35.510]                 {
[11:01:35.510]                   {
[11:01:35.510]                     {
[11:01:35.510]                       base::local({
[11:01:35.510]                         has_future <- base::requireNamespace("future", 
[11:01:35.510]                           quietly = TRUE)
[11:01:35.510]                         if (has_future) {
[11:01:35.510]                           ns <- base::getNamespace("future")
[11:01:35.510]                           version <- ns[[".package"]][["version"]]
[11:01:35.510]                           if (is.null(version)) 
[11:01:35.510]                             version <- utils::packageVersion("future")
[11:01:35.510]                         }
[11:01:35.510]                         else {
[11:01:35.510]                           version <- NULL
[11:01:35.510]                         }
[11:01:35.510]                         if (!has_future || version < "1.8.0") {
[11:01:35.510]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.510]                             "", base::R.version$version.string), 
[11:01:35.510]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:35.510]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:35.510]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.510]                               "release", "version")], collapse = " "), 
[11:01:35.510]                             hostname = base::Sys.info()[["nodename"]])
[11:01:35.510]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.510]                             info)
[11:01:35.510]                           info <- base::paste(info, collapse = "; ")
[11:01:35.510]                           if (!has_future) {
[11:01:35.510]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.510]                               info)
[11:01:35.510]                           }
[11:01:35.510]                           else {
[11:01:35.510]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.510]                               info, version)
[11:01:35.510]                           }
[11:01:35.510]                           base::stop(msg)
[11:01:35.510]                         }
[11:01:35.510]                       })
[11:01:35.510]                     }
[11:01:35.510]                     base::local({
[11:01:35.510]                       for (pkg in "stats") {
[11:01:35.510]                         base::loadNamespace(pkg)
[11:01:35.510]                         base::library(pkg, character.only = TRUE)
[11:01:35.510]                       }
[11:01:35.510]                     })
[11:01:35.510]                   }
[11:01:35.510]                   ...future.strategy.old <- future::plan("list")
[11:01:35.510]                   options(future.plan = NULL)
[11:01:35.510]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.510]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.510]                 }
[11:01:35.510]                 ...future.workdir <- getwd()
[11:01:35.510]             }
[11:01:35.510]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.510]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.510]         }
[11:01:35.510]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.510]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.510]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.510]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.510]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.510]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.510]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.510]             base::names(...future.oldOptions))
[11:01:35.510]     }
[11:01:35.510]     if (FALSE) {
[11:01:35.510]     }
[11:01:35.510]     else {
[11:01:35.510]         if (TRUE) {
[11:01:35.510]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.510]                 open = "w")
[11:01:35.510]         }
[11:01:35.510]         else {
[11:01:35.510]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.510]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.510]         }
[11:01:35.510]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.510]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.510]             base::sink(type = "output", split = FALSE)
[11:01:35.510]             base::close(...future.stdout)
[11:01:35.510]         }, add = TRUE)
[11:01:35.510]     }
[11:01:35.510]     ...future.frame <- base::sys.nframe()
[11:01:35.510]     ...future.conditions <- base::list()
[11:01:35.510]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.510]     if (FALSE) {
[11:01:35.510]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.510]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.510]     }
[11:01:35.510]     ...future.result <- base::tryCatch({
[11:01:35.510]         base::withCallingHandlers({
[11:01:35.510]             ...future.value <- base::withVisible(base::local({
[11:01:35.510]                 lm(weight ~ group - 1)
[11:01:35.510]             }))
[11:01:35.510]             future::FutureResult(value = ...future.value$value, 
[11:01:35.510]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.510]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.510]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.510]                     ...future.globalenv.names))
[11:01:35.510]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.510]         }, condition = base::local({
[11:01:35.510]             c <- base::c
[11:01:35.510]             inherits <- base::inherits
[11:01:35.510]             invokeRestart <- base::invokeRestart
[11:01:35.510]             length <- base::length
[11:01:35.510]             list <- base::list
[11:01:35.510]             seq.int <- base::seq.int
[11:01:35.510]             signalCondition <- base::signalCondition
[11:01:35.510]             sys.calls <- base::sys.calls
[11:01:35.510]             `[[` <- base::`[[`
[11:01:35.510]             `+` <- base::`+`
[11:01:35.510]             `<<-` <- base::`<<-`
[11:01:35.510]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.510]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.510]                   3L)]
[11:01:35.510]             }
[11:01:35.510]             function(cond) {
[11:01:35.510]                 is_error <- inherits(cond, "error")
[11:01:35.510]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.510]                   NULL)
[11:01:35.510]                 if (is_error) {
[11:01:35.510]                   sessionInformation <- function() {
[11:01:35.510]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.510]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.510]                       search = base::search(), system = base::Sys.info())
[11:01:35.510]                   }
[11:01:35.510]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.510]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.510]                     cond$call), session = sessionInformation(), 
[11:01:35.510]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.510]                   signalCondition(cond)
[11:01:35.510]                 }
[11:01:35.510]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.510]                 "immediateCondition"))) {
[11:01:35.510]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.510]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.510]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.510]                   if (TRUE && !signal) {
[11:01:35.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.510]                     {
[11:01:35.510]                       inherits <- base::inherits
[11:01:35.510]                       invokeRestart <- base::invokeRestart
[11:01:35.510]                       is.null <- base::is.null
[11:01:35.510]                       muffled <- FALSE
[11:01:35.510]                       if (inherits(cond, "message")) {
[11:01:35.510]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.510]                         if (muffled) 
[11:01:35.510]                           invokeRestart("muffleMessage")
[11:01:35.510]                       }
[11:01:35.510]                       else if (inherits(cond, "warning")) {
[11:01:35.510]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.510]                         if (muffled) 
[11:01:35.510]                           invokeRestart("muffleWarning")
[11:01:35.510]                       }
[11:01:35.510]                       else if (inherits(cond, "condition")) {
[11:01:35.510]                         if (!is.null(pattern)) {
[11:01:35.510]                           computeRestarts <- base::computeRestarts
[11:01:35.510]                           grepl <- base::grepl
[11:01:35.510]                           restarts <- computeRestarts(cond)
[11:01:35.510]                           for (restart in restarts) {
[11:01:35.510]                             name <- restart$name
[11:01:35.510]                             if (is.null(name)) 
[11:01:35.510]                               next
[11:01:35.510]                             if (!grepl(pattern, name)) 
[11:01:35.510]                               next
[11:01:35.510]                             invokeRestart(restart)
[11:01:35.510]                             muffled <- TRUE
[11:01:35.510]                             break
[11:01:35.510]                           }
[11:01:35.510]                         }
[11:01:35.510]                       }
[11:01:35.510]                       invisible(muffled)
[11:01:35.510]                     }
[11:01:35.510]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.510]                   }
[11:01:35.510]                 }
[11:01:35.510]                 else {
[11:01:35.510]                   if (TRUE) {
[11:01:35.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.510]                     {
[11:01:35.510]                       inherits <- base::inherits
[11:01:35.510]                       invokeRestart <- base::invokeRestart
[11:01:35.510]                       is.null <- base::is.null
[11:01:35.510]                       muffled <- FALSE
[11:01:35.510]                       if (inherits(cond, "message")) {
[11:01:35.510]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.510]                         if (muffled) 
[11:01:35.510]                           invokeRestart("muffleMessage")
[11:01:35.510]                       }
[11:01:35.510]                       else if (inherits(cond, "warning")) {
[11:01:35.510]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.510]                         if (muffled) 
[11:01:35.510]                           invokeRestart("muffleWarning")
[11:01:35.510]                       }
[11:01:35.510]                       else if (inherits(cond, "condition")) {
[11:01:35.510]                         if (!is.null(pattern)) {
[11:01:35.510]                           computeRestarts <- base::computeRestarts
[11:01:35.510]                           grepl <- base::grepl
[11:01:35.510]                           restarts <- computeRestarts(cond)
[11:01:35.510]                           for (restart in restarts) {
[11:01:35.510]                             name <- restart$name
[11:01:35.510]                             if (is.null(name)) 
[11:01:35.510]                               next
[11:01:35.510]                             if (!grepl(pattern, name)) 
[11:01:35.510]                               next
[11:01:35.510]                             invokeRestart(restart)
[11:01:35.510]                             muffled <- TRUE
[11:01:35.510]                             break
[11:01:35.510]                           }
[11:01:35.510]                         }
[11:01:35.510]                       }
[11:01:35.510]                       invisible(muffled)
[11:01:35.510]                     }
[11:01:35.510]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.510]                   }
[11:01:35.510]                 }
[11:01:35.510]             }
[11:01:35.510]         }))
[11:01:35.510]     }, error = function(ex) {
[11:01:35.510]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.510]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.510]                 ...future.rng), started = ...future.startTime, 
[11:01:35.510]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.510]             version = "1.8"), class = "FutureResult")
[11:01:35.510]     }, finally = {
[11:01:35.510]         if (!identical(...future.workdir, getwd())) 
[11:01:35.510]             setwd(...future.workdir)
[11:01:35.510]         {
[11:01:35.510]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.510]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.510]             }
[11:01:35.510]             base::options(...future.oldOptions)
[11:01:35.510]             if (.Platform$OS.type == "windows") {
[11:01:35.510]                 old_names <- names(...future.oldEnvVars)
[11:01:35.510]                 envs <- base::Sys.getenv()
[11:01:35.510]                 names <- names(envs)
[11:01:35.510]                 common <- intersect(names, old_names)
[11:01:35.510]                 added <- setdiff(names, old_names)
[11:01:35.510]                 removed <- setdiff(old_names, names)
[11:01:35.510]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.510]                   envs[common]]
[11:01:35.510]                 NAMES <- toupper(changed)
[11:01:35.510]                 args <- list()
[11:01:35.510]                 for (kk in seq_along(NAMES)) {
[11:01:35.510]                   name <- changed[[kk]]
[11:01:35.510]                   NAME <- NAMES[[kk]]
[11:01:35.510]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.510]                     next
[11:01:35.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.510]                 }
[11:01:35.510]                 NAMES <- toupper(added)
[11:01:35.510]                 for (kk in seq_along(NAMES)) {
[11:01:35.510]                   name <- added[[kk]]
[11:01:35.510]                   NAME <- NAMES[[kk]]
[11:01:35.510]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.510]                     next
[11:01:35.510]                   args[[name]] <- ""
[11:01:35.510]                 }
[11:01:35.510]                 NAMES <- toupper(removed)
[11:01:35.510]                 for (kk in seq_along(NAMES)) {
[11:01:35.510]                   name <- removed[[kk]]
[11:01:35.510]                   NAME <- NAMES[[kk]]
[11:01:35.510]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.510]                     next
[11:01:35.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.510]                 }
[11:01:35.510]                 if (length(args) > 0) 
[11:01:35.510]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.510]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.510]             }
[11:01:35.510]             else {
[11:01:35.510]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.510]             }
[11:01:35.510]             {
[11:01:35.510]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.510]                   0L) {
[11:01:35.510]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.510]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.510]                   base::options(opts)
[11:01:35.510]                 }
[11:01:35.510]                 {
[11:01:35.510]                   {
[11:01:35.510]                     NULL
[11:01:35.510]                     RNGkind("Mersenne-Twister")
[11:01:35.510]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:35.510]                       inherits = FALSE)
[11:01:35.510]                   }
[11:01:35.510]                   options(future.plan = NULL)
[11:01:35.510]                   if (is.na(NA_character_)) 
[11:01:35.510]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.510]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.510]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.510]                     .init = FALSE)
[11:01:35.510]                 }
[11:01:35.510]             }
[11:01:35.510]         }
[11:01:35.510]     })
[11:01:35.510]     if (TRUE) {
[11:01:35.510]         base::sink(type = "output", split = FALSE)
[11:01:35.510]         if (TRUE) {
[11:01:35.510]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.510]         }
[11:01:35.510]         else {
[11:01:35.510]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.510]         }
[11:01:35.510]         base::close(...future.stdout)
[11:01:35.510]         ...future.stdout <- NULL
[11:01:35.510]     }
[11:01:35.510]     ...future.result$conditions <- ...future.conditions
[11:01:35.510]     ...future.result$finished <- base::Sys.time()
[11:01:35.510]     ...future.result
[11:01:35.510] }
[11:01:35.511] assign_globals() ...
[11:01:35.511] List of 2
[11:01:35.511]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[11:01:35.511]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[11:01:35.511]  - attr(*, "where")=List of 2
[11:01:35.511]   ..$ weight:<environment: R_EmptyEnv> 
[11:01:35.511]   ..$ group :<environment: R_EmptyEnv> 
[11:01:35.511]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:35.511]  - attr(*, "resolved")= logi FALSE
[11:01:35.511]  - attr(*, "total_size")= num 401
[11:01:35.511]  - attr(*, "already-done")= logi TRUE
[11:01:35.514] - copied ‘weight’ to environment
[11:01:35.514] - copied ‘group’ to environment
[11:01:35.514] assign_globals() ... done
[11:01:35.515] plan(): Setting new future strategy stack:
[11:01:35.515] List of future strategies:
[11:01:35.515] 1. sequential:
[11:01:35.515]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.515]    - tweaked: FALSE
[11:01:35.515]    - call: NULL
[11:01:35.515] plan(): nbrOfWorkers() = 1
[11:01:35.517] plan(): Setting new future strategy stack:
[11:01:35.517] List of future strategies:
[11:01:35.517] 1. sequential:
[11:01:35.517]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.517]    - tweaked: FALSE
[11:01:35.517]    - call: plan(strategy)
[11:01:35.517] plan(): nbrOfWorkers() = 1
[11:01:35.517] SequentialFuture started (and completed)
[11:01:35.518] - Launch lazy future ... done
[11:01:35.518] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[11:01:35.520] getGlobalsAndPackages() ...
[11:01:35.520] Searching for globals...
[11:01:35.521] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[11:01:35.521] Searching for globals ... DONE
[11:01:35.521] Resolving globals: FALSE
[11:01:35.522] The total size of the 2 globals is 401 bytes (401 bytes)
[11:01:35.522] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[11:01:35.522] - globals: [2] ‘weight’, ‘group’
[11:01:35.522] - packages: [1] ‘stats’
[11:01:35.522] getGlobalsAndPackages() ... DONE
[11:01:35.523] run() for ‘Future’ ...
[11:01:35.523] - state: ‘created’
[11:01:35.523] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:35.523] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:35.523] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:35.523]   - Field: ‘label’
[11:01:35.523]   - Field: ‘local’
[11:01:35.523]   - Field: ‘owner’
[11:01:35.524]   - Field: ‘envir’
[11:01:35.524]   - Field: ‘packages’
[11:01:35.524]   - Field: ‘gc’
[11:01:35.524]   - Field: ‘conditions’
[11:01:35.524]   - Field: ‘expr’
[11:01:35.524]   - Field: ‘uuid’
[11:01:35.524]   - Field: ‘seed’
[11:01:35.524]   - Field: ‘version’
[11:01:35.524]   - Field: ‘result’
[11:01:35.524]   - Field: ‘asynchronous’
[11:01:35.524]   - Field: ‘calls’
[11:01:35.524]   - Field: ‘globals’
[11:01:35.525]   - Field: ‘stdout’
[11:01:35.525]   - Field: ‘earlySignal’
[11:01:35.525]   - Field: ‘lazy’
[11:01:35.525]   - Field: ‘state’
[11:01:35.525] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:35.525] - Launch lazy future ...
[11:01:35.525] Packages needed by the future expression (n = 1): ‘stats’
[11:01:35.525] Packages needed by future strategies (n = 0): <none>
[11:01:35.527] {
[11:01:35.527]     {
[11:01:35.527]         {
[11:01:35.527]             ...future.startTime <- base::Sys.time()
[11:01:35.527]             {
[11:01:35.527]                 {
[11:01:35.527]                   {
[11:01:35.527]                     {
[11:01:35.527]                       base::local({
[11:01:35.527]                         has_future <- base::requireNamespace("future", 
[11:01:35.527]                           quietly = TRUE)
[11:01:35.527]                         if (has_future) {
[11:01:35.527]                           ns <- base::getNamespace("future")
[11:01:35.527]                           version <- ns[[".package"]][["version"]]
[11:01:35.527]                           if (is.null(version)) 
[11:01:35.527]                             version <- utils::packageVersion("future")
[11:01:35.527]                         }
[11:01:35.527]                         else {
[11:01:35.527]                           version <- NULL
[11:01:35.527]                         }
[11:01:35.527]                         if (!has_future || version < "1.8.0") {
[11:01:35.527]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.527]                             "", base::R.version$version.string), 
[11:01:35.527]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:35.527]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:35.527]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.527]                               "release", "version")], collapse = " "), 
[11:01:35.527]                             hostname = base::Sys.info()[["nodename"]])
[11:01:35.527]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.527]                             info)
[11:01:35.527]                           info <- base::paste(info, collapse = "; ")
[11:01:35.527]                           if (!has_future) {
[11:01:35.527]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.527]                               info)
[11:01:35.527]                           }
[11:01:35.527]                           else {
[11:01:35.527]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.527]                               info, version)
[11:01:35.527]                           }
[11:01:35.527]                           base::stop(msg)
[11:01:35.527]                         }
[11:01:35.527]                       })
[11:01:35.527]                     }
[11:01:35.527]                     base::local({
[11:01:35.527]                       for (pkg in "stats") {
[11:01:35.527]                         base::loadNamespace(pkg)
[11:01:35.527]                         base::library(pkg, character.only = TRUE)
[11:01:35.527]                       }
[11:01:35.527]                     })
[11:01:35.527]                   }
[11:01:35.527]                   ...future.strategy.old <- future::plan("list")
[11:01:35.527]                   options(future.plan = NULL)
[11:01:35.527]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.527]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.527]                 }
[11:01:35.527]                 ...future.workdir <- getwd()
[11:01:35.527]             }
[11:01:35.527]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.527]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.527]         }
[11:01:35.527]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.527]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.527]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.527]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.527]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.527]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.527]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.527]             base::names(...future.oldOptions))
[11:01:35.527]     }
[11:01:35.527]     if (FALSE) {
[11:01:35.527]     }
[11:01:35.527]     else {
[11:01:35.527]         if (TRUE) {
[11:01:35.527]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.527]                 open = "w")
[11:01:35.527]         }
[11:01:35.527]         else {
[11:01:35.527]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.527]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.527]         }
[11:01:35.527]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.527]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.527]             base::sink(type = "output", split = FALSE)
[11:01:35.527]             base::close(...future.stdout)
[11:01:35.527]         }, add = TRUE)
[11:01:35.527]     }
[11:01:35.527]     ...future.frame <- base::sys.nframe()
[11:01:35.527]     ...future.conditions <- base::list()
[11:01:35.527]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.527]     if (FALSE) {
[11:01:35.527]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.527]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.527]     }
[11:01:35.527]     ...future.result <- base::tryCatch({
[11:01:35.527]         base::withCallingHandlers({
[11:01:35.527]             ...future.value <- base::withVisible(base::local({
[11:01:35.527]                 lm(weight ~ group - 1)
[11:01:35.527]             }))
[11:01:35.527]             future::FutureResult(value = ...future.value$value, 
[11:01:35.527]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.527]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.527]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.527]                     ...future.globalenv.names))
[11:01:35.527]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.527]         }, condition = base::local({
[11:01:35.527]             c <- base::c
[11:01:35.527]             inherits <- base::inherits
[11:01:35.527]             invokeRestart <- base::invokeRestart
[11:01:35.527]             length <- base::length
[11:01:35.527]             list <- base::list
[11:01:35.527]             seq.int <- base::seq.int
[11:01:35.527]             signalCondition <- base::signalCondition
[11:01:35.527]             sys.calls <- base::sys.calls
[11:01:35.527]             `[[` <- base::`[[`
[11:01:35.527]             `+` <- base::`+`
[11:01:35.527]             `<<-` <- base::`<<-`
[11:01:35.527]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.527]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.527]                   3L)]
[11:01:35.527]             }
[11:01:35.527]             function(cond) {
[11:01:35.527]                 is_error <- inherits(cond, "error")
[11:01:35.527]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.527]                   NULL)
[11:01:35.527]                 if (is_error) {
[11:01:35.527]                   sessionInformation <- function() {
[11:01:35.527]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.527]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.527]                       search = base::search(), system = base::Sys.info())
[11:01:35.527]                   }
[11:01:35.527]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.527]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.527]                     cond$call), session = sessionInformation(), 
[11:01:35.527]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.527]                   signalCondition(cond)
[11:01:35.527]                 }
[11:01:35.527]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.527]                 "immediateCondition"))) {
[11:01:35.527]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.527]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.527]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.527]                   if (TRUE && !signal) {
[11:01:35.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.527]                     {
[11:01:35.527]                       inherits <- base::inherits
[11:01:35.527]                       invokeRestart <- base::invokeRestart
[11:01:35.527]                       is.null <- base::is.null
[11:01:35.527]                       muffled <- FALSE
[11:01:35.527]                       if (inherits(cond, "message")) {
[11:01:35.527]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.527]                         if (muffled) 
[11:01:35.527]                           invokeRestart("muffleMessage")
[11:01:35.527]                       }
[11:01:35.527]                       else if (inherits(cond, "warning")) {
[11:01:35.527]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.527]                         if (muffled) 
[11:01:35.527]                           invokeRestart("muffleWarning")
[11:01:35.527]                       }
[11:01:35.527]                       else if (inherits(cond, "condition")) {
[11:01:35.527]                         if (!is.null(pattern)) {
[11:01:35.527]                           computeRestarts <- base::computeRestarts
[11:01:35.527]                           grepl <- base::grepl
[11:01:35.527]                           restarts <- computeRestarts(cond)
[11:01:35.527]                           for (restart in restarts) {
[11:01:35.527]                             name <- restart$name
[11:01:35.527]                             if (is.null(name)) 
[11:01:35.527]                               next
[11:01:35.527]                             if (!grepl(pattern, name)) 
[11:01:35.527]                               next
[11:01:35.527]                             invokeRestart(restart)
[11:01:35.527]                             muffled <- TRUE
[11:01:35.527]                             break
[11:01:35.527]                           }
[11:01:35.527]                         }
[11:01:35.527]                       }
[11:01:35.527]                       invisible(muffled)
[11:01:35.527]                     }
[11:01:35.527]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.527]                   }
[11:01:35.527]                 }
[11:01:35.527]                 else {
[11:01:35.527]                   if (TRUE) {
[11:01:35.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.527]                     {
[11:01:35.527]                       inherits <- base::inherits
[11:01:35.527]                       invokeRestart <- base::invokeRestart
[11:01:35.527]                       is.null <- base::is.null
[11:01:35.527]                       muffled <- FALSE
[11:01:35.527]                       if (inherits(cond, "message")) {
[11:01:35.527]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.527]                         if (muffled) 
[11:01:35.527]                           invokeRestart("muffleMessage")
[11:01:35.527]                       }
[11:01:35.527]                       else if (inherits(cond, "warning")) {
[11:01:35.527]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.527]                         if (muffled) 
[11:01:35.527]                           invokeRestart("muffleWarning")
[11:01:35.527]                       }
[11:01:35.527]                       else if (inherits(cond, "condition")) {
[11:01:35.527]                         if (!is.null(pattern)) {
[11:01:35.527]                           computeRestarts <- base::computeRestarts
[11:01:35.527]                           grepl <- base::grepl
[11:01:35.527]                           restarts <- computeRestarts(cond)
[11:01:35.527]                           for (restart in restarts) {
[11:01:35.527]                             name <- restart$name
[11:01:35.527]                             if (is.null(name)) 
[11:01:35.527]                               next
[11:01:35.527]                             if (!grepl(pattern, name)) 
[11:01:35.527]                               next
[11:01:35.527]                             invokeRestart(restart)
[11:01:35.527]                             muffled <- TRUE
[11:01:35.527]                             break
[11:01:35.527]                           }
[11:01:35.527]                         }
[11:01:35.527]                       }
[11:01:35.527]                       invisible(muffled)
[11:01:35.527]                     }
[11:01:35.527]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.527]                   }
[11:01:35.527]                 }
[11:01:35.527]             }
[11:01:35.527]         }))
[11:01:35.527]     }, error = function(ex) {
[11:01:35.527]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.527]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.527]                 ...future.rng), started = ...future.startTime, 
[11:01:35.527]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.527]             version = "1.8"), class = "FutureResult")
[11:01:35.527]     }, finally = {
[11:01:35.527]         if (!identical(...future.workdir, getwd())) 
[11:01:35.527]             setwd(...future.workdir)
[11:01:35.527]         {
[11:01:35.527]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.527]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.527]             }
[11:01:35.527]             base::options(...future.oldOptions)
[11:01:35.527]             if (.Platform$OS.type == "windows") {
[11:01:35.527]                 old_names <- names(...future.oldEnvVars)
[11:01:35.527]                 envs <- base::Sys.getenv()
[11:01:35.527]                 names <- names(envs)
[11:01:35.527]                 common <- intersect(names, old_names)
[11:01:35.527]                 added <- setdiff(names, old_names)
[11:01:35.527]                 removed <- setdiff(old_names, names)
[11:01:35.527]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.527]                   envs[common]]
[11:01:35.527]                 NAMES <- toupper(changed)
[11:01:35.527]                 args <- list()
[11:01:35.527]                 for (kk in seq_along(NAMES)) {
[11:01:35.527]                   name <- changed[[kk]]
[11:01:35.527]                   NAME <- NAMES[[kk]]
[11:01:35.527]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.527]                     next
[11:01:35.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.527]                 }
[11:01:35.527]                 NAMES <- toupper(added)
[11:01:35.527]                 for (kk in seq_along(NAMES)) {
[11:01:35.527]                   name <- added[[kk]]
[11:01:35.527]                   NAME <- NAMES[[kk]]
[11:01:35.527]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.527]                     next
[11:01:35.527]                   args[[name]] <- ""
[11:01:35.527]                 }
[11:01:35.527]                 NAMES <- toupper(removed)
[11:01:35.527]                 for (kk in seq_along(NAMES)) {
[11:01:35.527]                   name <- removed[[kk]]
[11:01:35.527]                   NAME <- NAMES[[kk]]
[11:01:35.527]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.527]                     next
[11:01:35.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.527]                 }
[11:01:35.527]                 if (length(args) > 0) 
[11:01:35.527]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.527]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.527]             }
[11:01:35.527]             else {
[11:01:35.527]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.527]             }
[11:01:35.527]             {
[11:01:35.527]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.527]                   0L) {
[11:01:35.527]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.527]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.527]                   base::options(opts)
[11:01:35.527]                 }
[11:01:35.527]                 {
[11:01:35.527]                   {
[11:01:35.527]                     NULL
[11:01:35.527]                     RNGkind("Mersenne-Twister")
[11:01:35.527]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:35.527]                       inherits = FALSE)
[11:01:35.527]                   }
[11:01:35.527]                   options(future.plan = NULL)
[11:01:35.527]                   if (is.na(NA_character_)) 
[11:01:35.527]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.527]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.527]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.527]                     .init = FALSE)
[11:01:35.527]                 }
[11:01:35.527]             }
[11:01:35.527]         }
[11:01:35.527]     })
[11:01:35.527]     if (TRUE) {
[11:01:35.527]         base::sink(type = "output", split = FALSE)
[11:01:35.527]         if (TRUE) {
[11:01:35.527]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.527]         }
[11:01:35.527]         else {
[11:01:35.527]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.527]         }
[11:01:35.527]         base::close(...future.stdout)
[11:01:35.527]         ...future.stdout <- NULL
[11:01:35.527]     }
[11:01:35.527]     ...future.result$conditions <- ...future.conditions
[11:01:35.527]     ...future.result$finished <- base::Sys.time()
[11:01:35.527]     ...future.result
[11:01:35.527] }
[11:01:35.528] assign_globals() ...
[11:01:35.528] List of 2
[11:01:35.528]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[11:01:35.528]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[11:01:35.528]  - attr(*, "where")=List of 2
[11:01:35.528]   ..$ weight:<environment: R_EmptyEnv> 
[11:01:35.528]   ..$ group :<environment: R_EmptyEnv> 
[11:01:35.528]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:35.528]  - attr(*, "resolved")= logi FALSE
[11:01:35.528]  - attr(*, "total_size")= num 401
[11:01:35.528]  - attr(*, "already-done")= logi TRUE
[11:01:35.531] - copied ‘weight’ to environment
[11:01:35.531] - copied ‘group’ to environment
[11:01:35.531] assign_globals() ... done
[11:01:35.532] plan(): Setting new future strategy stack:
[11:01:35.532] List of future strategies:
[11:01:35.532] 1. sequential:
[11:01:35.532]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.532]    - tweaked: FALSE
[11:01:35.532]    - call: NULL
[11:01:35.532] plan(): nbrOfWorkers() = 1
[11:01:35.534] plan(): Setting new future strategy stack:
[11:01:35.534] List of future strategies:
[11:01:35.534] 1. sequential:
[11:01:35.534]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.534]    - tweaked: FALSE
[11:01:35.534]    - call: plan(strategy)
[11:01:35.534] plan(): nbrOfWorkers() = 1
[11:01:35.534] SequentialFuture started (and completed)
[11:01:35.534] - Launch lazy future ... done
[11:01:35.534] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[11:01:35.536] getGlobalsAndPackages() ...
[11:01:35.536] Searching for globals...
[11:01:35.537] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[11:01:35.538] Searching for globals ... DONE
[11:01:35.538] Resolving globals: FALSE
[11:01:35.538] The total size of the 2 globals is 401 bytes (401 bytes)
[11:01:35.538] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[11:01:35.539] - globals: [2] ‘weight’, ‘group’
[11:01:35.539] - packages: [1] ‘stats’
[11:01:35.539] getGlobalsAndPackages() ... DONE
[11:01:35.539] run() for ‘Future’ ...
[11:01:35.539] - state: ‘created’
[11:01:35.539] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:35.539] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:35.540] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:35.540]   - Field: ‘label’
[11:01:35.540]   - Field: ‘local’
[11:01:35.540]   - Field: ‘owner’
[11:01:35.540]   - Field: ‘envir’
[11:01:35.540]   - Field: ‘packages’
[11:01:35.540]   - Field: ‘gc’
[11:01:35.540]   - Field: ‘conditions’
[11:01:35.540]   - Field: ‘expr’
[11:01:35.540]   - Field: ‘uuid’
[11:01:35.540]   - Field: ‘seed’
[11:01:35.540]   - Field: ‘version’
[11:01:35.540]   - Field: ‘result’
[11:01:35.541]   - Field: ‘asynchronous’
[11:01:35.541]   - Field: ‘calls’
[11:01:35.541]   - Field: ‘globals’
[11:01:35.541]   - Field: ‘stdout’
[11:01:35.541]   - Field: ‘earlySignal’
[11:01:35.541]   - Field: ‘lazy’
[11:01:35.541]   - Field: ‘state’
[11:01:35.541] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:35.541] - Launch lazy future ...
[11:01:35.541] Packages needed by the future expression (n = 1): ‘stats’
[11:01:35.541] Packages needed by future strategies (n = 0): <none>
[11:01:35.542] {
[11:01:35.542]     {
[11:01:35.542]         {
[11:01:35.542]             ...future.startTime <- base::Sys.time()
[11:01:35.542]             {
[11:01:35.542]                 {
[11:01:35.542]                   {
[11:01:35.542]                     {
[11:01:35.542]                       base::local({
[11:01:35.542]                         has_future <- base::requireNamespace("future", 
[11:01:35.542]                           quietly = TRUE)
[11:01:35.542]                         if (has_future) {
[11:01:35.542]                           ns <- base::getNamespace("future")
[11:01:35.542]                           version <- ns[[".package"]][["version"]]
[11:01:35.542]                           if (is.null(version)) 
[11:01:35.542]                             version <- utils::packageVersion("future")
[11:01:35.542]                         }
[11:01:35.542]                         else {
[11:01:35.542]                           version <- NULL
[11:01:35.542]                         }
[11:01:35.542]                         if (!has_future || version < "1.8.0") {
[11:01:35.542]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.542]                             "", base::R.version$version.string), 
[11:01:35.542]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:35.542]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:35.542]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.542]                               "release", "version")], collapse = " "), 
[11:01:35.542]                             hostname = base::Sys.info()[["nodename"]])
[11:01:35.542]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.542]                             info)
[11:01:35.542]                           info <- base::paste(info, collapse = "; ")
[11:01:35.542]                           if (!has_future) {
[11:01:35.542]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.542]                               info)
[11:01:35.542]                           }
[11:01:35.542]                           else {
[11:01:35.542]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.542]                               info, version)
[11:01:35.542]                           }
[11:01:35.542]                           base::stop(msg)
[11:01:35.542]                         }
[11:01:35.542]                       })
[11:01:35.542]                     }
[11:01:35.542]                     base::local({
[11:01:35.542]                       for (pkg in "stats") {
[11:01:35.542]                         base::loadNamespace(pkg)
[11:01:35.542]                         base::library(pkg, character.only = TRUE)
[11:01:35.542]                       }
[11:01:35.542]                     })
[11:01:35.542]                   }
[11:01:35.542]                   ...future.strategy.old <- future::plan("list")
[11:01:35.542]                   options(future.plan = NULL)
[11:01:35.542]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.542]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.542]                 }
[11:01:35.542]                 ...future.workdir <- getwd()
[11:01:35.542]             }
[11:01:35.542]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.542]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.542]         }
[11:01:35.542]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.542]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.542]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.542]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.542]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.542]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.542]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.542]             base::names(...future.oldOptions))
[11:01:35.542]     }
[11:01:35.542]     if (FALSE) {
[11:01:35.542]     }
[11:01:35.542]     else {
[11:01:35.542]         if (TRUE) {
[11:01:35.542]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.542]                 open = "w")
[11:01:35.542]         }
[11:01:35.542]         else {
[11:01:35.542]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.542]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.542]         }
[11:01:35.542]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.542]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.542]             base::sink(type = "output", split = FALSE)
[11:01:35.542]             base::close(...future.stdout)
[11:01:35.542]         }, add = TRUE)
[11:01:35.542]     }
[11:01:35.542]     ...future.frame <- base::sys.nframe()
[11:01:35.542]     ...future.conditions <- base::list()
[11:01:35.542]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.542]     if (FALSE) {
[11:01:35.542]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.542]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.542]     }
[11:01:35.542]     ...future.result <- base::tryCatch({
[11:01:35.542]         base::withCallingHandlers({
[11:01:35.542]             ...future.value <- base::withVisible(base::local({
[11:01:35.542]                 lm(weight ~ group - 1)
[11:01:35.542]             }))
[11:01:35.542]             future::FutureResult(value = ...future.value$value, 
[11:01:35.542]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.542]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.542]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.542]                     ...future.globalenv.names))
[11:01:35.542]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.542]         }, condition = base::local({
[11:01:35.542]             c <- base::c
[11:01:35.542]             inherits <- base::inherits
[11:01:35.542]             invokeRestart <- base::invokeRestart
[11:01:35.542]             length <- base::length
[11:01:35.542]             list <- base::list
[11:01:35.542]             seq.int <- base::seq.int
[11:01:35.542]             signalCondition <- base::signalCondition
[11:01:35.542]             sys.calls <- base::sys.calls
[11:01:35.542]             `[[` <- base::`[[`
[11:01:35.542]             `+` <- base::`+`
[11:01:35.542]             `<<-` <- base::`<<-`
[11:01:35.542]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.542]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.542]                   3L)]
[11:01:35.542]             }
[11:01:35.542]             function(cond) {
[11:01:35.542]                 is_error <- inherits(cond, "error")
[11:01:35.542]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.542]                   NULL)
[11:01:35.542]                 if (is_error) {
[11:01:35.542]                   sessionInformation <- function() {
[11:01:35.542]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.542]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.542]                       search = base::search(), system = base::Sys.info())
[11:01:35.542]                   }
[11:01:35.542]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.542]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.542]                     cond$call), session = sessionInformation(), 
[11:01:35.542]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.542]                   signalCondition(cond)
[11:01:35.542]                 }
[11:01:35.542]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.542]                 "immediateCondition"))) {
[11:01:35.542]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.542]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.542]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.542]                   if (TRUE && !signal) {
[11:01:35.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.542]                     {
[11:01:35.542]                       inherits <- base::inherits
[11:01:35.542]                       invokeRestart <- base::invokeRestart
[11:01:35.542]                       is.null <- base::is.null
[11:01:35.542]                       muffled <- FALSE
[11:01:35.542]                       if (inherits(cond, "message")) {
[11:01:35.542]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.542]                         if (muffled) 
[11:01:35.542]                           invokeRestart("muffleMessage")
[11:01:35.542]                       }
[11:01:35.542]                       else if (inherits(cond, "warning")) {
[11:01:35.542]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.542]                         if (muffled) 
[11:01:35.542]                           invokeRestart("muffleWarning")
[11:01:35.542]                       }
[11:01:35.542]                       else if (inherits(cond, "condition")) {
[11:01:35.542]                         if (!is.null(pattern)) {
[11:01:35.542]                           computeRestarts <- base::computeRestarts
[11:01:35.542]                           grepl <- base::grepl
[11:01:35.542]                           restarts <- computeRestarts(cond)
[11:01:35.542]                           for (restart in restarts) {
[11:01:35.542]                             name <- restart$name
[11:01:35.542]                             if (is.null(name)) 
[11:01:35.542]                               next
[11:01:35.542]                             if (!grepl(pattern, name)) 
[11:01:35.542]                               next
[11:01:35.542]                             invokeRestart(restart)
[11:01:35.542]                             muffled <- TRUE
[11:01:35.542]                             break
[11:01:35.542]                           }
[11:01:35.542]                         }
[11:01:35.542]                       }
[11:01:35.542]                       invisible(muffled)
[11:01:35.542]                     }
[11:01:35.542]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.542]                   }
[11:01:35.542]                 }
[11:01:35.542]                 else {
[11:01:35.542]                   if (TRUE) {
[11:01:35.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.542]                     {
[11:01:35.542]                       inherits <- base::inherits
[11:01:35.542]                       invokeRestart <- base::invokeRestart
[11:01:35.542]                       is.null <- base::is.null
[11:01:35.542]                       muffled <- FALSE
[11:01:35.542]                       if (inherits(cond, "message")) {
[11:01:35.542]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.542]                         if (muffled) 
[11:01:35.542]                           invokeRestart("muffleMessage")
[11:01:35.542]                       }
[11:01:35.542]                       else if (inherits(cond, "warning")) {
[11:01:35.542]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.542]                         if (muffled) 
[11:01:35.542]                           invokeRestart("muffleWarning")
[11:01:35.542]                       }
[11:01:35.542]                       else if (inherits(cond, "condition")) {
[11:01:35.542]                         if (!is.null(pattern)) {
[11:01:35.542]                           computeRestarts <- base::computeRestarts
[11:01:35.542]                           grepl <- base::grepl
[11:01:35.542]                           restarts <- computeRestarts(cond)
[11:01:35.542]                           for (restart in restarts) {
[11:01:35.542]                             name <- restart$name
[11:01:35.542]                             if (is.null(name)) 
[11:01:35.542]                               next
[11:01:35.542]                             if (!grepl(pattern, name)) 
[11:01:35.542]                               next
[11:01:35.542]                             invokeRestart(restart)
[11:01:35.542]                             muffled <- TRUE
[11:01:35.542]                             break
[11:01:35.542]                           }
[11:01:35.542]                         }
[11:01:35.542]                       }
[11:01:35.542]                       invisible(muffled)
[11:01:35.542]                     }
[11:01:35.542]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.542]                   }
[11:01:35.542]                 }
[11:01:35.542]             }
[11:01:35.542]         }))
[11:01:35.542]     }, error = function(ex) {
[11:01:35.542]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.542]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.542]                 ...future.rng), started = ...future.startTime, 
[11:01:35.542]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.542]             version = "1.8"), class = "FutureResult")
[11:01:35.542]     }, finally = {
[11:01:35.542]         if (!identical(...future.workdir, getwd())) 
[11:01:35.542]             setwd(...future.workdir)
[11:01:35.542]         {
[11:01:35.542]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.542]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.542]             }
[11:01:35.542]             base::options(...future.oldOptions)
[11:01:35.542]             if (.Platform$OS.type == "windows") {
[11:01:35.542]                 old_names <- names(...future.oldEnvVars)
[11:01:35.542]                 envs <- base::Sys.getenv()
[11:01:35.542]                 names <- names(envs)
[11:01:35.542]                 common <- intersect(names, old_names)
[11:01:35.542]                 added <- setdiff(names, old_names)
[11:01:35.542]                 removed <- setdiff(old_names, names)
[11:01:35.542]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.542]                   envs[common]]
[11:01:35.542]                 NAMES <- toupper(changed)
[11:01:35.542]                 args <- list()
[11:01:35.542]                 for (kk in seq_along(NAMES)) {
[11:01:35.542]                   name <- changed[[kk]]
[11:01:35.542]                   NAME <- NAMES[[kk]]
[11:01:35.542]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.542]                     next
[11:01:35.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.542]                 }
[11:01:35.542]                 NAMES <- toupper(added)
[11:01:35.542]                 for (kk in seq_along(NAMES)) {
[11:01:35.542]                   name <- added[[kk]]
[11:01:35.542]                   NAME <- NAMES[[kk]]
[11:01:35.542]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.542]                     next
[11:01:35.542]                   args[[name]] <- ""
[11:01:35.542]                 }
[11:01:35.542]                 NAMES <- toupper(removed)
[11:01:35.542]                 for (kk in seq_along(NAMES)) {
[11:01:35.542]                   name <- removed[[kk]]
[11:01:35.542]                   NAME <- NAMES[[kk]]
[11:01:35.542]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.542]                     next
[11:01:35.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.542]                 }
[11:01:35.542]                 if (length(args) > 0) 
[11:01:35.542]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.542]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.542]             }
[11:01:35.542]             else {
[11:01:35.542]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.542]             }
[11:01:35.542]             {
[11:01:35.542]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.542]                   0L) {
[11:01:35.542]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.542]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.542]                   base::options(opts)
[11:01:35.542]                 }
[11:01:35.542]                 {
[11:01:35.542]                   {
[11:01:35.542]                     NULL
[11:01:35.542]                     RNGkind("Mersenne-Twister")
[11:01:35.542]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:35.542]                       inherits = FALSE)
[11:01:35.542]                   }
[11:01:35.542]                   options(future.plan = NULL)
[11:01:35.542]                   if (is.na(NA_character_)) 
[11:01:35.542]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.542]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.542]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.542]                     .init = FALSE)
[11:01:35.542]                 }
[11:01:35.542]             }
[11:01:35.542]         }
[11:01:35.542]     })
[11:01:35.542]     if (TRUE) {
[11:01:35.542]         base::sink(type = "output", split = FALSE)
[11:01:35.542]         if (TRUE) {
[11:01:35.542]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.542]         }
[11:01:35.542]         else {
[11:01:35.542]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.542]         }
[11:01:35.542]         base::close(...future.stdout)
[11:01:35.542]         ...future.stdout <- NULL
[11:01:35.542]     }
[11:01:35.542]     ...future.result$conditions <- ...future.conditions
[11:01:35.542]     ...future.result$finished <- base::Sys.time()
[11:01:35.542]     ...future.result
[11:01:35.542] }
[11:01:35.544] assign_globals() ...
[11:01:35.544] List of 2
[11:01:35.544]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[11:01:35.544]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[11:01:35.544]  - attr(*, "where")=List of 2
[11:01:35.544]   ..$ weight:<environment: R_EmptyEnv> 
[11:01:35.544]   ..$ group :<environment: R_EmptyEnv> 
[11:01:35.544]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:35.544]  - attr(*, "resolved")= logi FALSE
[11:01:35.544]  - attr(*, "total_size")= num 401
[11:01:35.544]  - attr(*, "already-done")= logi TRUE
[11:01:35.546] - copied ‘weight’ to environment
[11:01:35.547] - copied ‘group’ to environment
[11:01:35.547] assign_globals() ... done
[11:01:35.547] plan(): Setting new future strategy stack:
[11:01:35.547] List of future strategies:
[11:01:35.547] 1. sequential:
[11:01:35.547]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.547]    - tweaked: FALSE
[11:01:35.547]    - call: NULL
[11:01:35.547] plan(): nbrOfWorkers() = 1
[11:01:35.549] plan(): Setting new future strategy stack:
[11:01:35.549] List of future strategies:
[11:01:35.549] 1. sequential:
[11:01:35.549]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.549]    - tweaked: FALSE
[11:01:35.549]    - call: plan(strategy)
[11:01:35.549] plan(): nbrOfWorkers() = 1
[11:01:35.549] SequentialFuture started (and completed)
[11:01:35.550] - Launch lazy future ... done
[11:01:35.550] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[11:01:35.552] getGlobalsAndPackages() ...
[11:01:35.552] Searching for globals...
[11:01:35.553] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[11:01:35.554] Searching for globals ... DONE
[11:01:35.554] Resolving globals: FALSE
[11:01:35.554] The total size of the 2 globals is 401 bytes (401 bytes)
[11:01:35.554] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[11:01:35.555] - globals: [2] ‘weight’, ‘group’
[11:01:35.555] - packages: [1] ‘stats’
[11:01:35.555] getGlobalsAndPackages() ... DONE
[11:01:35.555] run() for ‘Future’ ...
[11:01:35.555] - state: ‘created’
[11:01:35.555] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:35.555] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:35.556] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:35.556]   - Field: ‘label’
[11:01:35.556]   - Field: ‘local’
[11:01:35.556]   - Field: ‘owner’
[11:01:35.556]   - Field: ‘envir’
[11:01:35.556]   - Field: ‘packages’
[11:01:35.556]   - Field: ‘gc’
[11:01:35.556]   - Field: ‘conditions’
[11:01:35.556]   - Field: ‘expr’
[11:01:35.556]   - Field: ‘uuid’
[11:01:35.556]   - Field: ‘seed’
[11:01:35.556]   - Field: ‘version’
[11:01:35.557]   - Field: ‘result’
[11:01:35.557]   - Field: ‘asynchronous’
[11:01:35.557]   - Field: ‘calls’
[11:01:35.557]   - Field: ‘globals’
[11:01:35.557]   - Field: ‘stdout’
[11:01:35.557]   - Field: ‘earlySignal’
[11:01:35.557]   - Field: ‘lazy’
[11:01:35.557]   - Field: ‘state’
[11:01:35.557] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:35.557] - Launch lazy future ...
[11:01:35.557] Packages needed by the future expression (n = 1): ‘stats’
[11:01:35.558] Packages needed by future strategies (n = 0): <none>
[11:01:35.558] {
[11:01:35.558]     {
[11:01:35.558]         {
[11:01:35.558]             ...future.startTime <- base::Sys.time()
[11:01:35.558]             {
[11:01:35.558]                 {
[11:01:35.558]                   {
[11:01:35.558]                     {
[11:01:35.558]                       base::local({
[11:01:35.558]                         has_future <- base::requireNamespace("future", 
[11:01:35.558]                           quietly = TRUE)
[11:01:35.558]                         if (has_future) {
[11:01:35.558]                           ns <- base::getNamespace("future")
[11:01:35.558]                           version <- ns[[".package"]][["version"]]
[11:01:35.558]                           if (is.null(version)) 
[11:01:35.558]                             version <- utils::packageVersion("future")
[11:01:35.558]                         }
[11:01:35.558]                         else {
[11:01:35.558]                           version <- NULL
[11:01:35.558]                         }
[11:01:35.558]                         if (!has_future || version < "1.8.0") {
[11:01:35.558]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.558]                             "", base::R.version$version.string), 
[11:01:35.558]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:35.558]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:35.558]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.558]                               "release", "version")], collapse = " "), 
[11:01:35.558]                             hostname = base::Sys.info()[["nodename"]])
[11:01:35.558]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.558]                             info)
[11:01:35.558]                           info <- base::paste(info, collapse = "; ")
[11:01:35.558]                           if (!has_future) {
[11:01:35.558]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.558]                               info)
[11:01:35.558]                           }
[11:01:35.558]                           else {
[11:01:35.558]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.558]                               info, version)
[11:01:35.558]                           }
[11:01:35.558]                           base::stop(msg)
[11:01:35.558]                         }
[11:01:35.558]                       })
[11:01:35.558]                     }
[11:01:35.558]                     base::local({
[11:01:35.558]                       for (pkg in "stats") {
[11:01:35.558]                         base::loadNamespace(pkg)
[11:01:35.558]                         base::library(pkg, character.only = TRUE)
[11:01:35.558]                       }
[11:01:35.558]                     })
[11:01:35.558]                   }
[11:01:35.558]                   ...future.strategy.old <- future::plan("list")
[11:01:35.558]                   options(future.plan = NULL)
[11:01:35.558]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.558]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.558]                 }
[11:01:35.558]                 ...future.workdir <- getwd()
[11:01:35.558]             }
[11:01:35.558]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.558]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.558]         }
[11:01:35.558]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.558]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.558]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.558]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.558]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.558]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.558]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.558]             base::names(...future.oldOptions))
[11:01:35.558]     }
[11:01:35.558]     if (FALSE) {
[11:01:35.558]     }
[11:01:35.558]     else {
[11:01:35.558]         if (TRUE) {
[11:01:35.558]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.558]                 open = "w")
[11:01:35.558]         }
[11:01:35.558]         else {
[11:01:35.558]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.558]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.558]         }
[11:01:35.558]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.558]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.558]             base::sink(type = "output", split = FALSE)
[11:01:35.558]             base::close(...future.stdout)
[11:01:35.558]         }, add = TRUE)
[11:01:35.558]     }
[11:01:35.558]     ...future.frame <- base::sys.nframe()
[11:01:35.558]     ...future.conditions <- base::list()
[11:01:35.558]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.558]     if (FALSE) {
[11:01:35.558]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.558]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.558]     }
[11:01:35.558]     ...future.result <- base::tryCatch({
[11:01:35.558]         base::withCallingHandlers({
[11:01:35.558]             ...future.value <- base::withVisible(base::local({
[11:01:35.558]                 lm(weight ~ group - 1)
[11:01:35.558]             }))
[11:01:35.558]             future::FutureResult(value = ...future.value$value, 
[11:01:35.558]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.558]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.558]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.558]                     ...future.globalenv.names))
[11:01:35.558]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.558]         }, condition = base::local({
[11:01:35.558]             c <- base::c
[11:01:35.558]             inherits <- base::inherits
[11:01:35.558]             invokeRestart <- base::invokeRestart
[11:01:35.558]             length <- base::length
[11:01:35.558]             list <- base::list
[11:01:35.558]             seq.int <- base::seq.int
[11:01:35.558]             signalCondition <- base::signalCondition
[11:01:35.558]             sys.calls <- base::sys.calls
[11:01:35.558]             `[[` <- base::`[[`
[11:01:35.558]             `+` <- base::`+`
[11:01:35.558]             `<<-` <- base::`<<-`
[11:01:35.558]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.558]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.558]                   3L)]
[11:01:35.558]             }
[11:01:35.558]             function(cond) {
[11:01:35.558]                 is_error <- inherits(cond, "error")
[11:01:35.558]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.558]                   NULL)
[11:01:35.558]                 if (is_error) {
[11:01:35.558]                   sessionInformation <- function() {
[11:01:35.558]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.558]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.558]                       search = base::search(), system = base::Sys.info())
[11:01:35.558]                   }
[11:01:35.558]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.558]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.558]                     cond$call), session = sessionInformation(), 
[11:01:35.558]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.558]                   signalCondition(cond)
[11:01:35.558]                 }
[11:01:35.558]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.558]                 "immediateCondition"))) {
[11:01:35.558]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.558]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.558]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.558]                   if (TRUE && !signal) {
[11:01:35.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.558]                     {
[11:01:35.558]                       inherits <- base::inherits
[11:01:35.558]                       invokeRestart <- base::invokeRestart
[11:01:35.558]                       is.null <- base::is.null
[11:01:35.558]                       muffled <- FALSE
[11:01:35.558]                       if (inherits(cond, "message")) {
[11:01:35.558]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.558]                         if (muffled) 
[11:01:35.558]                           invokeRestart("muffleMessage")
[11:01:35.558]                       }
[11:01:35.558]                       else if (inherits(cond, "warning")) {
[11:01:35.558]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.558]                         if (muffled) 
[11:01:35.558]                           invokeRestart("muffleWarning")
[11:01:35.558]                       }
[11:01:35.558]                       else if (inherits(cond, "condition")) {
[11:01:35.558]                         if (!is.null(pattern)) {
[11:01:35.558]                           computeRestarts <- base::computeRestarts
[11:01:35.558]                           grepl <- base::grepl
[11:01:35.558]                           restarts <- computeRestarts(cond)
[11:01:35.558]                           for (restart in restarts) {
[11:01:35.558]                             name <- restart$name
[11:01:35.558]                             if (is.null(name)) 
[11:01:35.558]                               next
[11:01:35.558]                             if (!grepl(pattern, name)) 
[11:01:35.558]                               next
[11:01:35.558]                             invokeRestart(restart)
[11:01:35.558]                             muffled <- TRUE
[11:01:35.558]                             break
[11:01:35.558]                           }
[11:01:35.558]                         }
[11:01:35.558]                       }
[11:01:35.558]                       invisible(muffled)
[11:01:35.558]                     }
[11:01:35.558]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.558]                   }
[11:01:35.558]                 }
[11:01:35.558]                 else {
[11:01:35.558]                   if (TRUE) {
[11:01:35.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.558]                     {
[11:01:35.558]                       inherits <- base::inherits
[11:01:35.558]                       invokeRestart <- base::invokeRestart
[11:01:35.558]                       is.null <- base::is.null
[11:01:35.558]                       muffled <- FALSE
[11:01:35.558]                       if (inherits(cond, "message")) {
[11:01:35.558]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.558]                         if (muffled) 
[11:01:35.558]                           invokeRestart("muffleMessage")
[11:01:35.558]                       }
[11:01:35.558]                       else if (inherits(cond, "warning")) {
[11:01:35.558]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.558]                         if (muffled) 
[11:01:35.558]                           invokeRestart("muffleWarning")
[11:01:35.558]                       }
[11:01:35.558]                       else if (inherits(cond, "condition")) {
[11:01:35.558]                         if (!is.null(pattern)) {
[11:01:35.558]                           computeRestarts <- base::computeRestarts
[11:01:35.558]                           grepl <- base::grepl
[11:01:35.558]                           restarts <- computeRestarts(cond)
[11:01:35.558]                           for (restart in restarts) {
[11:01:35.558]                             name <- restart$name
[11:01:35.558]                             if (is.null(name)) 
[11:01:35.558]                               next
[11:01:35.558]                             if (!grepl(pattern, name)) 
[11:01:35.558]                               next
[11:01:35.558]                             invokeRestart(restart)
[11:01:35.558]                             muffled <- TRUE
[11:01:35.558]                             break
[11:01:35.558]                           }
[11:01:35.558]                         }
[11:01:35.558]                       }
[11:01:35.558]                       invisible(muffled)
[11:01:35.558]                     }
[11:01:35.558]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.558]                   }
[11:01:35.558]                 }
[11:01:35.558]             }
[11:01:35.558]         }))
[11:01:35.558]     }, error = function(ex) {
[11:01:35.558]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.558]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.558]                 ...future.rng), started = ...future.startTime, 
[11:01:35.558]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.558]             version = "1.8"), class = "FutureResult")
[11:01:35.558]     }, finally = {
[11:01:35.558]         if (!identical(...future.workdir, getwd())) 
[11:01:35.558]             setwd(...future.workdir)
[11:01:35.558]         {
[11:01:35.558]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.558]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.558]             }
[11:01:35.558]             base::options(...future.oldOptions)
[11:01:35.558]             if (.Platform$OS.type == "windows") {
[11:01:35.558]                 old_names <- names(...future.oldEnvVars)
[11:01:35.558]                 envs <- base::Sys.getenv()
[11:01:35.558]                 names <- names(envs)
[11:01:35.558]                 common <- intersect(names, old_names)
[11:01:35.558]                 added <- setdiff(names, old_names)
[11:01:35.558]                 removed <- setdiff(old_names, names)
[11:01:35.558]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.558]                   envs[common]]
[11:01:35.558]                 NAMES <- toupper(changed)
[11:01:35.558]                 args <- list()
[11:01:35.558]                 for (kk in seq_along(NAMES)) {
[11:01:35.558]                   name <- changed[[kk]]
[11:01:35.558]                   NAME <- NAMES[[kk]]
[11:01:35.558]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.558]                     next
[11:01:35.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.558]                 }
[11:01:35.558]                 NAMES <- toupper(added)
[11:01:35.558]                 for (kk in seq_along(NAMES)) {
[11:01:35.558]                   name <- added[[kk]]
[11:01:35.558]                   NAME <- NAMES[[kk]]
[11:01:35.558]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.558]                     next
[11:01:35.558]                   args[[name]] <- ""
[11:01:35.558]                 }
[11:01:35.558]                 NAMES <- toupper(removed)
[11:01:35.558]                 for (kk in seq_along(NAMES)) {
[11:01:35.558]                   name <- removed[[kk]]
[11:01:35.558]                   NAME <- NAMES[[kk]]
[11:01:35.558]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.558]                     next
[11:01:35.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.558]                 }
[11:01:35.558]                 if (length(args) > 0) 
[11:01:35.558]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.558]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.558]             }
[11:01:35.558]             else {
[11:01:35.558]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.558]             }
[11:01:35.558]             {
[11:01:35.558]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.558]                   0L) {
[11:01:35.558]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.558]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.558]                   base::options(opts)
[11:01:35.558]                 }
[11:01:35.558]                 {
[11:01:35.558]                   {
[11:01:35.558]                     NULL
[11:01:35.558]                     RNGkind("Mersenne-Twister")
[11:01:35.558]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:35.558]                       inherits = FALSE)
[11:01:35.558]                   }
[11:01:35.558]                   options(future.plan = NULL)
[11:01:35.558]                   if (is.na(NA_character_)) 
[11:01:35.558]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.558]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.558]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.558]                     .init = FALSE)
[11:01:35.558]                 }
[11:01:35.558]             }
[11:01:35.558]         }
[11:01:35.558]     })
[11:01:35.558]     if (TRUE) {
[11:01:35.558]         base::sink(type = "output", split = FALSE)
[11:01:35.558]         if (TRUE) {
[11:01:35.558]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.558]         }
[11:01:35.558]         else {
[11:01:35.558]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.558]         }
[11:01:35.558]         base::close(...future.stdout)
[11:01:35.558]         ...future.stdout <- NULL
[11:01:35.558]     }
[11:01:35.558]     ...future.result$conditions <- ...future.conditions
[11:01:35.558]     ...future.result$finished <- base::Sys.time()
[11:01:35.558]     ...future.result
[11:01:35.558] }
[11:01:35.560] assign_globals() ...
[11:01:35.560] List of 2
[11:01:35.560]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[11:01:35.560]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[11:01:35.560]  - attr(*, "where")=List of 2
[11:01:35.560]   ..$ weight:<environment: R_EmptyEnv> 
[11:01:35.560]   ..$ group :<environment: R_EmptyEnv> 
[11:01:35.560]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:35.560]  - attr(*, "resolved")= logi FALSE
[11:01:35.560]  - attr(*, "total_size")= num 401
[11:01:35.560]  - attr(*, "already-done")= logi TRUE
[11:01:35.562] - copied ‘weight’ to environment
[11:01:35.563] - copied ‘group’ to environment
[11:01:35.563] assign_globals() ... done
[11:01:35.563] plan(): Setting new future strategy stack:
[11:01:35.563] List of future strategies:
[11:01:35.563] 1. sequential:
[11:01:35.563]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.563]    - tweaked: FALSE
[11:01:35.563]    - call: NULL
[11:01:35.563] plan(): nbrOfWorkers() = 1
[11:01:35.565] plan(): Setting new future strategy stack:
[11:01:35.565] List of future strategies:
[11:01:35.565] 1. sequential:
[11:01:35.565]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.565]    - tweaked: FALSE
[11:01:35.565]    - call: plan(strategy)
[11:01:35.565] plan(): nbrOfWorkers() = 1
[11:01:35.565] SequentialFuture started (and completed)
[11:01:35.566] - Launch lazy future ... done
[11:01:35.566] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[11:01:35.567] getGlobalsAndPackages() ...
[11:01:35.567] Searching for globals...
[11:01:35.568] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[11:01:35.568] Searching for globals ... DONE
[11:01:35.568] Resolving globals: FALSE
[11:01:35.569] The total size of the 1 globals is 71 bytes (71 bytes)
[11:01:35.569] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 71 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (71 bytes of class ‘numeric’)
[11:01:35.569] - globals: [1] ‘x’
[11:01:35.569] - packages: [1] ‘stats’
[11:01:35.569] getGlobalsAndPackages() ... DONE
[11:01:35.570] run() for ‘Future’ ...
[11:01:35.570] - state: ‘created’
[11:01:35.570] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:35.570] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:35.570] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:35.570]   - Field: ‘label’
[11:01:35.570]   - Field: ‘local’
[11:01:35.570]   - Field: ‘owner’
[11:01:35.571]   - Field: ‘envir’
[11:01:35.571]   - Field: ‘packages’
[11:01:35.571]   - Field: ‘gc’
[11:01:35.571]   - Field: ‘conditions’
[11:01:35.571]   - Field: ‘expr’
[11:01:35.571]   - Field: ‘uuid’
[11:01:35.571]   - Field: ‘seed’
[11:01:35.571]   - Field: ‘version’
[11:01:35.571]   - Field: ‘result’
[11:01:35.571]   - Field: ‘asynchronous’
[11:01:35.571]   - Field: ‘calls’
[11:01:35.571]   - Field: ‘globals’
[11:01:35.571]   - Field: ‘stdout’
[11:01:35.572]   - Field: ‘earlySignal’
[11:01:35.572]   - Field: ‘lazy’
[11:01:35.572]   - Field: ‘state’
[11:01:35.572] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:35.572] - Launch lazy future ...
[11:01:35.573] Packages needed by the future expression (n = 1): ‘stats’
[11:01:35.573] Packages needed by future strategies (n = 0): <none>
[11:01:35.573] {
[11:01:35.573]     {
[11:01:35.573]         {
[11:01:35.573]             ...future.startTime <- base::Sys.time()
[11:01:35.573]             {
[11:01:35.573]                 {
[11:01:35.573]                   {
[11:01:35.573]                     {
[11:01:35.573]                       base::local({
[11:01:35.573]                         has_future <- base::requireNamespace("future", 
[11:01:35.573]                           quietly = TRUE)
[11:01:35.573]                         if (has_future) {
[11:01:35.573]                           ns <- base::getNamespace("future")
[11:01:35.573]                           version <- ns[[".package"]][["version"]]
[11:01:35.573]                           if (is.null(version)) 
[11:01:35.573]                             version <- utils::packageVersion("future")
[11:01:35.573]                         }
[11:01:35.573]                         else {
[11:01:35.573]                           version <- NULL
[11:01:35.573]                         }
[11:01:35.573]                         if (!has_future || version < "1.8.0") {
[11:01:35.573]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.573]                             "", base::R.version$version.string), 
[11:01:35.573]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:35.573]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:35.573]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.573]                               "release", "version")], collapse = " "), 
[11:01:35.573]                             hostname = base::Sys.info()[["nodename"]])
[11:01:35.573]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.573]                             info)
[11:01:35.573]                           info <- base::paste(info, collapse = "; ")
[11:01:35.573]                           if (!has_future) {
[11:01:35.573]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.573]                               info)
[11:01:35.573]                           }
[11:01:35.573]                           else {
[11:01:35.573]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.573]                               info, version)
[11:01:35.573]                           }
[11:01:35.573]                           base::stop(msg)
[11:01:35.573]                         }
[11:01:35.573]                       })
[11:01:35.573]                     }
[11:01:35.573]                     base::local({
[11:01:35.573]                       for (pkg in "stats") {
[11:01:35.573]                         base::loadNamespace(pkg)
[11:01:35.573]                         base::library(pkg, character.only = TRUE)
[11:01:35.573]                       }
[11:01:35.573]                     })
[11:01:35.573]                   }
[11:01:35.573]                   ...future.strategy.old <- future::plan("list")
[11:01:35.573]                   options(future.plan = NULL)
[11:01:35.573]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.573]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.573]                 }
[11:01:35.573]                 ...future.workdir <- getwd()
[11:01:35.573]             }
[11:01:35.573]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.573]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.573]         }
[11:01:35.573]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.573]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.573]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.573]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.573]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.573]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.573]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.573]             base::names(...future.oldOptions))
[11:01:35.573]     }
[11:01:35.573]     if (FALSE) {
[11:01:35.573]     }
[11:01:35.573]     else {
[11:01:35.573]         if (TRUE) {
[11:01:35.573]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.573]                 open = "w")
[11:01:35.573]         }
[11:01:35.573]         else {
[11:01:35.573]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.573]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.573]         }
[11:01:35.573]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.573]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.573]             base::sink(type = "output", split = FALSE)
[11:01:35.573]             base::close(...future.stdout)
[11:01:35.573]         }, add = TRUE)
[11:01:35.573]     }
[11:01:35.573]     ...future.frame <- base::sys.nframe()
[11:01:35.573]     ...future.conditions <- base::list()
[11:01:35.573]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.573]     if (FALSE) {
[11:01:35.573]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.573]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.573]     }
[11:01:35.573]     ...future.result <- base::tryCatch({
[11:01:35.573]         base::withCallingHandlers({
[11:01:35.573]             ...future.value <- base::withVisible(base::local({
[11:01:35.573]                 xtabs(~x)
[11:01:35.573]             }))
[11:01:35.573]             future::FutureResult(value = ...future.value$value, 
[11:01:35.573]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.573]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.573]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.573]                     ...future.globalenv.names))
[11:01:35.573]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.573]         }, condition = base::local({
[11:01:35.573]             c <- base::c
[11:01:35.573]             inherits <- base::inherits
[11:01:35.573]             invokeRestart <- base::invokeRestart
[11:01:35.573]             length <- base::length
[11:01:35.573]             list <- base::list
[11:01:35.573]             seq.int <- base::seq.int
[11:01:35.573]             signalCondition <- base::signalCondition
[11:01:35.573]             sys.calls <- base::sys.calls
[11:01:35.573]             `[[` <- base::`[[`
[11:01:35.573]             `+` <- base::`+`
[11:01:35.573]             `<<-` <- base::`<<-`
[11:01:35.573]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.573]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.573]                   3L)]
[11:01:35.573]             }
[11:01:35.573]             function(cond) {
[11:01:35.573]                 is_error <- inherits(cond, "error")
[11:01:35.573]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.573]                   NULL)
[11:01:35.573]                 if (is_error) {
[11:01:35.573]                   sessionInformation <- function() {
[11:01:35.573]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.573]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.573]                       search = base::search(), system = base::Sys.info())
[11:01:35.573]                   }
[11:01:35.573]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.573]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.573]                     cond$call), session = sessionInformation(), 
[11:01:35.573]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.573]                   signalCondition(cond)
[11:01:35.573]                 }
[11:01:35.573]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.573]                 "immediateCondition"))) {
[11:01:35.573]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.573]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.573]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.573]                   if (TRUE && !signal) {
[11:01:35.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.573]                     {
[11:01:35.573]                       inherits <- base::inherits
[11:01:35.573]                       invokeRestart <- base::invokeRestart
[11:01:35.573]                       is.null <- base::is.null
[11:01:35.573]                       muffled <- FALSE
[11:01:35.573]                       if (inherits(cond, "message")) {
[11:01:35.573]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.573]                         if (muffled) 
[11:01:35.573]                           invokeRestart("muffleMessage")
[11:01:35.573]                       }
[11:01:35.573]                       else if (inherits(cond, "warning")) {
[11:01:35.573]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.573]                         if (muffled) 
[11:01:35.573]                           invokeRestart("muffleWarning")
[11:01:35.573]                       }
[11:01:35.573]                       else if (inherits(cond, "condition")) {
[11:01:35.573]                         if (!is.null(pattern)) {
[11:01:35.573]                           computeRestarts <- base::computeRestarts
[11:01:35.573]                           grepl <- base::grepl
[11:01:35.573]                           restarts <- computeRestarts(cond)
[11:01:35.573]                           for (restart in restarts) {
[11:01:35.573]                             name <- restart$name
[11:01:35.573]                             if (is.null(name)) 
[11:01:35.573]                               next
[11:01:35.573]                             if (!grepl(pattern, name)) 
[11:01:35.573]                               next
[11:01:35.573]                             invokeRestart(restart)
[11:01:35.573]                             muffled <- TRUE
[11:01:35.573]                             break
[11:01:35.573]                           }
[11:01:35.573]                         }
[11:01:35.573]                       }
[11:01:35.573]                       invisible(muffled)
[11:01:35.573]                     }
[11:01:35.573]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.573]                   }
[11:01:35.573]                 }
[11:01:35.573]                 else {
[11:01:35.573]                   if (TRUE) {
[11:01:35.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.573]                     {
[11:01:35.573]                       inherits <- base::inherits
[11:01:35.573]                       invokeRestart <- base::invokeRestart
[11:01:35.573]                       is.null <- base::is.null
[11:01:35.573]                       muffled <- FALSE
[11:01:35.573]                       if (inherits(cond, "message")) {
[11:01:35.573]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.573]                         if (muffled) 
[11:01:35.573]                           invokeRestart("muffleMessage")
[11:01:35.573]                       }
[11:01:35.573]                       else if (inherits(cond, "warning")) {
[11:01:35.573]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.573]                         if (muffled) 
[11:01:35.573]                           invokeRestart("muffleWarning")
[11:01:35.573]                       }
[11:01:35.573]                       else if (inherits(cond, "condition")) {
[11:01:35.573]                         if (!is.null(pattern)) {
[11:01:35.573]                           computeRestarts <- base::computeRestarts
[11:01:35.573]                           grepl <- base::grepl
[11:01:35.573]                           restarts <- computeRestarts(cond)
[11:01:35.573]                           for (restart in restarts) {
[11:01:35.573]                             name <- restart$name
[11:01:35.573]                             if (is.null(name)) 
[11:01:35.573]                               next
[11:01:35.573]                             if (!grepl(pattern, name)) 
[11:01:35.573]                               next
[11:01:35.573]                             invokeRestart(restart)
[11:01:35.573]                             muffled <- TRUE
[11:01:35.573]                             break
[11:01:35.573]                           }
[11:01:35.573]                         }
[11:01:35.573]                       }
[11:01:35.573]                       invisible(muffled)
[11:01:35.573]                     }
[11:01:35.573]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.573]                   }
[11:01:35.573]                 }
[11:01:35.573]             }
[11:01:35.573]         }))
[11:01:35.573]     }, error = function(ex) {
[11:01:35.573]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.573]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.573]                 ...future.rng), started = ...future.startTime, 
[11:01:35.573]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.573]             version = "1.8"), class = "FutureResult")
[11:01:35.573]     }, finally = {
[11:01:35.573]         if (!identical(...future.workdir, getwd())) 
[11:01:35.573]             setwd(...future.workdir)
[11:01:35.573]         {
[11:01:35.573]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.573]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.573]             }
[11:01:35.573]             base::options(...future.oldOptions)
[11:01:35.573]             if (.Platform$OS.type == "windows") {
[11:01:35.573]                 old_names <- names(...future.oldEnvVars)
[11:01:35.573]                 envs <- base::Sys.getenv()
[11:01:35.573]                 names <- names(envs)
[11:01:35.573]                 common <- intersect(names, old_names)
[11:01:35.573]                 added <- setdiff(names, old_names)
[11:01:35.573]                 removed <- setdiff(old_names, names)
[11:01:35.573]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.573]                   envs[common]]
[11:01:35.573]                 NAMES <- toupper(changed)
[11:01:35.573]                 args <- list()
[11:01:35.573]                 for (kk in seq_along(NAMES)) {
[11:01:35.573]                   name <- changed[[kk]]
[11:01:35.573]                   NAME <- NAMES[[kk]]
[11:01:35.573]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.573]                     next
[11:01:35.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.573]                 }
[11:01:35.573]                 NAMES <- toupper(added)
[11:01:35.573]                 for (kk in seq_along(NAMES)) {
[11:01:35.573]                   name <- added[[kk]]
[11:01:35.573]                   NAME <- NAMES[[kk]]
[11:01:35.573]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.573]                     next
[11:01:35.573]                   args[[name]] <- ""
[11:01:35.573]                 }
[11:01:35.573]                 NAMES <- toupper(removed)
[11:01:35.573]                 for (kk in seq_along(NAMES)) {
[11:01:35.573]                   name <- removed[[kk]]
[11:01:35.573]                   NAME <- NAMES[[kk]]
[11:01:35.573]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.573]                     next
[11:01:35.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.573]                 }
[11:01:35.573]                 if (length(args) > 0) 
[11:01:35.573]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.573]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.573]             }
[11:01:35.573]             else {
[11:01:35.573]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.573]             }
[11:01:35.573]             {
[11:01:35.573]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.573]                   0L) {
[11:01:35.573]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.573]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.573]                   base::options(opts)
[11:01:35.573]                 }
[11:01:35.573]                 {
[11:01:35.573]                   {
[11:01:35.573]                     NULL
[11:01:35.573]                     RNGkind("Mersenne-Twister")
[11:01:35.573]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:35.573]                       inherits = FALSE)
[11:01:35.573]                   }
[11:01:35.573]                   options(future.plan = NULL)
[11:01:35.573]                   if (is.na(NA_character_)) 
[11:01:35.573]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.573]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.573]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.573]                     .init = FALSE)
[11:01:35.573]                 }
[11:01:35.573]             }
[11:01:35.573]         }
[11:01:35.573]     })
[11:01:35.573]     if (TRUE) {
[11:01:35.573]         base::sink(type = "output", split = FALSE)
[11:01:35.573]         if (TRUE) {
[11:01:35.573]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.573]         }
[11:01:35.573]         else {
[11:01:35.573]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.573]         }
[11:01:35.573]         base::close(...future.stdout)
[11:01:35.573]         ...future.stdout <- NULL
[11:01:35.573]     }
[11:01:35.573]     ...future.result$conditions <- ...future.conditions
[11:01:35.573]     ...future.result$finished <- base::Sys.time()
[11:01:35.573]     ...future.result
[11:01:35.573] }
[11:01:35.575] assign_globals() ...
[11:01:35.575] List of 1
[11:01:35.575]  $ x: num [1:5] 1 1 2 2 2
[11:01:35.575]  - attr(*, "where")=List of 1
[11:01:35.575]   ..$ x:<environment: R_EmptyEnv> 
[11:01:35.575]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:35.575]  - attr(*, "resolved")= logi FALSE
[11:01:35.575]  - attr(*, "total_size")= num 71
[11:01:35.575]  - attr(*, "already-done")= logi TRUE
[11:01:35.577] - copied ‘x’ to environment
[11:01:35.578] assign_globals() ... done
[11:01:35.578] plan(): Setting new future strategy stack:
[11:01:35.578] List of future strategies:
[11:01:35.578] 1. sequential:
[11:01:35.578]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.578]    - tweaked: FALSE
[11:01:35.578]    - call: NULL
[11:01:35.578] plan(): nbrOfWorkers() = 1
[11:01:35.579] plan(): Setting new future strategy stack:
[11:01:35.579] List of future strategies:
[11:01:35.579] 1. sequential:
[11:01:35.579]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.579]    - tweaked: FALSE
[11:01:35.579]    - call: plan(strategy)
[11:01:35.580] plan(): nbrOfWorkers() = 1
[11:01:35.580] SequentialFuture started (and completed)
[11:01:35.580] - Launch lazy future ... done
[11:01:35.580] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
[11:01:35.581] getGlobalsAndPackages() ...
[11:01:35.581] Searching for globals...
[11:01:35.582] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[11:01:35.582] Searching for globals ... DONE
[11:01:35.582] Resolving globals: FALSE
[11:01:35.582] The total size of the 1 globals is 71 bytes (71 bytes)
[11:01:35.583] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 71 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (71 bytes of class ‘numeric’)
[11:01:35.583] - globals: [1] ‘x’
[11:01:35.583] - packages: [1] ‘stats’
[11:01:35.583] getGlobalsAndPackages() ... DONE
[11:01:35.583] run() for ‘Future’ ...
[11:01:35.583] - state: ‘created’
[11:01:35.584] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:35.584] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:35.584] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:35.584]   - Field: ‘label’
[11:01:35.584]   - Field: ‘local’
[11:01:35.584]   - Field: ‘owner’
[11:01:35.584]   - Field: ‘envir’
[11:01:35.584]   - Field: ‘packages’
[11:01:35.584]   - Field: ‘gc’
[11:01:35.584]   - Field: ‘conditions’
[11:01:35.585]   - Field: ‘expr’
[11:01:35.585]   - Field: ‘uuid’
[11:01:35.585]   - Field: ‘seed’
[11:01:35.585]   - Field: ‘version’
[11:01:35.585]   - Field: ‘result’
[11:01:35.585]   - Field: ‘asynchronous’
[11:01:35.585]   - Field: ‘calls’
[11:01:35.585]   - Field: ‘globals’
[11:01:35.585]   - Field: ‘stdout’
[11:01:35.585]   - Field: ‘earlySignal’
[11:01:35.585]   - Field: ‘lazy’
[11:01:35.585]   - Field: ‘state’
[11:01:35.585] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:35.586] - Launch lazy future ...
[11:01:35.586] Packages needed by the future expression (n = 1): ‘stats’
[11:01:35.586] Packages needed by future strategies (n = 0): <none>
[11:01:35.586] {
[11:01:35.586]     {
[11:01:35.586]         {
[11:01:35.586]             ...future.startTime <- base::Sys.time()
[11:01:35.586]             {
[11:01:35.586]                 {
[11:01:35.586]                   {
[11:01:35.586]                     {
[11:01:35.586]                       base::local({
[11:01:35.586]                         has_future <- base::requireNamespace("future", 
[11:01:35.586]                           quietly = TRUE)
[11:01:35.586]                         if (has_future) {
[11:01:35.586]                           ns <- base::getNamespace("future")
[11:01:35.586]                           version <- ns[[".package"]][["version"]]
[11:01:35.586]                           if (is.null(version)) 
[11:01:35.586]                             version <- utils::packageVersion("future")
[11:01:35.586]                         }
[11:01:35.586]                         else {
[11:01:35.586]                           version <- NULL
[11:01:35.586]                         }
[11:01:35.586]                         if (!has_future || version < "1.8.0") {
[11:01:35.586]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.586]                             "", base::R.version$version.string), 
[11:01:35.586]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:35.586]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:35.586]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.586]                               "release", "version")], collapse = " "), 
[11:01:35.586]                             hostname = base::Sys.info()[["nodename"]])
[11:01:35.586]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.586]                             info)
[11:01:35.586]                           info <- base::paste(info, collapse = "; ")
[11:01:35.586]                           if (!has_future) {
[11:01:35.586]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.586]                               info)
[11:01:35.586]                           }
[11:01:35.586]                           else {
[11:01:35.586]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.586]                               info, version)
[11:01:35.586]                           }
[11:01:35.586]                           base::stop(msg)
[11:01:35.586]                         }
[11:01:35.586]                       })
[11:01:35.586]                     }
[11:01:35.586]                     base::local({
[11:01:35.586]                       for (pkg in "stats") {
[11:01:35.586]                         base::loadNamespace(pkg)
[11:01:35.586]                         base::library(pkg, character.only = TRUE)
[11:01:35.586]                       }
[11:01:35.586]                     })
[11:01:35.586]                   }
[11:01:35.586]                   ...future.strategy.old <- future::plan("list")
[11:01:35.586]                   options(future.plan = NULL)
[11:01:35.586]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.586]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.586]                 }
[11:01:35.586]                 ...future.workdir <- getwd()
[11:01:35.586]             }
[11:01:35.586]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.586]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.586]         }
[11:01:35.586]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.586]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.586]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.586]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.586]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.586]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.586]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.586]             base::names(...future.oldOptions))
[11:01:35.586]     }
[11:01:35.586]     if (FALSE) {
[11:01:35.586]     }
[11:01:35.586]     else {
[11:01:35.586]         if (TRUE) {
[11:01:35.586]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.586]                 open = "w")
[11:01:35.586]         }
[11:01:35.586]         else {
[11:01:35.586]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.586]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.586]         }
[11:01:35.586]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.586]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.586]             base::sink(type = "output", split = FALSE)
[11:01:35.586]             base::close(...future.stdout)
[11:01:35.586]         }, add = TRUE)
[11:01:35.586]     }
[11:01:35.586]     ...future.frame <- base::sys.nframe()
[11:01:35.586]     ...future.conditions <- base::list()
[11:01:35.586]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.586]     if (FALSE) {
[11:01:35.586]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.586]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.586]     }
[11:01:35.586]     ...future.result <- base::tryCatch({
[11:01:35.586]         base::withCallingHandlers({
[11:01:35.586]             ...future.value <- base::withVisible(base::local({
[11:01:35.586]                 xtabs(~x)
[11:01:35.586]             }))
[11:01:35.586]             future::FutureResult(value = ...future.value$value, 
[11:01:35.586]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.586]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.586]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.586]                     ...future.globalenv.names))
[11:01:35.586]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.586]         }, condition = base::local({
[11:01:35.586]             c <- base::c
[11:01:35.586]             inherits <- base::inherits
[11:01:35.586]             invokeRestart <- base::invokeRestart
[11:01:35.586]             length <- base::length
[11:01:35.586]             list <- base::list
[11:01:35.586]             seq.int <- base::seq.int
[11:01:35.586]             signalCondition <- base::signalCondition
[11:01:35.586]             sys.calls <- base::sys.calls
[11:01:35.586]             `[[` <- base::`[[`
[11:01:35.586]             `+` <- base::`+`
[11:01:35.586]             `<<-` <- base::`<<-`
[11:01:35.586]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.586]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.586]                   3L)]
[11:01:35.586]             }
[11:01:35.586]             function(cond) {
[11:01:35.586]                 is_error <- inherits(cond, "error")
[11:01:35.586]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.586]                   NULL)
[11:01:35.586]                 if (is_error) {
[11:01:35.586]                   sessionInformation <- function() {
[11:01:35.586]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.586]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.586]                       search = base::search(), system = base::Sys.info())
[11:01:35.586]                   }
[11:01:35.586]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.586]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.586]                     cond$call), session = sessionInformation(), 
[11:01:35.586]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.586]                   signalCondition(cond)
[11:01:35.586]                 }
[11:01:35.586]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.586]                 "immediateCondition"))) {
[11:01:35.586]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.586]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.586]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.586]                   if (TRUE && !signal) {
[11:01:35.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.586]                     {
[11:01:35.586]                       inherits <- base::inherits
[11:01:35.586]                       invokeRestart <- base::invokeRestart
[11:01:35.586]                       is.null <- base::is.null
[11:01:35.586]                       muffled <- FALSE
[11:01:35.586]                       if (inherits(cond, "message")) {
[11:01:35.586]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.586]                         if (muffled) 
[11:01:35.586]                           invokeRestart("muffleMessage")
[11:01:35.586]                       }
[11:01:35.586]                       else if (inherits(cond, "warning")) {
[11:01:35.586]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.586]                         if (muffled) 
[11:01:35.586]                           invokeRestart("muffleWarning")
[11:01:35.586]                       }
[11:01:35.586]                       else if (inherits(cond, "condition")) {
[11:01:35.586]                         if (!is.null(pattern)) {
[11:01:35.586]                           computeRestarts <- base::computeRestarts
[11:01:35.586]                           grepl <- base::grepl
[11:01:35.586]                           restarts <- computeRestarts(cond)
[11:01:35.586]                           for (restart in restarts) {
[11:01:35.586]                             name <- restart$name
[11:01:35.586]                             if (is.null(name)) 
[11:01:35.586]                               next
[11:01:35.586]                             if (!grepl(pattern, name)) 
[11:01:35.586]                               next
[11:01:35.586]                             invokeRestart(restart)
[11:01:35.586]                             muffled <- TRUE
[11:01:35.586]                             break
[11:01:35.586]                           }
[11:01:35.586]                         }
[11:01:35.586]                       }
[11:01:35.586]                       invisible(muffled)
[11:01:35.586]                     }
[11:01:35.586]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.586]                   }
[11:01:35.586]                 }
[11:01:35.586]                 else {
[11:01:35.586]                   if (TRUE) {
[11:01:35.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.586]                     {
[11:01:35.586]                       inherits <- base::inherits
[11:01:35.586]                       invokeRestart <- base::invokeRestart
[11:01:35.586]                       is.null <- base::is.null
[11:01:35.586]                       muffled <- FALSE
[11:01:35.586]                       if (inherits(cond, "message")) {
[11:01:35.586]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.586]                         if (muffled) 
[11:01:35.586]                           invokeRestart("muffleMessage")
[11:01:35.586]                       }
[11:01:35.586]                       else if (inherits(cond, "warning")) {
[11:01:35.586]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.586]                         if (muffled) 
[11:01:35.586]                           invokeRestart("muffleWarning")
[11:01:35.586]                       }
[11:01:35.586]                       else if (inherits(cond, "condition")) {
[11:01:35.586]                         if (!is.null(pattern)) {
[11:01:35.586]                           computeRestarts <- base::computeRestarts
[11:01:35.586]                           grepl <- base::grepl
[11:01:35.586]                           restarts <- computeRestarts(cond)
[11:01:35.586]                           for (restart in restarts) {
[11:01:35.586]                             name <- restart$name
[11:01:35.586]                             if (is.null(name)) 
[11:01:35.586]                               next
[11:01:35.586]                             if (!grepl(pattern, name)) 
[11:01:35.586]                               next
[11:01:35.586]                             invokeRestart(restart)
[11:01:35.586]                             muffled <- TRUE
[11:01:35.586]                             break
[11:01:35.586]                           }
[11:01:35.586]                         }
[11:01:35.586]                       }
[11:01:35.586]                       invisible(muffled)
[11:01:35.586]                     }
[11:01:35.586]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.586]                   }
[11:01:35.586]                 }
[11:01:35.586]             }
[11:01:35.586]         }))
[11:01:35.586]     }, error = function(ex) {
[11:01:35.586]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.586]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.586]                 ...future.rng), started = ...future.startTime, 
[11:01:35.586]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.586]             version = "1.8"), class = "FutureResult")
[11:01:35.586]     }, finally = {
[11:01:35.586]         if (!identical(...future.workdir, getwd())) 
[11:01:35.586]             setwd(...future.workdir)
[11:01:35.586]         {
[11:01:35.586]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.586]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.586]             }
[11:01:35.586]             base::options(...future.oldOptions)
[11:01:35.586]             if (.Platform$OS.type == "windows") {
[11:01:35.586]                 old_names <- names(...future.oldEnvVars)
[11:01:35.586]                 envs <- base::Sys.getenv()
[11:01:35.586]                 names <- names(envs)
[11:01:35.586]                 common <- intersect(names, old_names)
[11:01:35.586]                 added <- setdiff(names, old_names)
[11:01:35.586]                 removed <- setdiff(old_names, names)
[11:01:35.586]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.586]                   envs[common]]
[11:01:35.586]                 NAMES <- toupper(changed)
[11:01:35.586]                 args <- list()
[11:01:35.586]                 for (kk in seq_along(NAMES)) {
[11:01:35.586]                   name <- changed[[kk]]
[11:01:35.586]                   NAME <- NAMES[[kk]]
[11:01:35.586]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.586]                     next
[11:01:35.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.586]                 }
[11:01:35.586]                 NAMES <- toupper(added)
[11:01:35.586]                 for (kk in seq_along(NAMES)) {
[11:01:35.586]                   name <- added[[kk]]
[11:01:35.586]                   NAME <- NAMES[[kk]]
[11:01:35.586]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.586]                     next
[11:01:35.586]                   args[[name]] <- ""
[11:01:35.586]                 }
[11:01:35.586]                 NAMES <- toupper(removed)
[11:01:35.586]                 for (kk in seq_along(NAMES)) {
[11:01:35.586]                   name <- removed[[kk]]
[11:01:35.586]                   NAME <- NAMES[[kk]]
[11:01:35.586]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.586]                     next
[11:01:35.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.586]                 }
[11:01:35.586]                 if (length(args) > 0) 
[11:01:35.586]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.586]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.586]             }
[11:01:35.586]             else {
[11:01:35.586]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.586]             }
[11:01:35.586]             {
[11:01:35.586]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.586]                   0L) {
[11:01:35.586]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.586]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.586]                   base::options(opts)
[11:01:35.586]                 }
[11:01:35.586]                 {
[11:01:35.586]                   {
[11:01:35.586]                     NULL
[11:01:35.586]                     RNGkind("Mersenne-Twister")
[11:01:35.586]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:35.586]                       inherits = FALSE)
[11:01:35.586]                   }
[11:01:35.586]                   options(future.plan = NULL)
[11:01:35.586]                   if (is.na(NA_character_)) 
[11:01:35.586]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.586]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.586]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.586]                     .init = FALSE)
[11:01:35.586]                 }
[11:01:35.586]             }
[11:01:35.586]         }
[11:01:35.586]     })
[11:01:35.586]     if (TRUE) {
[11:01:35.586]         base::sink(type = "output", split = FALSE)
[11:01:35.586]         if (TRUE) {
[11:01:35.586]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.586]         }
[11:01:35.586]         else {
[11:01:35.586]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.586]         }
[11:01:35.586]         base::close(...future.stdout)
[11:01:35.586]         ...future.stdout <- NULL
[11:01:35.586]     }
[11:01:35.586]     ...future.result$conditions <- ...future.conditions
[11:01:35.586]     ...future.result$finished <- base::Sys.time()
[11:01:35.586]     ...future.result
[11:01:35.586] }
[11:01:35.588] assign_globals() ...
[11:01:35.588] List of 1
[11:01:35.588]  $ x: num [1:5] 1 1 2 2 2
[11:01:35.588]  - attr(*, "where")=List of 1
[11:01:35.588]   ..$ x:<environment: R_EmptyEnv> 
[11:01:35.588]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:35.588]  - attr(*, "resolved")= logi FALSE
[11:01:35.588]  - attr(*, "total_size")= num 71
[11:01:35.588]  - attr(*, "already-done")= logi TRUE
[11:01:35.590] - copied ‘x’ to environment
[11:01:35.590] assign_globals() ... done
[11:01:35.591] plan(): Setting new future strategy stack:
[11:01:35.591] List of future strategies:
[11:01:35.591] 1. sequential:
[11:01:35.591]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.591]    - tweaked: FALSE
[11:01:35.591]    - call: NULL
[11:01:35.591] plan(): nbrOfWorkers() = 1
[11:01:35.592] plan(): Setting new future strategy stack:
[11:01:35.592] List of future strategies:
[11:01:35.592] 1. sequential:
[11:01:35.592]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.592]    - tweaked: FALSE
[11:01:35.592]    - call: plan(strategy)
[11:01:35.592] plan(): nbrOfWorkers() = 1
[11:01:35.593] SequentialFuture started (and completed)
[11:01:35.593] - Launch lazy future ... done
[11:01:35.593] run() for ‘SequentialFuture’ ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[11:01:35.594] getGlobalsAndPackages() ...
[11:01:35.594] Searching for globals...
[11:01:35.596] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[11:01:35.596] Searching for globals ... DONE
[11:01:35.596] Resolving globals: FALSE
[11:01:35.597] 
[11:01:35.597] - packages: [2] ‘stats’, ‘datasets’
[11:01:35.598] getGlobalsAndPackages() ... DONE
[11:01:35.598] run() for ‘Future’ ...
[11:01:35.598] - state: ‘created’
[11:01:35.598] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:35.598] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:35.598] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:35.599]   - Field: ‘label’
[11:01:35.599]   - Field: ‘local’
[11:01:35.599]   - Field: ‘owner’
[11:01:35.599]   - Field: ‘envir’
[11:01:35.599]   - Field: ‘packages’
[11:01:35.599]   - Field: ‘gc’
[11:01:35.599]   - Field: ‘conditions’
[11:01:35.599]   - Field: ‘expr’
[11:01:35.599]   - Field: ‘uuid’
[11:01:35.599]   - Field: ‘seed’
[11:01:35.599]   - Field: ‘version’
[11:01:35.599]   - Field: ‘result’
[11:01:35.600]   - Field: ‘asynchronous’
[11:01:35.600]   - Field: ‘calls’
[11:01:35.600]   - Field: ‘globals’
[11:01:35.600]   - Field: ‘stdout’
[11:01:35.600]   - Field: ‘earlySignal’
[11:01:35.600]   - Field: ‘lazy’
[11:01:35.600]   - Field: ‘state’
[11:01:35.600] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:35.600] - Launch lazy future ...
[11:01:35.600] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[11:01:35.600] Packages needed by future strategies (n = 0): <none>
[11:01:35.601] {
[11:01:35.601]     {
[11:01:35.601]         {
[11:01:35.601]             ...future.startTime <- base::Sys.time()
[11:01:35.601]             {
[11:01:35.601]                 {
[11:01:35.601]                   {
[11:01:35.601]                     {
[11:01:35.601]                       base::local({
[11:01:35.601]                         has_future <- base::requireNamespace("future", 
[11:01:35.601]                           quietly = TRUE)
[11:01:35.601]                         if (has_future) {
[11:01:35.601]                           ns <- base::getNamespace("future")
[11:01:35.601]                           version <- ns[[".package"]][["version"]]
[11:01:35.601]                           if (is.null(version)) 
[11:01:35.601]                             version <- utils::packageVersion("future")
[11:01:35.601]                         }
[11:01:35.601]                         else {
[11:01:35.601]                           version <- NULL
[11:01:35.601]                         }
[11:01:35.601]                         if (!has_future || version < "1.8.0") {
[11:01:35.601]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.601]                             "", base::R.version$version.string), 
[11:01:35.601]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:35.601]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:35.601]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.601]                               "release", "version")], collapse = " "), 
[11:01:35.601]                             hostname = base::Sys.info()[["nodename"]])
[11:01:35.601]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.601]                             info)
[11:01:35.601]                           info <- base::paste(info, collapse = "; ")
[11:01:35.601]                           if (!has_future) {
[11:01:35.601]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.601]                               info)
[11:01:35.601]                           }
[11:01:35.601]                           else {
[11:01:35.601]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.601]                               info, version)
[11:01:35.601]                           }
[11:01:35.601]                           base::stop(msg)
[11:01:35.601]                         }
[11:01:35.601]                       })
[11:01:35.601]                     }
[11:01:35.601]                     base::local({
[11:01:35.601]                       for (pkg in c("stats", "datasets")) {
[11:01:35.601]                         base::loadNamespace(pkg)
[11:01:35.601]                         base::library(pkg, character.only = TRUE)
[11:01:35.601]                       }
[11:01:35.601]                     })
[11:01:35.601]                   }
[11:01:35.601]                   ...future.strategy.old <- future::plan("list")
[11:01:35.601]                   options(future.plan = NULL)
[11:01:35.601]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.601]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.601]                 }
[11:01:35.601]                 ...future.workdir <- getwd()
[11:01:35.601]             }
[11:01:35.601]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.601]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.601]         }
[11:01:35.601]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.601]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.601]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.601]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.601]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.601]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.601]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.601]             base::names(...future.oldOptions))
[11:01:35.601]     }
[11:01:35.601]     if (FALSE) {
[11:01:35.601]     }
[11:01:35.601]     else {
[11:01:35.601]         if (TRUE) {
[11:01:35.601]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.601]                 open = "w")
[11:01:35.601]         }
[11:01:35.601]         else {
[11:01:35.601]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.601]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.601]         }
[11:01:35.601]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.601]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.601]             base::sink(type = "output", split = FALSE)
[11:01:35.601]             base::close(...future.stdout)
[11:01:35.601]         }, add = TRUE)
[11:01:35.601]     }
[11:01:35.601]     ...future.frame <- base::sys.nframe()
[11:01:35.601]     ...future.conditions <- base::list()
[11:01:35.601]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.601]     if (FALSE) {
[11:01:35.601]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.601]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.601]     }
[11:01:35.601]     ...future.result <- base::tryCatch({
[11:01:35.601]         base::withCallingHandlers({
[11:01:35.601]             ...future.value <- base::withVisible(base::local({
[11:01:35.601]                 lm(dist ~ . - 1, data = cars)
[11:01:35.601]             }))
[11:01:35.601]             future::FutureResult(value = ...future.value$value, 
[11:01:35.601]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.601]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.601]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.601]                     ...future.globalenv.names))
[11:01:35.601]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.601]         }, condition = base::local({
[11:01:35.601]             c <- base::c
[11:01:35.601]             inherits <- base::inherits
[11:01:35.601]             invokeRestart <- base::invokeRestart
[11:01:35.601]             length <- base::length
[11:01:35.601]             list <- base::list
[11:01:35.601]             seq.int <- base::seq.int
[11:01:35.601]             signalCondition <- base::signalCondition
[11:01:35.601]             sys.calls <- base::sys.calls
[11:01:35.601]             `[[` <- base::`[[`
[11:01:35.601]             `+` <- base::`+`
[11:01:35.601]             `<<-` <- base::`<<-`
[11:01:35.601]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.601]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.601]                   3L)]
[11:01:35.601]             }
[11:01:35.601]             function(cond) {
[11:01:35.601]                 is_error <- inherits(cond, "error")
[11:01:35.601]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.601]                   NULL)
[11:01:35.601]                 if (is_error) {
[11:01:35.601]                   sessionInformation <- function() {
[11:01:35.601]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.601]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.601]                       search = base::search(), system = base::Sys.info())
[11:01:35.601]                   }
[11:01:35.601]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.601]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.601]                     cond$call), session = sessionInformation(), 
[11:01:35.601]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.601]                   signalCondition(cond)
[11:01:35.601]                 }
[11:01:35.601]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.601]                 "immediateCondition"))) {
[11:01:35.601]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.601]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.601]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.601]                   if (TRUE && !signal) {
[11:01:35.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.601]                     {
[11:01:35.601]                       inherits <- base::inherits
[11:01:35.601]                       invokeRestart <- base::invokeRestart
[11:01:35.601]                       is.null <- base::is.null
[11:01:35.601]                       muffled <- FALSE
[11:01:35.601]                       if (inherits(cond, "message")) {
[11:01:35.601]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.601]                         if (muffled) 
[11:01:35.601]                           invokeRestart("muffleMessage")
[11:01:35.601]                       }
[11:01:35.601]                       else if (inherits(cond, "warning")) {
[11:01:35.601]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.601]                         if (muffled) 
[11:01:35.601]                           invokeRestart("muffleWarning")
[11:01:35.601]                       }
[11:01:35.601]                       else if (inherits(cond, "condition")) {
[11:01:35.601]                         if (!is.null(pattern)) {
[11:01:35.601]                           computeRestarts <- base::computeRestarts
[11:01:35.601]                           grepl <- base::grepl
[11:01:35.601]                           restarts <- computeRestarts(cond)
[11:01:35.601]                           for (restart in restarts) {
[11:01:35.601]                             name <- restart$name
[11:01:35.601]                             if (is.null(name)) 
[11:01:35.601]                               next
[11:01:35.601]                             if (!grepl(pattern, name)) 
[11:01:35.601]                               next
[11:01:35.601]                             invokeRestart(restart)
[11:01:35.601]                             muffled <- TRUE
[11:01:35.601]                             break
[11:01:35.601]                           }
[11:01:35.601]                         }
[11:01:35.601]                       }
[11:01:35.601]                       invisible(muffled)
[11:01:35.601]                     }
[11:01:35.601]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.601]                   }
[11:01:35.601]                 }
[11:01:35.601]                 else {
[11:01:35.601]                   if (TRUE) {
[11:01:35.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.601]                     {
[11:01:35.601]                       inherits <- base::inherits
[11:01:35.601]                       invokeRestart <- base::invokeRestart
[11:01:35.601]                       is.null <- base::is.null
[11:01:35.601]                       muffled <- FALSE
[11:01:35.601]                       if (inherits(cond, "message")) {
[11:01:35.601]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.601]                         if (muffled) 
[11:01:35.601]                           invokeRestart("muffleMessage")
[11:01:35.601]                       }
[11:01:35.601]                       else if (inherits(cond, "warning")) {
[11:01:35.601]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.601]                         if (muffled) 
[11:01:35.601]                           invokeRestart("muffleWarning")
[11:01:35.601]                       }
[11:01:35.601]                       else if (inherits(cond, "condition")) {
[11:01:35.601]                         if (!is.null(pattern)) {
[11:01:35.601]                           computeRestarts <- base::computeRestarts
[11:01:35.601]                           grepl <- base::grepl
[11:01:35.601]                           restarts <- computeRestarts(cond)
[11:01:35.601]                           for (restart in restarts) {
[11:01:35.601]                             name <- restart$name
[11:01:35.601]                             if (is.null(name)) 
[11:01:35.601]                               next
[11:01:35.601]                             if (!grepl(pattern, name)) 
[11:01:35.601]                               next
[11:01:35.601]                             invokeRestart(restart)
[11:01:35.601]                             muffled <- TRUE
[11:01:35.601]                             break
[11:01:35.601]                           }
[11:01:35.601]                         }
[11:01:35.601]                       }
[11:01:35.601]                       invisible(muffled)
[11:01:35.601]                     }
[11:01:35.601]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.601]                   }
[11:01:35.601]                 }
[11:01:35.601]             }
[11:01:35.601]         }))
[11:01:35.601]     }, error = function(ex) {
[11:01:35.601]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.601]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.601]                 ...future.rng), started = ...future.startTime, 
[11:01:35.601]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.601]             version = "1.8"), class = "FutureResult")
[11:01:35.601]     }, finally = {
[11:01:35.601]         if (!identical(...future.workdir, getwd())) 
[11:01:35.601]             setwd(...future.workdir)
[11:01:35.601]         {
[11:01:35.601]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.601]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.601]             }
[11:01:35.601]             base::options(...future.oldOptions)
[11:01:35.601]             if (.Platform$OS.type == "windows") {
[11:01:35.601]                 old_names <- names(...future.oldEnvVars)
[11:01:35.601]                 envs <- base::Sys.getenv()
[11:01:35.601]                 names <- names(envs)
[11:01:35.601]                 common <- intersect(names, old_names)
[11:01:35.601]                 added <- setdiff(names, old_names)
[11:01:35.601]                 removed <- setdiff(old_names, names)
[11:01:35.601]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.601]                   envs[common]]
[11:01:35.601]                 NAMES <- toupper(changed)
[11:01:35.601]                 args <- list()
[11:01:35.601]                 for (kk in seq_along(NAMES)) {
[11:01:35.601]                   name <- changed[[kk]]
[11:01:35.601]                   NAME <- NAMES[[kk]]
[11:01:35.601]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.601]                     next
[11:01:35.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.601]                 }
[11:01:35.601]                 NAMES <- toupper(added)
[11:01:35.601]                 for (kk in seq_along(NAMES)) {
[11:01:35.601]                   name <- added[[kk]]
[11:01:35.601]                   NAME <- NAMES[[kk]]
[11:01:35.601]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.601]                     next
[11:01:35.601]                   args[[name]] <- ""
[11:01:35.601]                 }
[11:01:35.601]                 NAMES <- toupper(removed)
[11:01:35.601]                 for (kk in seq_along(NAMES)) {
[11:01:35.601]                   name <- removed[[kk]]
[11:01:35.601]                   NAME <- NAMES[[kk]]
[11:01:35.601]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.601]                     next
[11:01:35.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.601]                 }
[11:01:35.601]                 if (length(args) > 0) 
[11:01:35.601]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.601]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.601]             }
[11:01:35.601]             else {
[11:01:35.601]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.601]             }
[11:01:35.601]             {
[11:01:35.601]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.601]                   0L) {
[11:01:35.601]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.601]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.601]                   base::options(opts)
[11:01:35.601]                 }
[11:01:35.601]                 {
[11:01:35.601]                   {
[11:01:35.601]                     NULL
[11:01:35.601]                     RNGkind("Mersenne-Twister")
[11:01:35.601]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:35.601]                       inherits = FALSE)
[11:01:35.601]                   }
[11:01:35.601]                   options(future.plan = NULL)
[11:01:35.601]                   if (is.na(NA_character_)) 
[11:01:35.601]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.601]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.601]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.601]                     .init = FALSE)
[11:01:35.601]                 }
[11:01:35.601]             }
[11:01:35.601]         }
[11:01:35.601]     })
[11:01:35.601]     if (TRUE) {
[11:01:35.601]         base::sink(type = "output", split = FALSE)
[11:01:35.601]         if (TRUE) {
[11:01:35.601]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.601]         }
[11:01:35.601]         else {
[11:01:35.601]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.601]         }
[11:01:35.601]         base::close(...future.stdout)
[11:01:35.601]         ...future.stdout <- NULL
[11:01:35.601]     }
[11:01:35.601]     ...future.result$conditions <- ...future.conditions
[11:01:35.601]     ...future.result$finished <- base::Sys.time()
[11:01:35.601]     ...future.result
[11:01:35.601] }
[11:01:35.603] plan(): Setting new future strategy stack:
[11:01:35.603] List of future strategies:
[11:01:35.603] 1. sequential:
[11:01:35.603]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.603]    - tweaked: FALSE
[11:01:35.603]    - call: NULL
[11:01:35.603] plan(): nbrOfWorkers() = 1
[11:01:35.604] plan(): Setting new future strategy stack:
[11:01:35.605] List of future strategies:
[11:01:35.605] 1. sequential:
[11:01:35.605]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.605]    - tweaked: FALSE
[11:01:35.605]    - call: plan(strategy)
[11:01:35.605] plan(): nbrOfWorkers() = 1
[11:01:35.605] SequentialFuture started (and completed)
[11:01:35.605] - Launch lazy future ... done
[11:01:35.605] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[11:01:35.607] getGlobalsAndPackages() ...
[11:01:35.608] Searching for globals...
[11:01:35.609] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[11:01:35.609] Searching for globals ... DONE
[11:01:35.609] Resolving globals: FALSE
[11:01:35.610] 
[11:01:35.610] - packages: [2] ‘stats’, ‘datasets’
[11:01:35.610] getGlobalsAndPackages() ... DONE
[11:01:35.610] run() for ‘Future’ ...
[11:01:35.610] - state: ‘created’
[11:01:35.610] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:35.610] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:35.610] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:35.611]   - Field: ‘label’
[11:01:35.611]   - Field: ‘local’
[11:01:35.611]   - Field: ‘owner’
[11:01:35.611]   - Field: ‘envir’
[11:01:35.611]   - Field: ‘packages’
[11:01:35.611]   - Field: ‘gc’
[11:01:35.611]   - Field: ‘conditions’
[11:01:35.611]   - Field: ‘expr’
[11:01:35.611]   - Field: ‘uuid’
[11:01:35.611]   - Field: ‘seed’
[11:01:35.611]   - Field: ‘version’
[11:01:35.612]   - Field: ‘result’
[11:01:35.612]   - Field: ‘asynchronous’
[11:01:35.612]   - Field: ‘calls’
[11:01:35.612]   - Field: ‘globals’
[11:01:35.612]   - Field: ‘stdout’
[11:01:35.612]   - Field: ‘earlySignal’
[11:01:35.612]   - Field: ‘lazy’
[11:01:35.612]   - Field: ‘state’
[11:01:35.612] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:35.612] - Launch lazy future ...
[11:01:35.612] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[11:01:35.613] Packages needed by future strategies (n = 0): <none>
[11:01:35.613] {
[11:01:35.613]     {
[11:01:35.613]         {
[11:01:35.613]             ...future.startTime <- base::Sys.time()
[11:01:35.613]             {
[11:01:35.613]                 {
[11:01:35.613]                   {
[11:01:35.613]                     {
[11:01:35.613]                       base::local({
[11:01:35.613]                         has_future <- base::requireNamespace("future", 
[11:01:35.613]                           quietly = TRUE)
[11:01:35.613]                         if (has_future) {
[11:01:35.613]                           ns <- base::getNamespace("future")
[11:01:35.613]                           version <- ns[[".package"]][["version"]]
[11:01:35.613]                           if (is.null(version)) 
[11:01:35.613]                             version <- utils::packageVersion("future")
[11:01:35.613]                         }
[11:01:35.613]                         else {
[11:01:35.613]                           version <- NULL
[11:01:35.613]                         }
[11:01:35.613]                         if (!has_future || version < "1.8.0") {
[11:01:35.613]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.613]                             "", base::R.version$version.string), 
[11:01:35.613]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:35.613]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:35.613]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.613]                               "release", "version")], collapse = " "), 
[11:01:35.613]                             hostname = base::Sys.info()[["nodename"]])
[11:01:35.613]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.613]                             info)
[11:01:35.613]                           info <- base::paste(info, collapse = "; ")
[11:01:35.613]                           if (!has_future) {
[11:01:35.613]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.613]                               info)
[11:01:35.613]                           }
[11:01:35.613]                           else {
[11:01:35.613]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.613]                               info, version)
[11:01:35.613]                           }
[11:01:35.613]                           base::stop(msg)
[11:01:35.613]                         }
[11:01:35.613]                       })
[11:01:35.613]                     }
[11:01:35.613]                     base::local({
[11:01:35.613]                       for (pkg in c("stats", "datasets")) {
[11:01:35.613]                         base::loadNamespace(pkg)
[11:01:35.613]                         base::library(pkg, character.only = TRUE)
[11:01:35.613]                       }
[11:01:35.613]                     })
[11:01:35.613]                   }
[11:01:35.613]                   ...future.strategy.old <- future::plan("list")
[11:01:35.613]                   options(future.plan = NULL)
[11:01:35.613]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.613]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.613]                 }
[11:01:35.613]                 ...future.workdir <- getwd()
[11:01:35.613]             }
[11:01:35.613]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.613]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.613]         }
[11:01:35.613]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.613]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.613]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.613]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.613]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.613]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.613]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.613]             base::names(...future.oldOptions))
[11:01:35.613]     }
[11:01:35.613]     if (FALSE) {
[11:01:35.613]     }
[11:01:35.613]     else {
[11:01:35.613]         if (TRUE) {
[11:01:35.613]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.613]                 open = "w")
[11:01:35.613]         }
[11:01:35.613]         else {
[11:01:35.613]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.613]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.613]         }
[11:01:35.613]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.613]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.613]             base::sink(type = "output", split = FALSE)
[11:01:35.613]             base::close(...future.stdout)
[11:01:35.613]         }, add = TRUE)
[11:01:35.613]     }
[11:01:35.613]     ...future.frame <- base::sys.nframe()
[11:01:35.613]     ...future.conditions <- base::list()
[11:01:35.613]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.613]     if (FALSE) {
[11:01:35.613]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.613]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.613]     }
[11:01:35.613]     ...future.result <- base::tryCatch({
[11:01:35.613]         base::withCallingHandlers({
[11:01:35.613]             ...future.value <- base::withVisible(base::local({
[11:01:35.613]                 lm(dist ~ . + 0, data = cars)
[11:01:35.613]             }))
[11:01:35.613]             future::FutureResult(value = ...future.value$value, 
[11:01:35.613]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.613]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.613]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.613]                     ...future.globalenv.names))
[11:01:35.613]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.613]         }, condition = base::local({
[11:01:35.613]             c <- base::c
[11:01:35.613]             inherits <- base::inherits
[11:01:35.613]             invokeRestart <- base::invokeRestart
[11:01:35.613]             length <- base::length
[11:01:35.613]             list <- base::list
[11:01:35.613]             seq.int <- base::seq.int
[11:01:35.613]             signalCondition <- base::signalCondition
[11:01:35.613]             sys.calls <- base::sys.calls
[11:01:35.613]             `[[` <- base::`[[`
[11:01:35.613]             `+` <- base::`+`
[11:01:35.613]             `<<-` <- base::`<<-`
[11:01:35.613]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.613]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.613]                   3L)]
[11:01:35.613]             }
[11:01:35.613]             function(cond) {
[11:01:35.613]                 is_error <- inherits(cond, "error")
[11:01:35.613]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.613]                   NULL)
[11:01:35.613]                 if (is_error) {
[11:01:35.613]                   sessionInformation <- function() {
[11:01:35.613]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.613]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.613]                       search = base::search(), system = base::Sys.info())
[11:01:35.613]                   }
[11:01:35.613]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.613]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.613]                     cond$call), session = sessionInformation(), 
[11:01:35.613]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.613]                   signalCondition(cond)
[11:01:35.613]                 }
[11:01:35.613]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.613]                 "immediateCondition"))) {
[11:01:35.613]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.613]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.613]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.613]                   if (TRUE && !signal) {
[11:01:35.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.613]                     {
[11:01:35.613]                       inherits <- base::inherits
[11:01:35.613]                       invokeRestart <- base::invokeRestart
[11:01:35.613]                       is.null <- base::is.null
[11:01:35.613]                       muffled <- FALSE
[11:01:35.613]                       if (inherits(cond, "message")) {
[11:01:35.613]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.613]                         if (muffled) 
[11:01:35.613]                           invokeRestart("muffleMessage")
[11:01:35.613]                       }
[11:01:35.613]                       else if (inherits(cond, "warning")) {
[11:01:35.613]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.613]                         if (muffled) 
[11:01:35.613]                           invokeRestart("muffleWarning")
[11:01:35.613]                       }
[11:01:35.613]                       else if (inherits(cond, "condition")) {
[11:01:35.613]                         if (!is.null(pattern)) {
[11:01:35.613]                           computeRestarts <- base::computeRestarts
[11:01:35.613]                           grepl <- base::grepl
[11:01:35.613]                           restarts <- computeRestarts(cond)
[11:01:35.613]                           for (restart in restarts) {
[11:01:35.613]                             name <- restart$name
[11:01:35.613]                             if (is.null(name)) 
[11:01:35.613]                               next
[11:01:35.613]                             if (!grepl(pattern, name)) 
[11:01:35.613]                               next
[11:01:35.613]                             invokeRestart(restart)
[11:01:35.613]                             muffled <- TRUE
[11:01:35.613]                             break
[11:01:35.613]                           }
[11:01:35.613]                         }
[11:01:35.613]                       }
[11:01:35.613]                       invisible(muffled)
[11:01:35.613]                     }
[11:01:35.613]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.613]                   }
[11:01:35.613]                 }
[11:01:35.613]                 else {
[11:01:35.613]                   if (TRUE) {
[11:01:35.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.613]                     {
[11:01:35.613]                       inherits <- base::inherits
[11:01:35.613]                       invokeRestart <- base::invokeRestart
[11:01:35.613]                       is.null <- base::is.null
[11:01:35.613]                       muffled <- FALSE
[11:01:35.613]                       if (inherits(cond, "message")) {
[11:01:35.613]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.613]                         if (muffled) 
[11:01:35.613]                           invokeRestart("muffleMessage")
[11:01:35.613]                       }
[11:01:35.613]                       else if (inherits(cond, "warning")) {
[11:01:35.613]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.613]                         if (muffled) 
[11:01:35.613]                           invokeRestart("muffleWarning")
[11:01:35.613]                       }
[11:01:35.613]                       else if (inherits(cond, "condition")) {
[11:01:35.613]                         if (!is.null(pattern)) {
[11:01:35.613]                           computeRestarts <- base::computeRestarts
[11:01:35.613]                           grepl <- base::grepl
[11:01:35.613]                           restarts <- computeRestarts(cond)
[11:01:35.613]                           for (restart in restarts) {
[11:01:35.613]                             name <- restart$name
[11:01:35.613]                             if (is.null(name)) 
[11:01:35.613]                               next
[11:01:35.613]                             if (!grepl(pattern, name)) 
[11:01:35.613]                               next
[11:01:35.613]                             invokeRestart(restart)
[11:01:35.613]                             muffled <- TRUE
[11:01:35.613]                             break
[11:01:35.613]                           }
[11:01:35.613]                         }
[11:01:35.613]                       }
[11:01:35.613]                       invisible(muffled)
[11:01:35.613]                     }
[11:01:35.613]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.613]                   }
[11:01:35.613]                 }
[11:01:35.613]             }
[11:01:35.613]         }))
[11:01:35.613]     }, error = function(ex) {
[11:01:35.613]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.613]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.613]                 ...future.rng), started = ...future.startTime, 
[11:01:35.613]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.613]             version = "1.8"), class = "FutureResult")
[11:01:35.613]     }, finally = {
[11:01:35.613]         if (!identical(...future.workdir, getwd())) 
[11:01:35.613]             setwd(...future.workdir)
[11:01:35.613]         {
[11:01:35.613]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.613]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.613]             }
[11:01:35.613]             base::options(...future.oldOptions)
[11:01:35.613]             if (.Platform$OS.type == "windows") {
[11:01:35.613]                 old_names <- names(...future.oldEnvVars)
[11:01:35.613]                 envs <- base::Sys.getenv()
[11:01:35.613]                 names <- names(envs)
[11:01:35.613]                 common <- intersect(names, old_names)
[11:01:35.613]                 added <- setdiff(names, old_names)
[11:01:35.613]                 removed <- setdiff(old_names, names)
[11:01:35.613]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.613]                   envs[common]]
[11:01:35.613]                 NAMES <- toupper(changed)
[11:01:35.613]                 args <- list()
[11:01:35.613]                 for (kk in seq_along(NAMES)) {
[11:01:35.613]                   name <- changed[[kk]]
[11:01:35.613]                   NAME <- NAMES[[kk]]
[11:01:35.613]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.613]                     next
[11:01:35.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.613]                 }
[11:01:35.613]                 NAMES <- toupper(added)
[11:01:35.613]                 for (kk in seq_along(NAMES)) {
[11:01:35.613]                   name <- added[[kk]]
[11:01:35.613]                   NAME <- NAMES[[kk]]
[11:01:35.613]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.613]                     next
[11:01:35.613]                   args[[name]] <- ""
[11:01:35.613]                 }
[11:01:35.613]                 NAMES <- toupper(removed)
[11:01:35.613]                 for (kk in seq_along(NAMES)) {
[11:01:35.613]                   name <- removed[[kk]]
[11:01:35.613]                   NAME <- NAMES[[kk]]
[11:01:35.613]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.613]                     next
[11:01:35.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.613]                 }
[11:01:35.613]                 if (length(args) > 0) 
[11:01:35.613]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.613]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.613]             }
[11:01:35.613]             else {
[11:01:35.613]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.613]             }
[11:01:35.613]             {
[11:01:35.613]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.613]                   0L) {
[11:01:35.613]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.613]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.613]                   base::options(opts)
[11:01:35.613]                 }
[11:01:35.613]                 {
[11:01:35.613]                   {
[11:01:35.613]                     NULL
[11:01:35.613]                     RNGkind("Mersenne-Twister")
[11:01:35.613]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:35.613]                       inherits = FALSE)
[11:01:35.613]                   }
[11:01:35.613]                   options(future.plan = NULL)
[11:01:35.613]                   if (is.na(NA_character_)) 
[11:01:35.613]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.613]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.613]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.613]                     .init = FALSE)
[11:01:35.613]                 }
[11:01:35.613]             }
[11:01:35.613]         }
[11:01:35.613]     })
[11:01:35.613]     if (TRUE) {
[11:01:35.613]         base::sink(type = "output", split = FALSE)
[11:01:35.613]         if (TRUE) {
[11:01:35.613]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.613]         }
[11:01:35.613]         else {
[11:01:35.613]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.613]         }
[11:01:35.613]         base::close(...future.stdout)
[11:01:35.613]         ...future.stdout <- NULL
[11:01:35.613]     }
[11:01:35.613]     ...future.result$conditions <- ...future.conditions
[11:01:35.613]     ...future.result$finished <- base::Sys.time()
[11:01:35.613]     ...future.result
[11:01:35.613] }
[11:01:35.615] plan(): Setting new future strategy stack:
[11:01:35.615] List of future strategies:
[11:01:35.615] 1. sequential:
[11:01:35.615]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.615]    - tweaked: FALSE
[11:01:35.615]    - call: NULL
[11:01:35.615] plan(): nbrOfWorkers() = 1
[11:01:35.617] plan(): Setting new future strategy stack:
[11:01:35.617] List of future strategies:
[11:01:35.617] 1. sequential:
[11:01:35.617]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.617]    - tweaked: FALSE
[11:01:35.617]    - call: plan(strategy)
[11:01:35.617] plan(): nbrOfWorkers() = 1
[11:01:35.617] SequentialFuture started (and completed)
[11:01:35.617] - Launch lazy future ... done
[11:01:35.617] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[11:01:35.619] getGlobalsAndPackages() ...
[11:01:35.620] Searching for globals...
[11:01:35.622] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[11:01:35.622] Searching for globals ... DONE
[11:01:35.622] Resolving globals: FALSE
[11:01:35.623] 
[11:01:35.623] - packages: [2] ‘stats’, ‘datasets’
[11:01:35.623] getGlobalsAndPackages() ... DONE
[11:01:35.623] run() for ‘Future’ ...
[11:01:35.623] - state: ‘created’
[11:01:35.623] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:35.624] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:35.624] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:35.624]   - Field: ‘label’
[11:01:35.624]   - Field: ‘local’
[11:01:35.624]   - Field: ‘owner’
[11:01:35.624]   - Field: ‘envir’
[11:01:35.624]   - Field: ‘packages’
[11:01:35.624]   - Field: ‘gc’
[11:01:35.624]   - Field: ‘conditions’
[11:01:35.624]   - Field: ‘expr’
[11:01:35.624]   - Field: ‘uuid’
[11:01:35.624]   - Field: ‘seed’
[11:01:35.625]   - Field: ‘version’
[11:01:35.625]   - Field: ‘result’
[11:01:35.625]   - Field: ‘asynchronous’
[11:01:35.625]   - Field: ‘calls’
[11:01:35.625]   - Field: ‘globals’
[11:01:35.625]   - Field: ‘stdout’
[11:01:35.625]   - Field: ‘earlySignal’
[11:01:35.625]   - Field: ‘lazy’
[11:01:35.625]   - Field: ‘state’
[11:01:35.625] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:35.625] - Launch lazy future ...
[11:01:35.625] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[11:01:35.626] Packages needed by future strategies (n = 0): <none>
[11:01:35.626] {
[11:01:35.626]     {
[11:01:35.626]         {
[11:01:35.626]             ...future.startTime <- base::Sys.time()
[11:01:35.626]             {
[11:01:35.626]                 {
[11:01:35.626]                   {
[11:01:35.626]                     {
[11:01:35.626]                       base::local({
[11:01:35.626]                         has_future <- base::requireNamespace("future", 
[11:01:35.626]                           quietly = TRUE)
[11:01:35.626]                         if (has_future) {
[11:01:35.626]                           ns <- base::getNamespace("future")
[11:01:35.626]                           version <- ns[[".package"]][["version"]]
[11:01:35.626]                           if (is.null(version)) 
[11:01:35.626]                             version <- utils::packageVersion("future")
[11:01:35.626]                         }
[11:01:35.626]                         else {
[11:01:35.626]                           version <- NULL
[11:01:35.626]                         }
[11:01:35.626]                         if (!has_future || version < "1.8.0") {
[11:01:35.626]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.626]                             "", base::R.version$version.string), 
[11:01:35.626]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:35.626]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:35.626]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.626]                               "release", "version")], collapse = " "), 
[11:01:35.626]                             hostname = base::Sys.info()[["nodename"]])
[11:01:35.626]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.626]                             info)
[11:01:35.626]                           info <- base::paste(info, collapse = "; ")
[11:01:35.626]                           if (!has_future) {
[11:01:35.626]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.626]                               info)
[11:01:35.626]                           }
[11:01:35.626]                           else {
[11:01:35.626]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.626]                               info, version)
[11:01:35.626]                           }
[11:01:35.626]                           base::stop(msg)
[11:01:35.626]                         }
[11:01:35.626]                       })
[11:01:35.626]                     }
[11:01:35.626]                     base::local({
[11:01:35.626]                       for (pkg in c("stats", "datasets")) {
[11:01:35.626]                         base::loadNamespace(pkg)
[11:01:35.626]                         base::library(pkg, character.only = TRUE)
[11:01:35.626]                       }
[11:01:35.626]                     })
[11:01:35.626]                   }
[11:01:35.626]                   ...future.strategy.old <- future::plan("list")
[11:01:35.626]                   options(future.plan = NULL)
[11:01:35.626]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.626]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.626]                 }
[11:01:35.626]                 ...future.workdir <- getwd()
[11:01:35.626]             }
[11:01:35.626]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.626]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.626]         }
[11:01:35.626]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.626]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.626]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.626]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.626]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.626]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.626]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.626]             base::names(...future.oldOptions))
[11:01:35.626]     }
[11:01:35.626]     if (FALSE) {
[11:01:35.626]     }
[11:01:35.626]     else {
[11:01:35.626]         if (TRUE) {
[11:01:35.626]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.626]                 open = "w")
[11:01:35.626]         }
[11:01:35.626]         else {
[11:01:35.626]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.626]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.626]         }
[11:01:35.626]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.626]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.626]             base::sink(type = "output", split = FALSE)
[11:01:35.626]             base::close(...future.stdout)
[11:01:35.626]         }, add = TRUE)
[11:01:35.626]     }
[11:01:35.626]     ...future.frame <- base::sys.nframe()
[11:01:35.626]     ...future.conditions <- base::list()
[11:01:35.626]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.626]     if (FALSE) {
[11:01:35.626]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.626]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.626]     }
[11:01:35.626]     ...future.result <- base::tryCatch({
[11:01:35.626]         base::withCallingHandlers({
[11:01:35.626]             ...future.value <- base::withVisible(base::local({
[11:01:35.626]                 lm(dist ~ speed + speed^2, data = cars)
[11:01:35.626]             }))
[11:01:35.626]             future::FutureResult(value = ...future.value$value, 
[11:01:35.626]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.626]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.626]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.626]                     ...future.globalenv.names))
[11:01:35.626]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.626]         }, condition = base::local({
[11:01:35.626]             c <- base::c
[11:01:35.626]             inherits <- base::inherits
[11:01:35.626]             invokeRestart <- base::invokeRestart
[11:01:35.626]             length <- base::length
[11:01:35.626]             list <- base::list
[11:01:35.626]             seq.int <- base::seq.int
[11:01:35.626]             signalCondition <- base::signalCondition
[11:01:35.626]             sys.calls <- base::sys.calls
[11:01:35.626]             `[[` <- base::`[[`
[11:01:35.626]             `+` <- base::`+`
[11:01:35.626]             `<<-` <- base::`<<-`
[11:01:35.626]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.626]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.626]                   3L)]
[11:01:35.626]             }
[11:01:35.626]             function(cond) {
[11:01:35.626]                 is_error <- inherits(cond, "error")
[11:01:35.626]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.626]                   NULL)
[11:01:35.626]                 if (is_error) {
[11:01:35.626]                   sessionInformation <- function() {
[11:01:35.626]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.626]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.626]                       search = base::search(), system = base::Sys.info())
[11:01:35.626]                   }
[11:01:35.626]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.626]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.626]                     cond$call), session = sessionInformation(), 
[11:01:35.626]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.626]                   signalCondition(cond)
[11:01:35.626]                 }
[11:01:35.626]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.626]                 "immediateCondition"))) {
[11:01:35.626]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.626]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.626]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.626]                   if (TRUE && !signal) {
[11:01:35.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.626]                     {
[11:01:35.626]                       inherits <- base::inherits
[11:01:35.626]                       invokeRestart <- base::invokeRestart
[11:01:35.626]                       is.null <- base::is.null
[11:01:35.626]                       muffled <- FALSE
[11:01:35.626]                       if (inherits(cond, "message")) {
[11:01:35.626]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.626]                         if (muffled) 
[11:01:35.626]                           invokeRestart("muffleMessage")
[11:01:35.626]                       }
[11:01:35.626]                       else if (inherits(cond, "warning")) {
[11:01:35.626]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.626]                         if (muffled) 
[11:01:35.626]                           invokeRestart("muffleWarning")
[11:01:35.626]                       }
[11:01:35.626]                       else if (inherits(cond, "condition")) {
[11:01:35.626]                         if (!is.null(pattern)) {
[11:01:35.626]                           computeRestarts <- base::computeRestarts
[11:01:35.626]                           grepl <- base::grepl
[11:01:35.626]                           restarts <- computeRestarts(cond)
[11:01:35.626]                           for (restart in restarts) {
[11:01:35.626]                             name <- restart$name
[11:01:35.626]                             if (is.null(name)) 
[11:01:35.626]                               next
[11:01:35.626]                             if (!grepl(pattern, name)) 
[11:01:35.626]                               next
[11:01:35.626]                             invokeRestart(restart)
[11:01:35.626]                             muffled <- TRUE
[11:01:35.626]                             break
[11:01:35.626]                           }
[11:01:35.626]                         }
[11:01:35.626]                       }
[11:01:35.626]                       invisible(muffled)
[11:01:35.626]                     }
[11:01:35.626]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.626]                   }
[11:01:35.626]                 }
[11:01:35.626]                 else {
[11:01:35.626]                   if (TRUE) {
[11:01:35.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.626]                     {
[11:01:35.626]                       inherits <- base::inherits
[11:01:35.626]                       invokeRestart <- base::invokeRestart
[11:01:35.626]                       is.null <- base::is.null
[11:01:35.626]                       muffled <- FALSE
[11:01:35.626]                       if (inherits(cond, "message")) {
[11:01:35.626]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.626]                         if (muffled) 
[11:01:35.626]                           invokeRestart("muffleMessage")
[11:01:35.626]                       }
[11:01:35.626]                       else if (inherits(cond, "warning")) {
[11:01:35.626]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.626]                         if (muffled) 
[11:01:35.626]                           invokeRestart("muffleWarning")
[11:01:35.626]                       }
[11:01:35.626]                       else if (inherits(cond, "condition")) {
[11:01:35.626]                         if (!is.null(pattern)) {
[11:01:35.626]                           computeRestarts <- base::computeRestarts
[11:01:35.626]                           grepl <- base::grepl
[11:01:35.626]                           restarts <- computeRestarts(cond)
[11:01:35.626]                           for (restart in restarts) {
[11:01:35.626]                             name <- restart$name
[11:01:35.626]                             if (is.null(name)) 
[11:01:35.626]                               next
[11:01:35.626]                             if (!grepl(pattern, name)) 
[11:01:35.626]                               next
[11:01:35.626]                             invokeRestart(restart)
[11:01:35.626]                             muffled <- TRUE
[11:01:35.626]                             break
[11:01:35.626]                           }
[11:01:35.626]                         }
[11:01:35.626]                       }
[11:01:35.626]                       invisible(muffled)
[11:01:35.626]                     }
[11:01:35.626]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.626]                   }
[11:01:35.626]                 }
[11:01:35.626]             }
[11:01:35.626]         }))
[11:01:35.626]     }, error = function(ex) {
[11:01:35.626]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.626]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.626]                 ...future.rng), started = ...future.startTime, 
[11:01:35.626]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.626]             version = "1.8"), class = "FutureResult")
[11:01:35.626]     }, finally = {
[11:01:35.626]         if (!identical(...future.workdir, getwd())) 
[11:01:35.626]             setwd(...future.workdir)
[11:01:35.626]         {
[11:01:35.626]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.626]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.626]             }
[11:01:35.626]             base::options(...future.oldOptions)
[11:01:35.626]             if (.Platform$OS.type == "windows") {
[11:01:35.626]                 old_names <- names(...future.oldEnvVars)
[11:01:35.626]                 envs <- base::Sys.getenv()
[11:01:35.626]                 names <- names(envs)
[11:01:35.626]                 common <- intersect(names, old_names)
[11:01:35.626]                 added <- setdiff(names, old_names)
[11:01:35.626]                 removed <- setdiff(old_names, names)
[11:01:35.626]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.626]                   envs[common]]
[11:01:35.626]                 NAMES <- toupper(changed)
[11:01:35.626]                 args <- list()
[11:01:35.626]                 for (kk in seq_along(NAMES)) {
[11:01:35.626]                   name <- changed[[kk]]
[11:01:35.626]                   NAME <- NAMES[[kk]]
[11:01:35.626]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.626]                     next
[11:01:35.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.626]                 }
[11:01:35.626]                 NAMES <- toupper(added)
[11:01:35.626]                 for (kk in seq_along(NAMES)) {
[11:01:35.626]                   name <- added[[kk]]
[11:01:35.626]                   NAME <- NAMES[[kk]]
[11:01:35.626]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.626]                     next
[11:01:35.626]                   args[[name]] <- ""
[11:01:35.626]                 }
[11:01:35.626]                 NAMES <- toupper(removed)
[11:01:35.626]                 for (kk in seq_along(NAMES)) {
[11:01:35.626]                   name <- removed[[kk]]
[11:01:35.626]                   NAME <- NAMES[[kk]]
[11:01:35.626]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.626]                     next
[11:01:35.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.626]                 }
[11:01:35.626]                 if (length(args) > 0) 
[11:01:35.626]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.626]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.626]             }
[11:01:35.626]             else {
[11:01:35.626]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.626]             }
[11:01:35.626]             {
[11:01:35.626]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.626]                   0L) {
[11:01:35.626]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.626]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.626]                   base::options(opts)
[11:01:35.626]                 }
[11:01:35.626]                 {
[11:01:35.626]                   {
[11:01:35.626]                     NULL
[11:01:35.626]                     RNGkind("Mersenne-Twister")
[11:01:35.626]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:35.626]                       inherits = FALSE)
[11:01:35.626]                   }
[11:01:35.626]                   options(future.plan = NULL)
[11:01:35.626]                   if (is.na(NA_character_)) 
[11:01:35.626]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.626]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.626]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.626]                     .init = FALSE)
[11:01:35.626]                 }
[11:01:35.626]             }
[11:01:35.626]         }
[11:01:35.626]     })
[11:01:35.626]     if (TRUE) {
[11:01:35.626]         base::sink(type = "output", split = FALSE)
[11:01:35.626]         if (TRUE) {
[11:01:35.626]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.626]         }
[11:01:35.626]         else {
[11:01:35.626]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.626]         }
[11:01:35.626]         base::close(...future.stdout)
[11:01:35.626]         ...future.stdout <- NULL
[11:01:35.626]     }
[11:01:35.626]     ...future.result$conditions <- ...future.conditions
[11:01:35.626]     ...future.result$finished <- base::Sys.time()
[11:01:35.626]     ...future.result
[11:01:35.626] }
[11:01:35.628] plan(): Setting new future strategy stack:
[11:01:35.628] List of future strategies:
[11:01:35.628] 1. sequential:
[11:01:35.628]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.628]    - tweaked: FALSE
[11:01:35.628]    - call: NULL
[11:01:35.628] plan(): nbrOfWorkers() = 1
[11:01:35.630] plan(): Setting new future strategy stack:
[11:01:35.630] List of future strategies:
[11:01:35.630] 1. sequential:
[11:01:35.630]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.630]    - tweaked: FALSE
[11:01:35.630]    - call: plan(strategy)
[11:01:35.630] plan(): nbrOfWorkers() = 1
[11:01:35.630] SequentialFuture started (and completed)
[11:01:35.630] - Launch lazy future ... done
[11:01:35.630] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[11:01:35.633] getGlobalsAndPackages() ...
[11:01:35.633] Searching for globals...
[11:01:35.634] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[11:01:35.635] Searching for globals ... DONE
[11:01:35.635] Resolving globals: FALSE
[11:01:35.635] 
[11:01:35.635] - packages: [2] ‘stats’, ‘datasets’
[11:01:35.635] getGlobalsAndPackages() ... DONE
[11:01:35.636] run() for ‘Future’ ...
[11:01:35.636] - state: ‘created’
[11:01:35.636] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:35.636] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:35.636] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:35.636]   - Field: ‘label’
[11:01:35.636]   - Field: ‘local’
[11:01:35.636]   - Field: ‘owner’
[11:01:35.637]   - Field: ‘envir’
[11:01:35.637]   - Field: ‘packages’
[11:01:35.637]   - Field: ‘gc’
[11:01:35.637]   - Field: ‘conditions’
[11:01:35.637]   - Field: ‘expr’
[11:01:35.637]   - Field: ‘uuid’
[11:01:35.637]   - Field: ‘seed’
[11:01:35.637]   - Field: ‘version’
[11:01:35.637]   - Field: ‘result’
[11:01:35.637]   - Field: ‘asynchronous’
[11:01:35.637]   - Field: ‘calls’
[11:01:35.637]   - Field: ‘globals’
[11:01:35.637]   - Field: ‘stdout’
[11:01:35.638]   - Field: ‘earlySignal’
[11:01:35.638]   - Field: ‘lazy’
[11:01:35.638]   - Field: ‘state’
[11:01:35.638] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:35.638] - Launch lazy future ...
[11:01:35.638] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[11:01:35.638] Packages needed by future strategies (n = 0): <none>
[11:01:35.639] {
[11:01:35.639]     {
[11:01:35.639]         {
[11:01:35.639]             ...future.startTime <- base::Sys.time()
[11:01:35.639]             {
[11:01:35.639]                 {
[11:01:35.639]                   {
[11:01:35.639]                     {
[11:01:35.639]                       base::local({
[11:01:35.639]                         has_future <- base::requireNamespace("future", 
[11:01:35.639]                           quietly = TRUE)
[11:01:35.639]                         if (has_future) {
[11:01:35.639]                           ns <- base::getNamespace("future")
[11:01:35.639]                           version <- ns[[".package"]][["version"]]
[11:01:35.639]                           if (is.null(version)) 
[11:01:35.639]                             version <- utils::packageVersion("future")
[11:01:35.639]                         }
[11:01:35.639]                         else {
[11:01:35.639]                           version <- NULL
[11:01:35.639]                         }
[11:01:35.639]                         if (!has_future || version < "1.8.0") {
[11:01:35.639]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.639]                             "", base::R.version$version.string), 
[11:01:35.639]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:35.639]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:35.639]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.639]                               "release", "version")], collapse = " "), 
[11:01:35.639]                             hostname = base::Sys.info()[["nodename"]])
[11:01:35.639]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.639]                             info)
[11:01:35.639]                           info <- base::paste(info, collapse = "; ")
[11:01:35.639]                           if (!has_future) {
[11:01:35.639]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.639]                               info)
[11:01:35.639]                           }
[11:01:35.639]                           else {
[11:01:35.639]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.639]                               info, version)
[11:01:35.639]                           }
[11:01:35.639]                           base::stop(msg)
[11:01:35.639]                         }
[11:01:35.639]                       })
[11:01:35.639]                     }
[11:01:35.639]                     base::local({
[11:01:35.639]                       for (pkg in c("stats", "datasets")) {
[11:01:35.639]                         base::loadNamespace(pkg)
[11:01:35.639]                         base::library(pkg, character.only = TRUE)
[11:01:35.639]                       }
[11:01:35.639]                     })
[11:01:35.639]                   }
[11:01:35.639]                   ...future.strategy.old <- future::plan("list")
[11:01:35.639]                   options(future.plan = NULL)
[11:01:35.639]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.639]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.639]                 }
[11:01:35.639]                 ...future.workdir <- getwd()
[11:01:35.639]             }
[11:01:35.639]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.639]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.639]         }
[11:01:35.639]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.639]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.639]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.639]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.639]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.639]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.639]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.639]             base::names(...future.oldOptions))
[11:01:35.639]     }
[11:01:35.639]     if (FALSE) {
[11:01:35.639]     }
[11:01:35.639]     else {
[11:01:35.639]         if (TRUE) {
[11:01:35.639]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.639]                 open = "w")
[11:01:35.639]         }
[11:01:35.639]         else {
[11:01:35.639]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.639]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.639]         }
[11:01:35.639]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.639]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.639]             base::sink(type = "output", split = FALSE)
[11:01:35.639]             base::close(...future.stdout)
[11:01:35.639]         }, add = TRUE)
[11:01:35.639]     }
[11:01:35.639]     ...future.frame <- base::sys.nframe()
[11:01:35.639]     ...future.conditions <- base::list()
[11:01:35.639]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.639]     if (FALSE) {
[11:01:35.639]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.639]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.639]     }
[11:01:35.639]     ...future.result <- base::tryCatch({
[11:01:35.639]         base::withCallingHandlers({
[11:01:35.639]             ...future.value <- base::withVisible(base::local({
[11:01:35.639]                 lm(dist ~ speed + I(speed^2), data = cars)
[11:01:35.639]             }))
[11:01:35.639]             future::FutureResult(value = ...future.value$value, 
[11:01:35.639]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.639]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.639]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.639]                     ...future.globalenv.names))
[11:01:35.639]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.639]         }, condition = base::local({
[11:01:35.639]             c <- base::c
[11:01:35.639]             inherits <- base::inherits
[11:01:35.639]             invokeRestart <- base::invokeRestart
[11:01:35.639]             length <- base::length
[11:01:35.639]             list <- base::list
[11:01:35.639]             seq.int <- base::seq.int
[11:01:35.639]             signalCondition <- base::signalCondition
[11:01:35.639]             sys.calls <- base::sys.calls
[11:01:35.639]             `[[` <- base::`[[`
[11:01:35.639]             `+` <- base::`+`
[11:01:35.639]             `<<-` <- base::`<<-`
[11:01:35.639]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.639]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.639]                   3L)]
[11:01:35.639]             }
[11:01:35.639]             function(cond) {
[11:01:35.639]                 is_error <- inherits(cond, "error")
[11:01:35.639]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.639]                   NULL)
[11:01:35.639]                 if (is_error) {
[11:01:35.639]                   sessionInformation <- function() {
[11:01:35.639]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.639]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.639]                       search = base::search(), system = base::Sys.info())
[11:01:35.639]                   }
[11:01:35.639]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.639]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.639]                     cond$call), session = sessionInformation(), 
[11:01:35.639]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.639]                   signalCondition(cond)
[11:01:35.639]                 }
[11:01:35.639]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.639]                 "immediateCondition"))) {
[11:01:35.639]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.639]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.639]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.639]                   if (TRUE && !signal) {
[11:01:35.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.639]                     {
[11:01:35.639]                       inherits <- base::inherits
[11:01:35.639]                       invokeRestart <- base::invokeRestart
[11:01:35.639]                       is.null <- base::is.null
[11:01:35.639]                       muffled <- FALSE
[11:01:35.639]                       if (inherits(cond, "message")) {
[11:01:35.639]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.639]                         if (muffled) 
[11:01:35.639]                           invokeRestart("muffleMessage")
[11:01:35.639]                       }
[11:01:35.639]                       else if (inherits(cond, "warning")) {
[11:01:35.639]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.639]                         if (muffled) 
[11:01:35.639]                           invokeRestart("muffleWarning")
[11:01:35.639]                       }
[11:01:35.639]                       else if (inherits(cond, "condition")) {
[11:01:35.639]                         if (!is.null(pattern)) {
[11:01:35.639]                           computeRestarts <- base::computeRestarts
[11:01:35.639]                           grepl <- base::grepl
[11:01:35.639]                           restarts <- computeRestarts(cond)
[11:01:35.639]                           for (restart in restarts) {
[11:01:35.639]                             name <- restart$name
[11:01:35.639]                             if (is.null(name)) 
[11:01:35.639]                               next
[11:01:35.639]                             if (!grepl(pattern, name)) 
[11:01:35.639]                               next
[11:01:35.639]                             invokeRestart(restart)
[11:01:35.639]                             muffled <- TRUE
[11:01:35.639]                             break
[11:01:35.639]                           }
[11:01:35.639]                         }
[11:01:35.639]                       }
[11:01:35.639]                       invisible(muffled)
[11:01:35.639]                     }
[11:01:35.639]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.639]                   }
[11:01:35.639]                 }
[11:01:35.639]                 else {
[11:01:35.639]                   if (TRUE) {
[11:01:35.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.639]                     {
[11:01:35.639]                       inherits <- base::inherits
[11:01:35.639]                       invokeRestart <- base::invokeRestart
[11:01:35.639]                       is.null <- base::is.null
[11:01:35.639]                       muffled <- FALSE
[11:01:35.639]                       if (inherits(cond, "message")) {
[11:01:35.639]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.639]                         if (muffled) 
[11:01:35.639]                           invokeRestart("muffleMessage")
[11:01:35.639]                       }
[11:01:35.639]                       else if (inherits(cond, "warning")) {
[11:01:35.639]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.639]                         if (muffled) 
[11:01:35.639]                           invokeRestart("muffleWarning")
[11:01:35.639]                       }
[11:01:35.639]                       else if (inherits(cond, "condition")) {
[11:01:35.639]                         if (!is.null(pattern)) {
[11:01:35.639]                           computeRestarts <- base::computeRestarts
[11:01:35.639]                           grepl <- base::grepl
[11:01:35.639]                           restarts <- computeRestarts(cond)
[11:01:35.639]                           for (restart in restarts) {
[11:01:35.639]                             name <- restart$name
[11:01:35.639]                             if (is.null(name)) 
[11:01:35.639]                               next
[11:01:35.639]                             if (!grepl(pattern, name)) 
[11:01:35.639]                               next
[11:01:35.639]                             invokeRestart(restart)
[11:01:35.639]                             muffled <- TRUE
[11:01:35.639]                             break
[11:01:35.639]                           }
[11:01:35.639]                         }
[11:01:35.639]                       }
[11:01:35.639]                       invisible(muffled)
[11:01:35.639]                     }
[11:01:35.639]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.639]                   }
[11:01:35.639]                 }
[11:01:35.639]             }
[11:01:35.639]         }))
[11:01:35.639]     }, error = function(ex) {
[11:01:35.639]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.639]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.639]                 ...future.rng), started = ...future.startTime, 
[11:01:35.639]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.639]             version = "1.8"), class = "FutureResult")
[11:01:35.639]     }, finally = {
[11:01:35.639]         if (!identical(...future.workdir, getwd())) 
[11:01:35.639]             setwd(...future.workdir)
[11:01:35.639]         {
[11:01:35.639]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.639]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.639]             }
[11:01:35.639]             base::options(...future.oldOptions)
[11:01:35.639]             if (.Platform$OS.type == "windows") {
[11:01:35.639]                 old_names <- names(...future.oldEnvVars)
[11:01:35.639]                 envs <- base::Sys.getenv()
[11:01:35.639]                 names <- names(envs)
[11:01:35.639]                 common <- intersect(names, old_names)
[11:01:35.639]                 added <- setdiff(names, old_names)
[11:01:35.639]                 removed <- setdiff(old_names, names)
[11:01:35.639]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.639]                   envs[common]]
[11:01:35.639]                 NAMES <- toupper(changed)
[11:01:35.639]                 args <- list()
[11:01:35.639]                 for (kk in seq_along(NAMES)) {
[11:01:35.639]                   name <- changed[[kk]]
[11:01:35.639]                   NAME <- NAMES[[kk]]
[11:01:35.639]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.639]                     next
[11:01:35.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.639]                 }
[11:01:35.639]                 NAMES <- toupper(added)
[11:01:35.639]                 for (kk in seq_along(NAMES)) {
[11:01:35.639]                   name <- added[[kk]]
[11:01:35.639]                   NAME <- NAMES[[kk]]
[11:01:35.639]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.639]                     next
[11:01:35.639]                   args[[name]] <- ""
[11:01:35.639]                 }
[11:01:35.639]                 NAMES <- toupper(removed)
[11:01:35.639]                 for (kk in seq_along(NAMES)) {
[11:01:35.639]                   name <- removed[[kk]]
[11:01:35.639]                   NAME <- NAMES[[kk]]
[11:01:35.639]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.639]                     next
[11:01:35.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.639]                 }
[11:01:35.639]                 if (length(args) > 0) 
[11:01:35.639]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.639]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.639]             }
[11:01:35.639]             else {
[11:01:35.639]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.639]             }
[11:01:35.639]             {
[11:01:35.639]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.639]                   0L) {
[11:01:35.639]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.639]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.639]                   base::options(opts)
[11:01:35.639]                 }
[11:01:35.639]                 {
[11:01:35.639]                   {
[11:01:35.639]                     NULL
[11:01:35.639]                     RNGkind("Mersenne-Twister")
[11:01:35.639]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:35.639]                       inherits = FALSE)
[11:01:35.639]                   }
[11:01:35.639]                   options(future.plan = NULL)
[11:01:35.639]                   if (is.na(NA_character_)) 
[11:01:35.639]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.639]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.639]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.639]                     .init = FALSE)
[11:01:35.639]                 }
[11:01:35.639]             }
[11:01:35.639]         }
[11:01:35.639]     })
[11:01:35.639]     if (TRUE) {
[11:01:35.639]         base::sink(type = "output", split = FALSE)
[11:01:35.639]         if (TRUE) {
[11:01:35.639]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.639]         }
[11:01:35.639]         else {
[11:01:35.639]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.639]         }
[11:01:35.639]         base::close(...future.stdout)
[11:01:35.639]         ...future.stdout <- NULL
[11:01:35.639]     }
[11:01:35.639]     ...future.result$conditions <- ...future.conditions
[11:01:35.639]     ...future.result$finished <- base::Sys.time()
[11:01:35.639]     ...future.result
[11:01:35.639] }
[11:01:35.640] plan(): Setting new future strategy stack:
[11:01:35.641] List of future strategies:
[11:01:35.641] 1. sequential:
[11:01:35.641]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.641]    - tweaked: FALSE
[11:01:35.641]    - call: NULL
[11:01:35.641] plan(): nbrOfWorkers() = 1
[11:01:35.642] plan(): Setting new future strategy stack:
[11:01:35.642] List of future strategies:
[11:01:35.642] 1. sequential:
[11:01:35.642]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.642]    - tweaked: FALSE
[11:01:35.642]    - call: plan(strategy)
[11:01:35.643] plan(): nbrOfWorkers() = 1
[11:01:35.643] SequentialFuture started (and completed)
[11:01:35.643] - Launch lazy future ... done
[11:01:35.644] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[11:01:35.647] getGlobalsAndPackages() ...
[11:01:35.647] Searching for globals...
[11:01:35.648] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[11:01:35.649] Searching for globals ... DONE
[11:01:35.649] Resolving globals: FALSE
[11:01:35.649] 
[11:01:35.649] - packages: [2] ‘stats’, ‘datasets’
[11:01:35.649] getGlobalsAndPackages() ... DONE
[11:01:35.649] run() for ‘Future’ ...
[11:01:35.650] - state: ‘created’
[11:01:35.650] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:35.650] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:35.650] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:35.650]   - Field: ‘label’
[11:01:35.650]   - Field: ‘local’
[11:01:35.650]   - Field: ‘owner’
[11:01:35.650]   - Field: ‘envir’
[11:01:35.650]   - Field: ‘packages’
[11:01:35.651]   - Field: ‘gc’
[11:01:35.651]   - Field: ‘conditions’
[11:01:35.651]   - Field: ‘expr’
[11:01:35.651]   - Field: ‘uuid’
[11:01:35.651]   - Field: ‘seed’
[11:01:35.651]   - Field: ‘version’
[11:01:35.651]   - Field: ‘result’
[11:01:35.651]   - Field: ‘asynchronous’
[11:01:35.651]   - Field: ‘calls’
[11:01:35.651]   - Field: ‘globals’
[11:01:35.651]   - Field: ‘stdout’
[11:01:35.651]   - Field: ‘earlySignal’
[11:01:35.651]   - Field: ‘lazy’
[11:01:35.652]   - Field: ‘state’
[11:01:35.652] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:35.652] - Launch lazy future ...
[11:01:35.652] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[11:01:35.652] Packages needed by future strategies (n = 0): <none>
[11:01:35.652] {
[11:01:35.652]     {
[11:01:35.652]         {
[11:01:35.652]             ...future.startTime <- base::Sys.time()
[11:01:35.652]             {
[11:01:35.652]                 {
[11:01:35.652]                   {
[11:01:35.652]                     {
[11:01:35.652]                       base::local({
[11:01:35.652]                         has_future <- base::requireNamespace("future", 
[11:01:35.652]                           quietly = TRUE)
[11:01:35.652]                         if (has_future) {
[11:01:35.652]                           ns <- base::getNamespace("future")
[11:01:35.652]                           version <- ns[[".package"]][["version"]]
[11:01:35.652]                           if (is.null(version)) 
[11:01:35.652]                             version <- utils::packageVersion("future")
[11:01:35.652]                         }
[11:01:35.652]                         else {
[11:01:35.652]                           version <- NULL
[11:01:35.652]                         }
[11:01:35.652]                         if (!has_future || version < "1.8.0") {
[11:01:35.652]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.652]                             "", base::R.version$version.string), 
[11:01:35.652]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:35.652]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:35.652]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.652]                               "release", "version")], collapse = " "), 
[11:01:35.652]                             hostname = base::Sys.info()[["nodename"]])
[11:01:35.652]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.652]                             info)
[11:01:35.652]                           info <- base::paste(info, collapse = "; ")
[11:01:35.652]                           if (!has_future) {
[11:01:35.652]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.652]                               info)
[11:01:35.652]                           }
[11:01:35.652]                           else {
[11:01:35.652]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.652]                               info, version)
[11:01:35.652]                           }
[11:01:35.652]                           base::stop(msg)
[11:01:35.652]                         }
[11:01:35.652]                       })
[11:01:35.652]                     }
[11:01:35.652]                     base::local({
[11:01:35.652]                       for (pkg in c("stats", "datasets")) {
[11:01:35.652]                         base::loadNamespace(pkg)
[11:01:35.652]                         base::library(pkg, character.only = TRUE)
[11:01:35.652]                       }
[11:01:35.652]                     })
[11:01:35.652]                   }
[11:01:35.652]                   ...future.strategy.old <- future::plan("list")
[11:01:35.652]                   options(future.plan = NULL)
[11:01:35.652]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.652]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.652]                 }
[11:01:35.652]                 ...future.workdir <- getwd()
[11:01:35.652]             }
[11:01:35.652]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.652]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.652]         }
[11:01:35.652]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.652]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.652]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.652]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.652]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.652]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.652]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.652]             base::names(...future.oldOptions))
[11:01:35.652]     }
[11:01:35.652]     if (FALSE) {
[11:01:35.652]     }
[11:01:35.652]     else {
[11:01:35.652]         if (TRUE) {
[11:01:35.652]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.652]                 open = "w")
[11:01:35.652]         }
[11:01:35.652]         else {
[11:01:35.652]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.652]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.652]         }
[11:01:35.652]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.652]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.652]             base::sink(type = "output", split = FALSE)
[11:01:35.652]             base::close(...future.stdout)
[11:01:35.652]         }, add = TRUE)
[11:01:35.652]     }
[11:01:35.652]     ...future.frame <- base::sys.nframe()
[11:01:35.652]     ...future.conditions <- base::list()
[11:01:35.652]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.652]     if (FALSE) {
[11:01:35.652]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.652]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.652]     }
[11:01:35.652]     ...future.result <- base::tryCatch({
[11:01:35.652]         base::withCallingHandlers({
[11:01:35.652]             ...future.value <- base::withVisible(base::local({
[11:01:35.652]                 lm(dist ~ poly(speed, 2), data = cars)
[11:01:35.652]             }))
[11:01:35.652]             future::FutureResult(value = ...future.value$value, 
[11:01:35.652]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.652]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.652]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.652]                     ...future.globalenv.names))
[11:01:35.652]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.652]         }, condition = base::local({
[11:01:35.652]             c <- base::c
[11:01:35.652]             inherits <- base::inherits
[11:01:35.652]             invokeRestart <- base::invokeRestart
[11:01:35.652]             length <- base::length
[11:01:35.652]             list <- base::list
[11:01:35.652]             seq.int <- base::seq.int
[11:01:35.652]             signalCondition <- base::signalCondition
[11:01:35.652]             sys.calls <- base::sys.calls
[11:01:35.652]             `[[` <- base::`[[`
[11:01:35.652]             `+` <- base::`+`
[11:01:35.652]             `<<-` <- base::`<<-`
[11:01:35.652]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.652]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.652]                   3L)]
[11:01:35.652]             }
[11:01:35.652]             function(cond) {
[11:01:35.652]                 is_error <- inherits(cond, "error")
[11:01:35.652]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.652]                   NULL)
[11:01:35.652]                 if (is_error) {
[11:01:35.652]                   sessionInformation <- function() {
[11:01:35.652]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.652]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.652]                       search = base::search(), system = base::Sys.info())
[11:01:35.652]                   }
[11:01:35.652]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.652]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.652]                     cond$call), session = sessionInformation(), 
[11:01:35.652]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.652]                   signalCondition(cond)
[11:01:35.652]                 }
[11:01:35.652]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.652]                 "immediateCondition"))) {
[11:01:35.652]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.652]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.652]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.652]                   if (TRUE && !signal) {
[11:01:35.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.652]                     {
[11:01:35.652]                       inherits <- base::inherits
[11:01:35.652]                       invokeRestart <- base::invokeRestart
[11:01:35.652]                       is.null <- base::is.null
[11:01:35.652]                       muffled <- FALSE
[11:01:35.652]                       if (inherits(cond, "message")) {
[11:01:35.652]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.652]                         if (muffled) 
[11:01:35.652]                           invokeRestart("muffleMessage")
[11:01:35.652]                       }
[11:01:35.652]                       else if (inherits(cond, "warning")) {
[11:01:35.652]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.652]                         if (muffled) 
[11:01:35.652]                           invokeRestart("muffleWarning")
[11:01:35.652]                       }
[11:01:35.652]                       else if (inherits(cond, "condition")) {
[11:01:35.652]                         if (!is.null(pattern)) {
[11:01:35.652]                           computeRestarts <- base::computeRestarts
[11:01:35.652]                           grepl <- base::grepl
[11:01:35.652]                           restarts <- computeRestarts(cond)
[11:01:35.652]                           for (restart in restarts) {
[11:01:35.652]                             name <- restart$name
[11:01:35.652]                             if (is.null(name)) 
[11:01:35.652]                               next
[11:01:35.652]                             if (!grepl(pattern, name)) 
[11:01:35.652]                               next
[11:01:35.652]                             invokeRestart(restart)
[11:01:35.652]                             muffled <- TRUE
[11:01:35.652]                             break
[11:01:35.652]                           }
[11:01:35.652]                         }
[11:01:35.652]                       }
[11:01:35.652]                       invisible(muffled)
[11:01:35.652]                     }
[11:01:35.652]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.652]                   }
[11:01:35.652]                 }
[11:01:35.652]                 else {
[11:01:35.652]                   if (TRUE) {
[11:01:35.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.652]                     {
[11:01:35.652]                       inherits <- base::inherits
[11:01:35.652]                       invokeRestart <- base::invokeRestart
[11:01:35.652]                       is.null <- base::is.null
[11:01:35.652]                       muffled <- FALSE
[11:01:35.652]                       if (inherits(cond, "message")) {
[11:01:35.652]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.652]                         if (muffled) 
[11:01:35.652]                           invokeRestart("muffleMessage")
[11:01:35.652]                       }
[11:01:35.652]                       else if (inherits(cond, "warning")) {
[11:01:35.652]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.652]                         if (muffled) 
[11:01:35.652]                           invokeRestart("muffleWarning")
[11:01:35.652]                       }
[11:01:35.652]                       else if (inherits(cond, "condition")) {
[11:01:35.652]                         if (!is.null(pattern)) {
[11:01:35.652]                           computeRestarts <- base::computeRestarts
[11:01:35.652]                           grepl <- base::grepl
[11:01:35.652]                           restarts <- computeRestarts(cond)
[11:01:35.652]                           for (restart in restarts) {
[11:01:35.652]                             name <- restart$name
[11:01:35.652]                             if (is.null(name)) 
[11:01:35.652]                               next
[11:01:35.652]                             if (!grepl(pattern, name)) 
[11:01:35.652]                               next
[11:01:35.652]                             invokeRestart(restart)
[11:01:35.652]                             muffled <- TRUE
[11:01:35.652]                             break
[11:01:35.652]                           }
[11:01:35.652]                         }
[11:01:35.652]                       }
[11:01:35.652]                       invisible(muffled)
[11:01:35.652]                     }
[11:01:35.652]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.652]                   }
[11:01:35.652]                 }
[11:01:35.652]             }
[11:01:35.652]         }))
[11:01:35.652]     }, error = function(ex) {
[11:01:35.652]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.652]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.652]                 ...future.rng), started = ...future.startTime, 
[11:01:35.652]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.652]             version = "1.8"), class = "FutureResult")
[11:01:35.652]     }, finally = {
[11:01:35.652]         if (!identical(...future.workdir, getwd())) 
[11:01:35.652]             setwd(...future.workdir)
[11:01:35.652]         {
[11:01:35.652]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.652]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.652]             }
[11:01:35.652]             base::options(...future.oldOptions)
[11:01:35.652]             if (.Platform$OS.type == "windows") {
[11:01:35.652]                 old_names <- names(...future.oldEnvVars)
[11:01:35.652]                 envs <- base::Sys.getenv()
[11:01:35.652]                 names <- names(envs)
[11:01:35.652]                 common <- intersect(names, old_names)
[11:01:35.652]                 added <- setdiff(names, old_names)
[11:01:35.652]                 removed <- setdiff(old_names, names)
[11:01:35.652]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.652]                   envs[common]]
[11:01:35.652]                 NAMES <- toupper(changed)
[11:01:35.652]                 args <- list()
[11:01:35.652]                 for (kk in seq_along(NAMES)) {
[11:01:35.652]                   name <- changed[[kk]]
[11:01:35.652]                   NAME <- NAMES[[kk]]
[11:01:35.652]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.652]                     next
[11:01:35.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.652]                 }
[11:01:35.652]                 NAMES <- toupper(added)
[11:01:35.652]                 for (kk in seq_along(NAMES)) {
[11:01:35.652]                   name <- added[[kk]]
[11:01:35.652]                   NAME <- NAMES[[kk]]
[11:01:35.652]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.652]                     next
[11:01:35.652]                   args[[name]] <- ""
[11:01:35.652]                 }
[11:01:35.652]                 NAMES <- toupper(removed)
[11:01:35.652]                 for (kk in seq_along(NAMES)) {
[11:01:35.652]                   name <- removed[[kk]]
[11:01:35.652]                   NAME <- NAMES[[kk]]
[11:01:35.652]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.652]                     next
[11:01:35.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.652]                 }
[11:01:35.652]                 if (length(args) > 0) 
[11:01:35.652]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.652]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.652]             }
[11:01:35.652]             else {
[11:01:35.652]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.652]             }
[11:01:35.652]             {
[11:01:35.652]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.652]                   0L) {
[11:01:35.652]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.652]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.652]                   base::options(opts)
[11:01:35.652]                 }
[11:01:35.652]                 {
[11:01:35.652]                   {
[11:01:35.652]                     NULL
[11:01:35.652]                     RNGkind("Mersenne-Twister")
[11:01:35.652]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:35.652]                       inherits = FALSE)
[11:01:35.652]                   }
[11:01:35.652]                   options(future.plan = NULL)
[11:01:35.652]                   if (is.na(NA_character_)) 
[11:01:35.652]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.652]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.652]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.652]                     .init = FALSE)
[11:01:35.652]                 }
[11:01:35.652]             }
[11:01:35.652]         }
[11:01:35.652]     })
[11:01:35.652]     if (TRUE) {
[11:01:35.652]         base::sink(type = "output", split = FALSE)
[11:01:35.652]         if (TRUE) {
[11:01:35.652]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.652]         }
[11:01:35.652]         else {
[11:01:35.652]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.652]         }
[11:01:35.652]         base::close(...future.stdout)
[11:01:35.652]         ...future.stdout <- NULL
[11:01:35.652]     }
[11:01:35.652]     ...future.result$conditions <- ...future.conditions
[11:01:35.652]     ...future.result$finished <- base::Sys.time()
[11:01:35.652]     ...future.result
[11:01:35.652] }
[11:01:35.654] plan(): Setting new future strategy stack:
[11:01:35.654] List of future strategies:
[11:01:35.654] 1. sequential:
[11:01:35.654]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.654]    - tweaked: FALSE
[11:01:35.654]    - call: NULL
[11:01:35.655] plan(): nbrOfWorkers() = 1
[11:01:35.656] plan(): Setting new future strategy stack:
[11:01:35.656] List of future strategies:
[11:01:35.656] 1. sequential:
[11:01:35.656]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.656]    - tweaked: FALSE
[11:01:35.656]    - call: plan(strategy)
[11:01:35.657] plan(): nbrOfWorkers() = 1
[11:01:35.657] SequentialFuture started (and completed)
[11:01:35.657] - Launch lazy future ... done
[11:01:35.657] run() for ‘SequentialFuture’ ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[11:01:35.659] getGlobalsAndPackages() ...
[11:01:35.659] Searching for globals...
[11:01:35.663] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[11:01:35.663] Searching for globals ... DONE
[11:01:35.663] Resolving globals: FALSE
[11:01:35.665] The total size of the 3 globals is 1.22 KiB (1254 bytes)
[11:01:35.665] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (633 bytes of class ‘function’), ‘inner_function’ (371 bytes of class ‘function’) and ‘outer_function’ (250 bytes of class ‘function’)
[11:01:35.665] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[11:01:35.665] 
[11:01:35.665] getGlobalsAndPackages() ... DONE
[11:01:35.666] run() for ‘Future’ ...
[11:01:35.666] - state: ‘created’
[11:01:35.666] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:35.666] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:35.666] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:35.666]   - Field: ‘label’
[11:01:35.666]   - Field: ‘local’
[11:01:35.666]   - Field: ‘owner’
[11:01:35.666]   - Field: ‘envir’
[11:01:35.667]   - Field: ‘packages’
[11:01:35.667]   - Field: ‘gc’
[11:01:35.667]   - Field: ‘conditions’
[11:01:35.667]   - Field: ‘expr’
[11:01:35.667]   - Field: ‘uuid’
[11:01:35.667]   - Field: ‘seed’
[11:01:35.667]   - Field: ‘version’
[11:01:35.667]   - Field: ‘result’
[11:01:35.667]   - Field: ‘asynchronous’
[11:01:35.667]   - Field: ‘calls’
[11:01:35.667]   - Field: ‘globals’
[11:01:35.667]   - Field: ‘stdout’
[11:01:35.668]   - Field: ‘earlySignal’
[11:01:35.668]   - Field: ‘lazy’
[11:01:35.668]   - Field: ‘state’
[11:01:35.668] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:35.668] - Launch lazy future ...
[11:01:35.668] Packages needed by the future expression (n = 0): <none>
[11:01:35.668] Packages needed by future strategies (n = 0): <none>
[11:01:35.668] {
[11:01:35.668]     {
[11:01:35.668]         {
[11:01:35.668]             ...future.startTime <- base::Sys.time()
[11:01:35.668]             {
[11:01:35.668]                 {
[11:01:35.668]                   {
[11:01:35.668]                     base::local({
[11:01:35.668]                       has_future <- base::requireNamespace("future", 
[11:01:35.668]                         quietly = TRUE)
[11:01:35.668]                       if (has_future) {
[11:01:35.668]                         ns <- base::getNamespace("future")
[11:01:35.668]                         version <- ns[[".package"]][["version"]]
[11:01:35.668]                         if (is.null(version)) 
[11:01:35.668]                           version <- utils::packageVersion("future")
[11:01:35.668]                       }
[11:01:35.668]                       else {
[11:01:35.668]                         version <- NULL
[11:01:35.668]                       }
[11:01:35.668]                       if (!has_future || version < "1.8.0") {
[11:01:35.668]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.668]                           "", base::R.version$version.string), 
[11:01:35.668]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:35.668]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:35.668]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.668]                             "release", "version")], collapse = " "), 
[11:01:35.668]                           hostname = base::Sys.info()[["nodename"]])
[11:01:35.668]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.668]                           info)
[11:01:35.668]                         info <- base::paste(info, collapse = "; ")
[11:01:35.668]                         if (!has_future) {
[11:01:35.668]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.668]                             info)
[11:01:35.668]                         }
[11:01:35.668]                         else {
[11:01:35.668]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.668]                             info, version)
[11:01:35.668]                         }
[11:01:35.668]                         base::stop(msg)
[11:01:35.668]                       }
[11:01:35.668]                     })
[11:01:35.668]                   }
[11:01:35.668]                   ...future.strategy.old <- future::plan("list")
[11:01:35.668]                   options(future.plan = NULL)
[11:01:35.668]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.668]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.668]                 }
[11:01:35.668]                 ...future.workdir <- getwd()
[11:01:35.668]             }
[11:01:35.668]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.668]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.668]         }
[11:01:35.668]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.668]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.668]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.668]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.668]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.668]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.668]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.668]             base::names(...future.oldOptions))
[11:01:35.668]     }
[11:01:35.668]     if (FALSE) {
[11:01:35.668]     }
[11:01:35.668]     else {
[11:01:35.668]         if (TRUE) {
[11:01:35.668]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.668]                 open = "w")
[11:01:35.668]         }
[11:01:35.668]         else {
[11:01:35.668]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.668]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.668]         }
[11:01:35.668]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.668]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.668]             base::sink(type = "output", split = FALSE)
[11:01:35.668]             base::close(...future.stdout)
[11:01:35.668]         }, add = TRUE)
[11:01:35.668]     }
[11:01:35.668]     ...future.frame <- base::sys.nframe()
[11:01:35.668]     ...future.conditions <- base::list()
[11:01:35.668]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.668]     if (FALSE) {
[11:01:35.668]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.668]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.668]     }
[11:01:35.668]     ...future.result <- base::tryCatch({
[11:01:35.668]         base::withCallingHandlers({
[11:01:35.668]             ...future.value <- base::withVisible(base::local({
[11:01:35.668]                 outer_function(1L)
[11:01:35.668]             }))
[11:01:35.668]             future::FutureResult(value = ...future.value$value, 
[11:01:35.668]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.668]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.668]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.668]                     ...future.globalenv.names))
[11:01:35.668]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.668]         }, condition = base::local({
[11:01:35.668]             c <- base::c
[11:01:35.668]             inherits <- base::inherits
[11:01:35.668]             invokeRestart <- base::invokeRestart
[11:01:35.668]             length <- base::length
[11:01:35.668]             list <- base::list
[11:01:35.668]             seq.int <- base::seq.int
[11:01:35.668]             signalCondition <- base::signalCondition
[11:01:35.668]             sys.calls <- base::sys.calls
[11:01:35.668]             `[[` <- base::`[[`
[11:01:35.668]             `+` <- base::`+`
[11:01:35.668]             `<<-` <- base::`<<-`
[11:01:35.668]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.668]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.668]                   3L)]
[11:01:35.668]             }
[11:01:35.668]             function(cond) {
[11:01:35.668]                 is_error <- inherits(cond, "error")
[11:01:35.668]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.668]                   NULL)
[11:01:35.668]                 if (is_error) {
[11:01:35.668]                   sessionInformation <- function() {
[11:01:35.668]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.668]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.668]                       search = base::search(), system = base::Sys.info())
[11:01:35.668]                   }
[11:01:35.668]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.668]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.668]                     cond$call), session = sessionInformation(), 
[11:01:35.668]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.668]                   signalCondition(cond)
[11:01:35.668]                 }
[11:01:35.668]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.668]                 "immediateCondition"))) {
[11:01:35.668]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.668]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.668]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.668]                   if (TRUE && !signal) {
[11:01:35.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.668]                     {
[11:01:35.668]                       inherits <- base::inherits
[11:01:35.668]                       invokeRestart <- base::invokeRestart
[11:01:35.668]                       is.null <- base::is.null
[11:01:35.668]                       muffled <- FALSE
[11:01:35.668]                       if (inherits(cond, "message")) {
[11:01:35.668]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.668]                         if (muffled) 
[11:01:35.668]                           invokeRestart("muffleMessage")
[11:01:35.668]                       }
[11:01:35.668]                       else if (inherits(cond, "warning")) {
[11:01:35.668]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.668]                         if (muffled) 
[11:01:35.668]                           invokeRestart("muffleWarning")
[11:01:35.668]                       }
[11:01:35.668]                       else if (inherits(cond, "condition")) {
[11:01:35.668]                         if (!is.null(pattern)) {
[11:01:35.668]                           computeRestarts <- base::computeRestarts
[11:01:35.668]                           grepl <- base::grepl
[11:01:35.668]                           restarts <- computeRestarts(cond)
[11:01:35.668]                           for (restart in restarts) {
[11:01:35.668]                             name <- restart$name
[11:01:35.668]                             if (is.null(name)) 
[11:01:35.668]                               next
[11:01:35.668]                             if (!grepl(pattern, name)) 
[11:01:35.668]                               next
[11:01:35.668]                             invokeRestart(restart)
[11:01:35.668]                             muffled <- TRUE
[11:01:35.668]                             break
[11:01:35.668]                           }
[11:01:35.668]                         }
[11:01:35.668]                       }
[11:01:35.668]                       invisible(muffled)
[11:01:35.668]                     }
[11:01:35.668]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.668]                   }
[11:01:35.668]                 }
[11:01:35.668]                 else {
[11:01:35.668]                   if (TRUE) {
[11:01:35.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.668]                     {
[11:01:35.668]                       inherits <- base::inherits
[11:01:35.668]                       invokeRestart <- base::invokeRestart
[11:01:35.668]                       is.null <- base::is.null
[11:01:35.668]                       muffled <- FALSE
[11:01:35.668]                       if (inherits(cond, "message")) {
[11:01:35.668]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.668]                         if (muffled) 
[11:01:35.668]                           invokeRestart("muffleMessage")
[11:01:35.668]                       }
[11:01:35.668]                       else if (inherits(cond, "warning")) {
[11:01:35.668]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.668]                         if (muffled) 
[11:01:35.668]                           invokeRestart("muffleWarning")
[11:01:35.668]                       }
[11:01:35.668]                       else if (inherits(cond, "condition")) {
[11:01:35.668]                         if (!is.null(pattern)) {
[11:01:35.668]                           computeRestarts <- base::computeRestarts
[11:01:35.668]                           grepl <- base::grepl
[11:01:35.668]                           restarts <- computeRestarts(cond)
[11:01:35.668]                           for (restart in restarts) {
[11:01:35.668]                             name <- restart$name
[11:01:35.668]                             if (is.null(name)) 
[11:01:35.668]                               next
[11:01:35.668]                             if (!grepl(pattern, name)) 
[11:01:35.668]                               next
[11:01:35.668]                             invokeRestart(restart)
[11:01:35.668]                             muffled <- TRUE
[11:01:35.668]                             break
[11:01:35.668]                           }
[11:01:35.668]                         }
[11:01:35.668]                       }
[11:01:35.668]                       invisible(muffled)
[11:01:35.668]                     }
[11:01:35.668]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.668]                   }
[11:01:35.668]                 }
[11:01:35.668]             }
[11:01:35.668]         }))
[11:01:35.668]     }, error = function(ex) {
[11:01:35.668]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.668]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.668]                 ...future.rng), started = ...future.startTime, 
[11:01:35.668]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.668]             version = "1.8"), class = "FutureResult")
[11:01:35.668]     }, finally = {
[11:01:35.668]         if (!identical(...future.workdir, getwd())) 
[11:01:35.668]             setwd(...future.workdir)
[11:01:35.668]         {
[11:01:35.668]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.668]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.668]             }
[11:01:35.668]             base::options(...future.oldOptions)
[11:01:35.668]             if (.Platform$OS.type == "windows") {
[11:01:35.668]                 old_names <- names(...future.oldEnvVars)
[11:01:35.668]                 envs <- base::Sys.getenv()
[11:01:35.668]                 names <- names(envs)
[11:01:35.668]                 common <- intersect(names, old_names)
[11:01:35.668]                 added <- setdiff(names, old_names)
[11:01:35.668]                 removed <- setdiff(old_names, names)
[11:01:35.668]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.668]                   envs[common]]
[11:01:35.668]                 NAMES <- toupper(changed)
[11:01:35.668]                 args <- list()
[11:01:35.668]                 for (kk in seq_along(NAMES)) {
[11:01:35.668]                   name <- changed[[kk]]
[11:01:35.668]                   NAME <- NAMES[[kk]]
[11:01:35.668]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.668]                     next
[11:01:35.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.668]                 }
[11:01:35.668]                 NAMES <- toupper(added)
[11:01:35.668]                 for (kk in seq_along(NAMES)) {
[11:01:35.668]                   name <- added[[kk]]
[11:01:35.668]                   NAME <- NAMES[[kk]]
[11:01:35.668]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.668]                     next
[11:01:35.668]                   args[[name]] <- ""
[11:01:35.668]                 }
[11:01:35.668]                 NAMES <- toupper(removed)
[11:01:35.668]                 for (kk in seq_along(NAMES)) {
[11:01:35.668]                   name <- removed[[kk]]
[11:01:35.668]                   NAME <- NAMES[[kk]]
[11:01:35.668]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.668]                     next
[11:01:35.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.668]                 }
[11:01:35.668]                 if (length(args) > 0) 
[11:01:35.668]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.668]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.668]             }
[11:01:35.668]             else {
[11:01:35.668]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.668]             }
[11:01:35.668]             {
[11:01:35.668]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.668]                   0L) {
[11:01:35.668]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.668]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.668]                   base::options(opts)
[11:01:35.668]                 }
[11:01:35.668]                 {
[11:01:35.668]                   {
[11:01:35.668]                     NULL
[11:01:35.668]                     RNGkind("Mersenne-Twister")
[11:01:35.668]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:35.668]                       inherits = FALSE)
[11:01:35.668]                   }
[11:01:35.668]                   options(future.plan = NULL)
[11:01:35.668]                   if (is.na(NA_character_)) 
[11:01:35.668]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.668]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.668]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.668]                     .init = FALSE)
[11:01:35.668]                 }
[11:01:35.668]             }
[11:01:35.668]         }
[11:01:35.668]     })
[11:01:35.668]     if (TRUE) {
[11:01:35.668]         base::sink(type = "output", split = FALSE)
[11:01:35.668]         if (TRUE) {
[11:01:35.668]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.668]         }
[11:01:35.668]         else {
[11:01:35.668]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.668]         }
[11:01:35.668]         base::close(...future.stdout)
[11:01:35.668]         ...future.stdout <- NULL
[11:01:35.668]     }
[11:01:35.668]     ...future.result$conditions <- ...future.conditions
[11:01:35.668]     ...future.result$finished <- base::Sys.time()
[11:01:35.668]     ...future.result
[11:01:35.668] }
[11:01:35.670] assign_globals() ...
[11:01:35.670] List of 3
[11:01:35.670]  $ outer_function:function (x)  
[11:01:35.670]  $ map           :function (.x, .f, ...)  
[11:01:35.670]  $ inner_function:function (x)  
[11:01:35.670]  - attr(*, "where")=List of 3
[11:01:35.670]   ..$ outer_function:<environment: R_EmptyEnv> 
[11:01:35.670]   ..$ map           :<environment: R_EmptyEnv> 
[11:01:35.670]   ..$ inner_function:<environment: R_EmptyEnv> 
[11:01:35.670]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:35.670]  - attr(*, "resolved")= logi FALSE
[11:01:35.670]  - attr(*, "total_size")= num 1254
[11:01:35.670]  - attr(*, "already-done")= logi TRUE
[11:01:35.673] - reassign environment for ‘outer_function’
[11:01:35.673] - copied ‘outer_function’ to environment
[11:01:35.673] - reassign environment for ‘map’
[11:01:35.673] - copied ‘map’ to environment
[11:01:35.674] - reassign environment for ‘inner_function’
[11:01:35.674] - copied ‘inner_function’ to environment
[11:01:35.674] assign_globals() ... done
[11:01:35.674] plan(): Setting new future strategy stack:
[11:01:35.674] List of future strategies:
[11:01:35.674] 1. sequential:
[11:01:35.674]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.674]    - tweaked: FALSE
[11:01:35.674]    - call: NULL
[11:01:35.674] plan(): nbrOfWorkers() = 1
[11:01:35.679] plan(): Setting new future strategy stack:
[11:01:35.679] List of future strategies:
[11:01:35.679] 1. sequential:
[11:01:35.679]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.679]    - tweaked: FALSE
[11:01:35.679]    - call: plan(strategy)
[11:01:35.680] plan(): nbrOfWorkers() = 1
[11:01:35.680] SequentialFuture started (and completed)
[11:01:35.680] - Launch lazy future ... done
[11:01:35.680] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[11:01:35.681] getGlobalsAndPackages() ...
[11:01:35.681] Searching for globals...
[11:01:35.686] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[11:01:35.686] Searching for globals ... DONE
[11:01:35.686] Resolving globals: FALSE
[11:01:35.687] The total size of the 3 globals is 1.22 KiB (1254 bytes)
[11:01:35.687] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (633 bytes of class ‘function’), ‘inner_function’ (371 bytes of class ‘function’) and ‘outer_function’ (250 bytes of class ‘function’)
[11:01:35.687] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[11:01:35.687] 
[11:01:35.688] getGlobalsAndPackages() ... DONE
[11:01:35.688] run() for ‘Future’ ...
[11:01:35.688] - state: ‘created’
[11:01:35.688] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:35.688] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:35.688] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:35.688]   - Field: ‘label’
[11:01:35.688]   - Field: ‘local’
[11:01:35.689]   - Field: ‘owner’
[11:01:35.689]   - Field: ‘envir’
[11:01:35.689]   - Field: ‘packages’
[11:01:35.689]   - Field: ‘gc’
[11:01:35.689]   - Field: ‘conditions’
[11:01:35.689]   - Field: ‘expr’
[11:01:35.689]   - Field: ‘uuid’
[11:01:35.689]   - Field: ‘seed’
[11:01:35.689]   - Field: ‘version’
[11:01:35.689]   - Field: ‘result’
[11:01:35.690]   - Field: ‘asynchronous’
[11:01:35.690]   - Field: ‘calls’
[11:01:35.690]   - Field: ‘globals’
[11:01:35.690]   - Field: ‘stdout’
[11:01:35.690]   - Field: ‘earlySignal’
[11:01:35.690]   - Field: ‘lazy’
[11:01:35.690]   - Field: ‘state’
[11:01:35.690] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:35.690] - Launch lazy future ...
[11:01:35.690] Packages needed by the future expression (n = 0): <none>
[11:01:35.690] Packages needed by future strategies (n = 0): <none>
[11:01:35.691] {
[11:01:35.691]     {
[11:01:35.691]         {
[11:01:35.691]             ...future.startTime <- base::Sys.time()
[11:01:35.691]             {
[11:01:35.691]                 {
[11:01:35.691]                   {
[11:01:35.691]                     base::local({
[11:01:35.691]                       has_future <- base::requireNamespace("future", 
[11:01:35.691]                         quietly = TRUE)
[11:01:35.691]                       if (has_future) {
[11:01:35.691]                         ns <- base::getNamespace("future")
[11:01:35.691]                         version <- ns[[".package"]][["version"]]
[11:01:35.691]                         if (is.null(version)) 
[11:01:35.691]                           version <- utils::packageVersion("future")
[11:01:35.691]                       }
[11:01:35.691]                       else {
[11:01:35.691]                         version <- NULL
[11:01:35.691]                       }
[11:01:35.691]                       if (!has_future || version < "1.8.0") {
[11:01:35.691]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.691]                           "", base::R.version$version.string), 
[11:01:35.691]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:35.691]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:35.691]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.691]                             "release", "version")], collapse = " "), 
[11:01:35.691]                           hostname = base::Sys.info()[["nodename"]])
[11:01:35.691]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.691]                           info)
[11:01:35.691]                         info <- base::paste(info, collapse = "; ")
[11:01:35.691]                         if (!has_future) {
[11:01:35.691]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.691]                             info)
[11:01:35.691]                         }
[11:01:35.691]                         else {
[11:01:35.691]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.691]                             info, version)
[11:01:35.691]                         }
[11:01:35.691]                         base::stop(msg)
[11:01:35.691]                       }
[11:01:35.691]                     })
[11:01:35.691]                   }
[11:01:35.691]                   ...future.strategy.old <- future::plan("list")
[11:01:35.691]                   options(future.plan = NULL)
[11:01:35.691]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.691]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.691]                 }
[11:01:35.691]                 ...future.workdir <- getwd()
[11:01:35.691]             }
[11:01:35.691]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.691]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.691]         }
[11:01:35.691]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.691]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.691]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.691]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.691]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.691]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.691]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.691]             base::names(...future.oldOptions))
[11:01:35.691]     }
[11:01:35.691]     if (FALSE) {
[11:01:35.691]     }
[11:01:35.691]     else {
[11:01:35.691]         if (TRUE) {
[11:01:35.691]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.691]                 open = "w")
[11:01:35.691]         }
[11:01:35.691]         else {
[11:01:35.691]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.691]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.691]         }
[11:01:35.691]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.691]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.691]             base::sink(type = "output", split = FALSE)
[11:01:35.691]             base::close(...future.stdout)
[11:01:35.691]         }, add = TRUE)
[11:01:35.691]     }
[11:01:35.691]     ...future.frame <- base::sys.nframe()
[11:01:35.691]     ...future.conditions <- base::list()
[11:01:35.691]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.691]     if (FALSE) {
[11:01:35.691]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.691]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.691]     }
[11:01:35.691]     ...future.result <- base::tryCatch({
[11:01:35.691]         base::withCallingHandlers({
[11:01:35.691]             ...future.value <- base::withVisible(base::local({
[11:01:35.691]                 outer_function(1L)
[11:01:35.691]             }))
[11:01:35.691]             future::FutureResult(value = ...future.value$value, 
[11:01:35.691]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.691]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.691]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.691]                     ...future.globalenv.names))
[11:01:35.691]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.691]         }, condition = base::local({
[11:01:35.691]             c <- base::c
[11:01:35.691]             inherits <- base::inherits
[11:01:35.691]             invokeRestart <- base::invokeRestart
[11:01:35.691]             length <- base::length
[11:01:35.691]             list <- base::list
[11:01:35.691]             seq.int <- base::seq.int
[11:01:35.691]             signalCondition <- base::signalCondition
[11:01:35.691]             sys.calls <- base::sys.calls
[11:01:35.691]             `[[` <- base::`[[`
[11:01:35.691]             `+` <- base::`+`
[11:01:35.691]             `<<-` <- base::`<<-`
[11:01:35.691]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.691]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.691]                   3L)]
[11:01:35.691]             }
[11:01:35.691]             function(cond) {
[11:01:35.691]                 is_error <- inherits(cond, "error")
[11:01:35.691]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.691]                   NULL)
[11:01:35.691]                 if (is_error) {
[11:01:35.691]                   sessionInformation <- function() {
[11:01:35.691]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.691]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.691]                       search = base::search(), system = base::Sys.info())
[11:01:35.691]                   }
[11:01:35.691]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.691]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.691]                     cond$call), session = sessionInformation(), 
[11:01:35.691]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.691]                   signalCondition(cond)
[11:01:35.691]                 }
[11:01:35.691]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.691]                 "immediateCondition"))) {
[11:01:35.691]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.691]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.691]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.691]                   if (TRUE && !signal) {
[11:01:35.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.691]                     {
[11:01:35.691]                       inherits <- base::inherits
[11:01:35.691]                       invokeRestart <- base::invokeRestart
[11:01:35.691]                       is.null <- base::is.null
[11:01:35.691]                       muffled <- FALSE
[11:01:35.691]                       if (inherits(cond, "message")) {
[11:01:35.691]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.691]                         if (muffled) 
[11:01:35.691]                           invokeRestart("muffleMessage")
[11:01:35.691]                       }
[11:01:35.691]                       else if (inherits(cond, "warning")) {
[11:01:35.691]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.691]                         if (muffled) 
[11:01:35.691]                           invokeRestart("muffleWarning")
[11:01:35.691]                       }
[11:01:35.691]                       else if (inherits(cond, "condition")) {
[11:01:35.691]                         if (!is.null(pattern)) {
[11:01:35.691]                           computeRestarts <- base::computeRestarts
[11:01:35.691]                           grepl <- base::grepl
[11:01:35.691]                           restarts <- computeRestarts(cond)
[11:01:35.691]                           for (restart in restarts) {
[11:01:35.691]                             name <- restart$name
[11:01:35.691]                             if (is.null(name)) 
[11:01:35.691]                               next
[11:01:35.691]                             if (!grepl(pattern, name)) 
[11:01:35.691]                               next
[11:01:35.691]                             invokeRestart(restart)
[11:01:35.691]                             muffled <- TRUE
[11:01:35.691]                             break
[11:01:35.691]                           }
[11:01:35.691]                         }
[11:01:35.691]                       }
[11:01:35.691]                       invisible(muffled)
[11:01:35.691]                     }
[11:01:35.691]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.691]                   }
[11:01:35.691]                 }
[11:01:35.691]                 else {
[11:01:35.691]                   if (TRUE) {
[11:01:35.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.691]                     {
[11:01:35.691]                       inherits <- base::inherits
[11:01:35.691]                       invokeRestart <- base::invokeRestart
[11:01:35.691]                       is.null <- base::is.null
[11:01:35.691]                       muffled <- FALSE
[11:01:35.691]                       if (inherits(cond, "message")) {
[11:01:35.691]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.691]                         if (muffled) 
[11:01:35.691]                           invokeRestart("muffleMessage")
[11:01:35.691]                       }
[11:01:35.691]                       else if (inherits(cond, "warning")) {
[11:01:35.691]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.691]                         if (muffled) 
[11:01:35.691]                           invokeRestart("muffleWarning")
[11:01:35.691]                       }
[11:01:35.691]                       else if (inherits(cond, "condition")) {
[11:01:35.691]                         if (!is.null(pattern)) {
[11:01:35.691]                           computeRestarts <- base::computeRestarts
[11:01:35.691]                           grepl <- base::grepl
[11:01:35.691]                           restarts <- computeRestarts(cond)
[11:01:35.691]                           for (restart in restarts) {
[11:01:35.691]                             name <- restart$name
[11:01:35.691]                             if (is.null(name)) 
[11:01:35.691]                               next
[11:01:35.691]                             if (!grepl(pattern, name)) 
[11:01:35.691]                               next
[11:01:35.691]                             invokeRestart(restart)
[11:01:35.691]                             muffled <- TRUE
[11:01:35.691]                             break
[11:01:35.691]                           }
[11:01:35.691]                         }
[11:01:35.691]                       }
[11:01:35.691]                       invisible(muffled)
[11:01:35.691]                     }
[11:01:35.691]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.691]                   }
[11:01:35.691]                 }
[11:01:35.691]             }
[11:01:35.691]         }))
[11:01:35.691]     }, error = function(ex) {
[11:01:35.691]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.691]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.691]                 ...future.rng), started = ...future.startTime, 
[11:01:35.691]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.691]             version = "1.8"), class = "FutureResult")
[11:01:35.691]     }, finally = {
[11:01:35.691]         if (!identical(...future.workdir, getwd())) 
[11:01:35.691]             setwd(...future.workdir)
[11:01:35.691]         {
[11:01:35.691]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.691]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.691]             }
[11:01:35.691]             base::options(...future.oldOptions)
[11:01:35.691]             if (.Platform$OS.type == "windows") {
[11:01:35.691]                 old_names <- names(...future.oldEnvVars)
[11:01:35.691]                 envs <- base::Sys.getenv()
[11:01:35.691]                 names <- names(envs)
[11:01:35.691]                 common <- intersect(names, old_names)
[11:01:35.691]                 added <- setdiff(names, old_names)
[11:01:35.691]                 removed <- setdiff(old_names, names)
[11:01:35.691]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.691]                   envs[common]]
[11:01:35.691]                 NAMES <- toupper(changed)
[11:01:35.691]                 args <- list()
[11:01:35.691]                 for (kk in seq_along(NAMES)) {
[11:01:35.691]                   name <- changed[[kk]]
[11:01:35.691]                   NAME <- NAMES[[kk]]
[11:01:35.691]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.691]                     next
[11:01:35.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.691]                 }
[11:01:35.691]                 NAMES <- toupper(added)
[11:01:35.691]                 for (kk in seq_along(NAMES)) {
[11:01:35.691]                   name <- added[[kk]]
[11:01:35.691]                   NAME <- NAMES[[kk]]
[11:01:35.691]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.691]                     next
[11:01:35.691]                   args[[name]] <- ""
[11:01:35.691]                 }
[11:01:35.691]                 NAMES <- toupper(removed)
[11:01:35.691]                 for (kk in seq_along(NAMES)) {
[11:01:35.691]                   name <- removed[[kk]]
[11:01:35.691]                   NAME <- NAMES[[kk]]
[11:01:35.691]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.691]                     next
[11:01:35.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.691]                 }
[11:01:35.691]                 if (length(args) > 0) 
[11:01:35.691]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.691]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.691]             }
[11:01:35.691]             else {
[11:01:35.691]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.691]             }
[11:01:35.691]             {
[11:01:35.691]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.691]                   0L) {
[11:01:35.691]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.691]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.691]                   base::options(opts)
[11:01:35.691]                 }
[11:01:35.691]                 {
[11:01:35.691]                   {
[11:01:35.691]                     NULL
[11:01:35.691]                     RNGkind("Mersenne-Twister")
[11:01:35.691]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:35.691]                       inherits = FALSE)
[11:01:35.691]                   }
[11:01:35.691]                   options(future.plan = NULL)
[11:01:35.691]                   if (is.na(NA_character_)) 
[11:01:35.691]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.691]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.691]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.691]                     .init = FALSE)
[11:01:35.691]                 }
[11:01:35.691]             }
[11:01:35.691]         }
[11:01:35.691]     })
[11:01:35.691]     if (TRUE) {
[11:01:35.691]         base::sink(type = "output", split = FALSE)
[11:01:35.691]         if (TRUE) {
[11:01:35.691]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.691]         }
[11:01:35.691]         else {
[11:01:35.691]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.691]         }
[11:01:35.691]         base::close(...future.stdout)
[11:01:35.691]         ...future.stdout <- NULL
[11:01:35.691]     }
[11:01:35.691]     ...future.result$conditions <- ...future.conditions
[11:01:35.691]     ...future.result$finished <- base::Sys.time()
[11:01:35.691]     ...future.result
[11:01:35.691] }
[11:01:35.692] assign_globals() ...
[11:01:35.692] List of 3
[11:01:35.692]  $ outer_function:function (x)  
[11:01:35.692]  $ map           :function (.x, .f, ...)  
[11:01:35.692]  $ inner_function:function (x)  
[11:01:35.692]  - attr(*, "where")=List of 3
[11:01:35.692]   ..$ outer_function:<environment: R_EmptyEnv> 
[11:01:35.692]   ..$ map           :<environment: R_EmptyEnv> 
[11:01:35.692]   ..$ inner_function:<environment: R_EmptyEnv> 
[11:01:35.692]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:35.692]  - attr(*, "resolved")= logi FALSE
[11:01:35.692]  - attr(*, "total_size")= num 1254
[11:01:35.692]  - attr(*, "already-done")= logi TRUE
[11:01:35.695] - reassign environment for ‘outer_function’
[11:01:35.696] - copied ‘outer_function’ to environment
[11:01:35.696] - reassign environment for ‘map’
[11:01:35.696] - copied ‘map’ to environment
[11:01:35.696] - reassign environment for ‘inner_function’
[11:01:35.696] - copied ‘inner_function’ to environment
[11:01:35.696] assign_globals() ... done
[11:01:35.696] plan(): Setting new future strategy stack:
[11:01:35.696] List of future strategies:
[11:01:35.696] 1. sequential:
[11:01:35.696]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.696]    - tweaked: FALSE
[11:01:35.696]    - call: NULL
[11:01:35.697] plan(): nbrOfWorkers() = 1
[11:01:35.697] plan(): Setting new future strategy stack:
[11:01:35.697] List of future strategies:
[11:01:35.697] 1. sequential:
[11:01:35.697]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.697]    - tweaked: FALSE
[11:01:35.697]    - call: plan(strategy)
[11:01:35.698] plan(): nbrOfWorkers() = 1
[11:01:35.698] SequentialFuture started (and completed)
[11:01:35.698] - Launch lazy future ... done
[11:01:35.698] run() for ‘SequentialFuture’ ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[11:01:35.706] plan(): Setting new future strategy stack:
[11:01:35.706] List of future strategies:
[11:01:35.706] 1. multicore:
[11:01:35.706]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:35.706]    - tweaked: FALSE
[11:01:35.706]    - call: plan(strategy)
[11:01:35.708] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[11:01:35.708] getGlobalsAndPackages() ...
[11:01:35.708] Searching for globals...
[11:01:35.709] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[11:01:35.710] Searching for globals ... DONE
[11:01:35.710] Resolving globals: FALSE
[11:01:35.710] The total size of the 2 globals is 401 bytes (401 bytes)
[11:01:35.710] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[11:01:35.710] - globals: [2] ‘weight’, ‘group’
[11:01:35.711] - packages: [1] ‘stats’
[11:01:35.711] getGlobalsAndPackages() ... DONE
[11:01:35.711] run() for ‘Future’ ...
[11:01:35.711] - state: ‘created’
[11:01:35.711] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:35.713] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:35.713] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:35.713]   - Field: ‘label’
[11:01:35.713]   - Field: ‘local’
[11:01:35.713]   - Field: ‘owner’
[11:01:35.713]   - Field: ‘envir’
[11:01:35.713]   - Field: ‘workers’
[11:01:35.713]   - Field: ‘packages’
[11:01:35.713]   - Field: ‘gc’
[11:01:35.713]   - Field: ‘job’
[11:01:35.714]   - Field: ‘conditions’
[11:01:35.714]   - Field: ‘expr’
[11:01:35.714]   - Field: ‘uuid’
[11:01:35.714]   - Field: ‘seed’
[11:01:35.714]   - Field: ‘version’
[11:01:35.714]   - Field: ‘result’
[11:01:35.714]   - Field: ‘asynchronous’
[11:01:35.714]   - Field: ‘calls’
[11:01:35.714]   - Field: ‘globals’
[11:01:35.714]   - Field: ‘stdout’
[11:01:35.714]   - Field: ‘earlySignal’
[11:01:35.714]   - Field: ‘lazy’
[11:01:35.714]   - Field: ‘state’
[11:01:35.715] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:35.715] - Launch lazy future ...
[11:01:35.715] Packages needed by the future expression (n = 1): ‘stats’
[11:01:35.716] Packages needed by future strategies (n = 0): <none>
[11:01:35.716] {
[11:01:35.716]     {
[11:01:35.716]         {
[11:01:35.716]             ...future.startTime <- base::Sys.time()
[11:01:35.716]             {
[11:01:35.716]                 {
[11:01:35.716]                   {
[11:01:35.716]                     {
[11:01:35.716]                       {
[11:01:35.716]                         base::local({
[11:01:35.716]                           has_future <- base::requireNamespace("future", 
[11:01:35.716]                             quietly = TRUE)
[11:01:35.716]                           if (has_future) {
[11:01:35.716]                             ns <- base::getNamespace("future")
[11:01:35.716]                             version <- ns[[".package"]][["version"]]
[11:01:35.716]                             if (is.null(version)) 
[11:01:35.716]                               version <- utils::packageVersion("future")
[11:01:35.716]                           }
[11:01:35.716]                           else {
[11:01:35.716]                             version <- NULL
[11:01:35.716]                           }
[11:01:35.716]                           if (!has_future || version < "1.8.0") {
[11:01:35.716]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.716]                               "", base::R.version$version.string), 
[11:01:35.716]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:35.716]                                 base::R.version$platform, 8 * 
[11:01:35.716]                                   base::.Machine$sizeof.pointer), 
[11:01:35.716]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.716]                                 "release", "version")], collapse = " "), 
[11:01:35.716]                               hostname = base::Sys.info()[["nodename"]])
[11:01:35.716]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.716]                               info)
[11:01:35.716]                             info <- base::paste(info, collapse = "; ")
[11:01:35.716]                             if (!has_future) {
[11:01:35.716]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.716]                                 info)
[11:01:35.716]                             }
[11:01:35.716]                             else {
[11:01:35.716]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.716]                                 info, version)
[11:01:35.716]                             }
[11:01:35.716]                             base::stop(msg)
[11:01:35.716]                           }
[11:01:35.716]                         })
[11:01:35.716]                       }
[11:01:35.716]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:35.716]                       base::options(mc.cores = 1L)
[11:01:35.716]                     }
[11:01:35.716]                     base::local({
[11:01:35.716]                       for (pkg in "stats") {
[11:01:35.716]                         base::loadNamespace(pkg)
[11:01:35.716]                         base::library(pkg, character.only = TRUE)
[11:01:35.716]                       }
[11:01:35.716]                     })
[11:01:35.716]                   }
[11:01:35.716]                   ...future.strategy.old <- future::plan("list")
[11:01:35.716]                   options(future.plan = NULL)
[11:01:35.716]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.716]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.716]                 }
[11:01:35.716]                 ...future.workdir <- getwd()
[11:01:35.716]             }
[11:01:35.716]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.716]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.716]         }
[11:01:35.716]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.716]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.716]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.716]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.716]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.716]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.716]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.716]             base::names(...future.oldOptions))
[11:01:35.716]     }
[11:01:35.716]     if (FALSE) {
[11:01:35.716]     }
[11:01:35.716]     else {
[11:01:35.716]         if (TRUE) {
[11:01:35.716]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.716]                 open = "w")
[11:01:35.716]         }
[11:01:35.716]         else {
[11:01:35.716]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.716]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.716]         }
[11:01:35.716]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.716]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.716]             base::sink(type = "output", split = FALSE)
[11:01:35.716]             base::close(...future.stdout)
[11:01:35.716]         }, add = TRUE)
[11:01:35.716]     }
[11:01:35.716]     ...future.frame <- base::sys.nframe()
[11:01:35.716]     ...future.conditions <- base::list()
[11:01:35.716]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.716]     if (FALSE) {
[11:01:35.716]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.716]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.716]     }
[11:01:35.716]     ...future.result <- base::tryCatch({
[11:01:35.716]         base::withCallingHandlers({
[11:01:35.716]             ...future.value <- base::withVisible(base::local({
[11:01:35.716]                 withCallingHandlers({
[11:01:35.716]                   {
[11:01:35.716]                     lm(weight ~ group - 1)
[11:01:35.716]                   }
[11:01:35.716]                 }, immediateCondition = function(cond) {
[11:01:35.716]                   save_rds <- function (object, pathname, ...) 
[11:01:35.716]                   {
[11:01:35.716]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:35.716]                     if (file_test("-f", pathname_tmp)) {
[11:01:35.716]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.716]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:35.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.716]                         fi_tmp[["mtime"]])
[11:01:35.716]                     }
[11:01:35.716]                     tryCatch({
[11:01:35.716]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:35.716]                     }, error = function(ex) {
[11:01:35.716]                       msg <- conditionMessage(ex)
[11:01:35.716]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.716]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:35.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.716]                         fi_tmp[["mtime"]], msg)
[11:01:35.716]                       ex$message <- msg
[11:01:35.716]                       stop(ex)
[11:01:35.716]                     })
[11:01:35.716]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:35.716]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:35.716]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:35.716]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.716]                       fi <- file.info(pathname)
[11:01:35.716]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:35.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.716]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:35.716]                         fi[["size"]], fi[["mtime"]])
[11:01:35.716]                       stop(msg)
[11:01:35.716]                     }
[11:01:35.716]                     invisible(pathname)
[11:01:35.716]                   }
[11:01:35.716]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:35.716]                     rootPath = tempdir()) 
[11:01:35.716]                   {
[11:01:35.716]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:35.716]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:35.716]                       tmpdir = path, fileext = ".rds")
[11:01:35.716]                     save_rds(obj, file)
[11:01:35.716]                   }
[11:01:35.716]                   saveImmediateCondition(cond, path = "/tmp/Rtmpu6OqnW/.future/immediateConditions")
[11:01:35.716]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.716]                   {
[11:01:35.716]                     inherits <- base::inherits
[11:01:35.716]                     invokeRestart <- base::invokeRestart
[11:01:35.716]                     is.null <- base::is.null
[11:01:35.716]                     muffled <- FALSE
[11:01:35.716]                     if (inherits(cond, "message")) {
[11:01:35.716]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:35.716]                       if (muffled) 
[11:01:35.716]                         invokeRestart("muffleMessage")
[11:01:35.716]                     }
[11:01:35.716]                     else if (inherits(cond, "warning")) {
[11:01:35.716]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:35.716]                       if (muffled) 
[11:01:35.716]                         invokeRestart("muffleWarning")
[11:01:35.716]                     }
[11:01:35.716]                     else if (inherits(cond, "condition")) {
[11:01:35.716]                       if (!is.null(pattern)) {
[11:01:35.716]                         computeRestarts <- base::computeRestarts
[11:01:35.716]                         grepl <- base::grepl
[11:01:35.716]                         restarts <- computeRestarts(cond)
[11:01:35.716]                         for (restart in restarts) {
[11:01:35.716]                           name <- restart$name
[11:01:35.716]                           if (is.null(name)) 
[11:01:35.716]                             next
[11:01:35.716]                           if (!grepl(pattern, name)) 
[11:01:35.716]                             next
[11:01:35.716]                           invokeRestart(restart)
[11:01:35.716]                           muffled <- TRUE
[11:01:35.716]                           break
[11:01:35.716]                         }
[11:01:35.716]                       }
[11:01:35.716]                     }
[11:01:35.716]                     invisible(muffled)
[11:01:35.716]                   }
[11:01:35.716]                   muffleCondition(cond)
[11:01:35.716]                 })
[11:01:35.716]             }))
[11:01:35.716]             future::FutureResult(value = ...future.value$value, 
[11:01:35.716]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.716]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.716]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.716]                     ...future.globalenv.names))
[11:01:35.716]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.716]         }, condition = base::local({
[11:01:35.716]             c <- base::c
[11:01:35.716]             inherits <- base::inherits
[11:01:35.716]             invokeRestart <- base::invokeRestart
[11:01:35.716]             length <- base::length
[11:01:35.716]             list <- base::list
[11:01:35.716]             seq.int <- base::seq.int
[11:01:35.716]             signalCondition <- base::signalCondition
[11:01:35.716]             sys.calls <- base::sys.calls
[11:01:35.716]             `[[` <- base::`[[`
[11:01:35.716]             `+` <- base::`+`
[11:01:35.716]             `<<-` <- base::`<<-`
[11:01:35.716]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.716]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.716]                   3L)]
[11:01:35.716]             }
[11:01:35.716]             function(cond) {
[11:01:35.716]                 is_error <- inherits(cond, "error")
[11:01:35.716]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.716]                   NULL)
[11:01:35.716]                 if (is_error) {
[11:01:35.716]                   sessionInformation <- function() {
[11:01:35.716]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.716]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.716]                       search = base::search(), system = base::Sys.info())
[11:01:35.716]                   }
[11:01:35.716]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.716]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.716]                     cond$call), session = sessionInformation(), 
[11:01:35.716]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.716]                   signalCondition(cond)
[11:01:35.716]                 }
[11:01:35.716]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.716]                 "immediateCondition"))) {
[11:01:35.716]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.716]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.716]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.716]                   if (TRUE && !signal) {
[11:01:35.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.716]                     {
[11:01:35.716]                       inherits <- base::inherits
[11:01:35.716]                       invokeRestart <- base::invokeRestart
[11:01:35.716]                       is.null <- base::is.null
[11:01:35.716]                       muffled <- FALSE
[11:01:35.716]                       if (inherits(cond, "message")) {
[11:01:35.716]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.716]                         if (muffled) 
[11:01:35.716]                           invokeRestart("muffleMessage")
[11:01:35.716]                       }
[11:01:35.716]                       else if (inherits(cond, "warning")) {
[11:01:35.716]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.716]                         if (muffled) 
[11:01:35.716]                           invokeRestart("muffleWarning")
[11:01:35.716]                       }
[11:01:35.716]                       else if (inherits(cond, "condition")) {
[11:01:35.716]                         if (!is.null(pattern)) {
[11:01:35.716]                           computeRestarts <- base::computeRestarts
[11:01:35.716]                           grepl <- base::grepl
[11:01:35.716]                           restarts <- computeRestarts(cond)
[11:01:35.716]                           for (restart in restarts) {
[11:01:35.716]                             name <- restart$name
[11:01:35.716]                             if (is.null(name)) 
[11:01:35.716]                               next
[11:01:35.716]                             if (!grepl(pattern, name)) 
[11:01:35.716]                               next
[11:01:35.716]                             invokeRestart(restart)
[11:01:35.716]                             muffled <- TRUE
[11:01:35.716]                             break
[11:01:35.716]                           }
[11:01:35.716]                         }
[11:01:35.716]                       }
[11:01:35.716]                       invisible(muffled)
[11:01:35.716]                     }
[11:01:35.716]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.716]                   }
[11:01:35.716]                 }
[11:01:35.716]                 else {
[11:01:35.716]                   if (TRUE) {
[11:01:35.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.716]                     {
[11:01:35.716]                       inherits <- base::inherits
[11:01:35.716]                       invokeRestart <- base::invokeRestart
[11:01:35.716]                       is.null <- base::is.null
[11:01:35.716]                       muffled <- FALSE
[11:01:35.716]                       if (inherits(cond, "message")) {
[11:01:35.716]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.716]                         if (muffled) 
[11:01:35.716]                           invokeRestart("muffleMessage")
[11:01:35.716]                       }
[11:01:35.716]                       else if (inherits(cond, "warning")) {
[11:01:35.716]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.716]                         if (muffled) 
[11:01:35.716]                           invokeRestart("muffleWarning")
[11:01:35.716]                       }
[11:01:35.716]                       else if (inherits(cond, "condition")) {
[11:01:35.716]                         if (!is.null(pattern)) {
[11:01:35.716]                           computeRestarts <- base::computeRestarts
[11:01:35.716]                           grepl <- base::grepl
[11:01:35.716]                           restarts <- computeRestarts(cond)
[11:01:35.716]                           for (restart in restarts) {
[11:01:35.716]                             name <- restart$name
[11:01:35.716]                             if (is.null(name)) 
[11:01:35.716]                               next
[11:01:35.716]                             if (!grepl(pattern, name)) 
[11:01:35.716]                               next
[11:01:35.716]                             invokeRestart(restart)
[11:01:35.716]                             muffled <- TRUE
[11:01:35.716]                             break
[11:01:35.716]                           }
[11:01:35.716]                         }
[11:01:35.716]                       }
[11:01:35.716]                       invisible(muffled)
[11:01:35.716]                     }
[11:01:35.716]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.716]                   }
[11:01:35.716]                 }
[11:01:35.716]             }
[11:01:35.716]         }))
[11:01:35.716]     }, error = function(ex) {
[11:01:35.716]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.716]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.716]                 ...future.rng), started = ...future.startTime, 
[11:01:35.716]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.716]             version = "1.8"), class = "FutureResult")
[11:01:35.716]     }, finally = {
[11:01:35.716]         if (!identical(...future.workdir, getwd())) 
[11:01:35.716]             setwd(...future.workdir)
[11:01:35.716]         {
[11:01:35.716]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.716]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.716]             }
[11:01:35.716]             base::options(...future.oldOptions)
[11:01:35.716]             if (.Platform$OS.type == "windows") {
[11:01:35.716]                 old_names <- names(...future.oldEnvVars)
[11:01:35.716]                 envs <- base::Sys.getenv()
[11:01:35.716]                 names <- names(envs)
[11:01:35.716]                 common <- intersect(names, old_names)
[11:01:35.716]                 added <- setdiff(names, old_names)
[11:01:35.716]                 removed <- setdiff(old_names, names)
[11:01:35.716]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.716]                   envs[common]]
[11:01:35.716]                 NAMES <- toupper(changed)
[11:01:35.716]                 args <- list()
[11:01:35.716]                 for (kk in seq_along(NAMES)) {
[11:01:35.716]                   name <- changed[[kk]]
[11:01:35.716]                   NAME <- NAMES[[kk]]
[11:01:35.716]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.716]                     next
[11:01:35.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.716]                 }
[11:01:35.716]                 NAMES <- toupper(added)
[11:01:35.716]                 for (kk in seq_along(NAMES)) {
[11:01:35.716]                   name <- added[[kk]]
[11:01:35.716]                   NAME <- NAMES[[kk]]
[11:01:35.716]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.716]                     next
[11:01:35.716]                   args[[name]] <- ""
[11:01:35.716]                 }
[11:01:35.716]                 NAMES <- toupper(removed)
[11:01:35.716]                 for (kk in seq_along(NAMES)) {
[11:01:35.716]                   name <- removed[[kk]]
[11:01:35.716]                   NAME <- NAMES[[kk]]
[11:01:35.716]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.716]                     next
[11:01:35.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.716]                 }
[11:01:35.716]                 if (length(args) > 0) 
[11:01:35.716]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.716]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.716]             }
[11:01:35.716]             else {
[11:01:35.716]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.716]             }
[11:01:35.716]             {
[11:01:35.716]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.716]                   0L) {
[11:01:35.716]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.716]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.716]                   base::options(opts)
[11:01:35.716]                 }
[11:01:35.716]                 {
[11:01:35.716]                   {
[11:01:35.716]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:35.716]                     NULL
[11:01:35.716]                   }
[11:01:35.716]                   options(future.plan = NULL)
[11:01:35.716]                   if (is.na(NA_character_)) 
[11:01:35.716]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.716]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.716]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.716]                     .init = FALSE)
[11:01:35.716]                 }
[11:01:35.716]             }
[11:01:35.716]         }
[11:01:35.716]     })
[11:01:35.716]     if (TRUE) {
[11:01:35.716]         base::sink(type = "output", split = FALSE)
[11:01:35.716]         if (TRUE) {
[11:01:35.716]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.716]         }
[11:01:35.716]         else {
[11:01:35.716]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.716]         }
[11:01:35.716]         base::close(...future.stdout)
[11:01:35.716]         ...future.stdout <- NULL
[11:01:35.716]     }
[11:01:35.716]     ...future.result$conditions <- ...future.conditions
[11:01:35.716]     ...future.result$finished <- base::Sys.time()
[11:01:35.716]     ...future.result
[11:01:35.716] }
[11:01:35.718] assign_globals() ...
[11:01:35.718] List of 2
[11:01:35.718]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[11:01:35.718]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[11:01:35.718]  - attr(*, "where")=List of 2
[11:01:35.718]   ..$ weight:<environment: R_EmptyEnv> 
[11:01:35.718]   ..$ group :<environment: R_EmptyEnv> 
[11:01:35.718]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:35.718]  - attr(*, "resolved")= logi FALSE
[11:01:35.718]  - attr(*, "total_size")= num 401
[11:01:35.718]  - attr(*, "already-done")= logi TRUE
[11:01:35.721] - copied ‘weight’ to environment
[11:01:35.721] - copied ‘group’ to environment
[11:01:35.721] assign_globals() ... done
[11:01:35.722] requestCore(): workers = 2
[11:01:35.724] MulticoreFuture started
[11:01:35.725] - Launch lazy future ... done
[11:01:35.725] run() for ‘MulticoreFuture’ ... done
[11:01:35.725] plan(): Setting new future strategy stack:
[11:01:35.726] result() for MulticoreFuture ...
[11:01:35.725] List of future strategies:
[11:01:35.725] 1. sequential:
[11:01:35.725]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.725]    - tweaked: FALSE
[11:01:35.725]    - call: NULL
[11:01:35.726] plan(): nbrOfWorkers() = 1
[11:01:35.730] plan(): Setting new future strategy stack:
[11:01:35.730] List of future strategies:
[11:01:35.730] 1. multicore:
[11:01:35.730]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:35.730]    - tweaked: FALSE
[11:01:35.730]    - call: plan(strategy)
[11:01:35.733] plan(): nbrOfWorkers() = 2
[11:01:35.738] result() for MulticoreFuture ...
[11:01:35.738] result() for MulticoreFuture ... done
[11:01:35.739] result() for MulticoreFuture ... done
[11:01:35.739] result() for MulticoreFuture ...
[11:01:35.739] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[11:01:35.741] getGlobalsAndPackages() ...
[11:01:35.741] Searching for globals...
[11:01:35.745] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[11:01:35.745] Searching for globals ... DONE
[11:01:35.746] Resolving globals: FALSE
[11:01:35.746] The total size of the 2 globals is 401 bytes (401 bytes)
[11:01:35.747] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[11:01:35.747] - globals: [2] ‘weight’, ‘group’
[11:01:35.747] - packages: [1] ‘stats’
[11:01:35.747] getGlobalsAndPackages() ... DONE
[11:01:35.748] run() for ‘Future’ ...
[11:01:35.748] - state: ‘created’
[11:01:35.748] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:35.750] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:35.750] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:35.750]   - Field: ‘label’
[11:01:35.750]   - Field: ‘local’
[11:01:35.750]   - Field: ‘owner’
[11:01:35.750]   - Field: ‘envir’
[11:01:35.751]   - Field: ‘workers’
[11:01:35.751]   - Field: ‘packages’
[11:01:35.751]   - Field: ‘gc’
[11:01:35.751]   - Field: ‘job’
[11:01:35.751]   - Field: ‘conditions’
[11:01:35.751]   - Field: ‘expr’
[11:01:35.751]   - Field: ‘uuid’
[11:01:35.751]   - Field: ‘seed’
[11:01:35.751]   - Field: ‘version’
[11:01:35.752]   - Field: ‘result’
[11:01:35.752]   - Field: ‘asynchronous’
[11:01:35.752]   - Field: ‘calls’
[11:01:35.752]   - Field: ‘globals’
[11:01:35.752]   - Field: ‘stdout’
[11:01:35.752]   - Field: ‘earlySignal’
[11:01:35.752]   - Field: ‘lazy’
[11:01:35.752]   - Field: ‘state’
[11:01:35.752] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:35.753] - Launch lazy future ...
[11:01:35.753] Packages needed by the future expression (n = 1): ‘stats’
[11:01:35.753] Packages needed by future strategies (n = 0): <none>
[11:01:35.754] {
[11:01:35.754]     {
[11:01:35.754]         {
[11:01:35.754]             ...future.startTime <- base::Sys.time()
[11:01:35.754]             {
[11:01:35.754]                 {
[11:01:35.754]                   {
[11:01:35.754]                     {
[11:01:35.754]                       {
[11:01:35.754]                         base::local({
[11:01:35.754]                           has_future <- base::requireNamespace("future", 
[11:01:35.754]                             quietly = TRUE)
[11:01:35.754]                           if (has_future) {
[11:01:35.754]                             ns <- base::getNamespace("future")
[11:01:35.754]                             version <- ns[[".package"]][["version"]]
[11:01:35.754]                             if (is.null(version)) 
[11:01:35.754]                               version <- utils::packageVersion("future")
[11:01:35.754]                           }
[11:01:35.754]                           else {
[11:01:35.754]                             version <- NULL
[11:01:35.754]                           }
[11:01:35.754]                           if (!has_future || version < "1.8.0") {
[11:01:35.754]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.754]                               "", base::R.version$version.string), 
[11:01:35.754]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:35.754]                                 base::R.version$platform, 8 * 
[11:01:35.754]                                   base::.Machine$sizeof.pointer), 
[11:01:35.754]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.754]                                 "release", "version")], collapse = " "), 
[11:01:35.754]                               hostname = base::Sys.info()[["nodename"]])
[11:01:35.754]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.754]                               info)
[11:01:35.754]                             info <- base::paste(info, collapse = "; ")
[11:01:35.754]                             if (!has_future) {
[11:01:35.754]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.754]                                 info)
[11:01:35.754]                             }
[11:01:35.754]                             else {
[11:01:35.754]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.754]                                 info, version)
[11:01:35.754]                             }
[11:01:35.754]                             base::stop(msg)
[11:01:35.754]                           }
[11:01:35.754]                         })
[11:01:35.754]                       }
[11:01:35.754]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:35.754]                       base::options(mc.cores = 1L)
[11:01:35.754]                     }
[11:01:35.754]                     base::local({
[11:01:35.754]                       for (pkg in "stats") {
[11:01:35.754]                         base::loadNamespace(pkg)
[11:01:35.754]                         base::library(pkg, character.only = TRUE)
[11:01:35.754]                       }
[11:01:35.754]                     })
[11:01:35.754]                   }
[11:01:35.754]                   ...future.strategy.old <- future::plan("list")
[11:01:35.754]                   options(future.plan = NULL)
[11:01:35.754]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.754]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.754]                 }
[11:01:35.754]                 ...future.workdir <- getwd()
[11:01:35.754]             }
[11:01:35.754]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.754]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.754]         }
[11:01:35.754]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.754]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.754]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.754]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.754]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.754]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.754]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.754]             base::names(...future.oldOptions))
[11:01:35.754]     }
[11:01:35.754]     if (FALSE) {
[11:01:35.754]     }
[11:01:35.754]     else {
[11:01:35.754]         if (TRUE) {
[11:01:35.754]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.754]                 open = "w")
[11:01:35.754]         }
[11:01:35.754]         else {
[11:01:35.754]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.754]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.754]         }
[11:01:35.754]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.754]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.754]             base::sink(type = "output", split = FALSE)
[11:01:35.754]             base::close(...future.stdout)
[11:01:35.754]         }, add = TRUE)
[11:01:35.754]     }
[11:01:35.754]     ...future.frame <- base::sys.nframe()
[11:01:35.754]     ...future.conditions <- base::list()
[11:01:35.754]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.754]     if (FALSE) {
[11:01:35.754]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.754]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.754]     }
[11:01:35.754]     ...future.result <- base::tryCatch({
[11:01:35.754]         base::withCallingHandlers({
[11:01:35.754]             ...future.value <- base::withVisible(base::local({
[11:01:35.754]                 withCallingHandlers({
[11:01:35.754]                   {
[11:01:35.754]                     lm(weight ~ group - 1)
[11:01:35.754]                   }
[11:01:35.754]                 }, immediateCondition = function(cond) {
[11:01:35.754]                   save_rds <- function (object, pathname, ...) 
[11:01:35.754]                   {
[11:01:35.754]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:35.754]                     if (file_test("-f", pathname_tmp)) {
[11:01:35.754]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.754]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:35.754]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.754]                         fi_tmp[["mtime"]])
[11:01:35.754]                     }
[11:01:35.754]                     tryCatch({
[11:01:35.754]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:35.754]                     }, error = function(ex) {
[11:01:35.754]                       msg <- conditionMessage(ex)
[11:01:35.754]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.754]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:35.754]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.754]                         fi_tmp[["mtime"]], msg)
[11:01:35.754]                       ex$message <- msg
[11:01:35.754]                       stop(ex)
[11:01:35.754]                     })
[11:01:35.754]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:35.754]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:35.754]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:35.754]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.754]                       fi <- file.info(pathname)
[11:01:35.754]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:35.754]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.754]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:35.754]                         fi[["size"]], fi[["mtime"]])
[11:01:35.754]                       stop(msg)
[11:01:35.754]                     }
[11:01:35.754]                     invisible(pathname)
[11:01:35.754]                   }
[11:01:35.754]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:35.754]                     rootPath = tempdir()) 
[11:01:35.754]                   {
[11:01:35.754]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:35.754]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:35.754]                       tmpdir = path, fileext = ".rds")
[11:01:35.754]                     save_rds(obj, file)
[11:01:35.754]                   }
[11:01:35.754]                   saveImmediateCondition(cond, path = "/tmp/Rtmpu6OqnW/.future/immediateConditions")
[11:01:35.754]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.754]                   {
[11:01:35.754]                     inherits <- base::inherits
[11:01:35.754]                     invokeRestart <- base::invokeRestart
[11:01:35.754]                     is.null <- base::is.null
[11:01:35.754]                     muffled <- FALSE
[11:01:35.754]                     if (inherits(cond, "message")) {
[11:01:35.754]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:35.754]                       if (muffled) 
[11:01:35.754]                         invokeRestart("muffleMessage")
[11:01:35.754]                     }
[11:01:35.754]                     else if (inherits(cond, "warning")) {
[11:01:35.754]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:35.754]                       if (muffled) 
[11:01:35.754]                         invokeRestart("muffleWarning")
[11:01:35.754]                     }
[11:01:35.754]                     else if (inherits(cond, "condition")) {
[11:01:35.754]                       if (!is.null(pattern)) {
[11:01:35.754]                         computeRestarts <- base::computeRestarts
[11:01:35.754]                         grepl <- base::grepl
[11:01:35.754]                         restarts <- computeRestarts(cond)
[11:01:35.754]                         for (restart in restarts) {
[11:01:35.754]                           name <- restart$name
[11:01:35.754]                           if (is.null(name)) 
[11:01:35.754]                             next
[11:01:35.754]                           if (!grepl(pattern, name)) 
[11:01:35.754]                             next
[11:01:35.754]                           invokeRestart(restart)
[11:01:35.754]                           muffled <- TRUE
[11:01:35.754]                           break
[11:01:35.754]                         }
[11:01:35.754]                       }
[11:01:35.754]                     }
[11:01:35.754]                     invisible(muffled)
[11:01:35.754]                   }
[11:01:35.754]                   muffleCondition(cond)
[11:01:35.754]                 })
[11:01:35.754]             }))
[11:01:35.754]             future::FutureResult(value = ...future.value$value, 
[11:01:35.754]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.754]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.754]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.754]                     ...future.globalenv.names))
[11:01:35.754]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.754]         }, condition = base::local({
[11:01:35.754]             c <- base::c
[11:01:35.754]             inherits <- base::inherits
[11:01:35.754]             invokeRestart <- base::invokeRestart
[11:01:35.754]             length <- base::length
[11:01:35.754]             list <- base::list
[11:01:35.754]             seq.int <- base::seq.int
[11:01:35.754]             signalCondition <- base::signalCondition
[11:01:35.754]             sys.calls <- base::sys.calls
[11:01:35.754]             `[[` <- base::`[[`
[11:01:35.754]             `+` <- base::`+`
[11:01:35.754]             `<<-` <- base::`<<-`
[11:01:35.754]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.754]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.754]                   3L)]
[11:01:35.754]             }
[11:01:35.754]             function(cond) {
[11:01:35.754]                 is_error <- inherits(cond, "error")
[11:01:35.754]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.754]                   NULL)
[11:01:35.754]                 if (is_error) {
[11:01:35.754]                   sessionInformation <- function() {
[11:01:35.754]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.754]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.754]                       search = base::search(), system = base::Sys.info())
[11:01:35.754]                   }
[11:01:35.754]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.754]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.754]                     cond$call), session = sessionInformation(), 
[11:01:35.754]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.754]                   signalCondition(cond)
[11:01:35.754]                 }
[11:01:35.754]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.754]                 "immediateCondition"))) {
[11:01:35.754]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.754]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.754]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.754]                   if (TRUE && !signal) {
[11:01:35.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.754]                     {
[11:01:35.754]                       inherits <- base::inherits
[11:01:35.754]                       invokeRestart <- base::invokeRestart
[11:01:35.754]                       is.null <- base::is.null
[11:01:35.754]                       muffled <- FALSE
[11:01:35.754]                       if (inherits(cond, "message")) {
[11:01:35.754]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.754]                         if (muffled) 
[11:01:35.754]                           invokeRestart("muffleMessage")
[11:01:35.754]                       }
[11:01:35.754]                       else if (inherits(cond, "warning")) {
[11:01:35.754]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.754]                         if (muffled) 
[11:01:35.754]                           invokeRestart("muffleWarning")
[11:01:35.754]                       }
[11:01:35.754]                       else if (inherits(cond, "condition")) {
[11:01:35.754]                         if (!is.null(pattern)) {
[11:01:35.754]                           computeRestarts <- base::computeRestarts
[11:01:35.754]                           grepl <- base::grepl
[11:01:35.754]                           restarts <- computeRestarts(cond)
[11:01:35.754]                           for (restart in restarts) {
[11:01:35.754]                             name <- restart$name
[11:01:35.754]                             if (is.null(name)) 
[11:01:35.754]                               next
[11:01:35.754]                             if (!grepl(pattern, name)) 
[11:01:35.754]                               next
[11:01:35.754]                             invokeRestart(restart)
[11:01:35.754]                             muffled <- TRUE
[11:01:35.754]                             break
[11:01:35.754]                           }
[11:01:35.754]                         }
[11:01:35.754]                       }
[11:01:35.754]                       invisible(muffled)
[11:01:35.754]                     }
[11:01:35.754]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.754]                   }
[11:01:35.754]                 }
[11:01:35.754]                 else {
[11:01:35.754]                   if (TRUE) {
[11:01:35.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.754]                     {
[11:01:35.754]                       inherits <- base::inherits
[11:01:35.754]                       invokeRestart <- base::invokeRestart
[11:01:35.754]                       is.null <- base::is.null
[11:01:35.754]                       muffled <- FALSE
[11:01:35.754]                       if (inherits(cond, "message")) {
[11:01:35.754]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.754]                         if (muffled) 
[11:01:35.754]                           invokeRestart("muffleMessage")
[11:01:35.754]                       }
[11:01:35.754]                       else if (inherits(cond, "warning")) {
[11:01:35.754]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.754]                         if (muffled) 
[11:01:35.754]                           invokeRestart("muffleWarning")
[11:01:35.754]                       }
[11:01:35.754]                       else if (inherits(cond, "condition")) {
[11:01:35.754]                         if (!is.null(pattern)) {
[11:01:35.754]                           computeRestarts <- base::computeRestarts
[11:01:35.754]                           grepl <- base::grepl
[11:01:35.754]                           restarts <- computeRestarts(cond)
[11:01:35.754]                           for (restart in restarts) {
[11:01:35.754]                             name <- restart$name
[11:01:35.754]                             if (is.null(name)) 
[11:01:35.754]                               next
[11:01:35.754]                             if (!grepl(pattern, name)) 
[11:01:35.754]                               next
[11:01:35.754]                             invokeRestart(restart)
[11:01:35.754]                             muffled <- TRUE
[11:01:35.754]                             break
[11:01:35.754]                           }
[11:01:35.754]                         }
[11:01:35.754]                       }
[11:01:35.754]                       invisible(muffled)
[11:01:35.754]                     }
[11:01:35.754]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.754]                   }
[11:01:35.754]                 }
[11:01:35.754]             }
[11:01:35.754]         }))
[11:01:35.754]     }, error = function(ex) {
[11:01:35.754]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.754]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.754]                 ...future.rng), started = ...future.startTime, 
[11:01:35.754]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.754]             version = "1.8"), class = "FutureResult")
[11:01:35.754]     }, finally = {
[11:01:35.754]         if (!identical(...future.workdir, getwd())) 
[11:01:35.754]             setwd(...future.workdir)
[11:01:35.754]         {
[11:01:35.754]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.754]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.754]             }
[11:01:35.754]             base::options(...future.oldOptions)
[11:01:35.754]             if (.Platform$OS.type == "windows") {
[11:01:35.754]                 old_names <- names(...future.oldEnvVars)
[11:01:35.754]                 envs <- base::Sys.getenv()
[11:01:35.754]                 names <- names(envs)
[11:01:35.754]                 common <- intersect(names, old_names)
[11:01:35.754]                 added <- setdiff(names, old_names)
[11:01:35.754]                 removed <- setdiff(old_names, names)
[11:01:35.754]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.754]                   envs[common]]
[11:01:35.754]                 NAMES <- toupper(changed)
[11:01:35.754]                 args <- list()
[11:01:35.754]                 for (kk in seq_along(NAMES)) {
[11:01:35.754]                   name <- changed[[kk]]
[11:01:35.754]                   NAME <- NAMES[[kk]]
[11:01:35.754]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.754]                     next
[11:01:35.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.754]                 }
[11:01:35.754]                 NAMES <- toupper(added)
[11:01:35.754]                 for (kk in seq_along(NAMES)) {
[11:01:35.754]                   name <- added[[kk]]
[11:01:35.754]                   NAME <- NAMES[[kk]]
[11:01:35.754]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.754]                     next
[11:01:35.754]                   args[[name]] <- ""
[11:01:35.754]                 }
[11:01:35.754]                 NAMES <- toupper(removed)
[11:01:35.754]                 for (kk in seq_along(NAMES)) {
[11:01:35.754]                   name <- removed[[kk]]
[11:01:35.754]                   NAME <- NAMES[[kk]]
[11:01:35.754]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.754]                     next
[11:01:35.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.754]                 }
[11:01:35.754]                 if (length(args) > 0) 
[11:01:35.754]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.754]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.754]             }
[11:01:35.754]             else {
[11:01:35.754]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.754]             }
[11:01:35.754]             {
[11:01:35.754]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.754]                   0L) {
[11:01:35.754]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.754]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.754]                   base::options(opts)
[11:01:35.754]                 }
[11:01:35.754]                 {
[11:01:35.754]                   {
[11:01:35.754]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:35.754]                     NULL
[11:01:35.754]                   }
[11:01:35.754]                   options(future.plan = NULL)
[11:01:35.754]                   if (is.na(NA_character_)) 
[11:01:35.754]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.754]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.754]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.754]                     .init = FALSE)
[11:01:35.754]                 }
[11:01:35.754]             }
[11:01:35.754]         }
[11:01:35.754]     })
[11:01:35.754]     if (TRUE) {
[11:01:35.754]         base::sink(type = "output", split = FALSE)
[11:01:35.754]         if (TRUE) {
[11:01:35.754]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.754]         }
[11:01:35.754]         else {
[11:01:35.754]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.754]         }
[11:01:35.754]         base::close(...future.stdout)
[11:01:35.754]         ...future.stdout <- NULL
[11:01:35.754]     }
[11:01:35.754]     ...future.result$conditions <- ...future.conditions
[11:01:35.754]     ...future.result$finished <- base::Sys.time()
[11:01:35.754]     ...future.result
[11:01:35.754] }
[11:01:35.756] assign_globals() ...
[11:01:35.756] List of 2
[11:01:35.756]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[11:01:35.756]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[11:01:35.756]  - attr(*, "where")=List of 2
[11:01:35.756]   ..$ weight:<environment: R_EmptyEnv> 
[11:01:35.756]   ..$ group :<environment: R_EmptyEnv> 
[11:01:35.756]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:35.756]  - attr(*, "resolved")= logi FALSE
[11:01:35.756]  - attr(*, "total_size")= num 401
[11:01:35.756]  - attr(*, "already-done")= logi TRUE
[11:01:35.760] - copied ‘weight’ to environment
[11:01:35.760] - copied ‘group’ to environment
[11:01:35.760] assign_globals() ... done
[11:01:35.760] requestCore(): workers = 2
[11:01:35.761] MulticoreFuture started
[11:01:35.762] - Launch lazy future ... done
[11:01:35.762] run() for ‘MulticoreFuture’ ... done
[11:01:35.762] result() for MulticoreFuture ...
[11:01:35.763] plan(): Setting new future strategy stack:
[11:01:35.763] List of future strategies:
[11:01:35.763] 1. sequential:
[11:01:35.763]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.763]    - tweaked: FALSE
[11:01:35.763]    - call: NULL
[11:01:35.764] plan(): nbrOfWorkers() = 1
[11:01:35.767] plan(): Setting new future strategy stack:
[11:01:35.767] List of future strategies:
[11:01:35.767] 1. multicore:
[11:01:35.767]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:35.767]    - tweaked: FALSE
[11:01:35.767]    - call: plan(strategy)
[11:01:35.770] plan(): nbrOfWorkers() = 2
[11:01:35.773] result() for MulticoreFuture ...
[11:01:35.773] result() for MulticoreFuture ... done
[11:01:35.773] result() for MulticoreFuture ... done
[11:01:35.773] result() for MulticoreFuture ...
[11:01:35.773] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[11:01:35.776] getGlobalsAndPackages() ...
[11:01:35.776] Searching for globals...
[11:01:35.778] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[11:01:35.778] Searching for globals ... DONE
[11:01:35.778] Resolving globals: FALSE
[11:01:35.778] The total size of the 2 globals is 401 bytes (401 bytes)
[11:01:35.779] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[11:01:35.779] - globals: [2] ‘weight’, ‘group’
[11:01:35.779] - packages: [1] ‘stats’
[11:01:35.779] getGlobalsAndPackages() ... DONE
[11:01:35.780] run() for ‘Future’ ...
[11:01:35.780] - state: ‘created’
[11:01:35.780] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:35.782] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:35.782] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:35.782]   - Field: ‘label’
[11:01:35.782]   - Field: ‘local’
[11:01:35.782]   - Field: ‘owner’
[11:01:35.783]   - Field: ‘envir’
[11:01:35.785]   - Field: ‘workers’
[11:01:35.785]   - Field: ‘packages’
[11:01:35.785]   - Field: ‘gc’
[11:01:35.785]   - Field: ‘job’
[11:01:35.785]   - Field: ‘conditions’
[11:01:35.785]   - Field: ‘expr’
[11:01:35.785]   - Field: ‘uuid’
[11:01:35.785]   - Field: ‘seed’
[11:01:35.786]   - Field: ‘version’
[11:01:35.786]   - Field: ‘result’
[11:01:35.786]   - Field: ‘asynchronous’
[11:01:35.786]   - Field: ‘calls’
[11:01:35.786]   - Field: ‘globals’
[11:01:35.786]   - Field: ‘stdout’
[11:01:35.786]   - Field: ‘earlySignal’
[11:01:35.787]   - Field: ‘lazy’
[11:01:35.787]   - Field: ‘state’
[11:01:35.787] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:35.787] - Launch lazy future ...
[11:01:35.787] Packages needed by the future expression (n = 1): ‘stats’
[11:01:35.787] Packages needed by future strategies (n = 0): <none>
[11:01:35.788] {
[11:01:35.788]     {
[11:01:35.788]         {
[11:01:35.788]             ...future.startTime <- base::Sys.time()
[11:01:35.788]             {
[11:01:35.788]                 {
[11:01:35.788]                   {
[11:01:35.788]                     {
[11:01:35.788]                       {
[11:01:35.788]                         base::local({
[11:01:35.788]                           has_future <- base::requireNamespace("future", 
[11:01:35.788]                             quietly = TRUE)
[11:01:35.788]                           if (has_future) {
[11:01:35.788]                             ns <- base::getNamespace("future")
[11:01:35.788]                             version <- ns[[".package"]][["version"]]
[11:01:35.788]                             if (is.null(version)) 
[11:01:35.788]                               version <- utils::packageVersion("future")
[11:01:35.788]                           }
[11:01:35.788]                           else {
[11:01:35.788]                             version <- NULL
[11:01:35.788]                           }
[11:01:35.788]                           if (!has_future || version < "1.8.0") {
[11:01:35.788]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.788]                               "", base::R.version$version.string), 
[11:01:35.788]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:35.788]                                 base::R.version$platform, 8 * 
[11:01:35.788]                                   base::.Machine$sizeof.pointer), 
[11:01:35.788]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.788]                                 "release", "version")], collapse = " "), 
[11:01:35.788]                               hostname = base::Sys.info()[["nodename"]])
[11:01:35.788]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.788]                               info)
[11:01:35.788]                             info <- base::paste(info, collapse = "; ")
[11:01:35.788]                             if (!has_future) {
[11:01:35.788]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.788]                                 info)
[11:01:35.788]                             }
[11:01:35.788]                             else {
[11:01:35.788]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.788]                                 info, version)
[11:01:35.788]                             }
[11:01:35.788]                             base::stop(msg)
[11:01:35.788]                           }
[11:01:35.788]                         })
[11:01:35.788]                       }
[11:01:35.788]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:35.788]                       base::options(mc.cores = 1L)
[11:01:35.788]                     }
[11:01:35.788]                     base::local({
[11:01:35.788]                       for (pkg in "stats") {
[11:01:35.788]                         base::loadNamespace(pkg)
[11:01:35.788]                         base::library(pkg, character.only = TRUE)
[11:01:35.788]                       }
[11:01:35.788]                     })
[11:01:35.788]                   }
[11:01:35.788]                   ...future.strategy.old <- future::plan("list")
[11:01:35.788]                   options(future.plan = NULL)
[11:01:35.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.788]                 }
[11:01:35.788]                 ...future.workdir <- getwd()
[11:01:35.788]             }
[11:01:35.788]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.788]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.788]         }
[11:01:35.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.788]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.788]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.788]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.788]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.788]             base::names(...future.oldOptions))
[11:01:35.788]     }
[11:01:35.788]     if (FALSE) {
[11:01:35.788]     }
[11:01:35.788]     else {
[11:01:35.788]         if (TRUE) {
[11:01:35.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.788]                 open = "w")
[11:01:35.788]         }
[11:01:35.788]         else {
[11:01:35.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.788]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.788]         }
[11:01:35.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.788]             base::sink(type = "output", split = FALSE)
[11:01:35.788]             base::close(...future.stdout)
[11:01:35.788]         }, add = TRUE)
[11:01:35.788]     }
[11:01:35.788]     ...future.frame <- base::sys.nframe()
[11:01:35.788]     ...future.conditions <- base::list()
[11:01:35.788]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.788]     if (FALSE) {
[11:01:35.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.788]     }
[11:01:35.788]     ...future.result <- base::tryCatch({
[11:01:35.788]         base::withCallingHandlers({
[11:01:35.788]             ...future.value <- base::withVisible(base::local({
[11:01:35.788]                 withCallingHandlers({
[11:01:35.788]                   {
[11:01:35.788]                     lm(weight ~ group - 1)
[11:01:35.788]                   }
[11:01:35.788]                 }, immediateCondition = function(cond) {
[11:01:35.788]                   save_rds <- function (object, pathname, ...) 
[11:01:35.788]                   {
[11:01:35.788]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:35.788]                     if (file_test("-f", pathname_tmp)) {
[11:01:35.788]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.788]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:35.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.788]                         fi_tmp[["mtime"]])
[11:01:35.788]                     }
[11:01:35.788]                     tryCatch({
[11:01:35.788]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:35.788]                     }, error = function(ex) {
[11:01:35.788]                       msg <- conditionMessage(ex)
[11:01:35.788]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.788]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:35.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.788]                         fi_tmp[["mtime"]], msg)
[11:01:35.788]                       ex$message <- msg
[11:01:35.788]                       stop(ex)
[11:01:35.788]                     })
[11:01:35.788]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:35.788]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:35.788]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:35.788]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.788]                       fi <- file.info(pathname)
[11:01:35.788]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:35.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.788]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:35.788]                         fi[["size"]], fi[["mtime"]])
[11:01:35.788]                       stop(msg)
[11:01:35.788]                     }
[11:01:35.788]                     invisible(pathname)
[11:01:35.788]                   }
[11:01:35.788]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:35.788]                     rootPath = tempdir()) 
[11:01:35.788]                   {
[11:01:35.788]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:35.788]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:35.788]                       tmpdir = path, fileext = ".rds")
[11:01:35.788]                     save_rds(obj, file)
[11:01:35.788]                   }
[11:01:35.788]                   saveImmediateCondition(cond, path = "/tmp/Rtmpu6OqnW/.future/immediateConditions")
[11:01:35.788]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.788]                   {
[11:01:35.788]                     inherits <- base::inherits
[11:01:35.788]                     invokeRestart <- base::invokeRestart
[11:01:35.788]                     is.null <- base::is.null
[11:01:35.788]                     muffled <- FALSE
[11:01:35.788]                     if (inherits(cond, "message")) {
[11:01:35.788]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:35.788]                       if (muffled) 
[11:01:35.788]                         invokeRestart("muffleMessage")
[11:01:35.788]                     }
[11:01:35.788]                     else if (inherits(cond, "warning")) {
[11:01:35.788]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:35.788]                       if (muffled) 
[11:01:35.788]                         invokeRestart("muffleWarning")
[11:01:35.788]                     }
[11:01:35.788]                     else if (inherits(cond, "condition")) {
[11:01:35.788]                       if (!is.null(pattern)) {
[11:01:35.788]                         computeRestarts <- base::computeRestarts
[11:01:35.788]                         grepl <- base::grepl
[11:01:35.788]                         restarts <- computeRestarts(cond)
[11:01:35.788]                         for (restart in restarts) {
[11:01:35.788]                           name <- restart$name
[11:01:35.788]                           if (is.null(name)) 
[11:01:35.788]                             next
[11:01:35.788]                           if (!grepl(pattern, name)) 
[11:01:35.788]                             next
[11:01:35.788]                           invokeRestart(restart)
[11:01:35.788]                           muffled <- TRUE
[11:01:35.788]                           break
[11:01:35.788]                         }
[11:01:35.788]                       }
[11:01:35.788]                     }
[11:01:35.788]                     invisible(muffled)
[11:01:35.788]                   }
[11:01:35.788]                   muffleCondition(cond)
[11:01:35.788]                 })
[11:01:35.788]             }))
[11:01:35.788]             future::FutureResult(value = ...future.value$value, 
[11:01:35.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.788]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.788]                     ...future.globalenv.names))
[11:01:35.788]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.788]         }, condition = base::local({
[11:01:35.788]             c <- base::c
[11:01:35.788]             inherits <- base::inherits
[11:01:35.788]             invokeRestart <- base::invokeRestart
[11:01:35.788]             length <- base::length
[11:01:35.788]             list <- base::list
[11:01:35.788]             seq.int <- base::seq.int
[11:01:35.788]             signalCondition <- base::signalCondition
[11:01:35.788]             sys.calls <- base::sys.calls
[11:01:35.788]             `[[` <- base::`[[`
[11:01:35.788]             `+` <- base::`+`
[11:01:35.788]             `<<-` <- base::`<<-`
[11:01:35.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.788]                   3L)]
[11:01:35.788]             }
[11:01:35.788]             function(cond) {
[11:01:35.788]                 is_error <- inherits(cond, "error")
[11:01:35.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.788]                   NULL)
[11:01:35.788]                 if (is_error) {
[11:01:35.788]                   sessionInformation <- function() {
[11:01:35.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.788]                       search = base::search(), system = base::Sys.info())
[11:01:35.788]                   }
[11:01:35.788]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.788]                     cond$call), session = sessionInformation(), 
[11:01:35.788]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.788]                   signalCondition(cond)
[11:01:35.788]                 }
[11:01:35.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.788]                 "immediateCondition"))) {
[11:01:35.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.788]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.788]                   if (TRUE && !signal) {
[11:01:35.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.788]                     {
[11:01:35.788]                       inherits <- base::inherits
[11:01:35.788]                       invokeRestart <- base::invokeRestart
[11:01:35.788]                       is.null <- base::is.null
[11:01:35.788]                       muffled <- FALSE
[11:01:35.788]                       if (inherits(cond, "message")) {
[11:01:35.788]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.788]                         if (muffled) 
[11:01:35.788]                           invokeRestart("muffleMessage")
[11:01:35.788]                       }
[11:01:35.788]                       else if (inherits(cond, "warning")) {
[11:01:35.788]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.788]                         if (muffled) 
[11:01:35.788]                           invokeRestart("muffleWarning")
[11:01:35.788]                       }
[11:01:35.788]                       else if (inherits(cond, "condition")) {
[11:01:35.788]                         if (!is.null(pattern)) {
[11:01:35.788]                           computeRestarts <- base::computeRestarts
[11:01:35.788]                           grepl <- base::grepl
[11:01:35.788]                           restarts <- computeRestarts(cond)
[11:01:35.788]                           for (restart in restarts) {
[11:01:35.788]                             name <- restart$name
[11:01:35.788]                             if (is.null(name)) 
[11:01:35.788]                               next
[11:01:35.788]                             if (!grepl(pattern, name)) 
[11:01:35.788]                               next
[11:01:35.788]                             invokeRestart(restart)
[11:01:35.788]                             muffled <- TRUE
[11:01:35.788]                             break
[11:01:35.788]                           }
[11:01:35.788]                         }
[11:01:35.788]                       }
[11:01:35.788]                       invisible(muffled)
[11:01:35.788]                     }
[11:01:35.788]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.788]                   }
[11:01:35.788]                 }
[11:01:35.788]                 else {
[11:01:35.788]                   if (TRUE) {
[11:01:35.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.788]                     {
[11:01:35.788]                       inherits <- base::inherits
[11:01:35.788]                       invokeRestart <- base::invokeRestart
[11:01:35.788]                       is.null <- base::is.null
[11:01:35.788]                       muffled <- FALSE
[11:01:35.788]                       if (inherits(cond, "message")) {
[11:01:35.788]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.788]                         if (muffled) 
[11:01:35.788]                           invokeRestart("muffleMessage")
[11:01:35.788]                       }
[11:01:35.788]                       else if (inherits(cond, "warning")) {
[11:01:35.788]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.788]                         if (muffled) 
[11:01:35.788]                           invokeRestart("muffleWarning")
[11:01:35.788]                       }
[11:01:35.788]                       else if (inherits(cond, "condition")) {
[11:01:35.788]                         if (!is.null(pattern)) {
[11:01:35.788]                           computeRestarts <- base::computeRestarts
[11:01:35.788]                           grepl <- base::grepl
[11:01:35.788]                           restarts <- computeRestarts(cond)
[11:01:35.788]                           for (restart in restarts) {
[11:01:35.788]                             name <- restart$name
[11:01:35.788]                             if (is.null(name)) 
[11:01:35.788]                               next
[11:01:35.788]                             if (!grepl(pattern, name)) 
[11:01:35.788]                               next
[11:01:35.788]                             invokeRestart(restart)
[11:01:35.788]                             muffled <- TRUE
[11:01:35.788]                             break
[11:01:35.788]                           }
[11:01:35.788]                         }
[11:01:35.788]                       }
[11:01:35.788]                       invisible(muffled)
[11:01:35.788]                     }
[11:01:35.788]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.788]                   }
[11:01:35.788]                 }
[11:01:35.788]             }
[11:01:35.788]         }))
[11:01:35.788]     }, error = function(ex) {
[11:01:35.788]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.788]                 ...future.rng), started = ...future.startTime, 
[11:01:35.788]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.788]             version = "1.8"), class = "FutureResult")
[11:01:35.788]     }, finally = {
[11:01:35.788]         if (!identical(...future.workdir, getwd())) 
[11:01:35.788]             setwd(...future.workdir)
[11:01:35.788]         {
[11:01:35.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.788]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.788]             }
[11:01:35.788]             base::options(...future.oldOptions)
[11:01:35.788]             if (.Platform$OS.type == "windows") {
[11:01:35.788]                 old_names <- names(...future.oldEnvVars)
[11:01:35.788]                 envs <- base::Sys.getenv()
[11:01:35.788]                 names <- names(envs)
[11:01:35.788]                 common <- intersect(names, old_names)
[11:01:35.788]                 added <- setdiff(names, old_names)
[11:01:35.788]                 removed <- setdiff(old_names, names)
[11:01:35.788]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.788]                   envs[common]]
[11:01:35.788]                 NAMES <- toupper(changed)
[11:01:35.788]                 args <- list()
[11:01:35.788]                 for (kk in seq_along(NAMES)) {
[11:01:35.788]                   name <- changed[[kk]]
[11:01:35.788]                   NAME <- NAMES[[kk]]
[11:01:35.788]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.788]                     next
[11:01:35.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.788]                 }
[11:01:35.788]                 NAMES <- toupper(added)
[11:01:35.788]                 for (kk in seq_along(NAMES)) {
[11:01:35.788]                   name <- added[[kk]]
[11:01:35.788]                   NAME <- NAMES[[kk]]
[11:01:35.788]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.788]                     next
[11:01:35.788]                   args[[name]] <- ""
[11:01:35.788]                 }
[11:01:35.788]                 NAMES <- toupper(removed)
[11:01:35.788]                 for (kk in seq_along(NAMES)) {
[11:01:35.788]                   name <- removed[[kk]]
[11:01:35.788]                   NAME <- NAMES[[kk]]
[11:01:35.788]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.788]                     next
[11:01:35.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.788]                 }
[11:01:35.788]                 if (length(args) > 0) 
[11:01:35.788]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.788]             }
[11:01:35.788]             else {
[11:01:35.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.788]             }
[11:01:35.788]             {
[11:01:35.788]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.788]                   0L) {
[11:01:35.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.788]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.788]                   base::options(opts)
[11:01:35.788]                 }
[11:01:35.788]                 {
[11:01:35.788]                   {
[11:01:35.788]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:35.788]                     NULL
[11:01:35.788]                   }
[11:01:35.788]                   options(future.plan = NULL)
[11:01:35.788]                   if (is.na(NA_character_)) 
[11:01:35.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.788]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.788]                     .init = FALSE)
[11:01:35.788]                 }
[11:01:35.788]             }
[11:01:35.788]         }
[11:01:35.788]     })
[11:01:35.788]     if (TRUE) {
[11:01:35.788]         base::sink(type = "output", split = FALSE)
[11:01:35.788]         if (TRUE) {
[11:01:35.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.788]         }
[11:01:35.788]         else {
[11:01:35.788]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.788]         }
[11:01:35.788]         base::close(...future.stdout)
[11:01:35.788]         ...future.stdout <- NULL
[11:01:35.788]     }
[11:01:35.788]     ...future.result$conditions <- ...future.conditions
[11:01:35.788]     ...future.result$finished <- base::Sys.time()
[11:01:35.788]     ...future.result
[11:01:35.788] }
[11:01:35.790] assign_globals() ...
[11:01:35.791] List of 2
[11:01:35.791]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[11:01:35.791]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[11:01:35.791]  - attr(*, "where")=List of 2
[11:01:35.791]   ..$ weight:<environment: R_EmptyEnv> 
[11:01:35.791]   ..$ group :<environment: R_EmptyEnv> 
[11:01:35.791]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:35.791]  - attr(*, "resolved")= logi FALSE
[11:01:35.791]  - attr(*, "total_size")= num 401
[11:01:35.791]  - attr(*, "already-done")= logi TRUE
[11:01:35.794] - copied ‘weight’ to environment
[11:01:35.794] - copied ‘group’ to environment
[11:01:35.795] assign_globals() ... done
[11:01:35.795] requestCore(): workers = 2
[11:01:35.796] MulticoreFuture started
[11:01:35.797] - Launch lazy future ... done
[11:01:35.797] run() for ‘MulticoreFuture’ ... done
[11:01:35.797] result() for MulticoreFuture ...
[11:01:35.798] plan(): Setting new future strategy stack:
[11:01:35.798] List of future strategies:
[11:01:35.798] 1. sequential:
[11:01:35.798]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.798]    - tweaked: FALSE
[11:01:35.798]    - call: NULL
[11:01:35.799] plan(): nbrOfWorkers() = 1
[11:01:35.802] plan(): Setting new future strategy stack:
[11:01:35.802] List of future strategies:
[11:01:35.802] 1. multicore:
[11:01:35.802]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:35.802]    - tweaked: FALSE
[11:01:35.802]    - call: plan(strategy)
[11:01:35.805] plan(): nbrOfWorkers() = 2
[11:01:35.807] result() for MulticoreFuture ...
[11:01:35.807] result() for MulticoreFuture ... done
[11:01:35.807] result() for MulticoreFuture ... done
[11:01:35.808] result() for MulticoreFuture ...
[11:01:35.808] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[11:01:35.810] getGlobalsAndPackages() ...
[11:01:35.810] Searching for globals...
[11:01:35.812] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[11:01:35.812] Searching for globals ... DONE
[11:01:35.812] Resolving globals: FALSE
[11:01:35.813] The total size of the 2 globals is 401 bytes (401 bytes)
[11:01:35.814] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[11:01:35.814] - globals: [2] ‘weight’, ‘group’
[11:01:35.814] - packages: [1] ‘stats’
[11:01:35.814] getGlobalsAndPackages() ... DONE
[11:01:35.814] run() for ‘Future’ ...
[11:01:35.814] - state: ‘created’
[11:01:35.815] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:35.817] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:35.817] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:35.817]   - Field: ‘label’
[11:01:35.817]   - Field: ‘local’
[11:01:35.817]   - Field: ‘owner’
[11:01:35.817]   - Field: ‘envir’
[11:01:35.817]   - Field: ‘workers’
[11:01:35.817]   - Field: ‘packages’
[11:01:35.818]   - Field: ‘gc’
[11:01:35.818]   - Field: ‘job’
[11:01:35.818]   - Field: ‘conditions’
[11:01:35.818]   - Field: ‘expr’
[11:01:35.818]   - Field: ‘uuid’
[11:01:35.818]   - Field: ‘seed’
[11:01:35.818]   - Field: ‘version’
[11:01:35.818]   - Field: ‘result’
[11:01:35.818]   - Field: ‘asynchronous’
[11:01:35.818]   - Field: ‘calls’
[11:01:35.819]   - Field: ‘globals’
[11:01:35.819]   - Field: ‘stdout’
[11:01:35.819]   - Field: ‘earlySignal’
[11:01:35.819]   - Field: ‘lazy’
[11:01:35.819]   - Field: ‘state’
[11:01:35.819] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:35.819] - Launch lazy future ...
[11:01:35.819] Packages needed by the future expression (n = 1): ‘stats’
[11:01:35.820] Packages needed by future strategies (n = 0): <none>
[11:01:35.820] {
[11:01:35.820]     {
[11:01:35.820]         {
[11:01:35.820]             ...future.startTime <- base::Sys.time()
[11:01:35.820]             {
[11:01:35.820]                 {
[11:01:35.820]                   {
[11:01:35.820]                     {
[11:01:35.820]                       {
[11:01:35.820]                         base::local({
[11:01:35.820]                           has_future <- base::requireNamespace("future", 
[11:01:35.820]                             quietly = TRUE)
[11:01:35.820]                           if (has_future) {
[11:01:35.820]                             ns <- base::getNamespace("future")
[11:01:35.820]                             version <- ns[[".package"]][["version"]]
[11:01:35.820]                             if (is.null(version)) 
[11:01:35.820]                               version <- utils::packageVersion("future")
[11:01:35.820]                           }
[11:01:35.820]                           else {
[11:01:35.820]                             version <- NULL
[11:01:35.820]                           }
[11:01:35.820]                           if (!has_future || version < "1.8.0") {
[11:01:35.820]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.820]                               "", base::R.version$version.string), 
[11:01:35.820]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:35.820]                                 base::R.version$platform, 8 * 
[11:01:35.820]                                   base::.Machine$sizeof.pointer), 
[11:01:35.820]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.820]                                 "release", "version")], collapse = " "), 
[11:01:35.820]                               hostname = base::Sys.info()[["nodename"]])
[11:01:35.820]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.820]                               info)
[11:01:35.820]                             info <- base::paste(info, collapse = "; ")
[11:01:35.820]                             if (!has_future) {
[11:01:35.820]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.820]                                 info)
[11:01:35.820]                             }
[11:01:35.820]                             else {
[11:01:35.820]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.820]                                 info, version)
[11:01:35.820]                             }
[11:01:35.820]                             base::stop(msg)
[11:01:35.820]                           }
[11:01:35.820]                         })
[11:01:35.820]                       }
[11:01:35.820]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:35.820]                       base::options(mc.cores = 1L)
[11:01:35.820]                     }
[11:01:35.820]                     base::local({
[11:01:35.820]                       for (pkg in "stats") {
[11:01:35.820]                         base::loadNamespace(pkg)
[11:01:35.820]                         base::library(pkg, character.only = TRUE)
[11:01:35.820]                       }
[11:01:35.820]                     })
[11:01:35.820]                   }
[11:01:35.820]                   ...future.strategy.old <- future::plan("list")
[11:01:35.820]                   options(future.plan = NULL)
[11:01:35.820]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.820]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.820]                 }
[11:01:35.820]                 ...future.workdir <- getwd()
[11:01:35.820]             }
[11:01:35.820]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.820]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.820]         }
[11:01:35.820]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.820]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.820]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.820]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.820]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.820]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.820]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.820]             base::names(...future.oldOptions))
[11:01:35.820]     }
[11:01:35.820]     if (FALSE) {
[11:01:35.820]     }
[11:01:35.820]     else {
[11:01:35.820]         if (TRUE) {
[11:01:35.820]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.820]                 open = "w")
[11:01:35.820]         }
[11:01:35.820]         else {
[11:01:35.820]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.820]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.820]         }
[11:01:35.820]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.820]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.820]             base::sink(type = "output", split = FALSE)
[11:01:35.820]             base::close(...future.stdout)
[11:01:35.820]         }, add = TRUE)
[11:01:35.820]     }
[11:01:35.820]     ...future.frame <- base::sys.nframe()
[11:01:35.820]     ...future.conditions <- base::list()
[11:01:35.820]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.820]     if (FALSE) {
[11:01:35.820]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.820]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.820]     }
[11:01:35.820]     ...future.result <- base::tryCatch({
[11:01:35.820]         base::withCallingHandlers({
[11:01:35.820]             ...future.value <- base::withVisible(base::local({
[11:01:35.820]                 withCallingHandlers({
[11:01:35.820]                   {
[11:01:35.820]                     lm(weight ~ group - 1)
[11:01:35.820]                   }
[11:01:35.820]                 }, immediateCondition = function(cond) {
[11:01:35.820]                   save_rds <- function (object, pathname, ...) 
[11:01:35.820]                   {
[11:01:35.820]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:35.820]                     if (file_test("-f", pathname_tmp)) {
[11:01:35.820]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.820]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:35.820]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.820]                         fi_tmp[["mtime"]])
[11:01:35.820]                     }
[11:01:35.820]                     tryCatch({
[11:01:35.820]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:35.820]                     }, error = function(ex) {
[11:01:35.820]                       msg <- conditionMessage(ex)
[11:01:35.820]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.820]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:35.820]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.820]                         fi_tmp[["mtime"]], msg)
[11:01:35.820]                       ex$message <- msg
[11:01:35.820]                       stop(ex)
[11:01:35.820]                     })
[11:01:35.820]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:35.820]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:35.820]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:35.820]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.820]                       fi <- file.info(pathname)
[11:01:35.820]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:35.820]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.820]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:35.820]                         fi[["size"]], fi[["mtime"]])
[11:01:35.820]                       stop(msg)
[11:01:35.820]                     }
[11:01:35.820]                     invisible(pathname)
[11:01:35.820]                   }
[11:01:35.820]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:35.820]                     rootPath = tempdir()) 
[11:01:35.820]                   {
[11:01:35.820]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:35.820]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:35.820]                       tmpdir = path, fileext = ".rds")
[11:01:35.820]                     save_rds(obj, file)
[11:01:35.820]                   }
[11:01:35.820]                   saveImmediateCondition(cond, path = "/tmp/Rtmpu6OqnW/.future/immediateConditions")
[11:01:35.820]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.820]                   {
[11:01:35.820]                     inherits <- base::inherits
[11:01:35.820]                     invokeRestart <- base::invokeRestart
[11:01:35.820]                     is.null <- base::is.null
[11:01:35.820]                     muffled <- FALSE
[11:01:35.820]                     if (inherits(cond, "message")) {
[11:01:35.820]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:35.820]                       if (muffled) 
[11:01:35.820]                         invokeRestart("muffleMessage")
[11:01:35.820]                     }
[11:01:35.820]                     else if (inherits(cond, "warning")) {
[11:01:35.820]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:35.820]                       if (muffled) 
[11:01:35.820]                         invokeRestart("muffleWarning")
[11:01:35.820]                     }
[11:01:35.820]                     else if (inherits(cond, "condition")) {
[11:01:35.820]                       if (!is.null(pattern)) {
[11:01:35.820]                         computeRestarts <- base::computeRestarts
[11:01:35.820]                         grepl <- base::grepl
[11:01:35.820]                         restarts <- computeRestarts(cond)
[11:01:35.820]                         for (restart in restarts) {
[11:01:35.820]                           name <- restart$name
[11:01:35.820]                           if (is.null(name)) 
[11:01:35.820]                             next
[11:01:35.820]                           if (!grepl(pattern, name)) 
[11:01:35.820]                             next
[11:01:35.820]                           invokeRestart(restart)
[11:01:35.820]                           muffled <- TRUE
[11:01:35.820]                           break
[11:01:35.820]                         }
[11:01:35.820]                       }
[11:01:35.820]                     }
[11:01:35.820]                     invisible(muffled)
[11:01:35.820]                   }
[11:01:35.820]                   muffleCondition(cond)
[11:01:35.820]                 })
[11:01:35.820]             }))
[11:01:35.820]             future::FutureResult(value = ...future.value$value, 
[11:01:35.820]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.820]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.820]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.820]                     ...future.globalenv.names))
[11:01:35.820]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.820]         }, condition = base::local({
[11:01:35.820]             c <- base::c
[11:01:35.820]             inherits <- base::inherits
[11:01:35.820]             invokeRestart <- base::invokeRestart
[11:01:35.820]             length <- base::length
[11:01:35.820]             list <- base::list
[11:01:35.820]             seq.int <- base::seq.int
[11:01:35.820]             signalCondition <- base::signalCondition
[11:01:35.820]             sys.calls <- base::sys.calls
[11:01:35.820]             `[[` <- base::`[[`
[11:01:35.820]             `+` <- base::`+`
[11:01:35.820]             `<<-` <- base::`<<-`
[11:01:35.820]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.820]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.820]                   3L)]
[11:01:35.820]             }
[11:01:35.820]             function(cond) {
[11:01:35.820]                 is_error <- inherits(cond, "error")
[11:01:35.820]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.820]                   NULL)
[11:01:35.820]                 if (is_error) {
[11:01:35.820]                   sessionInformation <- function() {
[11:01:35.820]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.820]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.820]                       search = base::search(), system = base::Sys.info())
[11:01:35.820]                   }
[11:01:35.820]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.820]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.820]                     cond$call), session = sessionInformation(), 
[11:01:35.820]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.820]                   signalCondition(cond)
[11:01:35.820]                 }
[11:01:35.820]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.820]                 "immediateCondition"))) {
[11:01:35.820]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.820]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.820]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.820]                   if (TRUE && !signal) {
[11:01:35.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.820]                     {
[11:01:35.820]                       inherits <- base::inherits
[11:01:35.820]                       invokeRestart <- base::invokeRestart
[11:01:35.820]                       is.null <- base::is.null
[11:01:35.820]                       muffled <- FALSE
[11:01:35.820]                       if (inherits(cond, "message")) {
[11:01:35.820]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.820]                         if (muffled) 
[11:01:35.820]                           invokeRestart("muffleMessage")
[11:01:35.820]                       }
[11:01:35.820]                       else if (inherits(cond, "warning")) {
[11:01:35.820]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.820]                         if (muffled) 
[11:01:35.820]                           invokeRestart("muffleWarning")
[11:01:35.820]                       }
[11:01:35.820]                       else if (inherits(cond, "condition")) {
[11:01:35.820]                         if (!is.null(pattern)) {
[11:01:35.820]                           computeRestarts <- base::computeRestarts
[11:01:35.820]                           grepl <- base::grepl
[11:01:35.820]                           restarts <- computeRestarts(cond)
[11:01:35.820]                           for (restart in restarts) {
[11:01:35.820]                             name <- restart$name
[11:01:35.820]                             if (is.null(name)) 
[11:01:35.820]                               next
[11:01:35.820]                             if (!grepl(pattern, name)) 
[11:01:35.820]                               next
[11:01:35.820]                             invokeRestart(restart)
[11:01:35.820]                             muffled <- TRUE
[11:01:35.820]                             break
[11:01:35.820]                           }
[11:01:35.820]                         }
[11:01:35.820]                       }
[11:01:35.820]                       invisible(muffled)
[11:01:35.820]                     }
[11:01:35.820]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.820]                   }
[11:01:35.820]                 }
[11:01:35.820]                 else {
[11:01:35.820]                   if (TRUE) {
[11:01:35.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.820]                     {
[11:01:35.820]                       inherits <- base::inherits
[11:01:35.820]                       invokeRestart <- base::invokeRestart
[11:01:35.820]                       is.null <- base::is.null
[11:01:35.820]                       muffled <- FALSE
[11:01:35.820]                       if (inherits(cond, "message")) {
[11:01:35.820]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.820]                         if (muffled) 
[11:01:35.820]                           invokeRestart("muffleMessage")
[11:01:35.820]                       }
[11:01:35.820]                       else if (inherits(cond, "warning")) {
[11:01:35.820]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.820]                         if (muffled) 
[11:01:35.820]                           invokeRestart("muffleWarning")
[11:01:35.820]                       }
[11:01:35.820]                       else if (inherits(cond, "condition")) {
[11:01:35.820]                         if (!is.null(pattern)) {
[11:01:35.820]                           computeRestarts <- base::computeRestarts
[11:01:35.820]                           grepl <- base::grepl
[11:01:35.820]                           restarts <- computeRestarts(cond)
[11:01:35.820]                           for (restart in restarts) {
[11:01:35.820]                             name <- restart$name
[11:01:35.820]                             if (is.null(name)) 
[11:01:35.820]                               next
[11:01:35.820]                             if (!grepl(pattern, name)) 
[11:01:35.820]                               next
[11:01:35.820]                             invokeRestart(restart)
[11:01:35.820]                             muffled <- TRUE
[11:01:35.820]                             break
[11:01:35.820]                           }
[11:01:35.820]                         }
[11:01:35.820]                       }
[11:01:35.820]                       invisible(muffled)
[11:01:35.820]                     }
[11:01:35.820]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.820]                   }
[11:01:35.820]                 }
[11:01:35.820]             }
[11:01:35.820]         }))
[11:01:35.820]     }, error = function(ex) {
[11:01:35.820]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.820]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.820]                 ...future.rng), started = ...future.startTime, 
[11:01:35.820]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.820]             version = "1.8"), class = "FutureResult")
[11:01:35.820]     }, finally = {
[11:01:35.820]         if (!identical(...future.workdir, getwd())) 
[11:01:35.820]             setwd(...future.workdir)
[11:01:35.820]         {
[11:01:35.820]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.820]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.820]             }
[11:01:35.820]             base::options(...future.oldOptions)
[11:01:35.820]             if (.Platform$OS.type == "windows") {
[11:01:35.820]                 old_names <- names(...future.oldEnvVars)
[11:01:35.820]                 envs <- base::Sys.getenv()
[11:01:35.820]                 names <- names(envs)
[11:01:35.820]                 common <- intersect(names, old_names)
[11:01:35.820]                 added <- setdiff(names, old_names)
[11:01:35.820]                 removed <- setdiff(old_names, names)
[11:01:35.820]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.820]                   envs[common]]
[11:01:35.820]                 NAMES <- toupper(changed)
[11:01:35.820]                 args <- list()
[11:01:35.820]                 for (kk in seq_along(NAMES)) {
[11:01:35.820]                   name <- changed[[kk]]
[11:01:35.820]                   NAME <- NAMES[[kk]]
[11:01:35.820]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.820]                     next
[11:01:35.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.820]                 }
[11:01:35.820]                 NAMES <- toupper(added)
[11:01:35.820]                 for (kk in seq_along(NAMES)) {
[11:01:35.820]                   name <- added[[kk]]
[11:01:35.820]                   NAME <- NAMES[[kk]]
[11:01:35.820]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.820]                     next
[11:01:35.820]                   args[[name]] <- ""
[11:01:35.820]                 }
[11:01:35.820]                 NAMES <- toupper(removed)
[11:01:35.820]                 for (kk in seq_along(NAMES)) {
[11:01:35.820]                   name <- removed[[kk]]
[11:01:35.820]                   NAME <- NAMES[[kk]]
[11:01:35.820]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.820]                     next
[11:01:35.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.820]                 }
[11:01:35.820]                 if (length(args) > 0) 
[11:01:35.820]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.820]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.820]             }
[11:01:35.820]             else {
[11:01:35.820]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.820]             }
[11:01:35.820]             {
[11:01:35.820]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.820]                   0L) {
[11:01:35.820]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.820]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.820]                   base::options(opts)
[11:01:35.820]                 }
[11:01:35.820]                 {
[11:01:35.820]                   {
[11:01:35.820]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:35.820]                     NULL
[11:01:35.820]                   }
[11:01:35.820]                   options(future.plan = NULL)
[11:01:35.820]                   if (is.na(NA_character_)) 
[11:01:35.820]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.820]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.820]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.820]                     .init = FALSE)
[11:01:35.820]                 }
[11:01:35.820]             }
[11:01:35.820]         }
[11:01:35.820]     })
[11:01:35.820]     if (TRUE) {
[11:01:35.820]         base::sink(type = "output", split = FALSE)
[11:01:35.820]         if (TRUE) {
[11:01:35.820]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.820]         }
[11:01:35.820]         else {
[11:01:35.820]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.820]         }
[11:01:35.820]         base::close(...future.stdout)
[11:01:35.820]         ...future.stdout <- NULL
[11:01:35.820]     }
[11:01:35.820]     ...future.result$conditions <- ...future.conditions
[11:01:35.820]     ...future.result$finished <- base::Sys.time()
[11:01:35.820]     ...future.result
[11:01:35.820] }
[11:01:35.823] assign_globals() ...
[11:01:35.823] List of 2
[11:01:35.823]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[11:01:35.823]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[11:01:35.823]  - attr(*, "where")=List of 2
[11:01:35.823]   ..$ weight:<environment: R_EmptyEnv> 
[11:01:35.823]   ..$ group :<environment: R_EmptyEnv> 
[11:01:35.823]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:35.823]  - attr(*, "resolved")= logi FALSE
[11:01:35.823]  - attr(*, "total_size")= num 401
[11:01:35.823]  - attr(*, "already-done")= logi TRUE
[11:01:35.829] - copied ‘weight’ to environment
[11:01:35.829] - copied ‘group’ to environment
[11:01:35.829] assign_globals() ... done
[11:01:35.829] requestCore(): workers = 2
[11:01:35.831] MulticoreFuture started
[11:01:35.831] - Launch lazy future ... done
[11:01:35.831] run() for ‘MulticoreFuture’ ... done
[11:01:35.832] result() for MulticoreFuture ...
[11:01:35.832] plan(): Setting new future strategy stack:
[11:01:35.832] List of future strategies:
[11:01:35.832] 1. sequential:
[11:01:35.832]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.832]    - tweaked: FALSE
[11:01:35.832]    - call: NULL
[11:01:35.833] plan(): nbrOfWorkers() = 1
[11:01:35.837] plan(): Setting new future strategy stack:
[11:01:35.837] List of future strategies:
[11:01:35.837] 1. multicore:
[11:01:35.837]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:35.837]    - tweaked: FALSE
[11:01:35.837]    - call: plan(strategy)
[11:01:35.840] plan(): nbrOfWorkers() = 2
[11:01:35.842] result() for MulticoreFuture ...
[11:01:35.842] result() for MulticoreFuture ... done
[11:01:35.842] result() for MulticoreFuture ... done
[11:01:35.842] result() for MulticoreFuture ...
[11:01:35.842] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[11:01:35.845] getGlobalsAndPackages() ...
[11:01:35.845] Searching for globals...
[11:01:35.847] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[11:01:35.847] Searching for globals ... DONE
[11:01:35.848] Resolving globals: FALSE
[11:01:35.848] The total size of the 2 globals is 401 bytes (401 bytes)
[11:01:35.849] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[11:01:35.849] - globals: [2] ‘weight’, ‘group’
[11:01:35.849] - packages: [1] ‘stats’
[11:01:35.849] getGlobalsAndPackages() ... DONE
[11:01:35.849] run() for ‘Future’ ...
[11:01:35.849] - state: ‘created’
[11:01:35.850] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:35.852] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:35.852] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:35.852]   - Field: ‘label’
[11:01:35.852]   - Field: ‘local’
[11:01:35.852]   - Field: ‘owner’
[11:01:35.852]   - Field: ‘envir’
[11:01:35.852]   - Field: ‘workers’
[11:01:35.852]   - Field: ‘packages’
[11:01:35.853]   - Field: ‘gc’
[11:01:35.853]   - Field: ‘job’
[11:01:35.853]   - Field: ‘conditions’
[11:01:35.853]   - Field: ‘expr’
[11:01:35.853]   - Field: ‘uuid’
[11:01:35.853]   - Field: ‘seed’
[11:01:35.853]   - Field: ‘version’
[11:01:35.853]   - Field: ‘result’
[11:01:35.853]   - Field: ‘asynchronous’
[11:01:35.854]   - Field: ‘calls’
[11:01:35.854]   - Field: ‘globals’
[11:01:35.854]   - Field: ‘stdout’
[11:01:35.854]   - Field: ‘earlySignal’
[11:01:35.854]   - Field: ‘lazy’
[11:01:35.854]   - Field: ‘state’
[11:01:35.854] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:35.854] - Launch lazy future ...
[11:01:35.855] Packages needed by the future expression (n = 1): ‘stats’
[11:01:35.855] Packages needed by future strategies (n = 0): <none>
[11:01:35.855] {
[11:01:35.855]     {
[11:01:35.855]         {
[11:01:35.855]             ...future.startTime <- base::Sys.time()
[11:01:35.855]             {
[11:01:35.855]                 {
[11:01:35.855]                   {
[11:01:35.855]                     {
[11:01:35.855]                       {
[11:01:35.855]                         base::local({
[11:01:35.855]                           has_future <- base::requireNamespace("future", 
[11:01:35.855]                             quietly = TRUE)
[11:01:35.855]                           if (has_future) {
[11:01:35.855]                             ns <- base::getNamespace("future")
[11:01:35.855]                             version <- ns[[".package"]][["version"]]
[11:01:35.855]                             if (is.null(version)) 
[11:01:35.855]                               version <- utils::packageVersion("future")
[11:01:35.855]                           }
[11:01:35.855]                           else {
[11:01:35.855]                             version <- NULL
[11:01:35.855]                           }
[11:01:35.855]                           if (!has_future || version < "1.8.0") {
[11:01:35.855]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.855]                               "", base::R.version$version.string), 
[11:01:35.855]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:35.855]                                 base::R.version$platform, 8 * 
[11:01:35.855]                                   base::.Machine$sizeof.pointer), 
[11:01:35.855]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.855]                                 "release", "version")], collapse = " "), 
[11:01:35.855]                               hostname = base::Sys.info()[["nodename"]])
[11:01:35.855]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.855]                               info)
[11:01:35.855]                             info <- base::paste(info, collapse = "; ")
[11:01:35.855]                             if (!has_future) {
[11:01:35.855]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.855]                                 info)
[11:01:35.855]                             }
[11:01:35.855]                             else {
[11:01:35.855]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.855]                                 info, version)
[11:01:35.855]                             }
[11:01:35.855]                             base::stop(msg)
[11:01:35.855]                           }
[11:01:35.855]                         })
[11:01:35.855]                       }
[11:01:35.855]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:35.855]                       base::options(mc.cores = 1L)
[11:01:35.855]                     }
[11:01:35.855]                     base::local({
[11:01:35.855]                       for (pkg in "stats") {
[11:01:35.855]                         base::loadNamespace(pkg)
[11:01:35.855]                         base::library(pkg, character.only = TRUE)
[11:01:35.855]                       }
[11:01:35.855]                     })
[11:01:35.855]                   }
[11:01:35.855]                   ...future.strategy.old <- future::plan("list")
[11:01:35.855]                   options(future.plan = NULL)
[11:01:35.855]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.855]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.855]                 }
[11:01:35.855]                 ...future.workdir <- getwd()
[11:01:35.855]             }
[11:01:35.855]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.855]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.855]         }
[11:01:35.855]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.855]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.855]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.855]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.855]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.855]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.855]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.855]             base::names(...future.oldOptions))
[11:01:35.855]     }
[11:01:35.855]     if (FALSE) {
[11:01:35.855]     }
[11:01:35.855]     else {
[11:01:35.855]         if (TRUE) {
[11:01:35.855]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.855]                 open = "w")
[11:01:35.855]         }
[11:01:35.855]         else {
[11:01:35.855]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.855]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.855]         }
[11:01:35.855]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.855]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.855]             base::sink(type = "output", split = FALSE)
[11:01:35.855]             base::close(...future.stdout)
[11:01:35.855]         }, add = TRUE)
[11:01:35.855]     }
[11:01:35.855]     ...future.frame <- base::sys.nframe()
[11:01:35.855]     ...future.conditions <- base::list()
[11:01:35.855]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.855]     if (FALSE) {
[11:01:35.855]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.855]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.855]     }
[11:01:35.855]     ...future.result <- base::tryCatch({
[11:01:35.855]         base::withCallingHandlers({
[11:01:35.855]             ...future.value <- base::withVisible(base::local({
[11:01:35.855]                 withCallingHandlers({
[11:01:35.855]                   {
[11:01:35.855]                     lm(weight ~ group - 1)
[11:01:35.855]                   }
[11:01:35.855]                 }, immediateCondition = function(cond) {
[11:01:35.855]                   save_rds <- function (object, pathname, ...) 
[11:01:35.855]                   {
[11:01:35.855]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:35.855]                     if (file_test("-f", pathname_tmp)) {
[11:01:35.855]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.855]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:35.855]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.855]                         fi_tmp[["mtime"]])
[11:01:35.855]                     }
[11:01:35.855]                     tryCatch({
[11:01:35.855]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:35.855]                     }, error = function(ex) {
[11:01:35.855]                       msg <- conditionMessage(ex)
[11:01:35.855]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.855]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:35.855]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.855]                         fi_tmp[["mtime"]], msg)
[11:01:35.855]                       ex$message <- msg
[11:01:35.855]                       stop(ex)
[11:01:35.855]                     })
[11:01:35.855]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:35.855]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:35.855]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:35.855]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.855]                       fi <- file.info(pathname)
[11:01:35.855]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:35.855]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.855]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:35.855]                         fi[["size"]], fi[["mtime"]])
[11:01:35.855]                       stop(msg)
[11:01:35.855]                     }
[11:01:35.855]                     invisible(pathname)
[11:01:35.855]                   }
[11:01:35.855]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:35.855]                     rootPath = tempdir()) 
[11:01:35.855]                   {
[11:01:35.855]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:35.855]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:35.855]                       tmpdir = path, fileext = ".rds")
[11:01:35.855]                     save_rds(obj, file)
[11:01:35.855]                   }
[11:01:35.855]                   saveImmediateCondition(cond, path = "/tmp/Rtmpu6OqnW/.future/immediateConditions")
[11:01:35.855]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.855]                   {
[11:01:35.855]                     inherits <- base::inherits
[11:01:35.855]                     invokeRestart <- base::invokeRestart
[11:01:35.855]                     is.null <- base::is.null
[11:01:35.855]                     muffled <- FALSE
[11:01:35.855]                     if (inherits(cond, "message")) {
[11:01:35.855]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:35.855]                       if (muffled) 
[11:01:35.855]                         invokeRestart("muffleMessage")
[11:01:35.855]                     }
[11:01:35.855]                     else if (inherits(cond, "warning")) {
[11:01:35.855]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:35.855]                       if (muffled) 
[11:01:35.855]                         invokeRestart("muffleWarning")
[11:01:35.855]                     }
[11:01:35.855]                     else if (inherits(cond, "condition")) {
[11:01:35.855]                       if (!is.null(pattern)) {
[11:01:35.855]                         computeRestarts <- base::computeRestarts
[11:01:35.855]                         grepl <- base::grepl
[11:01:35.855]                         restarts <- computeRestarts(cond)
[11:01:35.855]                         for (restart in restarts) {
[11:01:35.855]                           name <- restart$name
[11:01:35.855]                           if (is.null(name)) 
[11:01:35.855]                             next
[11:01:35.855]                           if (!grepl(pattern, name)) 
[11:01:35.855]                             next
[11:01:35.855]                           invokeRestart(restart)
[11:01:35.855]                           muffled <- TRUE
[11:01:35.855]                           break
[11:01:35.855]                         }
[11:01:35.855]                       }
[11:01:35.855]                     }
[11:01:35.855]                     invisible(muffled)
[11:01:35.855]                   }
[11:01:35.855]                   muffleCondition(cond)
[11:01:35.855]                 })
[11:01:35.855]             }))
[11:01:35.855]             future::FutureResult(value = ...future.value$value, 
[11:01:35.855]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.855]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.855]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.855]                     ...future.globalenv.names))
[11:01:35.855]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.855]         }, condition = base::local({
[11:01:35.855]             c <- base::c
[11:01:35.855]             inherits <- base::inherits
[11:01:35.855]             invokeRestart <- base::invokeRestart
[11:01:35.855]             length <- base::length
[11:01:35.855]             list <- base::list
[11:01:35.855]             seq.int <- base::seq.int
[11:01:35.855]             signalCondition <- base::signalCondition
[11:01:35.855]             sys.calls <- base::sys.calls
[11:01:35.855]             `[[` <- base::`[[`
[11:01:35.855]             `+` <- base::`+`
[11:01:35.855]             `<<-` <- base::`<<-`
[11:01:35.855]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.855]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.855]                   3L)]
[11:01:35.855]             }
[11:01:35.855]             function(cond) {
[11:01:35.855]                 is_error <- inherits(cond, "error")
[11:01:35.855]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.855]                   NULL)
[11:01:35.855]                 if (is_error) {
[11:01:35.855]                   sessionInformation <- function() {
[11:01:35.855]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.855]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.855]                       search = base::search(), system = base::Sys.info())
[11:01:35.855]                   }
[11:01:35.855]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.855]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.855]                     cond$call), session = sessionInformation(), 
[11:01:35.855]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.855]                   signalCondition(cond)
[11:01:35.855]                 }
[11:01:35.855]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.855]                 "immediateCondition"))) {
[11:01:35.855]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.855]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.855]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.855]                   if (TRUE && !signal) {
[11:01:35.855]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.855]                     {
[11:01:35.855]                       inherits <- base::inherits
[11:01:35.855]                       invokeRestart <- base::invokeRestart
[11:01:35.855]                       is.null <- base::is.null
[11:01:35.855]                       muffled <- FALSE
[11:01:35.855]                       if (inherits(cond, "message")) {
[11:01:35.855]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.855]                         if (muffled) 
[11:01:35.855]                           invokeRestart("muffleMessage")
[11:01:35.855]                       }
[11:01:35.855]                       else if (inherits(cond, "warning")) {
[11:01:35.855]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.855]                         if (muffled) 
[11:01:35.855]                           invokeRestart("muffleWarning")
[11:01:35.855]                       }
[11:01:35.855]                       else if (inherits(cond, "condition")) {
[11:01:35.855]                         if (!is.null(pattern)) {
[11:01:35.855]                           computeRestarts <- base::computeRestarts
[11:01:35.855]                           grepl <- base::grepl
[11:01:35.855]                           restarts <- computeRestarts(cond)
[11:01:35.855]                           for (restart in restarts) {
[11:01:35.855]                             name <- restart$name
[11:01:35.855]                             if (is.null(name)) 
[11:01:35.855]                               next
[11:01:35.855]                             if (!grepl(pattern, name)) 
[11:01:35.855]                               next
[11:01:35.855]                             invokeRestart(restart)
[11:01:35.855]                             muffled <- TRUE
[11:01:35.855]                             break
[11:01:35.855]                           }
[11:01:35.855]                         }
[11:01:35.855]                       }
[11:01:35.855]                       invisible(muffled)
[11:01:35.855]                     }
[11:01:35.855]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.855]                   }
[11:01:35.855]                 }
[11:01:35.855]                 else {
[11:01:35.855]                   if (TRUE) {
[11:01:35.855]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.855]                     {
[11:01:35.855]                       inherits <- base::inherits
[11:01:35.855]                       invokeRestart <- base::invokeRestart
[11:01:35.855]                       is.null <- base::is.null
[11:01:35.855]                       muffled <- FALSE
[11:01:35.855]                       if (inherits(cond, "message")) {
[11:01:35.855]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.855]                         if (muffled) 
[11:01:35.855]                           invokeRestart("muffleMessage")
[11:01:35.855]                       }
[11:01:35.855]                       else if (inherits(cond, "warning")) {
[11:01:35.855]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.855]                         if (muffled) 
[11:01:35.855]                           invokeRestart("muffleWarning")
[11:01:35.855]                       }
[11:01:35.855]                       else if (inherits(cond, "condition")) {
[11:01:35.855]                         if (!is.null(pattern)) {
[11:01:35.855]                           computeRestarts <- base::computeRestarts
[11:01:35.855]                           grepl <- base::grepl
[11:01:35.855]                           restarts <- computeRestarts(cond)
[11:01:35.855]                           for (restart in restarts) {
[11:01:35.855]                             name <- restart$name
[11:01:35.855]                             if (is.null(name)) 
[11:01:35.855]                               next
[11:01:35.855]                             if (!grepl(pattern, name)) 
[11:01:35.855]                               next
[11:01:35.855]                             invokeRestart(restart)
[11:01:35.855]                             muffled <- TRUE
[11:01:35.855]                             break
[11:01:35.855]                           }
[11:01:35.855]                         }
[11:01:35.855]                       }
[11:01:35.855]                       invisible(muffled)
[11:01:35.855]                     }
[11:01:35.855]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.855]                   }
[11:01:35.855]                 }
[11:01:35.855]             }
[11:01:35.855]         }))
[11:01:35.855]     }, error = function(ex) {
[11:01:35.855]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.855]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.855]                 ...future.rng), started = ...future.startTime, 
[11:01:35.855]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.855]             version = "1.8"), class = "FutureResult")
[11:01:35.855]     }, finally = {
[11:01:35.855]         if (!identical(...future.workdir, getwd())) 
[11:01:35.855]             setwd(...future.workdir)
[11:01:35.855]         {
[11:01:35.855]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.855]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.855]             }
[11:01:35.855]             base::options(...future.oldOptions)
[11:01:35.855]             if (.Platform$OS.type == "windows") {
[11:01:35.855]                 old_names <- names(...future.oldEnvVars)
[11:01:35.855]                 envs <- base::Sys.getenv()
[11:01:35.855]                 names <- names(envs)
[11:01:35.855]                 common <- intersect(names, old_names)
[11:01:35.855]                 added <- setdiff(names, old_names)
[11:01:35.855]                 removed <- setdiff(old_names, names)
[11:01:35.855]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.855]                   envs[common]]
[11:01:35.855]                 NAMES <- toupper(changed)
[11:01:35.855]                 args <- list()
[11:01:35.855]                 for (kk in seq_along(NAMES)) {
[11:01:35.855]                   name <- changed[[kk]]
[11:01:35.855]                   NAME <- NAMES[[kk]]
[11:01:35.855]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.855]                     next
[11:01:35.855]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.855]                 }
[11:01:35.855]                 NAMES <- toupper(added)
[11:01:35.855]                 for (kk in seq_along(NAMES)) {
[11:01:35.855]                   name <- added[[kk]]
[11:01:35.855]                   NAME <- NAMES[[kk]]
[11:01:35.855]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.855]                     next
[11:01:35.855]                   args[[name]] <- ""
[11:01:35.855]                 }
[11:01:35.855]                 NAMES <- toupper(removed)
[11:01:35.855]                 for (kk in seq_along(NAMES)) {
[11:01:35.855]                   name <- removed[[kk]]
[11:01:35.855]                   NAME <- NAMES[[kk]]
[11:01:35.855]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.855]                     next
[11:01:35.855]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.855]                 }
[11:01:35.855]                 if (length(args) > 0) 
[11:01:35.855]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.855]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.855]             }
[11:01:35.855]             else {
[11:01:35.855]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.855]             }
[11:01:35.855]             {
[11:01:35.855]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.855]                   0L) {
[11:01:35.855]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.855]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.855]                   base::options(opts)
[11:01:35.855]                 }
[11:01:35.855]                 {
[11:01:35.855]                   {
[11:01:35.855]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:35.855]                     NULL
[11:01:35.855]                   }
[11:01:35.855]                   options(future.plan = NULL)
[11:01:35.855]                   if (is.na(NA_character_)) 
[11:01:35.855]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.855]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.855]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.855]                     .init = FALSE)
[11:01:35.855]                 }
[11:01:35.855]             }
[11:01:35.855]         }
[11:01:35.855]     })
[11:01:35.855]     if (TRUE) {
[11:01:35.855]         base::sink(type = "output", split = FALSE)
[11:01:35.855]         if (TRUE) {
[11:01:35.855]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.855]         }
[11:01:35.855]         else {
[11:01:35.855]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.855]         }
[11:01:35.855]         base::close(...future.stdout)
[11:01:35.855]         ...future.stdout <- NULL
[11:01:35.855]     }
[11:01:35.855]     ...future.result$conditions <- ...future.conditions
[11:01:35.855]     ...future.result$finished <- base::Sys.time()
[11:01:35.855]     ...future.result
[11:01:35.855] }
[11:01:35.858] assign_globals() ...
[11:01:35.858] List of 2
[11:01:35.858]  $ weight: num [1:20] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...
[11:01:35.858]  $ group : Factor w/ 2 levels "Ctl","Trt": 1 1 1 1 1 1 1 1 1 1 ...
[11:01:35.858]  - attr(*, "where")=List of 2
[11:01:35.858]   ..$ weight:<environment: R_EmptyEnv> 
[11:01:35.858]   ..$ group :<environment: R_EmptyEnv> 
[11:01:35.858]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:35.858]  - attr(*, "resolved")= logi FALSE
[11:01:35.858]  - attr(*, "total_size")= num 401
[11:01:35.858]  - attr(*, "already-done")= logi TRUE
[11:01:35.862] - copied ‘weight’ to environment
[11:01:35.862] - copied ‘group’ to environment
[11:01:35.862] assign_globals() ... done
[11:01:35.862] requestCore(): workers = 2
[11:01:35.864] MulticoreFuture started
[11:01:35.864] - Launch lazy future ... done
[11:01:35.864] run() for ‘MulticoreFuture’ ... done
[11:01:35.864] result() for MulticoreFuture ...
[11:01:35.865] plan(): Setting new future strategy stack:
[11:01:35.865] List of future strategies:
[11:01:35.865] 1. sequential:
[11:01:35.865]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.865]    - tweaked: FALSE
[11:01:35.865]    - call: NULL
[11:01:35.866] plan(): nbrOfWorkers() = 1
[11:01:35.873] plan(): Setting new future strategy stack:
[11:01:35.873] List of future strategies:
[11:01:35.873] 1. multicore:
[11:01:35.873]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:35.873]    - tweaked: FALSE
[11:01:35.873]    - call: plan(strategy)
[11:01:35.876] plan(): nbrOfWorkers() = 2
[11:01:35.879] result() for MulticoreFuture ...
[11:01:35.879] result() for MulticoreFuture ... done
[11:01:35.879] result() for MulticoreFuture ... done
[11:01:35.881] result() for MulticoreFuture ...
[11:01:35.881] result() for MulticoreFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[11:01:35.884] getGlobalsAndPackages() ...
[11:01:35.884] Searching for globals...
[11:01:35.885] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[11:01:35.886] Searching for globals ... DONE
[11:01:35.886] Resolving globals: FALSE
[11:01:35.886] The total size of the 1 globals is 71 bytes (71 bytes)
[11:01:35.887] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 71 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (71 bytes of class ‘numeric’)
[11:01:35.887] - globals: [1] ‘x’
[11:01:35.887] - packages: [1] ‘stats’
[11:01:35.887] getGlobalsAndPackages() ... DONE
[11:01:35.887] run() for ‘Future’ ...
[11:01:35.888] - state: ‘created’
[11:01:35.888] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:35.890] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:35.890] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:35.890]   - Field: ‘label’
[11:01:35.890]   - Field: ‘local’
[11:01:35.890]   - Field: ‘owner’
[11:01:35.890]   - Field: ‘envir’
[11:01:35.890]   - Field: ‘workers’
[11:01:35.891]   - Field: ‘packages’
[11:01:35.891]   - Field: ‘gc’
[11:01:35.891]   - Field: ‘job’
[11:01:35.891]   - Field: ‘conditions’
[11:01:35.891]   - Field: ‘expr’
[11:01:35.891]   - Field: ‘uuid’
[11:01:35.891]   - Field: ‘seed’
[11:01:35.891]   - Field: ‘version’
[11:01:35.891]   - Field: ‘result’
[11:01:35.891]   - Field: ‘asynchronous’
[11:01:35.892]   - Field: ‘calls’
[11:01:35.892]   - Field: ‘globals’
[11:01:35.892]   - Field: ‘stdout’
[11:01:35.892]   - Field: ‘earlySignal’
[11:01:35.892]   - Field: ‘lazy’
[11:01:35.892]   - Field: ‘state’
[11:01:35.892] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:35.892] - Launch lazy future ...
[11:01:35.893] Packages needed by the future expression (n = 1): ‘stats’
[11:01:35.893] Packages needed by future strategies (n = 0): <none>
[11:01:35.893] {
[11:01:35.893]     {
[11:01:35.893]         {
[11:01:35.893]             ...future.startTime <- base::Sys.time()
[11:01:35.893]             {
[11:01:35.893]                 {
[11:01:35.893]                   {
[11:01:35.893]                     {
[11:01:35.893]                       {
[11:01:35.893]                         base::local({
[11:01:35.893]                           has_future <- base::requireNamespace("future", 
[11:01:35.893]                             quietly = TRUE)
[11:01:35.893]                           if (has_future) {
[11:01:35.893]                             ns <- base::getNamespace("future")
[11:01:35.893]                             version <- ns[[".package"]][["version"]]
[11:01:35.893]                             if (is.null(version)) 
[11:01:35.893]                               version <- utils::packageVersion("future")
[11:01:35.893]                           }
[11:01:35.893]                           else {
[11:01:35.893]                             version <- NULL
[11:01:35.893]                           }
[11:01:35.893]                           if (!has_future || version < "1.8.0") {
[11:01:35.893]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.893]                               "", base::R.version$version.string), 
[11:01:35.893]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:35.893]                                 base::R.version$platform, 8 * 
[11:01:35.893]                                   base::.Machine$sizeof.pointer), 
[11:01:35.893]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.893]                                 "release", "version")], collapse = " "), 
[11:01:35.893]                               hostname = base::Sys.info()[["nodename"]])
[11:01:35.893]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.893]                               info)
[11:01:35.893]                             info <- base::paste(info, collapse = "; ")
[11:01:35.893]                             if (!has_future) {
[11:01:35.893]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.893]                                 info)
[11:01:35.893]                             }
[11:01:35.893]                             else {
[11:01:35.893]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.893]                                 info, version)
[11:01:35.893]                             }
[11:01:35.893]                             base::stop(msg)
[11:01:35.893]                           }
[11:01:35.893]                         })
[11:01:35.893]                       }
[11:01:35.893]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:35.893]                       base::options(mc.cores = 1L)
[11:01:35.893]                     }
[11:01:35.893]                     base::local({
[11:01:35.893]                       for (pkg in "stats") {
[11:01:35.893]                         base::loadNamespace(pkg)
[11:01:35.893]                         base::library(pkg, character.only = TRUE)
[11:01:35.893]                       }
[11:01:35.893]                     })
[11:01:35.893]                   }
[11:01:35.893]                   ...future.strategy.old <- future::plan("list")
[11:01:35.893]                   options(future.plan = NULL)
[11:01:35.893]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.893]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.893]                 }
[11:01:35.893]                 ...future.workdir <- getwd()
[11:01:35.893]             }
[11:01:35.893]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.893]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.893]         }
[11:01:35.893]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.893]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.893]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.893]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.893]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.893]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.893]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.893]             base::names(...future.oldOptions))
[11:01:35.893]     }
[11:01:35.893]     if (FALSE) {
[11:01:35.893]     }
[11:01:35.893]     else {
[11:01:35.893]         if (TRUE) {
[11:01:35.893]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.893]                 open = "w")
[11:01:35.893]         }
[11:01:35.893]         else {
[11:01:35.893]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.893]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.893]         }
[11:01:35.893]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.893]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.893]             base::sink(type = "output", split = FALSE)
[11:01:35.893]             base::close(...future.stdout)
[11:01:35.893]         }, add = TRUE)
[11:01:35.893]     }
[11:01:35.893]     ...future.frame <- base::sys.nframe()
[11:01:35.893]     ...future.conditions <- base::list()
[11:01:35.893]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.893]     if (FALSE) {
[11:01:35.893]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.893]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.893]     }
[11:01:35.893]     ...future.result <- base::tryCatch({
[11:01:35.893]         base::withCallingHandlers({
[11:01:35.893]             ...future.value <- base::withVisible(base::local({
[11:01:35.893]                 withCallingHandlers({
[11:01:35.893]                   {
[11:01:35.893]                     xtabs(~x)
[11:01:35.893]                   }
[11:01:35.893]                 }, immediateCondition = function(cond) {
[11:01:35.893]                   save_rds <- function (object, pathname, ...) 
[11:01:35.893]                   {
[11:01:35.893]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:35.893]                     if (file_test("-f", pathname_tmp)) {
[11:01:35.893]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.893]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:35.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.893]                         fi_tmp[["mtime"]])
[11:01:35.893]                     }
[11:01:35.893]                     tryCatch({
[11:01:35.893]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:35.893]                     }, error = function(ex) {
[11:01:35.893]                       msg <- conditionMessage(ex)
[11:01:35.893]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.893]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:35.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.893]                         fi_tmp[["mtime"]], msg)
[11:01:35.893]                       ex$message <- msg
[11:01:35.893]                       stop(ex)
[11:01:35.893]                     })
[11:01:35.893]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:35.893]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:35.893]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:35.893]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.893]                       fi <- file.info(pathname)
[11:01:35.893]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:35.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.893]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:35.893]                         fi[["size"]], fi[["mtime"]])
[11:01:35.893]                       stop(msg)
[11:01:35.893]                     }
[11:01:35.893]                     invisible(pathname)
[11:01:35.893]                   }
[11:01:35.893]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:35.893]                     rootPath = tempdir()) 
[11:01:35.893]                   {
[11:01:35.893]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:35.893]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:35.893]                       tmpdir = path, fileext = ".rds")
[11:01:35.893]                     save_rds(obj, file)
[11:01:35.893]                   }
[11:01:35.893]                   saveImmediateCondition(cond, path = "/tmp/Rtmpu6OqnW/.future/immediateConditions")
[11:01:35.893]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.893]                   {
[11:01:35.893]                     inherits <- base::inherits
[11:01:35.893]                     invokeRestart <- base::invokeRestart
[11:01:35.893]                     is.null <- base::is.null
[11:01:35.893]                     muffled <- FALSE
[11:01:35.893]                     if (inherits(cond, "message")) {
[11:01:35.893]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:35.893]                       if (muffled) 
[11:01:35.893]                         invokeRestart("muffleMessage")
[11:01:35.893]                     }
[11:01:35.893]                     else if (inherits(cond, "warning")) {
[11:01:35.893]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:35.893]                       if (muffled) 
[11:01:35.893]                         invokeRestart("muffleWarning")
[11:01:35.893]                     }
[11:01:35.893]                     else if (inherits(cond, "condition")) {
[11:01:35.893]                       if (!is.null(pattern)) {
[11:01:35.893]                         computeRestarts <- base::computeRestarts
[11:01:35.893]                         grepl <- base::grepl
[11:01:35.893]                         restarts <- computeRestarts(cond)
[11:01:35.893]                         for (restart in restarts) {
[11:01:35.893]                           name <- restart$name
[11:01:35.893]                           if (is.null(name)) 
[11:01:35.893]                             next
[11:01:35.893]                           if (!grepl(pattern, name)) 
[11:01:35.893]                             next
[11:01:35.893]                           invokeRestart(restart)
[11:01:35.893]                           muffled <- TRUE
[11:01:35.893]                           break
[11:01:35.893]                         }
[11:01:35.893]                       }
[11:01:35.893]                     }
[11:01:35.893]                     invisible(muffled)
[11:01:35.893]                   }
[11:01:35.893]                   muffleCondition(cond)
[11:01:35.893]                 })
[11:01:35.893]             }))
[11:01:35.893]             future::FutureResult(value = ...future.value$value, 
[11:01:35.893]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.893]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.893]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.893]                     ...future.globalenv.names))
[11:01:35.893]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.893]         }, condition = base::local({
[11:01:35.893]             c <- base::c
[11:01:35.893]             inherits <- base::inherits
[11:01:35.893]             invokeRestart <- base::invokeRestart
[11:01:35.893]             length <- base::length
[11:01:35.893]             list <- base::list
[11:01:35.893]             seq.int <- base::seq.int
[11:01:35.893]             signalCondition <- base::signalCondition
[11:01:35.893]             sys.calls <- base::sys.calls
[11:01:35.893]             `[[` <- base::`[[`
[11:01:35.893]             `+` <- base::`+`
[11:01:35.893]             `<<-` <- base::`<<-`
[11:01:35.893]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.893]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.893]                   3L)]
[11:01:35.893]             }
[11:01:35.893]             function(cond) {
[11:01:35.893]                 is_error <- inherits(cond, "error")
[11:01:35.893]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.893]                   NULL)
[11:01:35.893]                 if (is_error) {
[11:01:35.893]                   sessionInformation <- function() {
[11:01:35.893]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.893]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.893]                       search = base::search(), system = base::Sys.info())
[11:01:35.893]                   }
[11:01:35.893]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.893]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.893]                     cond$call), session = sessionInformation(), 
[11:01:35.893]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.893]                   signalCondition(cond)
[11:01:35.893]                 }
[11:01:35.893]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.893]                 "immediateCondition"))) {
[11:01:35.893]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.893]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.893]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.893]                   if (TRUE && !signal) {
[11:01:35.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.893]                     {
[11:01:35.893]                       inherits <- base::inherits
[11:01:35.893]                       invokeRestart <- base::invokeRestart
[11:01:35.893]                       is.null <- base::is.null
[11:01:35.893]                       muffled <- FALSE
[11:01:35.893]                       if (inherits(cond, "message")) {
[11:01:35.893]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.893]                         if (muffled) 
[11:01:35.893]                           invokeRestart("muffleMessage")
[11:01:35.893]                       }
[11:01:35.893]                       else if (inherits(cond, "warning")) {
[11:01:35.893]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.893]                         if (muffled) 
[11:01:35.893]                           invokeRestart("muffleWarning")
[11:01:35.893]                       }
[11:01:35.893]                       else if (inherits(cond, "condition")) {
[11:01:35.893]                         if (!is.null(pattern)) {
[11:01:35.893]                           computeRestarts <- base::computeRestarts
[11:01:35.893]                           grepl <- base::grepl
[11:01:35.893]                           restarts <- computeRestarts(cond)
[11:01:35.893]                           for (restart in restarts) {
[11:01:35.893]                             name <- restart$name
[11:01:35.893]                             if (is.null(name)) 
[11:01:35.893]                               next
[11:01:35.893]                             if (!grepl(pattern, name)) 
[11:01:35.893]                               next
[11:01:35.893]                             invokeRestart(restart)
[11:01:35.893]                             muffled <- TRUE
[11:01:35.893]                             break
[11:01:35.893]                           }
[11:01:35.893]                         }
[11:01:35.893]                       }
[11:01:35.893]                       invisible(muffled)
[11:01:35.893]                     }
[11:01:35.893]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.893]                   }
[11:01:35.893]                 }
[11:01:35.893]                 else {
[11:01:35.893]                   if (TRUE) {
[11:01:35.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.893]                     {
[11:01:35.893]                       inherits <- base::inherits
[11:01:35.893]                       invokeRestart <- base::invokeRestart
[11:01:35.893]                       is.null <- base::is.null
[11:01:35.893]                       muffled <- FALSE
[11:01:35.893]                       if (inherits(cond, "message")) {
[11:01:35.893]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.893]                         if (muffled) 
[11:01:35.893]                           invokeRestart("muffleMessage")
[11:01:35.893]                       }
[11:01:35.893]                       else if (inherits(cond, "warning")) {
[11:01:35.893]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.893]                         if (muffled) 
[11:01:35.893]                           invokeRestart("muffleWarning")
[11:01:35.893]                       }
[11:01:35.893]                       else if (inherits(cond, "condition")) {
[11:01:35.893]                         if (!is.null(pattern)) {
[11:01:35.893]                           computeRestarts <- base::computeRestarts
[11:01:35.893]                           grepl <- base::grepl
[11:01:35.893]                           restarts <- computeRestarts(cond)
[11:01:35.893]                           for (restart in restarts) {
[11:01:35.893]                             name <- restart$name
[11:01:35.893]                             if (is.null(name)) 
[11:01:35.893]                               next
[11:01:35.893]                             if (!grepl(pattern, name)) 
[11:01:35.893]                               next
[11:01:35.893]                             invokeRestart(restart)
[11:01:35.893]                             muffled <- TRUE
[11:01:35.893]                             break
[11:01:35.893]                           }
[11:01:35.893]                         }
[11:01:35.893]                       }
[11:01:35.893]                       invisible(muffled)
[11:01:35.893]                     }
[11:01:35.893]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.893]                   }
[11:01:35.893]                 }
[11:01:35.893]             }
[11:01:35.893]         }))
[11:01:35.893]     }, error = function(ex) {
[11:01:35.893]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.893]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.893]                 ...future.rng), started = ...future.startTime, 
[11:01:35.893]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.893]             version = "1.8"), class = "FutureResult")
[11:01:35.893]     }, finally = {
[11:01:35.893]         if (!identical(...future.workdir, getwd())) 
[11:01:35.893]             setwd(...future.workdir)
[11:01:35.893]         {
[11:01:35.893]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.893]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.893]             }
[11:01:35.893]             base::options(...future.oldOptions)
[11:01:35.893]             if (.Platform$OS.type == "windows") {
[11:01:35.893]                 old_names <- names(...future.oldEnvVars)
[11:01:35.893]                 envs <- base::Sys.getenv()
[11:01:35.893]                 names <- names(envs)
[11:01:35.893]                 common <- intersect(names, old_names)
[11:01:35.893]                 added <- setdiff(names, old_names)
[11:01:35.893]                 removed <- setdiff(old_names, names)
[11:01:35.893]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.893]                   envs[common]]
[11:01:35.893]                 NAMES <- toupper(changed)
[11:01:35.893]                 args <- list()
[11:01:35.893]                 for (kk in seq_along(NAMES)) {
[11:01:35.893]                   name <- changed[[kk]]
[11:01:35.893]                   NAME <- NAMES[[kk]]
[11:01:35.893]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.893]                     next
[11:01:35.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.893]                 }
[11:01:35.893]                 NAMES <- toupper(added)
[11:01:35.893]                 for (kk in seq_along(NAMES)) {
[11:01:35.893]                   name <- added[[kk]]
[11:01:35.893]                   NAME <- NAMES[[kk]]
[11:01:35.893]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.893]                     next
[11:01:35.893]                   args[[name]] <- ""
[11:01:35.893]                 }
[11:01:35.893]                 NAMES <- toupper(removed)
[11:01:35.893]                 for (kk in seq_along(NAMES)) {
[11:01:35.893]                   name <- removed[[kk]]
[11:01:35.893]                   NAME <- NAMES[[kk]]
[11:01:35.893]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.893]                     next
[11:01:35.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.893]                 }
[11:01:35.893]                 if (length(args) > 0) 
[11:01:35.893]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.893]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.893]             }
[11:01:35.893]             else {
[11:01:35.893]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.893]             }
[11:01:35.893]             {
[11:01:35.893]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.893]                   0L) {
[11:01:35.893]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.893]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.893]                   base::options(opts)
[11:01:35.893]                 }
[11:01:35.893]                 {
[11:01:35.893]                   {
[11:01:35.893]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:35.893]                     NULL
[11:01:35.893]                   }
[11:01:35.893]                   options(future.plan = NULL)
[11:01:35.893]                   if (is.na(NA_character_)) 
[11:01:35.893]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.893]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.893]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.893]                     .init = FALSE)
[11:01:35.893]                 }
[11:01:35.893]             }
[11:01:35.893]         }
[11:01:35.893]     })
[11:01:35.893]     if (TRUE) {
[11:01:35.893]         base::sink(type = "output", split = FALSE)
[11:01:35.893]         if (TRUE) {
[11:01:35.893]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.893]         }
[11:01:35.893]         else {
[11:01:35.893]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.893]         }
[11:01:35.893]         base::close(...future.stdout)
[11:01:35.893]         ...future.stdout <- NULL
[11:01:35.893]     }
[11:01:35.893]     ...future.result$conditions <- ...future.conditions
[11:01:35.893]     ...future.result$finished <- base::Sys.time()
[11:01:35.893]     ...future.result
[11:01:35.893] }
[11:01:35.896] assign_globals() ...
[11:01:35.896] List of 1
[11:01:35.896]  $ x: num [1:5] 1 1 2 2 2
[11:01:35.896]  - attr(*, "where")=List of 1
[11:01:35.896]   ..$ x:<environment: R_EmptyEnv> 
[11:01:35.896]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:35.896]  - attr(*, "resolved")= logi FALSE
[11:01:35.896]  - attr(*, "total_size")= num 71
[11:01:35.896]  - attr(*, "already-done")= logi TRUE
[11:01:35.899] - copied ‘x’ to environment
[11:01:35.899] assign_globals() ... done
[11:01:35.899] requestCore(): workers = 2
[11:01:35.901] MulticoreFuture started
[11:01:35.901] - Launch lazy future ... done
[11:01:35.901] run() for ‘MulticoreFuture’ ... done
[11:01:35.901] result() for MulticoreFuture ...
[11:01:35.902] plan(): Setting new future strategy stack:
[11:01:35.902] List of future strategies:
[11:01:35.902] 1. sequential:
[11:01:35.902]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.902]    - tweaked: FALSE
[11:01:35.902]    - call: NULL
[11:01:35.903] plan(): nbrOfWorkers() = 1
[11:01:35.905] plan(): Setting new future strategy stack:
[11:01:35.906] List of future strategies:
[11:01:35.906] 1. multicore:
[11:01:35.906]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:35.906]    - tweaked: FALSE
[11:01:35.906]    - call: plan(strategy)
[11:01:35.908] plan(): nbrOfWorkers() = 2
[11:01:35.909] result() for MulticoreFuture ...
[11:01:35.909] result() for MulticoreFuture ... done
[11:01:35.909] result() for MulticoreFuture ... done
[11:01:35.910] result() for MulticoreFuture ...
[11:01:35.910] result() for MulticoreFuture ... done
x
1 2 
2 3 
[11:01:35.911] getGlobalsAndPackages() ...
[11:01:35.911] Searching for globals...
[11:01:35.912] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[11:01:35.913] Searching for globals ... DONE
[11:01:35.913] Resolving globals: FALSE
[11:01:35.913] The total size of the 1 globals is 71 bytes (71 bytes)
[11:01:35.914] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 71 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (71 bytes of class ‘numeric’)
[11:01:35.914] - globals: [1] ‘x’
[11:01:35.914] - packages: [1] ‘stats’
[11:01:35.914] getGlobalsAndPackages() ... DONE
[11:01:35.915] run() for ‘Future’ ...
[11:01:35.915] - state: ‘created’
[11:01:35.915] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:35.917] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:35.919] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:35.919]   - Field: ‘label’
[11:01:35.919]   - Field: ‘local’
[11:01:35.919]   - Field: ‘owner’
[11:01:35.919]   - Field: ‘envir’
[11:01:35.919]   - Field: ‘workers’
[11:01:35.920]   - Field: ‘packages’
[11:01:35.920]   - Field: ‘gc’
[11:01:35.920]   - Field: ‘job’
[11:01:35.920]   - Field: ‘conditions’
[11:01:35.920]   - Field: ‘expr’
[11:01:35.920]   - Field: ‘uuid’
[11:01:35.920]   - Field: ‘seed’
[11:01:35.920]   - Field: ‘version’
[11:01:35.921]   - Field: ‘result’
[11:01:35.921]   - Field: ‘asynchronous’
[11:01:35.921]   - Field: ‘calls’
[11:01:35.921]   - Field: ‘globals’
[11:01:35.921]   - Field: ‘stdout’
[11:01:35.921]   - Field: ‘earlySignal’
[11:01:35.921]   - Field: ‘lazy’
[11:01:35.921]   - Field: ‘state’
[11:01:35.922] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:35.922] - Launch lazy future ...
[11:01:35.922] Packages needed by the future expression (n = 1): ‘stats’
[11:01:35.922] Packages needed by future strategies (n = 0): <none>
[11:01:35.923] {
[11:01:35.923]     {
[11:01:35.923]         {
[11:01:35.923]             ...future.startTime <- base::Sys.time()
[11:01:35.923]             {
[11:01:35.923]                 {
[11:01:35.923]                   {
[11:01:35.923]                     {
[11:01:35.923]                       {
[11:01:35.923]                         base::local({
[11:01:35.923]                           has_future <- base::requireNamespace("future", 
[11:01:35.923]                             quietly = TRUE)
[11:01:35.923]                           if (has_future) {
[11:01:35.923]                             ns <- base::getNamespace("future")
[11:01:35.923]                             version <- ns[[".package"]][["version"]]
[11:01:35.923]                             if (is.null(version)) 
[11:01:35.923]                               version <- utils::packageVersion("future")
[11:01:35.923]                           }
[11:01:35.923]                           else {
[11:01:35.923]                             version <- NULL
[11:01:35.923]                           }
[11:01:35.923]                           if (!has_future || version < "1.8.0") {
[11:01:35.923]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.923]                               "", base::R.version$version.string), 
[11:01:35.923]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:35.923]                                 base::R.version$platform, 8 * 
[11:01:35.923]                                   base::.Machine$sizeof.pointer), 
[11:01:35.923]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.923]                                 "release", "version")], collapse = " "), 
[11:01:35.923]                               hostname = base::Sys.info()[["nodename"]])
[11:01:35.923]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.923]                               info)
[11:01:35.923]                             info <- base::paste(info, collapse = "; ")
[11:01:35.923]                             if (!has_future) {
[11:01:35.923]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.923]                                 info)
[11:01:35.923]                             }
[11:01:35.923]                             else {
[11:01:35.923]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.923]                                 info, version)
[11:01:35.923]                             }
[11:01:35.923]                             base::stop(msg)
[11:01:35.923]                           }
[11:01:35.923]                         })
[11:01:35.923]                       }
[11:01:35.923]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:35.923]                       base::options(mc.cores = 1L)
[11:01:35.923]                     }
[11:01:35.923]                     base::local({
[11:01:35.923]                       for (pkg in "stats") {
[11:01:35.923]                         base::loadNamespace(pkg)
[11:01:35.923]                         base::library(pkg, character.only = TRUE)
[11:01:35.923]                       }
[11:01:35.923]                     })
[11:01:35.923]                   }
[11:01:35.923]                   ...future.strategy.old <- future::plan("list")
[11:01:35.923]                   options(future.plan = NULL)
[11:01:35.923]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.923]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.923]                 }
[11:01:35.923]                 ...future.workdir <- getwd()
[11:01:35.923]             }
[11:01:35.923]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.923]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.923]         }
[11:01:35.923]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.923]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.923]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.923]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.923]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.923]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.923]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.923]             base::names(...future.oldOptions))
[11:01:35.923]     }
[11:01:35.923]     if (FALSE) {
[11:01:35.923]     }
[11:01:35.923]     else {
[11:01:35.923]         if (TRUE) {
[11:01:35.923]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.923]                 open = "w")
[11:01:35.923]         }
[11:01:35.923]         else {
[11:01:35.923]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.923]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.923]         }
[11:01:35.923]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.923]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.923]             base::sink(type = "output", split = FALSE)
[11:01:35.923]             base::close(...future.stdout)
[11:01:35.923]         }, add = TRUE)
[11:01:35.923]     }
[11:01:35.923]     ...future.frame <- base::sys.nframe()
[11:01:35.923]     ...future.conditions <- base::list()
[11:01:35.923]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.923]     if (FALSE) {
[11:01:35.923]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.923]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.923]     }
[11:01:35.923]     ...future.result <- base::tryCatch({
[11:01:35.923]         base::withCallingHandlers({
[11:01:35.923]             ...future.value <- base::withVisible(base::local({
[11:01:35.923]                 withCallingHandlers({
[11:01:35.923]                   {
[11:01:35.923]                     xtabs(~x)
[11:01:35.923]                   }
[11:01:35.923]                 }, immediateCondition = function(cond) {
[11:01:35.923]                   save_rds <- function (object, pathname, ...) 
[11:01:35.923]                   {
[11:01:35.923]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:35.923]                     if (file_test("-f", pathname_tmp)) {
[11:01:35.923]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.923]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:35.923]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.923]                         fi_tmp[["mtime"]])
[11:01:35.923]                     }
[11:01:35.923]                     tryCatch({
[11:01:35.923]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:35.923]                     }, error = function(ex) {
[11:01:35.923]                       msg <- conditionMessage(ex)
[11:01:35.923]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.923]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:35.923]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.923]                         fi_tmp[["mtime"]], msg)
[11:01:35.923]                       ex$message <- msg
[11:01:35.923]                       stop(ex)
[11:01:35.923]                     })
[11:01:35.923]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:35.923]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:35.923]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:35.923]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.923]                       fi <- file.info(pathname)
[11:01:35.923]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:35.923]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.923]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:35.923]                         fi[["size"]], fi[["mtime"]])
[11:01:35.923]                       stop(msg)
[11:01:35.923]                     }
[11:01:35.923]                     invisible(pathname)
[11:01:35.923]                   }
[11:01:35.923]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:35.923]                     rootPath = tempdir()) 
[11:01:35.923]                   {
[11:01:35.923]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:35.923]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:35.923]                       tmpdir = path, fileext = ".rds")
[11:01:35.923]                     save_rds(obj, file)
[11:01:35.923]                   }
[11:01:35.923]                   saveImmediateCondition(cond, path = "/tmp/Rtmpu6OqnW/.future/immediateConditions")
[11:01:35.923]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.923]                   {
[11:01:35.923]                     inherits <- base::inherits
[11:01:35.923]                     invokeRestart <- base::invokeRestart
[11:01:35.923]                     is.null <- base::is.null
[11:01:35.923]                     muffled <- FALSE
[11:01:35.923]                     if (inherits(cond, "message")) {
[11:01:35.923]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:35.923]                       if (muffled) 
[11:01:35.923]                         invokeRestart("muffleMessage")
[11:01:35.923]                     }
[11:01:35.923]                     else if (inherits(cond, "warning")) {
[11:01:35.923]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:35.923]                       if (muffled) 
[11:01:35.923]                         invokeRestart("muffleWarning")
[11:01:35.923]                     }
[11:01:35.923]                     else if (inherits(cond, "condition")) {
[11:01:35.923]                       if (!is.null(pattern)) {
[11:01:35.923]                         computeRestarts <- base::computeRestarts
[11:01:35.923]                         grepl <- base::grepl
[11:01:35.923]                         restarts <- computeRestarts(cond)
[11:01:35.923]                         for (restart in restarts) {
[11:01:35.923]                           name <- restart$name
[11:01:35.923]                           if (is.null(name)) 
[11:01:35.923]                             next
[11:01:35.923]                           if (!grepl(pattern, name)) 
[11:01:35.923]                             next
[11:01:35.923]                           invokeRestart(restart)
[11:01:35.923]                           muffled <- TRUE
[11:01:35.923]                           break
[11:01:35.923]                         }
[11:01:35.923]                       }
[11:01:35.923]                     }
[11:01:35.923]                     invisible(muffled)
[11:01:35.923]                   }
[11:01:35.923]                   muffleCondition(cond)
[11:01:35.923]                 })
[11:01:35.923]             }))
[11:01:35.923]             future::FutureResult(value = ...future.value$value, 
[11:01:35.923]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.923]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.923]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.923]                     ...future.globalenv.names))
[11:01:35.923]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.923]         }, condition = base::local({
[11:01:35.923]             c <- base::c
[11:01:35.923]             inherits <- base::inherits
[11:01:35.923]             invokeRestart <- base::invokeRestart
[11:01:35.923]             length <- base::length
[11:01:35.923]             list <- base::list
[11:01:35.923]             seq.int <- base::seq.int
[11:01:35.923]             signalCondition <- base::signalCondition
[11:01:35.923]             sys.calls <- base::sys.calls
[11:01:35.923]             `[[` <- base::`[[`
[11:01:35.923]             `+` <- base::`+`
[11:01:35.923]             `<<-` <- base::`<<-`
[11:01:35.923]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.923]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.923]                   3L)]
[11:01:35.923]             }
[11:01:35.923]             function(cond) {
[11:01:35.923]                 is_error <- inherits(cond, "error")
[11:01:35.923]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.923]                   NULL)
[11:01:35.923]                 if (is_error) {
[11:01:35.923]                   sessionInformation <- function() {
[11:01:35.923]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.923]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.923]                       search = base::search(), system = base::Sys.info())
[11:01:35.923]                   }
[11:01:35.923]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.923]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.923]                     cond$call), session = sessionInformation(), 
[11:01:35.923]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.923]                   signalCondition(cond)
[11:01:35.923]                 }
[11:01:35.923]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.923]                 "immediateCondition"))) {
[11:01:35.923]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.923]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.923]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.923]                   if (TRUE && !signal) {
[11:01:35.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.923]                     {
[11:01:35.923]                       inherits <- base::inherits
[11:01:35.923]                       invokeRestart <- base::invokeRestart
[11:01:35.923]                       is.null <- base::is.null
[11:01:35.923]                       muffled <- FALSE
[11:01:35.923]                       if (inherits(cond, "message")) {
[11:01:35.923]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.923]                         if (muffled) 
[11:01:35.923]                           invokeRestart("muffleMessage")
[11:01:35.923]                       }
[11:01:35.923]                       else if (inherits(cond, "warning")) {
[11:01:35.923]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.923]                         if (muffled) 
[11:01:35.923]                           invokeRestart("muffleWarning")
[11:01:35.923]                       }
[11:01:35.923]                       else if (inherits(cond, "condition")) {
[11:01:35.923]                         if (!is.null(pattern)) {
[11:01:35.923]                           computeRestarts <- base::computeRestarts
[11:01:35.923]                           grepl <- base::grepl
[11:01:35.923]                           restarts <- computeRestarts(cond)
[11:01:35.923]                           for (restart in restarts) {
[11:01:35.923]                             name <- restart$name
[11:01:35.923]                             if (is.null(name)) 
[11:01:35.923]                               next
[11:01:35.923]                             if (!grepl(pattern, name)) 
[11:01:35.923]                               next
[11:01:35.923]                             invokeRestart(restart)
[11:01:35.923]                             muffled <- TRUE
[11:01:35.923]                             break
[11:01:35.923]                           }
[11:01:35.923]                         }
[11:01:35.923]                       }
[11:01:35.923]                       invisible(muffled)
[11:01:35.923]                     }
[11:01:35.923]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.923]                   }
[11:01:35.923]                 }
[11:01:35.923]                 else {
[11:01:35.923]                   if (TRUE) {
[11:01:35.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.923]                     {
[11:01:35.923]                       inherits <- base::inherits
[11:01:35.923]                       invokeRestart <- base::invokeRestart
[11:01:35.923]                       is.null <- base::is.null
[11:01:35.923]                       muffled <- FALSE
[11:01:35.923]                       if (inherits(cond, "message")) {
[11:01:35.923]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.923]                         if (muffled) 
[11:01:35.923]                           invokeRestart("muffleMessage")
[11:01:35.923]                       }
[11:01:35.923]                       else if (inherits(cond, "warning")) {
[11:01:35.923]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.923]                         if (muffled) 
[11:01:35.923]                           invokeRestart("muffleWarning")
[11:01:35.923]                       }
[11:01:35.923]                       else if (inherits(cond, "condition")) {
[11:01:35.923]                         if (!is.null(pattern)) {
[11:01:35.923]                           computeRestarts <- base::computeRestarts
[11:01:35.923]                           grepl <- base::grepl
[11:01:35.923]                           restarts <- computeRestarts(cond)
[11:01:35.923]                           for (restart in restarts) {
[11:01:35.923]                             name <- restart$name
[11:01:35.923]                             if (is.null(name)) 
[11:01:35.923]                               next
[11:01:35.923]                             if (!grepl(pattern, name)) 
[11:01:35.923]                               next
[11:01:35.923]                             invokeRestart(restart)
[11:01:35.923]                             muffled <- TRUE
[11:01:35.923]                             break
[11:01:35.923]                           }
[11:01:35.923]                         }
[11:01:35.923]                       }
[11:01:35.923]                       invisible(muffled)
[11:01:35.923]                     }
[11:01:35.923]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.923]                   }
[11:01:35.923]                 }
[11:01:35.923]             }
[11:01:35.923]         }))
[11:01:35.923]     }, error = function(ex) {
[11:01:35.923]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.923]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.923]                 ...future.rng), started = ...future.startTime, 
[11:01:35.923]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.923]             version = "1.8"), class = "FutureResult")
[11:01:35.923]     }, finally = {
[11:01:35.923]         if (!identical(...future.workdir, getwd())) 
[11:01:35.923]             setwd(...future.workdir)
[11:01:35.923]         {
[11:01:35.923]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.923]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.923]             }
[11:01:35.923]             base::options(...future.oldOptions)
[11:01:35.923]             if (.Platform$OS.type == "windows") {
[11:01:35.923]                 old_names <- names(...future.oldEnvVars)
[11:01:35.923]                 envs <- base::Sys.getenv()
[11:01:35.923]                 names <- names(envs)
[11:01:35.923]                 common <- intersect(names, old_names)
[11:01:35.923]                 added <- setdiff(names, old_names)
[11:01:35.923]                 removed <- setdiff(old_names, names)
[11:01:35.923]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.923]                   envs[common]]
[11:01:35.923]                 NAMES <- toupper(changed)
[11:01:35.923]                 args <- list()
[11:01:35.923]                 for (kk in seq_along(NAMES)) {
[11:01:35.923]                   name <- changed[[kk]]
[11:01:35.923]                   NAME <- NAMES[[kk]]
[11:01:35.923]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.923]                     next
[11:01:35.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.923]                 }
[11:01:35.923]                 NAMES <- toupper(added)
[11:01:35.923]                 for (kk in seq_along(NAMES)) {
[11:01:35.923]                   name <- added[[kk]]
[11:01:35.923]                   NAME <- NAMES[[kk]]
[11:01:35.923]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.923]                     next
[11:01:35.923]                   args[[name]] <- ""
[11:01:35.923]                 }
[11:01:35.923]                 NAMES <- toupper(removed)
[11:01:35.923]                 for (kk in seq_along(NAMES)) {
[11:01:35.923]                   name <- removed[[kk]]
[11:01:35.923]                   NAME <- NAMES[[kk]]
[11:01:35.923]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.923]                     next
[11:01:35.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.923]                 }
[11:01:35.923]                 if (length(args) > 0) 
[11:01:35.923]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.923]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.923]             }
[11:01:35.923]             else {
[11:01:35.923]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.923]             }
[11:01:35.923]             {
[11:01:35.923]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.923]                   0L) {
[11:01:35.923]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.923]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.923]                   base::options(opts)
[11:01:35.923]                 }
[11:01:35.923]                 {
[11:01:35.923]                   {
[11:01:35.923]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:35.923]                     NULL
[11:01:35.923]                   }
[11:01:35.923]                   options(future.plan = NULL)
[11:01:35.923]                   if (is.na(NA_character_)) 
[11:01:35.923]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.923]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.923]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.923]                     .init = FALSE)
[11:01:35.923]                 }
[11:01:35.923]             }
[11:01:35.923]         }
[11:01:35.923]     })
[11:01:35.923]     if (TRUE) {
[11:01:35.923]         base::sink(type = "output", split = FALSE)
[11:01:35.923]         if (TRUE) {
[11:01:35.923]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.923]         }
[11:01:35.923]         else {
[11:01:35.923]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.923]         }
[11:01:35.923]         base::close(...future.stdout)
[11:01:35.923]         ...future.stdout <- NULL
[11:01:35.923]     }
[11:01:35.923]     ...future.result$conditions <- ...future.conditions
[11:01:35.923]     ...future.result$finished <- base::Sys.time()
[11:01:35.923]     ...future.result
[11:01:35.923] }
[11:01:35.925] assign_globals() ...
[11:01:35.925] List of 1
[11:01:35.925]  $ x: num [1:5] 1 1 2 2 2
[11:01:35.925]  - attr(*, "where")=List of 1
[11:01:35.925]   ..$ x:<environment: R_EmptyEnv> 
[11:01:35.925]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:35.925]  - attr(*, "resolved")= logi FALSE
[11:01:35.925]  - attr(*, "total_size")= num 71
[11:01:35.925]  - attr(*, "already-done")= logi TRUE
[11:01:35.928] - copied ‘x’ to environment
[11:01:35.928] assign_globals() ... done
[11:01:35.929] requestCore(): workers = 2
[11:01:35.930] MulticoreFuture started
[11:01:35.930] - Launch lazy future ... done
[11:01:35.931] run() for ‘MulticoreFuture’ ... done
[11:01:35.931] result() for MulticoreFuture ...
[11:01:35.931] plan(): Setting new future strategy stack:
[11:01:35.932] List of future strategies:
[11:01:35.932] 1. sequential:
[11:01:35.932]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.932]    - tweaked: FALSE
[11:01:35.932]    - call: NULL
[11:01:35.933] plan(): nbrOfWorkers() = 1
[11:01:35.935] plan(): Setting new future strategy stack:
[11:01:35.935] List of future strategies:
[11:01:35.935] 1. multicore:
[11:01:35.935]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:35.935]    - tweaked: FALSE
[11:01:35.935]    - call: plan(strategy)
[11:01:35.938] plan(): nbrOfWorkers() = 2
[11:01:35.939] result() for MulticoreFuture ...
[11:01:35.939] result() for MulticoreFuture ... done
[11:01:35.939] result() for MulticoreFuture ... done
[11:01:35.940] result() for MulticoreFuture ...
[11:01:35.940] result() for MulticoreFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[11:01:35.942] getGlobalsAndPackages() ...
[11:01:35.942] Searching for globals...
[11:01:35.944] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[11:01:35.944] Searching for globals ... DONE
[11:01:35.944] Resolving globals: FALSE
[11:01:35.945] 
[11:01:35.945] - packages: [2] ‘stats’, ‘datasets’
[11:01:35.945] getGlobalsAndPackages() ... DONE
[11:01:35.946] run() for ‘Future’ ...
[11:01:35.946] - state: ‘created’
[11:01:35.946] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:35.948] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:35.948] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:35.948]   - Field: ‘label’
[11:01:35.948]   - Field: ‘local’
[11:01:35.949]   - Field: ‘owner’
[11:01:35.949]   - Field: ‘envir’
[11:01:35.949]   - Field: ‘workers’
[11:01:35.949]   - Field: ‘packages’
[11:01:35.949]   - Field: ‘gc’
[11:01:35.949]   - Field: ‘job’
[11:01:35.949]   - Field: ‘conditions’
[11:01:35.949]   - Field: ‘expr’
[11:01:35.949]   - Field: ‘uuid’
[11:01:35.949]   - Field: ‘seed’
[11:01:35.950]   - Field: ‘version’
[11:01:35.950]   - Field: ‘result’
[11:01:35.950]   - Field: ‘asynchronous’
[11:01:35.950]   - Field: ‘calls’
[11:01:35.950]   - Field: ‘globals’
[11:01:35.950]   - Field: ‘stdout’
[11:01:35.950]   - Field: ‘earlySignal’
[11:01:35.950]   - Field: ‘lazy’
[11:01:35.950]   - Field: ‘state’
[11:01:35.950] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:35.951] - Launch lazy future ...
[11:01:35.951] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[11:01:35.951] Packages needed by future strategies (n = 0): <none>
[11:01:35.952] {
[11:01:35.952]     {
[11:01:35.952]         {
[11:01:35.952]             ...future.startTime <- base::Sys.time()
[11:01:35.952]             {
[11:01:35.952]                 {
[11:01:35.952]                   {
[11:01:35.952]                     {
[11:01:35.952]                       {
[11:01:35.952]                         base::local({
[11:01:35.952]                           has_future <- base::requireNamespace("future", 
[11:01:35.952]                             quietly = TRUE)
[11:01:35.952]                           if (has_future) {
[11:01:35.952]                             ns <- base::getNamespace("future")
[11:01:35.952]                             version <- ns[[".package"]][["version"]]
[11:01:35.952]                             if (is.null(version)) 
[11:01:35.952]                               version <- utils::packageVersion("future")
[11:01:35.952]                           }
[11:01:35.952]                           else {
[11:01:35.952]                             version <- NULL
[11:01:35.952]                           }
[11:01:35.952]                           if (!has_future || version < "1.8.0") {
[11:01:35.952]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.952]                               "", base::R.version$version.string), 
[11:01:35.952]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:35.952]                                 base::R.version$platform, 8 * 
[11:01:35.952]                                   base::.Machine$sizeof.pointer), 
[11:01:35.952]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.952]                                 "release", "version")], collapse = " "), 
[11:01:35.952]                               hostname = base::Sys.info()[["nodename"]])
[11:01:35.952]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.952]                               info)
[11:01:35.952]                             info <- base::paste(info, collapse = "; ")
[11:01:35.952]                             if (!has_future) {
[11:01:35.952]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.952]                                 info)
[11:01:35.952]                             }
[11:01:35.952]                             else {
[11:01:35.952]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.952]                                 info, version)
[11:01:35.952]                             }
[11:01:35.952]                             base::stop(msg)
[11:01:35.952]                           }
[11:01:35.952]                         })
[11:01:35.952]                       }
[11:01:35.952]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:35.952]                       base::options(mc.cores = 1L)
[11:01:35.952]                     }
[11:01:35.952]                     base::local({
[11:01:35.952]                       for (pkg in c("stats", "datasets")) {
[11:01:35.952]                         base::loadNamespace(pkg)
[11:01:35.952]                         base::library(pkg, character.only = TRUE)
[11:01:35.952]                       }
[11:01:35.952]                     })
[11:01:35.952]                   }
[11:01:35.952]                   ...future.strategy.old <- future::plan("list")
[11:01:35.952]                   options(future.plan = NULL)
[11:01:35.952]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.952]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.952]                 }
[11:01:35.952]                 ...future.workdir <- getwd()
[11:01:35.952]             }
[11:01:35.952]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.952]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.952]         }
[11:01:35.952]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.952]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.952]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.952]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.952]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.952]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.952]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.952]             base::names(...future.oldOptions))
[11:01:35.952]     }
[11:01:35.952]     if (FALSE) {
[11:01:35.952]     }
[11:01:35.952]     else {
[11:01:35.952]         if (TRUE) {
[11:01:35.952]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.952]                 open = "w")
[11:01:35.952]         }
[11:01:35.952]         else {
[11:01:35.952]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.952]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.952]         }
[11:01:35.952]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.952]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.952]             base::sink(type = "output", split = FALSE)
[11:01:35.952]             base::close(...future.stdout)
[11:01:35.952]         }, add = TRUE)
[11:01:35.952]     }
[11:01:35.952]     ...future.frame <- base::sys.nframe()
[11:01:35.952]     ...future.conditions <- base::list()
[11:01:35.952]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.952]     if (FALSE) {
[11:01:35.952]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.952]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.952]     }
[11:01:35.952]     ...future.result <- base::tryCatch({
[11:01:35.952]         base::withCallingHandlers({
[11:01:35.952]             ...future.value <- base::withVisible(base::local({
[11:01:35.952]                 withCallingHandlers({
[11:01:35.952]                   {
[11:01:35.952]                     lm(dist ~ . - 1, data = cars)
[11:01:35.952]                   }
[11:01:35.952]                 }, immediateCondition = function(cond) {
[11:01:35.952]                   save_rds <- function (object, pathname, ...) 
[11:01:35.952]                   {
[11:01:35.952]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:35.952]                     if (file_test("-f", pathname_tmp)) {
[11:01:35.952]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.952]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:35.952]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.952]                         fi_tmp[["mtime"]])
[11:01:35.952]                     }
[11:01:35.952]                     tryCatch({
[11:01:35.952]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:35.952]                     }, error = function(ex) {
[11:01:35.952]                       msg <- conditionMessage(ex)
[11:01:35.952]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.952]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:35.952]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.952]                         fi_tmp[["mtime"]], msg)
[11:01:35.952]                       ex$message <- msg
[11:01:35.952]                       stop(ex)
[11:01:35.952]                     })
[11:01:35.952]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:35.952]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:35.952]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:35.952]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.952]                       fi <- file.info(pathname)
[11:01:35.952]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:35.952]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.952]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:35.952]                         fi[["size"]], fi[["mtime"]])
[11:01:35.952]                       stop(msg)
[11:01:35.952]                     }
[11:01:35.952]                     invisible(pathname)
[11:01:35.952]                   }
[11:01:35.952]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:35.952]                     rootPath = tempdir()) 
[11:01:35.952]                   {
[11:01:35.952]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:35.952]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:35.952]                       tmpdir = path, fileext = ".rds")
[11:01:35.952]                     save_rds(obj, file)
[11:01:35.952]                   }
[11:01:35.952]                   saveImmediateCondition(cond, path = "/tmp/Rtmpu6OqnW/.future/immediateConditions")
[11:01:35.952]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.952]                   {
[11:01:35.952]                     inherits <- base::inherits
[11:01:35.952]                     invokeRestart <- base::invokeRestart
[11:01:35.952]                     is.null <- base::is.null
[11:01:35.952]                     muffled <- FALSE
[11:01:35.952]                     if (inherits(cond, "message")) {
[11:01:35.952]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:35.952]                       if (muffled) 
[11:01:35.952]                         invokeRestart("muffleMessage")
[11:01:35.952]                     }
[11:01:35.952]                     else if (inherits(cond, "warning")) {
[11:01:35.952]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:35.952]                       if (muffled) 
[11:01:35.952]                         invokeRestart("muffleWarning")
[11:01:35.952]                     }
[11:01:35.952]                     else if (inherits(cond, "condition")) {
[11:01:35.952]                       if (!is.null(pattern)) {
[11:01:35.952]                         computeRestarts <- base::computeRestarts
[11:01:35.952]                         grepl <- base::grepl
[11:01:35.952]                         restarts <- computeRestarts(cond)
[11:01:35.952]                         for (restart in restarts) {
[11:01:35.952]                           name <- restart$name
[11:01:35.952]                           if (is.null(name)) 
[11:01:35.952]                             next
[11:01:35.952]                           if (!grepl(pattern, name)) 
[11:01:35.952]                             next
[11:01:35.952]                           invokeRestart(restart)
[11:01:35.952]                           muffled <- TRUE
[11:01:35.952]                           break
[11:01:35.952]                         }
[11:01:35.952]                       }
[11:01:35.952]                     }
[11:01:35.952]                     invisible(muffled)
[11:01:35.952]                   }
[11:01:35.952]                   muffleCondition(cond)
[11:01:35.952]                 })
[11:01:35.952]             }))
[11:01:35.952]             future::FutureResult(value = ...future.value$value, 
[11:01:35.952]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.952]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.952]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.952]                     ...future.globalenv.names))
[11:01:35.952]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.952]         }, condition = base::local({
[11:01:35.952]             c <- base::c
[11:01:35.952]             inherits <- base::inherits
[11:01:35.952]             invokeRestart <- base::invokeRestart
[11:01:35.952]             length <- base::length
[11:01:35.952]             list <- base::list
[11:01:35.952]             seq.int <- base::seq.int
[11:01:35.952]             signalCondition <- base::signalCondition
[11:01:35.952]             sys.calls <- base::sys.calls
[11:01:35.952]             `[[` <- base::`[[`
[11:01:35.952]             `+` <- base::`+`
[11:01:35.952]             `<<-` <- base::`<<-`
[11:01:35.952]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.952]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.952]                   3L)]
[11:01:35.952]             }
[11:01:35.952]             function(cond) {
[11:01:35.952]                 is_error <- inherits(cond, "error")
[11:01:35.952]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.952]                   NULL)
[11:01:35.952]                 if (is_error) {
[11:01:35.952]                   sessionInformation <- function() {
[11:01:35.952]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.952]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.952]                       search = base::search(), system = base::Sys.info())
[11:01:35.952]                   }
[11:01:35.952]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.952]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.952]                     cond$call), session = sessionInformation(), 
[11:01:35.952]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.952]                   signalCondition(cond)
[11:01:35.952]                 }
[11:01:35.952]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.952]                 "immediateCondition"))) {
[11:01:35.952]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.952]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.952]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.952]                   if (TRUE && !signal) {
[11:01:35.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.952]                     {
[11:01:35.952]                       inherits <- base::inherits
[11:01:35.952]                       invokeRestart <- base::invokeRestart
[11:01:35.952]                       is.null <- base::is.null
[11:01:35.952]                       muffled <- FALSE
[11:01:35.952]                       if (inherits(cond, "message")) {
[11:01:35.952]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.952]                         if (muffled) 
[11:01:35.952]                           invokeRestart("muffleMessage")
[11:01:35.952]                       }
[11:01:35.952]                       else if (inherits(cond, "warning")) {
[11:01:35.952]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.952]                         if (muffled) 
[11:01:35.952]                           invokeRestart("muffleWarning")
[11:01:35.952]                       }
[11:01:35.952]                       else if (inherits(cond, "condition")) {
[11:01:35.952]                         if (!is.null(pattern)) {
[11:01:35.952]                           computeRestarts <- base::computeRestarts
[11:01:35.952]                           grepl <- base::grepl
[11:01:35.952]                           restarts <- computeRestarts(cond)
[11:01:35.952]                           for (restart in restarts) {
[11:01:35.952]                             name <- restart$name
[11:01:35.952]                             if (is.null(name)) 
[11:01:35.952]                               next
[11:01:35.952]                             if (!grepl(pattern, name)) 
[11:01:35.952]                               next
[11:01:35.952]                             invokeRestart(restart)
[11:01:35.952]                             muffled <- TRUE
[11:01:35.952]                             break
[11:01:35.952]                           }
[11:01:35.952]                         }
[11:01:35.952]                       }
[11:01:35.952]                       invisible(muffled)
[11:01:35.952]                     }
[11:01:35.952]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.952]                   }
[11:01:35.952]                 }
[11:01:35.952]                 else {
[11:01:35.952]                   if (TRUE) {
[11:01:35.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.952]                     {
[11:01:35.952]                       inherits <- base::inherits
[11:01:35.952]                       invokeRestart <- base::invokeRestart
[11:01:35.952]                       is.null <- base::is.null
[11:01:35.952]                       muffled <- FALSE
[11:01:35.952]                       if (inherits(cond, "message")) {
[11:01:35.952]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.952]                         if (muffled) 
[11:01:35.952]                           invokeRestart("muffleMessage")
[11:01:35.952]                       }
[11:01:35.952]                       else if (inherits(cond, "warning")) {
[11:01:35.952]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.952]                         if (muffled) 
[11:01:35.952]                           invokeRestart("muffleWarning")
[11:01:35.952]                       }
[11:01:35.952]                       else if (inherits(cond, "condition")) {
[11:01:35.952]                         if (!is.null(pattern)) {
[11:01:35.952]                           computeRestarts <- base::computeRestarts
[11:01:35.952]                           grepl <- base::grepl
[11:01:35.952]                           restarts <- computeRestarts(cond)
[11:01:35.952]                           for (restart in restarts) {
[11:01:35.952]                             name <- restart$name
[11:01:35.952]                             if (is.null(name)) 
[11:01:35.952]                               next
[11:01:35.952]                             if (!grepl(pattern, name)) 
[11:01:35.952]                               next
[11:01:35.952]                             invokeRestart(restart)
[11:01:35.952]                             muffled <- TRUE
[11:01:35.952]                             break
[11:01:35.952]                           }
[11:01:35.952]                         }
[11:01:35.952]                       }
[11:01:35.952]                       invisible(muffled)
[11:01:35.952]                     }
[11:01:35.952]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.952]                   }
[11:01:35.952]                 }
[11:01:35.952]             }
[11:01:35.952]         }))
[11:01:35.952]     }, error = function(ex) {
[11:01:35.952]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.952]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.952]                 ...future.rng), started = ...future.startTime, 
[11:01:35.952]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.952]             version = "1.8"), class = "FutureResult")
[11:01:35.952]     }, finally = {
[11:01:35.952]         if (!identical(...future.workdir, getwd())) 
[11:01:35.952]             setwd(...future.workdir)
[11:01:35.952]         {
[11:01:35.952]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.952]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.952]             }
[11:01:35.952]             base::options(...future.oldOptions)
[11:01:35.952]             if (.Platform$OS.type == "windows") {
[11:01:35.952]                 old_names <- names(...future.oldEnvVars)
[11:01:35.952]                 envs <- base::Sys.getenv()
[11:01:35.952]                 names <- names(envs)
[11:01:35.952]                 common <- intersect(names, old_names)
[11:01:35.952]                 added <- setdiff(names, old_names)
[11:01:35.952]                 removed <- setdiff(old_names, names)
[11:01:35.952]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.952]                   envs[common]]
[11:01:35.952]                 NAMES <- toupper(changed)
[11:01:35.952]                 args <- list()
[11:01:35.952]                 for (kk in seq_along(NAMES)) {
[11:01:35.952]                   name <- changed[[kk]]
[11:01:35.952]                   NAME <- NAMES[[kk]]
[11:01:35.952]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.952]                     next
[11:01:35.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.952]                 }
[11:01:35.952]                 NAMES <- toupper(added)
[11:01:35.952]                 for (kk in seq_along(NAMES)) {
[11:01:35.952]                   name <- added[[kk]]
[11:01:35.952]                   NAME <- NAMES[[kk]]
[11:01:35.952]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.952]                     next
[11:01:35.952]                   args[[name]] <- ""
[11:01:35.952]                 }
[11:01:35.952]                 NAMES <- toupper(removed)
[11:01:35.952]                 for (kk in seq_along(NAMES)) {
[11:01:35.952]                   name <- removed[[kk]]
[11:01:35.952]                   NAME <- NAMES[[kk]]
[11:01:35.952]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.952]                     next
[11:01:35.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.952]                 }
[11:01:35.952]                 if (length(args) > 0) 
[11:01:35.952]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.952]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.952]             }
[11:01:35.952]             else {
[11:01:35.952]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.952]             }
[11:01:35.952]             {
[11:01:35.952]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.952]                   0L) {
[11:01:35.952]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.952]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.952]                   base::options(opts)
[11:01:35.952]                 }
[11:01:35.952]                 {
[11:01:35.952]                   {
[11:01:35.952]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:35.952]                     NULL
[11:01:35.952]                   }
[11:01:35.952]                   options(future.plan = NULL)
[11:01:35.952]                   if (is.na(NA_character_)) 
[11:01:35.952]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.952]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.952]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.952]                     .init = FALSE)
[11:01:35.952]                 }
[11:01:35.952]             }
[11:01:35.952]         }
[11:01:35.952]     })
[11:01:35.952]     if (TRUE) {
[11:01:35.952]         base::sink(type = "output", split = FALSE)
[11:01:35.952]         if (TRUE) {
[11:01:35.952]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.952]         }
[11:01:35.952]         else {
[11:01:35.952]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.952]         }
[11:01:35.952]         base::close(...future.stdout)
[11:01:35.952]         ...future.stdout <- NULL
[11:01:35.952]     }
[11:01:35.952]     ...future.result$conditions <- ...future.conditions
[11:01:35.952]     ...future.result$finished <- base::Sys.time()
[11:01:35.952]     ...future.result
[11:01:35.952] }
[11:01:35.954] requestCore(): workers = 2
[11:01:35.956] MulticoreFuture started
[11:01:35.956] - Launch lazy future ... done
[11:01:35.956] run() for ‘MulticoreFuture’ ... done
[11:01:35.957] result() for MulticoreFuture ...
[11:01:35.957] plan(): Setting new future strategy stack:
[11:01:35.957] List of future strategies:
[11:01:35.957] 1. sequential:
[11:01:35.957]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.957]    - tweaked: FALSE
[11:01:35.957]    - call: NULL
[11:01:35.958] plan(): nbrOfWorkers() = 1
[11:01:35.965] plan(): Setting new future strategy stack:
[11:01:35.965] List of future strategies:
[11:01:35.965] 1. multicore:
[11:01:35.965]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:35.965]    - tweaked: FALSE
[11:01:35.965]    - call: plan(strategy)
[11:01:35.968] plan(): nbrOfWorkers() = 2
[11:01:35.971] result() for MulticoreFuture ...
[11:01:35.971] result() for MulticoreFuture ... done
[11:01:35.971] result() for MulticoreFuture ... done
[11:01:35.971] result() for MulticoreFuture ...
[11:01:35.971] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[11:01:35.977] getGlobalsAndPackages() ...
[11:01:35.977] Searching for globals...
[11:01:35.979] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[11:01:35.979] Searching for globals ... DONE
[11:01:35.979] Resolving globals: FALSE
[11:01:35.980] 
[11:01:35.980] - packages: [2] ‘stats’, ‘datasets’
[11:01:35.980] getGlobalsAndPackages() ... DONE
[11:01:35.980] run() for ‘Future’ ...
[11:01:35.981] - state: ‘created’
[11:01:35.981] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:35.983] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:35.983] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:35.983]   - Field: ‘label’
[11:01:35.983]   - Field: ‘local’
[11:01:35.983]   - Field: ‘owner’
[11:01:35.983]   - Field: ‘envir’
[11:01:35.983]   - Field: ‘workers’
[11:01:35.984]   - Field: ‘packages’
[11:01:35.984]   - Field: ‘gc’
[11:01:35.984]   - Field: ‘job’
[11:01:35.984]   - Field: ‘conditions’
[11:01:35.984]   - Field: ‘expr’
[11:01:35.984]   - Field: ‘uuid’
[11:01:35.984]   - Field: ‘seed’
[11:01:35.984]   - Field: ‘version’
[11:01:35.984]   - Field: ‘result’
[11:01:35.984]   - Field: ‘asynchronous’
[11:01:35.985]   - Field: ‘calls’
[11:01:35.985]   - Field: ‘globals’
[11:01:35.985]   - Field: ‘stdout’
[11:01:35.985]   - Field: ‘earlySignal’
[11:01:35.985]   - Field: ‘lazy’
[11:01:35.985]   - Field: ‘state’
[11:01:35.985] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:35.985] - Launch lazy future ...
[11:01:35.986] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[11:01:35.986] Packages needed by future strategies (n = 0): <none>
[11:01:35.986] {
[11:01:35.986]     {
[11:01:35.986]         {
[11:01:35.986]             ...future.startTime <- base::Sys.time()
[11:01:35.986]             {
[11:01:35.986]                 {
[11:01:35.986]                   {
[11:01:35.986]                     {
[11:01:35.986]                       {
[11:01:35.986]                         base::local({
[11:01:35.986]                           has_future <- base::requireNamespace("future", 
[11:01:35.986]                             quietly = TRUE)
[11:01:35.986]                           if (has_future) {
[11:01:35.986]                             ns <- base::getNamespace("future")
[11:01:35.986]                             version <- ns[[".package"]][["version"]]
[11:01:35.986]                             if (is.null(version)) 
[11:01:35.986]                               version <- utils::packageVersion("future")
[11:01:35.986]                           }
[11:01:35.986]                           else {
[11:01:35.986]                             version <- NULL
[11:01:35.986]                           }
[11:01:35.986]                           if (!has_future || version < "1.8.0") {
[11:01:35.986]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:35.986]                               "", base::R.version$version.string), 
[11:01:35.986]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:35.986]                                 base::R.version$platform, 8 * 
[11:01:35.986]                                   base::.Machine$sizeof.pointer), 
[11:01:35.986]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:35.986]                                 "release", "version")], collapse = " "), 
[11:01:35.986]                               hostname = base::Sys.info()[["nodename"]])
[11:01:35.986]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:35.986]                               info)
[11:01:35.986]                             info <- base::paste(info, collapse = "; ")
[11:01:35.986]                             if (!has_future) {
[11:01:35.986]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:35.986]                                 info)
[11:01:35.986]                             }
[11:01:35.986]                             else {
[11:01:35.986]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:35.986]                                 info, version)
[11:01:35.986]                             }
[11:01:35.986]                             base::stop(msg)
[11:01:35.986]                           }
[11:01:35.986]                         })
[11:01:35.986]                       }
[11:01:35.986]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:35.986]                       base::options(mc.cores = 1L)
[11:01:35.986]                     }
[11:01:35.986]                     base::local({
[11:01:35.986]                       for (pkg in c("stats", "datasets")) {
[11:01:35.986]                         base::loadNamespace(pkg)
[11:01:35.986]                         base::library(pkg, character.only = TRUE)
[11:01:35.986]                       }
[11:01:35.986]                     })
[11:01:35.986]                   }
[11:01:35.986]                   ...future.strategy.old <- future::plan("list")
[11:01:35.986]                   options(future.plan = NULL)
[11:01:35.986]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.986]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:35.986]                 }
[11:01:35.986]                 ...future.workdir <- getwd()
[11:01:35.986]             }
[11:01:35.986]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:35.986]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:35.986]         }
[11:01:35.986]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:35.986]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:35.986]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:35.986]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:35.986]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:35.986]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:35.986]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:35.986]             base::names(...future.oldOptions))
[11:01:35.986]     }
[11:01:35.986]     if (FALSE) {
[11:01:35.986]     }
[11:01:35.986]     else {
[11:01:35.986]         if (TRUE) {
[11:01:35.986]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:35.986]                 open = "w")
[11:01:35.986]         }
[11:01:35.986]         else {
[11:01:35.986]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:35.986]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:35.986]         }
[11:01:35.986]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:35.986]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:35.986]             base::sink(type = "output", split = FALSE)
[11:01:35.986]             base::close(...future.stdout)
[11:01:35.986]         }, add = TRUE)
[11:01:35.986]     }
[11:01:35.986]     ...future.frame <- base::sys.nframe()
[11:01:35.986]     ...future.conditions <- base::list()
[11:01:35.986]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:35.986]     if (FALSE) {
[11:01:35.986]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:35.986]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:35.986]     }
[11:01:35.986]     ...future.result <- base::tryCatch({
[11:01:35.986]         base::withCallingHandlers({
[11:01:35.986]             ...future.value <- base::withVisible(base::local({
[11:01:35.986]                 withCallingHandlers({
[11:01:35.986]                   {
[11:01:35.986]                     lm(dist ~ . + 0, data = cars)
[11:01:35.986]                   }
[11:01:35.986]                 }, immediateCondition = function(cond) {
[11:01:35.986]                   save_rds <- function (object, pathname, ...) 
[11:01:35.986]                   {
[11:01:35.986]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:35.986]                     if (file_test("-f", pathname_tmp)) {
[11:01:35.986]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.986]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:35.986]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.986]                         fi_tmp[["mtime"]])
[11:01:35.986]                     }
[11:01:35.986]                     tryCatch({
[11:01:35.986]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:35.986]                     }, error = function(ex) {
[11:01:35.986]                       msg <- conditionMessage(ex)
[11:01:35.986]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.986]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:35.986]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.986]                         fi_tmp[["mtime"]], msg)
[11:01:35.986]                       ex$message <- msg
[11:01:35.986]                       stop(ex)
[11:01:35.986]                     })
[11:01:35.986]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:35.986]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:35.986]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:35.986]                       fi_tmp <- file.info(pathname_tmp)
[11:01:35.986]                       fi <- file.info(pathname)
[11:01:35.986]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:35.986]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:35.986]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:35.986]                         fi[["size"]], fi[["mtime"]])
[11:01:35.986]                       stop(msg)
[11:01:35.986]                     }
[11:01:35.986]                     invisible(pathname)
[11:01:35.986]                   }
[11:01:35.986]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:35.986]                     rootPath = tempdir()) 
[11:01:35.986]                   {
[11:01:35.986]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:35.986]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:35.986]                       tmpdir = path, fileext = ".rds")
[11:01:35.986]                     save_rds(obj, file)
[11:01:35.986]                   }
[11:01:35.986]                   saveImmediateCondition(cond, path = "/tmp/Rtmpu6OqnW/.future/immediateConditions")
[11:01:35.986]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.986]                   {
[11:01:35.986]                     inherits <- base::inherits
[11:01:35.986]                     invokeRestart <- base::invokeRestart
[11:01:35.986]                     is.null <- base::is.null
[11:01:35.986]                     muffled <- FALSE
[11:01:35.986]                     if (inherits(cond, "message")) {
[11:01:35.986]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:35.986]                       if (muffled) 
[11:01:35.986]                         invokeRestart("muffleMessage")
[11:01:35.986]                     }
[11:01:35.986]                     else if (inherits(cond, "warning")) {
[11:01:35.986]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:35.986]                       if (muffled) 
[11:01:35.986]                         invokeRestart("muffleWarning")
[11:01:35.986]                     }
[11:01:35.986]                     else if (inherits(cond, "condition")) {
[11:01:35.986]                       if (!is.null(pattern)) {
[11:01:35.986]                         computeRestarts <- base::computeRestarts
[11:01:35.986]                         grepl <- base::grepl
[11:01:35.986]                         restarts <- computeRestarts(cond)
[11:01:35.986]                         for (restart in restarts) {
[11:01:35.986]                           name <- restart$name
[11:01:35.986]                           if (is.null(name)) 
[11:01:35.986]                             next
[11:01:35.986]                           if (!grepl(pattern, name)) 
[11:01:35.986]                             next
[11:01:35.986]                           invokeRestart(restart)
[11:01:35.986]                           muffled <- TRUE
[11:01:35.986]                           break
[11:01:35.986]                         }
[11:01:35.986]                       }
[11:01:35.986]                     }
[11:01:35.986]                     invisible(muffled)
[11:01:35.986]                   }
[11:01:35.986]                   muffleCondition(cond)
[11:01:35.986]                 })
[11:01:35.986]             }))
[11:01:35.986]             future::FutureResult(value = ...future.value$value, 
[11:01:35.986]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.986]                   ...future.rng), globalenv = if (FALSE) 
[11:01:35.986]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:35.986]                     ...future.globalenv.names))
[11:01:35.986]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:35.986]         }, condition = base::local({
[11:01:35.986]             c <- base::c
[11:01:35.986]             inherits <- base::inherits
[11:01:35.986]             invokeRestart <- base::invokeRestart
[11:01:35.986]             length <- base::length
[11:01:35.986]             list <- base::list
[11:01:35.986]             seq.int <- base::seq.int
[11:01:35.986]             signalCondition <- base::signalCondition
[11:01:35.986]             sys.calls <- base::sys.calls
[11:01:35.986]             `[[` <- base::`[[`
[11:01:35.986]             `+` <- base::`+`
[11:01:35.986]             `<<-` <- base::`<<-`
[11:01:35.986]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:35.986]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:35.986]                   3L)]
[11:01:35.986]             }
[11:01:35.986]             function(cond) {
[11:01:35.986]                 is_error <- inherits(cond, "error")
[11:01:35.986]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:35.986]                   NULL)
[11:01:35.986]                 if (is_error) {
[11:01:35.986]                   sessionInformation <- function() {
[11:01:35.986]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:35.986]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:35.986]                       search = base::search(), system = base::Sys.info())
[11:01:35.986]                   }
[11:01:35.986]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.986]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:35.986]                     cond$call), session = sessionInformation(), 
[11:01:35.986]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:35.986]                   signalCondition(cond)
[11:01:35.986]                 }
[11:01:35.986]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:35.986]                 "immediateCondition"))) {
[11:01:35.986]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:35.986]                   ...future.conditions[[length(...future.conditions) + 
[11:01:35.986]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:35.986]                   if (TRUE && !signal) {
[11:01:35.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.986]                     {
[11:01:35.986]                       inherits <- base::inherits
[11:01:35.986]                       invokeRestart <- base::invokeRestart
[11:01:35.986]                       is.null <- base::is.null
[11:01:35.986]                       muffled <- FALSE
[11:01:35.986]                       if (inherits(cond, "message")) {
[11:01:35.986]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.986]                         if (muffled) 
[11:01:35.986]                           invokeRestart("muffleMessage")
[11:01:35.986]                       }
[11:01:35.986]                       else if (inherits(cond, "warning")) {
[11:01:35.986]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.986]                         if (muffled) 
[11:01:35.986]                           invokeRestart("muffleWarning")
[11:01:35.986]                       }
[11:01:35.986]                       else if (inherits(cond, "condition")) {
[11:01:35.986]                         if (!is.null(pattern)) {
[11:01:35.986]                           computeRestarts <- base::computeRestarts
[11:01:35.986]                           grepl <- base::grepl
[11:01:35.986]                           restarts <- computeRestarts(cond)
[11:01:35.986]                           for (restart in restarts) {
[11:01:35.986]                             name <- restart$name
[11:01:35.986]                             if (is.null(name)) 
[11:01:35.986]                               next
[11:01:35.986]                             if (!grepl(pattern, name)) 
[11:01:35.986]                               next
[11:01:35.986]                             invokeRestart(restart)
[11:01:35.986]                             muffled <- TRUE
[11:01:35.986]                             break
[11:01:35.986]                           }
[11:01:35.986]                         }
[11:01:35.986]                       }
[11:01:35.986]                       invisible(muffled)
[11:01:35.986]                     }
[11:01:35.986]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.986]                   }
[11:01:35.986]                 }
[11:01:35.986]                 else {
[11:01:35.986]                   if (TRUE) {
[11:01:35.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:35.986]                     {
[11:01:35.986]                       inherits <- base::inherits
[11:01:35.986]                       invokeRestart <- base::invokeRestart
[11:01:35.986]                       is.null <- base::is.null
[11:01:35.986]                       muffled <- FALSE
[11:01:35.986]                       if (inherits(cond, "message")) {
[11:01:35.986]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:35.986]                         if (muffled) 
[11:01:35.986]                           invokeRestart("muffleMessage")
[11:01:35.986]                       }
[11:01:35.986]                       else if (inherits(cond, "warning")) {
[11:01:35.986]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:35.986]                         if (muffled) 
[11:01:35.986]                           invokeRestart("muffleWarning")
[11:01:35.986]                       }
[11:01:35.986]                       else if (inherits(cond, "condition")) {
[11:01:35.986]                         if (!is.null(pattern)) {
[11:01:35.986]                           computeRestarts <- base::computeRestarts
[11:01:35.986]                           grepl <- base::grepl
[11:01:35.986]                           restarts <- computeRestarts(cond)
[11:01:35.986]                           for (restart in restarts) {
[11:01:35.986]                             name <- restart$name
[11:01:35.986]                             if (is.null(name)) 
[11:01:35.986]                               next
[11:01:35.986]                             if (!grepl(pattern, name)) 
[11:01:35.986]                               next
[11:01:35.986]                             invokeRestart(restart)
[11:01:35.986]                             muffled <- TRUE
[11:01:35.986]                             break
[11:01:35.986]                           }
[11:01:35.986]                         }
[11:01:35.986]                       }
[11:01:35.986]                       invisible(muffled)
[11:01:35.986]                     }
[11:01:35.986]                     muffleCondition(cond, pattern = "^muffle")
[11:01:35.986]                   }
[11:01:35.986]                 }
[11:01:35.986]             }
[11:01:35.986]         }))
[11:01:35.986]     }, error = function(ex) {
[11:01:35.986]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:35.986]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:35.986]                 ...future.rng), started = ...future.startTime, 
[11:01:35.986]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:35.986]             version = "1.8"), class = "FutureResult")
[11:01:35.986]     }, finally = {
[11:01:35.986]         if (!identical(...future.workdir, getwd())) 
[11:01:35.986]             setwd(...future.workdir)
[11:01:35.986]         {
[11:01:35.986]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:35.986]                 ...future.oldOptions$nwarnings <- NULL
[11:01:35.986]             }
[11:01:35.986]             base::options(...future.oldOptions)
[11:01:35.986]             if (.Platform$OS.type == "windows") {
[11:01:35.986]                 old_names <- names(...future.oldEnvVars)
[11:01:35.986]                 envs <- base::Sys.getenv()
[11:01:35.986]                 names <- names(envs)
[11:01:35.986]                 common <- intersect(names, old_names)
[11:01:35.986]                 added <- setdiff(names, old_names)
[11:01:35.986]                 removed <- setdiff(old_names, names)
[11:01:35.986]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:35.986]                   envs[common]]
[11:01:35.986]                 NAMES <- toupper(changed)
[11:01:35.986]                 args <- list()
[11:01:35.986]                 for (kk in seq_along(NAMES)) {
[11:01:35.986]                   name <- changed[[kk]]
[11:01:35.986]                   NAME <- NAMES[[kk]]
[11:01:35.986]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.986]                     next
[11:01:35.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.986]                 }
[11:01:35.986]                 NAMES <- toupper(added)
[11:01:35.986]                 for (kk in seq_along(NAMES)) {
[11:01:35.986]                   name <- added[[kk]]
[11:01:35.986]                   NAME <- NAMES[[kk]]
[11:01:35.986]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.986]                     next
[11:01:35.986]                   args[[name]] <- ""
[11:01:35.986]                 }
[11:01:35.986]                 NAMES <- toupper(removed)
[11:01:35.986]                 for (kk in seq_along(NAMES)) {
[11:01:35.986]                   name <- removed[[kk]]
[11:01:35.986]                   NAME <- NAMES[[kk]]
[11:01:35.986]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:35.986]                     next
[11:01:35.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:35.986]                 }
[11:01:35.986]                 if (length(args) > 0) 
[11:01:35.986]                   base::do.call(base::Sys.setenv, args = args)
[11:01:35.986]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:35.986]             }
[11:01:35.986]             else {
[11:01:35.986]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:35.986]             }
[11:01:35.986]             {
[11:01:35.986]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:35.986]                   0L) {
[11:01:35.986]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:35.986]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:35.986]                   base::options(opts)
[11:01:35.986]                 }
[11:01:35.986]                 {
[11:01:35.986]                   {
[11:01:35.986]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:35.986]                     NULL
[11:01:35.986]                   }
[11:01:35.986]                   options(future.plan = NULL)
[11:01:35.986]                   if (is.na(NA_character_)) 
[11:01:35.986]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:35.986]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:35.986]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:35.986]                     .init = FALSE)
[11:01:35.986]                 }
[11:01:35.986]             }
[11:01:35.986]         }
[11:01:35.986]     })
[11:01:35.986]     if (TRUE) {
[11:01:35.986]         base::sink(type = "output", split = FALSE)
[11:01:35.986]         if (TRUE) {
[11:01:35.986]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:35.986]         }
[11:01:35.986]         else {
[11:01:35.986]             ...future.result["stdout"] <- base::list(NULL)
[11:01:35.986]         }
[11:01:35.986]         base::close(...future.stdout)
[11:01:35.986]         ...future.stdout <- NULL
[11:01:35.986]     }
[11:01:35.986]     ...future.result$conditions <- ...future.conditions
[11:01:35.986]     ...future.result$finished <- base::Sys.time()
[11:01:35.986]     ...future.result
[11:01:35.986] }
[11:01:35.989] requestCore(): workers = 2
[11:01:35.990] MulticoreFuture started
[11:01:35.991] - Launch lazy future ... done
[11:01:35.991] run() for ‘MulticoreFuture’ ... done
[11:01:35.991] result() for MulticoreFuture ...
[11:01:35.992] plan(): Setting new future strategy stack:
[11:01:35.992] List of future strategies:
[11:01:35.992] 1. sequential:
[11:01:35.992]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:35.992]    - tweaked: FALSE
[11:01:35.992]    - call: NULL
[11:01:35.993] plan(): nbrOfWorkers() = 1
[11:01:35.996] plan(): Setting new future strategy stack:
[11:01:35.996] List of future strategies:
[11:01:35.996] 1. multicore:
[11:01:35.996]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:35.996]    - tweaked: FALSE
[11:01:35.996]    - call: plan(strategy)
[11:01:35.999] plan(): nbrOfWorkers() = 2
[11:01:36.001] result() for MulticoreFuture ...
[11:01:36.001] result() for MulticoreFuture ... done
[11:01:36.001] result() for MulticoreFuture ... done
[11:01:36.001] result() for MulticoreFuture ...
[11:01:36.002] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[11:01:36.005] getGlobalsAndPackages() ...
[11:01:36.005] Searching for globals...
[11:01:36.007] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[11:01:36.007] Searching for globals ... DONE
[11:01:36.007] Resolving globals: FALSE
[11:01:36.008] 
[11:01:36.008] - packages: [2] ‘stats’, ‘datasets’
[11:01:36.008] getGlobalsAndPackages() ... DONE
[11:01:36.009] run() for ‘Future’ ...
[11:01:36.041] - state: ‘created’
[11:01:36.042] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:36.043] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:36.044] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:36.044]   - Field: ‘label’
[11:01:36.044]   - Field: ‘local’
[11:01:36.044]   - Field: ‘owner’
[11:01:36.044]   - Field: ‘envir’
[11:01:36.044]   - Field: ‘workers’
[11:01:36.044]   - Field: ‘packages’
[11:01:36.044]   - Field: ‘gc’
[11:01:36.044]   - Field: ‘job’
[11:01:36.044]   - Field: ‘conditions’
[11:01:36.045]   - Field: ‘expr’
[11:01:36.045]   - Field: ‘uuid’
[11:01:36.045]   - Field: ‘seed’
[11:01:36.045]   - Field: ‘version’
[11:01:36.045]   - Field: ‘result’
[11:01:36.045]   - Field: ‘asynchronous’
[11:01:36.045]   - Field: ‘calls’
[11:01:36.045]   - Field: ‘globals’
[11:01:36.045]   - Field: ‘stdout’
[11:01:36.045]   - Field: ‘earlySignal’
[11:01:36.045]   - Field: ‘lazy’
[11:01:36.046]   - Field: ‘state’
[11:01:36.046] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:36.046] - Launch lazy future ...
[11:01:36.046] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[11:01:36.046] Packages needed by future strategies (n = 0): <none>
[11:01:36.047] {
[11:01:36.047]     {
[11:01:36.047]         {
[11:01:36.047]             ...future.startTime <- base::Sys.time()
[11:01:36.047]             {
[11:01:36.047]                 {
[11:01:36.047]                   {
[11:01:36.047]                     {
[11:01:36.047]                       {
[11:01:36.047]                         base::local({
[11:01:36.047]                           has_future <- base::requireNamespace("future", 
[11:01:36.047]                             quietly = TRUE)
[11:01:36.047]                           if (has_future) {
[11:01:36.047]                             ns <- base::getNamespace("future")
[11:01:36.047]                             version <- ns[[".package"]][["version"]]
[11:01:36.047]                             if (is.null(version)) 
[11:01:36.047]                               version <- utils::packageVersion("future")
[11:01:36.047]                           }
[11:01:36.047]                           else {
[11:01:36.047]                             version <- NULL
[11:01:36.047]                           }
[11:01:36.047]                           if (!has_future || version < "1.8.0") {
[11:01:36.047]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:36.047]                               "", base::R.version$version.string), 
[11:01:36.047]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:36.047]                                 base::R.version$platform, 8 * 
[11:01:36.047]                                   base::.Machine$sizeof.pointer), 
[11:01:36.047]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:36.047]                                 "release", "version")], collapse = " "), 
[11:01:36.047]                               hostname = base::Sys.info()[["nodename"]])
[11:01:36.047]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:36.047]                               info)
[11:01:36.047]                             info <- base::paste(info, collapse = "; ")
[11:01:36.047]                             if (!has_future) {
[11:01:36.047]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:36.047]                                 info)
[11:01:36.047]                             }
[11:01:36.047]                             else {
[11:01:36.047]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:36.047]                                 info, version)
[11:01:36.047]                             }
[11:01:36.047]                             base::stop(msg)
[11:01:36.047]                           }
[11:01:36.047]                         })
[11:01:36.047]                       }
[11:01:36.047]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:36.047]                       base::options(mc.cores = 1L)
[11:01:36.047]                     }
[11:01:36.047]                     base::local({
[11:01:36.047]                       for (pkg in c("stats", "datasets")) {
[11:01:36.047]                         base::loadNamespace(pkg)
[11:01:36.047]                         base::library(pkg, character.only = TRUE)
[11:01:36.047]                       }
[11:01:36.047]                     })
[11:01:36.047]                   }
[11:01:36.047]                   ...future.strategy.old <- future::plan("list")
[11:01:36.047]                   options(future.plan = NULL)
[11:01:36.047]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:36.047]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:36.047]                 }
[11:01:36.047]                 ...future.workdir <- getwd()
[11:01:36.047]             }
[11:01:36.047]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:36.047]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:36.047]         }
[11:01:36.047]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:36.047]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:36.047]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:36.047]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:36.047]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:36.047]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:36.047]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:36.047]             base::names(...future.oldOptions))
[11:01:36.047]     }
[11:01:36.047]     if (FALSE) {
[11:01:36.047]     }
[11:01:36.047]     else {
[11:01:36.047]         if (TRUE) {
[11:01:36.047]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:36.047]                 open = "w")
[11:01:36.047]         }
[11:01:36.047]         else {
[11:01:36.047]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:36.047]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:36.047]         }
[11:01:36.047]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:36.047]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:36.047]             base::sink(type = "output", split = FALSE)
[11:01:36.047]             base::close(...future.stdout)
[11:01:36.047]         }, add = TRUE)
[11:01:36.047]     }
[11:01:36.047]     ...future.frame <- base::sys.nframe()
[11:01:36.047]     ...future.conditions <- base::list()
[11:01:36.047]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:36.047]     if (FALSE) {
[11:01:36.047]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:36.047]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:36.047]     }
[11:01:36.047]     ...future.result <- base::tryCatch({
[11:01:36.047]         base::withCallingHandlers({
[11:01:36.047]             ...future.value <- base::withVisible(base::local({
[11:01:36.047]                 withCallingHandlers({
[11:01:36.047]                   {
[11:01:36.047]                     lm(dist ~ speed + speed^2, data = cars)
[11:01:36.047]                   }
[11:01:36.047]                 }, immediateCondition = function(cond) {
[11:01:36.047]                   save_rds <- function (object, pathname, ...) 
[11:01:36.047]                   {
[11:01:36.047]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:36.047]                     if (file_test("-f", pathname_tmp)) {
[11:01:36.047]                       fi_tmp <- file.info(pathname_tmp)
[11:01:36.047]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:36.047]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:36.047]                         fi_tmp[["mtime"]])
[11:01:36.047]                     }
[11:01:36.047]                     tryCatch({
[11:01:36.047]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:36.047]                     }, error = function(ex) {
[11:01:36.047]                       msg <- conditionMessage(ex)
[11:01:36.047]                       fi_tmp <- file.info(pathname_tmp)
[11:01:36.047]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:36.047]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:36.047]                         fi_tmp[["mtime"]], msg)
[11:01:36.047]                       ex$message <- msg
[11:01:36.047]                       stop(ex)
[11:01:36.047]                     })
[11:01:36.047]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:36.047]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:36.047]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:36.047]                       fi_tmp <- file.info(pathname_tmp)
[11:01:36.047]                       fi <- file.info(pathname)
[11:01:36.047]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:36.047]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:36.047]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:36.047]                         fi[["size"]], fi[["mtime"]])
[11:01:36.047]                       stop(msg)
[11:01:36.047]                     }
[11:01:36.047]                     invisible(pathname)
[11:01:36.047]                   }
[11:01:36.047]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:36.047]                     rootPath = tempdir()) 
[11:01:36.047]                   {
[11:01:36.047]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:36.047]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:36.047]                       tmpdir = path, fileext = ".rds")
[11:01:36.047]                     save_rds(obj, file)
[11:01:36.047]                   }
[11:01:36.047]                   saveImmediateCondition(cond, path = "/tmp/Rtmpu6OqnW/.future/immediateConditions")
[11:01:36.047]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.047]                   {
[11:01:36.047]                     inherits <- base::inherits
[11:01:36.047]                     invokeRestart <- base::invokeRestart
[11:01:36.047]                     is.null <- base::is.null
[11:01:36.047]                     muffled <- FALSE
[11:01:36.047]                     if (inherits(cond, "message")) {
[11:01:36.047]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:36.047]                       if (muffled) 
[11:01:36.047]                         invokeRestart("muffleMessage")
[11:01:36.047]                     }
[11:01:36.047]                     else if (inherits(cond, "warning")) {
[11:01:36.047]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:36.047]                       if (muffled) 
[11:01:36.047]                         invokeRestart("muffleWarning")
[11:01:36.047]                     }
[11:01:36.047]                     else if (inherits(cond, "condition")) {
[11:01:36.047]                       if (!is.null(pattern)) {
[11:01:36.047]                         computeRestarts <- base::computeRestarts
[11:01:36.047]                         grepl <- base::grepl
[11:01:36.047]                         restarts <- computeRestarts(cond)
[11:01:36.047]                         for (restart in restarts) {
[11:01:36.047]                           name <- restart$name
[11:01:36.047]                           if (is.null(name)) 
[11:01:36.047]                             next
[11:01:36.047]                           if (!grepl(pattern, name)) 
[11:01:36.047]                             next
[11:01:36.047]                           invokeRestart(restart)
[11:01:36.047]                           muffled <- TRUE
[11:01:36.047]                           break
[11:01:36.047]                         }
[11:01:36.047]                       }
[11:01:36.047]                     }
[11:01:36.047]                     invisible(muffled)
[11:01:36.047]                   }
[11:01:36.047]                   muffleCondition(cond)
[11:01:36.047]                 })
[11:01:36.047]             }))
[11:01:36.047]             future::FutureResult(value = ...future.value$value, 
[11:01:36.047]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:36.047]                   ...future.rng), globalenv = if (FALSE) 
[11:01:36.047]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:36.047]                     ...future.globalenv.names))
[11:01:36.047]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:36.047]         }, condition = base::local({
[11:01:36.047]             c <- base::c
[11:01:36.047]             inherits <- base::inherits
[11:01:36.047]             invokeRestart <- base::invokeRestart
[11:01:36.047]             length <- base::length
[11:01:36.047]             list <- base::list
[11:01:36.047]             seq.int <- base::seq.int
[11:01:36.047]             signalCondition <- base::signalCondition
[11:01:36.047]             sys.calls <- base::sys.calls
[11:01:36.047]             `[[` <- base::`[[`
[11:01:36.047]             `+` <- base::`+`
[11:01:36.047]             `<<-` <- base::`<<-`
[11:01:36.047]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:36.047]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:36.047]                   3L)]
[11:01:36.047]             }
[11:01:36.047]             function(cond) {
[11:01:36.047]                 is_error <- inherits(cond, "error")
[11:01:36.047]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:36.047]                   NULL)
[11:01:36.047]                 if (is_error) {
[11:01:36.047]                   sessionInformation <- function() {
[11:01:36.047]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:36.047]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:36.047]                       search = base::search(), system = base::Sys.info())
[11:01:36.047]                   }
[11:01:36.047]                   ...future.conditions[[length(...future.conditions) + 
[11:01:36.047]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:36.047]                     cond$call), session = sessionInformation(), 
[11:01:36.047]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:36.047]                   signalCondition(cond)
[11:01:36.047]                 }
[11:01:36.047]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:36.047]                 "immediateCondition"))) {
[11:01:36.047]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:36.047]                   ...future.conditions[[length(...future.conditions) + 
[11:01:36.047]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:36.047]                   if (TRUE && !signal) {
[11:01:36.047]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.047]                     {
[11:01:36.047]                       inherits <- base::inherits
[11:01:36.047]                       invokeRestart <- base::invokeRestart
[11:01:36.047]                       is.null <- base::is.null
[11:01:36.047]                       muffled <- FALSE
[11:01:36.047]                       if (inherits(cond, "message")) {
[11:01:36.047]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:36.047]                         if (muffled) 
[11:01:36.047]                           invokeRestart("muffleMessage")
[11:01:36.047]                       }
[11:01:36.047]                       else if (inherits(cond, "warning")) {
[11:01:36.047]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:36.047]                         if (muffled) 
[11:01:36.047]                           invokeRestart("muffleWarning")
[11:01:36.047]                       }
[11:01:36.047]                       else if (inherits(cond, "condition")) {
[11:01:36.047]                         if (!is.null(pattern)) {
[11:01:36.047]                           computeRestarts <- base::computeRestarts
[11:01:36.047]                           grepl <- base::grepl
[11:01:36.047]                           restarts <- computeRestarts(cond)
[11:01:36.047]                           for (restart in restarts) {
[11:01:36.047]                             name <- restart$name
[11:01:36.047]                             if (is.null(name)) 
[11:01:36.047]                               next
[11:01:36.047]                             if (!grepl(pattern, name)) 
[11:01:36.047]                               next
[11:01:36.047]                             invokeRestart(restart)
[11:01:36.047]                             muffled <- TRUE
[11:01:36.047]                             break
[11:01:36.047]                           }
[11:01:36.047]                         }
[11:01:36.047]                       }
[11:01:36.047]                       invisible(muffled)
[11:01:36.047]                     }
[11:01:36.047]                     muffleCondition(cond, pattern = "^muffle")
[11:01:36.047]                   }
[11:01:36.047]                 }
[11:01:36.047]                 else {
[11:01:36.047]                   if (TRUE) {
[11:01:36.047]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.047]                     {
[11:01:36.047]                       inherits <- base::inherits
[11:01:36.047]                       invokeRestart <- base::invokeRestart
[11:01:36.047]                       is.null <- base::is.null
[11:01:36.047]                       muffled <- FALSE
[11:01:36.047]                       if (inherits(cond, "message")) {
[11:01:36.047]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:36.047]                         if (muffled) 
[11:01:36.047]                           invokeRestart("muffleMessage")
[11:01:36.047]                       }
[11:01:36.047]                       else if (inherits(cond, "warning")) {
[11:01:36.047]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:36.047]                         if (muffled) 
[11:01:36.047]                           invokeRestart("muffleWarning")
[11:01:36.047]                       }
[11:01:36.047]                       else if (inherits(cond, "condition")) {
[11:01:36.047]                         if (!is.null(pattern)) {
[11:01:36.047]                           computeRestarts <- base::computeRestarts
[11:01:36.047]                           grepl <- base::grepl
[11:01:36.047]                           restarts <- computeRestarts(cond)
[11:01:36.047]                           for (restart in restarts) {
[11:01:36.047]                             name <- restart$name
[11:01:36.047]                             if (is.null(name)) 
[11:01:36.047]                               next
[11:01:36.047]                             if (!grepl(pattern, name)) 
[11:01:36.047]                               next
[11:01:36.047]                             invokeRestart(restart)
[11:01:36.047]                             muffled <- TRUE
[11:01:36.047]                             break
[11:01:36.047]                           }
[11:01:36.047]                         }
[11:01:36.047]                       }
[11:01:36.047]                       invisible(muffled)
[11:01:36.047]                     }
[11:01:36.047]                     muffleCondition(cond, pattern = "^muffle")
[11:01:36.047]                   }
[11:01:36.047]                 }
[11:01:36.047]             }
[11:01:36.047]         }))
[11:01:36.047]     }, error = function(ex) {
[11:01:36.047]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:36.047]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:36.047]                 ...future.rng), started = ...future.startTime, 
[11:01:36.047]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:36.047]             version = "1.8"), class = "FutureResult")
[11:01:36.047]     }, finally = {
[11:01:36.047]         if (!identical(...future.workdir, getwd())) 
[11:01:36.047]             setwd(...future.workdir)
[11:01:36.047]         {
[11:01:36.047]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:36.047]                 ...future.oldOptions$nwarnings <- NULL
[11:01:36.047]             }
[11:01:36.047]             base::options(...future.oldOptions)
[11:01:36.047]             if (.Platform$OS.type == "windows") {
[11:01:36.047]                 old_names <- names(...future.oldEnvVars)
[11:01:36.047]                 envs <- base::Sys.getenv()
[11:01:36.047]                 names <- names(envs)
[11:01:36.047]                 common <- intersect(names, old_names)
[11:01:36.047]                 added <- setdiff(names, old_names)
[11:01:36.047]                 removed <- setdiff(old_names, names)
[11:01:36.047]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:36.047]                   envs[common]]
[11:01:36.047]                 NAMES <- toupper(changed)
[11:01:36.047]                 args <- list()
[11:01:36.047]                 for (kk in seq_along(NAMES)) {
[11:01:36.047]                   name <- changed[[kk]]
[11:01:36.047]                   NAME <- NAMES[[kk]]
[11:01:36.047]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.047]                     next
[11:01:36.047]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:36.047]                 }
[11:01:36.047]                 NAMES <- toupper(added)
[11:01:36.047]                 for (kk in seq_along(NAMES)) {
[11:01:36.047]                   name <- added[[kk]]
[11:01:36.047]                   NAME <- NAMES[[kk]]
[11:01:36.047]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.047]                     next
[11:01:36.047]                   args[[name]] <- ""
[11:01:36.047]                 }
[11:01:36.047]                 NAMES <- toupper(removed)
[11:01:36.047]                 for (kk in seq_along(NAMES)) {
[11:01:36.047]                   name <- removed[[kk]]
[11:01:36.047]                   NAME <- NAMES[[kk]]
[11:01:36.047]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.047]                     next
[11:01:36.047]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:36.047]                 }
[11:01:36.047]                 if (length(args) > 0) 
[11:01:36.047]                   base::do.call(base::Sys.setenv, args = args)
[11:01:36.047]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:36.047]             }
[11:01:36.047]             else {
[11:01:36.047]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:36.047]             }
[11:01:36.047]             {
[11:01:36.047]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:36.047]                   0L) {
[11:01:36.047]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:36.047]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:36.047]                   base::options(opts)
[11:01:36.047]                 }
[11:01:36.047]                 {
[11:01:36.047]                   {
[11:01:36.047]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:36.047]                     NULL
[11:01:36.047]                   }
[11:01:36.047]                   options(future.plan = NULL)
[11:01:36.047]                   if (is.na(NA_character_)) 
[11:01:36.047]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:36.047]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:36.047]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:36.047]                     .init = FALSE)
[11:01:36.047]                 }
[11:01:36.047]             }
[11:01:36.047]         }
[11:01:36.047]     })
[11:01:36.047]     if (TRUE) {
[11:01:36.047]         base::sink(type = "output", split = FALSE)
[11:01:36.047]         if (TRUE) {
[11:01:36.047]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:36.047]         }
[11:01:36.047]         else {
[11:01:36.047]             ...future.result["stdout"] <- base::list(NULL)
[11:01:36.047]         }
[11:01:36.047]         base::close(...future.stdout)
[11:01:36.047]         ...future.stdout <- NULL
[11:01:36.047]     }
[11:01:36.047]     ...future.result$conditions <- ...future.conditions
[11:01:36.047]     ...future.result$finished <- base::Sys.time()
[11:01:36.047]     ...future.result
[11:01:36.047] }
[11:01:36.049] requestCore(): workers = 2
[11:01:36.051] MulticoreFuture started
[11:01:36.051] - Launch lazy future ... done
[11:01:36.052] run() for ‘MulticoreFuture’ ... done
[11:01:36.052] result() for MulticoreFuture ...
[11:01:36.052] plan(): Setting new future strategy stack:
[11:01:36.053] List of future strategies:
[11:01:36.053] 1. sequential:
[11:01:36.053]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:36.053]    - tweaked: FALSE
[11:01:36.053]    - call: NULL
[11:01:36.054] plan(): nbrOfWorkers() = 1
[11:01:36.058] plan(): Setting new future strategy stack:
[11:01:36.058] List of future strategies:
[11:01:36.058] 1. multicore:
[11:01:36.058]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:36.058]    - tweaked: FALSE
[11:01:36.058]    - call: plan(strategy)
[11:01:36.061] plan(): nbrOfWorkers() = 2
[11:01:36.063] result() for MulticoreFuture ...
[11:01:36.063] result() for MulticoreFuture ... done
[11:01:36.063] result() for MulticoreFuture ... done
[11:01:36.064] result() for MulticoreFuture ...
[11:01:36.064] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[11:01:36.067] getGlobalsAndPackages() ...
[11:01:36.068] Searching for globals...
[11:01:36.070] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[11:01:36.070] Searching for globals ... DONE
[11:01:36.071] Resolving globals: FALSE
[11:01:36.071] 
[11:01:36.071] - packages: [2] ‘stats’, ‘datasets’
[11:01:36.072] getGlobalsAndPackages() ... DONE
[11:01:36.072] run() for ‘Future’ ...
[11:01:36.072] - state: ‘created’
[11:01:36.072] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:36.074] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:36.074] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:36.074]   - Field: ‘label’
[11:01:36.075]   - Field: ‘local’
[11:01:36.075]   - Field: ‘owner’
[11:01:36.075]   - Field: ‘envir’
[11:01:36.075]   - Field: ‘workers’
[11:01:36.075]   - Field: ‘packages’
[11:01:36.075]   - Field: ‘gc’
[11:01:36.075]   - Field: ‘job’
[11:01:36.075]   - Field: ‘conditions’
[11:01:36.075]   - Field: ‘expr’
[11:01:36.076]   - Field: ‘uuid’
[11:01:36.076]   - Field: ‘seed’
[11:01:36.076]   - Field: ‘version’
[11:01:36.076]   - Field: ‘result’
[11:01:36.076]   - Field: ‘asynchronous’
[11:01:36.076]   - Field: ‘calls’
[11:01:36.076]   - Field: ‘globals’
[11:01:36.076]   - Field: ‘stdout’
[11:01:36.076]   - Field: ‘earlySignal’
[11:01:36.077]   - Field: ‘lazy’
[11:01:36.077]   - Field: ‘state’
[11:01:36.077] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:36.077] - Launch lazy future ...
[11:01:36.077] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[11:01:36.077] Packages needed by future strategies (n = 0): <none>
[11:01:36.078] {
[11:01:36.078]     {
[11:01:36.078]         {
[11:01:36.078]             ...future.startTime <- base::Sys.time()
[11:01:36.078]             {
[11:01:36.078]                 {
[11:01:36.078]                   {
[11:01:36.078]                     {
[11:01:36.078]                       {
[11:01:36.078]                         base::local({
[11:01:36.078]                           has_future <- base::requireNamespace("future", 
[11:01:36.078]                             quietly = TRUE)
[11:01:36.078]                           if (has_future) {
[11:01:36.078]                             ns <- base::getNamespace("future")
[11:01:36.078]                             version <- ns[[".package"]][["version"]]
[11:01:36.078]                             if (is.null(version)) 
[11:01:36.078]                               version <- utils::packageVersion("future")
[11:01:36.078]                           }
[11:01:36.078]                           else {
[11:01:36.078]                             version <- NULL
[11:01:36.078]                           }
[11:01:36.078]                           if (!has_future || version < "1.8.0") {
[11:01:36.078]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:36.078]                               "", base::R.version$version.string), 
[11:01:36.078]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:36.078]                                 base::R.version$platform, 8 * 
[11:01:36.078]                                   base::.Machine$sizeof.pointer), 
[11:01:36.078]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:36.078]                                 "release", "version")], collapse = " "), 
[11:01:36.078]                               hostname = base::Sys.info()[["nodename"]])
[11:01:36.078]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:36.078]                               info)
[11:01:36.078]                             info <- base::paste(info, collapse = "; ")
[11:01:36.078]                             if (!has_future) {
[11:01:36.078]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:36.078]                                 info)
[11:01:36.078]                             }
[11:01:36.078]                             else {
[11:01:36.078]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:36.078]                                 info, version)
[11:01:36.078]                             }
[11:01:36.078]                             base::stop(msg)
[11:01:36.078]                           }
[11:01:36.078]                         })
[11:01:36.078]                       }
[11:01:36.078]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:36.078]                       base::options(mc.cores = 1L)
[11:01:36.078]                     }
[11:01:36.078]                     base::local({
[11:01:36.078]                       for (pkg in c("stats", "datasets")) {
[11:01:36.078]                         base::loadNamespace(pkg)
[11:01:36.078]                         base::library(pkg, character.only = TRUE)
[11:01:36.078]                       }
[11:01:36.078]                     })
[11:01:36.078]                   }
[11:01:36.078]                   ...future.strategy.old <- future::plan("list")
[11:01:36.078]                   options(future.plan = NULL)
[11:01:36.078]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:36.078]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:36.078]                 }
[11:01:36.078]                 ...future.workdir <- getwd()
[11:01:36.078]             }
[11:01:36.078]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:36.078]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:36.078]         }
[11:01:36.078]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:36.078]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:36.078]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:36.078]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:36.078]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:36.078]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:36.078]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:36.078]             base::names(...future.oldOptions))
[11:01:36.078]     }
[11:01:36.078]     if (FALSE) {
[11:01:36.078]     }
[11:01:36.078]     else {
[11:01:36.078]         if (TRUE) {
[11:01:36.078]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:36.078]                 open = "w")
[11:01:36.078]         }
[11:01:36.078]         else {
[11:01:36.078]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:36.078]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:36.078]         }
[11:01:36.078]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:36.078]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:36.078]             base::sink(type = "output", split = FALSE)
[11:01:36.078]             base::close(...future.stdout)
[11:01:36.078]         }, add = TRUE)
[11:01:36.078]     }
[11:01:36.078]     ...future.frame <- base::sys.nframe()
[11:01:36.078]     ...future.conditions <- base::list()
[11:01:36.078]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:36.078]     if (FALSE) {
[11:01:36.078]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:36.078]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:36.078]     }
[11:01:36.078]     ...future.result <- base::tryCatch({
[11:01:36.078]         base::withCallingHandlers({
[11:01:36.078]             ...future.value <- base::withVisible(base::local({
[11:01:36.078]                 withCallingHandlers({
[11:01:36.078]                   {
[11:01:36.078]                     lm(dist ~ speed + I(speed^2), data = cars)
[11:01:36.078]                   }
[11:01:36.078]                 }, immediateCondition = function(cond) {
[11:01:36.078]                   save_rds <- function (object, pathname, ...) 
[11:01:36.078]                   {
[11:01:36.078]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:36.078]                     if (file_test("-f", pathname_tmp)) {
[11:01:36.078]                       fi_tmp <- file.info(pathname_tmp)
[11:01:36.078]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:36.078]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:36.078]                         fi_tmp[["mtime"]])
[11:01:36.078]                     }
[11:01:36.078]                     tryCatch({
[11:01:36.078]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:36.078]                     }, error = function(ex) {
[11:01:36.078]                       msg <- conditionMessage(ex)
[11:01:36.078]                       fi_tmp <- file.info(pathname_tmp)
[11:01:36.078]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:36.078]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:36.078]                         fi_tmp[["mtime"]], msg)
[11:01:36.078]                       ex$message <- msg
[11:01:36.078]                       stop(ex)
[11:01:36.078]                     })
[11:01:36.078]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:36.078]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:36.078]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:36.078]                       fi_tmp <- file.info(pathname_tmp)
[11:01:36.078]                       fi <- file.info(pathname)
[11:01:36.078]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:36.078]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:36.078]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:36.078]                         fi[["size"]], fi[["mtime"]])
[11:01:36.078]                       stop(msg)
[11:01:36.078]                     }
[11:01:36.078]                     invisible(pathname)
[11:01:36.078]                   }
[11:01:36.078]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:36.078]                     rootPath = tempdir()) 
[11:01:36.078]                   {
[11:01:36.078]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:36.078]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:36.078]                       tmpdir = path, fileext = ".rds")
[11:01:36.078]                     save_rds(obj, file)
[11:01:36.078]                   }
[11:01:36.078]                   saveImmediateCondition(cond, path = "/tmp/Rtmpu6OqnW/.future/immediateConditions")
[11:01:36.078]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.078]                   {
[11:01:36.078]                     inherits <- base::inherits
[11:01:36.078]                     invokeRestart <- base::invokeRestart
[11:01:36.078]                     is.null <- base::is.null
[11:01:36.078]                     muffled <- FALSE
[11:01:36.078]                     if (inherits(cond, "message")) {
[11:01:36.078]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:36.078]                       if (muffled) 
[11:01:36.078]                         invokeRestart("muffleMessage")
[11:01:36.078]                     }
[11:01:36.078]                     else if (inherits(cond, "warning")) {
[11:01:36.078]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:36.078]                       if (muffled) 
[11:01:36.078]                         invokeRestart("muffleWarning")
[11:01:36.078]                     }
[11:01:36.078]                     else if (inherits(cond, "condition")) {
[11:01:36.078]                       if (!is.null(pattern)) {
[11:01:36.078]                         computeRestarts <- base::computeRestarts
[11:01:36.078]                         grepl <- base::grepl
[11:01:36.078]                         restarts <- computeRestarts(cond)
[11:01:36.078]                         for (restart in restarts) {
[11:01:36.078]                           name <- restart$name
[11:01:36.078]                           if (is.null(name)) 
[11:01:36.078]                             next
[11:01:36.078]                           if (!grepl(pattern, name)) 
[11:01:36.078]                             next
[11:01:36.078]                           invokeRestart(restart)
[11:01:36.078]                           muffled <- TRUE
[11:01:36.078]                           break
[11:01:36.078]                         }
[11:01:36.078]                       }
[11:01:36.078]                     }
[11:01:36.078]                     invisible(muffled)
[11:01:36.078]                   }
[11:01:36.078]                   muffleCondition(cond)
[11:01:36.078]                 })
[11:01:36.078]             }))
[11:01:36.078]             future::FutureResult(value = ...future.value$value, 
[11:01:36.078]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:36.078]                   ...future.rng), globalenv = if (FALSE) 
[11:01:36.078]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:36.078]                     ...future.globalenv.names))
[11:01:36.078]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:36.078]         }, condition = base::local({
[11:01:36.078]             c <- base::c
[11:01:36.078]             inherits <- base::inherits
[11:01:36.078]             invokeRestart <- base::invokeRestart
[11:01:36.078]             length <- base::length
[11:01:36.078]             list <- base::list
[11:01:36.078]             seq.int <- base::seq.int
[11:01:36.078]             signalCondition <- base::signalCondition
[11:01:36.078]             sys.calls <- base::sys.calls
[11:01:36.078]             `[[` <- base::`[[`
[11:01:36.078]             `+` <- base::`+`
[11:01:36.078]             `<<-` <- base::`<<-`
[11:01:36.078]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:36.078]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:36.078]                   3L)]
[11:01:36.078]             }
[11:01:36.078]             function(cond) {
[11:01:36.078]                 is_error <- inherits(cond, "error")
[11:01:36.078]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:36.078]                   NULL)
[11:01:36.078]                 if (is_error) {
[11:01:36.078]                   sessionInformation <- function() {
[11:01:36.078]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:36.078]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:36.078]                       search = base::search(), system = base::Sys.info())
[11:01:36.078]                   }
[11:01:36.078]                   ...future.conditions[[length(...future.conditions) + 
[11:01:36.078]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:36.078]                     cond$call), session = sessionInformation(), 
[11:01:36.078]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:36.078]                   signalCondition(cond)
[11:01:36.078]                 }
[11:01:36.078]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:36.078]                 "immediateCondition"))) {
[11:01:36.078]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:36.078]                   ...future.conditions[[length(...future.conditions) + 
[11:01:36.078]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:36.078]                   if (TRUE && !signal) {
[11:01:36.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.078]                     {
[11:01:36.078]                       inherits <- base::inherits
[11:01:36.078]                       invokeRestart <- base::invokeRestart
[11:01:36.078]                       is.null <- base::is.null
[11:01:36.078]                       muffled <- FALSE
[11:01:36.078]                       if (inherits(cond, "message")) {
[11:01:36.078]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:36.078]                         if (muffled) 
[11:01:36.078]                           invokeRestart("muffleMessage")
[11:01:36.078]                       }
[11:01:36.078]                       else if (inherits(cond, "warning")) {
[11:01:36.078]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:36.078]                         if (muffled) 
[11:01:36.078]                           invokeRestart("muffleWarning")
[11:01:36.078]                       }
[11:01:36.078]                       else if (inherits(cond, "condition")) {
[11:01:36.078]                         if (!is.null(pattern)) {
[11:01:36.078]                           computeRestarts <- base::computeRestarts
[11:01:36.078]                           grepl <- base::grepl
[11:01:36.078]                           restarts <- computeRestarts(cond)
[11:01:36.078]                           for (restart in restarts) {
[11:01:36.078]                             name <- restart$name
[11:01:36.078]                             if (is.null(name)) 
[11:01:36.078]                               next
[11:01:36.078]                             if (!grepl(pattern, name)) 
[11:01:36.078]                               next
[11:01:36.078]                             invokeRestart(restart)
[11:01:36.078]                             muffled <- TRUE
[11:01:36.078]                             break
[11:01:36.078]                           }
[11:01:36.078]                         }
[11:01:36.078]                       }
[11:01:36.078]                       invisible(muffled)
[11:01:36.078]                     }
[11:01:36.078]                     muffleCondition(cond, pattern = "^muffle")
[11:01:36.078]                   }
[11:01:36.078]                 }
[11:01:36.078]                 else {
[11:01:36.078]                   if (TRUE) {
[11:01:36.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.078]                     {
[11:01:36.078]                       inherits <- base::inherits
[11:01:36.078]                       invokeRestart <- base::invokeRestart
[11:01:36.078]                       is.null <- base::is.null
[11:01:36.078]                       muffled <- FALSE
[11:01:36.078]                       if (inherits(cond, "message")) {
[11:01:36.078]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:36.078]                         if (muffled) 
[11:01:36.078]                           invokeRestart("muffleMessage")
[11:01:36.078]                       }
[11:01:36.078]                       else if (inherits(cond, "warning")) {
[11:01:36.078]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:36.078]                         if (muffled) 
[11:01:36.078]                           invokeRestart("muffleWarning")
[11:01:36.078]                       }
[11:01:36.078]                       else if (inherits(cond, "condition")) {
[11:01:36.078]                         if (!is.null(pattern)) {
[11:01:36.078]                           computeRestarts <- base::computeRestarts
[11:01:36.078]                           grepl <- base::grepl
[11:01:36.078]                           restarts <- computeRestarts(cond)
[11:01:36.078]                           for (restart in restarts) {
[11:01:36.078]                             name <- restart$name
[11:01:36.078]                             if (is.null(name)) 
[11:01:36.078]                               next
[11:01:36.078]                             if (!grepl(pattern, name)) 
[11:01:36.078]                               next
[11:01:36.078]                             invokeRestart(restart)
[11:01:36.078]                             muffled <- TRUE
[11:01:36.078]                             break
[11:01:36.078]                           }
[11:01:36.078]                         }
[11:01:36.078]                       }
[11:01:36.078]                       invisible(muffled)
[11:01:36.078]                     }
[11:01:36.078]                     muffleCondition(cond, pattern = "^muffle")
[11:01:36.078]                   }
[11:01:36.078]                 }
[11:01:36.078]             }
[11:01:36.078]         }))
[11:01:36.078]     }, error = function(ex) {
[11:01:36.078]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:36.078]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:36.078]                 ...future.rng), started = ...future.startTime, 
[11:01:36.078]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:36.078]             version = "1.8"), class = "FutureResult")
[11:01:36.078]     }, finally = {
[11:01:36.078]         if (!identical(...future.workdir, getwd())) 
[11:01:36.078]             setwd(...future.workdir)
[11:01:36.078]         {
[11:01:36.078]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:36.078]                 ...future.oldOptions$nwarnings <- NULL
[11:01:36.078]             }
[11:01:36.078]             base::options(...future.oldOptions)
[11:01:36.078]             if (.Platform$OS.type == "windows") {
[11:01:36.078]                 old_names <- names(...future.oldEnvVars)
[11:01:36.078]                 envs <- base::Sys.getenv()
[11:01:36.078]                 names <- names(envs)
[11:01:36.078]                 common <- intersect(names, old_names)
[11:01:36.078]                 added <- setdiff(names, old_names)
[11:01:36.078]                 removed <- setdiff(old_names, names)
[11:01:36.078]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:36.078]                   envs[common]]
[11:01:36.078]                 NAMES <- toupper(changed)
[11:01:36.078]                 args <- list()
[11:01:36.078]                 for (kk in seq_along(NAMES)) {
[11:01:36.078]                   name <- changed[[kk]]
[11:01:36.078]                   NAME <- NAMES[[kk]]
[11:01:36.078]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.078]                     next
[11:01:36.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:36.078]                 }
[11:01:36.078]                 NAMES <- toupper(added)
[11:01:36.078]                 for (kk in seq_along(NAMES)) {
[11:01:36.078]                   name <- added[[kk]]
[11:01:36.078]                   NAME <- NAMES[[kk]]
[11:01:36.078]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.078]                     next
[11:01:36.078]                   args[[name]] <- ""
[11:01:36.078]                 }
[11:01:36.078]                 NAMES <- toupper(removed)
[11:01:36.078]                 for (kk in seq_along(NAMES)) {
[11:01:36.078]                   name <- removed[[kk]]
[11:01:36.078]                   NAME <- NAMES[[kk]]
[11:01:36.078]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.078]                     next
[11:01:36.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:36.078]                 }
[11:01:36.078]                 if (length(args) > 0) 
[11:01:36.078]                   base::do.call(base::Sys.setenv, args = args)
[11:01:36.078]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:36.078]             }
[11:01:36.078]             else {
[11:01:36.078]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:36.078]             }
[11:01:36.078]             {
[11:01:36.078]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:36.078]                   0L) {
[11:01:36.078]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:36.078]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:36.078]                   base::options(opts)
[11:01:36.078]                 }
[11:01:36.078]                 {
[11:01:36.078]                   {
[11:01:36.078]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:36.078]                     NULL
[11:01:36.078]                   }
[11:01:36.078]                   options(future.plan = NULL)
[11:01:36.078]                   if (is.na(NA_character_)) 
[11:01:36.078]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:36.078]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:36.078]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:36.078]                     .init = FALSE)
[11:01:36.078]                 }
[11:01:36.078]             }
[11:01:36.078]         }
[11:01:36.078]     })
[11:01:36.078]     if (TRUE) {
[11:01:36.078]         base::sink(type = "output", split = FALSE)
[11:01:36.078]         if (TRUE) {
[11:01:36.078]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:36.078]         }
[11:01:36.078]         else {
[11:01:36.078]             ...future.result["stdout"] <- base::list(NULL)
[11:01:36.078]         }
[11:01:36.078]         base::close(...future.stdout)
[11:01:36.078]         ...future.stdout <- NULL
[11:01:36.078]     }
[11:01:36.078]     ...future.result$conditions <- ...future.conditions
[11:01:36.078]     ...future.result$finished <- base::Sys.time()
[11:01:36.078]     ...future.result
[11:01:36.078] }
[11:01:36.081] requestCore(): workers = 2
[11:01:36.082] MulticoreFuture started
[11:01:36.083] - Launch lazy future ... done
[11:01:36.083] run() for ‘MulticoreFuture’ ... done
[11:01:36.083] result() for MulticoreFuture ...
[11:01:36.084] plan(): Setting new future strategy stack:
[11:01:36.084] List of future strategies:
[11:01:36.084] 1. sequential:
[11:01:36.084]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:36.084]    - tweaked: FALSE
[11:01:36.084]    - call: NULL
[11:01:36.085] plan(): nbrOfWorkers() = 1
[11:01:36.088] plan(): Setting new future strategy stack:
[11:01:36.089] List of future strategies:
[11:01:36.089] 1. multicore:
[11:01:36.089]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:36.089]    - tweaked: FALSE
[11:01:36.089]    - call: plan(strategy)
[11:01:36.092] plan(): nbrOfWorkers() = 2
[11:01:36.094] result() for MulticoreFuture ...
[11:01:36.094] result() for MulticoreFuture ... done
[11:01:36.094] result() for MulticoreFuture ... done
[11:01:36.094] result() for MulticoreFuture ...
[11:01:36.095] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[11:01:36.098] getGlobalsAndPackages() ...
[11:01:36.099] Searching for globals...
[11:01:36.104] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[11:01:36.104] Searching for globals ... DONE
[11:01:36.104] Resolving globals: FALSE
[11:01:36.105] 
[11:01:36.105] - packages: [2] ‘stats’, ‘datasets’
[11:01:36.105] getGlobalsAndPackages() ... DONE
[11:01:36.105] run() for ‘Future’ ...
[11:01:36.106] - state: ‘created’
[11:01:36.106] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:36.108] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:36.108] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:36.108]   - Field: ‘label’
[11:01:36.108]   - Field: ‘local’
[11:01:36.108]   - Field: ‘owner’
[11:01:36.108]   - Field: ‘envir’
[11:01:36.108]   - Field: ‘workers’
[11:01:36.109]   - Field: ‘packages’
[11:01:36.109]   - Field: ‘gc’
[11:01:36.109]   - Field: ‘job’
[11:01:36.109]   - Field: ‘conditions’
[11:01:36.109]   - Field: ‘expr’
[11:01:36.109]   - Field: ‘uuid’
[11:01:36.109]   - Field: ‘seed’
[11:01:36.109]   - Field: ‘version’
[11:01:36.109]   - Field: ‘result’
[11:01:36.110]   - Field: ‘asynchronous’
[11:01:36.110]   - Field: ‘calls’
[11:01:36.110]   - Field: ‘globals’
[11:01:36.110]   - Field: ‘stdout’
[11:01:36.110]   - Field: ‘earlySignal’
[11:01:36.110]   - Field: ‘lazy’
[11:01:36.110]   - Field: ‘state’
[11:01:36.110] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:36.110] - Launch lazy future ...
[11:01:36.111] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[11:01:36.111] Packages needed by future strategies (n = 0): <none>
[11:01:36.111] {
[11:01:36.111]     {
[11:01:36.111]         {
[11:01:36.111]             ...future.startTime <- base::Sys.time()
[11:01:36.111]             {
[11:01:36.111]                 {
[11:01:36.111]                   {
[11:01:36.111]                     {
[11:01:36.111]                       {
[11:01:36.111]                         base::local({
[11:01:36.111]                           has_future <- base::requireNamespace("future", 
[11:01:36.111]                             quietly = TRUE)
[11:01:36.111]                           if (has_future) {
[11:01:36.111]                             ns <- base::getNamespace("future")
[11:01:36.111]                             version <- ns[[".package"]][["version"]]
[11:01:36.111]                             if (is.null(version)) 
[11:01:36.111]                               version <- utils::packageVersion("future")
[11:01:36.111]                           }
[11:01:36.111]                           else {
[11:01:36.111]                             version <- NULL
[11:01:36.111]                           }
[11:01:36.111]                           if (!has_future || version < "1.8.0") {
[11:01:36.111]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:36.111]                               "", base::R.version$version.string), 
[11:01:36.111]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:36.111]                                 base::R.version$platform, 8 * 
[11:01:36.111]                                   base::.Machine$sizeof.pointer), 
[11:01:36.111]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:36.111]                                 "release", "version")], collapse = " "), 
[11:01:36.111]                               hostname = base::Sys.info()[["nodename"]])
[11:01:36.111]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:36.111]                               info)
[11:01:36.111]                             info <- base::paste(info, collapse = "; ")
[11:01:36.111]                             if (!has_future) {
[11:01:36.111]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:36.111]                                 info)
[11:01:36.111]                             }
[11:01:36.111]                             else {
[11:01:36.111]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:36.111]                                 info, version)
[11:01:36.111]                             }
[11:01:36.111]                             base::stop(msg)
[11:01:36.111]                           }
[11:01:36.111]                         })
[11:01:36.111]                       }
[11:01:36.111]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:36.111]                       base::options(mc.cores = 1L)
[11:01:36.111]                     }
[11:01:36.111]                     base::local({
[11:01:36.111]                       for (pkg in c("stats", "datasets")) {
[11:01:36.111]                         base::loadNamespace(pkg)
[11:01:36.111]                         base::library(pkg, character.only = TRUE)
[11:01:36.111]                       }
[11:01:36.111]                     })
[11:01:36.111]                   }
[11:01:36.111]                   ...future.strategy.old <- future::plan("list")
[11:01:36.111]                   options(future.plan = NULL)
[11:01:36.111]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:36.111]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:36.111]                 }
[11:01:36.111]                 ...future.workdir <- getwd()
[11:01:36.111]             }
[11:01:36.111]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:36.111]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:36.111]         }
[11:01:36.111]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:36.111]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:36.111]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:36.111]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:36.111]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:36.111]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:36.111]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:36.111]             base::names(...future.oldOptions))
[11:01:36.111]     }
[11:01:36.111]     if (FALSE) {
[11:01:36.111]     }
[11:01:36.111]     else {
[11:01:36.111]         if (TRUE) {
[11:01:36.111]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:36.111]                 open = "w")
[11:01:36.111]         }
[11:01:36.111]         else {
[11:01:36.111]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:36.111]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:36.111]         }
[11:01:36.111]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:36.111]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:36.111]             base::sink(type = "output", split = FALSE)
[11:01:36.111]             base::close(...future.stdout)
[11:01:36.111]         }, add = TRUE)
[11:01:36.111]     }
[11:01:36.111]     ...future.frame <- base::sys.nframe()
[11:01:36.111]     ...future.conditions <- base::list()
[11:01:36.111]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:36.111]     if (FALSE) {
[11:01:36.111]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:36.111]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:36.111]     }
[11:01:36.111]     ...future.result <- base::tryCatch({
[11:01:36.111]         base::withCallingHandlers({
[11:01:36.111]             ...future.value <- base::withVisible(base::local({
[11:01:36.111]                 withCallingHandlers({
[11:01:36.111]                   {
[11:01:36.111]                     lm(dist ~ poly(speed, 2), data = cars)
[11:01:36.111]                   }
[11:01:36.111]                 }, immediateCondition = function(cond) {
[11:01:36.111]                   save_rds <- function (object, pathname, ...) 
[11:01:36.111]                   {
[11:01:36.111]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:36.111]                     if (file_test("-f", pathname_tmp)) {
[11:01:36.111]                       fi_tmp <- file.info(pathname_tmp)
[11:01:36.111]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:36.111]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:36.111]                         fi_tmp[["mtime"]])
[11:01:36.111]                     }
[11:01:36.111]                     tryCatch({
[11:01:36.111]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:36.111]                     }, error = function(ex) {
[11:01:36.111]                       msg <- conditionMessage(ex)
[11:01:36.111]                       fi_tmp <- file.info(pathname_tmp)
[11:01:36.111]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:36.111]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:36.111]                         fi_tmp[["mtime"]], msg)
[11:01:36.111]                       ex$message <- msg
[11:01:36.111]                       stop(ex)
[11:01:36.111]                     })
[11:01:36.111]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:36.111]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:36.111]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:36.111]                       fi_tmp <- file.info(pathname_tmp)
[11:01:36.111]                       fi <- file.info(pathname)
[11:01:36.111]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:36.111]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:36.111]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:36.111]                         fi[["size"]], fi[["mtime"]])
[11:01:36.111]                       stop(msg)
[11:01:36.111]                     }
[11:01:36.111]                     invisible(pathname)
[11:01:36.111]                   }
[11:01:36.111]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:36.111]                     rootPath = tempdir()) 
[11:01:36.111]                   {
[11:01:36.111]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:36.111]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:36.111]                       tmpdir = path, fileext = ".rds")
[11:01:36.111]                     save_rds(obj, file)
[11:01:36.111]                   }
[11:01:36.111]                   saveImmediateCondition(cond, path = "/tmp/Rtmpu6OqnW/.future/immediateConditions")
[11:01:36.111]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.111]                   {
[11:01:36.111]                     inherits <- base::inherits
[11:01:36.111]                     invokeRestart <- base::invokeRestart
[11:01:36.111]                     is.null <- base::is.null
[11:01:36.111]                     muffled <- FALSE
[11:01:36.111]                     if (inherits(cond, "message")) {
[11:01:36.111]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:36.111]                       if (muffled) 
[11:01:36.111]                         invokeRestart("muffleMessage")
[11:01:36.111]                     }
[11:01:36.111]                     else if (inherits(cond, "warning")) {
[11:01:36.111]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:36.111]                       if (muffled) 
[11:01:36.111]                         invokeRestart("muffleWarning")
[11:01:36.111]                     }
[11:01:36.111]                     else if (inherits(cond, "condition")) {
[11:01:36.111]                       if (!is.null(pattern)) {
[11:01:36.111]                         computeRestarts <- base::computeRestarts
[11:01:36.111]                         grepl <- base::grepl
[11:01:36.111]                         restarts <- computeRestarts(cond)
[11:01:36.111]                         for (restart in restarts) {
[11:01:36.111]                           name <- restart$name
[11:01:36.111]                           if (is.null(name)) 
[11:01:36.111]                             next
[11:01:36.111]                           if (!grepl(pattern, name)) 
[11:01:36.111]                             next
[11:01:36.111]                           invokeRestart(restart)
[11:01:36.111]                           muffled <- TRUE
[11:01:36.111]                           break
[11:01:36.111]                         }
[11:01:36.111]                       }
[11:01:36.111]                     }
[11:01:36.111]                     invisible(muffled)
[11:01:36.111]                   }
[11:01:36.111]                   muffleCondition(cond)
[11:01:36.111]                 })
[11:01:36.111]             }))
[11:01:36.111]             future::FutureResult(value = ...future.value$value, 
[11:01:36.111]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:36.111]                   ...future.rng), globalenv = if (FALSE) 
[11:01:36.111]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:36.111]                     ...future.globalenv.names))
[11:01:36.111]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:36.111]         }, condition = base::local({
[11:01:36.111]             c <- base::c
[11:01:36.111]             inherits <- base::inherits
[11:01:36.111]             invokeRestart <- base::invokeRestart
[11:01:36.111]             length <- base::length
[11:01:36.111]             list <- base::list
[11:01:36.111]             seq.int <- base::seq.int
[11:01:36.111]             signalCondition <- base::signalCondition
[11:01:36.111]             sys.calls <- base::sys.calls
[11:01:36.111]             `[[` <- base::`[[`
[11:01:36.111]             `+` <- base::`+`
[11:01:36.111]             `<<-` <- base::`<<-`
[11:01:36.111]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:36.111]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:36.111]                   3L)]
[11:01:36.111]             }
[11:01:36.111]             function(cond) {
[11:01:36.111]                 is_error <- inherits(cond, "error")
[11:01:36.111]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:36.111]                   NULL)
[11:01:36.111]                 if (is_error) {
[11:01:36.111]                   sessionInformation <- function() {
[11:01:36.111]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:36.111]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:36.111]                       search = base::search(), system = base::Sys.info())
[11:01:36.111]                   }
[11:01:36.111]                   ...future.conditions[[length(...future.conditions) + 
[11:01:36.111]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:36.111]                     cond$call), session = sessionInformation(), 
[11:01:36.111]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:36.111]                   signalCondition(cond)
[11:01:36.111]                 }
[11:01:36.111]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:36.111]                 "immediateCondition"))) {
[11:01:36.111]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:36.111]                   ...future.conditions[[length(...future.conditions) + 
[11:01:36.111]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:36.111]                   if (TRUE && !signal) {
[11:01:36.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.111]                     {
[11:01:36.111]                       inherits <- base::inherits
[11:01:36.111]                       invokeRestart <- base::invokeRestart
[11:01:36.111]                       is.null <- base::is.null
[11:01:36.111]                       muffled <- FALSE
[11:01:36.111]                       if (inherits(cond, "message")) {
[11:01:36.111]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:36.111]                         if (muffled) 
[11:01:36.111]                           invokeRestart("muffleMessage")
[11:01:36.111]                       }
[11:01:36.111]                       else if (inherits(cond, "warning")) {
[11:01:36.111]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:36.111]                         if (muffled) 
[11:01:36.111]                           invokeRestart("muffleWarning")
[11:01:36.111]                       }
[11:01:36.111]                       else if (inherits(cond, "condition")) {
[11:01:36.111]                         if (!is.null(pattern)) {
[11:01:36.111]                           computeRestarts <- base::computeRestarts
[11:01:36.111]                           grepl <- base::grepl
[11:01:36.111]                           restarts <- computeRestarts(cond)
[11:01:36.111]                           for (restart in restarts) {
[11:01:36.111]                             name <- restart$name
[11:01:36.111]                             if (is.null(name)) 
[11:01:36.111]                               next
[11:01:36.111]                             if (!grepl(pattern, name)) 
[11:01:36.111]                               next
[11:01:36.111]                             invokeRestart(restart)
[11:01:36.111]                             muffled <- TRUE
[11:01:36.111]                             break
[11:01:36.111]                           }
[11:01:36.111]                         }
[11:01:36.111]                       }
[11:01:36.111]                       invisible(muffled)
[11:01:36.111]                     }
[11:01:36.111]                     muffleCondition(cond, pattern = "^muffle")
[11:01:36.111]                   }
[11:01:36.111]                 }
[11:01:36.111]                 else {
[11:01:36.111]                   if (TRUE) {
[11:01:36.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.111]                     {
[11:01:36.111]                       inherits <- base::inherits
[11:01:36.111]                       invokeRestart <- base::invokeRestart
[11:01:36.111]                       is.null <- base::is.null
[11:01:36.111]                       muffled <- FALSE
[11:01:36.111]                       if (inherits(cond, "message")) {
[11:01:36.111]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:36.111]                         if (muffled) 
[11:01:36.111]                           invokeRestart("muffleMessage")
[11:01:36.111]                       }
[11:01:36.111]                       else if (inherits(cond, "warning")) {
[11:01:36.111]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:36.111]                         if (muffled) 
[11:01:36.111]                           invokeRestart("muffleWarning")
[11:01:36.111]                       }
[11:01:36.111]                       else if (inherits(cond, "condition")) {
[11:01:36.111]                         if (!is.null(pattern)) {
[11:01:36.111]                           computeRestarts <- base::computeRestarts
[11:01:36.111]                           grepl <- base::grepl
[11:01:36.111]                           restarts <- computeRestarts(cond)
[11:01:36.111]                           for (restart in restarts) {
[11:01:36.111]                             name <- restart$name
[11:01:36.111]                             if (is.null(name)) 
[11:01:36.111]                               next
[11:01:36.111]                             if (!grepl(pattern, name)) 
[11:01:36.111]                               next
[11:01:36.111]                             invokeRestart(restart)
[11:01:36.111]                             muffled <- TRUE
[11:01:36.111]                             break
[11:01:36.111]                           }
[11:01:36.111]                         }
[11:01:36.111]                       }
[11:01:36.111]                       invisible(muffled)
[11:01:36.111]                     }
[11:01:36.111]                     muffleCondition(cond, pattern = "^muffle")
[11:01:36.111]                   }
[11:01:36.111]                 }
[11:01:36.111]             }
[11:01:36.111]         }))
[11:01:36.111]     }, error = function(ex) {
[11:01:36.111]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:36.111]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:36.111]                 ...future.rng), started = ...future.startTime, 
[11:01:36.111]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:36.111]             version = "1.8"), class = "FutureResult")
[11:01:36.111]     }, finally = {
[11:01:36.111]         if (!identical(...future.workdir, getwd())) 
[11:01:36.111]             setwd(...future.workdir)
[11:01:36.111]         {
[11:01:36.111]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:36.111]                 ...future.oldOptions$nwarnings <- NULL
[11:01:36.111]             }
[11:01:36.111]             base::options(...future.oldOptions)
[11:01:36.111]             if (.Platform$OS.type == "windows") {
[11:01:36.111]                 old_names <- names(...future.oldEnvVars)
[11:01:36.111]                 envs <- base::Sys.getenv()
[11:01:36.111]                 names <- names(envs)
[11:01:36.111]                 common <- intersect(names, old_names)
[11:01:36.111]                 added <- setdiff(names, old_names)
[11:01:36.111]                 removed <- setdiff(old_names, names)
[11:01:36.111]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:36.111]                   envs[common]]
[11:01:36.111]                 NAMES <- toupper(changed)
[11:01:36.111]                 args <- list()
[11:01:36.111]                 for (kk in seq_along(NAMES)) {
[11:01:36.111]                   name <- changed[[kk]]
[11:01:36.111]                   NAME <- NAMES[[kk]]
[11:01:36.111]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.111]                     next
[11:01:36.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:36.111]                 }
[11:01:36.111]                 NAMES <- toupper(added)
[11:01:36.111]                 for (kk in seq_along(NAMES)) {
[11:01:36.111]                   name <- added[[kk]]
[11:01:36.111]                   NAME <- NAMES[[kk]]
[11:01:36.111]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.111]                     next
[11:01:36.111]                   args[[name]] <- ""
[11:01:36.111]                 }
[11:01:36.111]                 NAMES <- toupper(removed)
[11:01:36.111]                 for (kk in seq_along(NAMES)) {
[11:01:36.111]                   name <- removed[[kk]]
[11:01:36.111]                   NAME <- NAMES[[kk]]
[11:01:36.111]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.111]                     next
[11:01:36.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:36.111]                 }
[11:01:36.111]                 if (length(args) > 0) 
[11:01:36.111]                   base::do.call(base::Sys.setenv, args = args)
[11:01:36.111]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:36.111]             }
[11:01:36.111]             else {
[11:01:36.111]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:36.111]             }
[11:01:36.111]             {
[11:01:36.111]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:36.111]                   0L) {
[11:01:36.111]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:36.111]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:36.111]                   base::options(opts)
[11:01:36.111]                 }
[11:01:36.111]                 {
[11:01:36.111]                   {
[11:01:36.111]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:36.111]                     NULL
[11:01:36.111]                   }
[11:01:36.111]                   options(future.plan = NULL)
[11:01:36.111]                   if (is.na(NA_character_)) 
[11:01:36.111]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:36.111]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:36.111]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:36.111]                     .init = FALSE)
[11:01:36.111]                 }
[11:01:36.111]             }
[11:01:36.111]         }
[11:01:36.111]     })
[11:01:36.111]     if (TRUE) {
[11:01:36.111]         base::sink(type = "output", split = FALSE)
[11:01:36.111]         if (TRUE) {
[11:01:36.111]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:36.111]         }
[11:01:36.111]         else {
[11:01:36.111]             ...future.result["stdout"] <- base::list(NULL)
[11:01:36.111]         }
[11:01:36.111]         base::close(...future.stdout)
[11:01:36.111]         ...future.stdout <- NULL
[11:01:36.111]     }
[11:01:36.111]     ...future.result$conditions <- ...future.conditions
[11:01:36.111]     ...future.result$finished <- base::Sys.time()
[11:01:36.111]     ...future.result
[11:01:36.111] }
[11:01:36.114] requestCore(): workers = 2
[11:01:36.115] MulticoreFuture started
[11:01:36.116] - Launch lazy future ... done
[11:01:36.116] run() for ‘MulticoreFuture’ ... done
[11:01:36.116] result() for MulticoreFuture ...
[11:01:36.117] plan(): Setting new future strategy stack:
[11:01:36.117] List of future strategies:
[11:01:36.117] 1. sequential:
[11:01:36.117]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:36.117]    - tweaked: FALSE
[11:01:36.117]    - call: NULL
[11:01:36.118] plan(): nbrOfWorkers() = 1
[11:01:36.122] plan(): Setting new future strategy stack:
[11:01:36.123] List of future strategies:
[11:01:36.123] 1. multicore:
[11:01:36.123]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:36.123]    - tweaked: FALSE
[11:01:36.123]    - call: plan(strategy)
[11:01:36.126] plan(): nbrOfWorkers() = 2
[11:01:36.128] result() for MulticoreFuture ...
[11:01:36.128] result() for MulticoreFuture ... done
[11:01:36.128] result() for MulticoreFuture ... done
[11:01:36.128] result() for MulticoreFuture ...
[11:01:36.128] result() for MulticoreFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[11:01:36.131] getGlobalsAndPackages() ...
[11:01:36.131] Searching for globals...
[11:01:36.137] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[11:01:36.137] Searching for globals ... DONE
[11:01:36.137] Resolving globals: FALSE
[11:01:36.138] The total size of the 3 globals is 1.22 KiB (1254 bytes)
[11:01:36.139] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (633 bytes of class ‘function’), ‘inner_function’ (371 bytes of class ‘function’) and ‘outer_function’ (250 bytes of class ‘function’)
[11:01:36.139] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[11:01:36.139] 
[11:01:36.139] getGlobalsAndPackages() ... DONE
[11:01:36.139] run() for ‘Future’ ...
[11:01:36.139] - state: ‘created’
[11:01:36.140] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:36.141] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:36.142] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:36.142]   - Field: ‘label’
[11:01:36.142]   - Field: ‘local’
[11:01:36.142]   - Field: ‘owner’
[11:01:36.142]   - Field: ‘envir’
[11:01:36.142]   - Field: ‘workers’
[11:01:36.142]   - Field: ‘packages’
[11:01:36.142]   - Field: ‘gc’
[11:01:36.143]   - Field: ‘job’
[11:01:36.143]   - Field: ‘conditions’
[11:01:36.143]   - Field: ‘expr’
[11:01:36.143]   - Field: ‘uuid’
[11:01:36.143]   - Field: ‘seed’
[11:01:36.143]   - Field: ‘version’
[11:01:36.143]   - Field: ‘result’
[11:01:36.145]   - Field: ‘asynchronous’
[11:01:36.145]   - Field: ‘calls’
[11:01:36.145]   - Field: ‘globals’
[11:01:36.145]   - Field: ‘stdout’
[11:01:36.146]   - Field: ‘earlySignal’
[11:01:36.146]   - Field: ‘lazy’
[11:01:36.146]   - Field: ‘state’
[11:01:36.146] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:36.146] - Launch lazy future ...
[11:01:36.147] Packages needed by the future expression (n = 0): <none>
[11:01:36.147] Packages needed by future strategies (n = 0): <none>
[11:01:36.147] {
[11:01:36.147]     {
[11:01:36.147]         {
[11:01:36.147]             ...future.startTime <- base::Sys.time()
[11:01:36.147]             {
[11:01:36.147]                 {
[11:01:36.147]                   {
[11:01:36.147]                     {
[11:01:36.147]                       base::local({
[11:01:36.147]                         has_future <- base::requireNamespace("future", 
[11:01:36.147]                           quietly = TRUE)
[11:01:36.147]                         if (has_future) {
[11:01:36.147]                           ns <- base::getNamespace("future")
[11:01:36.147]                           version <- ns[[".package"]][["version"]]
[11:01:36.147]                           if (is.null(version)) 
[11:01:36.147]                             version <- utils::packageVersion("future")
[11:01:36.147]                         }
[11:01:36.147]                         else {
[11:01:36.147]                           version <- NULL
[11:01:36.147]                         }
[11:01:36.147]                         if (!has_future || version < "1.8.0") {
[11:01:36.147]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:36.147]                             "", base::R.version$version.string), 
[11:01:36.147]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:36.147]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:36.147]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:36.147]                               "release", "version")], collapse = " "), 
[11:01:36.147]                             hostname = base::Sys.info()[["nodename"]])
[11:01:36.147]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:36.147]                             info)
[11:01:36.147]                           info <- base::paste(info, collapse = "; ")
[11:01:36.147]                           if (!has_future) {
[11:01:36.147]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:36.147]                               info)
[11:01:36.147]                           }
[11:01:36.147]                           else {
[11:01:36.147]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:36.147]                               info, version)
[11:01:36.147]                           }
[11:01:36.147]                           base::stop(msg)
[11:01:36.147]                         }
[11:01:36.147]                       })
[11:01:36.147]                     }
[11:01:36.147]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:36.147]                     base::options(mc.cores = 1L)
[11:01:36.147]                   }
[11:01:36.147]                   ...future.strategy.old <- future::plan("list")
[11:01:36.147]                   options(future.plan = NULL)
[11:01:36.147]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:36.147]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:36.147]                 }
[11:01:36.147]                 ...future.workdir <- getwd()
[11:01:36.147]             }
[11:01:36.147]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:36.147]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:36.147]         }
[11:01:36.147]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:36.147]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:36.147]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:36.147]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:36.147]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:36.147]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:36.147]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:36.147]             base::names(...future.oldOptions))
[11:01:36.147]     }
[11:01:36.147]     if (FALSE) {
[11:01:36.147]     }
[11:01:36.147]     else {
[11:01:36.147]         if (TRUE) {
[11:01:36.147]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:36.147]                 open = "w")
[11:01:36.147]         }
[11:01:36.147]         else {
[11:01:36.147]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:36.147]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:36.147]         }
[11:01:36.147]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:36.147]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:36.147]             base::sink(type = "output", split = FALSE)
[11:01:36.147]             base::close(...future.stdout)
[11:01:36.147]         }, add = TRUE)
[11:01:36.147]     }
[11:01:36.147]     ...future.frame <- base::sys.nframe()
[11:01:36.147]     ...future.conditions <- base::list()
[11:01:36.147]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:36.147]     if (FALSE) {
[11:01:36.147]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:36.147]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:36.147]     }
[11:01:36.147]     ...future.result <- base::tryCatch({
[11:01:36.147]         base::withCallingHandlers({
[11:01:36.147]             ...future.value <- base::withVisible(base::local({
[11:01:36.147]                 withCallingHandlers({
[11:01:36.147]                   {
[11:01:36.147]                     outer_function(1L)
[11:01:36.147]                   }
[11:01:36.147]                 }, immediateCondition = function(cond) {
[11:01:36.147]                   save_rds <- function (object, pathname, ...) 
[11:01:36.147]                   {
[11:01:36.147]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:36.147]                     if (file_test("-f", pathname_tmp)) {
[11:01:36.147]                       fi_tmp <- file.info(pathname_tmp)
[11:01:36.147]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:36.147]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:36.147]                         fi_tmp[["mtime"]])
[11:01:36.147]                     }
[11:01:36.147]                     tryCatch({
[11:01:36.147]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:36.147]                     }, error = function(ex) {
[11:01:36.147]                       msg <- conditionMessage(ex)
[11:01:36.147]                       fi_tmp <- file.info(pathname_tmp)
[11:01:36.147]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:36.147]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:36.147]                         fi_tmp[["mtime"]], msg)
[11:01:36.147]                       ex$message <- msg
[11:01:36.147]                       stop(ex)
[11:01:36.147]                     })
[11:01:36.147]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:36.147]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:36.147]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:36.147]                       fi_tmp <- file.info(pathname_tmp)
[11:01:36.147]                       fi <- file.info(pathname)
[11:01:36.147]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:36.147]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:36.147]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:36.147]                         fi[["size"]], fi[["mtime"]])
[11:01:36.147]                       stop(msg)
[11:01:36.147]                     }
[11:01:36.147]                     invisible(pathname)
[11:01:36.147]                   }
[11:01:36.147]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:36.147]                     rootPath = tempdir()) 
[11:01:36.147]                   {
[11:01:36.147]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:36.147]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:36.147]                       tmpdir = path, fileext = ".rds")
[11:01:36.147]                     save_rds(obj, file)
[11:01:36.147]                   }
[11:01:36.147]                   saveImmediateCondition(cond, path = "/tmp/Rtmpu6OqnW/.future/immediateConditions")
[11:01:36.147]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.147]                   {
[11:01:36.147]                     inherits <- base::inherits
[11:01:36.147]                     invokeRestart <- base::invokeRestart
[11:01:36.147]                     is.null <- base::is.null
[11:01:36.147]                     muffled <- FALSE
[11:01:36.147]                     if (inherits(cond, "message")) {
[11:01:36.147]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:36.147]                       if (muffled) 
[11:01:36.147]                         invokeRestart("muffleMessage")
[11:01:36.147]                     }
[11:01:36.147]                     else if (inherits(cond, "warning")) {
[11:01:36.147]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:36.147]                       if (muffled) 
[11:01:36.147]                         invokeRestart("muffleWarning")
[11:01:36.147]                     }
[11:01:36.147]                     else if (inherits(cond, "condition")) {
[11:01:36.147]                       if (!is.null(pattern)) {
[11:01:36.147]                         computeRestarts <- base::computeRestarts
[11:01:36.147]                         grepl <- base::grepl
[11:01:36.147]                         restarts <- computeRestarts(cond)
[11:01:36.147]                         for (restart in restarts) {
[11:01:36.147]                           name <- restart$name
[11:01:36.147]                           if (is.null(name)) 
[11:01:36.147]                             next
[11:01:36.147]                           if (!grepl(pattern, name)) 
[11:01:36.147]                             next
[11:01:36.147]                           invokeRestart(restart)
[11:01:36.147]                           muffled <- TRUE
[11:01:36.147]                           break
[11:01:36.147]                         }
[11:01:36.147]                       }
[11:01:36.147]                     }
[11:01:36.147]                     invisible(muffled)
[11:01:36.147]                   }
[11:01:36.147]                   muffleCondition(cond)
[11:01:36.147]                 })
[11:01:36.147]             }))
[11:01:36.147]             future::FutureResult(value = ...future.value$value, 
[11:01:36.147]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:36.147]                   ...future.rng), globalenv = if (FALSE) 
[11:01:36.147]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:36.147]                     ...future.globalenv.names))
[11:01:36.147]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:36.147]         }, condition = base::local({
[11:01:36.147]             c <- base::c
[11:01:36.147]             inherits <- base::inherits
[11:01:36.147]             invokeRestart <- base::invokeRestart
[11:01:36.147]             length <- base::length
[11:01:36.147]             list <- base::list
[11:01:36.147]             seq.int <- base::seq.int
[11:01:36.147]             signalCondition <- base::signalCondition
[11:01:36.147]             sys.calls <- base::sys.calls
[11:01:36.147]             `[[` <- base::`[[`
[11:01:36.147]             `+` <- base::`+`
[11:01:36.147]             `<<-` <- base::`<<-`
[11:01:36.147]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:36.147]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:36.147]                   3L)]
[11:01:36.147]             }
[11:01:36.147]             function(cond) {
[11:01:36.147]                 is_error <- inherits(cond, "error")
[11:01:36.147]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:36.147]                   NULL)
[11:01:36.147]                 if (is_error) {
[11:01:36.147]                   sessionInformation <- function() {
[11:01:36.147]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:36.147]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:36.147]                       search = base::search(), system = base::Sys.info())
[11:01:36.147]                   }
[11:01:36.147]                   ...future.conditions[[length(...future.conditions) + 
[11:01:36.147]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:36.147]                     cond$call), session = sessionInformation(), 
[11:01:36.147]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:36.147]                   signalCondition(cond)
[11:01:36.147]                 }
[11:01:36.147]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:36.147]                 "immediateCondition"))) {
[11:01:36.147]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:36.147]                   ...future.conditions[[length(...future.conditions) + 
[11:01:36.147]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:36.147]                   if (TRUE && !signal) {
[11:01:36.147]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.147]                     {
[11:01:36.147]                       inherits <- base::inherits
[11:01:36.147]                       invokeRestart <- base::invokeRestart
[11:01:36.147]                       is.null <- base::is.null
[11:01:36.147]                       muffled <- FALSE
[11:01:36.147]                       if (inherits(cond, "message")) {
[11:01:36.147]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:36.147]                         if (muffled) 
[11:01:36.147]                           invokeRestart("muffleMessage")
[11:01:36.147]                       }
[11:01:36.147]                       else if (inherits(cond, "warning")) {
[11:01:36.147]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:36.147]                         if (muffled) 
[11:01:36.147]                           invokeRestart("muffleWarning")
[11:01:36.147]                       }
[11:01:36.147]                       else if (inherits(cond, "condition")) {
[11:01:36.147]                         if (!is.null(pattern)) {
[11:01:36.147]                           computeRestarts <- base::computeRestarts
[11:01:36.147]                           grepl <- base::grepl
[11:01:36.147]                           restarts <- computeRestarts(cond)
[11:01:36.147]                           for (restart in restarts) {
[11:01:36.147]                             name <- restart$name
[11:01:36.147]                             if (is.null(name)) 
[11:01:36.147]                               next
[11:01:36.147]                             if (!grepl(pattern, name)) 
[11:01:36.147]                               next
[11:01:36.147]                             invokeRestart(restart)
[11:01:36.147]                             muffled <- TRUE
[11:01:36.147]                             break
[11:01:36.147]                           }
[11:01:36.147]                         }
[11:01:36.147]                       }
[11:01:36.147]                       invisible(muffled)
[11:01:36.147]                     }
[11:01:36.147]                     muffleCondition(cond, pattern = "^muffle")
[11:01:36.147]                   }
[11:01:36.147]                 }
[11:01:36.147]                 else {
[11:01:36.147]                   if (TRUE) {
[11:01:36.147]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.147]                     {
[11:01:36.147]                       inherits <- base::inherits
[11:01:36.147]                       invokeRestart <- base::invokeRestart
[11:01:36.147]                       is.null <- base::is.null
[11:01:36.147]                       muffled <- FALSE
[11:01:36.147]                       if (inherits(cond, "message")) {
[11:01:36.147]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:36.147]                         if (muffled) 
[11:01:36.147]                           invokeRestart("muffleMessage")
[11:01:36.147]                       }
[11:01:36.147]                       else if (inherits(cond, "warning")) {
[11:01:36.147]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:36.147]                         if (muffled) 
[11:01:36.147]                           invokeRestart("muffleWarning")
[11:01:36.147]                       }
[11:01:36.147]                       else if (inherits(cond, "condition")) {
[11:01:36.147]                         if (!is.null(pattern)) {
[11:01:36.147]                           computeRestarts <- base::computeRestarts
[11:01:36.147]                           grepl <- base::grepl
[11:01:36.147]                           restarts <- computeRestarts(cond)
[11:01:36.147]                           for (restart in restarts) {
[11:01:36.147]                             name <- restart$name
[11:01:36.147]                             if (is.null(name)) 
[11:01:36.147]                               next
[11:01:36.147]                             if (!grepl(pattern, name)) 
[11:01:36.147]                               next
[11:01:36.147]                             invokeRestart(restart)
[11:01:36.147]                             muffled <- TRUE
[11:01:36.147]                             break
[11:01:36.147]                           }
[11:01:36.147]                         }
[11:01:36.147]                       }
[11:01:36.147]                       invisible(muffled)
[11:01:36.147]                     }
[11:01:36.147]                     muffleCondition(cond, pattern = "^muffle")
[11:01:36.147]                   }
[11:01:36.147]                 }
[11:01:36.147]             }
[11:01:36.147]         }))
[11:01:36.147]     }, error = function(ex) {
[11:01:36.147]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:36.147]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:36.147]                 ...future.rng), started = ...future.startTime, 
[11:01:36.147]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:36.147]             version = "1.8"), class = "FutureResult")
[11:01:36.147]     }, finally = {
[11:01:36.147]         if (!identical(...future.workdir, getwd())) 
[11:01:36.147]             setwd(...future.workdir)
[11:01:36.147]         {
[11:01:36.147]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:36.147]                 ...future.oldOptions$nwarnings <- NULL
[11:01:36.147]             }
[11:01:36.147]             base::options(...future.oldOptions)
[11:01:36.147]             if (.Platform$OS.type == "windows") {
[11:01:36.147]                 old_names <- names(...future.oldEnvVars)
[11:01:36.147]                 envs <- base::Sys.getenv()
[11:01:36.147]                 names <- names(envs)
[11:01:36.147]                 common <- intersect(names, old_names)
[11:01:36.147]                 added <- setdiff(names, old_names)
[11:01:36.147]                 removed <- setdiff(old_names, names)
[11:01:36.147]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:36.147]                   envs[common]]
[11:01:36.147]                 NAMES <- toupper(changed)
[11:01:36.147]                 args <- list()
[11:01:36.147]                 for (kk in seq_along(NAMES)) {
[11:01:36.147]                   name <- changed[[kk]]
[11:01:36.147]                   NAME <- NAMES[[kk]]
[11:01:36.147]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.147]                     next
[11:01:36.147]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:36.147]                 }
[11:01:36.147]                 NAMES <- toupper(added)
[11:01:36.147]                 for (kk in seq_along(NAMES)) {
[11:01:36.147]                   name <- added[[kk]]
[11:01:36.147]                   NAME <- NAMES[[kk]]
[11:01:36.147]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.147]                     next
[11:01:36.147]                   args[[name]] <- ""
[11:01:36.147]                 }
[11:01:36.147]                 NAMES <- toupper(removed)
[11:01:36.147]                 for (kk in seq_along(NAMES)) {
[11:01:36.147]                   name <- removed[[kk]]
[11:01:36.147]                   NAME <- NAMES[[kk]]
[11:01:36.147]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.147]                     next
[11:01:36.147]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:36.147]                 }
[11:01:36.147]                 if (length(args) > 0) 
[11:01:36.147]                   base::do.call(base::Sys.setenv, args = args)
[11:01:36.147]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:36.147]             }
[11:01:36.147]             else {
[11:01:36.147]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:36.147]             }
[11:01:36.147]             {
[11:01:36.147]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:36.147]                   0L) {
[11:01:36.147]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:36.147]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:36.147]                   base::options(opts)
[11:01:36.147]                 }
[11:01:36.147]                 {
[11:01:36.147]                   {
[11:01:36.147]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:36.147]                     NULL
[11:01:36.147]                   }
[11:01:36.147]                   options(future.plan = NULL)
[11:01:36.147]                   if (is.na(NA_character_)) 
[11:01:36.147]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:36.147]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:36.147]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:36.147]                     .init = FALSE)
[11:01:36.147]                 }
[11:01:36.147]             }
[11:01:36.147]         }
[11:01:36.147]     })
[11:01:36.147]     if (TRUE) {
[11:01:36.147]         base::sink(type = "output", split = FALSE)
[11:01:36.147]         if (TRUE) {
[11:01:36.147]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:36.147]         }
[11:01:36.147]         else {
[11:01:36.147]             ...future.result["stdout"] <- base::list(NULL)
[11:01:36.147]         }
[11:01:36.147]         base::close(...future.stdout)
[11:01:36.147]         ...future.stdout <- NULL
[11:01:36.147]     }
[11:01:36.147]     ...future.result$conditions <- ...future.conditions
[11:01:36.147]     ...future.result$finished <- base::Sys.time()
[11:01:36.147]     ...future.result
[11:01:36.147] }
[11:01:36.150] assign_globals() ...
[11:01:36.150] List of 3
[11:01:36.150]  $ outer_function:function (x)  
[11:01:36.150]  $ map           :function (.x, .f, ...)  
[11:01:36.150]  $ inner_function:function (x)  
[11:01:36.150]  - attr(*, "where")=List of 3
[11:01:36.150]   ..$ outer_function:<environment: R_EmptyEnv> 
[11:01:36.150]   ..$ map           :<environment: R_EmptyEnv> 
[11:01:36.150]   ..$ inner_function:<environment: R_EmptyEnv> 
[11:01:36.150]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:36.150]  - attr(*, "resolved")= logi FALSE
[11:01:36.150]  - attr(*, "total_size")= num 1254
[11:01:36.150]  - attr(*, "already-done")= logi TRUE
[11:01:36.154] - reassign environment for ‘outer_function’
[11:01:36.154] - copied ‘outer_function’ to environment
[11:01:36.154] - reassign environment for ‘map’
[11:01:36.154] - copied ‘map’ to environment
[11:01:36.154] - reassign environment for ‘inner_function’
[11:01:36.154] - copied ‘inner_function’ to environment
[11:01:36.154] assign_globals() ... done
[11:01:36.154] requestCore(): workers = 2
[11:01:36.156] MulticoreFuture started
[11:01:36.156] - Launch lazy future ... done
[11:01:36.157] run() for ‘MulticoreFuture’ ... done
[11:01:36.157] plan(): Setting new future strategy stack:
[11:01:36.157] result() for MulticoreFuture ...
[11:01:36.157] List of future strategies:
[11:01:36.157] 1. sequential:
[11:01:36.157]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:36.157]    - tweaked: FALSE
[11:01:36.157]    - call: NULL
[11:01:36.158] plan(): nbrOfWorkers() = 1
[11:01:36.161] plan(): Setting new future strategy stack:
[11:01:36.161] List of future strategies:
[11:01:36.161] 1. multicore:
[11:01:36.161]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:36.161]    - tweaked: FALSE
[11:01:36.161]    - call: plan(strategy)
[11:01:36.164] plan(): nbrOfWorkers() = 2
[11:01:36.165] result() for MulticoreFuture ...
[11:01:36.165] result() for MulticoreFuture ... done
[11:01:36.165] result() for MulticoreFuture ... done
[11:01:36.165] result() for MulticoreFuture ...
[11:01:36.166] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[11:01:36.167] getGlobalsAndPackages() ...
[11:01:36.168] Searching for globals...
[11:01:36.173] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[11:01:36.173] Searching for globals ... DONE
[11:01:36.173] Resolving globals: FALSE
[11:01:36.174] The total size of the 3 globals is 1.22 KiB (1254 bytes)
[11:01:36.175] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (633 bytes of class ‘function’), ‘inner_function’ (371 bytes of class ‘function’) and ‘outer_function’ (250 bytes of class ‘function’)
[11:01:36.175] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[11:01:36.175] 
[11:01:36.175] getGlobalsAndPackages() ... DONE
[11:01:36.175] run() for ‘Future’ ...
[11:01:36.176] - state: ‘created’
[11:01:36.176] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:36.178] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:36.178] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:36.178]   - Field: ‘label’
[11:01:36.178]   - Field: ‘local’
[11:01:36.178]   - Field: ‘owner’
[11:01:36.178]   - Field: ‘envir’
[11:01:36.178]   - Field: ‘workers’
[11:01:36.179]   - Field: ‘packages’
[11:01:36.179]   - Field: ‘gc’
[11:01:36.179]   - Field: ‘job’
[11:01:36.179]   - Field: ‘conditions’
[11:01:36.179]   - Field: ‘expr’
[11:01:36.179]   - Field: ‘uuid’
[11:01:36.179]   - Field: ‘seed’
[11:01:36.179]   - Field: ‘version’
[11:01:36.179]   - Field: ‘result’
[11:01:36.179]   - Field: ‘asynchronous’
[11:01:36.180]   - Field: ‘calls’
[11:01:36.180]   - Field: ‘globals’
[11:01:36.180]   - Field: ‘stdout’
[11:01:36.180]   - Field: ‘earlySignal’
[11:01:36.180]   - Field: ‘lazy’
[11:01:36.180]   - Field: ‘state’
[11:01:36.180] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:36.180] - Launch lazy future ...
[11:01:36.181] Packages needed by the future expression (n = 0): <none>
[11:01:36.181] Packages needed by future strategies (n = 0): <none>
[11:01:36.181] {
[11:01:36.181]     {
[11:01:36.181]         {
[11:01:36.181]             ...future.startTime <- base::Sys.time()
[11:01:36.181]             {
[11:01:36.181]                 {
[11:01:36.181]                   {
[11:01:36.181]                     {
[11:01:36.181]                       base::local({
[11:01:36.181]                         has_future <- base::requireNamespace("future", 
[11:01:36.181]                           quietly = TRUE)
[11:01:36.181]                         if (has_future) {
[11:01:36.181]                           ns <- base::getNamespace("future")
[11:01:36.181]                           version <- ns[[".package"]][["version"]]
[11:01:36.181]                           if (is.null(version)) 
[11:01:36.181]                             version <- utils::packageVersion("future")
[11:01:36.181]                         }
[11:01:36.181]                         else {
[11:01:36.181]                           version <- NULL
[11:01:36.181]                         }
[11:01:36.181]                         if (!has_future || version < "1.8.0") {
[11:01:36.181]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:36.181]                             "", base::R.version$version.string), 
[11:01:36.181]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:36.181]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:36.181]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:36.181]                               "release", "version")], collapse = " "), 
[11:01:36.181]                             hostname = base::Sys.info()[["nodename"]])
[11:01:36.181]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:36.181]                             info)
[11:01:36.181]                           info <- base::paste(info, collapse = "; ")
[11:01:36.181]                           if (!has_future) {
[11:01:36.181]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:36.181]                               info)
[11:01:36.181]                           }
[11:01:36.181]                           else {
[11:01:36.181]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:36.181]                               info, version)
[11:01:36.181]                           }
[11:01:36.181]                           base::stop(msg)
[11:01:36.181]                         }
[11:01:36.181]                       })
[11:01:36.181]                     }
[11:01:36.181]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:36.181]                     base::options(mc.cores = 1L)
[11:01:36.181]                   }
[11:01:36.181]                   ...future.strategy.old <- future::plan("list")
[11:01:36.181]                   options(future.plan = NULL)
[11:01:36.181]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:36.181]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:36.181]                 }
[11:01:36.181]                 ...future.workdir <- getwd()
[11:01:36.181]             }
[11:01:36.181]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:36.181]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:36.181]         }
[11:01:36.181]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:36.181]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:36.181]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:36.181]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:36.181]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:36.181]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:36.181]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:36.181]             base::names(...future.oldOptions))
[11:01:36.181]     }
[11:01:36.181]     if (FALSE) {
[11:01:36.181]     }
[11:01:36.181]     else {
[11:01:36.181]         if (TRUE) {
[11:01:36.181]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:36.181]                 open = "w")
[11:01:36.181]         }
[11:01:36.181]         else {
[11:01:36.181]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:36.181]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:36.181]         }
[11:01:36.181]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:36.181]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:36.181]             base::sink(type = "output", split = FALSE)
[11:01:36.181]             base::close(...future.stdout)
[11:01:36.181]         }, add = TRUE)
[11:01:36.181]     }
[11:01:36.181]     ...future.frame <- base::sys.nframe()
[11:01:36.181]     ...future.conditions <- base::list()
[11:01:36.181]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:36.181]     if (FALSE) {
[11:01:36.181]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:36.181]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:36.181]     }
[11:01:36.181]     ...future.result <- base::tryCatch({
[11:01:36.181]         base::withCallingHandlers({
[11:01:36.181]             ...future.value <- base::withVisible(base::local({
[11:01:36.181]                 withCallingHandlers({
[11:01:36.181]                   {
[11:01:36.181]                     outer_function(1L)
[11:01:36.181]                   }
[11:01:36.181]                 }, immediateCondition = function(cond) {
[11:01:36.181]                   save_rds <- function (object, pathname, ...) 
[11:01:36.181]                   {
[11:01:36.181]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:36.181]                     if (file_test("-f", pathname_tmp)) {
[11:01:36.181]                       fi_tmp <- file.info(pathname_tmp)
[11:01:36.181]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:36.181]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:36.181]                         fi_tmp[["mtime"]])
[11:01:36.181]                     }
[11:01:36.181]                     tryCatch({
[11:01:36.181]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:36.181]                     }, error = function(ex) {
[11:01:36.181]                       msg <- conditionMessage(ex)
[11:01:36.181]                       fi_tmp <- file.info(pathname_tmp)
[11:01:36.181]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:36.181]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:36.181]                         fi_tmp[["mtime"]], msg)
[11:01:36.181]                       ex$message <- msg
[11:01:36.181]                       stop(ex)
[11:01:36.181]                     })
[11:01:36.181]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:36.181]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:36.181]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:36.181]                       fi_tmp <- file.info(pathname_tmp)
[11:01:36.181]                       fi <- file.info(pathname)
[11:01:36.181]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:36.181]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:36.181]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:36.181]                         fi[["size"]], fi[["mtime"]])
[11:01:36.181]                       stop(msg)
[11:01:36.181]                     }
[11:01:36.181]                     invisible(pathname)
[11:01:36.181]                   }
[11:01:36.181]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:36.181]                     rootPath = tempdir()) 
[11:01:36.181]                   {
[11:01:36.181]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:36.181]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:36.181]                       tmpdir = path, fileext = ".rds")
[11:01:36.181]                     save_rds(obj, file)
[11:01:36.181]                   }
[11:01:36.181]                   saveImmediateCondition(cond, path = "/tmp/Rtmpu6OqnW/.future/immediateConditions")
[11:01:36.181]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.181]                   {
[11:01:36.181]                     inherits <- base::inherits
[11:01:36.181]                     invokeRestart <- base::invokeRestart
[11:01:36.181]                     is.null <- base::is.null
[11:01:36.181]                     muffled <- FALSE
[11:01:36.181]                     if (inherits(cond, "message")) {
[11:01:36.181]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:36.181]                       if (muffled) 
[11:01:36.181]                         invokeRestart("muffleMessage")
[11:01:36.181]                     }
[11:01:36.181]                     else if (inherits(cond, "warning")) {
[11:01:36.181]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:36.181]                       if (muffled) 
[11:01:36.181]                         invokeRestart("muffleWarning")
[11:01:36.181]                     }
[11:01:36.181]                     else if (inherits(cond, "condition")) {
[11:01:36.181]                       if (!is.null(pattern)) {
[11:01:36.181]                         computeRestarts <- base::computeRestarts
[11:01:36.181]                         grepl <- base::grepl
[11:01:36.181]                         restarts <- computeRestarts(cond)
[11:01:36.181]                         for (restart in restarts) {
[11:01:36.181]                           name <- restart$name
[11:01:36.181]                           if (is.null(name)) 
[11:01:36.181]                             next
[11:01:36.181]                           if (!grepl(pattern, name)) 
[11:01:36.181]                             next
[11:01:36.181]                           invokeRestart(restart)
[11:01:36.181]                           muffled <- TRUE
[11:01:36.181]                           break
[11:01:36.181]                         }
[11:01:36.181]                       }
[11:01:36.181]                     }
[11:01:36.181]                     invisible(muffled)
[11:01:36.181]                   }
[11:01:36.181]                   muffleCondition(cond)
[11:01:36.181]                 })
[11:01:36.181]             }))
[11:01:36.181]             future::FutureResult(value = ...future.value$value, 
[11:01:36.181]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:36.181]                   ...future.rng), globalenv = if (FALSE) 
[11:01:36.181]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:36.181]                     ...future.globalenv.names))
[11:01:36.181]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:36.181]         }, condition = base::local({
[11:01:36.181]             c <- base::c
[11:01:36.181]             inherits <- base::inherits
[11:01:36.181]             invokeRestart <- base::invokeRestart
[11:01:36.181]             length <- base::length
[11:01:36.181]             list <- base::list
[11:01:36.181]             seq.int <- base::seq.int
[11:01:36.181]             signalCondition <- base::signalCondition
[11:01:36.181]             sys.calls <- base::sys.calls
[11:01:36.181]             `[[` <- base::`[[`
[11:01:36.181]             `+` <- base::`+`
[11:01:36.181]             `<<-` <- base::`<<-`
[11:01:36.181]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:36.181]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:36.181]                   3L)]
[11:01:36.181]             }
[11:01:36.181]             function(cond) {
[11:01:36.181]                 is_error <- inherits(cond, "error")
[11:01:36.181]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:36.181]                   NULL)
[11:01:36.181]                 if (is_error) {
[11:01:36.181]                   sessionInformation <- function() {
[11:01:36.181]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:36.181]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:36.181]                       search = base::search(), system = base::Sys.info())
[11:01:36.181]                   }
[11:01:36.181]                   ...future.conditions[[length(...future.conditions) + 
[11:01:36.181]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:36.181]                     cond$call), session = sessionInformation(), 
[11:01:36.181]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:36.181]                   signalCondition(cond)
[11:01:36.181]                 }
[11:01:36.181]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:36.181]                 "immediateCondition"))) {
[11:01:36.181]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:36.181]                   ...future.conditions[[length(...future.conditions) + 
[11:01:36.181]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:36.181]                   if (TRUE && !signal) {
[11:01:36.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.181]                     {
[11:01:36.181]                       inherits <- base::inherits
[11:01:36.181]                       invokeRestart <- base::invokeRestart
[11:01:36.181]                       is.null <- base::is.null
[11:01:36.181]                       muffled <- FALSE
[11:01:36.181]                       if (inherits(cond, "message")) {
[11:01:36.181]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:36.181]                         if (muffled) 
[11:01:36.181]                           invokeRestart("muffleMessage")
[11:01:36.181]                       }
[11:01:36.181]                       else if (inherits(cond, "warning")) {
[11:01:36.181]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:36.181]                         if (muffled) 
[11:01:36.181]                           invokeRestart("muffleWarning")
[11:01:36.181]                       }
[11:01:36.181]                       else if (inherits(cond, "condition")) {
[11:01:36.181]                         if (!is.null(pattern)) {
[11:01:36.181]                           computeRestarts <- base::computeRestarts
[11:01:36.181]                           grepl <- base::grepl
[11:01:36.181]                           restarts <- computeRestarts(cond)
[11:01:36.181]                           for (restart in restarts) {
[11:01:36.181]                             name <- restart$name
[11:01:36.181]                             if (is.null(name)) 
[11:01:36.181]                               next
[11:01:36.181]                             if (!grepl(pattern, name)) 
[11:01:36.181]                               next
[11:01:36.181]                             invokeRestart(restart)
[11:01:36.181]                             muffled <- TRUE
[11:01:36.181]                             break
[11:01:36.181]                           }
[11:01:36.181]                         }
[11:01:36.181]                       }
[11:01:36.181]                       invisible(muffled)
[11:01:36.181]                     }
[11:01:36.181]                     muffleCondition(cond, pattern = "^muffle")
[11:01:36.181]                   }
[11:01:36.181]                 }
[11:01:36.181]                 else {
[11:01:36.181]                   if (TRUE) {
[11:01:36.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.181]                     {
[11:01:36.181]                       inherits <- base::inherits
[11:01:36.181]                       invokeRestart <- base::invokeRestart
[11:01:36.181]                       is.null <- base::is.null
[11:01:36.181]                       muffled <- FALSE
[11:01:36.181]                       if (inherits(cond, "message")) {
[11:01:36.181]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:36.181]                         if (muffled) 
[11:01:36.181]                           invokeRestart("muffleMessage")
[11:01:36.181]                       }
[11:01:36.181]                       else if (inherits(cond, "warning")) {
[11:01:36.181]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:36.181]                         if (muffled) 
[11:01:36.181]                           invokeRestart("muffleWarning")
[11:01:36.181]                       }
[11:01:36.181]                       else if (inherits(cond, "condition")) {
[11:01:36.181]                         if (!is.null(pattern)) {
[11:01:36.181]                           computeRestarts <- base::computeRestarts
[11:01:36.181]                           grepl <- base::grepl
[11:01:36.181]                           restarts <- computeRestarts(cond)
[11:01:36.181]                           for (restart in restarts) {
[11:01:36.181]                             name <- restart$name
[11:01:36.181]                             if (is.null(name)) 
[11:01:36.181]                               next
[11:01:36.181]                             if (!grepl(pattern, name)) 
[11:01:36.181]                               next
[11:01:36.181]                             invokeRestart(restart)
[11:01:36.181]                             muffled <- TRUE
[11:01:36.181]                             break
[11:01:36.181]                           }
[11:01:36.181]                         }
[11:01:36.181]                       }
[11:01:36.181]                       invisible(muffled)
[11:01:36.181]                     }
[11:01:36.181]                     muffleCondition(cond, pattern = "^muffle")
[11:01:36.181]                   }
[11:01:36.181]                 }
[11:01:36.181]             }
[11:01:36.181]         }))
[11:01:36.181]     }, error = function(ex) {
[11:01:36.181]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:36.181]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:36.181]                 ...future.rng), started = ...future.startTime, 
[11:01:36.181]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:36.181]             version = "1.8"), class = "FutureResult")
[11:01:36.181]     }, finally = {
[11:01:36.181]         if (!identical(...future.workdir, getwd())) 
[11:01:36.181]             setwd(...future.workdir)
[11:01:36.181]         {
[11:01:36.181]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:36.181]                 ...future.oldOptions$nwarnings <- NULL
[11:01:36.181]             }
[11:01:36.181]             base::options(...future.oldOptions)
[11:01:36.181]             if (.Platform$OS.type == "windows") {
[11:01:36.181]                 old_names <- names(...future.oldEnvVars)
[11:01:36.181]                 envs <- base::Sys.getenv()
[11:01:36.181]                 names <- names(envs)
[11:01:36.181]                 common <- intersect(names, old_names)
[11:01:36.181]                 added <- setdiff(names, old_names)
[11:01:36.181]                 removed <- setdiff(old_names, names)
[11:01:36.181]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:36.181]                   envs[common]]
[11:01:36.181]                 NAMES <- toupper(changed)
[11:01:36.181]                 args <- list()
[11:01:36.181]                 for (kk in seq_along(NAMES)) {
[11:01:36.181]                   name <- changed[[kk]]
[11:01:36.181]                   NAME <- NAMES[[kk]]
[11:01:36.181]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.181]                     next
[11:01:36.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:36.181]                 }
[11:01:36.181]                 NAMES <- toupper(added)
[11:01:36.181]                 for (kk in seq_along(NAMES)) {
[11:01:36.181]                   name <- added[[kk]]
[11:01:36.181]                   NAME <- NAMES[[kk]]
[11:01:36.181]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.181]                     next
[11:01:36.181]                   args[[name]] <- ""
[11:01:36.181]                 }
[11:01:36.181]                 NAMES <- toupper(removed)
[11:01:36.181]                 for (kk in seq_along(NAMES)) {
[11:01:36.181]                   name <- removed[[kk]]
[11:01:36.181]                   NAME <- NAMES[[kk]]
[11:01:36.181]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.181]                     next
[11:01:36.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:36.181]                 }
[11:01:36.181]                 if (length(args) > 0) 
[11:01:36.181]                   base::do.call(base::Sys.setenv, args = args)
[11:01:36.181]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:36.181]             }
[11:01:36.181]             else {
[11:01:36.181]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:36.181]             }
[11:01:36.181]             {
[11:01:36.181]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:36.181]                   0L) {
[11:01:36.181]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:36.181]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:36.181]                   base::options(opts)
[11:01:36.181]                 }
[11:01:36.181]                 {
[11:01:36.181]                   {
[11:01:36.181]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:36.181]                     NULL
[11:01:36.181]                   }
[11:01:36.181]                   options(future.plan = NULL)
[11:01:36.181]                   if (is.na(NA_character_)) 
[11:01:36.181]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:36.181]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:36.181]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:36.181]                     .init = FALSE)
[11:01:36.181]                 }
[11:01:36.181]             }
[11:01:36.181]         }
[11:01:36.181]     })
[11:01:36.181]     if (TRUE) {
[11:01:36.181]         base::sink(type = "output", split = FALSE)
[11:01:36.181]         if (TRUE) {
[11:01:36.181]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:36.181]         }
[11:01:36.181]         else {
[11:01:36.181]             ...future.result["stdout"] <- base::list(NULL)
[11:01:36.181]         }
[11:01:36.181]         base::close(...future.stdout)
[11:01:36.181]         ...future.stdout <- NULL
[11:01:36.181]     }
[11:01:36.181]     ...future.result$conditions <- ...future.conditions
[11:01:36.181]     ...future.result$finished <- base::Sys.time()
[11:01:36.181]     ...future.result
[11:01:36.181] }
[11:01:36.184] assign_globals() ...
[11:01:36.184] List of 3
[11:01:36.184]  $ outer_function:function (x)  
[11:01:36.184]  $ map           :function (.x, .f, ...)  
[11:01:36.184]  $ inner_function:function (x)  
[11:01:36.184]  - attr(*, "where")=List of 3
[11:01:36.184]   ..$ outer_function:<environment: R_EmptyEnv> 
[11:01:36.184]   ..$ map           :<environment: R_EmptyEnv> 
[11:01:36.184]   ..$ inner_function:<environment: R_EmptyEnv> 
[11:01:36.184]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:36.184]  - attr(*, "resolved")= logi FALSE
[11:01:36.184]  - attr(*, "total_size")= num 1254
[11:01:36.184]  - attr(*, "already-done")= logi TRUE
[11:01:36.190] - reassign environment for ‘outer_function’
[11:01:36.190] - copied ‘outer_function’ to environment
[11:01:36.190] - reassign environment for ‘map’
[11:01:36.190] - copied ‘map’ to environment
[11:01:36.190] - reassign environment for ‘inner_function’
[11:01:36.190] - copied ‘inner_function’ to environment
[11:01:36.190] assign_globals() ... done
[11:01:36.190] requestCore(): workers = 2
[11:01:36.192] MulticoreFuture started
[11:01:36.193] - Launch lazy future ... done
[11:01:36.193] run() for ‘MulticoreFuture’ ... done
[11:01:36.193] plan(): Setting new future strategy stack:
[11:01:36.193] result() for MulticoreFuture ...
[11:01:36.193] List of future strategies:
[11:01:36.193] 1. sequential:
[11:01:36.193]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:36.193]    - tweaked: FALSE
[11:01:36.193]    - call: NULL
[11:01:36.195] plan(): nbrOfWorkers() = 1
[11:01:36.197] plan(): Setting new future strategy stack:
[11:01:36.197] List of future strategies:
[11:01:36.197] 1. multicore:
[11:01:36.197]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:36.197]    - tweaked: FALSE
[11:01:36.197]    - call: plan(strategy)
[11:01:36.200] plan(): nbrOfWorkers() = 2
[11:01:36.201] result() for MulticoreFuture ...
[11:01:36.201] result() for MulticoreFuture ... done
[11:01:36.202] result() for MulticoreFuture ... done
[11:01:36.202] result() for MulticoreFuture ...
[11:01:36.202] result() for MulticoreFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
- plan('multisession') ...
[11:01:36.204] plan(): Setting new future strategy stack:
[11:01:36.204] List of future strategies:
[11:01:36.204] 1. multisession:
[11:01:36.204]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:36.204]    - tweaked: FALSE
[11:01:36.204]    - call: plan(strategy)
[11:01:36.205] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[11:01:36.205] multisession:
[11:01:36.205] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:36.205] - tweaked: FALSE
[11:01:36.205] - call: plan(strategy)
[11:01:36.209] getGlobalsAndPackages() ...
[11:01:36.210] Not searching for globals
[11:01:36.210] - globals: [0] <none>
[11:01:36.210] getGlobalsAndPackages() ... DONE
[11:01:36.686] Packages needed by the future expression (n = 0): <none>
[11:01:36.686] Packages needed by future strategies (n = 0): <none>
[11:01:36.686] {
[11:01:36.686]     {
[11:01:36.686]         {
[11:01:36.686]             ...future.startTime <- base::Sys.time()
[11:01:36.686]             {
[11:01:36.686]                 {
[11:01:36.686]                   {
[11:01:36.686]                     {
[11:01:36.686]                       base::local({
[11:01:36.686]                         has_future <- base::requireNamespace("future", 
[11:01:36.686]                           quietly = TRUE)
[11:01:36.686]                         if (has_future) {
[11:01:36.686]                           ns <- base::getNamespace("future")
[11:01:36.686]                           version <- ns[[".package"]][["version"]]
[11:01:36.686]                           if (is.null(version)) 
[11:01:36.686]                             version <- utils::packageVersion("future")
[11:01:36.686]                         }
[11:01:36.686]                         else {
[11:01:36.686]                           version <- NULL
[11:01:36.686]                         }
[11:01:36.686]                         if (!has_future || version < "1.8.0") {
[11:01:36.686]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:36.686]                             "", base::R.version$version.string), 
[11:01:36.686]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:36.686]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:36.686]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:36.686]                               "release", "version")], collapse = " "), 
[11:01:36.686]                             hostname = base::Sys.info()[["nodename"]])
[11:01:36.686]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:36.686]                             info)
[11:01:36.686]                           info <- base::paste(info, collapse = "; ")
[11:01:36.686]                           if (!has_future) {
[11:01:36.686]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:36.686]                               info)
[11:01:36.686]                           }
[11:01:36.686]                           else {
[11:01:36.686]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:36.686]                               info, version)
[11:01:36.686]                           }
[11:01:36.686]                           base::stop(msg)
[11:01:36.686]                         }
[11:01:36.686]                       })
[11:01:36.686]                     }
[11:01:36.686]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:36.686]                     base::options(mc.cores = 1L)
[11:01:36.686]                   }
[11:01:36.686]                   ...future.strategy.old <- future::plan("list")
[11:01:36.686]                   options(future.plan = NULL)
[11:01:36.686]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:36.686]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:36.686]                 }
[11:01:36.686]                 ...future.workdir <- getwd()
[11:01:36.686]             }
[11:01:36.686]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:36.686]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:36.686]         }
[11:01:36.686]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:36.686]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:36.686]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:36.686]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:36.686]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:36.686]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:36.686]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:36.686]             base::names(...future.oldOptions))
[11:01:36.686]     }
[11:01:36.686]     if (FALSE) {
[11:01:36.686]     }
[11:01:36.686]     else {
[11:01:36.686]         if (TRUE) {
[11:01:36.686]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:36.686]                 open = "w")
[11:01:36.686]         }
[11:01:36.686]         else {
[11:01:36.686]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:36.686]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:36.686]         }
[11:01:36.686]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:36.686]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:36.686]             base::sink(type = "output", split = FALSE)
[11:01:36.686]             base::close(...future.stdout)
[11:01:36.686]         }, add = TRUE)
[11:01:36.686]     }
[11:01:36.686]     ...future.frame <- base::sys.nframe()
[11:01:36.686]     ...future.conditions <- base::list()
[11:01:36.686]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:36.686]     if (FALSE) {
[11:01:36.686]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:36.686]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:36.686]     }
[11:01:36.686]     ...future.result <- base::tryCatch({
[11:01:36.686]         base::withCallingHandlers({
[11:01:36.686]             ...future.value <- base::withVisible(base::local({
[11:01:36.686]                 ...future.makeSendCondition <- base::local({
[11:01:36.686]                   sendCondition <- NULL
[11:01:36.686]                   function(frame = 1L) {
[11:01:36.686]                     if (is.function(sendCondition)) 
[11:01:36.686]                       return(sendCondition)
[11:01:36.686]                     ns <- getNamespace("parallel")
[11:01:36.686]                     if (exists("sendData", mode = "function", 
[11:01:36.686]                       envir = ns)) {
[11:01:36.686]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:36.686]                         envir = ns)
[11:01:36.686]                       envir <- sys.frame(frame)
[11:01:36.686]                       master <- NULL
[11:01:36.686]                       while (!identical(envir, .GlobalEnv) && 
[11:01:36.686]                         !identical(envir, emptyenv())) {
[11:01:36.686]                         if (exists("master", mode = "list", envir = envir, 
[11:01:36.686]                           inherits = FALSE)) {
[11:01:36.686]                           master <- get("master", mode = "list", 
[11:01:36.686]                             envir = envir, inherits = FALSE)
[11:01:36.686]                           if (inherits(master, c("SOCKnode", 
[11:01:36.686]                             "SOCK0node"))) {
[11:01:36.686]                             sendCondition <<- function(cond) {
[11:01:36.686]                               data <- list(type = "VALUE", value = cond, 
[11:01:36.686]                                 success = TRUE)
[11:01:36.686]                               parallel_sendData(master, data)
[11:01:36.686]                             }
[11:01:36.686]                             return(sendCondition)
[11:01:36.686]                           }
[11:01:36.686]                         }
[11:01:36.686]                         frame <- frame + 1L
[11:01:36.686]                         envir <- sys.frame(frame)
[11:01:36.686]                       }
[11:01:36.686]                     }
[11:01:36.686]                     sendCondition <<- function(cond) NULL
[11:01:36.686]                   }
[11:01:36.686]                 })
[11:01:36.686]                 withCallingHandlers({
[11:01:36.686]                   NA
[11:01:36.686]                 }, immediateCondition = function(cond) {
[11:01:36.686]                   sendCondition <- ...future.makeSendCondition()
[11:01:36.686]                   sendCondition(cond)
[11:01:36.686]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.686]                   {
[11:01:36.686]                     inherits <- base::inherits
[11:01:36.686]                     invokeRestart <- base::invokeRestart
[11:01:36.686]                     is.null <- base::is.null
[11:01:36.686]                     muffled <- FALSE
[11:01:36.686]                     if (inherits(cond, "message")) {
[11:01:36.686]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:36.686]                       if (muffled) 
[11:01:36.686]                         invokeRestart("muffleMessage")
[11:01:36.686]                     }
[11:01:36.686]                     else if (inherits(cond, "warning")) {
[11:01:36.686]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:36.686]                       if (muffled) 
[11:01:36.686]                         invokeRestart("muffleWarning")
[11:01:36.686]                     }
[11:01:36.686]                     else if (inherits(cond, "condition")) {
[11:01:36.686]                       if (!is.null(pattern)) {
[11:01:36.686]                         computeRestarts <- base::computeRestarts
[11:01:36.686]                         grepl <- base::grepl
[11:01:36.686]                         restarts <- computeRestarts(cond)
[11:01:36.686]                         for (restart in restarts) {
[11:01:36.686]                           name <- restart$name
[11:01:36.686]                           if (is.null(name)) 
[11:01:36.686]                             next
[11:01:36.686]                           if (!grepl(pattern, name)) 
[11:01:36.686]                             next
[11:01:36.686]                           invokeRestart(restart)
[11:01:36.686]                           muffled <- TRUE
[11:01:36.686]                           break
[11:01:36.686]                         }
[11:01:36.686]                       }
[11:01:36.686]                     }
[11:01:36.686]                     invisible(muffled)
[11:01:36.686]                   }
[11:01:36.686]                   muffleCondition(cond)
[11:01:36.686]                 })
[11:01:36.686]             }))
[11:01:36.686]             future::FutureResult(value = ...future.value$value, 
[11:01:36.686]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:36.686]                   ...future.rng), globalenv = if (FALSE) 
[11:01:36.686]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:36.686]                     ...future.globalenv.names))
[11:01:36.686]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:36.686]         }, condition = base::local({
[11:01:36.686]             c <- base::c
[11:01:36.686]             inherits <- base::inherits
[11:01:36.686]             invokeRestart <- base::invokeRestart
[11:01:36.686]             length <- base::length
[11:01:36.686]             list <- base::list
[11:01:36.686]             seq.int <- base::seq.int
[11:01:36.686]             signalCondition <- base::signalCondition
[11:01:36.686]             sys.calls <- base::sys.calls
[11:01:36.686]             `[[` <- base::`[[`
[11:01:36.686]             `+` <- base::`+`
[11:01:36.686]             `<<-` <- base::`<<-`
[11:01:36.686]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:36.686]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:36.686]                   3L)]
[11:01:36.686]             }
[11:01:36.686]             function(cond) {
[11:01:36.686]                 is_error <- inherits(cond, "error")
[11:01:36.686]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:36.686]                   NULL)
[11:01:36.686]                 if (is_error) {
[11:01:36.686]                   sessionInformation <- function() {
[11:01:36.686]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:36.686]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:36.686]                       search = base::search(), system = base::Sys.info())
[11:01:36.686]                   }
[11:01:36.686]                   ...future.conditions[[length(...future.conditions) + 
[11:01:36.686]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:36.686]                     cond$call), session = sessionInformation(), 
[11:01:36.686]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:36.686]                   signalCondition(cond)
[11:01:36.686]                 }
[11:01:36.686]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:36.686]                 "immediateCondition"))) {
[11:01:36.686]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:36.686]                   ...future.conditions[[length(...future.conditions) + 
[11:01:36.686]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:36.686]                   if (TRUE && !signal) {
[11:01:36.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.686]                     {
[11:01:36.686]                       inherits <- base::inherits
[11:01:36.686]                       invokeRestart <- base::invokeRestart
[11:01:36.686]                       is.null <- base::is.null
[11:01:36.686]                       muffled <- FALSE
[11:01:36.686]                       if (inherits(cond, "message")) {
[11:01:36.686]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:36.686]                         if (muffled) 
[11:01:36.686]                           invokeRestart("muffleMessage")
[11:01:36.686]                       }
[11:01:36.686]                       else if (inherits(cond, "warning")) {
[11:01:36.686]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:36.686]                         if (muffled) 
[11:01:36.686]                           invokeRestart("muffleWarning")
[11:01:36.686]                       }
[11:01:36.686]                       else if (inherits(cond, "condition")) {
[11:01:36.686]                         if (!is.null(pattern)) {
[11:01:36.686]                           computeRestarts <- base::computeRestarts
[11:01:36.686]                           grepl <- base::grepl
[11:01:36.686]                           restarts <- computeRestarts(cond)
[11:01:36.686]                           for (restart in restarts) {
[11:01:36.686]                             name <- restart$name
[11:01:36.686]                             if (is.null(name)) 
[11:01:36.686]                               next
[11:01:36.686]                             if (!grepl(pattern, name)) 
[11:01:36.686]                               next
[11:01:36.686]                             invokeRestart(restart)
[11:01:36.686]                             muffled <- TRUE
[11:01:36.686]                             break
[11:01:36.686]                           }
[11:01:36.686]                         }
[11:01:36.686]                       }
[11:01:36.686]                       invisible(muffled)
[11:01:36.686]                     }
[11:01:36.686]                     muffleCondition(cond, pattern = "^muffle")
[11:01:36.686]                   }
[11:01:36.686]                 }
[11:01:36.686]                 else {
[11:01:36.686]                   if (TRUE) {
[11:01:36.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.686]                     {
[11:01:36.686]                       inherits <- base::inherits
[11:01:36.686]                       invokeRestart <- base::invokeRestart
[11:01:36.686]                       is.null <- base::is.null
[11:01:36.686]                       muffled <- FALSE
[11:01:36.686]                       if (inherits(cond, "message")) {
[11:01:36.686]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:36.686]                         if (muffled) 
[11:01:36.686]                           invokeRestart("muffleMessage")
[11:01:36.686]                       }
[11:01:36.686]                       else if (inherits(cond, "warning")) {
[11:01:36.686]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:36.686]                         if (muffled) 
[11:01:36.686]                           invokeRestart("muffleWarning")
[11:01:36.686]                       }
[11:01:36.686]                       else if (inherits(cond, "condition")) {
[11:01:36.686]                         if (!is.null(pattern)) {
[11:01:36.686]                           computeRestarts <- base::computeRestarts
[11:01:36.686]                           grepl <- base::grepl
[11:01:36.686]                           restarts <- computeRestarts(cond)
[11:01:36.686]                           for (restart in restarts) {
[11:01:36.686]                             name <- restart$name
[11:01:36.686]                             if (is.null(name)) 
[11:01:36.686]                               next
[11:01:36.686]                             if (!grepl(pattern, name)) 
[11:01:36.686]                               next
[11:01:36.686]                             invokeRestart(restart)
[11:01:36.686]                             muffled <- TRUE
[11:01:36.686]                             break
[11:01:36.686]                           }
[11:01:36.686]                         }
[11:01:36.686]                       }
[11:01:36.686]                       invisible(muffled)
[11:01:36.686]                     }
[11:01:36.686]                     muffleCondition(cond, pattern = "^muffle")
[11:01:36.686]                   }
[11:01:36.686]                 }
[11:01:36.686]             }
[11:01:36.686]         }))
[11:01:36.686]     }, error = function(ex) {
[11:01:36.686]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:36.686]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:36.686]                 ...future.rng), started = ...future.startTime, 
[11:01:36.686]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:36.686]             version = "1.8"), class = "FutureResult")
[11:01:36.686]     }, finally = {
[11:01:36.686]         if (!identical(...future.workdir, getwd())) 
[11:01:36.686]             setwd(...future.workdir)
[11:01:36.686]         {
[11:01:36.686]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:36.686]                 ...future.oldOptions$nwarnings <- NULL
[11:01:36.686]             }
[11:01:36.686]             base::options(...future.oldOptions)
[11:01:36.686]             if (.Platform$OS.type == "windows") {
[11:01:36.686]                 old_names <- names(...future.oldEnvVars)
[11:01:36.686]                 envs <- base::Sys.getenv()
[11:01:36.686]                 names <- names(envs)
[11:01:36.686]                 common <- intersect(names, old_names)
[11:01:36.686]                 added <- setdiff(names, old_names)
[11:01:36.686]                 removed <- setdiff(old_names, names)
[11:01:36.686]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:36.686]                   envs[common]]
[11:01:36.686]                 NAMES <- toupper(changed)
[11:01:36.686]                 args <- list()
[11:01:36.686]                 for (kk in seq_along(NAMES)) {
[11:01:36.686]                   name <- changed[[kk]]
[11:01:36.686]                   NAME <- NAMES[[kk]]
[11:01:36.686]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.686]                     next
[11:01:36.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:36.686]                 }
[11:01:36.686]                 NAMES <- toupper(added)
[11:01:36.686]                 for (kk in seq_along(NAMES)) {
[11:01:36.686]                   name <- added[[kk]]
[11:01:36.686]                   NAME <- NAMES[[kk]]
[11:01:36.686]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.686]                     next
[11:01:36.686]                   args[[name]] <- ""
[11:01:36.686]                 }
[11:01:36.686]                 NAMES <- toupper(removed)
[11:01:36.686]                 for (kk in seq_along(NAMES)) {
[11:01:36.686]                   name <- removed[[kk]]
[11:01:36.686]                   NAME <- NAMES[[kk]]
[11:01:36.686]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.686]                     next
[11:01:36.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:36.686]                 }
[11:01:36.686]                 if (length(args) > 0) 
[11:01:36.686]                   base::do.call(base::Sys.setenv, args = args)
[11:01:36.686]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:36.686]             }
[11:01:36.686]             else {
[11:01:36.686]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:36.686]             }
[11:01:36.686]             {
[11:01:36.686]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:36.686]                   0L) {
[11:01:36.686]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:36.686]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:36.686]                   base::options(opts)
[11:01:36.686]                 }
[11:01:36.686]                 {
[11:01:36.686]                   {
[11:01:36.686]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:36.686]                     NULL
[11:01:36.686]                   }
[11:01:36.686]                   options(future.plan = NULL)
[11:01:36.686]                   if (is.na(NA_character_)) 
[11:01:36.686]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:36.686]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:36.686]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:36.686]                     .init = FALSE)
[11:01:36.686]                 }
[11:01:36.686]             }
[11:01:36.686]         }
[11:01:36.686]     })
[11:01:36.686]     if (TRUE) {
[11:01:36.686]         base::sink(type = "output", split = FALSE)
[11:01:36.686]         if (TRUE) {
[11:01:36.686]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:36.686]         }
[11:01:36.686]         else {
[11:01:36.686]             ...future.result["stdout"] <- base::list(NULL)
[11:01:36.686]         }
[11:01:36.686]         base::close(...future.stdout)
[11:01:36.686]         ...future.stdout <- NULL
[11:01:36.686]     }
[11:01:36.686]     ...future.result$conditions <- ...future.conditions
[11:01:36.686]     ...future.result$finished <- base::Sys.time()
[11:01:36.686]     ...future.result
[11:01:36.686] }
[11:01:36.738] MultisessionFuture started
[11:01:36.739] result() for ClusterFuture ...
[11:01:36.739] receiveMessageFromWorker() for ClusterFuture ...
[11:01:36.739] - Validating connection of MultisessionFuture
[11:01:36.770] - received message: FutureResult
[11:01:36.770] - Received FutureResult
[11:01:36.770] - Erased future from FutureRegistry
[11:01:36.770] result() for ClusterFuture ...
[11:01:36.770] - result already collected: FutureResult
[11:01:36.770] result() for ClusterFuture ... done
[11:01:36.770] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:36.770] result() for ClusterFuture ... done
[11:01:36.771] result() for ClusterFuture ...
[11:01:36.771] - result already collected: FutureResult
[11:01:36.771] result() for ClusterFuture ... done
[11:01:36.771] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[11:01:36.772] plan(): nbrOfWorkers() = 2
- lm(<formula>) ...
[11:01:36.773] getGlobalsAndPackages() ...
[11:01:36.773] Searching for globals...
[11:01:36.774] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[11:01:36.774] Searching for globals ... DONE
[11:01:36.774] Resolving globals: FALSE
[11:01:36.775] The total size of the 2 globals is 401 bytes (401 bytes)
[11:01:36.775] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[11:01:36.775] - globals: [2] ‘weight’, ‘group’
[11:01:36.775] - packages: [1] ‘stats’
[11:01:36.775] getGlobalsAndPackages() ... DONE
[11:01:36.776] run() for ‘Future’ ...
[11:01:36.776] - state: ‘created’
[11:01:36.776] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:36.790] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:36.790] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:36.790]   - Field: ‘node’
[11:01:36.790]   - Field: ‘label’
[11:01:36.790]   - Field: ‘local’
[11:01:36.790]   - Field: ‘owner’
[11:01:36.790]   - Field: ‘envir’
[11:01:36.790]   - Field: ‘workers’
[11:01:36.791]   - Field: ‘packages’
[11:01:36.791]   - Field: ‘gc’
[11:01:36.791]   - Field: ‘conditions’
[11:01:36.791]   - Field: ‘persistent’
[11:01:36.791]   - Field: ‘expr’
[11:01:36.791]   - Field: ‘uuid’
[11:01:36.791]   - Field: ‘seed’
[11:01:36.791]   - Field: ‘version’
[11:01:36.791]   - Field: ‘result’
[11:01:36.791]   - Field: ‘asynchronous’
[11:01:36.791]   - Field: ‘calls’
[11:01:36.791]   - Field: ‘globals’
[11:01:36.792]   - Field: ‘stdout’
[11:01:36.792]   - Field: ‘earlySignal’
[11:01:36.792]   - Field: ‘lazy’
[11:01:36.792]   - Field: ‘state’
[11:01:36.792] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:36.792] - Launch lazy future ...
[11:01:36.792] Packages needed by the future expression (n = 1): ‘stats’
[11:01:36.792] Packages needed by future strategies (n = 0): <none>
[11:01:36.793] {
[11:01:36.793]     {
[11:01:36.793]         {
[11:01:36.793]             ...future.startTime <- base::Sys.time()
[11:01:36.793]             {
[11:01:36.793]                 {
[11:01:36.793]                   {
[11:01:36.793]                     {
[11:01:36.793]                       {
[11:01:36.793]                         base::local({
[11:01:36.793]                           has_future <- base::requireNamespace("future", 
[11:01:36.793]                             quietly = TRUE)
[11:01:36.793]                           if (has_future) {
[11:01:36.793]                             ns <- base::getNamespace("future")
[11:01:36.793]                             version <- ns[[".package"]][["version"]]
[11:01:36.793]                             if (is.null(version)) 
[11:01:36.793]                               version <- utils::packageVersion("future")
[11:01:36.793]                           }
[11:01:36.793]                           else {
[11:01:36.793]                             version <- NULL
[11:01:36.793]                           }
[11:01:36.793]                           if (!has_future || version < "1.8.0") {
[11:01:36.793]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:36.793]                               "", base::R.version$version.string), 
[11:01:36.793]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:36.793]                                 base::R.version$platform, 8 * 
[11:01:36.793]                                   base::.Machine$sizeof.pointer), 
[11:01:36.793]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:36.793]                                 "release", "version")], collapse = " "), 
[11:01:36.793]                               hostname = base::Sys.info()[["nodename"]])
[11:01:36.793]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:36.793]                               info)
[11:01:36.793]                             info <- base::paste(info, collapse = "; ")
[11:01:36.793]                             if (!has_future) {
[11:01:36.793]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:36.793]                                 info)
[11:01:36.793]                             }
[11:01:36.793]                             else {
[11:01:36.793]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:36.793]                                 info, version)
[11:01:36.793]                             }
[11:01:36.793]                             base::stop(msg)
[11:01:36.793]                           }
[11:01:36.793]                         })
[11:01:36.793]                       }
[11:01:36.793]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:36.793]                       base::options(mc.cores = 1L)
[11:01:36.793]                     }
[11:01:36.793]                     base::local({
[11:01:36.793]                       for (pkg in "stats") {
[11:01:36.793]                         base::loadNamespace(pkg)
[11:01:36.793]                         base::library(pkg, character.only = TRUE)
[11:01:36.793]                       }
[11:01:36.793]                     })
[11:01:36.793]                   }
[11:01:36.793]                   ...future.strategy.old <- future::plan("list")
[11:01:36.793]                   options(future.plan = NULL)
[11:01:36.793]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:36.793]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:36.793]                 }
[11:01:36.793]                 ...future.workdir <- getwd()
[11:01:36.793]             }
[11:01:36.793]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:36.793]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:36.793]         }
[11:01:36.793]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:36.793]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:36.793]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:36.793]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:36.793]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:36.793]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:36.793]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:36.793]             base::names(...future.oldOptions))
[11:01:36.793]     }
[11:01:36.793]     if (FALSE) {
[11:01:36.793]     }
[11:01:36.793]     else {
[11:01:36.793]         if (TRUE) {
[11:01:36.793]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:36.793]                 open = "w")
[11:01:36.793]         }
[11:01:36.793]         else {
[11:01:36.793]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:36.793]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:36.793]         }
[11:01:36.793]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:36.793]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:36.793]             base::sink(type = "output", split = FALSE)
[11:01:36.793]             base::close(...future.stdout)
[11:01:36.793]         }, add = TRUE)
[11:01:36.793]     }
[11:01:36.793]     ...future.frame <- base::sys.nframe()
[11:01:36.793]     ...future.conditions <- base::list()
[11:01:36.793]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:36.793]     if (FALSE) {
[11:01:36.793]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:36.793]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:36.793]     }
[11:01:36.793]     ...future.result <- base::tryCatch({
[11:01:36.793]         base::withCallingHandlers({
[11:01:36.793]             ...future.value <- base::withVisible(base::local({
[11:01:36.793]                 ...future.makeSendCondition <- base::local({
[11:01:36.793]                   sendCondition <- NULL
[11:01:36.793]                   function(frame = 1L) {
[11:01:36.793]                     if (is.function(sendCondition)) 
[11:01:36.793]                       return(sendCondition)
[11:01:36.793]                     ns <- getNamespace("parallel")
[11:01:36.793]                     if (exists("sendData", mode = "function", 
[11:01:36.793]                       envir = ns)) {
[11:01:36.793]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:36.793]                         envir = ns)
[11:01:36.793]                       envir <- sys.frame(frame)
[11:01:36.793]                       master <- NULL
[11:01:36.793]                       while (!identical(envir, .GlobalEnv) && 
[11:01:36.793]                         !identical(envir, emptyenv())) {
[11:01:36.793]                         if (exists("master", mode = "list", envir = envir, 
[11:01:36.793]                           inherits = FALSE)) {
[11:01:36.793]                           master <- get("master", mode = "list", 
[11:01:36.793]                             envir = envir, inherits = FALSE)
[11:01:36.793]                           if (inherits(master, c("SOCKnode", 
[11:01:36.793]                             "SOCK0node"))) {
[11:01:36.793]                             sendCondition <<- function(cond) {
[11:01:36.793]                               data <- list(type = "VALUE", value = cond, 
[11:01:36.793]                                 success = TRUE)
[11:01:36.793]                               parallel_sendData(master, data)
[11:01:36.793]                             }
[11:01:36.793]                             return(sendCondition)
[11:01:36.793]                           }
[11:01:36.793]                         }
[11:01:36.793]                         frame <- frame + 1L
[11:01:36.793]                         envir <- sys.frame(frame)
[11:01:36.793]                       }
[11:01:36.793]                     }
[11:01:36.793]                     sendCondition <<- function(cond) NULL
[11:01:36.793]                   }
[11:01:36.793]                 })
[11:01:36.793]                 withCallingHandlers({
[11:01:36.793]                   {
[11:01:36.793]                     lm(weight ~ group - 1)
[11:01:36.793]                   }
[11:01:36.793]                 }, immediateCondition = function(cond) {
[11:01:36.793]                   sendCondition <- ...future.makeSendCondition()
[11:01:36.793]                   sendCondition(cond)
[11:01:36.793]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.793]                   {
[11:01:36.793]                     inherits <- base::inherits
[11:01:36.793]                     invokeRestart <- base::invokeRestart
[11:01:36.793]                     is.null <- base::is.null
[11:01:36.793]                     muffled <- FALSE
[11:01:36.793]                     if (inherits(cond, "message")) {
[11:01:36.793]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:36.793]                       if (muffled) 
[11:01:36.793]                         invokeRestart("muffleMessage")
[11:01:36.793]                     }
[11:01:36.793]                     else if (inherits(cond, "warning")) {
[11:01:36.793]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:36.793]                       if (muffled) 
[11:01:36.793]                         invokeRestart("muffleWarning")
[11:01:36.793]                     }
[11:01:36.793]                     else if (inherits(cond, "condition")) {
[11:01:36.793]                       if (!is.null(pattern)) {
[11:01:36.793]                         computeRestarts <- base::computeRestarts
[11:01:36.793]                         grepl <- base::grepl
[11:01:36.793]                         restarts <- computeRestarts(cond)
[11:01:36.793]                         for (restart in restarts) {
[11:01:36.793]                           name <- restart$name
[11:01:36.793]                           if (is.null(name)) 
[11:01:36.793]                             next
[11:01:36.793]                           if (!grepl(pattern, name)) 
[11:01:36.793]                             next
[11:01:36.793]                           invokeRestart(restart)
[11:01:36.793]                           muffled <- TRUE
[11:01:36.793]                           break
[11:01:36.793]                         }
[11:01:36.793]                       }
[11:01:36.793]                     }
[11:01:36.793]                     invisible(muffled)
[11:01:36.793]                   }
[11:01:36.793]                   muffleCondition(cond)
[11:01:36.793]                 })
[11:01:36.793]             }))
[11:01:36.793]             future::FutureResult(value = ...future.value$value, 
[11:01:36.793]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:36.793]                   ...future.rng), globalenv = if (FALSE) 
[11:01:36.793]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:36.793]                     ...future.globalenv.names))
[11:01:36.793]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:36.793]         }, condition = base::local({
[11:01:36.793]             c <- base::c
[11:01:36.793]             inherits <- base::inherits
[11:01:36.793]             invokeRestart <- base::invokeRestart
[11:01:36.793]             length <- base::length
[11:01:36.793]             list <- base::list
[11:01:36.793]             seq.int <- base::seq.int
[11:01:36.793]             signalCondition <- base::signalCondition
[11:01:36.793]             sys.calls <- base::sys.calls
[11:01:36.793]             `[[` <- base::`[[`
[11:01:36.793]             `+` <- base::`+`
[11:01:36.793]             `<<-` <- base::`<<-`
[11:01:36.793]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:36.793]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:36.793]                   3L)]
[11:01:36.793]             }
[11:01:36.793]             function(cond) {
[11:01:36.793]                 is_error <- inherits(cond, "error")
[11:01:36.793]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:36.793]                   NULL)
[11:01:36.793]                 if (is_error) {
[11:01:36.793]                   sessionInformation <- function() {
[11:01:36.793]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:36.793]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:36.793]                       search = base::search(), system = base::Sys.info())
[11:01:36.793]                   }
[11:01:36.793]                   ...future.conditions[[length(...future.conditions) + 
[11:01:36.793]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:36.793]                     cond$call), session = sessionInformation(), 
[11:01:36.793]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:36.793]                   signalCondition(cond)
[11:01:36.793]                 }
[11:01:36.793]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:36.793]                 "immediateCondition"))) {
[11:01:36.793]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:36.793]                   ...future.conditions[[length(...future.conditions) + 
[11:01:36.793]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:36.793]                   if (TRUE && !signal) {
[11:01:36.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.793]                     {
[11:01:36.793]                       inherits <- base::inherits
[11:01:36.793]                       invokeRestart <- base::invokeRestart
[11:01:36.793]                       is.null <- base::is.null
[11:01:36.793]                       muffled <- FALSE
[11:01:36.793]                       if (inherits(cond, "message")) {
[11:01:36.793]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:36.793]                         if (muffled) 
[11:01:36.793]                           invokeRestart("muffleMessage")
[11:01:36.793]                       }
[11:01:36.793]                       else if (inherits(cond, "warning")) {
[11:01:36.793]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:36.793]                         if (muffled) 
[11:01:36.793]                           invokeRestart("muffleWarning")
[11:01:36.793]                       }
[11:01:36.793]                       else if (inherits(cond, "condition")) {
[11:01:36.793]                         if (!is.null(pattern)) {
[11:01:36.793]                           computeRestarts <- base::computeRestarts
[11:01:36.793]                           grepl <- base::grepl
[11:01:36.793]                           restarts <- computeRestarts(cond)
[11:01:36.793]                           for (restart in restarts) {
[11:01:36.793]                             name <- restart$name
[11:01:36.793]                             if (is.null(name)) 
[11:01:36.793]                               next
[11:01:36.793]                             if (!grepl(pattern, name)) 
[11:01:36.793]                               next
[11:01:36.793]                             invokeRestart(restart)
[11:01:36.793]                             muffled <- TRUE
[11:01:36.793]                             break
[11:01:36.793]                           }
[11:01:36.793]                         }
[11:01:36.793]                       }
[11:01:36.793]                       invisible(muffled)
[11:01:36.793]                     }
[11:01:36.793]                     muffleCondition(cond, pattern = "^muffle")
[11:01:36.793]                   }
[11:01:36.793]                 }
[11:01:36.793]                 else {
[11:01:36.793]                   if (TRUE) {
[11:01:36.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.793]                     {
[11:01:36.793]                       inherits <- base::inherits
[11:01:36.793]                       invokeRestart <- base::invokeRestart
[11:01:36.793]                       is.null <- base::is.null
[11:01:36.793]                       muffled <- FALSE
[11:01:36.793]                       if (inherits(cond, "message")) {
[11:01:36.793]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:36.793]                         if (muffled) 
[11:01:36.793]                           invokeRestart("muffleMessage")
[11:01:36.793]                       }
[11:01:36.793]                       else if (inherits(cond, "warning")) {
[11:01:36.793]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:36.793]                         if (muffled) 
[11:01:36.793]                           invokeRestart("muffleWarning")
[11:01:36.793]                       }
[11:01:36.793]                       else if (inherits(cond, "condition")) {
[11:01:36.793]                         if (!is.null(pattern)) {
[11:01:36.793]                           computeRestarts <- base::computeRestarts
[11:01:36.793]                           grepl <- base::grepl
[11:01:36.793]                           restarts <- computeRestarts(cond)
[11:01:36.793]                           for (restart in restarts) {
[11:01:36.793]                             name <- restart$name
[11:01:36.793]                             if (is.null(name)) 
[11:01:36.793]                               next
[11:01:36.793]                             if (!grepl(pattern, name)) 
[11:01:36.793]                               next
[11:01:36.793]                             invokeRestart(restart)
[11:01:36.793]                             muffled <- TRUE
[11:01:36.793]                             break
[11:01:36.793]                           }
[11:01:36.793]                         }
[11:01:36.793]                       }
[11:01:36.793]                       invisible(muffled)
[11:01:36.793]                     }
[11:01:36.793]                     muffleCondition(cond, pattern = "^muffle")
[11:01:36.793]                   }
[11:01:36.793]                 }
[11:01:36.793]             }
[11:01:36.793]         }))
[11:01:36.793]     }, error = function(ex) {
[11:01:36.793]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:36.793]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:36.793]                 ...future.rng), started = ...future.startTime, 
[11:01:36.793]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:36.793]             version = "1.8"), class = "FutureResult")
[11:01:36.793]     }, finally = {
[11:01:36.793]         if (!identical(...future.workdir, getwd())) 
[11:01:36.793]             setwd(...future.workdir)
[11:01:36.793]         {
[11:01:36.793]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:36.793]                 ...future.oldOptions$nwarnings <- NULL
[11:01:36.793]             }
[11:01:36.793]             base::options(...future.oldOptions)
[11:01:36.793]             if (.Platform$OS.type == "windows") {
[11:01:36.793]                 old_names <- names(...future.oldEnvVars)
[11:01:36.793]                 envs <- base::Sys.getenv()
[11:01:36.793]                 names <- names(envs)
[11:01:36.793]                 common <- intersect(names, old_names)
[11:01:36.793]                 added <- setdiff(names, old_names)
[11:01:36.793]                 removed <- setdiff(old_names, names)
[11:01:36.793]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:36.793]                   envs[common]]
[11:01:36.793]                 NAMES <- toupper(changed)
[11:01:36.793]                 args <- list()
[11:01:36.793]                 for (kk in seq_along(NAMES)) {
[11:01:36.793]                   name <- changed[[kk]]
[11:01:36.793]                   NAME <- NAMES[[kk]]
[11:01:36.793]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.793]                     next
[11:01:36.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:36.793]                 }
[11:01:36.793]                 NAMES <- toupper(added)
[11:01:36.793]                 for (kk in seq_along(NAMES)) {
[11:01:36.793]                   name <- added[[kk]]
[11:01:36.793]                   NAME <- NAMES[[kk]]
[11:01:36.793]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.793]                     next
[11:01:36.793]                   args[[name]] <- ""
[11:01:36.793]                 }
[11:01:36.793]                 NAMES <- toupper(removed)
[11:01:36.793]                 for (kk in seq_along(NAMES)) {
[11:01:36.793]                   name <- removed[[kk]]
[11:01:36.793]                   NAME <- NAMES[[kk]]
[11:01:36.793]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.793]                     next
[11:01:36.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:36.793]                 }
[11:01:36.793]                 if (length(args) > 0) 
[11:01:36.793]                   base::do.call(base::Sys.setenv, args = args)
[11:01:36.793]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:36.793]             }
[11:01:36.793]             else {
[11:01:36.793]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:36.793]             }
[11:01:36.793]             {
[11:01:36.793]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:36.793]                   0L) {
[11:01:36.793]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:36.793]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:36.793]                   base::options(opts)
[11:01:36.793]                 }
[11:01:36.793]                 {
[11:01:36.793]                   {
[11:01:36.793]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:36.793]                     NULL
[11:01:36.793]                   }
[11:01:36.793]                   options(future.plan = NULL)
[11:01:36.793]                   if (is.na(NA_character_)) 
[11:01:36.793]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:36.793]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:36.793]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:36.793]                     .init = FALSE)
[11:01:36.793]                 }
[11:01:36.793]             }
[11:01:36.793]         }
[11:01:36.793]     })
[11:01:36.793]     if (TRUE) {
[11:01:36.793]         base::sink(type = "output", split = FALSE)
[11:01:36.793]         if (TRUE) {
[11:01:36.793]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:36.793]         }
[11:01:36.793]         else {
[11:01:36.793]             ...future.result["stdout"] <- base::list(NULL)
[11:01:36.793]         }
[11:01:36.793]         base::close(...future.stdout)
[11:01:36.793]         ...future.stdout <- NULL
[11:01:36.793]     }
[11:01:36.793]     ...future.result$conditions <- ...future.conditions
[11:01:36.793]     ...future.result$finished <- base::Sys.time()
[11:01:36.793]     ...future.result
[11:01:36.793] }
[11:01:36.795] Exporting 2 global objects (712 bytes) to cluster node #1 ...
[11:01:36.796] Exporting ‘weight’ (191 bytes) to cluster node #1 ...
[11:01:36.796] Exporting ‘weight’ (191 bytes) to cluster node #1 ... DONE
[11:01:36.796] Exporting ‘group’ (210 bytes) to cluster node #1 ...
[11:01:36.796] Exporting ‘group’ (210 bytes) to cluster node #1 ... DONE
[11:01:36.797] Exporting 2 global objects (712 bytes) to cluster node #1 ... DONE
[11:01:36.797] MultisessionFuture started
[11:01:36.797] - Launch lazy future ... done
[11:01:36.797] run() for ‘MultisessionFuture’ ... done
[11:01:36.797] result() for ClusterFuture ...
[11:01:36.797] receiveMessageFromWorker() for ClusterFuture ...
[11:01:36.798] - Validating connection of MultisessionFuture
[11:01:36.845] - received message: FutureResult
[11:01:36.845] - Received FutureResult
[11:01:36.845] - Erased future from FutureRegistry
[11:01:36.845] result() for ClusterFuture ...
[11:01:36.845] - result already collected: FutureResult
[11:01:36.845] result() for ClusterFuture ... done
[11:01:36.845] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:36.845] result() for ClusterFuture ... done
[11:01:36.846] result() for ClusterFuture ...
[11:01:36.846] - result already collected: FutureResult
[11:01:36.846] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[11:01:36.847] getGlobalsAndPackages() ...
[11:01:36.848] Searching for globals...
[11:01:36.849] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[11:01:36.849] Searching for globals ... DONE
[11:01:36.849] Resolving globals: FALSE
[11:01:36.850] The total size of the 2 globals is 401 bytes (401 bytes)
[11:01:36.850] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[11:01:36.851] - globals: [2] ‘weight’, ‘group’
[11:01:36.851] - packages: [1] ‘stats’
[11:01:36.851] getGlobalsAndPackages() ... DONE
[11:01:36.851] run() for ‘Future’ ...
[11:01:36.851] - state: ‘created’
[11:01:36.851] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:36.866] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:36.866] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:36.866]   - Field: ‘node’
[11:01:36.866]   - Field: ‘label’
[11:01:36.866]   - Field: ‘local’
[11:01:36.866]   - Field: ‘owner’
[11:01:36.867]   - Field: ‘envir’
[11:01:36.867]   - Field: ‘workers’
[11:01:36.867]   - Field: ‘packages’
[11:01:36.867]   - Field: ‘gc’
[11:01:36.867]   - Field: ‘conditions’
[11:01:36.867]   - Field: ‘persistent’
[11:01:36.867]   - Field: ‘expr’
[11:01:36.867]   - Field: ‘uuid’
[11:01:36.867]   - Field: ‘seed’
[11:01:36.867]   - Field: ‘version’
[11:01:36.868]   - Field: ‘result’
[11:01:36.868]   - Field: ‘asynchronous’
[11:01:36.868]   - Field: ‘calls’
[11:01:36.868]   - Field: ‘globals’
[11:01:36.868]   - Field: ‘stdout’
[11:01:36.868]   - Field: ‘earlySignal’
[11:01:36.868]   - Field: ‘lazy’
[11:01:36.868]   - Field: ‘state’
[11:01:36.868] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:36.869] - Launch lazy future ...
[11:01:36.869] Packages needed by the future expression (n = 1): ‘stats’
[11:01:36.869] Packages needed by future strategies (n = 0): <none>
[11:01:36.870] {
[11:01:36.870]     {
[11:01:36.870]         {
[11:01:36.870]             ...future.startTime <- base::Sys.time()
[11:01:36.870]             {
[11:01:36.870]                 {
[11:01:36.870]                   {
[11:01:36.870]                     {
[11:01:36.870]                       {
[11:01:36.870]                         base::local({
[11:01:36.870]                           has_future <- base::requireNamespace("future", 
[11:01:36.870]                             quietly = TRUE)
[11:01:36.870]                           if (has_future) {
[11:01:36.870]                             ns <- base::getNamespace("future")
[11:01:36.870]                             version <- ns[[".package"]][["version"]]
[11:01:36.870]                             if (is.null(version)) 
[11:01:36.870]                               version <- utils::packageVersion("future")
[11:01:36.870]                           }
[11:01:36.870]                           else {
[11:01:36.870]                             version <- NULL
[11:01:36.870]                           }
[11:01:36.870]                           if (!has_future || version < "1.8.0") {
[11:01:36.870]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:36.870]                               "", base::R.version$version.string), 
[11:01:36.870]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:36.870]                                 base::R.version$platform, 8 * 
[11:01:36.870]                                   base::.Machine$sizeof.pointer), 
[11:01:36.870]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:36.870]                                 "release", "version")], collapse = " "), 
[11:01:36.870]                               hostname = base::Sys.info()[["nodename"]])
[11:01:36.870]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:36.870]                               info)
[11:01:36.870]                             info <- base::paste(info, collapse = "; ")
[11:01:36.870]                             if (!has_future) {
[11:01:36.870]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:36.870]                                 info)
[11:01:36.870]                             }
[11:01:36.870]                             else {
[11:01:36.870]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:36.870]                                 info, version)
[11:01:36.870]                             }
[11:01:36.870]                             base::stop(msg)
[11:01:36.870]                           }
[11:01:36.870]                         })
[11:01:36.870]                       }
[11:01:36.870]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:36.870]                       base::options(mc.cores = 1L)
[11:01:36.870]                     }
[11:01:36.870]                     base::local({
[11:01:36.870]                       for (pkg in "stats") {
[11:01:36.870]                         base::loadNamespace(pkg)
[11:01:36.870]                         base::library(pkg, character.only = TRUE)
[11:01:36.870]                       }
[11:01:36.870]                     })
[11:01:36.870]                   }
[11:01:36.870]                   ...future.strategy.old <- future::plan("list")
[11:01:36.870]                   options(future.plan = NULL)
[11:01:36.870]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:36.870]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:36.870]                 }
[11:01:36.870]                 ...future.workdir <- getwd()
[11:01:36.870]             }
[11:01:36.870]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:36.870]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:36.870]         }
[11:01:36.870]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:36.870]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:36.870]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:36.870]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:36.870]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:36.870]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:36.870]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:36.870]             base::names(...future.oldOptions))
[11:01:36.870]     }
[11:01:36.870]     if (FALSE) {
[11:01:36.870]     }
[11:01:36.870]     else {
[11:01:36.870]         if (TRUE) {
[11:01:36.870]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:36.870]                 open = "w")
[11:01:36.870]         }
[11:01:36.870]         else {
[11:01:36.870]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:36.870]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:36.870]         }
[11:01:36.870]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:36.870]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:36.870]             base::sink(type = "output", split = FALSE)
[11:01:36.870]             base::close(...future.stdout)
[11:01:36.870]         }, add = TRUE)
[11:01:36.870]     }
[11:01:36.870]     ...future.frame <- base::sys.nframe()
[11:01:36.870]     ...future.conditions <- base::list()
[11:01:36.870]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:36.870]     if (FALSE) {
[11:01:36.870]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:36.870]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:36.870]     }
[11:01:36.870]     ...future.result <- base::tryCatch({
[11:01:36.870]         base::withCallingHandlers({
[11:01:36.870]             ...future.value <- base::withVisible(base::local({
[11:01:36.870]                 ...future.makeSendCondition <- base::local({
[11:01:36.870]                   sendCondition <- NULL
[11:01:36.870]                   function(frame = 1L) {
[11:01:36.870]                     if (is.function(sendCondition)) 
[11:01:36.870]                       return(sendCondition)
[11:01:36.870]                     ns <- getNamespace("parallel")
[11:01:36.870]                     if (exists("sendData", mode = "function", 
[11:01:36.870]                       envir = ns)) {
[11:01:36.870]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:36.870]                         envir = ns)
[11:01:36.870]                       envir <- sys.frame(frame)
[11:01:36.870]                       master <- NULL
[11:01:36.870]                       while (!identical(envir, .GlobalEnv) && 
[11:01:36.870]                         !identical(envir, emptyenv())) {
[11:01:36.870]                         if (exists("master", mode = "list", envir = envir, 
[11:01:36.870]                           inherits = FALSE)) {
[11:01:36.870]                           master <- get("master", mode = "list", 
[11:01:36.870]                             envir = envir, inherits = FALSE)
[11:01:36.870]                           if (inherits(master, c("SOCKnode", 
[11:01:36.870]                             "SOCK0node"))) {
[11:01:36.870]                             sendCondition <<- function(cond) {
[11:01:36.870]                               data <- list(type = "VALUE", value = cond, 
[11:01:36.870]                                 success = TRUE)
[11:01:36.870]                               parallel_sendData(master, data)
[11:01:36.870]                             }
[11:01:36.870]                             return(sendCondition)
[11:01:36.870]                           }
[11:01:36.870]                         }
[11:01:36.870]                         frame <- frame + 1L
[11:01:36.870]                         envir <- sys.frame(frame)
[11:01:36.870]                       }
[11:01:36.870]                     }
[11:01:36.870]                     sendCondition <<- function(cond) NULL
[11:01:36.870]                   }
[11:01:36.870]                 })
[11:01:36.870]                 withCallingHandlers({
[11:01:36.870]                   {
[11:01:36.870]                     lm(weight ~ group - 1)
[11:01:36.870]                   }
[11:01:36.870]                 }, immediateCondition = function(cond) {
[11:01:36.870]                   sendCondition <- ...future.makeSendCondition()
[11:01:36.870]                   sendCondition(cond)
[11:01:36.870]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.870]                   {
[11:01:36.870]                     inherits <- base::inherits
[11:01:36.870]                     invokeRestart <- base::invokeRestart
[11:01:36.870]                     is.null <- base::is.null
[11:01:36.870]                     muffled <- FALSE
[11:01:36.870]                     if (inherits(cond, "message")) {
[11:01:36.870]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:36.870]                       if (muffled) 
[11:01:36.870]                         invokeRestart("muffleMessage")
[11:01:36.870]                     }
[11:01:36.870]                     else if (inherits(cond, "warning")) {
[11:01:36.870]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:36.870]                       if (muffled) 
[11:01:36.870]                         invokeRestart("muffleWarning")
[11:01:36.870]                     }
[11:01:36.870]                     else if (inherits(cond, "condition")) {
[11:01:36.870]                       if (!is.null(pattern)) {
[11:01:36.870]                         computeRestarts <- base::computeRestarts
[11:01:36.870]                         grepl <- base::grepl
[11:01:36.870]                         restarts <- computeRestarts(cond)
[11:01:36.870]                         for (restart in restarts) {
[11:01:36.870]                           name <- restart$name
[11:01:36.870]                           if (is.null(name)) 
[11:01:36.870]                             next
[11:01:36.870]                           if (!grepl(pattern, name)) 
[11:01:36.870]                             next
[11:01:36.870]                           invokeRestart(restart)
[11:01:36.870]                           muffled <- TRUE
[11:01:36.870]                           break
[11:01:36.870]                         }
[11:01:36.870]                       }
[11:01:36.870]                     }
[11:01:36.870]                     invisible(muffled)
[11:01:36.870]                   }
[11:01:36.870]                   muffleCondition(cond)
[11:01:36.870]                 })
[11:01:36.870]             }))
[11:01:36.870]             future::FutureResult(value = ...future.value$value, 
[11:01:36.870]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:36.870]                   ...future.rng), globalenv = if (FALSE) 
[11:01:36.870]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:36.870]                     ...future.globalenv.names))
[11:01:36.870]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:36.870]         }, condition = base::local({
[11:01:36.870]             c <- base::c
[11:01:36.870]             inherits <- base::inherits
[11:01:36.870]             invokeRestart <- base::invokeRestart
[11:01:36.870]             length <- base::length
[11:01:36.870]             list <- base::list
[11:01:36.870]             seq.int <- base::seq.int
[11:01:36.870]             signalCondition <- base::signalCondition
[11:01:36.870]             sys.calls <- base::sys.calls
[11:01:36.870]             `[[` <- base::`[[`
[11:01:36.870]             `+` <- base::`+`
[11:01:36.870]             `<<-` <- base::`<<-`
[11:01:36.870]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:36.870]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:36.870]                   3L)]
[11:01:36.870]             }
[11:01:36.870]             function(cond) {
[11:01:36.870]                 is_error <- inherits(cond, "error")
[11:01:36.870]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:36.870]                   NULL)
[11:01:36.870]                 if (is_error) {
[11:01:36.870]                   sessionInformation <- function() {
[11:01:36.870]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:36.870]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:36.870]                       search = base::search(), system = base::Sys.info())
[11:01:36.870]                   }
[11:01:36.870]                   ...future.conditions[[length(...future.conditions) + 
[11:01:36.870]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:36.870]                     cond$call), session = sessionInformation(), 
[11:01:36.870]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:36.870]                   signalCondition(cond)
[11:01:36.870]                 }
[11:01:36.870]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:36.870]                 "immediateCondition"))) {
[11:01:36.870]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:36.870]                   ...future.conditions[[length(...future.conditions) + 
[11:01:36.870]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:36.870]                   if (TRUE && !signal) {
[11:01:36.870]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.870]                     {
[11:01:36.870]                       inherits <- base::inherits
[11:01:36.870]                       invokeRestart <- base::invokeRestart
[11:01:36.870]                       is.null <- base::is.null
[11:01:36.870]                       muffled <- FALSE
[11:01:36.870]                       if (inherits(cond, "message")) {
[11:01:36.870]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:36.870]                         if (muffled) 
[11:01:36.870]                           invokeRestart("muffleMessage")
[11:01:36.870]                       }
[11:01:36.870]                       else if (inherits(cond, "warning")) {
[11:01:36.870]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:36.870]                         if (muffled) 
[11:01:36.870]                           invokeRestart("muffleWarning")
[11:01:36.870]                       }
[11:01:36.870]                       else if (inherits(cond, "condition")) {
[11:01:36.870]                         if (!is.null(pattern)) {
[11:01:36.870]                           computeRestarts <- base::computeRestarts
[11:01:36.870]                           grepl <- base::grepl
[11:01:36.870]                           restarts <- computeRestarts(cond)
[11:01:36.870]                           for (restart in restarts) {
[11:01:36.870]                             name <- restart$name
[11:01:36.870]                             if (is.null(name)) 
[11:01:36.870]                               next
[11:01:36.870]                             if (!grepl(pattern, name)) 
[11:01:36.870]                               next
[11:01:36.870]                             invokeRestart(restart)
[11:01:36.870]                             muffled <- TRUE
[11:01:36.870]                             break
[11:01:36.870]                           }
[11:01:36.870]                         }
[11:01:36.870]                       }
[11:01:36.870]                       invisible(muffled)
[11:01:36.870]                     }
[11:01:36.870]                     muffleCondition(cond, pattern = "^muffle")
[11:01:36.870]                   }
[11:01:36.870]                 }
[11:01:36.870]                 else {
[11:01:36.870]                   if (TRUE) {
[11:01:36.870]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.870]                     {
[11:01:36.870]                       inherits <- base::inherits
[11:01:36.870]                       invokeRestart <- base::invokeRestart
[11:01:36.870]                       is.null <- base::is.null
[11:01:36.870]                       muffled <- FALSE
[11:01:36.870]                       if (inherits(cond, "message")) {
[11:01:36.870]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:36.870]                         if (muffled) 
[11:01:36.870]                           invokeRestart("muffleMessage")
[11:01:36.870]                       }
[11:01:36.870]                       else if (inherits(cond, "warning")) {
[11:01:36.870]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:36.870]                         if (muffled) 
[11:01:36.870]                           invokeRestart("muffleWarning")
[11:01:36.870]                       }
[11:01:36.870]                       else if (inherits(cond, "condition")) {
[11:01:36.870]                         if (!is.null(pattern)) {
[11:01:36.870]                           computeRestarts <- base::computeRestarts
[11:01:36.870]                           grepl <- base::grepl
[11:01:36.870]                           restarts <- computeRestarts(cond)
[11:01:36.870]                           for (restart in restarts) {
[11:01:36.870]                             name <- restart$name
[11:01:36.870]                             if (is.null(name)) 
[11:01:36.870]                               next
[11:01:36.870]                             if (!grepl(pattern, name)) 
[11:01:36.870]                               next
[11:01:36.870]                             invokeRestart(restart)
[11:01:36.870]                             muffled <- TRUE
[11:01:36.870]                             break
[11:01:36.870]                           }
[11:01:36.870]                         }
[11:01:36.870]                       }
[11:01:36.870]                       invisible(muffled)
[11:01:36.870]                     }
[11:01:36.870]                     muffleCondition(cond, pattern = "^muffle")
[11:01:36.870]                   }
[11:01:36.870]                 }
[11:01:36.870]             }
[11:01:36.870]         }))
[11:01:36.870]     }, error = function(ex) {
[11:01:36.870]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:36.870]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:36.870]                 ...future.rng), started = ...future.startTime, 
[11:01:36.870]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:36.870]             version = "1.8"), class = "FutureResult")
[11:01:36.870]     }, finally = {
[11:01:36.870]         if (!identical(...future.workdir, getwd())) 
[11:01:36.870]             setwd(...future.workdir)
[11:01:36.870]         {
[11:01:36.870]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:36.870]                 ...future.oldOptions$nwarnings <- NULL
[11:01:36.870]             }
[11:01:36.870]             base::options(...future.oldOptions)
[11:01:36.870]             if (.Platform$OS.type == "windows") {
[11:01:36.870]                 old_names <- names(...future.oldEnvVars)
[11:01:36.870]                 envs <- base::Sys.getenv()
[11:01:36.870]                 names <- names(envs)
[11:01:36.870]                 common <- intersect(names, old_names)
[11:01:36.870]                 added <- setdiff(names, old_names)
[11:01:36.870]                 removed <- setdiff(old_names, names)
[11:01:36.870]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:36.870]                   envs[common]]
[11:01:36.870]                 NAMES <- toupper(changed)
[11:01:36.870]                 args <- list()
[11:01:36.870]                 for (kk in seq_along(NAMES)) {
[11:01:36.870]                   name <- changed[[kk]]
[11:01:36.870]                   NAME <- NAMES[[kk]]
[11:01:36.870]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.870]                     next
[11:01:36.870]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:36.870]                 }
[11:01:36.870]                 NAMES <- toupper(added)
[11:01:36.870]                 for (kk in seq_along(NAMES)) {
[11:01:36.870]                   name <- added[[kk]]
[11:01:36.870]                   NAME <- NAMES[[kk]]
[11:01:36.870]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.870]                     next
[11:01:36.870]                   args[[name]] <- ""
[11:01:36.870]                 }
[11:01:36.870]                 NAMES <- toupper(removed)
[11:01:36.870]                 for (kk in seq_along(NAMES)) {
[11:01:36.870]                   name <- removed[[kk]]
[11:01:36.870]                   NAME <- NAMES[[kk]]
[11:01:36.870]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.870]                     next
[11:01:36.870]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:36.870]                 }
[11:01:36.870]                 if (length(args) > 0) 
[11:01:36.870]                   base::do.call(base::Sys.setenv, args = args)
[11:01:36.870]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:36.870]             }
[11:01:36.870]             else {
[11:01:36.870]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:36.870]             }
[11:01:36.870]             {
[11:01:36.870]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:36.870]                   0L) {
[11:01:36.870]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:36.870]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:36.870]                   base::options(opts)
[11:01:36.870]                 }
[11:01:36.870]                 {
[11:01:36.870]                   {
[11:01:36.870]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:36.870]                     NULL
[11:01:36.870]                   }
[11:01:36.870]                   options(future.plan = NULL)
[11:01:36.870]                   if (is.na(NA_character_)) 
[11:01:36.870]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:36.870]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:36.870]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:36.870]                     .init = FALSE)
[11:01:36.870]                 }
[11:01:36.870]             }
[11:01:36.870]         }
[11:01:36.870]     })
[11:01:36.870]     if (TRUE) {
[11:01:36.870]         base::sink(type = "output", split = FALSE)
[11:01:36.870]         if (TRUE) {
[11:01:36.870]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:36.870]         }
[11:01:36.870]         else {
[11:01:36.870]             ...future.result["stdout"] <- base::list(NULL)
[11:01:36.870]         }
[11:01:36.870]         base::close(...future.stdout)
[11:01:36.870]         ...future.stdout <- NULL
[11:01:36.870]     }
[11:01:36.870]     ...future.result$conditions <- ...future.conditions
[11:01:36.870]     ...future.result$finished <- base::Sys.time()
[11:01:36.870]     ...future.result
[11:01:36.870] }
[11:01:36.872] Exporting 2 global objects (712 bytes) to cluster node #1 ...
[11:01:36.873] Exporting ‘weight’ (191 bytes) to cluster node #1 ...
[11:01:36.873] Exporting ‘weight’ (191 bytes) to cluster node #1 ... DONE
[11:01:36.873] Exporting ‘group’ (210 bytes) to cluster node #1 ...
[11:01:36.873] Exporting ‘group’ (210 bytes) to cluster node #1 ... DONE
[11:01:36.874] Exporting 2 global objects (712 bytes) to cluster node #1 ... DONE
[11:01:36.874] MultisessionFuture started
[11:01:36.874] - Launch lazy future ... done
[11:01:36.874] run() for ‘MultisessionFuture’ ... done
[11:01:36.874] result() for ClusterFuture ...
[11:01:36.874] receiveMessageFromWorker() for ClusterFuture ...
[11:01:36.875] - Validating connection of MultisessionFuture
[11:01:36.917] - received message: FutureResult
[11:01:36.917] - Received FutureResult
[11:01:36.917] - Erased future from FutureRegistry
[11:01:36.917] result() for ClusterFuture ...
[11:01:36.918] - result already collected: FutureResult
[11:01:36.918] result() for ClusterFuture ... done
[11:01:36.918] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:36.918] result() for ClusterFuture ... done
[11:01:36.918] result() for ClusterFuture ...
[11:01:36.918] - result already collected: FutureResult
[11:01:36.918] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[11:01:36.920] getGlobalsAndPackages() ...
[11:01:36.920] Searching for globals...
[11:01:36.922] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[11:01:36.922] Searching for globals ... DONE
[11:01:36.922] Resolving globals: FALSE
[11:01:36.923] The total size of the 2 globals is 401 bytes (401 bytes)
[11:01:36.923] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[11:01:36.924] - globals: [2] ‘weight’, ‘group’
[11:01:36.924] - packages: [1] ‘stats’
[11:01:36.924] getGlobalsAndPackages() ... DONE
[11:01:36.924] run() for ‘Future’ ...
[11:01:36.924] - state: ‘created’
[11:01:36.924] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:36.939] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:36.939] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:36.939]   - Field: ‘node’
[11:01:36.939]   - Field: ‘label’
[11:01:36.939]   - Field: ‘local’
[11:01:36.939]   - Field: ‘owner’
[11:01:36.939]   - Field: ‘envir’
[11:01:36.939]   - Field: ‘workers’
[11:01:36.939]   - Field: ‘packages’
[11:01:36.940]   - Field: ‘gc’
[11:01:36.940]   - Field: ‘conditions’
[11:01:36.940]   - Field: ‘persistent’
[11:01:36.940]   - Field: ‘expr’
[11:01:36.940]   - Field: ‘uuid’
[11:01:36.940]   - Field: ‘seed’
[11:01:36.940]   - Field: ‘version’
[11:01:36.940]   - Field: ‘result’
[11:01:36.940]   - Field: ‘asynchronous’
[11:01:36.941]   - Field: ‘calls’
[11:01:36.941]   - Field: ‘globals’
[11:01:36.941]   - Field: ‘stdout’
[11:01:36.941]   - Field: ‘earlySignal’
[11:01:36.941]   - Field: ‘lazy’
[11:01:36.941]   - Field: ‘state’
[11:01:36.941] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:36.941] - Launch lazy future ...
[11:01:36.942] Packages needed by the future expression (n = 1): ‘stats’
[11:01:36.942] Packages needed by future strategies (n = 0): <none>
[11:01:36.942] {
[11:01:36.942]     {
[11:01:36.942]         {
[11:01:36.942]             ...future.startTime <- base::Sys.time()
[11:01:36.942]             {
[11:01:36.942]                 {
[11:01:36.942]                   {
[11:01:36.942]                     {
[11:01:36.942]                       {
[11:01:36.942]                         base::local({
[11:01:36.942]                           has_future <- base::requireNamespace("future", 
[11:01:36.942]                             quietly = TRUE)
[11:01:36.942]                           if (has_future) {
[11:01:36.942]                             ns <- base::getNamespace("future")
[11:01:36.942]                             version <- ns[[".package"]][["version"]]
[11:01:36.942]                             if (is.null(version)) 
[11:01:36.942]                               version <- utils::packageVersion("future")
[11:01:36.942]                           }
[11:01:36.942]                           else {
[11:01:36.942]                             version <- NULL
[11:01:36.942]                           }
[11:01:36.942]                           if (!has_future || version < "1.8.0") {
[11:01:36.942]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:36.942]                               "", base::R.version$version.string), 
[11:01:36.942]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:36.942]                                 base::R.version$platform, 8 * 
[11:01:36.942]                                   base::.Machine$sizeof.pointer), 
[11:01:36.942]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:36.942]                                 "release", "version")], collapse = " "), 
[11:01:36.942]                               hostname = base::Sys.info()[["nodename"]])
[11:01:36.942]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:36.942]                               info)
[11:01:36.942]                             info <- base::paste(info, collapse = "; ")
[11:01:36.942]                             if (!has_future) {
[11:01:36.942]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:36.942]                                 info)
[11:01:36.942]                             }
[11:01:36.942]                             else {
[11:01:36.942]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:36.942]                                 info, version)
[11:01:36.942]                             }
[11:01:36.942]                             base::stop(msg)
[11:01:36.942]                           }
[11:01:36.942]                         })
[11:01:36.942]                       }
[11:01:36.942]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:36.942]                       base::options(mc.cores = 1L)
[11:01:36.942]                     }
[11:01:36.942]                     base::local({
[11:01:36.942]                       for (pkg in "stats") {
[11:01:36.942]                         base::loadNamespace(pkg)
[11:01:36.942]                         base::library(pkg, character.only = TRUE)
[11:01:36.942]                       }
[11:01:36.942]                     })
[11:01:36.942]                   }
[11:01:36.942]                   ...future.strategy.old <- future::plan("list")
[11:01:36.942]                   options(future.plan = NULL)
[11:01:36.942]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:36.942]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:36.942]                 }
[11:01:36.942]                 ...future.workdir <- getwd()
[11:01:36.942]             }
[11:01:36.942]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:36.942]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:36.942]         }
[11:01:36.942]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:36.942]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:36.942]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:36.942]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:36.942]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:36.942]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:36.942]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:36.942]             base::names(...future.oldOptions))
[11:01:36.942]     }
[11:01:36.942]     if (FALSE) {
[11:01:36.942]     }
[11:01:36.942]     else {
[11:01:36.942]         if (TRUE) {
[11:01:36.942]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:36.942]                 open = "w")
[11:01:36.942]         }
[11:01:36.942]         else {
[11:01:36.942]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:36.942]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:36.942]         }
[11:01:36.942]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:36.942]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:36.942]             base::sink(type = "output", split = FALSE)
[11:01:36.942]             base::close(...future.stdout)
[11:01:36.942]         }, add = TRUE)
[11:01:36.942]     }
[11:01:36.942]     ...future.frame <- base::sys.nframe()
[11:01:36.942]     ...future.conditions <- base::list()
[11:01:36.942]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:36.942]     if (FALSE) {
[11:01:36.942]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:36.942]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:36.942]     }
[11:01:36.942]     ...future.result <- base::tryCatch({
[11:01:36.942]         base::withCallingHandlers({
[11:01:36.942]             ...future.value <- base::withVisible(base::local({
[11:01:36.942]                 ...future.makeSendCondition <- base::local({
[11:01:36.942]                   sendCondition <- NULL
[11:01:36.942]                   function(frame = 1L) {
[11:01:36.942]                     if (is.function(sendCondition)) 
[11:01:36.942]                       return(sendCondition)
[11:01:36.942]                     ns <- getNamespace("parallel")
[11:01:36.942]                     if (exists("sendData", mode = "function", 
[11:01:36.942]                       envir = ns)) {
[11:01:36.942]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:36.942]                         envir = ns)
[11:01:36.942]                       envir <- sys.frame(frame)
[11:01:36.942]                       master <- NULL
[11:01:36.942]                       while (!identical(envir, .GlobalEnv) && 
[11:01:36.942]                         !identical(envir, emptyenv())) {
[11:01:36.942]                         if (exists("master", mode = "list", envir = envir, 
[11:01:36.942]                           inherits = FALSE)) {
[11:01:36.942]                           master <- get("master", mode = "list", 
[11:01:36.942]                             envir = envir, inherits = FALSE)
[11:01:36.942]                           if (inherits(master, c("SOCKnode", 
[11:01:36.942]                             "SOCK0node"))) {
[11:01:36.942]                             sendCondition <<- function(cond) {
[11:01:36.942]                               data <- list(type = "VALUE", value = cond, 
[11:01:36.942]                                 success = TRUE)
[11:01:36.942]                               parallel_sendData(master, data)
[11:01:36.942]                             }
[11:01:36.942]                             return(sendCondition)
[11:01:36.942]                           }
[11:01:36.942]                         }
[11:01:36.942]                         frame <- frame + 1L
[11:01:36.942]                         envir <- sys.frame(frame)
[11:01:36.942]                       }
[11:01:36.942]                     }
[11:01:36.942]                     sendCondition <<- function(cond) NULL
[11:01:36.942]                   }
[11:01:36.942]                 })
[11:01:36.942]                 withCallingHandlers({
[11:01:36.942]                   {
[11:01:36.942]                     lm(weight ~ group - 1)
[11:01:36.942]                   }
[11:01:36.942]                 }, immediateCondition = function(cond) {
[11:01:36.942]                   sendCondition <- ...future.makeSendCondition()
[11:01:36.942]                   sendCondition(cond)
[11:01:36.942]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.942]                   {
[11:01:36.942]                     inherits <- base::inherits
[11:01:36.942]                     invokeRestart <- base::invokeRestart
[11:01:36.942]                     is.null <- base::is.null
[11:01:36.942]                     muffled <- FALSE
[11:01:36.942]                     if (inherits(cond, "message")) {
[11:01:36.942]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:36.942]                       if (muffled) 
[11:01:36.942]                         invokeRestart("muffleMessage")
[11:01:36.942]                     }
[11:01:36.942]                     else if (inherits(cond, "warning")) {
[11:01:36.942]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:36.942]                       if (muffled) 
[11:01:36.942]                         invokeRestart("muffleWarning")
[11:01:36.942]                     }
[11:01:36.942]                     else if (inherits(cond, "condition")) {
[11:01:36.942]                       if (!is.null(pattern)) {
[11:01:36.942]                         computeRestarts <- base::computeRestarts
[11:01:36.942]                         grepl <- base::grepl
[11:01:36.942]                         restarts <- computeRestarts(cond)
[11:01:36.942]                         for (restart in restarts) {
[11:01:36.942]                           name <- restart$name
[11:01:36.942]                           if (is.null(name)) 
[11:01:36.942]                             next
[11:01:36.942]                           if (!grepl(pattern, name)) 
[11:01:36.942]                             next
[11:01:36.942]                           invokeRestart(restart)
[11:01:36.942]                           muffled <- TRUE
[11:01:36.942]                           break
[11:01:36.942]                         }
[11:01:36.942]                       }
[11:01:36.942]                     }
[11:01:36.942]                     invisible(muffled)
[11:01:36.942]                   }
[11:01:36.942]                   muffleCondition(cond)
[11:01:36.942]                 })
[11:01:36.942]             }))
[11:01:36.942]             future::FutureResult(value = ...future.value$value, 
[11:01:36.942]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:36.942]                   ...future.rng), globalenv = if (FALSE) 
[11:01:36.942]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:36.942]                     ...future.globalenv.names))
[11:01:36.942]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:36.942]         }, condition = base::local({
[11:01:36.942]             c <- base::c
[11:01:36.942]             inherits <- base::inherits
[11:01:36.942]             invokeRestart <- base::invokeRestart
[11:01:36.942]             length <- base::length
[11:01:36.942]             list <- base::list
[11:01:36.942]             seq.int <- base::seq.int
[11:01:36.942]             signalCondition <- base::signalCondition
[11:01:36.942]             sys.calls <- base::sys.calls
[11:01:36.942]             `[[` <- base::`[[`
[11:01:36.942]             `+` <- base::`+`
[11:01:36.942]             `<<-` <- base::`<<-`
[11:01:36.942]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:36.942]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:36.942]                   3L)]
[11:01:36.942]             }
[11:01:36.942]             function(cond) {
[11:01:36.942]                 is_error <- inherits(cond, "error")
[11:01:36.942]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:36.942]                   NULL)
[11:01:36.942]                 if (is_error) {
[11:01:36.942]                   sessionInformation <- function() {
[11:01:36.942]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:36.942]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:36.942]                       search = base::search(), system = base::Sys.info())
[11:01:36.942]                   }
[11:01:36.942]                   ...future.conditions[[length(...future.conditions) + 
[11:01:36.942]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:36.942]                     cond$call), session = sessionInformation(), 
[11:01:36.942]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:36.942]                   signalCondition(cond)
[11:01:36.942]                 }
[11:01:36.942]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:36.942]                 "immediateCondition"))) {
[11:01:36.942]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:36.942]                   ...future.conditions[[length(...future.conditions) + 
[11:01:36.942]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:36.942]                   if (TRUE && !signal) {
[11:01:36.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.942]                     {
[11:01:36.942]                       inherits <- base::inherits
[11:01:36.942]                       invokeRestart <- base::invokeRestart
[11:01:36.942]                       is.null <- base::is.null
[11:01:36.942]                       muffled <- FALSE
[11:01:36.942]                       if (inherits(cond, "message")) {
[11:01:36.942]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:36.942]                         if (muffled) 
[11:01:36.942]                           invokeRestart("muffleMessage")
[11:01:36.942]                       }
[11:01:36.942]                       else if (inherits(cond, "warning")) {
[11:01:36.942]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:36.942]                         if (muffled) 
[11:01:36.942]                           invokeRestart("muffleWarning")
[11:01:36.942]                       }
[11:01:36.942]                       else if (inherits(cond, "condition")) {
[11:01:36.942]                         if (!is.null(pattern)) {
[11:01:36.942]                           computeRestarts <- base::computeRestarts
[11:01:36.942]                           grepl <- base::grepl
[11:01:36.942]                           restarts <- computeRestarts(cond)
[11:01:36.942]                           for (restart in restarts) {
[11:01:36.942]                             name <- restart$name
[11:01:36.942]                             if (is.null(name)) 
[11:01:36.942]                               next
[11:01:36.942]                             if (!grepl(pattern, name)) 
[11:01:36.942]                               next
[11:01:36.942]                             invokeRestart(restart)
[11:01:36.942]                             muffled <- TRUE
[11:01:36.942]                             break
[11:01:36.942]                           }
[11:01:36.942]                         }
[11:01:36.942]                       }
[11:01:36.942]                       invisible(muffled)
[11:01:36.942]                     }
[11:01:36.942]                     muffleCondition(cond, pattern = "^muffle")
[11:01:36.942]                   }
[11:01:36.942]                 }
[11:01:36.942]                 else {
[11:01:36.942]                   if (TRUE) {
[11:01:36.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:36.942]                     {
[11:01:36.942]                       inherits <- base::inherits
[11:01:36.942]                       invokeRestart <- base::invokeRestart
[11:01:36.942]                       is.null <- base::is.null
[11:01:36.942]                       muffled <- FALSE
[11:01:36.942]                       if (inherits(cond, "message")) {
[11:01:36.942]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:36.942]                         if (muffled) 
[11:01:36.942]                           invokeRestart("muffleMessage")
[11:01:36.942]                       }
[11:01:36.942]                       else if (inherits(cond, "warning")) {
[11:01:36.942]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:36.942]                         if (muffled) 
[11:01:36.942]                           invokeRestart("muffleWarning")
[11:01:36.942]                       }
[11:01:36.942]                       else if (inherits(cond, "condition")) {
[11:01:36.942]                         if (!is.null(pattern)) {
[11:01:36.942]                           computeRestarts <- base::computeRestarts
[11:01:36.942]                           grepl <- base::grepl
[11:01:36.942]                           restarts <- computeRestarts(cond)
[11:01:36.942]                           for (restart in restarts) {
[11:01:36.942]                             name <- restart$name
[11:01:36.942]                             if (is.null(name)) 
[11:01:36.942]                               next
[11:01:36.942]                             if (!grepl(pattern, name)) 
[11:01:36.942]                               next
[11:01:36.942]                             invokeRestart(restart)
[11:01:36.942]                             muffled <- TRUE
[11:01:36.942]                             break
[11:01:36.942]                           }
[11:01:36.942]                         }
[11:01:36.942]                       }
[11:01:36.942]                       invisible(muffled)
[11:01:36.942]                     }
[11:01:36.942]                     muffleCondition(cond, pattern = "^muffle")
[11:01:36.942]                   }
[11:01:36.942]                 }
[11:01:36.942]             }
[11:01:36.942]         }))
[11:01:36.942]     }, error = function(ex) {
[11:01:36.942]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:36.942]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:36.942]                 ...future.rng), started = ...future.startTime, 
[11:01:36.942]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:36.942]             version = "1.8"), class = "FutureResult")
[11:01:36.942]     }, finally = {
[11:01:36.942]         if (!identical(...future.workdir, getwd())) 
[11:01:36.942]             setwd(...future.workdir)
[11:01:36.942]         {
[11:01:36.942]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:36.942]                 ...future.oldOptions$nwarnings <- NULL
[11:01:36.942]             }
[11:01:36.942]             base::options(...future.oldOptions)
[11:01:36.942]             if (.Platform$OS.type == "windows") {
[11:01:36.942]                 old_names <- names(...future.oldEnvVars)
[11:01:36.942]                 envs <- base::Sys.getenv()
[11:01:36.942]                 names <- names(envs)
[11:01:36.942]                 common <- intersect(names, old_names)
[11:01:36.942]                 added <- setdiff(names, old_names)
[11:01:36.942]                 removed <- setdiff(old_names, names)
[11:01:36.942]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:36.942]                   envs[common]]
[11:01:36.942]                 NAMES <- toupper(changed)
[11:01:36.942]                 args <- list()
[11:01:36.942]                 for (kk in seq_along(NAMES)) {
[11:01:36.942]                   name <- changed[[kk]]
[11:01:36.942]                   NAME <- NAMES[[kk]]
[11:01:36.942]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.942]                     next
[11:01:36.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:36.942]                 }
[11:01:36.942]                 NAMES <- toupper(added)
[11:01:36.942]                 for (kk in seq_along(NAMES)) {
[11:01:36.942]                   name <- added[[kk]]
[11:01:36.942]                   NAME <- NAMES[[kk]]
[11:01:36.942]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.942]                     next
[11:01:36.942]                   args[[name]] <- ""
[11:01:36.942]                 }
[11:01:36.942]                 NAMES <- toupper(removed)
[11:01:36.942]                 for (kk in seq_along(NAMES)) {
[11:01:36.942]                   name <- removed[[kk]]
[11:01:36.942]                   NAME <- NAMES[[kk]]
[11:01:36.942]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:36.942]                     next
[11:01:36.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:36.942]                 }
[11:01:36.942]                 if (length(args) > 0) 
[11:01:36.942]                   base::do.call(base::Sys.setenv, args = args)
[11:01:36.942]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:36.942]             }
[11:01:36.942]             else {
[11:01:36.942]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:36.942]             }
[11:01:36.942]             {
[11:01:36.942]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:36.942]                   0L) {
[11:01:36.942]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:36.942]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:36.942]                   base::options(opts)
[11:01:36.942]                 }
[11:01:36.942]                 {
[11:01:36.942]                   {
[11:01:36.942]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:36.942]                     NULL
[11:01:36.942]                   }
[11:01:36.942]                   options(future.plan = NULL)
[11:01:36.942]                   if (is.na(NA_character_)) 
[11:01:36.942]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:36.942]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:36.942]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:36.942]                     .init = FALSE)
[11:01:36.942]                 }
[11:01:36.942]             }
[11:01:36.942]         }
[11:01:36.942]     })
[11:01:36.942]     if (TRUE) {
[11:01:36.942]         base::sink(type = "output", split = FALSE)
[11:01:36.942]         if (TRUE) {
[11:01:36.942]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:36.942]         }
[11:01:36.942]         else {
[11:01:36.942]             ...future.result["stdout"] <- base::list(NULL)
[11:01:36.942]         }
[11:01:36.942]         base::close(...future.stdout)
[11:01:36.942]         ...future.stdout <- NULL
[11:01:36.942]     }
[11:01:36.942]     ...future.result$conditions <- ...future.conditions
[11:01:36.942]     ...future.result$finished <- base::Sys.time()
[11:01:36.942]     ...future.result
[11:01:36.942] }
[11:01:36.945] Exporting 2 global objects (712 bytes) to cluster node #1 ...
[11:01:36.945] Exporting ‘weight’ (191 bytes) to cluster node #1 ...
[11:01:36.946] Exporting ‘weight’ (191 bytes) to cluster node #1 ... DONE
[11:01:36.946] Exporting ‘group’ (210 bytes) to cluster node #1 ...
[11:01:36.946] Exporting ‘group’ (210 bytes) to cluster node #1 ... DONE
[11:01:36.946] Exporting 2 global objects (712 bytes) to cluster node #1 ... DONE
[11:01:36.947] MultisessionFuture started
[11:01:36.947] - Launch lazy future ... done
[11:01:36.947] run() for ‘MultisessionFuture’ ... done
[11:01:36.947] result() for ClusterFuture ...
[11:01:36.947] receiveMessageFromWorker() for ClusterFuture ...
[11:01:36.948] - Validating connection of MultisessionFuture
[11:01:36.990] - received message: FutureResult
[11:01:36.990] - Received FutureResult
[11:01:36.990] - Erased future from FutureRegistry
[11:01:36.990] result() for ClusterFuture ...
[11:01:36.990] - result already collected: FutureResult
[11:01:36.990] result() for ClusterFuture ... done
[11:01:36.990] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:36.991] result() for ClusterFuture ... done
[11:01:36.991] result() for ClusterFuture ...
[11:01:36.991] - result already collected: FutureResult
[11:01:36.991] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[11:01:36.993] getGlobalsAndPackages() ...
[11:01:36.993] Searching for globals...
[11:01:36.995] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[11:01:36.995] Searching for globals ... DONE
[11:01:36.995] Resolving globals: FALSE
[11:01:36.996] The total size of the 2 globals is 401 bytes (401 bytes)
[11:01:36.996] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[11:01:36.996] - globals: [2] ‘weight’, ‘group’
[11:01:36.996] - packages: [1] ‘stats’
[11:01:36.997] getGlobalsAndPackages() ... DONE
[11:01:36.997] run() for ‘Future’ ...
[11:01:36.997] - state: ‘created’
[11:01:36.997] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:37.012] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:37.012] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:37.012]   - Field: ‘node’
[11:01:37.012]   - Field: ‘label’
[11:01:37.012]   - Field: ‘local’
[11:01:37.012]   - Field: ‘owner’
[11:01:37.012]   - Field: ‘envir’
[11:01:37.012]   - Field: ‘workers’
[11:01:37.012]   - Field: ‘packages’
[11:01:37.012]   - Field: ‘gc’
[11:01:37.013]   - Field: ‘conditions’
[11:01:37.013]   - Field: ‘persistent’
[11:01:37.013]   - Field: ‘expr’
[11:01:37.013]   - Field: ‘uuid’
[11:01:37.013]   - Field: ‘seed’
[11:01:37.013]   - Field: ‘version’
[11:01:37.013]   - Field: ‘result’
[11:01:37.013]   - Field: ‘asynchronous’
[11:01:37.013]   - Field: ‘calls’
[11:01:37.013]   - Field: ‘globals’
[11:01:37.014]   - Field: ‘stdout’
[11:01:37.014]   - Field: ‘earlySignal’
[11:01:37.014]   - Field: ‘lazy’
[11:01:37.014]   - Field: ‘state’
[11:01:37.014] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:37.014] - Launch lazy future ...
[11:01:37.014] Packages needed by the future expression (n = 1): ‘stats’
[11:01:37.015] Packages needed by future strategies (n = 0): <none>
[11:01:37.015] {
[11:01:37.015]     {
[11:01:37.015]         {
[11:01:37.015]             ...future.startTime <- base::Sys.time()
[11:01:37.015]             {
[11:01:37.015]                 {
[11:01:37.015]                   {
[11:01:37.015]                     {
[11:01:37.015]                       {
[11:01:37.015]                         base::local({
[11:01:37.015]                           has_future <- base::requireNamespace("future", 
[11:01:37.015]                             quietly = TRUE)
[11:01:37.015]                           if (has_future) {
[11:01:37.015]                             ns <- base::getNamespace("future")
[11:01:37.015]                             version <- ns[[".package"]][["version"]]
[11:01:37.015]                             if (is.null(version)) 
[11:01:37.015]                               version <- utils::packageVersion("future")
[11:01:37.015]                           }
[11:01:37.015]                           else {
[11:01:37.015]                             version <- NULL
[11:01:37.015]                           }
[11:01:37.015]                           if (!has_future || version < "1.8.0") {
[11:01:37.015]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:37.015]                               "", base::R.version$version.string), 
[11:01:37.015]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:37.015]                                 base::R.version$platform, 8 * 
[11:01:37.015]                                   base::.Machine$sizeof.pointer), 
[11:01:37.015]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:37.015]                                 "release", "version")], collapse = " "), 
[11:01:37.015]                               hostname = base::Sys.info()[["nodename"]])
[11:01:37.015]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:37.015]                               info)
[11:01:37.015]                             info <- base::paste(info, collapse = "; ")
[11:01:37.015]                             if (!has_future) {
[11:01:37.015]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:37.015]                                 info)
[11:01:37.015]                             }
[11:01:37.015]                             else {
[11:01:37.015]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:37.015]                                 info, version)
[11:01:37.015]                             }
[11:01:37.015]                             base::stop(msg)
[11:01:37.015]                           }
[11:01:37.015]                         })
[11:01:37.015]                       }
[11:01:37.015]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:37.015]                       base::options(mc.cores = 1L)
[11:01:37.015]                     }
[11:01:37.015]                     base::local({
[11:01:37.015]                       for (pkg in "stats") {
[11:01:37.015]                         base::loadNamespace(pkg)
[11:01:37.015]                         base::library(pkg, character.only = TRUE)
[11:01:37.015]                       }
[11:01:37.015]                     })
[11:01:37.015]                   }
[11:01:37.015]                   ...future.strategy.old <- future::plan("list")
[11:01:37.015]                   options(future.plan = NULL)
[11:01:37.015]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:37.015]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:37.015]                 }
[11:01:37.015]                 ...future.workdir <- getwd()
[11:01:37.015]             }
[11:01:37.015]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:37.015]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:37.015]         }
[11:01:37.015]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:37.015]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:37.015]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:37.015]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:37.015]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:37.015]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:37.015]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:37.015]             base::names(...future.oldOptions))
[11:01:37.015]     }
[11:01:37.015]     if (FALSE) {
[11:01:37.015]     }
[11:01:37.015]     else {
[11:01:37.015]         if (TRUE) {
[11:01:37.015]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:37.015]                 open = "w")
[11:01:37.015]         }
[11:01:37.015]         else {
[11:01:37.015]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:37.015]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:37.015]         }
[11:01:37.015]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:37.015]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:37.015]             base::sink(type = "output", split = FALSE)
[11:01:37.015]             base::close(...future.stdout)
[11:01:37.015]         }, add = TRUE)
[11:01:37.015]     }
[11:01:37.015]     ...future.frame <- base::sys.nframe()
[11:01:37.015]     ...future.conditions <- base::list()
[11:01:37.015]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:37.015]     if (FALSE) {
[11:01:37.015]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:37.015]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:37.015]     }
[11:01:37.015]     ...future.result <- base::tryCatch({
[11:01:37.015]         base::withCallingHandlers({
[11:01:37.015]             ...future.value <- base::withVisible(base::local({
[11:01:37.015]                 ...future.makeSendCondition <- base::local({
[11:01:37.015]                   sendCondition <- NULL
[11:01:37.015]                   function(frame = 1L) {
[11:01:37.015]                     if (is.function(sendCondition)) 
[11:01:37.015]                       return(sendCondition)
[11:01:37.015]                     ns <- getNamespace("parallel")
[11:01:37.015]                     if (exists("sendData", mode = "function", 
[11:01:37.015]                       envir = ns)) {
[11:01:37.015]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:37.015]                         envir = ns)
[11:01:37.015]                       envir <- sys.frame(frame)
[11:01:37.015]                       master <- NULL
[11:01:37.015]                       while (!identical(envir, .GlobalEnv) && 
[11:01:37.015]                         !identical(envir, emptyenv())) {
[11:01:37.015]                         if (exists("master", mode = "list", envir = envir, 
[11:01:37.015]                           inherits = FALSE)) {
[11:01:37.015]                           master <- get("master", mode = "list", 
[11:01:37.015]                             envir = envir, inherits = FALSE)
[11:01:37.015]                           if (inherits(master, c("SOCKnode", 
[11:01:37.015]                             "SOCK0node"))) {
[11:01:37.015]                             sendCondition <<- function(cond) {
[11:01:37.015]                               data <- list(type = "VALUE", value = cond, 
[11:01:37.015]                                 success = TRUE)
[11:01:37.015]                               parallel_sendData(master, data)
[11:01:37.015]                             }
[11:01:37.015]                             return(sendCondition)
[11:01:37.015]                           }
[11:01:37.015]                         }
[11:01:37.015]                         frame <- frame + 1L
[11:01:37.015]                         envir <- sys.frame(frame)
[11:01:37.015]                       }
[11:01:37.015]                     }
[11:01:37.015]                     sendCondition <<- function(cond) NULL
[11:01:37.015]                   }
[11:01:37.015]                 })
[11:01:37.015]                 withCallingHandlers({
[11:01:37.015]                   {
[11:01:37.015]                     lm(weight ~ group - 1)
[11:01:37.015]                   }
[11:01:37.015]                 }, immediateCondition = function(cond) {
[11:01:37.015]                   sendCondition <- ...future.makeSendCondition()
[11:01:37.015]                   sendCondition(cond)
[11:01:37.015]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.015]                   {
[11:01:37.015]                     inherits <- base::inherits
[11:01:37.015]                     invokeRestart <- base::invokeRestart
[11:01:37.015]                     is.null <- base::is.null
[11:01:37.015]                     muffled <- FALSE
[11:01:37.015]                     if (inherits(cond, "message")) {
[11:01:37.015]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:37.015]                       if (muffled) 
[11:01:37.015]                         invokeRestart("muffleMessage")
[11:01:37.015]                     }
[11:01:37.015]                     else if (inherits(cond, "warning")) {
[11:01:37.015]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:37.015]                       if (muffled) 
[11:01:37.015]                         invokeRestart("muffleWarning")
[11:01:37.015]                     }
[11:01:37.015]                     else if (inherits(cond, "condition")) {
[11:01:37.015]                       if (!is.null(pattern)) {
[11:01:37.015]                         computeRestarts <- base::computeRestarts
[11:01:37.015]                         grepl <- base::grepl
[11:01:37.015]                         restarts <- computeRestarts(cond)
[11:01:37.015]                         for (restart in restarts) {
[11:01:37.015]                           name <- restart$name
[11:01:37.015]                           if (is.null(name)) 
[11:01:37.015]                             next
[11:01:37.015]                           if (!grepl(pattern, name)) 
[11:01:37.015]                             next
[11:01:37.015]                           invokeRestart(restart)
[11:01:37.015]                           muffled <- TRUE
[11:01:37.015]                           break
[11:01:37.015]                         }
[11:01:37.015]                       }
[11:01:37.015]                     }
[11:01:37.015]                     invisible(muffled)
[11:01:37.015]                   }
[11:01:37.015]                   muffleCondition(cond)
[11:01:37.015]                 })
[11:01:37.015]             }))
[11:01:37.015]             future::FutureResult(value = ...future.value$value, 
[11:01:37.015]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:37.015]                   ...future.rng), globalenv = if (FALSE) 
[11:01:37.015]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:37.015]                     ...future.globalenv.names))
[11:01:37.015]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:37.015]         }, condition = base::local({
[11:01:37.015]             c <- base::c
[11:01:37.015]             inherits <- base::inherits
[11:01:37.015]             invokeRestart <- base::invokeRestart
[11:01:37.015]             length <- base::length
[11:01:37.015]             list <- base::list
[11:01:37.015]             seq.int <- base::seq.int
[11:01:37.015]             signalCondition <- base::signalCondition
[11:01:37.015]             sys.calls <- base::sys.calls
[11:01:37.015]             `[[` <- base::`[[`
[11:01:37.015]             `+` <- base::`+`
[11:01:37.015]             `<<-` <- base::`<<-`
[11:01:37.015]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:37.015]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:37.015]                   3L)]
[11:01:37.015]             }
[11:01:37.015]             function(cond) {
[11:01:37.015]                 is_error <- inherits(cond, "error")
[11:01:37.015]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:37.015]                   NULL)
[11:01:37.015]                 if (is_error) {
[11:01:37.015]                   sessionInformation <- function() {
[11:01:37.015]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:37.015]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:37.015]                       search = base::search(), system = base::Sys.info())
[11:01:37.015]                   }
[11:01:37.015]                   ...future.conditions[[length(...future.conditions) + 
[11:01:37.015]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:37.015]                     cond$call), session = sessionInformation(), 
[11:01:37.015]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:37.015]                   signalCondition(cond)
[11:01:37.015]                 }
[11:01:37.015]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:37.015]                 "immediateCondition"))) {
[11:01:37.015]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:37.015]                   ...future.conditions[[length(...future.conditions) + 
[11:01:37.015]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:37.015]                   if (TRUE && !signal) {
[11:01:37.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.015]                     {
[11:01:37.015]                       inherits <- base::inherits
[11:01:37.015]                       invokeRestart <- base::invokeRestart
[11:01:37.015]                       is.null <- base::is.null
[11:01:37.015]                       muffled <- FALSE
[11:01:37.015]                       if (inherits(cond, "message")) {
[11:01:37.015]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:37.015]                         if (muffled) 
[11:01:37.015]                           invokeRestart("muffleMessage")
[11:01:37.015]                       }
[11:01:37.015]                       else if (inherits(cond, "warning")) {
[11:01:37.015]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:37.015]                         if (muffled) 
[11:01:37.015]                           invokeRestart("muffleWarning")
[11:01:37.015]                       }
[11:01:37.015]                       else if (inherits(cond, "condition")) {
[11:01:37.015]                         if (!is.null(pattern)) {
[11:01:37.015]                           computeRestarts <- base::computeRestarts
[11:01:37.015]                           grepl <- base::grepl
[11:01:37.015]                           restarts <- computeRestarts(cond)
[11:01:37.015]                           for (restart in restarts) {
[11:01:37.015]                             name <- restart$name
[11:01:37.015]                             if (is.null(name)) 
[11:01:37.015]                               next
[11:01:37.015]                             if (!grepl(pattern, name)) 
[11:01:37.015]                               next
[11:01:37.015]                             invokeRestart(restart)
[11:01:37.015]                             muffled <- TRUE
[11:01:37.015]                             break
[11:01:37.015]                           }
[11:01:37.015]                         }
[11:01:37.015]                       }
[11:01:37.015]                       invisible(muffled)
[11:01:37.015]                     }
[11:01:37.015]                     muffleCondition(cond, pattern = "^muffle")
[11:01:37.015]                   }
[11:01:37.015]                 }
[11:01:37.015]                 else {
[11:01:37.015]                   if (TRUE) {
[11:01:37.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.015]                     {
[11:01:37.015]                       inherits <- base::inherits
[11:01:37.015]                       invokeRestart <- base::invokeRestart
[11:01:37.015]                       is.null <- base::is.null
[11:01:37.015]                       muffled <- FALSE
[11:01:37.015]                       if (inherits(cond, "message")) {
[11:01:37.015]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:37.015]                         if (muffled) 
[11:01:37.015]                           invokeRestart("muffleMessage")
[11:01:37.015]                       }
[11:01:37.015]                       else if (inherits(cond, "warning")) {
[11:01:37.015]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:37.015]                         if (muffled) 
[11:01:37.015]                           invokeRestart("muffleWarning")
[11:01:37.015]                       }
[11:01:37.015]                       else if (inherits(cond, "condition")) {
[11:01:37.015]                         if (!is.null(pattern)) {
[11:01:37.015]                           computeRestarts <- base::computeRestarts
[11:01:37.015]                           grepl <- base::grepl
[11:01:37.015]                           restarts <- computeRestarts(cond)
[11:01:37.015]                           for (restart in restarts) {
[11:01:37.015]                             name <- restart$name
[11:01:37.015]                             if (is.null(name)) 
[11:01:37.015]                               next
[11:01:37.015]                             if (!grepl(pattern, name)) 
[11:01:37.015]                               next
[11:01:37.015]                             invokeRestart(restart)
[11:01:37.015]                             muffled <- TRUE
[11:01:37.015]                             break
[11:01:37.015]                           }
[11:01:37.015]                         }
[11:01:37.015]                       }
[11:01:37.015]                       invisible(muffled)
[11:01:37.015]                     }
[11:01:37.015]                     muffleCondition(cond, pattern = "^muffle")
[11:01:37.015]                   }
[11:01:37.015]                 }
[11:01:37.015]             }
[11:01:37.015]         }))
[11:01:37.015]     }, error = function(ex) {
[11:01:37.015]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:37.015]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:37.015]                 ...future.rng), started = ...future.startTime, 
[11:01:37.015]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:37.015]             version = "1.8"), class = "FutureResult")
[11:01:37.015]     }, finally = {
[11:01:37.015]         if (!identical(...future.workdir, getwd())) 
[11:01:37.015]             setwd(...future.workdir)
[11:01:37.015]         {
[11:01:37.015]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:37.015]                 ...future.oldOptions$nwarnings <- NULL
[11:01:37.015]             }
[11:01:37.015]             base::options(...future.oldOptions)
[11:01:37.015]             if (.Platform$OS.type == "windows") {
[11:01:37.015]                 old_names <- names(...future.oldEnvVars)
[11:01:37.015]                 envs <- base::Sys.getenv()
[11:01:37.015]                 names <- names(envs)
[11:01:37.015]                 common <- intersect(names, old_names)
[11:01:37.015]                 added <- setdiff(names, old_names)
[11:01:37.015]                 removed <- setdiff(old_names, names)
[11:01:37.015]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:37.015]                   envs[common]]
[11:01:37.015]                 NAMES <- toupper(changed)
[11:01:37.015]                 args <- list()
[11:01:37.015]                 for (kk in seq_along(NAMES)) {
[11:01:37.015]                   name <- changed[[kk]]
[11:01:37.015]                   NAME <- NAMES[[kk]]
[11:01:37.015]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.015]                     next
[11:01:37.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:37.015]                 }
[11:01:37.015]                 NAMES <- toupper(added)
[11:01:37.015]                 for (kk in seq_along(NAMES)) {
[11:01:37.015]                   name <- added[[kk]]
[11:01:37.015]                   NAME <- NAMES[[kk]]
[11:01:37.015]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.015]                     next
[11:01:37.015]                   args[[name]] <- ""
[11:01:37.015]                 }
[11:01:37.015]                 NAMES <- toupper(removed)
[11:01:37.015]                 for (kk in seq_along(NAMES)) {
[11:01:37.015]                   name <- removed[[kk]]
[11:01:37.015]                   NAME <- NAMES[[kk]]
[11:01:37.015]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.015]                     next
[11:01:37.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:37.015]                 }
[11:01:37.015]                 if (length(args) > 0) 
[11:01:37.015]                   base::do.call(base::Sys.setenv, args = args)
[11:01:37.015]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:37.015]             }
[11:01:37.015]             else {
[11:01:37.015]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:37.015]             }
[11:01:37.015]             {
[11:01:37.015]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:37.015]                   0L) {
[11:01:37.015]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:37.015]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:37.015]                   base::options(opts)
[11:01:37.015]                 }
[11:01:37.015]                 {
[11:01:37.015]                   {
[11:01:37.015]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:37.015]                     NULL
[11:01:37.015]                   }
[11:01:37.015]                   options(future.plan = NULL)
[11:01:37.015]                   if (is.na(NA_character_)) 
[11:01:37.015]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:37.015]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:37.015]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:37.015]                     .init = FALSE)
[11:01:37.015]                 }
[11:01:37.015]             }
[11:01:37.015]         }
[11:01:37.015]     })
[11:01:37.015]     if (TRUE) {
[11:01:37.015]         base::sink(type = "output", split = FALSE)
[11:01:37.015]         if (TRUE) {
[11:01:37.015]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:37.015]         }
[11:01:37.015]         else {
[11:01:37.015]             ...future.result["stdout"] <- base::list(NULL)
[11:01:37.015]         }
[11:01:37.015]         base::close(...future.stdout)
[11:01:37.015]         ...future.stdout <- NULL
[11:01:37.015]     }
[11:01:37.015]     ...future.result$conditions <- ...future.conditions
[11:01:37.015]     ...future.result$finished <- base::Sys.time()
[11:01:37.015]     ...future.result
[11:01:37.015] }
[11:01:37.018] Exporting 2 global objects (712 bytes) to cluster node #1 ...
[11:01:37.018] Exporting ‘weight’ (191 bytes) to cluster node #1 ...
[11:01:37.019] Exporting ‘weight’ (191 bytes) to cluster node #1 ... DONE
[11:01:37.019] Exporting ‘group’ (210 bytes) to cluster node #1 ...
[11:01:37.019] Exporting ‘group’ (210 bytes) to cluster node #1 ... DONE
[11:01:37.019] Exporting 2 global objects (712 bytes) to cluster node #1 ... DONE
[11:01:37.020] MultisessionFuture started
[11:01:37.020] - Launch lazy future ... done
[11:01:37.020] run() for ‘MultisessionFuture’ ... done
[11:01:37.020] result() for ClusterFuture ...
[11:01:37.020] receiveMessageFromWorker() for ClusterFuture ...
[11:01:37.020] - Validating connection of MultisessionFuture
[11:01:37.063] - received message: FutureResult
[11:01:37.063] - Received FutureResult
[11:01:37.063] - Erased future from FutureRegistry
[11:01:37.063] result() for ClusterFuture ...
[11:01:37.063] - result already collected: FutureResult
[11:01:37.063] result() for ClusterFuture ... done
[11:01:37.064] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:37.064] result() for ClusterFuture ... done
[11:01:37.064] result() for ClusterFuture ...
[11:01:37.064] - result already collected: FutureResult
[11:01:37.064] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

[11:01:37.066] getGlobalsAndPackages() ...
[11:01:37.066] Searching for globals...
[11:01:37.068] - globals found: [6] ‘{’, ‘lm’, ‘weight’, ‘-’, ‘group’, ‘~’
[11:01:37.068] Searching for globals ... DONE
[11:01:37.068] Resolving globals: FALSE
[11:01:37.069] The total size of the 2 globals is 401 bytes (401 bytes)
[11:01:37.069] The total size of the 2 globals exported for future expression (‘{; lm(weight ~ group - 1); }’) is 401 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘group’ (210 bytes of class ‘numeric’) and ‘weight’ (191 bytes of class ‘numeric’)
[11:01:37.069] - globals: [2] ‘weight’, ‘group’
[11:01:37.069] - packages: [1] ‘stats’
[11:01:37.070] getGlobalsAndPackages() ... DONE
[11:01:37.070] run() for ‘Future’ ...
[11:01:37.070] - state: ‘created’
[11:01:37.070] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:37.086] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:37.086] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:37.086]   - Field: ‘node’
[11:01:37.087]   - Field: ‘label’
[11:01:37.087]   - Field: ‘local’
[11:01:37.087]   - Field: ‘owner’
[11:01:37.087]   - Field: ‘envir’
[11:01:37.087]   - Field: ‘workers’
[11:01:37.087]   - Field: ‘packages’
[11:01:37.087]   - Field: ‘gc’
[11:01:37.087]   - Field: ‘conditions’
[11:01:37.087]   - Field: ‘persistent’
[11:01:37.087]   - Field: ‘expr’
[11:01:37.087]   - Field: ‘uuid’
[11:01:37.087]   - Field: ‘seed’
[11:01:37.087]   - Field: ‘version’
[11:01:37.088]   - Field: ‘result’
[11:01:37.088]   - Field: ‘asynchronous’
[11:01:37.088]   - Field: ‘calls’
[11:01:37.088]   - Field: ‘globals’
[11:01:37.088]   - Field: ‘stdout’
[11:01:37.088]   - Field: ‘earlySignal’
[11:01:37.088]   - Field: ‘lazy’
[11:01:37.088]   - Field: ‘state’
[11:01:37.088] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:37.088] - Launch lazy future ...
[11:01:37.089] Packages needed by the future expression (n = 1): ‘stats’
[11:01:37.089] Packages needed by future strategies (n = 0): <none>
[11:01:37.089] {
[11:01:37.089]     {
[11:01:37.089]         {
[11:01:37.089]             ...future.startTime <- base::Sys.time()
[11:01:37.089]             {
[11:01:37.089]                 {
[11:01:37.089]                   {
[11:01:37.089]                     {
[11:01:37.089]                       {
[11:01:37.089]                         base::local({
[11:01:37.089]                           has_future <- base::requireNamespace("future", 
[11:01:37.089]                             quietly = TRUE)
[11:01:37.089]                           if (has_future) {
[11:01:37.089]                             ns <- base::getNamespace("future")
[11:01:37.089]                             version <- ns[[".package"]][["version"]]
[11:01:37.089]                             if (is.null(version)) 
[11:01:37.089]                               version <- utils::packageVersion("future")
[11:01:37.089]                           }
[11:01:37.089]                           else {
[11:01:37.089]                             version <- NULL
[11:01:37.089]                           }
[11:01:37.089]                           if (!has_future || version < "1.8.0") {
[11:01:37.089]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:37.089]                               "", base::R.version$version.string), 
[11:01:37.089]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:37.089]                                 base::R.version$platform, 8 * 
[11:01:37.089]                                   base::.Machine$sizeof.pointer), 
[11:01:37.089]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:37.089]                                 "release", "version")], collapse = " "), 
[11:01:37.089]                               hostname = base::Sys.info()[["nodename"]])
[11:01:37.089]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:37.089]                               info)
[11:01:37.089]                             info <- base::paste(info, collapse = "; ")
[11:01:37.089]                             if (!has_future) {
[11:01:37.089]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:37.089]                                 info)
[11:01:37.089]                             }
[11:01:37.089]                             else {
[11:01:37.089]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:37.089]                                 info, version)
[11:01:37.089]                             }
[11:01:37.089]                             base::stop(msg)
[11:01:37.089]                           }
[11:01:37.089]                         })
[11:01:37.089]                       }
[11:01:37.089]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:37.089]                       base::options(mc.cores = 1L)
[11:01:37.089]                     }
[11:01:37.089]                     base::local({
[11:01:37.089]                       for (pkg in "stats") {
[11:01:37.089]                         base::loadNamespace(pkg)
[11:01:37.089]                         base::library(pkg, character.only = TRUE)
[11:01:37.089]                       }
[11:01:37.089]                     })
[11:01:37.089]                   }
[11:01:37.089]                   ...future.strategy.old <- future::plan("list")
[11:01:37.089]                   options(future.plan = NULL)
[11:01:37.089]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:37.089]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:37.089]                 }
[11:01:37.089]                 ...future.workdir <- getwd()
[11:01:37.089]             }
[11:01:37.089]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:37.089]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:37.089]         }
[11:01:37.089]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:37.089]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:37.089]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:37.089]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:37.089]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:37.089]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:37.089]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:37.089]             base::names(...future.oldOptions))
[11:01:37.089]     }
[11:01:37.089]     if (FALSE) {
[11:01:37.089]     }
[11:01:37.089]     else {
[11:01:37.089]         if (TRUE) {
[11:01:37.089]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:37.089]                 open = "w")
[11:01:37.089]         }
[11:01:37.089]         else {
[11:01:37.089]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:37.089]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:37.089]         }
[11:01:37.089]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:37.089]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:37.089]             base::sink(type = "output", split = FALSE)
[11:01:37.089]             base::close(...future.stdout)
[11:01:37.089]         }, add = TRUE)
[11:01:37.089]     }
[11:01:37.089]     ...future.frame <- base::sys.nframe()
[11:01:37.089]     ...future.conditions <- base::list()
[11:01:37.089]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:37.089]     if (FALSE) {
[11:01:37.089]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:37.089]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:37.089]     }
[11:01:37.089]     ...future.result <- base::tryCatch({
[11:01:37.089]         base::withCallingHandlers({
[11:01:37.089]             ...future.value <- base::withVisible(base::local({
[11:01:37.089]                 ...future.makeSendCondition <- base::local({
[11:01:37.089]                   sendCondition <- NULL
[11:01:37.089]                   function(frame = 1L) {
[11:01:37.089]                     if (is.function(sendCondition)) 
[11:01:37.089]                       return(sendCondition)
[11:01:37.089]                     ns <- getNamespace("parallel")
[11:01:37.089]                     if (exists("sendData", mode = "function", 
[11:01:37.089]                       envir = ns)) {
[11:01:37.089]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:37.089]                         envir = ns)
[11:01:37.089]                       envir <- sys.frame(frame)
[11:01:37.089]                       master <- NULL
[11:01:37.089]                       while (!identical(envir, .GlobalEnv) && 
[11:01:37.089]                         !identical(envir, emptyenv())) {
[11:01:37.089]                         if (exists("master", mode = "list", envir = envir, 
[11:01:37.089]                           inherits = FALSE)) {
[11:01:37.089]                           master <- get("master", mode = "list", 
[11:01:37.089]                             envir = envir, inherits = FALSE)
[11:01:37.089]                           if (inherits(master, c("SOCKnode", 
[11:01:37.089]                             "SOCK0node"))) {
[11:01:37.089]                             sendCondition <<- function(cond) {
[11:01:37.089]                               data <- list(type = "VALUE", value = cond, 
[11:01:37.089]                                 success = TRUE)
[11:01:37.089]                               parallel_sendData(master, data)
[11:01:37.089]                             }
[11:01:37.089]                             return(sendCondition)
[11:01:37.089]                           }
[11:01:37.089]                         }
[11:01:37.089]                         frame <- frame + 1L
[11:01:37.089]                         envir <- sys.frame(frame)
[11:01:37.089]                       }
[11:01:37.089]                     }
[11:01:37.089]                     sendCondition <<- function(cond) NULL
[11:01:37.089]                   }
[11:01:37.089]                 })
[11:01:37.089]                 withCallingHandlers({
[11:01:37.089]                   {
[11:01:37.089]                     lm(weight ~ group - 1)
[11:01:37.089]                   }
[11:01:37.089]                 }, immediateCondition = function(cond) {
[11:01:37.089]                   sendCondition <- ...future.makeSendCondition()
[11:01:37.089]                   sendCondition(cond)
[11:01:37.089]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.089]                   {
[11:01:37.089]                     inherits <- base::inherits
[11:01:37.089]                     invokeRestart <- base::invokeRestart
[11:01:37.089]                     is.null <- base::is.null
[11:01:37.089]                     muffled <- FALSE
[11:01:37.089]                     if (inherits(cond, "message")) {
[11:01:37.089]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:37.089]                       if (muffled) 
[11:01:37.089]                         invokeRestart("muffleMessage")
[11:01:37.089]                     }
[11:01:37.089]                     else if (inherits(cond, "warning")) {
[11:01:37.089]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:37.089]                       if (muffled) 
[11:01:37.089]                         invokeRestart("muffleWarning")
[11:01:37.089]                     }
[11:01:37.089]                     else if (inherits(cond, "condition")) {
[11:01:37.089]                       if (!is.null(pattern)) {
[11:01:37.089]                         computeRestarts <- base::computeRestarts
[11:01:37.089]                         grepl <- base::grepl
[11:01:37.089]                         restarts <- computeRestarts(cond)
[11:01:37.089]                         for (restart in restarts) {
[11:01:37.089]                           name <- restart$name
[11:01:37.089]                           if (is.null(name)) 
[11:01:37.089]                             next
[11:01:37.089]                           if (!grepl(pattern, name)) 
[11:01:37.089]                             next
[11:01:37.089]                           invokeRestart(restart)
[11:01:37.089]                           muffled <- TRUE
[11:01:37.089]                           break
[11:01:37.089]                         }
[11:01:37.089]                       }
[11:01:37.089]                     }
[11:01:37.089]                     invisible(muffled)
[11:01:37.089]                   }
[11:01:37.089]                   muffleCondition(cond)
[11:01:37.089]                 })
[11:01:37.089]             }))
[11:01:37.089]             future::FutureResult(value = ...future.value$value, 
[11:01:37.089]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:37.089]                   ...future.rng), globalenv = if (FALSE) 
[11:01:37.089]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:37.089]                     ...future.globalenv.names))
[11:01:37.089]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:37.089]         }, condition = base::local({
[11:01:37.089]             c <- base::c
[11:01:37.089]             inherits <- base::inherits
[11:01:37.089]             invokeRestart <- base::invokeRestart
[11:01:37.089]             length <- base::length
[11:01:37.089]             list <- base::list
[11:01:37.089]             seq.int <- base::seq.int
[11:01:37.089]             signalCondition <- base::signalCondition
[11:01:37.089]             sys.calls <- base::sys.calls
[11:01:37.089]             `[[` <- base::`[[`
[11:01:37.089]             `+` <- base::`+`
[11:01:37.089]             `<<-` <- base::`<<-`
[11:01:37.089]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:37.089]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:37.089]                   3L)]
[11:01:37.089]             }
[11:01:37.089]             function(cond) {
[11:01:37.089]                 is_error <- inherits(cond, "error")
[11:01:37.089]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:37.089]                   NULL)
[11:01:37.089]                 if (is_error) {
[11:01:37.089]                   sessionInformation <- function() {
[11:01:37.089]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:37.089]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:37.089]                       search = base::search(), system = base::Sys.info())
[11:01:37.089]                   }
[11:01:37.089]                   ...future.conditions[[length(...future.conditions) + 
[11:01:37.089]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:37.089]                     cond$call), session = sessionInformation(), 
[11:01:37.089]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:37.089]                   signalCondition(cond)
[11:01:37.089]                 }
[11:01:37.089]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:37.089]                 "immediateCondition"))) {
[11:01:37.089]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:37.089]                   ...future.conditions[[length(...future.conditions) + 
[11:01:37.089]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:37.089]                   if (TRUE && !signal) {
[11:01:37.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.089]                     {
[11:01:37.089]                       inherits <- base::inherits
[11:01:37.089]                       invokeRestart <- base::invokeRestart
[11:01:37.089]                       is.null <- base::is.null
[11:01:37.089]                       muffled <- FALSE
[11:01:37.089]                       if (inherits(cond, "message")) {
[11:01:37.089]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:37.089]                         if (muffled) 
[11:01:37.089]                           invokeRestart("muffleMessage")
[11:01:37.089]                       }
[11:01:37.089]                       else if (inherits(cond, "warning")) {
[11:01:37.089]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:37.089]                         if (muffled) 
[11:01:37.089]                           invokeRestart("muffleWarning")
[11:01:37.089]                       }
[11:01:37.089]                       else if (inherits(cond, "condition")) {
[11:01:37.089]                         if (!is.null(pattern)) {
[11:01:37.089]                           computeRestarts <- base::computeRestarts
[11:01:37.089]                           grepl <- base::grepl
[11:01:37.089]                           restarts <- computeRestarts(cond)
[11:01:37.089]                           for (restart in restarts) {
[11:01:37.089]                             name <- restart$name
[11:01:37.089]                             if (is.null(name)) 
[11:01:37.089]                               next
[11:01:37.089]                             if (!grepl(pattern, name)) 
[11:01:37.089]                               next
[11:01:37.089]                             invokeRestart(restart)
[11:01:37.089]                             muffled <- TRUE
[11:01:37.089]                             break
[11:01:37.089]                           }
[11:01:37.089]                         }
[11:01:37.089]                       }
[11:01:37.089]                       invisible(muffled)
[11:01:37.089]                     }
[11:01:37.089]                     muffleCondition(cond, pattern = "^muffle")
[11:01:37.089]                   }
[11:01:37.089]                 }
[11:01:37.089]                 else {
[11:01:37.089]                   if (TRUE) {
[11:01:37.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.089]                     {
[11:01:37.089]                       inherits <- base::inherits
[11:01:37.089]                       invokeRestart <- base::invokeRestart
[11:01:37.089]                       is.null <- base::is.null
[11:01:37.089]                       muffled <- FALSE
[11:01:37.089]                       if (inherits(cond, "message")) {
[11:01:37.089]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:37.089]                         if (muffled) 
[11:01:37.089]                           invokeRestart("muffleMessage")
[11:01:37.089]                       }
[11:01:37.089]                       else if (inherits(cond, "warning")) {
[11:01:37.089]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:37.089]                         if (muffled) 
[11:01:37.089]                           invokeRestart("muffleWarning")
[11:01:37.089]                       }
[11:01:37.089]                       else if (inherits(cond, "condition")) {
[11:01:37.089]                         if (!is.null(pattern)) {
[11:01:37.089]                           computeRestarts <- base::computeRestarts
[11:01:37.089]                           grepl <- base::grepl
[11:01:37.089]                           restarts <- computeRestarts(cond)
[11:01:37.089]                           for (restart in restarts) {
[11:01:37.089]                             name <- restart$name
[11:01:37.089]                             if (is.null(name)) 
[11:01:37.089]                               next
[11:01:37.089]                             if (!grepl(pattern, name)) 
[11:01:37.089]                               next
[11:01:37.089]                             invokeRestart(restart)
[11:01:37.089]                             muffled <- TRUE
[11:01:37.089]                             break
[11:01:37.089]                           }
[11:01:37.089]                         }
[11:01:37.089]                       }
[11:01:37.089]                       invisible(muffled)
[11:01:37.089]                     }
[11:01:37.089]                     muffleCondition(cond, pattern = "^muffle")
[11:01:37.089]                   }
[11:01:37.089]                 }
[11:01:37.089]             }
[11:01:37.089]         }))
[11:01:37.089]     }, error = function(ex) {
[11:01:37.089]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:37.089]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:37.089]                 ...future.rng), started = ...future.startTime, 
[11:01:37.089]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:37.089]             version = "1.8"), class = "FutureResult")
[11:01:37.089]     }, finally = {
[11:01:37.089]         if (!identical(...future.workdir, getwd())) 
[11:01:37.089]             setwd(...future.workdir)
[11:01:37.089]         {
[11:01:37.089]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:37.089]                 ...future.oldOptions$nwarnings <- NULL
[11:01:37.089]             }
[11:01:37.089]             base::options(...future.oldOptions)
[11:01:37.089]             if (.Platform$OS.type == "windows") {
[11:01:37.089]                 old_names <- names(...future.oldEnvVars)
[11:01:37.089]                 envs <- base::Sys.getenv()
[11:01:37.089]                 names <- names(envs)
[11:01:37.089]                 common <- intersect(names, old_names)
[11:01:37.089]                 added <- setdiff(names, old_names)
[11:01:37.089]                 removed <- setdiff(old_names, names)
[11:01:37.089]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:37.089]                   envs[common]]
[11:01:37.089]                 NAMES <- toupper(changed)
[11:01:37.089]                 args <- list()
[11:01:37.089]                 for (kk in seq_along(NAMES)) {
[11:01:37.089]                   name <- changed[[kk]]
[11:01:37.089]                   NAME <- NAMES[[kk]]
[11:01:37.089]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.089]                     next
[11:01:37.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:37.089]                 }
[11:01:37.089]                 NAMES <- toupper(added)
[11:01:37.089]                 for (kk in seq_along(NAMES)) {
[11:01:37.089]                   name <- added[[kk]]
[11:01:37.089]                   NAME <- NAMES[[kk]]
[11:01:37.089]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.089]                     next
[11:01:37.089]                   args[[name]] <- ""
[11:01:37.089]                 }
[11:01:37.089]                 NAMES <- toupper(removed)
[11:01:37.089]                 for (kk in seq_along(NAMES)) {
[11:01:37.089]                   name <- removed[[kk]]
[11:01:37.089]                   NAME <- NAMES[[kk]]
[11:01:37.089]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.089]                     next
[11:01:37.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:37.089]                 }
[11:01:37.089]                 if (length(args) > 0) 
[11:01:37.089]                   base::do.call(base::Sys.setenv, args = args)
[11:01:37.089]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:37.089]             }
[11:01:37.089]             else {
[11:01:37.089]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:37.089]             }
[11:01:37.089]             {
[11:01:37.089]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:37.089]                   0L) {
[11:01:37.089]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:37.089]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:37.089]                   base::options(opts)
[11:01:37.089]                 }
[11:01:37.089]                 {
[11:01:37.089]                   {
[11:01:37.089]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:37.089]                     NULL
[11:01:37.089]                   }
[11:01:37.089]                   options(future.plan = NULL)
[11:01:37.089]                   if (is.na(NA_character_)) 
[11:01:37.089]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:37.089]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:37.089]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:37.089]                     .init = FALSE)
[11:01:37.089]                 }
[11:01:37.089]             }
[11:01:37.089]         }
[11:01:37.089]     })
[11:01:37.089]     if (TRUE) {
[11:01:37.089]         base::sink(type = "output", split = FALSE)
[11:01:37.089]         if (TRUE) {
[11:01:37.089]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:37.089]         }
[11:01:37.089]         else {
[11:01:37.089]             ...future.result["stdout"] <- base::list(NULL)
[11:01:37.089]         }
[11:01:37.089]         base::close(...future.stdout)
[11:01:37.089]         ...future.stdout <- NULL
[11:01:37.089]     }
[11:01:37.089]     ...future.result$conditions <- ...future.conditions
[11:01:37.089]     ...future.result$finished <- base::Sys.time()
[11:01:37.089]     ...future.result
[11:01:37.089] }
[11:01:37.092] Exporting 2 global objects (712 bytes) to cluster node #1 ...
[11:01:37.092] Exporting ‘weight’ (191 bytes) to cluster node #1 ...
[11:01:37.092] Exporting ‘weight’ (191 bytes) to cluster node #1 ... DONE
[11:01:37.092] Exporting ‘group’ (210 bytes) to cluster node #1 ...
[11:01:37.092] Exporting ‘group’ (210 bytes) to cluster node #1 ... DONE
[11:01:37.093] Exporting 2 global objects (712 bytes) to cluster node #1 ... DONE
[11:01:37.093] MultisessionFuture started
[11:01:37.093] - Launch lazy future ... done
[11:01:37.093] run() for ‘MultisessionFuture’ ... done
[11:01:37.093] result() for ClusterFuture ...
[11:01:37.093] receiveMessageFromWorker() for ClusterFuture ...
[11:01:37.093] - Validating connection of MultisessionFuture
[11:01:37.136] - received message: FutureResult
[11:01:37.136] - Received FutureResult
[11:01:37.136] - Erased future from FutureRegistry
[11:01:37.136] result() for ClusterFuture ...
[11:01:37.136] - result already collected: FutureResult
[11:01:37.136] result() for ClusterFuture ... done
[11:01:37.136] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:37.136] result() for ClusterFuture ... done
[11:01:37.136] result() for ClusterFuture ...
[11:01:37.137] - result already collected: FutureResult
[11:01:37.137] result() for ClusterFuture ... done

Call:
lm(formula = weight ~ group - 1)

Coefficients:
groupCtl  groupTrt  
   5.032     4.661  

- Globals - one-side formulas, e.g. xtabs(~ x) ...
[11:01:37.138] getGlobalsAndPackages() ...
[11:01:37.138] Searching for globals...
[11:01:37.139] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[11:01:37.139] Searching for globals ... DONE
[11:01:37.139] Resolving globals: FALSE
[11:01:37.140] The total size of the 1 globals is 71 bytes (71 bytes)
[11:01:37.140] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 71 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (71 bytes of class ‘numeric’)
[11:01:37.140] - globals: [1] ‘x’
[11:01:37.140] - packages: [1] ‘stats’
[11:01:37.140] getGlobalsAndPackages() ... DONE
[11:01:37.141] run() for ‘Future’ ...
[11:01:37.141] - state: ‘created’
[11:01:37.141] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:37.154] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:37.154] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:37.155]   - Field: ‘node’
[11:01:37.155]   - Field: ‘label’
[11:01:37.155]   - Field: ‘local’
[11:01:37.155]   - Field: ‘owner’
[11:01:37.155]   - Field: ‘envir’
[11:01:37.155]   - Field: ‘workers’
[11:01:37.155]   - Field: ‘packages’
[11:01:37.155]   - Field: ‘gc’
[11:01:37.155]   - Field: ‘conditions’
[11:01:37.155]   - Field: ‘persistent’
[11:01:37.155]   - Field: ‘expr’
[11:01:37.155]   - Field: ‘uuid’
[11:01:37.156]   - Field: ‘seed’
[11:01:37.156]   - Field: ‘version’
[11:01:37.156]   - Field: ‘result’
[11:01:37.156]   - Field: ‘asynchronous’
[11:01:37.156]   - Field: ‘calls’
[11:01:37.156]   - Field: ‘globals’
[11:01:37.156]   - Field: ‘stdout’
[11:01:37.156]   - Field: ‘earlySignal’
[11:01:37.156]   - Field: ‘lazy’
[11:01:37.156]   - Field: ‘state’
[11:01:37.156] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:37.156] - Launch lazy future ...
[11:01:37.157] Packages needed by the future expression (n = 1): ‘stats’
[11:01:37.157] Packages needed by future strategies (n = 0): <none>
[11:01:37.157] {
[11:01:37.157]     {
[11:01:37.157]         {
[11:01:37.157]             ...future.startTime <- base::Sys.time()
[11:01:37.157]             {
[11:01:37.157]                 {
[11:01:37.157]                   {
[11:01:37.157]                     {
[11:01:37.157]                       {
[11:01:37.157]                         base::local({
[11:01:37.157]                           has_future <- base::requireNamespace("future", 
[11:01:37.157]                             quietly = TRUE)
[11:01:37.157]                           if (has_future) {
[11:01:37.157]                             ns <- base::getNamespace("future")
[11:01:37.157]                             version <- ns[[".package"]][["version"]]
[11:01:37.157]                             if (is.null(version)) 
[11:01:37.157]                               version <- utils::packageVersion("future")
[11:01:37.157]                           }
[11:01:37.157]                           else {
[11:01:37.157]                             version <- NULL
[11:01:37.157]                           }
[11:01:37.157]                           if (!has_future || version < "1.8.0") {
[11:01:37.157]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:37.157]                               "", base::R.version$version.string), 
[11:01:37.157]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:37.157]                                 base::R.version$platform, 8 * 
[11:01:37.157]                                   base::.Machine$sizeof.pointer), 
[11:01:37.157]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:37.157]                                 "release", "version")], collapse = " "), 
[11:01:37.157]                               hostname = base::Sys.info()[["nodename"]])
[11:01:37.157]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:37.157]                               info)
[11:01:37.157]                             info <- base::paste(info, collapse = "; ")
[11:01:37.157]                             if (!has_future) {
[11:01:37.157]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:37.157]                                 info)
[11:01:37.157]                             }
[11:01:37.157]                             else {
[11:01:37.157]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:37.157]                                 info, version)
[11:01:37.157]                             }
[11:01:37.157]                             base::stop(msg)
[11:01:37.157]                           }
[11:01:37.157]                         })
[11:01:37.157]                       }
[11:01:37.157]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:37.157]                       base::options(mc.cores = 1L)
[11:01:37.157]                     }
[11:01:37.157]                     base::local({
[11:01:37.157]                       for (pkg in "stats") {
[11:01:37.157]                         base::loadNamespace(pkg)
[11:01:37.157]                         base::library(pkg, character.only = TRUE)
[11:01:37.157]                       }
[11:01:37.157]                     })
[11:01:37.157]                   }
[11:01:37.157]                   ...future.strategy.old <- future::plan("list")
[11:01:37.157]                   options(future.plan = NULL)
[11:01:37.157]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:37.157]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:37.157]                 }
[11:01:37.157]                 ...future.workdir <- getwd()
[11:01:37.157]             }
[11:01:37.157]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:37.157]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:37.157]         }
[11:01:37.157]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:37.157]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:37.157]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:37.157]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:37.157]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:37.157]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:37.157]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:37.157]             base::names(...future.oldOptions))
[11:01:37.157]     }
[11:01:37.157]     if (FALSE) {
[11:01:37.157]     }
[11:01:37.157]     else {
[11:01:37.157]         if (TRUE) {
[11:01:37.157]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:37.157]                 open = "w")
[11:01:37.157]         }
[11:01:37.157]         else {
[11:01:37.157]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:37.157]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:37.157]         }
[11:01:37.157]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:37.157]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:37.157]             base::sink(type = "output", split = FALSE)
[11:01:37.157]             base::close(...future.stdout)
[11:01:37.157]         }, add = TRUE)
[11:01:37.157]     }
[11:01:37.157]     ...future.frame <- base::sys.nframe()
[11:01:37.157]     ...future.conditions <- base::list()
[11:01:37.157]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:37.157]     if (FALSE) {
[11:01:37.157]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:37.157]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:37.157]     }
[11:01:37.157]     ...future.result <- base::tryCatch({
[11:01:37.157]         base::withCallingHandlers({
[11:01:37.157]             ...future.value <- base::withVisible(base::local({
[11:01:37.157]                 ...future.makeSendCondition <- base::local({
[11:01:37.157]                   sendCondition <- NULL
[11:01:37.157]                   function(frame = 1L) {
[11:01:37.157]                     if (is.function(sendCondition)) 
[11:01:37.157]                       return(sendCondition)
[11:01:37.157]                     ns <- getNamespace("parallel")
[11:01:37.157]                     if (exists("sendData", mode = "function", 
[11:01:37.157]                       envir = ns)) {
[11:01:37.157]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:37.157]                         envir = ns)
[11:01:37.157]                       envir <- sys.frame(frame)
[11:01:37.157]                       master <- NULL
[11:01:37.157]                       while (!identical(envir, .GlobalEnv) && 
[11:01:37.157]                         !identical(envir, emptyenv())) {
[11:01:37.157]                         if (exists("master", mode = "list", envir = envir, 
[11:01:37.157]                           inherits = FALSE)) {
[11:01:37.157]                           master <- get("master", mode = "list", 
[11:01:37.157]                             envir = envir, inherits = FALSE)
[11:01:37.157]                           if (inherits(master, c("SOCKnode", 
[11:01:37.157]                             "SOCK0node"))) {
[11:01:37.157]                             sendCondition <<- function(cond) {
[11:01:37.157]                               data <- list(type = "VALUE", value = cond, 
[11:01:37.157]                                 success = TRUE)
[11:01:37.157]                               parallel_sendData(master, data)
[11:01:37.157]                             }
[11:01:37.157]                             return(sendCondition)
[11:01:37.157]                           }
[11:01:37.157]                         }
[11:01:37.157]                         frame <- frame + 1L
[11:01:37.157]                         envir <- sys.frame(frame)
[11:01:37.157]                       }
[11:01:37.157]                     }
[11:01:37.157]                     sendCondition <<- function(cond) NULL
[11:01:37.157]                   }
[11:01:37.157]                 })
[11:01:37.157]                 withCallingHandlers({
[11:01:37.157]                   {
[11:01:37.157]                     xtabs(~x)
[11:01:37.157]                   }
[11:01:37.157]                 }, immediateCondition = function(cond) {
[11:01:37.157]                   sendCondition <- ...future.makeSendCondition()
[11:01:37.157]                   sendCondition(cond)
[11:01:37.157]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.157]                   {
[11:01:37.157]                     inherits <- base::inherits
[11:01:37.157]                     invokeRestart <- base::invokeRestart
[11:01:37.157]                     is.null <- base::is.null
[11:01:37.157]                     muffled <- FALSE
[11:01:37.157]                     if (inherits(cond, "message")) {
[11:01:37.157]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:37.157]                       if (muffled) 
[11:01:37.157]                         invokeRestart("muffleMessage")
[11:01:37.157]                     }
[11:01:37.157]                     else if (inherits(cond, "warning")) {
[11:01:37.157]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:37.157]                       if (muffled) 
[11:01:37.157]                         invokeRestart("muffleWarning")
[11:01:37.157]                     }
[11:01:37.157]                     else if (inherits(cond, "condition")) {
[11:01:37.157]                       if (!is.null(pattern)) {
[11:01:37.157]                         computeRestarts <- base::computeRestarts
[11:01:37.157]                         grepl <- base::grepl
[11:01:37.157]                         restarts <- computeRestarts(cond)
[11:01:37.157]                         for (restart in restarts) {
[11:01:37.157]                           name <- restart$name
[11:01:37.157]                           if (is.null(name)) 
[11:01:37.157]                             next
[11:01:37.157]                           if (!grepl(pattern, name)) 
[11:01:37.157]                             next
[11:01:37.157]                           invokeRestart(restart)
[11:01:37.157]                           muffled <- TRUE
[11:01:37.157]                           break
[11:01:37.157]                         }
[11:01:37.157]                       }
[11:01:37.157]                     }
[11:01:37.157]                     invisible(muffled)
[11:01:37.157]                   }
[11:01:37.157]                   muffleCondition(cond)
[11:01:37.157]                 })
[11:01:37.157]             }))
[11:01:37.157]             future::FutureResult(value = ...future.value$value, 
[11:01:37.157]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:37.157]                   ...future.rng), globalenv = if (FALSE) 
[11:01:37.157]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:37.157]                     ...future.globalenv.names))
[11:01:37.157]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:37.157]         }, condition = base::local({
[11:01:37.157]             c <- base::c
[11:01:37.157]             inherits <- base::inherits
[11:01:37.157]             invokeRestart <- base::invokeRestart
[11:01:37.157]             length <- base::length
[11:01:37.157]             list <- base::list
[11:01:37.157]             seq.int <- base::seq.int
[11:01:37.157]             signalCondition <- base::signalCondition
[11:01:37.157]             sys.calls <- base::sys.calls
[11:01:37.157]             `[[` <- base::`[[`
[11:01:37.157]             `+` <- base::`+`
[11:01:37.157]             `<<-` <- base::`<<-`
[11:01:37.157]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:37.157]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:37.157]                   3L)]
[11:01:37.157]             }
[11:01:37.157]             function(cond) {
[11:01:37.157]                 is_error <- inherits(cond, "error")
[11:01:37.157]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:37.157]                   NULL)
[11:01:37.157]                 if (is_error) {
[11:01:37.157]                   sessionInformation <- function() {
[11:01:37.157]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:37.157]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:37.157]                       search = base::search(), system = base::Sys.info())
[11:01:37.157]                   }
[11:01:37.157]                   ...future.conditions[[length(...future.conditions) + 
[11:01:37.157]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:37.157]                     cond$call), session = sessionInformation(), 
[11:01:37.157]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:37.157]                   signalCondition(cond)
[11:01:37.157]                 }
[11:01:37.157]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:37.157]                 "immediateCondition"))) {
[11:01:37.157]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:37.157]                   ...future.conditions[[length(...future.conditions) + 
[11:01:37.157]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:37.157]                   if (TRUE && !signal) {
[11:01:37.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.157]                     {
[11:01:37.157]                       inherits <- base::inherits
[11:01:37.157]                       invokeRestart <- base::invokeRestart
[11:01:37.157]                       is.null <- base::is.null
[11:01:37.157]                       muffled <- FALSE
[11:01:37.157]                       if (inherits(cond, "message")) {
[11:01:37.157]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:37.157]                         if (muffled) 
[11:01:37.157]                           invokeRestart("muffleMessage")
[11:01:37.157]                       }
[11:01:37.157]                       else if (inherits(cond, "warning")) {
[11:01:37.157]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:37.157]                         if (muffled) 
[11:01:37.157]                           invokeRestart("muffleWarning")
[11:01:37.157]                       }
[11:01:37.157]                       else if (inherits(cond, "condition")) {
[11:01:37.157]                         if (!is.null(pattern)) {
[11:01:37.157]                           computeRestarts <- base::computeRestarts
[11:01:37.157]                           grepl <- base::grepl
[11:01:37.157]                           restarts <- computeRestarts(cond)
[11:01:37.157]                           for (restart in restarts) {
[11:01:37.157]                             name <- restart$name
[11:01:37.157]                             if (is.null(name)) 
[11:01:37.157]                               next
[11:01:37.157]                             if (!grepl(pattern, name)) 
[11:01:37.157]                               next
[11:01:37.157]                             invokeRestart(restart)
[11:01:37.157]                             muffled <- TRUE
[11:01:37.157]                             break
[11:01:37.157]                           }
[11:01:37.157]                         }
[11:01:37.157]                       }
[11:01:37.157]                       invisible(muffled)
[11:01:37.157]                     }
[11:01:37.157]                     muffleCondition(cond, pattern = "^muffle")
[11:01:37.157]                   }
[11:01:37.157]                 }
[11:01:37.157]                 else {
[11:01:37.157]                   if (TRUE) {
[11:01:37.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.157]                     {
[11:01:37.157]                       inherits <- base::inherits
[11:01:37.157]                       invokeRestart <- base::invokeRestart
[11:01:37.157]                       is.null <- base::is.null
[11:01:37.157]                       muffled <- FALSE
[11:01:37.157]                       if (inherits(cond, "message")) {
[11:01:37.157]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:37.157]                         if (muffled) 
[11:01:37.157]                           invokeRestart("muffleMessage")
[11:01:37.157]                       }
[11:01:37.157]                       else if (inherits(cond, "warning")) {
[11:01:37.157]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:37.157]                         if (muffled) 
[11:01:37.157]                           invokeRestart("muffleWarning")
[11:01:37.157]                       }
[11:01:37.157]                       else if (inherits(cond, "condition")) {
[11:01:37.157]                         if (!is.null(pattern)) {
[11:01:37.157]                           computeRestarts <- base::computeRestarts
[11:01:37.157]                           grepl <- base::grepl
[11:01:37.157]                           restarts <- computeRestarts(cond)
[11:01:37.157]                           for (restart in restarts) {
[11:01:37.157]                             name <- restart$name
[11:01:37.157]                             if (is.null(name)) 
[11:01:37.157]                               next
[11:01:37.157]                             if (!grepl(pattern, name)) 
[11:01:37.157]                               next
[11:01:37.157]                             invokeRestart(restart)
[11:01:37.157]                             muffled <- TRUE
[11:01:37.157]                             break
[11:01:37.157]                           }
[11:01:37.157]                         }
[11:01:37.157]                       }
[11:01:37.157]                       invisible(muffled)
[11:01:37.157]                     }
[11:01:37.157]                     muffleCondition(cond, pattern = "^muffle")
[11:01:37.157]                   }
[11:01:37.157]                 }
[11:01:37.157]             }
[11:01:37.157]         }))
[11:01:37.157]     }, error = function(ex) {
[11:01:37.157]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:37.157]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:37.157]                 ...future.rng), started = ...future.startTime, 
[11:01:37.157]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:37.157]             version = "1.8"), class = "FutureResult")
[11:01:37.157]     }, finally = {
[11:01:37.157]         if (!identical(...future.workdir, getwd())) 
[11:01:37.157]             setwd(...future.workdir)
[11:01:37.157]         {
[11:01:37.157]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:37.157]                 ...future.oldOptions$nwarnings <- NULL
[11:01:37.157]             }
[11:01:37.157]             base::options(...future.oldOptions)
[11:01:37.157]             if (.Platform$OS.type == "windows") {
[11:01:37.157]                 old_names <- names(...future.oldEnvVars)
[11:01:37.157]                 envs <- base::Sys.getenv()
[11:01:37.157]                 names <- names(envs)
[11:01:37.157]                 common <- intersect(names, old_names)
[11:01:37.157]                 added <- setdiff(names, old_names)
[11:01:37.157]                 removed <- setdiff(old_names, names)
[11:01:37.157]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:37.157]                   envs[common]]
[11:01:37.157]                 NAMES <- toupper(changed)
[11:01:37.157]                 args <- list()
[11:01:37.157]                 for (kk in seq_along(NAMES)) {
[11:01:37.157]                   name <- changed[[kk]]
[11:01:37.157]                   NAME <- NAMES[[kk]]
[11:01:37.157]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.157]                     next
[11:01:37.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:37.157]                 }
[11:01:37.157]                 NAMES <- toupper(added)
[11:01:37.157]                 for (kk in seq_along(NAMES)) {
[11:01:37.157]                   name <- added[[kk]]
[11:01:37.157]                   NAME <- NAMES[[kk]]
[11:01:37.157]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.157]                     next
[11:01:37.157]                   args[[name]] <- ""
[11:01:37.157]                 }
[11:01:37.157]                 NAMES <- toupper(removed)
[11:01:37.157]                 for (kk in seq_along(NAMES)) {
[11:01:37.157]                   name <- removed[[kk]]
[11:01:37.157]                   NAME <- NAMES[[kk]]
[11:01:37.157]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.157]                     next
[11:01:37.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:37.157]                 }
[11:01:37.157]                 if (length(args) > 0) 
[11:01:37.157]                   base::do.call(base::Sys.setenv, args = args)
[11:01:37.157]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:37.157]             }
[11:01:37.157]             else {
[11:01:37.157]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:37.157]             }
[11:01:37.157]             {
[11:01:37.157]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:37.157]                   0L) {
[11:01:37.157]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:37.157]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:37.157]                   base::options(opts)
[11:01:37.157]                 }
[11:01:37.157]                 {
[11:01:37.157]                   {
[11:01:37.157]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:37.157]                     NULL
[11:01:37.157]                   }
[11:01:37.157]                   options(future.plan = NULL)
[11:01:37.157]                   if (is.na(NA_character_)) 
[11:01:37.157]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:37.157]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:37.157]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:37.157]                     .init = FALSE)
[11:01:37.157]                 }
[11:01:37.157]             }
[11:01:37.157]         }
[11:01:37.157]     })
[11:01:37.157]     if (TRUE) {
[11:01:37.157]         base::sink(type = "output", split = FALSE)
[11:01:37.157]         if (TRUE) {
[11:01:37.157]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:37.157]         }
[11:01:37.157]         else {
[11:01:37.157]             ...future.result["stdout"] <- base::list(NULL)
[11:01:37.157]         }
[11:01:37.157]         base::close(...future.stdout)
[11:01:37.157]         ...future.stdout <- NULL
[11:01:37.157]     }
[11:01:37.157]     ...future.result$conditions <- ...future.conditions
[11:01:37.157]     ...future.result$finished <- base::Sys.time()
[11:01:37.157]     ...future.result
[11:01:37.157] }
[11:01:37.160] Exporting 1 global objects (378 bytes) to cluster node #1 ...
[11:01:37.160] Exporting ‘x’ (71 bytes) to cluster node #1 ...
[11:01:37.160] Exporting ‘x’ (71 bytes) to cluster node #1 ... DONE
[11:01:37.160] Exporting 1 global objects (378 bytes) to cluster node #1 ... DONE
[11:01:37.161] MultisessionFuture started
[11:01:37.161] - Launch lazy future ... done
[11:01:37.161] run() for ‘MultisessionFuture’ ... done
[11:01:37.161] result() for ClusterFuture ...
[11:01:37.161] receiveMessageFromWorker() for ClusterFuture ...
[11:01:37.161] - Validating connection of MultisessionFuture
[11:01:37.204] - received message: FutureResult
[11:01:37.204] - Received FutureResult
[11:01:37.204] - Erased future from FutureRegistry
[11:01:37.204] result() for ClusterFuture ...
[11:01:37.204] - result already collected: FutureResult
[11:01:37.204] result() for ClusterFuture ... done
[11:01:37.204] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:37.204] result() for ClusterFuture ... done
[11:01:37.204] result() for ClusterFuture ...
[11:01:37.205] - result already collected: FutureResult
[11:01:37.205] result() for ClusterFuture ... done
x
1 2 
2 3 
[11:01:37.205] getGlobalsAndPackages() ...
[11:01:37.205] Searching for globals...
[11:01:37.206] - globals found: [4] ‘{’, ‘xtabs’, ‘x’, ‘~’
[11:01:37.207] Searching for globals ... DONE
[11:01:37.207] Resolving globals: FALSE
[11:01:37.207] The total size of the 1 globals is 71 bytes (71 bytes)
[11:01:37.207] The total size of the 1 globals exported for future expression (‘{; xtabs(~x); }’) is 71 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (71 bytes of class ‘numeric’)
[11:01:37.207] - globals: [1] ‘x’
[11:01:37.208] - packages: [1] ‘stats’
[11:01:37.208] getGlobalsAndPackages() ... DONE
[11:01:37.208] run() for ‘Future’ ...
[11:01:37.208] - state: ‘created’
[11:01:37.208] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:37.222] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:37.222] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:37.222]   - Field: ‘node’
[11:01:37.222]   - Field: ‘label’
[11:01:37.222]   - Field: ‘local’
[11:01:37.222]   - Field: ‘owner’
[11:01:37.223]   - Field: ‘envir’
[11:01:37.223]   - Field: ‘workers’
[11:01:37.223]   - Field: ‘packages’
[11:01:37.223]   - Field: ‘gc’
[11:01:37.223]   - Field: ‘conditions’
[11:01:37.223]   - Field: ‘persistent’
[11:01:37.223]   - Field: ‘expr’
[11:01:37.223]   - Field: ‘uuid’
[11:01:37.223]   - Field: ‘seed’
[11:01:37.223]   - Field: ‘version’
[11:01:37.223]   - Field: ‘result’
[11:01:37.223]   - Field: ‘asynchronous’
[11:01:37.224]   - Field: ‘calls’
[11:01:37.224]   - Field: ‘globals’
[11:01:37.224]   - Field: ‘stdout’
[11:01:37.224]   - Field: ‘earlySignal’
[11:01:37.224]   - Field: ‘lazy’
[11:01:37.224]   - Field: ‘state’
[11:01:37.224] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:37.224] - Launch lazy future ...
[11:01:37.224] Packages needed by the future expression (n = 1): ‘stats’
[11:01:37.224] Packages needed by future strategies (n = 0): <none>
[11:01:37.225] {
[11:01:37.225]     {
[11:01:37.225]         {
[11:01:37.225]             ...future.startTime <- base::Sys.time()
[11:01:37.225]             {
[11:01:37.225]                 {
[11:01:37.225]                   {
[11:01:37.225]                     {
[11:01:37.225]                       {
[11:01:37.225]                         base::local({
[11:01:37.225]                           has_future <- base::requireNamespace("future", 
[11:01:37.225]                             quietly = TRUE)
[11:01:37.225]                           if (has_future) {
[11:01:37.225]                             ns <- base::getNamespace("future")
[11:01:37.225]                             version <- ns[[".package"]][["version"]]
[11:01:37.225]                             if (is.null(version)) 
[11:01:37.225]                               version <- utils::packageVersion("future")
[11:01:37.225]                           }
[11:01:37.225]                           else {
[11:01:37.225]                             version <- NULL
[11:01:37.225]                           }
[11:01:37.225]                           if (!has_future || version < "1.8.0") {
[11:01:37.225]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:37.225]                               "", base::R.version$version.string), 
[11:01:37.225]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:37.225]                                 base::R.version$platform, 8 * 
[11:01:37.225]                                   base::.Machine$sizeof.pointer), 
[11:01:37.225]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:37.225]                                 "release", "version")], collapse = " "), 
[11:01:37.225]                               hostname = base::Sys.info()[["nodename"]])
[11:01:37.225]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:37.225]                               info)
[11:01:37.225]                             info <- base::paste(info, collapse = "; ")
[11:01:37.225]                             if (!has_future) {
[11:01:37.225]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:37.225]                                 info)
[11:01:37.225]                             }
[11:01:37.225]                             else {
[11:01:37.225]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:37.225]                                 info, version)
[11:01:37.225]                             }
[11:01:37.225]                             base::stop(msg)
[11:01:37.225]                           }
[11:01:37.225]                         })
[11:01:37.225]                       }
[11:01:37.225]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:37.225]                       base::options(mc.cores = 1L)
[11:01:37.225]                     }
[11:01:37.225]                     base::local({
[11:01:37.225]                       for (pkg in "stats") {
[11:01:37.225]                         base::loadNamespace(pkg)
[11:01:37.225]                         base::library(pkg, character.only = TRUE)
[11:01:37.225]                       }
[11:01:37.225]                     })
[11:01:37.225]                   }
[11:01:37.225]                   ...future.strategy.old <- future::plan("list")
[11:01:37.225]                   options(future.plan = NULL)
[11:01:37.225]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:37.225]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:37.225]                 }
[11:01:37.225]                 ...future.workdir <- getwd()
[11:01:37.225]             }
[11:01:37.225]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:37.225]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:37.225]         }
[11:01:37.225]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:37.225]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:37.225]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:37.225]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:37.225]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:37.225]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:37.225]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:37.225]             base::names(...future.oldOptions))
[11:01:37.225]     }
[11:01:37.225]     if (FALSE) {
[11:01:37.225]     }
[11:01:37.225]     else {
[11:01:37.225]         if (TRUE) {
[11:01:37.225]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:37.225]                 open = "w")
[11:01:37.225]         }
[11:01:37.225]         else {
[11:01:37.225]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:37.225]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:37.225]         }
[11:01:37.225]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:37.225]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:37.225]             base::sink(type = "output", split = FALSE)
[11:01:37.225]             base::close(...future.stdout)
[11:01:37.225]         }, add = TRUE)
[11:01:37.225]     }
[11:01:37.225]     ...future.frame <- base::sys.nframe()
[11:01:37.225]     ...future.conditions <- base::list()
[11:01:37.225]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:37.225]     if (FALSE) {
[11:01:37.225]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:37.225]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:37.225]     }
[11:01:37.225]     ...future.result <- base::tryCatch({
[11:01:37.225]         base::withCallingHandlers({
[11:01:37.225]             ...future.value <- base::withVisible(base::local({
[11:01:37.225]                 ...future.makeSendCondition <- base::local({
[11:01:37.225]                   sendCondition <- NULL
[11:01:37.225]                   function(frame = 1L) {
[11:01:37.225]                     if (is.function(sendCondition)) 
[11:01:37.225]                       return(sendCondition)
[11:01:37.225]                     ns <- getNamespace("parallel")
[11:01:37.225]                     if (exists("sendData", mode = "function", 
[11:01:37.225]                       envir = ns)) {
[11:01:37.225]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:37.225]                         envir = ns)
[11:01:37.225]                       envir <- sys.frame(frame)
[11:01:37.225]                       master <- NULL
[11:01:37.225]                       while (!identical(envir, .GlobalEnv) && 
[11:01:37.225]                         !identical(envir, emptyenv())) {
[11:01:37.225]                         if (exists("master", mode = "list", envir = envir, 
[11:01:37.225]                           inherits = FALSE)) {
[11:01:37.225]                           master <- get("master", mode = "list", 
[11:01:37.225]                             envir = envir, inherits = FALSE)
[11:01:37.225]                           if (inherits(master, c("SOCKnode", 
[11:01:37.225]                             "SOCK0node"))) {
[11:01:37.225]                             sendCondition <<- function(cond) {
[11:01:37.225]                               data <- list(type = "VALUE", value = cond, 
[11:01:37.225]                                 success = TRUE)
[11:01:37.225]                               parallel_sendData(master, data)
[11:01:37.225]                             }
[11:01:37.225]                             return(sendCondition)
[11:01:37.225]                           }
[11:01:37.225]                         }
[11:01:37.225]                         frame <- frame + 1L
[11:01:37.225]                         envir <- sys.frame(frame)
[11:01:37.225]                       }
[11:01:37.225]                     }
[11:01:37.225]                     sendCondition <<- function(cond) NULL
[11:01:37.225]                   }
[11:01:37.225]                 })
[11:01:37.225]                 withCallingHandlers({
[11:01:37.225]                   {
[11:01:37.225]                     xtabs(~x)
[11:01:37.225]                   }
[11:01:37.225]                 }, immediateCondition = function(cond) {
[11:01:37.225]                   sendCondition <- ...future.makeSendCondition()
[11:01:37.225]                   sendCondition(cond)
[11:01:37.225]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.225]                   {
[11:01:37.225]                     inherits <- base::inherits
[11:01:37.225]                     invokeRestart <- base::invokeRestart
[11:01:37.225]                     is.null <- base::is.null
[11:01:37.225]                     muffled <- FALSE
[11:01:37.225]                     if (inherits(cond, "message")) {
[11:01:37.225]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:37.225]                       if (muffled) 
[11:01:37.225]                         invokeRestart("muffleMessage")
[11:01:37.225]                     }
[11:01:37.225]                     else if (inherits(cond, "warning")) {
[11:01:37.225]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:37.225]                       if (muffled) 
[11:01:37.225]                         invokeRestart("muffleWarning")
[11:01:37.225]                     }
[11:01:37.225]                     else if (inherits(cond, "condition")) {
[11:01:37.225]                       if (!is.null(pattern)) {
[11:01:37.225]                         computeRestarts <- base::computeRestarts
[11:01:37.225]                         grepl <- base::grepl
[11:01:37.225]                         restarts <- computeRestarts(cond)
[11:01:37.225]                         for (restart in restarts) {
[11:01:37.225]                           name <- restart$name
[11:01:37.225]                           if (is.null(name)) 
[11:01:37.225]                             next
[11:01:37.225]                           if (!grepl(pattern, name)) 
[11:01:37.225]                             next
[11:01:37.225]                           invokeRestart(restart)
[11:01:37.225]                           muffled <- TRUE
[11:01:37.225]                           break
[11:01:37.225]                         }
[11:01:37.225]                       }
[11:01:37.225]                     }
[11:01:37.225]                     invisible(muffled)
[11:01:37.225]                   }
[11:01:37.225]                   muffleCondition(cond)
[11:01:37.225]                 })
[11:01:37.225]             }))
[11:01:37.225]             future::FutureResult(value = ...future.value$value, 
[11:01:37.225]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:37.225]                   ...future.rng), globalenv = if (FALSE) 
[11:01:37.225]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:37.225]                     ...future.globalenv.names))
[11:01:37.225]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:37.225]         }, condition = base::local({
[11:01:37.225]             c <- base::c
[11:01:37.225]             inherits <- base::inherits
[11:01:37.225]             invokeRestart <- base::invokeRestart
[11:01:37.225]             length <- base::length
[11:01:37.225]             list <- base::list
[11:01:37.225]             seq.int <- base::seq.int
[11:01:37.225]             signalCondition <- base::signalCondition
[11:01:37.225]             sys.calls <- base::sys.calls
[11:01:37.225]             `[[` <- base::`[[`
[11:01:37.225]             `+` <- base::`+`
[11:01:37.225]             `<<-` <- base::`<<-`
[11:01:37.225]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:37.225]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:37.225]                   3L)]
[11:01:37.225]             }
[11:01:37.225]             function(cond) {
[11:01:37.225]                 is_error <- inherits(cond, "error")
[11:01:37.225]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:37.225]                   NULL)
[11:01:37.225]                 if (is_error) {
[11:01:37.225]                   sessionInformation <- function() {
[11:01:37.225]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:37.225]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:37.225]                       search = base::search(), system = base::Sys.info())
[11:01:37.225]                   }
[11:01:37.225]                   ...future.conditions[[length(...future.conditions) + 
[11:01:37.225]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:37.225]                     cond$call), session = sessionInformation(), 
[11:01:37.225]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:37.225]                   signalCondition(cond)
[11:01:37.225]                 }
[11:01:37.225]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:37.225]                 "immediateCondition"))) {
[11:01:37.225]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:37.225]                   ...future.conditions[[length(...future.conditions) + 
[11:01:37.225]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:37.225]                   if (TRUE && !signal) {
[11:01:37.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.225]                     {
[11:01:37.225]                       inherits <- base::inherits
[11:01:37.225]                       invokeRestart <- base::invokeRestart
[11:01:37.225]                       is.null <- base::is.null
[11:01:37.225]                       muffled <- FALSE
[11:01:37.225]                       if (inherits(cond, "message")) {
[11:01:37.225]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:37.225]                         if (muffled) 
[11:01:37.225]                           invokeRestart("muffleMessage")
[11:01:37.225]                       }
[11:01:37.225]                       else if (inherits(cond, "warning")) {
[11:01:37.225]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:37.225]                         if (muffled) 
[11:01:37.225]                           invokeRestart("muffleWarning")
[11:01:37.225]                       }
[11:01:37.225]                       else if (inherits(cond, "condition")) {
[11:01:37.225]                         if (!is.null(pattern)) {
[11:01:37.225]                           computeRestarts <- base::computeRestarts
[11:01:37.225]                           grepl <- base::grepl
[11:01:37.225]                           restarts <- computeRestarts(cond)
[11:01:37.225]                           for (restart in restarts) {
[11:01:37.225]                             name <- restart$name
[11:01:37.225]                             if (is.null(name)) 
[11:01:37.225]                               next
[11:01:37.225]                             if (!grepl(pattern, name)) 
[11:01:37.225]                               next
[11:01:37.225]                             invokeRestart(restart)
[11:01:37.225]                             muffled <- TRUE
[11:01:37.225]                             break
[11:01:37.225]                           }
[11:01:37.225]                         }
[11:01:37.225]                       }
[11:01:37.225]                       invisible(muffled)
[11:01:37.225]                     }
[11:01:37.225]                     muffleCondition(cond, pattern = "^muffle")
[11:01:37.225]                   }
[11:01:37.225]                 }
[11:01:37.225]                 else {
[11:01:37.225]                   if (TRUE) {
[11:01:37.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.225]                     {
[11:01:37.225]                       inherits <- base::inherits
[11:01:37.225]                       invokeRestart <- base::invokeRestart
[11:01:37.225]                       is.null <- base::is.null
[11:01:37.225]                       muffled <- FALSE
[11:01:37.225]                       if (inherits(cond, "message")) {
[11:01:37.225]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:37.225]                         if (muffled) 
[11:01:37.225]                           invokeRestart("muffleMessage")
[11:01:37.225]                       }
[11:01:37.225]                       else if (inherits(cond, "warning")) {
[11:01:37.225]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:37.225]                         if (muffled) 
[11:01:37.225]                           invokeRestart("muffleWarning")
[11:01:37.225]                       }
[11:01:37.225]                       else if (inherits(cond, "condition")) {
[11:01:37.225]                         if (!is.null(pattern)) {
[11:01:37.225]                           computeRestarts <- base::computeRestarts
[11:01:37.225]                           grepl <- base::grepl
[11:01:37.225]                           restarts <- computeRestarts(cond)
[11:01:37.225]                           for (restart in restarts) {
[11:01:37.225]                             name <- restart$name
[11:01:37.225]                             if (is.null(name)) 
[11:01:37.225]                               next
[11:01:37.225]                             if (!grepl(pattern, name)) 
[11:01:37.225]                               next
[11:01:37.225]                             invokeRestart(restart)
[11:01:37.225]                             muffled <- TRUE
[11:01:37.225]                             break
[11:01:37.225]                           }
[11:01:37.225]                         }
[11:01:37.225]                       }
[11:01:37.225]                       invisible(muffled)
[11:01:37.225]                     }
[11:01:37.225]                     muffleCondition(cond, pattern = "^muffle")
[11:01:37.225]                   }
[11:01:37.225]                 }
[11:01:37.225]             }
[11:01:37.225]         }))
[11:01:37.225]     }, error = function(ex) {
[11:01:37.225]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:37.225]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:37.225]                 ...future.rng), started = ...future.startTime, 
[11:01:37.225]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:37.225]             version = "1.8"), class = "FutureResult")
[11:01:37.225]     }, finally = {
[11:01:37.225]         if (!identical(...future.workdir, getwd())) 
[11:01:37.225]             setwd(...future.workdir)
[11:01:37.225]         {
[11:01:37.225]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:37.225]                 ...future.oldOptions$nwarnings <- NULL
[11:01:37.225]             }
[11:01:37.225]             base::options(...future.oldOptions)
[11:01:37.225]             if (.Platform$OS.type == "windows") {
[11:01:37.225]                 old_names <- names(...future.oldEnvVars)
[11:01:37.225]                 envs <- base::Sys.getenv()
[11:01:37.225]                 names <- names(envs)
[11:01:37.225]                 common <- intersect(names, old_names)
[11:01:37.225]                 added <- setdiff(names, old_names)
[11:01:37.225]                 removed <- setdiff(old_names, names)
[11:01:37.225]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:37.225]                   envs[common]]
[11:01:37.225]                 NAMES <- toupper(changed)
[11:01:37.225]                 args <- list()
[11:01:37.225]                 for (kk in seq_along(NAMES)) {
[11:01:37.225]                   name <- changed[[kk]]
[11:01:37.225]                   NAME <- NAMES[[kk]]
[11:01:37.225]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.225]                     next
[11:01:37.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:37.225]                 }
[11:01:37.225]                 NAMES <- toupper(added)
[11:01:37.225]                 for (kk in seq_along(NAMES)) {
[11:01:37.225]                   name <- added[[kk]]
[11:01:37.225]                   NAME <- NAMES[[kk]]
[11:01:37.225]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.225]                     next
[11:01:37.225]                   args[[name]] <- ""
[11:01:37.225]                 }
[11:01:37.225]                 NAMES <- toupper(removed)
[11:01:37.225]                 for (kk in seq_along(NAMES)) {
[11:01:37.225]                   name <- removed[[kk]]
[11:01:37.225]                   NAME <- NAMES[[kk]]
[11:01:37.225]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.225]                     next
[11:01:37.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:37.225]                 }
[11:01:37.225]                 if (length(args) > 0) 
[11:01:37.225]                   base::do.call(base::Sys.setenv, args = args)
[11:01:37.225]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:37.225]             }
[11:01:37.225]             else {
[11:01:37.225]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:37.225]             }
[11:01:37.225]             {
[11:01:37.225]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:37.225]                   0L) {
[11:01:37.225]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:37.225]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:37.225]                   base::options(opts)
[11:01:37.225]                 }
[11:01:37.225]                 {
[11:01:37.225]                   {
[11:01:37.225]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:37.225]                     NULL
[11:01:37.225]                   }
[11:01:37.225]                   options(future.plan = NULL)
[11:01:37.225]                   if (is.na(NA_character_)) 
[11:01:37.225]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:37.225]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:37.225]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:37.225]                     .init = FALSE)
[11:01:37.225]                 }
[11:01:37.225]             }
[11:01:37.225]         }
[11:01:37.225]     })
[11:01:37.225]     if (TRUE) {
[11:01:37.225]         base::sink(type = "output", split = FALSE)
[11:01:37.225]         if (TRUE) {
[11:01:37.225]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:37.225]         }
[11:01:37.225]         else {
[11:01:37.225]             ...future.result["stdout"] <- base::list(NULL)
[11:01:37.225]         }
[11:01:37.225]         base::close(...future.stdout)
[11:01:37.225]         ...future.stdout <- NULL
[11:01:37.225]     }
[11:01:37.225]     ...future.result$conditions <- ...future.conditions
[11:01:37.225]     ...future.result$finished <- base::Sys.time()
[11:01:37.225]     ...future.result
[11:01:37.225] }
[11:01:37.227] Exporting 1 global objects (378 bytes) to cluster node #1 ...
[11:01:37.228] Exporting ‘x’ (71 bytes) to cluster node #1 ...
[11:01:37.228] Exporting ‘x’ (71 bytes) to cluster node #1 ... DONE
[11:01:37.228] Exporting 1 global objects (378 bytes) to cluster node #1 ... DONE
[11:01:37.228] MultisessionFuture started
[11:01:37.229] - Launch lazy future ... done
[11:01:37.229] run() for ‘MultisessionFuture’ ... done
[11:01:37.229] result() for ClusterFuture ...
[11:01:37.229] receiveMessageFromWorker() for ClusterFuture ...
[11:01:37.229] - Validating connection of MultisessionFuture
[11:01:37.270] - received message: FutureResult
[11:01:37.271] - Received FutureResult
[11:01:37.271] - Erased future from FutureRegistry
[11:01:37.271] result() for ClusterFuture ...
[11:01:37.271] - result already collected: FutureResult
[11:01:37.271] result() for ClusterFuture ... done
[11:01:37.271] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:37.271] result() for ClusterFuture ... done
[11:01:37.271] result() for ClusterFuture ...
[11:01:37.271] - result already collected: FutureResult
[11:01:37.271] result() for ClusterFuture ... done
x
1 2 
2 3 
- Globals - lm(<formula>, data = cars) ...
- Globals - lm(<formula #1 (‘a’)>, data = cars) ...

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

[11:01:37.273] getGlobalsAndPackages() ...
[11:01:37.273] Searching for globals...
[11:01:37.274] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘-’, ‘.’, ‘~’, ‘cars’
[11:01:37.274] Searching for globals ... DONE
[11:01:37.275] Resolving globals: FALSE
[11:01:37.275] 
[11:01:37.275] - packages: [2] ‘stats’, ‘datasets’
[11:01:37.275] getGlobalsAndPackages() ... DONE
[11:01:37.275] run() for ‘Future’ ...
[11:01:37.276] - state: ‘created’
[11:01:37.276] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:37.289] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:37.289] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:37.289]   - Field: ‘node’
[11:01:37.290]   - Field: ‘label’
[11:01:37.290]   - Field: ‘local’
[11:01:37.290]   - Field: ‘owner’
[11:01:37.290]   - Field: ‘envir’
[11:01:37.290]   - Field: ‘workers’
[11:01:37.290]   - Field: ‘packages’
[11:01:37.290]   - Field: ‘gc’
[11:01:37.290]   - Field: ‘conditions’
[11:01:37.290]   - Field: ‘persistent’
[11:01:37.290]   - Field: ‘expr’
[11:01:37.290]   - Field: ‘uuid’
[11:01:37.290]   - Field: ‘seed’
[11:01:37.291]   - Field: ‘version’
[11:01:37.291]   - Field: ‘result’
[11:01:37.291]   - Field: ‘asynchronous’
[11:01:37.291]   - Field: ‘calls’
[11:01:37.291]   - Field: ‘globals’
[11:01:37.291]   - Field: ‘stdout’
[11:01:37.291]   - Field: ‘earlySignal’
[11:01:37.291]   - Field: ‘lazy’
[11:01:37.291]   - Field: ‘state’
[11:01:37.291] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:37.291] - Launch lazy future ...
[11:01:37.292] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[11:01:37.292] Packages needed by future strategies (n = 0): <none>
[11:01:37.292] {
[11:01:37.292]     {
[11:01:37.292]         {
[11:01:37.292]             ...future.startTime <- base::Sys.time()
[11:01:37.292]             {
[11:01:37.292]                 {
[11:01:37.292]                   {
[11:01:37.292]                     {
[11:01:37.292]                       {
[11:01:37.292]                         base::local({
[11:01:37.292]                           has_future <- base::requireNamespace("future", 
[11:01:37.292]                             quietly = TRUE)
[11:01:37.292]                           if (has_future) {
[11:01:37.292]                             ns <- base::getNamespace("future")
[11:01:37.292]                             version <- ns[[".package"]][["version"]]
[11:01:37.292]                             if (is.null(version)) 
[11:01:37.292]                               version <- utils::packageVersion("future")
[11:01:37.292]                           }
[11:01:37.292]                           else {
[11:01:37.292]                             version <- NULL
[11:01:37.292]                           }
[11:01:37.292]                           if (!has_future || version < "1.8.0") {
[11:01:37.292]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:37.292]                               "", base::R.version$version.string), 
[11:01:37.292]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:37.292]                                 base::R.version$platform, 8 * 
[11:01:37.292]                                   base::.Machine$sizeof.pointer), 
[11:01:37.292]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:37.292]                                 "release", "version")], collapse = " "), 
[11:01:37.292]                               hostname = base::Sys.info()[["nodename"]])
[11:01:37.292]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:37.292]                               info)
[11:01:37.292]                             info <- base::paste(info, collapse = "; ")
[11:01:37.292]                             if (!has_future) {
[11:01:37.292]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:37.292]                                 info)
[11:01:37.292]                             }
[11:01:37.292]                             else {
[11:01:37.292]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:37.292]                                 info, version)
[11:01:37.292]                             }
[11:01:37.292]                             base::stop(msg)
[11:01:37.292]                           }
[11:01:37.292]                         })
[11:01:37.292]                       }
[11:01:37.292]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:37.292]                       base::options(mc.cores = 1L)
[11:01:37.292]                     }
[11:01:37.292]                     base::local({
[11:01:37.292]                       for (pkg in c("stats", "datasets")) {
[11:01:37.292]                         base::loadNamespace(pkg)
[11:01:37.292]                         base::library(pkg, character.only = TRUE)
[11:01:37.292]                       }
[11:01:37.292]                     })
[11:01:37.292]                   }
[11:01:37.292]                   ...future.strategy.old <- future::plan("list")
[11:01:37.292]                   options(future.plan = NULL)
[11:01:37.292]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:37.292]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:37.292]                 }
[11:01:37.292]                 ...future.workdir <- getwd()
[11:01:37.292]             }
[11:01:37.292]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:37.292]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:37.292]         }
[11:01:37.292]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:37.292]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:37.292]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:37.292]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:37.292]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:37.292]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:37.292]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:37.292]             base::names(...future.oldOptions))
[11:01:37.292]     }
[11:01:37.292]     if (FALSE) {
[11:01:37.292]     }
[11:01:37.292]     else {
[11:01:37.292]         if (TRUE) {
[11:01:37.292]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:37.292]                 open = "w")
[11:01:37.292]         }
[11:01:37.292]         else {
[11:01:37.292]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:37.292]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:37.292]         }
[11:01:37.292]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:37.292]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:37.292]             base::sink(type = "output", split = FALSE)
[11:01:37.292]             base::close(...future.stdout)
[11:01:37.292]         }, add = TRUE)
[11:01:37.292]     }
[11:01:37.292]     ...future.frame <- base::sys.nframe()
[11:01:37.292]     ...future.conditions <- base::list()
[11:01:37.292]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:37.292]     if (FALSE) {
[11:01:37.292]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:37.292]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:37.292]     }
[11:01:37.292]     ...future.result <- base::tryCatch({
[11:01:37.292]         base::withCallingHandlers({
[11:01:37.292]             ...future.value <- base::withVisible(base::local({
[11:01:37.292]                 ...future.makeSendCondition <- base::local({
[11:01:37.292]                   sendCondition <- NULL
[11:01:37.292]                   function(frame = 1L) {
[11:01:37.292]                     if (is.function(sendCondition)) 
[11:01:37.292]                       return(sendCondition)
[11:01:37.292]                     ns <- getNamespace("parallel")
[11:01:37.292]                     if (exists("sendData", mode = "function", 
[11:01:37.292]                       envir = ns)) {
[11:01:37.292]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:37.292]                         envir = ns)
[11:01:37.292]                       envir <- sys.frame(frame)
[11:01:37.292]                       master <- NULL
[11:01:37.292]                       while (!identical(envir, .GlobalEnv) && 
[11:01:37.292]                         !identical(envir, emptyenv())) {
[11:01:37.292]                         if (exists("master", mode = "list", envir = envir, 
[11:01:37.292]                           inherits = FALSE)) {
[11:01:37.292]                           master <- get("master", mode = "list", 
[11:01:37.292]                             envir = envir, inherits = FALSE)
[11:01:37.292]                           if (inherits(master, c("SOCKnode", 
[11:01:37.292]                             "SOCK0node"))) {
[11:01:37.292]                             sendCondition <<- function(cond) {
[11:01:37.292]                               data <- list(type = "VALUE", value = cond, 
[11:01:37.292]                                 success = TRUE)
[11:01:37.292]                               parallel_sendData(master, data)
[11:01:37.292]                             }
[11:01:37.292]                             return(sendCondition)
[11:01:37.292]                           }
[11:01:37.292]                         }
[11:01:37.292]                         frame <- frame + 1L
[11:01:37.292]                         envir <- sys.frame(frame)
[11:01:37.292]                       }
[11:01:37.292]                     }
[11:01:37.292]                     sendCondition <<- function(cond) NULL
[11:01:37.292]                   }
[11:01:37.292]                 })
[11:01:37.292]                 withCallingHandlers({
[11:01:37.292]                   {
[11:01:37.292]                     lm(dist ~ . - 1, data = cars)
[11:01:37.292]                   }
[11:01:37.292]                 }, immediateCondition = function(cond) {
[11:01:37.292]                   sendCondition <- ...future.makeSendCondition()
[11:01:37.292]                   sendCondition(cond)
[11:01:37.292]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.292]                   {
[11:01:37.292]                     inherits <- base::inherits
[11:01:37.292]                     invokeRestart <- base::invokeRestart
[11:01:37.292]                     is.null <- base::is.null
[11:01:37.292]                     muffled <- FALSE
[11:01:37.292]                     if (inherits(cond, "message")) {
[11:01:37.292]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:37.292]                       if (muffled) 
[11:01:37.292]                         invokeRestart("muffleMessage")
[11:01:37.292]                     }
[11:01:37.292]                     else if (inherits(cond, "warning")) {
[11:01:37.292]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:37.292]                       if (muffled) 
[11:01:37.292]                         invokeRestart("muffleWarning")
[11:01:37.292]                     }
[11:01:37.292]                     else if (inherits(cond, "condition")) {
[11:01:37.292]                       if (!is.null(pattern)) {
[11:01:37.292]                         computeRestarts <- base::computeRestarts
[11:01:37.292]                         grepl <- base::grepl
[11:01:37.292]                         restarts <- computeRestarts(cond)
[11:01:37.292]                         for (restart in restarts) {
[11:01:37.292]                           name <- restart$name
[11:01:37.292]                           if (is.null(name)) 
[11:01:37.292]                             next
[11:01:37.292]                           if (!grepl(pattern, name)) 
[11:01:37.292]                             next
[11:01:37.292]                           invokeRestart(restart)
[11:01:37.292]                           muffled <- TRUE
[11:01:37.292]                           break
[11:01:37.292]                         }
[11:01:37.292]                       }
[11:01:37.292]                     }
[11:01:37.292]                     invisible(muffled)
[11:01:37.292]                   }
[11:01:37.292]                   muffleCondition(cond)
[11:01:37.292]                 })
[11:01:37.292]             }))
[11:01:37.292]             future::FutureResult(value = ...future.value$value, 
[11:01:37.292]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:37.292]                   ...future.rng), globalenv = if (FALSE) 
[11:01:37.292]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:37.292]                     ...future.globalenv.names))
[11:01:37.292]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:37.292]         }, condition = base::local({
[11:01:37.292]             c <- base::c
[11:01:37.292]             inherits <- base::inherits
[11:01:37.292]             invokeRestart <- base::invokeRestart
[11:01:37.292]             length <- base::length
[11:01:37.292]             list <- base::list
[11:01:37.292]             seq.int <- base::seq.int
[11:01:37.292]             signalCondition <- base::signalCondition
[11:01:37.292]             sys.calls <- base::sys.calls
[11:01:37.292]             `[[` <- base::`[[`
[11:01:37.292]             `+` <- base::`+`
[11:01:37.292]             `<<-` <- base::`<<-`
[11:01:37.292]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:37.292]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:37.292]                   3L)]
[11:01:37.292]             }
[11:01:37.292]             function(cond) {
[11:01:37.292]                 is_error <- inherits(cond, "error")
[11:01:37.292]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:37.292]                   NULL)
[11:01:37.292]                 if (is_error) {
[11:01:37.292]                   sessionInformation <- function() {
[11:01:37.292]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:37.292]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:37.292]                       search = base::search(), system = base::Sys.info())
[11:01:37.292]                   }
[11:01:37.292]                   ...future.conditions[[length(...future.conditions) + 
[11:01:37.292]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:37.292]                     cond$call), session = sessionInformation(), 
[11:01:37.292]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:37.292]                   signalCondition(cond)
[11:01:37.292]                 }
[11:01:37.292]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:37.292]                 "immediateCondition"))) {
[11:01:37.292]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:37.292]                   ...future.conditions[[length(...future.conditions) + 
[11:01:37.292]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:37.292]                   if (TRUE && !signal) {
[11:01:37.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.292]                     {
[11:01:37.292]                       inherits <- base::inherits
[11:01:37.292]                       invokeRestart <- base::invokeRestart
[11:01:37.292]                       is.null <- base::is.null
[11:01:37.292]                       muffled <- FALSE
[11:01:37.292]                       if (inherits(cond, "message")) {
[11:01:37.292]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:37.292]                         if (muffled) 
[11:01:37.292]                           invokeRestart("muffleMessage")
[11:01:37.292]                       }
[11:01:37.292]                       else if (inherits(cond, "warning")) {
[11:01:37.292]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:37.292]                         if (muffled) 
[11:01:37.292]                           invokeRestart("muffleWarning")
[11:01:37.292]                       }
[11:01:37.292]                       else if (inherits(cond, "condition")) {
[11:01:37.292]                         if (!is.null(pattern)) {
[11:01:37.292]                           computeRestarts <- base::computeRestarts
[11:01:37.292]                           grepl <- base::grepl
[11:01:37.292]                           restarts <- computeRestarts(cond)
[11:01:37.292]                           for (restart in restarts) {
[11:01:37.292]                             name <- restart$name
[11:01:37.292]                             if (is.null(name)) 
[11:01:37.292]                               next
[11:01:37.292]                             if (!grepl(pattern, name)) 
[11:01:37.292]                               next
[11:01:37.292]                             invokeRestart(restart)
[11:01:37.292]                             muffled <- TRUE
[11:01:37.292]                             break
[11:01:37.292]                           }
[11:01:37.292]                         }
[11:01:37.292]                       }
[11:01:37.292]                       invisible(muffled)
[11:01:37.292]                     }
[11:01:37.292]                     muffleCondition(cond, pattern = "^muffle")
[11:01:37.292]                   }
[11:01:37.292]                 }
[11:01:37.292]                 else {
[11:01:37.292]                   if (TRUE) {
[11:01:37.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.292]                     {
[11:01:37.292]                       inherits <- base::inherits
[11:01:37.292]                       invokeRestart <- base::invokeRestart
[11:01:37.292]                       is.null <- base::is.null
[11:01:37.292]                       muffled <- FALSE
[11:01:37.292]                       if (inherits(cond, "message")) {
[11:01:37.292]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:37.292]                         if (muffled) 
[11:01:37.292]                           invokeRestart("muffleMessage")
[11:01:37.292]                       }
[11:01:37.292]                       else if (inherits(cond, "warning")) {
[11:01:37.292]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:37.292]                         if (muffled) 
[11:01:37.292]                           invokeRestart("muffleWarning")
[11:01:37.292]                       }
[11:01:37.292]                       else if (inherits(cond, "condition")) {
[11:01:37.292]                         if (!is.null(pattern)) {
[11:01:37.292]                           computeRestarts <- base::computeRestarts
[11:01:37.292]                           grepl <- base::grepl
[11:01:37.292]                           restarts <- computeRestarts(cond)
[11:01:37.292]                           for (restart in restarts) {
[11:01:37.292]                             name <- restart$name
[11:01:37.292]                             if (is.null(name)) 
[11:01:37.292]                               next
[11:01:37.292]                             if (!grepl(pattern, name)) 
[11:01:37.292]                               next
[11:01:37.292]                             invokeRestart(restart)
[11:01:37.292]                             muffled <- TRUE
[11:01:37.292]                             break
[11:01:37.292]                           }
[11:01:37.292]                         }
[11:01:37.292]                       }
[11:01:37.292]                       invisible(muffled)
[11:01:37.292]                     }
[11:01:37.292]                     muffleCondition(cond, pattern = "^muffle")
[11:01:37.292]                   }
[11:01:37.292]                 }
[11:01:37.292]             }
[11:01:37.292]         }))
[11:01:37.292]     }, error = function(ex) {
[11:01:37.292]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:37.292]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:37.292]                 ...future.rng), started = ...future.startTime, 
[11:01:37.292]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:37.292]             version = "1.8"), class = "FutureResult")
[11:01:37.292]     }, finally = {
[11:01:37.292]         if (!identical(...future.workdir, getwd())) 
[11:01:37.292]             setwd(...future.workdir)
[11:01:37.292]         {
[11:01:37.292]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:37.292]                 ...future.oldOptions$nwarnings <- NULL
[11:01:37.292]             }
[11:01:37.292]             base::options(...future.oldOptions)
[11:01:37.292]             if (.Platform$OS.type == "windows") {
[11:01:37.292]                 old_names <- names(...future.oldEnvVars)
[11:01:37.292]                 envs <- base::Sys.getenv()
[11:01:37.292]                 names <- names(envs)
[11:01:37.292]                 common <- intersect(names, old_names)
[11:01:37.292]                 added <- setdiff(names, old_names)
[11:01:37.292]                 removed <- setdiff(old_names, names)
[11:01:37.292]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:37.292]                   envs[common]]
[11:01:37.292]                 NAMES <- toupper(changed)
[11:01:37.292]                 args <- list()
[11:01:37.292]                 for (kk in seq_along(NAMES)) {
[11:01:37.292]                   name <- changed[[kk]]
[11:01:37.292]                   NAME <- NAMES[[kk]]
[11:01:37.292]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.292]                     next
[11:01:37.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:37.292]                 }
[11:01:37.292]                 NAMES <- toupper(added)
[11:01:37.292]                 for (kk in seq_along(NAMES)) {
[11:01:37.292]                   name <- added[[kk]]
[11:01:37.292]                   NAME <- NAMES[[kk]]
[11:01:37.292]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.292]                     next
[11:01:37.292]                   args[[name]] <- ""
[11:01:37.292]                 }
[11:01:37.292]                 NAMES <- toupper(removed)
[11:01:37.292]                 for (kk in seq_along(NAMES)) {
[11:01:37.292]                   name <- removed[[kk]]
[11:01:37.292]                   NAME <- NAMES[[kk]]
[11:01:37.292]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.292]                     next
[11:01:37.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:37.292]                 }
[11:01:37.292]                 if (length(args) > 0) 
[11:01:37.292]                   base::do.call(base::Sys.setenv, args = args)
[11:01:37.292]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:37.292]             }
[11:01:37.292]             else {
[11:01:37.292]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:37.292]             }
[11:01:37.292]             {
[11:01:37.292]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:37.292]                   0L) {
[11:01:37.292]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:37.292]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:37.292]                   base::options(opts)
[11:01:37.292]                 }
[11:01:37.292]                 {
[11:01:37.292]                   {
[11:01:37.292]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:37.292]                     NULL
[11:01:37.292]                   }
[11:01:37.292]                   options(future.plan = NULL)
[11:01:37.292]                   if (is.na(NA_character_)) 
[11:01:37.292]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:37.292]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:37.292]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:37.292]                     .init = FALSE)
[11:01:37.292]                 }
[11:01:37.292]             }
[11:01:37.292]         }
[11:01:37.292]     })
[11:01:37.292]     if (TRUE) {
[11:01:37.292]         base::sink(type = "output", split = FALSE)
[11:01:37.292]         if (TRUE) {
[11:01:37.292]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:37.292]         }
[11:01:37.292]         else {
[11:01:37.292]             ...future.result["stdout"] <- base::list(NULL)
[11:01:37.292]         }
[11:01:37.292]         base::close(...future.stdout)
[11:01:37.292]         ...future.stdout <- NULL
[11:01:37.292]     }
[11:01:37.292]     ...future.result$conditions <- ...future.conditions
[11:01:37.292]     ...future.result$finished <- base::Sys.time()
[11:01:37.292]     ...future.result
[11:01:37.292] }
[11:01:37.295] MultisessionFuture started
[11:01:37.295] - Launch lazy future ... done
[11:01:37.295] run() for ‘MultisessionFuture’ ... done
[11:01:37.295] result() for ClusterFuture ...
[11:01:37.296] receiveMessageFromWorker() for ClusterFuture ...
[11:01:37.296] - Validating connection of MultisessionFuture
[11:01:37.338] - received message: FutureResult
[11:01:37.338] - Received FutureResult
[11:01:37.338] - Erased future from FutureRegistry
[11:01:37.338] result() for ClusterFuture ...
[11:01:37.339] - result already collected: FutureResult
[11:01:37.339] result() for ClusterFuture ... done
[11:01:37.339] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:37.339] result() for ClusterFuture ... done
[11:01:37.339] result() for ClusterFuture ...
[11:01:37.339] - result already collected: FutureResult
[11:01:37.339] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . - 1, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #2 (‘b’)>, data = cars) ...

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

[11:01:37.341] getGlobalsAndPackages() ...
[11:01:37.341] Searching for globals...
[11:01:37.343] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘.’, ‘~’, ‘cars’
[11:01:37.343] Searching for globals ... DONE
[11:01:37.343] Resolving globals: FALSE
[11:01:37.343] 
[11:01:37.343] - packages: [2] ‘stats’, ‘datasets’
[11:01:37.344] getGlobalsAndPackages() ... DONE
[11:01:37.344] run() for ‘Future’ ...
[11:01:37.344] - state: ‘created’
[11:01:37.344] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:37.357] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:37.358] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:37.358]   - Field: ‘node’
[11:01:37.358]   - Field: ‘label’
[11:01:37.358]   - Field: ‘local’
[11:01:37.358]   - Field: ‘owner’
[11:01:37.358]   - Field: ‘envir’
[11:01:37.358]   - Field: ‘workers’
[11:01:37.358]   - Field: ‘packages’
[11:01:37.358]   - Field: ‘gc’
[11:01:37.358]   - Field: ‘conditions’
[11:01:37.358]   - Field: ‘persistent’
[11:01:37.359]   - Field: ‘expr’
[11:01:37.359]   - Field: ‘uuid’
[11:01:37.359]   - Field: ‘seed’
[11:01:37.359]   - Field: ‘version’
[11:01:37.359]   - Field: ‘result’
[11:01:37.359]   - Field: ‘asynchronous’
[11:01:37.359]   - Field: ‘calls’
[11:01:37.359]   - Field: ‘globals’
[11:01:37.359]   - Field: ‘stdout’
[11:01:37.359]   - Field: ‘earlySignal’
[11:01:37.359]   - Field: ‘lazy’
[11:01:37.359]   - Field: ‘state’
[11:01:37.360] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:37.360] - Launch lazy future ...
[11:01:37.360] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[11:01:37.360] Packages needed by future strategies (n = 0): <none>
[11:01:37.360] {
[11:01:37.360]     {
[11:01:37.360]         {
[11:01:37.360]             ...future.startTime <- base::Sys.time()
[11:01:37.360]             {
[11:01:37.360]                 {
[11:01:37.360]                   {
[11:01:37.360]                     {
[11:01:37.360]                       {
[11:01:37.360]                         base::local({
[11:01:37.360]                           has_future <- base::requireNamespace("future", 
[11:01:37.360]                             quietly = TRUE)
[11:01:37.360]                           if (has_future) {
[11:01:37.360]                             ns <- base::getNamespace("future")
[11:01:37.360]                             version <- ns[[".package"]][["version"]]
[11:01:37.360]                             if (is.null(version)) 
[11:01:37.360]                               version <- utils::packageVersion("future")
[11:01:37.360]                           }
[11:01:37.360]                           else {
[11:01:37.360]                             version <- NULL
[11:01:37.360]                           }
[11:01:37.360]                           if (!has_future || version < "1.8.0") {
[11:01:37.360]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:37.360]                               "", base::R.version$version.string), 
[11:01:37.360]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:37.360]                                 base::R.version$platform, 8 * 
[11:01:37.360]                                   base::.Machine$sizeof.pointer), 
[11:01:37.360]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:37.360]                                 "release", "version")], collapse = " "), 
[11:01:37.360]                               hostname = base::Sys.info()[["nodename"]])
[11:01:37.360]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:37.360]                               info)
[11:01:37.360]                             info <- base::paste(info, collapse = "; ")
[11:01:37.360]                             if (!has_future) {
[11:01:37.360]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:37.360]                                 info)
[11:01:37.360]                             }
[11:01:37.360]                             else {
[11:01:37.360]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:37.360]                                 info, version)
[11:01:37.360]                             }
[11:01:37.360]                             base::stop(msg)
[11:01:37.360]                           }
[11:01:37.360]                         })
[11:01:37.360]                       }
[11:01:37.360]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:37.360]                       base::options(mc.cores = 1L)
[11:01:37.360]                     }
[11:01:37.360]                     base::local({
[11:01:37.360]                       for (pkg in c("stats", "datasets")) {
[11:01:37.360]                         base::loadNamespace(pkg)
[11:01:37.360]                         base::library(pkg, character.only = TRUE)
[11:01:37.360]                       }
[11:01:37.360]                     })
[11:01:37.360]                   }
[11:01:37.360]                   ...future.strategy.old <- future::plan("list")
[11:01:37.360]                   options(future.plan = NULL)
[11:01:37.360]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:37.360]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:37.360]                 }
[11:01:37.360]                 ...future.workdir <- getwd()
[11:01:37.360]             }
[11:01:37.360]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:37.360]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:37.360]         }
[11:01:37.360]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:37.360]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:37.360]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:37.360]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:37.360]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:37.360]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:37.360]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:37.360]             base::names(...future.oldOptions))
[11:01:37.360]     }
[11:01:37.360]     if (FALSE) {
[11:01:37.360]     }
[11:01:37.360]     else {
[11:01:37.360]         if (TRUE) {
[11:01:37.360]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:37.360]                 open = "w")
[11:01:37.360]         }
[11:01:37.360]         else {
[11:01:37.360]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:37.360]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:37.360]         }
[11:01:37.360]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:37.360]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:37.360]             base::sink(type = "output", split = FALSE)
[11:01:37.360]             base::close(...future.stdout)
[11:01:37.360]         }, add = TRUE)
[11:01:37.360]     }
[11:01:37.360]     ...future.frame <- base::sys.nframe()
[11:01:37.360]     ...future.conditions <- base::list()
[11:01:37.360]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:37.360]     if (FALSE) {
[11:01:37.360]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:37.360]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:37.360]     }
[11:01:37.360]     ...future.result <- base::tryCatch({
[11:01:37.360]         base::withCallingHandlers({
[11:01:37.360]             ...future.value <- base::withVisible(base::local({
[11:01:37.360]                 ...future.makeSendCondition <- base::local({
[11:01:37.360]                   sendCondition <- NULL
[11:01:37.360]                   function(frame = 1L) {
[11:01:37.360]                     if (is.function(sendCondition)) 
[11:01:37.360]                       return(sendCondition)
[11:01:37.360]                     ns <- getNamespace("parallel")
[11:01:37.360]                     if (exists("sendData", mode = "function", 
[11:01:37.360]                       envir = ns)) {
[11:01:37.360]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:37.360]                         envir = ns)
[11:01:37.360]                       envir <- sys.frame(frame)
[11:01:37.360]                       master <- NULL
[11:01:37.360]                       while (!identical(envir, .GlobalEnv) && 
[11:01:37.360]                         !identical(envir, emptyenv())) {
[11:01:37.360]                         if (exists("master", mode = "list", envir = envir, 
[11:01:37.360]                           inherits = FALSE)) {
[11:01:37.360]                           master <- get("master", mode = "list", 
[11:01:37.360]                             envir = envir, inherits = FALSE)
[11:01:37.360]                           if (inherits(master, c("SOCKnode", 
[11:01:37.360]                             "SOCK0node"))) {
[11:01:37.360]                             sendCondition <<- function(cond) {
[11:01:37.360]                               data <- list(type = "VALUE", value = cond, 
[11:01:37.360]                                 success = TRUE)
[11:01:37.360]                               parallel_sendData(master, data)
[11:01:37.360]                             }
[11:01:37.360]                             return(sendCondition)
[11:01:37.360]                           }
[11:01:37.360]                         }
[11:01:37.360]                         frame <- frame + 1L
[11:01:37.360]                         envir <- sys.frame(frame)
[11:01:37.360]                       }
[11:01:37.360]                     }
[11:01:37.360]                     sendCondition <<- function(cond) NULL
[11:01:37.360]                   }
[11:01:37.360]                 })
[11:01:37.360]                 withCallingHandlers({
[11:01:37.360]                   {
[11:01:37.360]                     lm(dist ~ . + 0, data = cars)
[11:01:37.360]                   }
[11:01:37.360]                 }, immediateCondition = function(cond) {
[11:01:37.360]                   sendCondition <- ...future.makeSendCondition()
[11:01:37.360]                   sendCondition(cond)
[11:01:37.360]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.360]                   {
[11:01:37.360]                     inherits <- base::inherits
[11:01:37.360]                     invokeRestart <- base::invokeRestart
[11:01:37.360]                     is.null <- base::is.null
[11:01:37.360]                     muffled <- FALSE
[11:01:37.360]                     if (inherits(cond, "message")) {
[11:01:37.360]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:37.360]                       if (muffled) 
[11:01:37.360]                         invokeRestart("muffleMessage")
[11:01:37.360]                     }
[11:01:37.360]                     else if (inherits(cond, "warning")) {
[11:01:37.360]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:37.360]                       if (muffled) 
[11:01:37.360]                         invokeRestart("muffleWarning")
[11:01:37.360]                     }
[11:01:37.360]                     else if (inherits(cond, "condition")) {
[11:01:37.360]                       if (!is.null(pattern)) {
[11:01:37.360]                         computeRestarts <- base::computeRestarts
[11:01:37.360]                         grepl <- base::grepl
[11:01:37.360]                         restarts <- computeRestarts(cond)
[11:01:37.360]                         for (restart in restarts) {
[11:01:37.360]                           name <- restart$name
[11:01:37.360]                           if (is.null(name)) 
[11:01:37.360]                             next
[11:01:37.360]                           if (!grepl(pattern, name)) 
[11:01:37.360]                             next
[11:01:37.360]                           invokeRestart(restart)
[11:01:37.360]                           muffled <- TRUE
[11:01:37.360]                           break
[11:01:37.360]                         }
[11:01:37.360]                       }
[11:01:37.360]                     }
[11:01:37.360]                     invisible(muffled)
[11:01:37.360]                   }
[11:01:37.360]                   muffleCondition(cond)
[11:01:37.360]                 })
[11:01:37.360]             }))
[11:01:37.360]             future::FutureResult(value = ...future.value$value, 
[11:01:37.360]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:37.360]                   ...future.rng), globalenv = if (FALSE) 
[11:01:37.360]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:37.360]                     ...future.globalenv.names))
[11:01:37.360]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:37.360]         }, condition = base::local({
[11:01:37.360]             c <- base::c
[11:01:37.360]             inherits <- base::inherits
[11:01:37.360]             invokeRestart <- base::invokeRestart
[11:01:37.360]             length <- base::length
[11:01:37.360]             list <- base::list
[11:01:37.360]             seq.int <- base::seq.int
[11:01:37.360]             signalCondition <- base::signalCondition
[11:01:37.360]             sys.calls <- base::sys.calls
[11:01:37.360]             `[[` <- base::`[[`
[11:01:37.360]             `+` <- base::`+`
[11:01:37.360]             `<<-` <- base::`<<-`
[11:01:37.360]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:37.360]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:37.360]                   3L)]
[11:01:37.360]             }
[11:01:37.360]             function(cond) {
[11:01:37.360]                 is_error <- inherits(cond, "error")
[11:01:37.360]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:37.360]                   NULL)
[11:01:37.360]                 if (is_error) {
[11:01:37.360]                   sessionInformation <- function() {
[11:01:37.360]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:37.360]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:37.360]                       search = base::search(), system = base::Sys.info())
[11:01:37.360]                   }
[11:01:37.360]                   ...future.conditions[[length(...future.conditions) + 
[11:01:37.360]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:37.360]                     cond$call), session = sessionInformation(), 
[11:01:37.360]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:37.360]                   signalCondition(cond)
[11:01:37.360]                 }
[11:01:37.360]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:37.360]                 "immediateCondition"))) {
[11:01:37.360]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:37.360]                   ...future.conditions[[length(...future.conditions) + 
[11:01:37.360]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:37.360]                   if (TRUE && !signal) {
[11:01:37.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.360]                     {
[11:01:37.360]                       inherits <- base::inherits
[11:01:37.360]                       invokeRestart <- base::invokeRestart
[11:01:37.360]                       is.null <- base::is.null
[11:01:37.360]                       muffled <- FALSE
[11:01:37.360]                       if (inherits(cond, "message")) {
[11:01:37.360]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:37.360]                         if (muffled) 
[11:01:37.360]                           invokeRestart("muffleMessage")
[11:01:37.360]                       }
[11:01:37.360]                       else if (inherits(cond, "warning")) {
[11:01:37.360]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:37.360]                         if (muffled) 
[11:01:37.360]                           invokeRestart("muffleWarning")
[11:01:37.360]                       }
[11:01:37.360]                       else if (inherits(cond, "condition")) {
[11:01:37.360]                         if (!is.null(pattern)) {
[11:01:37.360]                           computeRestarts <- base::computeRestarts
[11:01:37.360]                           grepl <- base::grepl
[11:01:37.360]                           restarts <- computeRestarts(cond)
[11:01:37.360]                           for (restart in restarts) {
[11:01:37.360]                             name <- restart$name
[11:01:37.360]                             if (is.null(name)) 
[11:01:37.360]                               next
[11:01:37.360]                             if (!grepl(pattern, name)) 
[11:01:37.360]                               next
[11:01:37.360]                             invokeRestart(restart)
[11:01:37.360]                             muffled <- TRUE
[11:01:37.360]                             break
[11:01:37.360]                           }
[11:01:37.360]                         }
[11:01:37.360]                       }
[11:01:37.360]                       invisible(muffled)
[11:01:37.360]                     }
[11:01:37.360]                     muffleCondition(cond, pattern = "^muffle")
[11:01:37.360]                   }
[11:01:37.360]                 }
[11:01:37.360]                 else {
[11:01:37.360]                   if (TRUE) {
[11:01:37.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.360]                     {
[11:01:37.360]                       inherits <- base::inherits
[11:01:37.360]                       invokeRestart <- base::invokeRestart
[11:01:37.360]                       is.null <- base::is.null
[11:01:37.360]                       muffled <- FALSE
[11:01:37.360]                       if (inherits(cond, "message")) {
[11:01:37.360]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:37.360]                         if (muffled) 
[11:01:37.360]                           invokeRestart("muffleMessage")
[11:01:37.360]                       }
[11:01:37.360]                       else if (inherits(cond, "warning")) {
[11:01:37.360]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:37.360]                         if (muffled) 
[11:01:37.360]                           invokeRestart("muffleWarning")
[11:01:37.360]                       }
[11:01:37.360]                       else if (inherits(cond, "condition")) {
[11:01:37.360]                         if (!is.null(pattern)) {
[11:01:37.360]                           computeRestarts <- base::computeRestarts
[11:01:37.360]                           grepl <- base::grepl
[11:01:37.360]                           restarts <- computeRestarts(cond)
[11:01:37.360]                           for (restart in restarts) {
[11:01:37.360]                             name <- restart$name
[11:01:37.360]                             if (is.null(name)) 
[11:01:37.360]                               next
[11:01:37.360]                             if (!grepl(pattern, name)) 
[11:01:37.360]                               next
[11:01:37.360]                             invokeRestart(restart)
[11:01:37.360]                             muffled <- TRUE
[11:01:37.360]                             break
[11:01:37.360]                           }
[11:01:37.360]                         }
[11:01:37.360]                       }
[11:01:37.360]                       invisible(muffled)
[11:01:37.360]                     }
[11:01:37.360]                     muffleCondition(cond, pattern = "^muffle")
[11:01:37.360]                   }
[11:01:37.360]                 }
[11:01:37.360]             }
[11:01:37.360]         }))
[11:01:37.360]     }, error = function(ex) {
[11:01:37.360]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:37.360]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:37.360]                 ...future.rng), started = ...future.startTime, 
[11:01:37.360]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:37.360]             version = "1.8"), class = "FutureResult")
[11:01:37.360]     }, finally = {
[11:01:37.360]         if (!identical(...future.workdir, getwd())) 
[11:01:37.360]             setwd(...future.workdir)
[11:01:37.360]         {
[11:01:37.360]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:37.360]                 ...future.oldOptions$nwarnings <- NULL
[11:01:37.360]             }
[11:01:37.360]             base::options(...future.oldOptions)
[11:01:37.360]             if (.Platform$OS.type == "windows") {
[11:01:37.360]                 old_names <- names(...future.oldEnvVars)
[11:01:37.360]                 envs <- base::Sys.getenv()
[11:01:37.360]                 names <- names(envs)
[11:01:37.360]                 common <- intersect(names, old_names)
[11:01:37.360]                 added <- setdiff(names, old_names)
[11:01:37.360]                 removed <- setdiff(old_names, names)
[11:01:37.360]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:37.360]                   envs[common]]
[11:01:37.360]                 NAMES <- toupper(changed)
[11:01:37.360]                 args <- list()
[11:01:37.360]                 for (kk in seq_along(NAMES)) {
[11:01:37.360]                   name <- changed[[kk]]
[11:01:37.360]                   NAME <- NAMES[[kk]]
[11:01:37.360]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.360]                     next
[11:01:37.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:37.360]                 }
[11:01:37.360]                 NAMES <- toupper(added)
[11:01:37.360]                 for (kk in seq_along(NAMES)) {
[11:01:37.360]                   name <- added[[kk]]
[11:01:37.360]                   NAME <- NAMES[[kk]]
[11:01:37.360]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.360]                     next
[11:01:37.360]                   args[[name]] <- ""
[11:01:37.360]                 }
[11:01:37.360]                 NAMES <- toupper(removed)
[11:01:37.360]                 for (kk in seq_along(NAMES)) {
[11:01:37.360]                   name <- removed[[kk]]
[11:01:37.360]                   NAME <- NAMES[[kk]]
[11:01:37.360]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.360]                     next
[11:01:37.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:37.360]                 }
[11:01:37.360]                 if (length(args) > 0) 
[11:01:37.360]                   base::do.call(base::Sys.setenv, args = args)
[11:01:37.360]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:37.360]             }
[11:01:37.360]             else {
[11:01:37.360]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:37.360]             }
[11:01:37.360]             {
[11:01:37.360]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:37.360]                   0L) {
[11:01:37.360]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:37.360]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:37.360]                   base::options(opts)
[11:01:37.360]                 }
[11:01:37.360]                 {
[11:01:37.360]                   {
[11:01:37.360]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:37.360]                     NULL
[11:01:37.360]                   }
[11:01:37.360]                   options(future.plan = NULL)
[11:01:37.360]                   if (is.na(NA_character_)) 
[11:01:37.360]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:37.360]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:37.360]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:37.360]                     .init = FALSE)
[11:01:37.360]                 }
[11:01:37.360]             }
[11:01:37.360]         }
[11:01:37.360]     })
[11:01:37.360]     if (TRUE) {
[11:01:37.360]         base::sink(type = "output", split = FALSE)
[11:01:37.360]         if (TRUE) {
[11:01:37.360]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:37.360]         }
[11:01:37.360]         else {
[11:01:37.360]             ...future.result["stdout"] <- base::list(NULL)
[11:01:37.360]         }
[11:01:37.360]         base::close(...future.stdout)
[11:01:37.360]         ...future.stdout <- NULL
[11:01:37.360]     }
[11:01:37.360]     ...future.result$conditions <- ...future.conditions
[11:01:37.360]     ...future.result$finished <- base::Sys.time()
[11:01:37.360]     ...future.result
[11:01:37.360] }
[11:01:37.363] MultisessionFuture started
[11:01:37.363] - Launch lazy future ... done
[11:01:37.363] run() for ‘MultisessionFuture’ ... done
[11:01:37.364] result() for ClusterFuture ...
[11:01:37.364] receiveMessageFromWorker() for ClusterFuture ...
[11:01:37.364] - Validating connection of MultisessionFuture
[11:01:37.406] - received message: FutureResult
[11:01:37.406] - Received FutureResult
[11:01:37.406] - Erased future from FutureRegistry
[11:01:37.406] result() for ClusterFuture ...
[11:01:37.406] - result already collected: FutureResult
[11:01:37.406] result() for ClusterFuture ... done
[11:01:37.406] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:37.406] result() for ClusterFuture ... done
[11:01:37.407] result() for ClusterFuture ...
[11:01:37.407] - result already collected: FutureResult
[11:01:37.407] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ . + 0, data = cars)

Coefficients:
speed  
2.909  

- Globals - lm(<formula #3 (‘c’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

[11:01:37.409] getGlobalsAndPackages() ...
[11:01:37.409] Searching for globals...
[11:01:37.411] - globals found: [8] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘^’, ‘~’, ‘cars’
[11:01:37.411] Searching for globals ... DONE
[11:01:37.411] Resolving globals: FALSE
[11:01:37.411] 
[11:01:37.411] - packages: [2] ‘stats’, ‘datasets’
[11:01:37.411] getGlobalsAndPackages() ... DONE
[11:01:37.412] run() for ‘Future’ ...
[11:01:37.412] - state: ‘created’
[11:01:37.412] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:37.426] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:37.426] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:37.426]   - Field: ‘node’
[11:01:37.426]   - Field: ‘label’
[11:01:37.426]   - Field: ‘local’
[11:01:37.426]   - Field: ‘owner’
[11:01:37.426]   - Field: ‘envir’
[11:01:37.426]   - Field: ‘workers’
[11:01:37.426]   - Field: ‘packages’
[11:01:37.426]   - Field: ‘gc’
[11:01:37.426]   - Field: ‘conditions’
[11:01:37.427]   - Field: ‘persistent’
[11:01:37.427]   - Field: ‘expr’
[11:01:37.427]   - Field: ‘uuid’
[11:01:37.427]   - Field: ‘seed’
[11:01:37.427]   - Field: ‘version’
[11:01:37.427]   - Field: ‘result’
[11:01:37.427]   - Field: ‘asynchronous’
[11:01:37.427]   - Field: ‘calls’
[11:01:37.427]   - Field: ‘globals’
[11:01:37.427]   - Field: ‘stdout’
[11:01:37.427]   - Field: ‘earlySignal’
[11:01:37.427]   - Field: ‘lazy’
[11:01:37.428]   - Field: ‘state’
[11:01:37.428] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:37.428] - Launch lazy future ...
[11:01:37.428] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[11:01:37.428] Packages needed by future strategies (n = 0): <none>
[11:01:37.429] {
[11:01:37.429]     {
[11:01:37.429]         {
[11:01:37.429]             ...future.startTime <- base::Sys.time()
[11:01:37.429]             {
[11:01:37.429]                 {
[11:01:37.429]                   {
[11:01:37.429]                     {
[11:01:37.429]                       {
[11:01:37.429]                         base::local({
[11:01:37.429]                           has_future <- base::requireNamespace("future", 
[11:01:37.429]                             quietly = TRUE)
[11:01:37.429]                           if (has_future) {
[11:01:37.429]                             ns <- base::getNamespace("future")
[11:01:37.429]                             version <- ns[[".package"]][["version"]]
[11:01:37.429]                             if (is.null(version)) 
[11:01:37.429]                               version <- utils::packageVersion("future")
[11:01:37.429]                           }
[11:01:37.429]                           else {
[11:01:37.429]                             version <- NULL
[11:01:37.429]                           }
[11:01:37.429]                           if (!has_future || version < "1.8.0") {
[11:01:37.429]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:37.429]                               "", base::R.version$version.string), 
[11:01:37.429]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:37.429]                                 base::R.version$platform, 8 * 
[11:01:37.429]                                   base::.Machine$sizeof.pointer), 
[11:01:37.429]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:37.429]                                 "release", "version")], collapse = " "), 
[11:01:37.429]                               hostname = base::Sys.info()[["nodename"]])
[11:01:37.429]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:37.429]                               info)
[11:01:37.429]                             info <- base::paste(info, collapse = "; ")
[11:01:37.429]                             if (!has_future) {
[11:01:37.429]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:37.429]                                 info)
[11:01:37.429]                             }
[11:01:37.429]                             else {
[11:01:37.429]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:37.429]                                 info, version)
[11:01:37.429]                             }
[11:01:37.429]                             base::stop(msg)
[11:01:37.429]                           }
[11:01:37.429]                         })
[11:01:37.429]                       }
[11:01:37.429]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:37.429]                       base::options(mc.cores = 1L)
[11:01:37.429]                     }
[11:01:37.429]                     base::local({
[11:01:37.429]                       for (pkg in c("stats", "datasets")) {
[11:01:37.429]                         base::loadNamespace(pkg)
[11:01:37.429]                         base::library(pkg, character.only = TRUE)
[11:01:37.429]                       }
[11:01:37.429]                     })
[11:01:37.429]                   }
[11:01:37.429]                   ...future.strategy.old <- future::plan("list")
[11:01:37.429]                   options(future.plan = NULL)
[11:01:37.429]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:37.429]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:37.429]                 }
[11:01:37.429]                 ...future.workdir <- getwd()
[11:01:37.429]             }
[11:01:37.429]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:37.429]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:37.429]         }
[11:01:37.429]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:37.429]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:37.429]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:37.429]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:37.429]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:37.429]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:37.429]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:37.429]             base::names(...future.oldOptions))
[11:01:37.429]     }
[11:01:37.429]     if (FALSE) {
[11:01:37.429]     }
[11:01:37.429]     else {
[11:01:37.429]         if (TRUE) {
[11:01:37.429]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:37.429]                 open = "w")
[11:01:37.429]         }
[11:01:37.429]         else {
[11:01:37.429]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:37.429]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:37.429]         }
[11:01:37.429]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:37.429]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:37.429]             base::sink(type = "output", split = FALSE)
[11:01:37.429]             base::close(...future.stdout)
[11:01:37.429]         }, add = TRUE)
[11:01:37.429]     }
[11:01:37.429]     ...future.frame <- base::sys.nframe()
[11:01:37.429]     ...future.conditions <- base::list()
[11:01:37.429]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:37.429]     if (FALSE) {
[11:01:37.429]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:37.429]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:37.429]     }
[11:01:37.429]     ...future.result <- base::tryCatch({
[11:01:37.429]         base::withCallingHandlers({
[11:01:37.429]             ...future.value <- base::withVisible(base::local({
[11:01:37.429]                 ...future.makeSendCondition <- base::local({
[11:01:37.429]                   sendCondition <- NULL
[11:01:37.429]                   function(frame = 1L) {
[11:01:37.429]                     if (is.function(sendCondition)) 
[11:01:37.429]                       return(sendCondition)
[11:01:37.429]                     ns <- getNamespace("parallel")
[11:01:37.429]                     if (exists("sendData", mode = "function", 
[11:01:37.429]                       envir = ns)) {
[11:01:37.429]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:37.429]                         envir = ns)
[11:01:37.429]                       envir <- sys.frame(frame)
[11:01:37.429]                       master <- NULL
[11:01:37.429]                       while (!identical(envir, .GlobalEnv) && 
[11:01:37.429]                         !identical(envir, emptyenv())) {
[11:01:37.429]                         if (exists("master", mode = "list", envir = envir, 
[11:01:37.429]                           inherits = FALSE)) {
[11:01:37.429]                           master <- get("master", mode = "list", 
[11:01:37.429]                             envir = envir, inherits = FALSE)
[11:01:37.429]                           if (inherits(master, c("SOCKnode", 
[11:01:37.429]                             "SOCK0node"))) {
[11:01:37.429]                             sendCondition <<- function(cond) {
[11:01:37.429]                               data <- list(type = "VALUE", value = cond, 
[11:01:37.429]                                 success = TRUE)
[11:01:37.429]                               parallel_sendData(master, data)
[11:01:37.429]                             }
[11:01:37.429]                             return(sendCondition)
[11:01:37.429]                           }
[11:01:37.429]                         }
[11:01:37.429]                         frame <- frame + 1L
[11:01:37.429]                         envir <- sys.frame(frame)
[11:01:37.429]                       }
[11:01:37.429]                     }
[11:01:37.429]                     sendCondition <<- function(cond) NULL
[11:01:37.429]                   }
[11:01:37.429]                 })
[11:01:37.429]                 withCallingHandlers({
[11:01:37.429]                   {
[11:01:37.429]                     lm(dist ~ speed + speed^2, data = cars)
[11:01:37.429]                   }
[11:01:37.429]                 }, immediateCondition = function(cond) {
[11:01:37.429]                   sendCondition <- ...future.makeSendCondition()
[11:01:37.429]                   sendCondition(cond)
[11:01:37.429]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.429]                   {
[11:01:37.429]                     inherits <- base::inherits
[11:01:37.429]                     invokeRestart <- base::invokeRestart
[11:01:37.429]                     is.null <- base::is.null
[11:01:37.429]                     muffled <- FALSE
[11:01:37.429]                     if (inherits(cond, "message")) {
[11:01:37.429]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:37.429]                       if (muffled) 
[11:01:37.429]                         invokeRestart("muffleMessage")
[11:01:37.429]                     }
[11:01:37.429]                     else if (inherits(cond, "warning")) {
[11:01:37.429]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:37.429]                       if (muffled) 
[11:01:37.429]                         invokeRestart("muffleWarning")
[11:01:37.429]                     }
[11:01:37.429]                     else if (inherits(cond, "condition")) {
[11:01:37.429]                       if (!is.null(pattern)) {
[11:01:37.429]                         computeRestarts <- base::computeRestarts
[11:01:37.429]                         grepl <- base::grepl
[11:01:37.429]                         restarts <- computeRestarts(cond)
[11:01:37.429]                         for (restart in restarts) {
[11:01:37.429]                           name <- restart$name
[11:01:37.429]                           if (is.null(name)) 
[11:01:37.429]                             next
[11:01:37.429]                           if (!grepl(pattern, name)) 
[11:01:37.429]                             next
[11:01:37.429]                           invokeRestart(restart)
[11:01:37.429]                           muffled <- TRUE
[11:01:37.429]                           break
[11:01:37.429]                         }
[11:01:37.429]                       }
[11:01:37.429]                     }
[11:01:37.429]                     invisible(muffled)
[11:01:37.429]                   }
[11:01:37.429]                   muffleCondition(cond)
[11:01:37.429]                 })
[11:01:37.429]             }))
[11:01:37.429]             future::FutureResult(value = ...future.value$value, 
[11:01:37.429]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:37.429]                   ...future.rng), globalenv = if (FALSE) 
[11:01:37.429]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:37.429]                     ...future.globalenv.names))
[11:01:37.429]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:37.429]         }, condition = base::local({
[11:01:37.429]             c <- base::c
[11:01:37.429]             inherits <- base::inherits
[11:01:37.429]             invokeRestart <- base::invokeRestart
[11:01:37.429]             length <- base::length
[11:01:37.429]             list <- base::list
[11:01:37.429]             seq.int <- base::seq.int
[11:01:37.429]             signalCondition <- base::signalCondition
[11:01:37.429]             sys.calls <- base::sys.calls
[11:01:37.429]             `[[` <- base::`[[`
[11:01:37.429]             `+` <- base::`+`
[11:01:37.429]             `<<-` <- base::`<<-`
[11:01:37.429]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:37.429]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:37.429]                   3L)]
[11:01:37.429]             }
[11:01:37.429]             function(cond) {
[11:01:37.429]                 is_error <- inherits(cond, "error")
[11:01:37.429]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:37.429]                   NULL)
[11:01:37.429]                 if (is_error) {
[11:01:37.429]                   sessionInformation <- function() {
[11:01:37.429]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:37.429]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:37.429]                       search = base::search(), system = base::Sys.info())
[11:01:37.429]                   }
[11:01:37.429]                   ...future.conditions[[length(...future.conditions) + 
[11:01:37.429]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:37.429]                     cond$call), session = sessionInformation(), 
[11:01:37.429]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:37.429]                   signalCondition(cond)
[11:01:37.429]                 }
[11:01:37.429]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:37.429]                 "immediateCondition"))) {
[11:01:37.429]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:37.429]                   ...future.conditions[[length(...future.conditions) + 
[11:01:37.429]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:37.429]                   if (TRUE && !signal) {
[11:01:37.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.429]                     {
[11:01:37.429]                       inherits <- base::inherits
[11:01:37.429]                       invokeRestart <- base::invokeRestart
[11:01:37.429]                       is.null <- base::is.null
[11:01:37.429]                       muffled <- FALSE
[11:01:37.429]                       if (inherits(cond, "message")) {
[11:01:37.429]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:37.429]                         if (muffled) 
[11:01:37.429]                           invokeRestart("muffleMessage")
[11:01:37.429]                       }
[11:01:37.429]                       else if (inherits(cond, "warning")) {
[11:01:37.429]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:37.429]                         if (muffled) 
[11:01:37.429]                           invokeRestart("muffleWarning")
[11:01:37.429]                       }
[11:01:37.429]                       else if (inherits(cond, "condition")) {
[11:01:37.429]                         if (!is.null(pattern)) {
[11:01:37.429]                           computeRestarts <- base::computeRestarts
[11:01:37.429]                           grepl <- base::grepl
[11:01:37.429]                           restarts <- computeRestarts(cond)
[11:01:37.429]                           for (restart in restarts) {
[11:01:37.429]                             name <- restart$name
[11:01:37.429]                             if (is.null(name)) 
[11:01:37.429]                               next
[11:01:37.429]                             if (!grepl(pattern, name)) 
[11:01:37.429]                               next
[11:01:37.429]                             invokeRestart(restart)
[11:01:37.429]                             muffled <- TRUE
[11:01:37.429]                             break
[11:01:37.429]                           }
[11:01:37.429]                         }
[11:01:37.429]                       }
[11:01:37.429]                       invisible(muffled)
[11:01:37.429]                     }
[11:01:37.429]                     muffleCondition(cond, pattern = "^muffle")
[11:01:37.429]                   }
[11:01:37.429]                 }
[11:01:37.429]                 else {
[11:01:37.429]                   if (TRUE) {
[11:01:37.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.429]                     {
[11:01:37.429]                       inherits <- base::inherits
[11:01:37.429]                       invokeRestart <- base::invokeRestart
[11:01:37.429]                       is.null <- base::is.null
[11:01:37.429]                       muffled <- FALSE
[11:01:37.429]                       if (inherits(cond, "message")) {
[11:01:37.429]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:37.429]                         if (muffled) 
[11:01:37.429]                           invokeRestart("muffleMessage")
[11:01:37.429]                       }
[11:01:37.429]                       else if (inherits(cond, "warning")) {
[11:01:37.429]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:37.429]                         if (muffled) 
[11:01:37.429]                           invokeRestart("muffleWarning")
[11:01:37.429]                       }
[11:01:37.429]                       else if (inherits(cond, "condition")) {
[11:01:37.429]                         if (!is.null(pattern)) {
[11:01:37.429]                           computeRestarts <- base::computeRestarts
[11:01:37.429]                           grepl <- base::grepl
[11:01:37.429]                           restarts <- computeRestarts(cond)
[11:01:37.429]                           for (restart in restarts) {
[11:01:37.429]                             name <- restart$name
[11:01:37.429]                             if (is.null(name)) 
[11:01:37.429]                               next
[11:01:37.429]                             if (!grepl(pattern, name)) 
[11:01:37.429]                               next
[11:01:37.429]                             invokeRestart(restart)
[11:01:37.429]                             muffled <- TRUE
[11:01:37.429]                             break
[11:01:37.429]                           }
[11:01:37.429]                         }
[11:01:37.429]                       }
[11:01:37.429]                       invisible(muffled)
[11:01:37.429]                     }
[11:01:37.429]                     muffleCondition(cond, pattern = "^muffle")
[11:01:37.429]                   }
[11:01:37.429]                 }
[11:01:37.429]             }
[11:01:37.429]         }))
[11:01:37.429]     }, error = function(ex) {
[11:01:37.429]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:37.429]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:37.429]                 ...future.rng), started = ...future.startTime, 
[11:01:37.429]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:37.429]             version = "1.8"), class = "FutureResult")
[11:01:37.429]     }, finally = {
[11:01:37.429]         if (!identical(...future.workdir, getwd())) 
[11:01:37.429]             setwd(...future.workdir)
[11:01:37.429]         {
[11:01:37.429]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:37.429]                 ...future.oldOptions$nwarnings <- NULL
[11:01:37.429]             }
[11:01:37.429]             base::options(...future.oldOptions)
[11:01:37.429]             if (.Platform$OS.type == "windows") {
[11:01:37.429]                 old_names <- names(...future.oldEnvVars)
[11:01:37.429]                 envs <- base::Sys.getenv()
[11:01:37.429]                 names <- names(envs)
[11:01:37.429]                 common <- intersect(names, old_names)
[11:01:37.429]                 added <- setdiff(names, old_names)
[11:01:37.429]                 removed <- setdiff(old_names, names)
[11:01:37.429]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:37.429]                   envs[common]]
[11:01:37.429]                 NAMES <- toupper(changed)
[11:01:37.429]                 args <- list()
[11:01:37.429]                 for (kk in seq_along(NAMES)) {
[11:01:37.429]                   name <- changed[[kk]]
[11:01:37.429]                   NAME <- NAMES[[kk]]
[11:01:37.429]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.429]                     next
[11:01:37.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:37.429]                 }
[11:01:37.429]                 NAMES <- toupper(added)
[11:01:37.429]                 for (kk in seq_along(NAMES)) {
[11:01:37.429]                   name <- added[[kk]]
[11:01:37.429]                   NAME <- NAMES[[kk]]
[11:01:37.429]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.429]                     next
[11:01:37.429]                   args[[name]] <- ""
[11:01:37.429]                 }
[11:01:37.429]                 NAMES <- toupper(removed)
[11:01:37.429]                 for (kk in seq_along(NAMES)) {
[11:01:37.429]                   name <- removed[[kk]]
[11:01:37.429]                   NAME <- NAMES[[kk]]
[11:01:37.429]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.429]                     next
[11:01:37.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:37.429]                 }
[11:01:37.429]                 if (length(args) > 0) 
[11:01:37.429]                   base::do.call(base::Sys.setenv, args = args)
[11:01:37.429]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:37.429]             }
[11:01:37.429]             else {
[11:01:37.429]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:37.429]             }
[11:01:37.429]             {
[11:01:37.429]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:37.429]                   0L) {
[11:01:37.429]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:37.429]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:37.429]                   base::options(opts)
[11:01:37.429]                 }
[11:01:37.429]                 {
[11:01:37.429]                   {
[11:01:37.429]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:37.429]                     NULL
[11:01:37.429]                   }
[11:01:37.429]                   options(future.plan = NULL)
[11:01:37.429]                   if (is.na(NA_character_)) 
[11:01:37.429]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:37.429]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:37.429]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:37.429]                     .init = FALSE)
[11:01:37.429]                 }
[11:01:37.429]             }
[11:01:37.429]         }
[11:01:37.429]     })
[11:01:37.429]     if (TRUE) {
[11:01:37.429]         base::sink(type = "output", split = FALSE)
[11:01:37.429]         if (TRUE) {
[11:01:37.429]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:37.429]         }
[11:01:37.429]         else {
[11:01:37.429]             ...future.result["stdout"] <- base::list(NULL)
[11:01:37.429]         }
[11:01:37.429]         base::close(...future.stdout)
[11:01:37.429]         ...future.stdout <- NULL
[11:01:37.429]     }
[11:01:37.429]     ...future.result$conditions <- ...future.conditions
[11:01:37.429]     ...future.result$finished <- base::Sys.time()
[11:01:37.429]     ...future.result
[11:01:37.429] }
[11:01:37.432] MultisessionFuture started
[11:01:37.432] - Launch lazy future ... done
[11:01:37.432] run() for ‘MultisessionFuture’ ... done
[11:01:37.432] result() for ClusterFuture ...
[11:01:37.432] receiveMessageFromWorker() for ClusterFuture ...
[11:01:37.432] - Validating connection of MultisessionFuture
[11:01:37.474] - received message: FutureResult
[11:01:37.474] - Received FutureResult
[11:01:37.474] - Erased future from FutureRegistry
[11:01:37.474] result() for ClusterFuture ...
[11:01:37.474] - result already collected: FutureResult
[11:01:37.475] result() for ClusterFuture ... done
[11:01:37.476] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:37.477] result() for ClusterFuture ... done
[11:01:37.477] result() for ClusterFuture ...
[11:01:37.477] - result already collected: FutureResult
[11:01:37.477] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + speed^2, data = cars)

Coefficients:
(Intercept)        speed  
    -17.579        3.932  

- Globals - lm(<formula #4 (‘d’)>, data = cars) ...

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

[11:01:37.479] getGlobalsAndPackages() ...
[11:01:37.479] Searching for globals...
[11:01:37.481] - globals found: [9] ‘{’, ‘lm’, ‘dist’, ‘+’, ‘speed’, ‘I’, ‘^’, ‘~’, ‘cars’
[11:01:37.481] Searching for globals ... DONE
[11:01:37.481] Resolving globals: FALSE
[11:01:37.482] 
[11:01:37.482] - packages: [2] ‘stats’, ‘datasets’
[11:01:37.482] getGlobalsAndPackages() ... DONE
[11:01:37.482] run() for ‘Future’ ...
[11:01:37.482] - state: ‘created’
[11:01:37.482] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:37.496] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:37.496] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:37.496]   - Field: ‘node’
[11:01:37.496]   - Field: ‘label’
[11:01:37.496]   - Field: ‘local’
[11:01:37.496]   - Field: ‘owner’
[11:01:37.496]   - Field: ‘envir’
[11:01:37.497]   - Field: ‘workers’
[11:01:37.497]   - Field: ‘packages’
[11:01:37.497]   - Field: ‘gc’
[11:01:37.497]   - Field: ‘conditions’
[11:01:37.497]   - Field: ‘persistent’
[11:01:37.497]   - Field: ‘expr’
[11:01:37.497]   - Field: ‘uuid’
[11:01:37.497]   - Field: ‘seed’
[11:01:37.497]   - Field: ‘version’
[11:01:37.497]   - Field: ‘result’
[11:01:37.497]   - Field: ‘asynchronous’
[11:01:37.497]   - Field: ‘calls’
[11:01:37.497]   - Field: ‘globals’
[11:01:37.498]   - Field: ‘stdout’
[11:01:37.498]   - Field: ‘earlySignal’
[11:01:37.498]   - Field: ‘lazy’
[11:01:37.498]   - Field: ‘state’
[11:01:37.498] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:37.498] - Launch lazy future ...
[11:01:37.498] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[11:01:37.498] Packages needed by future strategies (n = 0): <none>
[11:01:37.499] {
[11:01:37.499]     {
[11:01:37.499]         {
[11:01:37.499]             ...future.startTime <- base::Sys.time()
[11:01:37.499]             {
[11:01:37.499]                 {
[11:01:37.499]                   {
[11:01:37.499]                     {
[11:01:37.499]                       {
[11:01:37.499]                         base::local({
[11:01:37.499]                           has_future <- base::requireNamespace("future", 
[11:01:37.499]                             quietly = TRUE)
[11:01:37.499]                           if (has_future) {
[11:01:37.499]                             ns <- base::getNamespace("future")
[11:01:37.499]                             version <- ns[[".package"]][["version"]]
[11:01:37.499]                             if (is.null(version)) 
[11:01:37.499]                               version <- utils::packageVersion("future")
[11:01:37.499]                           }
[11:01:37.499]                           else {
[11:01:37.499]                             version <- NULL
[11:01:37.499]                           }
[11:01:37.499]                           if (!has_future || version < "1.8.0") {
[11:01:37.499]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:37.499]                               "", base::R.version$version.string), 
[11:01:37.499]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:37.499]                                 base::R.version$platform, 8 * 
[11:01:37.499]                                   base::.Machine$sizeof.pointer), 
[11:01:37.499]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:37.499]                                 "release", "version")], collapse = " "), 
[11:01:37.499]                               hostname = base::Sys.info()[["nodename"]])
[11:01:37.499]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:37.499]                               info)
[11:01:37.499]                             info <- base::paste(info, collapse = "; ")
[11:01:37.499]                             if (!has_future) {
[11:01:37.499]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:37.499]                                 info)
[11:01:37.499]                             }
[11:01:37.499]                             else {
[11:01:37.499]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:37.499]                                 info, version)
[11:01:37.499]                             }
[11:01:37.499]                             base::stop(msg)
[11:01:37.499]                           }
[11:01:37.499]                         })
[11:01:37.499]                       }
[11:01:37.499]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:37.499]                       base::options(mc.cores = 1L)
[11:01:37.499]                     }
[11:01:37.499]                     base::local({
[11:01:37.499]                       for (pkg in c("stats", "datasets")) {
[11:01:37.499]                         base::loadNamespace(pkg)
[11:01:37.499]                         base::library(pkg, character.only = TRUE)
[11:01:37.499]                       }
[11:01:37.499]                     })
[11:01:37.499]                   }
[11:01:37.499]                   ...future.strategy.old <- future::plan("list")
[11:01:37.499]                   options(future.plan = NULL)
[11:01:37.499]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:37.499]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:37.499]                 }
[11:01:37.499]                 ...future.workdir <- getwd()
[11:01:37.499]             }
[11:01:37.499]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:37.499]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:37.499]         }
[11:01:37.499]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:37.499]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:37.499]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:37.499]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:37.499]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:37.499]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:37.499]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:37.499]             base::names(...future.oldOptions))
[11:01:37.499]     }
[11:01:37.499]     if (FALSE) {
[11:01:37.499]     }
[11:01:37.499]     else {
[11:01:37.499]         if (TRUE) {
[11:01:37.499]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:37.499]                 open = "w")
[11:01:37.499]         }
[11:01:37.499]         else {
[11:01:37.499]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:37.499]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:37.499]         }
[11:01:37.499]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:37.499]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:37.499]             base::sink(type = "output", split = FALSE)
[11:01:37.499]             base::close(...future.stdout)
[11:01:37.499]         }, add = TRUE)
[11:01:37.499]     }
[11:01:37.499]     ...future.frame <- base::sys.nframe()
[11:01:37.499]     ...future.conditions <- base::list()
[11:01:37.499]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:37.499]     if (FALSE) {
[11:01:37.499]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:37.499]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:37.499]     }
[11:01:37.499]     ...future.result <- base::tryCatch({
[11:01:37.499]         base::withCallingHandlers({
[11:01:37.499]             ...future.value <- base::withVisible(base::local({
[11:01:37.499]                 ...future.makeSendCondition <- base::local({
[11:01:37.499]                   sendCondition <- NULL
[11:01:37.499]                   function(frame = 1L) {
[11:01:37.499]                     if (is.function(sendCondition)) 
[11:01:37.499]                       return(sendCondition)
[11:01:37.499]                     ns <- getNamespace("parallel")
[11:01:37.499]                     if (exists("sendData", mode = "function", 
[11:01:37.499]                       envir = ns)) {
[11:01:37.499]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:37.499]                         envir = ns)
[11:01:37.499]                       envir <- sys.frame(frame)
[11:01:37.499]                       master <- NULL
[11:01:37.499]                       while (!identical(envir, .GlobalEnv) && 
[11:01:37.499]                         !identical(envir, emptyenv())) {
[11:01:37.499]                         if (exists("master", mode = "list", envir = envir, 
[11:01:37.499]                           inherits = FALSE)) {
[11:01:37.499]                           master <- get("master", mode = "list", 
[11:01:37.499]                             envir = envir, inherits = FALSE)
[11:01:37.499]                           if (inherits(master, c("SOCKnode", 
[11:01:37.499]                             "SOCK0node"))) {
[11:01:37.499]                             sendCondition <<- function(cond) {
[11:01:37.499]                               data <- list(type = "VALUE", value = cond, 
[11:01:37.499]                                 success = TRUE)
[11:01:37.499]                               parallel_sendData(master, data)
[11:01:37.499]                             }
[11:01:37.499]                             return(sendCondition)
[11:01:37.499]                           }
[11:01:37.499]                         }
[11:01:37.499]                         frame <- frame + 1L
[11:01:37.499]                         envir <- sys.frame(frame)
[11:01:37.499]                       }
[11:01:37.499]                     }
[11:01:37.499]                     sendCondition <<- function(cond) NULL
[11:01:37.499]                   }
[11:01:37.499]                 })
[11:01:37.499]                 withCallingHandlers({
[11:01:37.499]                   {
[11:01:37.499]                     lm(dist ~ speed + I(speed^2), data = cars)
[11:01:37.499]                   }
[11:01:37.499]                 }, immediateCondition = function(cond) {
[11:01:37.499]                   sendCondition <- ...future.makeSendCondition()
[11:01:37.499]                   sendCondition(cond)
[11:01:37.499]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.499]                   {
[11:01:37.499]                     inherits <- base::inherits
[11:01:37.499]                     invokeRestart <- base::invokeRestart
[11:01:37.499]                     is.null <- base::is.null
[11:01:37.499]                     muffled <- FALSE
[11:01:37.499]                     if (inherits(cond, "message")) {
[11:01:37.499]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:37.499]                       if (muffled) 
[11:01:37.499]                         invokeRestart("muffleMessage")
[11:01:37.499]                     }
[11:01:37.499]                     else if (inherits(cond, "warning")) {
[11:01:37.499]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:37.499]                       if (muffled) 
[11:01:37.499]                         invokeRestart("muffleWarning")
[11:01:37.499]                     }
[11:01:37.499]                     else if (inherits(cond, "condition")) {
[11:01:37.499]                       if (!is.null(pattern)) {
[11:01:37.499]                         computeRestarts <- base::computeRestarts
[11:01:37.499]                         grepl <- base::grepl
[11:01:37.499]                         restarts <- computeRestarts(cond)
[11:01:37.499]                         for (restart in restarts) {
[11:01:37.499]                           name <- restart$name
[11:01:37.499]                           if (is.null(name)) 
[11:01:37.499]                             next
[11:01:37.499]                           if (!grepl(pattern, name)) 
[11:01:37.499]                             next
[11:01:37.499]                           invokeRestart(restart)
[11:01:37.499]                           muffled <- TRUE
[11:01:37.499]                           break
[11:01:37.499]                         }
[11:01:37.499]                       }
[11:01:37.499]                     }
[11:01:37.499]                     invisible(muffled)
[11:01:37.499]                   }
[11:01:37.499]                   muffleCondition(cond)
[11:01:37.499]                 })
[11:01:37.499]             }))
[11:01:37.499]             future::FutureResult(value = ...future.value$value, 
[11:01:37.499]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:37.499]                   ...future.rng), globalenv = if (FALSE) 
[11:01:37.499]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:37.499]                     ...future.globalenv.names))
[11:01:37.499]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:37.499]         }, condition = base::local({
[11:01:37.499]             c <- base::c
[11:01:37.499]             inherits <- base::inherits
[11:01:37.499]             invokeRestart <- base::invokeRestart
[11:01:37.499]             length <- base::length
[11:01:37.499]             list <- base::list
[11:01:37.499]             seq.int <- base::seq.int
[11:01:37.499]             signalCondition <- base::signalCondition
[11:01:37.499]             sys.calls <- base::sys.calls
[11:01:37.499]             `[[` <- base::`[[`
[11:01:37.499]             `+` <- base::`+`
[11:01:37.499]             `<<-` <- base::`<<-`
[11:01:37.499]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:37.499]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:37.499]                   3L)]
[11:01:37.499]             }
[11:01:37.499]             function(cond) {
[11:01:37.499]                 is_error <- inherits(cond, "error")
[11:01:37.499]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:37.499]                   NULL)
[11:01:37.499]                 if (is_error) {
[11:01:37.499]                   sessionInformation <- function() {
[11:01:37.499]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:37.499]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:37.499]                       search = base::search(), system = base::Sys.info())
[11:01:37.499]                   }
[11:01:37.499]                   ...future.conditions[[length(...future.conditions) + 
[11:01:37.499]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:37.499]                     cond$call), session = sessionInformation(), 
[11:01:37.499]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:37.499]                   signalCondition(cond)
[11:01:37.499]                 }
[11:01:37.499]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:37.499]                 "immediateCondition"))) {
[11:01:37.499]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:37.499]                   ...future.conditions[[length(...future.conditions) + 
[11:01:37.499]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:37.499]                   if (TRUE && !signal) {
[11:01:37.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.499]                     {
[11:01:37.499]                       inherits <- base::inherits
[11:01:37.499]                       invokeRestart <- base::invokeRestart
[11:01:37.499]                       is.null <- base::is.null
[11:01:37.499]                       muffled <- FALSE
[11:01:37.499]                       if (inherits(cond, "message")) {
[11:01:37.499]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:37.499]                         if (muffled) 
[11:01:37.499]                           invokeRestart("muffleMessage")
[11:01:37.499]                       }
[11:01:37.499]                       else if (inherits(cond, "warning")) {
[11:01:37.499]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:37.499]                         if (muffled) 
[11:01:37.499]                           invokeRestart("muffleWarning")
[11:01:37.499]                       }
[11:01:37.499]                       else if (inherits(cond, "condition")) {
[11:01:37.499]                         if (!is.null(pattern)) {
[11:01:37.499]                           computeRestarts <- base::computeRestarts
[11:01:37.499]                           grepl <- base::grepl
[11:01:37.499]                           restarts <- computeRestarts(cond)
[11:01:37.499]                           for (restart in restarts) {
[11:01:37.499]                             name <- restart$name
[11:01:37.499]                             if (is.null(name)) 
[11:01:37.499]                               next
[11:01:37.499]                             if (!grepl(pattern, name)) 
[11:01:37.499]                               next
[11:01:37.499]                             invokeRestart(restart)
[11:01:37.499]                             muffled <- TRUE
[11:01:37.499]                             break
[11:01:37.499]                           }
[11:01:37.499]                         }
[11:01:37.499]                       }
[11:01:37.499]                       invisible(muffled)
[11:01:37.499]                     }
[11:01:37.499]                     muffleCondition(cond, pattern = "^muffle")
[11:01:37.499]                   }
[11:01:37.499]                 }
[11:01:37.499]                 else {
[11:01:37.499]                   if (TRUE) {
[11:01:37.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.499]                     {
[11:01:37.499]                       inherits <- base::inherits
[11:01:37.499]                       invokeRestart <- base::invokeRestart
[11:01:37.499]                       is.null <- base::is.null
[11:01:37.499]                       muffled <- FALSE
[11:01:37.499]                       if (inherits(cond, "message")) {
[11:01:37.499]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:37.499]                         if (muffled) 
[11:01:37.499]                           invokeRestart("muffleMessage")
[11:01:37.499]                       }
[11:01:37.499]                       else if (inherits(cond, "warning")) {
[11:01:37.499]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:37.499]                         if (muffled) 
[11:01:37.499]                           invokeRestart("muffleWarning")
[11:01:37.499]                       }
[11:01:37.499]                       else if (inherits(cond, "condition")) {
[11:01:37.499]                         if (!is.null(pattern)) {
[11:01:37.499]                           computeRestarts <- base::computeRestarts
[11:01:37.499]                           grepl <- base::grepl
[11:01:37.499]                           restarts <- computeRestarts(cond)
[11:01:37.499]                           for (restart in restarts) {
[11:01:37.499]                             name <- restart$name
[11:01:37.499]                             if (is.null(name)) 
[11:01:37.499]                               next
[11:01:37.499]                             if (!grepl(pattern, name)) 
[11:01:37.499]                               next
[11:01:37.499]                             invokeRestart(restart)
[11:01:37.499]                             muffled <- TRUE
[11:01:37.499]                             break
[11:01:37.499]                           }
[11:01:37.499]                         }
[11:01:37.499]                       }
[11:01:37.499]                       invisible(muffled)
[11:01:37.499]                     }
[11:01:37.499]                     muffleCondition(cond, pattern = "^muffle")
[11:01:37.499]                   }
[11:01:37.499]                 }
[11:01:37.499]             }
[11:01:37.499]         }))
[11:01:37.499]     }, error = function(ex) {
[11:01:37.499]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:37.499]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:37.499]                 ...future.rng), started = ...future.startTime, 
[11:01:37.499]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:37.499]             version = "1.8"), class = "FutureResult")
[11:01:37.499]     }, finally = {
[11:01:37.499]         if (!identical(...future.workdir, getwd())) 
[11:01:37.499]             setwd(...future.workdir)
[11:01:37.499]         {
[11:01:37.499]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:37.499]                 ...future.oldOptions$nwarnings <- NULL
[11:01:37.499]             }
[11:01:37.499]             base::options(...future.oldOptions)
[11:01:37.499]             if (.Platform$OS.type == "windows") {
[11:01:37.499]                 old_names <- names(...future.oldEnvVars)
[11:01:37.499]                 envs <- base::Sys.getenv()
[11:01:37.499]                 names <- names(envs)
[11:01:37.499]                 common <- intersect(names, old_names)
[11:01:37.499]                 added <- setdiff(names, old_names)
[11:01:37.499]                 removed <- setdiff(old_names, names)
[11:01:37.499]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:37.499]                   envs[common]]
[11:01:37.499]                 NAMES <- toupper(changed)
[11:01:37.499]                 args <- list()
[11:01:37.499]                 for (kk in seq_along(NAMES)) {
[11:01:37.499]                   name <- changed[[kk]]
[11:01:37.499]                   NAME <- NAMES[[kk]]
[11:01:37.499]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.499]                     next
[11:01:37.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:37.499]                 }
[11:01:37.499]                 NAMES <- toupper(added)
[11:01:37.499]                 for (kk in seq_along(NAMES)) {
[11:01:37.499]                   name <- added[[kk]]
[11:01:37.499]                   NAME <- NAMES[[kk]]
[11:01:37.499]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.499]                     next
[11:01:37.499]                   args[[name]] <- ""
[11:01:37.499]                 }
[11:01:37.499]                 NAMES <- toupper(removed)
[11:01:37.499]                 for (kk in seq_along(NAMES)) {
[11:01:37.499]                   name <- removed[[kk]]
[11:01:37.499]                   NAME <- NAMES[[kk]]
[11:01:37.499]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.499]                     next
[11:01:37.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:37.499]                 }
[11:01:37.499]                 if (length(args) > 0) 
[11:01:37.499]                   base::do.call(base::Sys.setenv, args = args)
[11:01:37.499]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:37.499]             }
[11:01:37.499]             else {
[11:01:37.499]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:37.499]             }
[11:01:37.499]             {
[11:01:37.499]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:37.499]                   0L) {
[11:01:37.499]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:37.499]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:37.499]                   base::options(opts)
[11:01:37.499]                 }
[11:01:37.499]                 {
[11:01:37.499]                   {
[11:01:37.499]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:37.499]                     NULL
[11:01:37.499]                   }
[11:01:37.499]                   options(future.plan = NULL)
[11:01:37.499]                   if (is.na(NA_character_)) 
[11:01:37.499]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:37.499]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:37.499]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:37.499]                     .init = FALSE)
[11:01:37.499]                 }
[11:01:37.499]             }
[11:01:37.499]         }
[11:01:37.499]     })
[11:01:37.499]     if (TRUE) {
[11:01:37.499]         base::sink(type = "output", split = FALSE)
[11:01:37.499]         if (TRUE) {
[11:01:37.499]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:37.499]         }
[11:01:37.499]         else {
[11:01:37.499]             ...future.result["stdout"] <- base::list(NULL)
[11:01:37.499]         }
[11:01:37.499]         base::close(...future.stdout)
[11:01:37.499]         ...future.stdout <- NULL
[11:01:37.499]     }
[11:01:37.499]     ...future.result$conditions <- ...future.conditions
[11:01:37.499]     ...future.result$finished <- base::Sys.time()
[11:01:37.499]     ...future.result
[11:01:37.499] }
[11:01:37.502] MultisessionFuture started
[11:01:37.502] - Launch lazy future ... done
[11:01:37.502] run() for ‘MultisessionFuture’ ... done
[11:01:37.502] result() for ClusterFuture ...
[11:01:37.502] receiveMessageFromWorker() for ClusterFuture ...
[11:01:37.502] - Validating connection of MultisessionFuture
[11:01:37.545] - received message: FutureResult
[11:01:37.545] - Received FutureResult
[11:01:37.545] - Erased future from FutureRegistry
[11:01:37.545] result() for ClusterFuture ...
[11:01:37.545] - result already collected: FutureResult
[11:01:37.545] result() for ClusterFuture ... done
[11:01:37.546] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:37.546] result() for ClusterFuture ... done
[11:01:37.546] result() for ClusterFuture ...
[11:01:37.546] - result already collected: FutureResult
[11:01:37.546] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ speed + I(speed^2), data = cars)

Coefficients:
(Intercept)        speed   I(speed^2)  
    2.47014      0.91329      0.09996  

- Globals - lm(<formula #5 (‘e’)>, data = cars) ...

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

[11:01:37.548] getGlobalsAndPackages() ...
[11:01:37.548] Searching for globals...
[11:01:37.550] - globals found: [7] ‘{’, ‘lm’, ‘dist’, ‘poly’, ‘speed’, ‘~’, ‘cars’
[11:01:37.550] Searching for globals ... DONE
[11:01:37.550] Resolving globals: FALSE
[11:01:37.551] 
[11:01:37.551] - packages: [2] ‘stats’, ‘datasets’
[11:01:37.551] getGlobalsAndPackages() ... DONE
[11:01:37.551] run() for ‘Future’ ...
[11:01:37.551] - state: ‘created’
[11:01:37.551] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:37.565] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:37.566] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:37.566]   - Field: ‘node’
[11:01:37.566]   - Field: ‘label’
[11:01:37.566]   - Field: ‘local’
[11:01:37.566]   - Field: ‘owner’
[11:01:37.566]   - Field: ‘envir’
[11:01:37.566]   - Field: ‘workers’
[11:01:37.566]   - Field: ‘packages’
[11:01:37.566]   - Field: ‘gc’
[11:01:37.566]   - Field: ‘conditions’
[11:01:37.567]   - Field: ‘persistent’
[11:01:37.567]   - Field: ‘expr’
[11:01:37.567]   - Field: ‘uuid’
[11:01:37.567]   - Field: ‘seed’
[11:01:37.567]   - Field: ‘version’
[11:01:37.567]   - Field: ‘result’
[11:01:37.567]   - Field: ‘asynchronous’
[11:01:37.567]   - Field: ‘calls’
[11:01:37.567]   - Field: ‘globals’
[11:01:37.567]   - Field: ‘stdout’
[11:01:37.567]   - Field: ‘earlySignal’
[11:01:37.567]   - Field: ‘lazy’
[11:01:37.568]   - Field: ‘state’
[11:01:37.568] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:37.568] - Launch lazy future ...
[11:01:37.568] Packages needed by the future expression (n = 2): ‘stats’, ‘datasets’
[11:01:37.568] Packages needed by future strategies (n = 0): <none>
[11:01:37.569] {
[11:01:37.569]     {
[11:01:37.569]         {
[11:01:37.569]             ...future.startTime <- base::Sys.time()
[11:01:37.569]             {
[11:01:37.569]                 {
[11:01:37.569]                   {
[11:01:37.569]                     {
[11:01:37.569]                       {
[11:01:37.569]                         base::local({
[11:01:37.569]                           has_future <- base::requireNamespace("future", 
[11:01:37.569]                             quietly = TRUE)
[11:01:37.569]                           if (has_future) {
[11:01:37.569]                             ns <- base::getNamespace("future")
[11:01:37.569]                             version <- ns[[".package"]][["version"]]
[11:01:37.569]                             if (is.null(version)) 
[11:01:37.569]                               version <- utils::packageVersion("future")
[11:01:37.569]                           }
[11:01:37.569]                           else {
[11:01:37.569]                             version <- NULL
[11:01:37.569]                           }
[11:01:37.569]                           if (!has_future || version < "1.8.0") {
[11:01:37.569]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:37.569]                               "", base::R.version$version.string), 
[11:01:37.569]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:37.569]                                 base::R.version$platform, 8 * 
[11:01:37.569]                                   base::.Machine$sizeof.pointer), 
[11:01:37.569]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:37.569]                                 "release", "version")], collapse = " "), 
[11:01:37.569]                               hostname = base::Sys.info()[["nodename"]])
[11:01:37.569]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:37.569]                               info)
[11:01:37.569]                             info <- base::paste(info, collapse = "; ")
[11:01:37.569]                             if (!has_future) {
[11:01:37.569]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:37.569]                                 info)
[11:01:37.569]                             }
[11:01:37.569]                             else {
[11:01:37.569]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:37.569]                                 info, version)
[11:01:37.569]                             }
[11:01:37.569]                             base::stop(msg)
[11:01:37.569]                           }
[11:01:37.569]                         })
[11:01:37.569]                       }
[11:01:37.569]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:37.569]                       base::options(mc.cores = 1L)
[11:01:37.569]                     }
[11:01:37.569]                     base::local({
[11:01:37.569]                       for (pkg in c("stats", "datasets")) {
[11:01:37.569]                         base::loadNamespace(pkg)
[11:01:37.569]                         base::library(pkg, character.only = TRUE)
[11:01:37.569]                       }
[11:01:37.569]                     })
[11:01:37.569]                   }
[11:01:37.569]                   ...future.strategy.old <- future::plan("list")
[11:01:37.569]                   options(future.plan = NULL)
[11:01:37.569]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:37.569]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:37.569]                 }
[11:01:37.569]                 ...future.workdir <- getwd()
[11:01:37.569]             }
[11:01:37.569]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:37.569]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:37.569]         }
[11:01:37.569]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:37.569]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:37.569]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:37.569]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:37.569]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:37.569]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:37.569]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:37.569]             base::names(...future.oldOptions))
[11:01:37.569]     }
[11:01:37.569]     if (FALSE) {
[11:01:37.569]     }
[11:01:37.569]     else {
[11:01:37.569]         if (TRUE) {
[11:01:37.569]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:37.569]                 open = "w")
[11:01:37.569]         }
[11:01:37.569]         else {
[11:01:37.569]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:37.569]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:37.569]         }
[11:01:37.569]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:37.569]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:37.569]             base::sink(type = "output", split = FALSE)
[11:01:37.569]             base::close(...future.stdout)
[11:01:37.569]         }, add = TRUE)
[11:01:37.569]     }
[11:01:37.569]     ...future.frame <- base::sys.nframe()
[11:01:37.569]     ...future.conditions <- base::list()
[11:01:37.569]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:37.569]     if (FALSE) {
[11:01:37.569]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:37.569]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:37.569]     }
[11:01:37.569]     ...future.result <- base::tryCatch({
[11:01:37.569]         base::withCallingHandlers({
[11:01:37.569]             ...future.value <- base::withVisible(base::local({
[11:01:37.569]                 ...future.makeSendCondition <- base::local({
[11:01:37.569]                   sendCondition <- NULL
[11:01:37.569]                   function(frame = 1L) {
[11:01:37.569]                     if (is.function(sendCondition)) 
[11:01:37.569]                       return(sendCondition)
[11:01:37.569]                     ns <- getNamespace("parallel")
[11:01:37.569]                     if (exists("sendData", mode = "function", 
[11:01:37.569]                       envir = ns)) {
[11:01:37.569]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:37.569]                         envir = ns)
[11:01:37.569]                       envir <- sys.frame(frame)
[11:01:37.569]                       master <- NULL
[11:01:37.569]                       while (!identical(envir, .GlobalEnv) && 
[11:01:37.569]                         !identical(envir, emptyenv())) {
[11:01:37.569]                         if (exists("master", mode = "list", envir = envir, 
[11:01:37.569]                           inherits = FALSE)) {
[11:01:37.569]                           master <- get("master", mode = "list", 
[11:01:37.569]                             envir = envir, inherits = FALSE)
[11:01:37.569]                           if (inherits(master, c("SOCKnode", 
[11:01:37.569]                             "SOCK0node"))) {
[11:01:37.569]                             sendCondition <<- function(cond) {
[11:01:37.569]                               data <- list(type = "VALUE", value = cond, 
[11:01:37.569]                                 success = TRUE)
[11:01:37.569]                               parallel_sendData(master, data)
[11:01:37.569]                             }
[11:01:37.569]                             return(sendCondition)
[11:01:37.569]                           }
[11:01:37.569]                         }
[11:01:37.569]                         frame <- frame + 1L
[11:01:37.569]                         envir <- sys.frame(frame)
[11:01:37.569]                       }
[11:01:37.569]                     }
[11:01:37.569]                     sendCondition <<- function(cond) NULL
[11:01:37.569]                   }
[11:01:37.569]                 })
[11:01:37.569]                 withCallingHandlers({
[11:01:37.569]                   {
[11:01:37.569]                     lm(dist ~ poly(speed, 2), data = cars)
[11:01:37.569]                   }
[11:01:37.569]                 }, immediateCondition = function(cond) {
[11:01:37.569]                   sendCondition <- ...future.makeSendCondition()
[11:01:37.569]                   sendCondition(cond)
[11:01:37.569]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.569]                   {
[11:01:37.569]                     inherits <- base::inherits
[11:01:37.569]                     invokeRestart <- base::invokeRestart
[11:01:37.569]                     is.null <- base::is.null
[11:01:37.569]                     muffled <- FALSE
[11:01:37.569]                     if (inherits(cond, "message")) {
[11:01:37.569]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:37.569]                       if (muffled) 
[11:01:37.569]                         invokeRestart("muffleMessage")
[11:01:37.569]                     }
[11:01:37.569]                     else if (inherits(cond, "warning")) {
[11:01:37.569]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:37.569]                       if (muffled) 
[11:01:37.569]                         invokeRestart("muffleWarning")
[11:01:37.569]                     }
[11:01:37.569]                     else if (inherits(cond, "condition")) {
[11:01:37.569]                       if (!is.null(pattern)) {
[11:01:37.569]                         computeRestarts <- base::computeRestarts
[11:01:37.569]                         grepl <- base::grepl
[11:01:37.569]                         restarts <- computeRestarts(cond)
[11:01:37.569]                         for (restart in restarts) {
[11:01:37.569]                           name <- restart$name
[11:01:37.569]                           if (is.null(name)) 
[11:01:37.569]                             next
[11:01:37.569]                           if (!grepl(pattern, name)) 
[11:01:37.569]                             next
[11:01:37.569]                           invokeRestart(restart)
[11:01:37.569]                           muffled <- TRUE
[11:01:37.569]                           break
[11:01:37.569]                         }
[11:01:37.569]                       }
[11:01:37.569]                     }
[11:01:37.569]                     invisible(muffled)
[11:01:37.569]                   }
[11:01:37.569]                   muffleCondition(cond)
[11:01:37.569]                 })
[11:01:37.569]             }))
[11:01:37.569]             future::FutureResult(value = ...future.value$value, 
[11:01:37.569]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:37.569]                   ...future.rng), globalenv = if (FALSE) 
[11:01:37.569]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:37.569]                     ...future.globalenv.names))
[11:01:37.569]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:37.569]         }, condition = base::local({
[11:01:37.569]             c <- base::c
[11:01:37.569]             inherits <- base::inherits
[11:01:37.569]             invokeRestart <- base::invokeRestart
[11:01:37.569]             length <- base::length
[11:01:37.569]             list <- base::list
[11:01:37.569]             seq.int <- base::seq.int
[11:01:37.569]             signalCondition <- base::signalCondition
[11:01:37.569]             sys.calls <- base::sys.calls
[11:01:37.569]             `[[` <- base::`[[`
[11:01:37.569]             `+` <- base::`+`
[11:01:37.569]             `<<-` <- base::`<<-`
[11:01:37.569]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:37.569]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:37.569]                   3L)]
[11:01:37.569]             }
[11:01:37.569]             function(cond) {
[11:01:37.569]                 is_error <- inherits(cond, "error")
[11:01:37.569]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:37.569]                   NULL)
[11:01:37.569]                 if (is_error) {
[11:01:37.569]                   sessionInformation <- function() {
[11:01:37.569]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:37.569]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:37.569]                       search = base::search(), system = base::Sys.info())
[11:01:37.569]                   }
[11:01:37.569]                   ...future.conditions[[length(...future.conditions) + 
[11:01:37.569]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:37.569]                     cond$call), session = sessionInformation(), 
[11:01:37.569]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:37.569]                   signalCondition(cond)
[11:01:37.569]                 }
[11:01:37.569]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:37.569]                 "immediateCondition"))) {
[11:01:37.569]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:37.569]                   ...future.conditions[[length(...future.conditions) + 
[11:01:37.569]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:37.569]                   if (TRUE && !signal) {
[11:01:37.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.569]                     {
[11:01:37.569]                       inherits <- base::inherits
[11:01:37.569]                       invokeRestart <- base::invokeRestart
[11:01:37.569]                       is.null <- base::is.null
[11:01:37.569]                       muffled <- FALSE
[11:01:37.569]                       if (inherits(cond, "message")) {
[11:01:37.569]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:37.569]                         if (muffled) 
[11:01:37.569]                           invokeRestart("muffleMessage")
[11:01:37.569]                       }
[11:01:37.569]                       else if (inherits(cond, "warning")) {
[11:01:37.569]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:37.569]                         if (muffled) 
[11:01:37.569]                           invokeRestart("muffleWarning")
[11:01:37.569]                       }
[11:01:37.569]                       else if (inherits(cond, "condition")) {
[11:01:37.569]                         if (!is.null(pattern)) {
[11:01:37.569]                           computeRestarts <- base::computeRestarts
[11:01:37.569]                           grepl <- base::grepl
[11:01:37.569]                           restarts <- computeRestarts(cond)
[11:01:37.569]                           for (restart in restarts) {
[11:01:37.569]                             name <- restart$name
[11:01:37.569]                             if (is.null(name)) 
[11:01:37.569]                               next
[11:01:37.569]                             if (!grepl(pattern, name)) 
[11:01:37.569]                               next
[11:01:37.569]                             invokeRestart(restart)
[11:01:37.569]                             muffled <- TRUE
[11:01:37.569]                             break
[11:01:37.569]                           }
[11:01:37.569]                         }
[11:01:37.569]                       }
[11:01:37.569]                       invisible(muffled)
[11:01:37.569]                     }
[11:01:37.569]                     muffleCondition(cond, pattern = "^muffle")
[11:01:37.569]                   }
[11:01:37.569]                 }
[11:01:37.569]                 else {
[11:01:37.569]                   if (TRUE) {
[11:01:37.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.569]                     {
[11:01:37.569]                       inherits <- base::inherits
[11:01:37.569]                       invokeRestart <- base::invokeRestart
[11:01:37.569]                       is.null <- base::is.null
[11:01:37.569]                       muffled <- FALSE
[11:01:37.569]                       if (inherits(cond, "message")) {
[11:01:37.569]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:37.569]                         if (muffled) 
[11:01:37.569]                           invokeRestart("muffleMessage")
[11:01:37.569]                       }
[11:01:37.569]                       else if (inherits(cond, "warning")) {
[11:01:37.569]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:37.569]                         if (muffled) 
[11:01:37.569]                           invokeRestart("muffleWarning")
[11:01:37.569]                       }
[11:01:37.569]                       else if (inherits(cond, "condition")) {
[11:01:37.569]                         if (!is.null(pattern)) {
[11:01:37.569]                           computeRestarts <- base::computeRestarts
[11:01:37.569]                           grepl <- base::grepl
[11:01:37.569]                           restarts <- computeRestarts(cond)
[11:01:37.569]                           for (restart in restarts) {
[11:01:37.569]                             name <- restart$name
[11:01:37.569]                             if (is.null(name)) 
[11:01:37.569]                               next
[11:01:37.569]                             if (!grepl(pattern, name)) 
[11:01:37.569]                               next
[11:01:37.569]                             invokeRestart(restart)
[11:01:37.569]                             muffled <- TRUE
[11:01:37.569]                             break
[11:01:37.569]                           }
[11:01:37.569]                         }
[11:01:37.569]                       }
[11:01:37.569]                       invisible(muffled)
[11:01:37.569]                     }
[11:01:37.569]                     muffleCondition(cond, pattern = "^muffle")
[11:01:37.569]                   }
[11:01:37.569]                 }
[11:01:37.569]             }
[11:01:37.569]         }))
[11:01:37.569]     }, error = function(ex) {
[11:01:37.569]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:37.569]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:37.569]                 ...future.rng), started = ...future.startTime, 
[11:01:37.569]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:37.569]             version = "1.8"), class = "FutureResult")
[11:01:37.569]     }, finally = {
[11:01:37.569]         if (!identical(...future.workdir, getwd())) 
[11:01:37.569]             setwd(...future.workdir)
[11:01:37.569]         {
[11:01:37.569]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:37.569]                 ...future.oldOptions$nwarnings <- NULL
[11:01:37.569]             }
[11:01:37.569]             base::options(...future.oldOptions)
[11:01:37.569]             if (.Platform$OS.type == "windows") {
[11:01:37.569]                 old_names <- names(...future.oldEnvVars)
[11:01:37.569]                 envs <- base::Sys.getenv()
[11:01:37.569]                 names <- names(envs)
[11:01:37.569]                 common <- intersect(names, old_names)
[11:01:37.569]                 added <- setdiff(names, old_names)
[11:01:37.569]                 removed <- setdiff(old_names, names)
[11:01:37.569]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:37.569]                   envs[common]]
[11:01:37.569]                 NAMES <- toupper(changed)
[11:01:37.569]                 args <- list()
[11:01:37.569]                 for (kk in seq_along(NAMES)) {
[11:01:37.569]                   name <- changed[[kk]]
[11:01:37.569]                   NAME <- NAMES[[kk]]
[11:01:37.569]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.569]                     next
[11:01:37.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:37.569]                 }
[11:01:37.569]                 NAMES <- toupper(added)
[11:01:37.569]                 for (kk in seq_along(NAMES)) {
[11:01:37.569]                   name <- added[[kk]]
[11:01:37.569]                   NAME <- NAMES[[kk]]
[11:01:37.569]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.569]                     next
[11:01:37.569]                   args[[name]] <- ""
[11:01:37.569]                 }
[11:01:37.569]                 NAMES <- toupper(removed)
[11:01:37.569]                 for (kk in seq_along(NAMES)) {
[11:01:37.569]                   name <- removed[[kk]]
[11:01:37.569]                   NAME <- NAMES[[kk]]
[11:01:37.569]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.569]                     next
[11:01:37.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:37.569]                 }
[11:01:37.569]                 if (length(args) > 0) 
[11:01:37.569]                   base::do.call(base::Sys.setenv, args = args)
[11:01:37.569]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:37.569]             }
[11:01:37.569]             else {
[11:01:37.569]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:37.569]             }
[11:01:37.569]             {
[11:01:37.569]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:37.569]                   0L) {
[11:01:37.569]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:37.569]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:37.569]                   base::options(opts)
[11:01:37.569]                 }
[11:01:37.569]                 {
[11:01:37.569]                   {
[11:01:37.569]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:37.569]                     NULL
[11:01:37.569]                   }
[11:01:37.569]                   options(future.plan = NULL)
[11:01:37.569]                   if (is.na(NA_character_)) 
[11:01:37.569]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:37.569]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:37.569]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:37.569]                     .init = FALSE)
[11:01:37.569]                 }
[11:01:37.569]             }
[11:01:37.569]         }
[11:01:37.569]     })
[11:01:37.569]     if (TRUE) {
[11:01:37.569]         base::sink(type = "output", split = FALSE)
[11:01:37.569]         if (TRUE) {
[11:01:37.569]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:37.569]         }
[11:01:37.569]         else {
[11:01:37.569]             ...future.result["stdout"] <- base::list(NULL)
[11:01:37.569]         }
[11:01:37.569]         base::close(...future.stdout)
[11:01:37.569]         ...future.stdout <- NULL
[11:01:37.569]     }
[11:01:37.569]     ...future.result$conditions <- ...future.conditions
[11:01:37.569]     ...future.result$finished <- base::Sys.time()
[11:01:37.569]     ...future.result
[11:01:37.569] }
[11:01:37.571] MultisessionFuture started
[11:01:37.572] - Launch lazy future ... done
[11:01:37.572] run() for ‘MultisessionFuture’ ... done
[11:01:37.572] result() for ClusterFuture ...
[11:01:37.572] receiveMessageFromWorker() for ClusterFuture ...
[11:01:37.572] - Validating connection of MultisessionFuture
[11:01:37.615] - received message: FutureResult
[11:01:37.615] - Received FutureResult
[11:01:37.615] - Erased future from FutureRegistry
[11:01:37.615] result() for ClusterFuture ...
[11:01:37.615] - result already collected: FutureResult
[11:01:37.615] result() for ClusterFuture ... done
[11:01:37.615] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:37.615] result() for ClusterFuture ... done
[11:01:37.615] result() for ClusterFuture ...
[11:01:37.616] - result already collected: FutureResult
[11:01:37.616] result() for ClusterFuture ... done

Call:
lm(formula = dist ~ poly(speed, 2), data = cars)

Coefficients:
    (Intercept)  poly(speed, 2)1  poly(speed, 2)2  
          42.98           145.55            23.00  

- Globals - map(x, ~ expr) ...
[11:01:37.617] getGlobalsAndPackages() ...
[11:01:37.617] Searching for globals...
[11:01:37.621] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[11:01:37.621] Searching for globals ... DONE
[11:01:37.622] Resolving globals: FALSE
[11:01:37.622] The total size of the 3 globals is 1.22 KiB (1254 bytes)
[11:01:37.623] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (633 bytes of class ‘function’), ‘inner_function’ (371 bytes of class ‘function’) and ‘outer_function’ (250 bytes of class ‘function’)
[11:01:37.623] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[11:01:37.623] 
[11:01:37.623] getGlobalsAndPackages() ... DONE
[11:01:37.623] run() for ‘Future’ ...
[11:01:37.623] - state: ‘created’
[11:01:37.623] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:37.637] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:37.637] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:37.637]   - Field: ‘node’
[11:01:37.637]   - Field: ‘label’
[11:01:37.637]   - Field: ‘local’
[11:01:37.637]   - Field: ‘owner’
[11:01:37.637]   - Field: ‘envir’
[11:01:37.637]   - Field: ‘workers’
[11:01:37.638]   - Field: ‘packages’
[11:01:37.638]   - Field: ‘gc’
[11:01:37.638]   - Field: ‘conditions’
[11:01:37.638]   - Field: ‘persistent’
[11:01:37.638]   - Field: ‘expr’
[11:01:37.638]   - Field: ‘uuid’
[11:01:37.638]   - Field: ‘seed’
[11:01:37.638]   - Field: ‘version’
[11:01:37.638]   - Field: ‘result’
[11:01:37.638]   - Field: ‘asynchronous’
[11:01:37.638]   - Field: ‘calls’
[11:01:37.638]   - Field: ‘globals’
[11:01:37.639]   - Field: ‘stdout’
[11:01:37.639]   - Field: ‘earlySignal’
[11:01:37.639]   - Field: ‘lazy’
[11:01:37.639]   - Field: ‘state’
[11:01:37.639] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:37.639] - Launch lazy future ...
[11:01:37.639] Packages needed by the future expression (n = 0): <none>
[11:01:37.639] Packages needed by future strategies (n = 0): <none>
[11:01:37.640] {
[11:01:37.640]     {
[11:01:37.640]         {
[11:01:37.640]             ...future.startTime <- base::Sys.time()
[11:01:37.640]             {
[11:01:37.640]                 {
[11:01:37.640]                   {
[11:01:37.640]                     {
[11:01:37.640]                       base::local({
[11:01:37.640]                         has_future <- base::requireNamespace("future", 
[11:01:37.640]                           quietly = TRUE)
[11:01:37.640]                         if (has_future) {
[11:01:37.640]                           ns <- base::getNamespace("future")
[11:01:37.640]                           version <- ns[[".package"]][["version"]]
[11:01:37.640]                           if (is.null(version)) 
[11:01:37.640]                             version <- utils::packageVersion("future")
[11:01:37.640]                         }
[11:01:37.640]                         else {
[11:01:37.640]                           version <- NULL
[11:01:37.640]                         }
[11:01:37.640]                         if (!has_future || version < "1.8.0") {
[11:01:37.640]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:37.640]                             "", base::R.version$version.string), 
[11:01:37.640]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:37.640]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:37.640]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:37.640]                               "release", "version")], collapse = " "), 
[11:01:37.640]                             hostname = base::Sys.info()[["nodename"]])
[11:01:37.640]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:37.640]                             info)
[11:01:37.640]                           info <- base::paste(info, collapse = "; ")
[11:01:37.640]                           if (!has_future) {
[11:01:37.640]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:37.640]                               info)
[11:01:37.640]                           }
[11:01:37.640]                           else {
[11:01:37.640]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:37.640]                               info, version)
[11:01:37.640]                           }
[11:01:37.640]                           base::stop(msg)
[11:01:37.640]                         }
[11:01:37.640]                       })
[11:01:37.640]                     }
[11:01:37.640]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:37.640]                     base::options(mc.cores = 1L)
[11:01:37.640]                   }
[11:01:37.640]                   ...future.strategy.old <- future::plan("list")
[11:01:37.640]                   options(future.plan = NULL)
[11:01:37.640]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:37.640]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:37.640]                 }
[11:01:37.640]                 ...future.workdir <- getwd()
[11:01:37.640]             }
[11:01:37.640]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:37.640]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:37.640]         }
[11:01:37.640]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:37.640]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:37.640]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:37.640]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:37.640]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:37.640]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:37.640]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:37.640]             base::names(...future.oldOptions))
[11:01:37.640]     }
[11:01:37.640]     if (FALSE) {
[11:01:37.640]     }
[11:01:37.640]     else {
[11:01:37.640]         if (TRUE) {
[11:01:37.640]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:37.640]                 open = "w")
[11:01:37.640]         }
[11:01:37.640]         else {
[11:01:37.640]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:37.640]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:37.640]         }
[11:01:37.640]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:37.640]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:37.640]             base::sink(type = "output", split = FALSE)
[11:01:37.640]             base::close(...future.stdout)
[11:01:37.640]         }, add = TRUE)
[11:01:37.640]     }
[11:01:37.640]     ...future.frame <- base::sys.nframe()
[11:01:37.640]     ...future.conditions <- base::list()
[11:01:37.640]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:37.640]     if (FALSE) {
[11:01:37.640]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:37.640]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:37.640]     }
[11:01:37.640]     ...future.result <- base::tryCatch({
[11:01:37.640]         base::withCallingHandlers({
[11:01:37.640]             ...future.value <- base::withVisible(base::local({
[11:01:37.640]                 ...future.makeSendCondition <- base::local({
[11:01:37.640]                   sendCondition <- NULL
[11:01:37.640]                   function(frame = 1L) {
[11:01:37.640]                     if (is.function(sendCondition)) 
[11:01:37.640]                       return(sendCondition)
[11:01:37.640]                     ns <- getNamespace("parallel")
[11:01:37.640]                     if (exists("sendData", mode = "function", 
[11:01:37.640]                       envir = ns)) {
[11:01:37.640]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:37.640]                         envir = ns)
[11:01:37.640]                       envir <- sys.frame(frame)
[11:01:37.640]                       master <- NULL
[11:01:37.640]                       while (!identical(envir, .GlobalEnv) && 
[11:01:37.640]                         !identical(envir, emptyenv())) {
[11:01:37.640]                         if (exists("master", mode = "list", envir = envir, 
[11:01:37.640]                           inherits = FALSE)) {
[11:01:37.640]                           master <- get("master", mode = "list", 
[11:01:37.640]                             envir = envir, inherits = FALSE)
[11:01:37.640]                           if (inherits(master, c("SOCKnode", 
[11:01:37.640]                             "SOCK0node"))) {
[11:01:37.640]                             sendCondition <<- function(cond) {
[11:01:37.640]                               data <- list(type = "VALUE", value = cond, 
[11:01:37.640]                                 success = TRUE)
[11:01:37.640]                               parallel_sendData(master, data)
[11:01:37.640]                             }
[11:01:37.640]                             return(sendCondition)
[11:01:37.640]                           }
[11:01:37.640]                         }
[11:01:37.640]                         frame <- frame + 1L
[11:01:37.640]                         envir <- sys.frame(frame)
[11:01:37.640]                       }
[11:01:37.640]                     }
[11:01:37.640]                     sendCondition <<- function(cond) NULL
[11:01:37.640]                   }
[11:01:37.640]                 })
[11:01:37.640]                 withCallingHandlers({
[11:01:37.640]                   {
[11:01:37.640]                     outer_function(1L)
[11:01:37.640]                   }
[11:01:37.640]                 }, immediateCondition = function(cond) {
[11:01:37.640]                   sendCondition <- ...future.makeSendCondition()
[11:01:37.640]                   sendCondition(cond)
[11:01:37.640]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.640]                   {
[11:01:37.640]                     inherits <- base::inherits
[11:01:37.640]                     invokeRestart <- base::invokeRestart
[11:01:37.640]                     is.null <- base::is.null
[11:01:37.640]                     muffled <- FALSE
[11:01:37.640]                     if (inherits(cond, "message")) {
[11:01:37.640]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:37.640]                       if (muffled) 
[11:01:37.640]                         invokeRestart("muffleMessage")
[11:01:37.640]                     }
[11:01:37.640]                     else if (inherits(cond, "warning")) {
[11:01:37.640]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:37.640]                       if (muffled) 
[11:01:37.640]                         invokeRestart("muffleWarning")
[11:01:37.640]                     }
[11:01:37.640]                     else if (inherits(cond, "condition")) {
[11:01:37.640]                       if (!is.null(pattern)) {
[11:01:37.640]                         computeRestarts <- base::computeRestarts
[11:01:37.640]                         grepl <- base::grepl
[11:01:37.640]                         restarts <- computeRestarts(cond)
[11:01:37.640]                         for (restart in restarts) {
[11:01:37.640]                           name <- restart$name
[11:01:37.640]                           if (is.null(name)) 
[11:01:37.640]                             next
[11:01:37.640]                           if (!grepl(pattern, name)) 
[11:01:37.640]                             next
[11:01:37.640]                           invokeRestart(restart)
[11:01:37.640]                           muffled <- TRUE
[11:01:37.640]                           break
[11:01:37.640]                         }
[11:01:37.640]                       }
[11:01:37.640]                     }
[11:01:37.640]                     invisible(muffled)
[11:01:37.640]                   }
[11:01:37.640]                   muffleCondition(cond)
[11:01:37.640]                 })
[11:01:37.640]             }))
[11:01:37.640]             future::FutureResult(value = ...future.value$value, 
[11:01:37.640]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:37.640]                   ...future.rng), globalenv = if (FALSE) 
[11:01:37.640]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:37.640]                     ...future.globalenv.names))
[11:01:37.640]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:37.640]         }, condition = base::local({
[11:01:37.640]             c <- base::c
[11:01:37.640]             inherits <- base::inherits
[11:01:37.640]             invokeRestart <- base::invokeRestart
[11:01:37.640]             length <- base::length
[11:01:37.640]             list <- base::list
[11:01:37.640]             seq.int <- base::seq.int
[11:01:37.640]             signalCondition <- base::signalCondition
[11:01:37.640]             sys.calls <- base::sys.calls
[11:01:37.640]             `[[` <- base::`[[`
[11:01:37.640]             `+` <- base::`+`
[11:01:37.640]             `<<-` <- base::`<<-`
[11:01:37.640]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:37.640]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:37.640]                   3L)]
[11:01:37.640]             }
[11:01:37.640]             function(cond) {
[11:01:37.640]                 is_error <- inherits(cond, "error")
[11:01:37.640]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:37.640]                   NULL)
[11:01:37.640]                 if (is_error) {
[11:01:37.640]                   sessionInformation <- function() {
[11:01:37.640]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:37.640]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:37.640]                       search = base::search(), system = base::Sys.info())
[11:01:37.640]                   }
[11:01:37.640]                   ...future.conditions[[length(...future.conditions) + 
[11:01:37.640]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:37.640]                     cond$call), session = sessionInformation(), 
[11:01:37.640]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:37.640]                   signalCondition(cond)
[11:01:37.640]                 }
[11:01:37.640]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:37.640]                 "immediateCondition"))) {
[11:01:37.640]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:37.640]                   ...future.conditions[[length(...future.conditions) + 
[11:01:37.640]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:37.640]                   if (TRUE && !signal) {
[11:01:37.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.640]                     {
[11:01:37.640]                       inherits <- base::inherits
[11:01:37.640]                       invokeRestart <- base::invokeRestart
[11:01:37.640]                       is.null <- base::is.null
[11:01:37.640]                       muffled <- FALSE
[11:01:37.640]                       if (inherits(cond, "message")) {
[11:01:37.640]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:37.640]                         if (muffled) 
[11:01:37.640]                           invokeRestart("muffleMessage")
[11:01:37.640]                       }
[11:01:37.640]                       else if (inherits(cond, "warning")) {
[11:01:37.640]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:37.640]                         if (muffled) 
[11:01:37.640]                           invokeRestart("muffleWarning")
[11:01:37.640]                       }
[11:01:37.640]                       else if (inherits(cond, "condition")) {
[11:01:37.640]                         if (!is.null(pattern)) {
[11:01:37.640]                           computeRestarts <- base::computeRestarts
[11:01:37.640]                           grepl <- base::grepl
[11:01:37.640]                           restarts <- computeRestarts(cond)
[11:01:37.640]                           for (restart in restarts) {
[11:01:37.640]                             name <- restart$name
[11:01:37.640]                             if (is.null(name)) 
[11:01:37.640]                               next
[11:01:37.640]                             if (!grepl(pattern, name)) 
[11:01:37.640]                               next
[11:01:37.640]                             invokeRestart(restart)
[11:01:37.640]                             muffled <- TRUE
[11:01:37.640]                             break
[11:01:37.640]                           }
[11:01:37.640]                         }
[11:01:37.640]                       }
[11:01:37.640]                       invisible(muffled)
[11:01:37.640]                     }
[11:01:37.640]                     muffleCondition(cond, pattern = "^muffle")
[11:01:37.640]                   }
[11:01:37.640]                 }
[11:01:37.640]                 else {
[11:01:37.640]                   if (TRUE) {
[11:01:37.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.640]                     {
[11:01:37.640]                       inherits <- base::inherits
[11:01:37.640]                       invokeRestart <- base::invokeRestart
[11:01:37.640]                       is.null <- base::is.null
[11:01:37.640]                       muffled <- FALSE
[11:01:37.640]                       if (inherits(cond, "message")) {
[11:01:37.640]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:37.640]                         if (muffled) 
[11:01:37.640]                           invokeRestart("muffleMessage")
[11:01:37.640]                       }
[11:01:37.640]                       else if (inherits(cond, "warning")) {
[11:01:37.640]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:37.640]                         if (muffled) 
[11:01:37.640]                           invokeRestart("muffleWarning")
[11:01:37.640]                       }
[11:01:37.640]                       else if (inherits(cond, "condition")) {
[11:01:37.640]                         if (!is.null(pattern)) {
[11:01:37.640]                           computeRestarts <- base::computeRestarts
[11:01:37.640]                           grepl <- base::grepl
[11:01:37.640]                           restarts <- computeRestarts(cond)
[11:01:37.640]                           for (restart in restarts) {
[11:01:37.640]                             name <- restart$name
[11:01:37.640]                             if (is.null(name)) 
[11:01:37.640]                               next
[11:01:37.640]                             if (!grepl(pattern, name)) 
[11:01:37.640]                               next
[11:01:37.640]                             invokeRestart(restart)
[11:01:37.640]                             muffled <- TRUE
[11:01:37.640]                             break
[11:01:37.640]                           }
[11:01:37.640]                         }
[11:01:37.640]                       }
[11:01:37.640]                       invisible(muffled)
[11:01:37.640]                     }
[11:01:37.640]                     muffleCondition(cond, pattern = "^muffle")
[11:01:37.640]                   }
[11:01:37.640]                 }
[11:01:37.640]             }
[11:01:37.640]         }))
[11:01:37.640]     }, error = function(ex) {
[11:01:37.640]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:37.640]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:37.640]                 ...future.rng), started = ...future.startTime, 
[11:01:37.640]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:37.640]             version = "1.8"), class = "FutureResult")
[11:01:37.640]     }, finally = {
[11:01:37.640]         if (!identical(...future.workdir, getwd())) 
[11:01:37.640]             setwd(...future.workdir)
[11:01:37.640]         {
[11:01:37.640]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:37.640]                 ...future.oldOptions$nwarnings <- NULL
[11:01:37.640]             }
[11:01:37.640]             base::options(...future.oldOptions)
[11:01:37.640]             if (.Platform$OS.type == "windows") {
[11:01:37.640]                 old_names <- names(...future.oldEnvVars)
[11:01:37.640]                 envs <- base::Sys.getenv()
[11:01:37.640]                 names <- names(envs)
[11:01:37.640]                 common <- intersect(names, old_names)
[11:01:37.640]                 added <- setdiff(names, old_names)
[11:01:37.640]                 removed <- setdiff(old_names, names)
[11:01:37.640]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:37.640]                   envs[common]]
[11:01:37.640]                 NAMES <- toupper(changed)
[11:01:37.640]                 args <- list()
[11:01:37.640]                 for (kk in seq_along(NAMES)) {
[11:01:37.640]                   name <- changed[[kk]]
[11:01:37.640]                   NAME <- NAMES[[kk]]
[11:01:37.640]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.640]                     next
[11:01:37.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:37.640]                 }
[11:01:37.640]                 NAMES <- toupper(added)
[11:01:37.640]                 for (kk in seq_along(NAMES)) {
[11:01:37.640]                   name <- added[[kk]]
[11:01:37.640]                   NAME <- NAMES[[kk]]
[11:01:37.640]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.640]                     next
[11:01:37.640]                   args[[name]] <- ""
[11:01:37.640]                 }
[11:01:37.640]                 NAMES <- toupper(removed)
[11:01:37.640]                 for (kk in seq_along(NAMES)) {
[11:01:37.640]                   name <- removed[[kk]]
[11:01:37.640]                   NAME <- NAMES[[kk]]
[11:01:37.640]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.640]                     next
[11:01:37.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:37.640]                 }
[11:01:37.640]                 if (length(args) > 0) 
[11:01:37.640]                   base::do.call(base::Sys.setenv, args = args)
[11:01:37.640]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:37.640]             }
[11:01:37.640]             else {
[11:01:37.640]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:37.640]             }
[11:01:37.640]             {
[11:01:37.640]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:37.640]                   0L) {
[11:01:37.640]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:37.640]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:37.640]                   base::options(opts)
[11:01:37.640]                 }
[11:01:37.640]                 {
[11:01:37.640]                   {
[11:01:37.640]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:37.640]                     NULL
[11:01:37.640]                   }
[11:01:37.640]                   options(future.plan = NULL)
[11:01:37.640]                   if (is.na(NA_character_)) 
[11:01:37.640]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:37.640]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:37.640]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:37.640]                     .init = FALSE)
[11:01:37.640]                 }
[11:01:37.640]             }
[11:01:37.640]         }
[11:01:37.640]     })
[11:01:37.640]     if (TRUE) {
[11:01:37.640]         base::sink(type = "output", split = FALSE)
[11:01:37.640]         if (TRUE) {
[11:01:37.640]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:37.640]         }
[11:01:37.640]         else {
[11:01:37.640]             ...future.result["stdout"] <- base::list(NULL)
[11:01:37.640]         }
[11:01:37.640]         base::close(...future.stdout)
[11:01:37.640]         ...future.stdout <- NULL
[11:01:37.640]     }
[11:01:37.640]     ...future.result$conditions <- ...future.conditions
[11:01:37.640]     ...future.result$finished <- base::Sys.time()
[11:01:37.640]     ...future.result
[11:01:37.640] }
[11:01:37.642] Exporting 3 global objects (1.53 KiB) to cluster node #1 ...
[11:01:37.642] Exporting ‘outer_function’ (250 bytes) to cluster node #1 ...
[11:01:37.643] Exporting ‘outer_function’ (250 bytes) to cluster node #1 ... DONE
[11:01:37.643] Exporting ‘map’ (633 bytes) to cluster node #1 ...
[11:01:37.643] Exporting ‘map’ (633 bytes) to cluster node #1 ... DONE
[11:01:37.644] Exporting ‘inner_function’ (371 bytes) to cluster node #1 ...
[11:01:37.644] Exporting ‘inner_function’ (371 bytes) to cluster node #1 ... DONE
[11:01:37.644] Exporting 3 global objects (1.53 KiB) to cluster node #1 ... DONE
[11:01:37.644] MultisessionFuture started
[11:01:37.644] - Launch lazy future ... done
[11:01:37.645] run() for ‘MultisessionFuture’ ... done
[11:01:37.645] result() for ClusterFuture ...
[11:01:37.645] receiveMessageFromWorker() for ClusterFuture ...
[11:01:37.645] - Validating connection of MultisessionFuture
[11:01:37.690] - received message: FutureResult
[11:01:37.691] - Received FutureResult
[11:01:37.691] - Erased future from FutureRegistry
[11:01:37.691] result() for ClusterFuture ...
[11:01:37.691] - result already collected: FutureResult
[11:01:37.691] result() for ClusterFuture ... done
[11:01:37.691] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:37.691] result() for ClusterFuture ... done
[11:01:37.691] result() for ClusterFuture ...
[11:01:37.691] - result already collected: FutureResult
[11:01:37.691] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
[11:01:37.693] getGlobalsAndPackages() ...
[11:01:37.693] Searching for globals...
[11:01:37.697] - globals found: [16] ‘{’, ‘outer_function’, ‘map’, ‘:’, ‘~’, ‘inner_function’, ‘.x’, ‘if’, ‘inherits’, ‘<-’, ‘[[’, ‘-’, ‘eval’, ‘bquote’, ‘lapply’, ‘+’
[11:01:37.697] Searching for globals ... DONE
[11:01:37.697] Resolving globals: FALSE
[11:01:37.698] The total size of the 3 globals is 1.22 KiB (1254 bytes)
[11:01:37.698] The total size of the 3 globals exported for future expression (‘{; outer_function(1L); }’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘map’ (633 bytes of class ‘function’), ‘inner_function’ (371 bytes of class ‘function’) and ‘outer_function’ (250 bytes of class ‘function’)
[11:01:37.698] - globals: [3] ‘outer_function’, ‘map’, ‘inner_function’
[11:01:37.698] 
[11:01:37.698] getGlobalsAndPackages() ... DONE
[11:01:37.699] run() for ‘Future’ ...
[11:01:37.699] - state: ‘created’
[11:01:37.699] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:37.712] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:37.712] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:37.712]   - Field: ‘node’
[11:01:37.713]   - Field: ‘label’
[11:01:37.713]   - Field: ‘local’
[11:01:37.713]   - Field: ‘owner’
[11:01:37.713]   - Field: ‘envir’
[11:01:37.713]   - Field: ‘workers’
[11:01:37.713]   - Field: ‘packages’
[11:01:37.713]   - Field: ‘gc’
[11:01:37.713]   - Field: ‘conditions’
[11:01:37.713]   - Field: ‘persistent’
[11:01:37.713]   - Field: ‘expr’
[11:01:37.713]   - Field: ‘uuid’
[11:01:37.713]   - Field: ‘seed’
[11:01:37.714]   - Field: ‘version’
[11:01:37.714]   - Field: ‘result’
[11:01:37.714]   - Field: ‘asynchronous’
[11:01:37.714]   - Field: ‘calls’
[11:01:37.714]   - Field: ‘globals’
[11:01:37.714]   - Field: ‘stdout’
[11:01:37.714]   - Field: ‘earlySignal’
[11:01:37.714]   - Field: ‘lazy’
[11:01:37.714]   - Field: ‘state’
[11:01:37.714] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:37.714] - Launch lazy future ...
[11:01:37.715] Packages needed by the future expression (n = 0): <none>
[11:01:37.715] Packages needed by future strategies (n = 0): <none>
[11:01:37.715] {
[11:01:37.715]     {
[11:01:37.715]         {
[11:01:37.715]             ...future.startTime <- base::Sys.time()
[11:01:37.715]             {
[11:01:37.715]                 {
[11:01:37.715]                   {
[11:01:37.715]                     {
[11:01:37.715]                       base::local({
[11:01:37.715]                         has_future <- base::requireNamespace("future", 
[11:01:37.715]                           quietly = TRUE)
[11:01:37.715]                         if (has_future) {
[11:01:37.715]                           ns <- base::getNamespace("future")
[11:01:37.715]                           version <- ns[[".package"]][["version"]]
[11:01:37.715]                           if (is.null(version)) 
[11:01:37.715]                             version <- utils::packageVersion("future")
[11:01:37.715]                         }
[11:01:37.715]                         else {
[11:01:37.715]                           version <- NULL
[11:01:37.715]                         }
[11:01:37.715]                         if (!has_future || version < "1.8.0") {
[11:01:37.715]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:37.715]                             "", base::R.version$version.string), 
[11:01:37.715]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:37.715]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:37.715]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:37.715]                               "release", "version")], collapse = " "), 
[11:01:37.715]                             hostname = base::Sys.info()[["nodename"]])
[11:01:37.715]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:37.715]                             info)
[11:01:37.715]                           info <- base::paste(info, collapse = "; ")
[11:01:37.715]                           if (!has_future) {
[11:01:37.715]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:37.715]                               info)
[11:01:37.715]                           }
[11:01:37.715]                           else {
[11:01:37.715]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:37.715]                               info, version)
[11:01:37.715]                           }
[11:01:37.715]                           base::stop(msg)
[11:01:37.715]                         }
[11:01:37.715]                       })
[11:01:37.715]                     }
[11:01:37.715]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:37.715]                     base::options(mc.cores = 1L)
[11:01:37.715]                   }
[11:01:37.715]                   ...future.strategy.old <- future::plan("list")
[11:01:37.715]                   options(future.plan = NULL)
[11:01:37.715]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:37.715]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:37.715]                 }
[11:01:37.715]                 ...future.workdir <- getwd()
[11:01:37.715]             }
[11:01:37.715]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:37.715]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:37.715]         }
[11:01:37.715]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:37.715]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:37.715]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:37.715]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:37.715]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:37.715]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:37.715]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:37.715]             base::names(...future.oldOptions))
[11:01:37.715]     }
[11:01:37.715]     if (FALSE) {
[11:01:37.715]     }
[11:01:37.715]     else {
[11:01:37.715]         if (TRUE) {
[11:01:37.715]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:37.715]                 open = "w")
[11:01:37.715]         }
[11:01:37.715]         else {
[11:01:37.715]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:37.715]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:37.715]         }
[11:01:37.715]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:37.715]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:37.715]             base::sink(type = "output", split = FALSE)
[11:01:37.715]             base::close(...future.stdout)
[11:01:37.715]         }, add = TRUE)
[11:01:37.715]     }
[11:01:37.715]     ...future.frame <- base::sys.nframe()
[11:01:37.715]     ...future.conditions <- base::list()
[11:01:37.715]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:37.715]     if (FALSE) {
[11:01:37.715]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:37.715]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:37.715]     }
[11:01:37.715]     ...future.result <- base::tryCatch({
[11:01:37.715]         base::withCallingHandlers({
[11:01:37.715]             ...future.value <- base::withVisible(base::local({
[11:01:37.715]                 ...future.makeSendCondition <- base::local({
[11:01:37.715]                   sendCondition <- NULL
[11:01:37.715]                   function(frame = 1L) {
[11:01:37.715]                     if (is.function(sendCondition)) 
[11:01:37.715]                       return(sendCondition)
[11:01:37.715]                     ns <- getNamespace("parallel")
[11:01:37.715]                     if (exists("sendData", mode = "function", 
[11:01:37.715]                       envir = ns)) {
[11:01:37.715]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:37.715]                         envir = ns)
[11:01:37.715]                       envir <- sys.frame(frame)
[11:01:37.715]                       master <- NULL
[11:01:37.715]                       while (!identical(envir, .GlobalEnv) && 
[11:01:37.715]                         !identical(envir, emptyenv())) {
[11:01:37.715]                         if (exists("master", mode = "list", envir = envir, 
[11:01:37.715]                           inherits = FALSE)) {
[11:01:37.715]                           master <- get("master", mode = "list", 
[11:01:37.715]                             envir = envir, inherits = FALSE)
[11:01:37.715]                           if (inherits(master, c("SOCKnode", 
[11:01:37.715]                             "SOCK0node"))) {
[11:01:37.715]                             sendCondition <<- function(cond) {
[11:01:37.715]                               data <- list(type = "VALUE", value = cond, 
[11:01:37.715]                                 success = TRUE)
[11:01:37.715]                               parallel_sendData(master, data)
[11:01:37.715]                             }
[11:01:37.715]                             return(sendCondition)
[11:01:37.715]                           }
[11:01:37.715]                         }
[11:01:37.715]                         frame <- frame + 1L
[11:01:37.715]                         envir <- sys.frame(frame)
[11:01:37.715]                       }
[11:01:37.715]                     }
[11:01:37.715]                     sendCondition <<- function(cond) NULL
[11:01:37.715]                   }
[11:01:37.715]                 })
[11:01:37.715]                 withCallingHandlers({
[11:01:37.715]                   {
[11:01:37.715]                     outer_function(1L)
[11:01:37.715]                   }
[11:01:37.715]                 }, immediateCondition = function(cond) {
[11:01:37.715]                   sendCondition <- ...future.makeSendCondition()
[11:01:37.715]                   sendCondition(cond)
[11:01:37.715]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.715]                   {
[11:01:37.715]                     inherits <- base::inherits
[11:01:37.715]                     invokeRestart <- base::invokeRestart
[11:01:37.715]                     is.null <- base::is.null
[11:01:37.715]                     muffled <- FALSE
[11:01:37.715]                     if (inherits(cond, "message")) {
[11:01:37.715]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:37.715]                       if (muffled) 
[11:01:37.715]                         invokeRestart("muffleMessage")
[11:01:37.715]                     }
[11:01:37.715]                     else if (inherits(cond, "warning")) {
[11:01:37.715]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:37.715]                       if (muffled) 
[11:01:37.715]                         invokeRestart("muffleWarning")
[11:01:37.715]                     }
[11:01:37.715]                     else if (inherits(cond, "condition")) {
[11:01:37.715]                       if (!is.null(pattern)) {
[11:01:37.715]                         computeRestarts <- base::computeRestarts
[11:01:37.715]                         grepl <- base::grepl
[11:01:37.715]                         restarts <- computeRestarts(cond)
[11:01:37.715]                         for (restart in restarts) {
[11:01:37.715]                           name <- restart$name
[11:01:37.715]                           if (is.null(name)) 
[11:01:37.715]                             next
[11:01:37.715]                           if (!grepl(pattern, name)) 
[11:01:37.715]                             next
[11:01:37.715]                           invokeRestart(restart)
[11:01:37.715]                           muffled <- TRUE
[11:01:37.715]                           break
[11:01:37.715]                         }
[11:01:37.715]                       }
[11:01:37.715]                     }
[11:01:37.715]                     invisible(muffled)
[11:01:37.715]                   }
[11:01:37.715]                   muffleCondition(cond)
[11:01:37.715]                 })
[11:01:37.715]             }))
[11:01:37.715]             future::FutureResult(value = ...future.value$value, 
[11:01:37.715]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:37.715]                   ...future.rng), globalenv = if (FALSE) 
[11:01:37.715]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:37.715]                     ...future.globalenv.names))
[11:01:37.715]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:37.715]         }, condition = base::local({
[11:01:37.715]             c <- base::c
[11:01:37.715]             inherits <- base::inherits
[11:01:37.715]             invokeRestart <- base::invokeRestart
[11:01:37.715]             length <- base::length
[11:01:37.715]             list <- base::list
[11:01:37.715]             seq.int <- base::seq.int
[11:01:37.715]             signalCondition <- base::signalCondition
[11:01:37.715]             sys.calls <- base::sys.calls
[11:01:37.715]             `[[` <- base::`[[`
[11:01:37.715]             `+` <- base::`+`
[11:01:37.715]             `<<-` <- base::`<<-`
[11:01:37.715]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:37.715]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:37.715]                   3L)]
[11:01:37.715]             }
[11:01:37.715]             function(cond) {
[11:01:37.715]                 is_error <- inherits(cond, "error")
[11:01:37.715]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:37.715]                   NULL)
[11:01:37.715]                 if (is_error) {
[11:01:37.715]                   sessionInformation <- function() {
[11:01:37.715]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:37.715]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:37.715]                       search = base::search(), system = base::Sys.info())
[11:01:37.715]                   }
[11:01:37.715]                   ...future.conditions[[length(...future.conditions) + 
[11:01:37.715]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:37.715]                     cond$call), session = sessionInformation(), 
[11:01:37.715]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:37.715]                   signalCondition(cond)
[11:01:37.715]                 }
[11:01:37.715]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:37.715]                 "immediateCondition"))) {
[11:01:37.715]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:37.715]                   ...future.conditions[[length(...future.conditions) + 
[11:01:37.715]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:37.715]                   if (TRUE && !signal) {
[11:01:37.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.715]                     {
[11:01:37.715]                       inherits <- base::inherits
[11:01:37.715]                       invokeRestart <- base::invokeRestart
[11:01:37.715]                       is.null <- base::is.null
[11:01:37.715]                       muffled <- FALSE
[11:01:37.715]                       if (inherits(cond, "message")) {
[11:01:37.715]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:37.715]                         if (muffled) 
[11:01:37.715]                           invokeRestart("muffleMessage")
[11:01:37.715]                       }
[11:01:37.715]                       else if (inherits(cond, "warning")) {
[11:01:37.715]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:37.715]                         if (muffled) 
[11:01:37.715]                           invokeRestart("muffleWarning")
[11:01:37.715]                       }
[11:01:37.715]                       else if (inherits(cond, "condition")) {
[11:01:37.715]                         if (!is.null(pattern)) {
[11:01:37.715]                           computeRestarts <- base::computeRestarts
[11:01:37.715]                           grepl <- base::grepl
[11:01:37.715]                           restarts <- computeRestarts(cond)
[11:01:37.715]                           for (restart in restarts) {
[11:01:37.715]                             name <- restart$name
[11:01:37.715]                             if (is.null(name)) 
[11:01:37.715]                               next
[11:01:37.715]                             if (!grepl(pattern, name)) 
[11:01:37.715]                               next
[11:01:37.715]                             invokeRestart(restart)
[11:01:37.715]                             muffled <- TRUE
[11:01:37.715]                             break
[11:01:37.715]                           }
[11:01:37.715]                         }
[11:01:37.715]                       }
[11:01:37.715]                       invisible(muffled)
[11:01:37.715]                     }
[11:01:37.715]                     muffleCondition(cond, pattern = "^muffle")
[11:01:37.715]                   }
[11:01:37.715]                 }
[11:01:37.715]                 else {
[11:01:37.715]                   if (TRUE) {
[11:01:37.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:37.715]                     {
[11:01:37.715]                       inherits <- base::inherits
[11:01:37.715]                       invokeRestart <- base::invokeRestart
[11:01:37.715]                       is.null <- base::is.null
[11:01:37.715]                       muffled <- FALSE
[11:01:37.715]                       if (inherits(cond, "message")) {
[11:01:37.715]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:37.715]                         if (muffled) 
[11:01:37.715]                           invokeRestart("muffleMessage")
[11:01:37.715]                       }
[11:01:37.715]                       else if (inherits(cond, "warning")) {
[11:01:37.715]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:37.715]                         if (muffled) 
[11:01:37.715]                           invokeRestart("muffleWarning")
[11:01:37.715]                       }
[11:01:37.715]                       else if (inherits(cond, "condition")) {
[11:01:37.715]                         if (!is.null(pattern)) {
[11:01:37.715]                           computeRestarts <- base::computeRestarts
[11:01:37.715]                           grepl <- base::grepl
[11:01:37.715]                           restarts <- computeRestarts(cond)
[11:01:37.715]                           for (restart in restarts) {
[11:01:37.715]                             name <- restart$name
[11:01:37.715]                             if (is.null(name)) 
[11:01:37.715]                               next
[11:01:37.715]                             if (!grepl(pattern, name)) 
[11:01:37.715]                               next
[11:01:37.715]                             invokeRestart(restart)
[11:01:37.715]                             muffled <- TRUE
[11:01:37.715]                             break
[11:01:37.715]                           }
[11:01:37.715]                         }
[11:01:37.715]                       }
[11:01:37.715]                       invisible(muffled)
[11:01:37.715]                     }
[11:01:37.715]                     muffleCondition(cond, pattern = "^muffle")
[11:01:37.715]                   }
[11:01:37.715]                 }
[11:01:37.715]             }
[11:01:37.715]         }))
[11:01:37.715]     }, error = function(ex) {
[11:01:37.715]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:37.715]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:37.715]                 ...future.rng), started = ...future.startTime, 
[11:01:37.715]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:37.715]             version = "1.8"), class = "FutureResult")
[11:01:37.715]     }, finally = {
[11:01:37.715]         if (!identical(...future.workdir, getwd())) 
[11:01:37.715]             setwd(...future.workdir)
[11:01:37.715]         {
[11:01:37.715]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:37.715]                 ...future.oldOptions$nwarnings <- NULL
[11:01:37.715]             }
[11:01:37.715]             base::options(...future.oldOptions)
[11:01:37.715]             if (.Platform$OS.type == "windows") {
[11:01:37.715]                 old_names <- names(...future.oldEnvVars)
[11:01:37.715]                 envs <- base::Sys.getenv()
[11:01:37.715]                 names <- names(envs)
[11:01:37.715]                 common <- intersect(names, old_names)
[11:01:37.715]                 added <- setdiff(names, old_names)
[11:01:37.715]                 removed <- setdiff(old_names, names)
[11:01:37.715]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:37.715]                   envs[common]]
[11:01:37.715]                 NAMES <- toupper(changed)
[11:01:37.715]                 args <- list()
[11:01:37.715]                 for (kk in seq_along(NAMES)) {
[11:01:37.715]                   name <- changed[[kk]]
[11:01:37.715]                   NAME <- NAMES[[kk]]
[11:01:37.715]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.715]                     next
[11:01:37.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:37.715]                 }
[11:01:37.715]                 NAMES <- toupper(added)
[11:01:37.715]                 for (kk in seq_along(NAMES)) {
[11:01:37.715]                   name <- added[[kk]]
[11:01:37.715]                   NAME <- NAMES[[kk]]
[11:01:37.715]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.715]                     next
[11:01:37.715]                   args[[name]] <- ""
[11:01:37.715]                 }
[11:01:37.715]                 NAMES <- toupper(removed)
[11:01:37.715]                 for (kk in seq_along(NAMES)) {
[11:01:37.715]                   name <- removed[[kk]]
[11:01:37.715]                   NAME <- NAMES[[kk]]
[11:01:37.715]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:37.715]                     next
[11:01:37.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:37.715]                 }
[11:01:37.715]                 if (length(args) > 0) 
[11:01:37.715]                   base::do.call(base::Sys.setenv, args = args)
[11:01:37.715]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:37.715]             }
[11:01:37.715]             else {
[11:01:37.715]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:37.715]             }
[11:01:37.715]             {
[11:01:37.715]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:37.715]                   0L) {
[11:01:37.715]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:37.715]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:37.715]                   base::options(opts)
[11:01:37.715]                 }
[11:01:37.715]                 {
[11:01:37.715]                   {
[11:01:37.715]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:37.715]                     NULL
[11:01:37.715]                   }
[11:01:37.715]                   options(future.plan = NULL)
[11:01:37.715]                   if (is.na(NA_character_)) 
[11:01:37.715]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:37.715]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:37.715]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:37.715]                     .init = FALSE)
[11:01:37.715]                 }
[11:01:37.715]             }
[11:01:37.715]         }
[11:01:37.715]     })
[11:01:37.715]     if (TRUE) {
[11:01:37.715]         base::sink(type = "output", split = FALSE)
[11:01:37.715]         if (TRUE) {
[11:01:37.715]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:37.715]         }
[11:01:37.715]         else {
[11:01:37.715]             ...future.result["stdout"] <- base::list(NULL)
[11:01:37.715]         }
[11:01:37.715]         base::close(...future.stdout)
[11:01:37.715]         ...future.stdout <- NULL
[11:01:37.715]     }
[11:01:37.715]     ...future.result$conditions <- ...future.conditions
[11:01:37.715]     ...future.result$finished <- base::Sys.time()
[11:01:37.715]     ...future.result
[11:01:37.715] }
[11:01:37.718] Exporting 3 global objects (1.53 KiB) to cluster node #1 ...
[11:01:37.718] Exporting ‘outer_function’ (250 bytes) to cluster node #1 ...
[11:01:37.718] Exporting ‘outer_function’ (250 bytes) to cluster node #1 ... DONE
[11:01:37.718] Exporting ‘map’ (633 bytes) to cluster node #1 ...
[11:01:37.719] Exporting ‘map’ (633 bytes) to cluster node #1 ... DONE
[11:01:37.719] Exporting ‘inner_function’ (371 bytes) to cluster node #1 ...
[11:01:37.719] Exporting ‘inner_function’ (371 bytes) to cluster node #1 ... DONE
[11:01:37.719] Exporting 3 global objects (1.53 KiB) to cluster node #1 ... DONE
[11:01:37.720] MultisessionFuture started
[11:01:37.720] - Launch lazy future ... done
[11:01:37.720] run() for ‘MultisessionFuture’ ... done
[11:01:37.720] result() for ClusterFuture ...
[11:01:37.720] receiveMessageFromWorker() for ClusterFuture ...
[11:01:37.720] - Validating connection of MultisessionFuture
[11:01:37.762] - received message: FutureResult
[11:01:37.762] - Received FutureResult
[11:01:37.762] - Erased future from FutureRegistry
[11:01:37.762] result() for ClusterFuture ...
[11:01:37.763] - result already collected: FutureResult
[11:01:37.763] result() for ClusterFuture ... done
[11:01:37.763] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:37.763] result() for ClusterFuture ... done
[11:01:37.763] result() for ClusterFuture ...
[11:01:37.763] - result already collected: FutureResult
[11:01:37.763] result() for ClusterFuture ... done
List of 2
 $ : num [1:2] 2 3
 $ : num [1:2] 2 3
Testing with 2 cores ... DONE
> 
> message("*** Globals - formulas ... DONE")
*** Globals - formulas ... DONE
> 
> source("incl/end.R")
[11:01:37.765] plan(): Setting new future strategy stack:
[11:01:37.765] List of future strategies:
[11:01:37.765] 1. FutureStrategy:
[11:01:37.765]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:37.765]    - tweaked: FALSE
[11:01:37.765]    - call: future::plan(oplan)
[11:01:37.765] plan(): nbrOfWorkers() = 1
> 
